commit 52c310ce462d9b401d41304f459adcb9e5d5a1ae
Author: Simon Kaegi <skaegi>
Date:   Sat Oct 13 18:38:13 2007 +0000

    Bug 190923 [prov] Javascript in provisioning metadata has poor maintainability

55	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/InstructionParser.java
56	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ParameterizedProvisioningAction.java
30	5	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Phase.java
8	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Touchpoint.java
1	1	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Collect.java
45	4	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Install.java
1	1	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/SizingPhase.java
44	4	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Uninstall.java
5	5	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/EclipseInstallGeneratorInfoProvider.java
6	6	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
41	57	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
2	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
1	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/PhaseTest.java
437	182	bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
152	76	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/InstructionParser.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/InstructionParser.java
new file mode 100644
index 0000000..084c489
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/InstructionParser.java
@@ -0,0 +1,55 @@
+package org.eclipse.equinox.p2.engine;
+
+import java.util.*;
+
+public class InstructionParser {
+
+	Phase phase;
+	Touchpoint touchpoint;
+
+	public InstructionParser(Phase phase, Touchpoint touchpoint) {
+		this.phase = phase;
+		this.touchpoint = touchpoint;
+	}
+
+	public ProvisioningAction[] parseActions(String instruction) {
+		List actions = new ArrayList();
+		StringTokenizer tokenizer = new StringTokenizer(instruction, ";");
+		while (tokenizer.hasMoreTokens()) {
+			actions.add(parseAction(tokenizer.nextToken()));
+		}
+
+		return (ProvisioningAction[]) actions.toArray(new ProvisioningAction[actions.size()]);
+	}
+
+	private ProvisioningAction parseAction(String statement) {
+		int openBracket = statement.indexOf('(');
+		int closeBracket = statement.lastIndexOf(')');
+		String actionName = statement.substring(0, openBracket).trim();
+		ProvisioningAction action = lookupAction(actionName);
+
+		String nameValuePairs = statement.substring(openBracket + 1, closeBracket);
+		StringTokenizer tokenizer = new StringTokenizer(nameValuePairs, ",");
+		Map parameters = new HashMap();
+		while (tokenizer.hasMoreTokens()) {
+			String nameValuePair = tokenizer.nextToken();
+			int colonIndex = nameValuePair.indexOf(":");
+			String name = nameValuePair.substring(0, colonIndex).trim();
+			String value = nameValuePair.substring(colonIndex + 1).trim();
+			parameters.put(name, value);
+		}
+		return new ParameterizedProvisioningAction(action, parameters);
+	}
+
+	private ProvisioningAction lookupAction(String actionId) {
+
+		ProvisioningAction action = phase.getAction(actionId);
+		if (action == null)
+			action = touchpoint.getAction(actionId);
+
+		if (action == null)
+			throw new IllegalArgumentException("No action found for " + actionId + ".");
+
+		return action;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ParameterizedProvisioningAction.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ParameterizedProvisioningAction.java
new file mode 100644
index 0000000..ea9f625
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ParameterizedProvisioningAction.java
@@ -0,0 +1,56 @@
+package org.eclipse.equinox.p2.engine;
+
+import java.util.*;
+import java.util.Map.Entry;
+import org.eclipse.core.runtime.IStatus;
+
+public class ParameterizedProvisioningAction extends ProvisioningAction {
+
+	private ProvisioningAction action;
+	private Map actionParameters;
+
+	public ParameterizedProvisioningAction(ProvisioningAction action, Map actionParameters) {
+		if (action == null || actionParameters == null)
+			throw new IllegalArgumentException("Both action and action pararameters must not be null.");
+		this.action = action;
+		this.actionParameters = actionParameters;
+	}
+
+	public IStatus execute(Map parameters) {
+		parameters = processActionParameters(parameters);
+		return action.execute(parameters);
+	}
+
+	public IStatus undo(Map parameters) {
+		parameters = processActionParameters(parameters);
+		return action.undo(parameters);
+	}
+
+	private Map processActionParameters(Map parameters) {
+		Map result = new HashMap(parameters);
+		for (Iterator it = actionParameters.entrySet().iterator(); it.hasNext();) {
+			Entry entry = (Entry) it.next();
+			String name = (String) entry.getKey();
+			String value = processVariables((String) entry.getValue(), parameters);
+			result.put(name, value);
+		}
+		return Collections.unmodifiableMap(result);
+	}
+
+	private String processVariables(String parameterValue, Map parameters) {
+
+		int variableBeginIndex = parameterValue.indexOf("${");
+		if (variableBeginIndex == -1)
+			return parameterValue;
+
+		int variableEndIndex = parameterValue.indexOf("}", variableBeginIndex + 2);
+		if (variableEndIndex == -1)
+			return parameterValue;
+
+		String preVariable = parameterValue.substring(0, variableBeginIndex);
+		String variableName = parameterValue.substring(variableBeginIndex + 2, variableEndIndex);
+		String variableValue = (String) parameters.get(variableName);
+		String postVariable = processVariables(parameterValue.substring(variableEndIndex + 1), parameters);
+		return preVariable + variableValue + postVariable;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Phase.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Phase.java
index 450e17e..409144e 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Phase.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Phase.java
@@ -67,12 +67,16 @@ public abstract class Phase {
 		Map touchpointParameters = (Map) touchpointToTouchpointParameters.get(touchpoint);
 		Map parameters = new HashMap(touchpointParameters);
 		parameters.put("operand", operand);
+		status.add(initializeOperand(operand, parameters));
+		status.add(touchpoint.initializeOperand(operand, phaseId, parameters));
 		parameters = Collections.unmodifiableMap(parameters);
 		for (int j = 0; j < actions.length; j++) {
 			ProvisioningAction action = actions[j];
 			IStatus actionStatus = action.undo(parameters);
 			status.add(actionStatus);
 		}
+		status.add(touchpoint.completeOperand(operand, phaseId, parameters));
+		status.add(completeOperand(operand, parameters));
 	}
 
 	void perform(MultiStatus status, EngineSession session, Profile profile, Operand[] operands, IProgressMonitor monitor) {
@@ -137,20 +141,30 @@ public abstract class Phase {
 			if (touchpoint == null || !touchpoint.supports(phaseId))
 				continue;
 
+			ProvisioningAction[] actions;
+			try {
+				actions = getActions(touchpoint, operand);
+			} catch (Throwable t) {
+				status.add(new Status(IStatus.ERROR, phaseId, t.getMessage()));
+				return;
+			}
+
 			Map touchpointParameters = (Map) touchpointToTouchpointParameters.get(touchpoint);
 			Map parameters = new HashMap(touchpointParameters);
 			parameters.put("operand", operand);
+			status.add(initializeOperand(operand, parameters));
+			status.add(touchpoint.initializeOperand(operand, phaseId, parameters));
 			parameters = Collections.unmodifiableMap(parameters);
-			ProvisioningAction[] actions = getActions(touchpoint, profile, operand);
 			for (int j = 0; j < actions.length; j++) {
 				ProvisioningAction action = actions[j];
-				IStatus actionStatus = action.execute(parameters);
-				status.add(actionStatus);
-				if (actionStatus != null && !actionStatus.isOK())
+				status.add(action.execute(parameters));
+				if (!status.isOK())
 					return;
 
 				session.recordAction(action, operand);
 			}
+			status.add(touchpoint.completeOperand(operand, phaseId, parameters));
+			status.add(completeOperand(operand, parameters));
 		}
 	}
 
@@ -190,6 +204,17 @@ public abstract class Phase {
 		return Status.OK_STATUS;
 	}
 
-	protected abstract ProvisioningAction[] getActions(Touchpoint touchpoint, Profile profile, Operand currentOperand);
+	protected IStatus completeOperand(Operand operand, Map parameters) {
+		return Status.OK_STATUS;
+	}
+
+	protected IStatus initializeOperand(Operand operand, Map parameters) {
+		return Status.OK_STATUS;
+	}
+
+	public ProvisioningAction getAction(String actionId) {
+		return null;
+	}
 
+	protected abstract ProvisioningAction[] getActions(Touchpoint touchpoint, Operand currentOperand);
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Touchpoint.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Touchpoint.java
index 3112c48..7e81f3e 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Touchpoint.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Touchpoint.java
@@ -33,4 +33,12 @@ public abstract class Touchpoint {
 	public IStatus completePhase(IProgressMonitor monitor, Profile profile, String phaseId, Map touchpointParameters) {
 		return Status.OK_STATUS;
 	}
+
+	public IStatus initializeOperand(Operand operand, String phaseId, Map parameters) {
+		return Status.OK_STATUS;
+	}
+
+	public IStatus completeOperand(Operand operand, String phaseId, Map parameters) {
+		return Status.OK_STATUS;
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Collect.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Collect.java
index ea03abd..5448cbc 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Collect.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Collect.java
@@ -62,7 +62,7 @@ public class Collect extends Phase {
 		return false;
 	}
 
-	protected ProvisioningAction[] getActions(Touchpoint touchpoint, Profile profile, Operand currentOperand) {
+	protected ProvisioningAction[] getActions(Touchpoint touchpoint, Operand currentOperand) {
 		ProvisioningAction action = touchpoint.getAction("collect");
 		return new ProvisioningAction[] {action};
 	}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Install.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Install.java
index 58ca1aa..7849941 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Install.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Install.java
@@ -12,10 +12,12 @@ package org.eclipse.equinox.p2.engine.phases;
 
 import java.util.Map;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
 import org.eclipse.equinox.internal.p2.engine.EngineActivator;
 import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
 import org.eclipse.equinox.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.p2.engine.*;
+import org.eclipse.equinox.p2.metadata.*;
 
 public class Install extends Phase {
 
@@ -96,13 +98,52 @@ public class Install extends Phase {
 		return false;
 	}
 
-	protected ProvisioningAction[] getActions(Touchpoint touchpoint, Profile profile, Operand currentOperand) {
+	protected ProvisioningAction[] getActions(Touchpoint touchpoint, Operand currentOperand) {
 		//TODO: monitor.subTask(NLS.bind(Messages.Engine_Installing_IU, unit.getId()));
 
-		ProvisioningAction[] actions = new ProvisioningAction[3];
+		IInstallableUnit unit = currentOperand.second();
+		if (unit.isFragment())
+			return new ProvisioningAction[0];
+		TouchpointData[] data = unit.getTouchpointData();
+
+		if (data == null)
+			return new ProvisioningAction[0];
+		String[] instructions = getInstructionsFor("configurationData", data);
+		if (instructions.length == 0)
+			return new ProvisioningAction[0];
+		InstructionParser parser = new InstructionParser(this, touchpoint);
+		ProvisioningAction[] parsedActions = parser.parseActions(instructions[0]);
+		ProvisioningAction[] actions = new ProvisioningAction[parsedActions.length + 2];
 		actions[0] = new BeforeInstallEventAction();
-		actions[1] = touchpoint.getAction("install");
-		actions[2] = new AfterInstallEventAction();
+		System.arraycopy(parsedActions, 0, actions, 1, parsedActions.length);
+		actions[actions.length - 1] = new AfterInstallEventAction();
 		return actions;
 	}
+
+	// We could put this in a utility class or perhaps refactor touchpoint data
+	static private String[] getInstructionsFor(String key, TouchpointData[] data) {
+		String[] matches = new String[data.length];
+		int count = 0;
+		for (int i = 0; i < data.length; i++) {
+			matches[count] = data[i].getInstructions(key);
+			if (matches[count] != null)
+				count++;
+		}
+		if (count == data.length)
+			return matches;
+		String[] result = new String[count];
+		System.arraycopy(matches, 0, result, 0, count);
+		return result;
+	}
+
+	protected IStatus initializeOperand(Operand operand, Map parameters) {
+		IResolvedInstallableUnit iu = operand.second();
+		parameters.put("iu", iu);
+
+		IArtifactKey[] artifacts = iu.getArtifacts();
+		if (artifacts != null && artifacts.length > 0)
+			parameters.put("artifactId", artifacts[0].getId());
+
+		return Status.OK_STATUS;
+	}
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/SizingPhase.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/SizingPhase.java
index 099b84c..317957c 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/SizingPhase.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/SizingPhase.java
@@ -96,7 +96,7 @@ public class SizingPhase extends Phase {
 		return dlSize;
 	}
 
-	protected ProvisioningAction[] getActions(Touchpoint touchpoint, Profile profile, Operand currentOperand) {
+	protected ProvisioningAction[] getActions(Touchpoint touchpoint, Operand currentOperand) {
 		ProvisioningAction action = touchpoint.getAction("collect");
 		return new ProvisioningAction[] {action};
 	}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Uninstall.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Uninstall.java
index c5c05a9..836030b 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Uninstall.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/phases/Uninstall.java
@@ -12,10 +12,12 @@ package org.eclipse.equinox.p2.engine.phases;
 
 import java.util.Map;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
 import org.eclipse.equinox.internal.p2.engine.EngineActivator;
 import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
 import org.eclipse.equinox.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.p2.engine.*;
+import org.eclipse.equinox.p2.metadata.*;
 
 public class Uninstall extends Phase {
 
@@ -94,13 +96,51 @@ public class Uninstall extends Phase {
 		return false;
 	}
 
-	protected ProvisioningAction[] getActions(Touchpoint touchpoint, Profile profile, Operand currentOperand) {
+	protected ProvisioningAction[] getActions(Touchpoint touchpoint, Operand currentOperand) {
 		//TODO: monitor.subTask(NLS.bind(Messages.Engine_Uninstalling_IU, unit.getId()));
 
-		ProvisioningAction[] actions = new ProvisioningAction[3];
+		IInstallableUnit unit = currentOperand.first();
+		if (unit.isFragment())
+			return new ProvisioningAction[0];
+		TouchpointData[] data = unit.getTouchpointData();
+		if (data == null)
+			return new ProvisioningAction[0];
+		String[] instructions = getInstructionsFor("unconfigurationData", data);
+		if (instructions.length == 0)
+			return new ProvisioningAction[0];
+		InstructionParser parser = new InstructionParser(this, touchpoint);
+		ProvisioningAction[] parsedActions = parser.parseActions(instructions[0]);
+		ProvisioningAction[] actions = new ProvisioningAction[parsedActions.length + 2];
 		actions[0] = new BeforeUninstallEventAction();
-		actions[1] = touchpoint.getAction("uninstall");
-		actions[2] = new AfterUninstallEventAction();
+		System.arraycopy(parsedActions, 0, actions, 1, parsedActions.length);
+		actions[actions.length - 1] = new AfterUninstallEventAction();
 		return actions;
 	}
+
+	// We could put this in a utility class or perhaps refactor touchpoint data
+	static private String[] getInstructionsFor(String key, TouchpointData[] data) {
+		String[] matches = new String[data.length];
+		int count = 0;
+		for (int i = 0; i < data.length; i++) {
+			matches[count] = data[i].getInstructions(key);
+			if (matches[count] != null)
+				count++;
+		}
+		if (count == data.length)
+			return matches;
+		String[] result = new String[count];
+		System.arraycopy(matches, 0, result, 0, count);
+		return result;
+	}
+
+	protected IStatus initializeOperand(Operand operand, Map parameters) {
+		IResolvedInstallableUnit iu = operand.first();
+		parameters.put("iu", iu);
+
+		IArtifactKey[] artifacts = iu.getArtifacts();
+		if (artifacts != null && artifacts.length > 0)
+			parameters.put("artifactId", artifacts[0].getId());
+
+		return Status.OK_STATUS;
+	}
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/EclipseInstallGeneratorInfoProvider.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/EclipseInstallGeneratorInfoProvider.java
index ff74a5b..af331c8 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/EclipseInstallGeneratorInfoProvider.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/EclipseInstallGeneratorInfoProvider.java
@@ -151,7 +151,7 @@ public class EclipseInstallGeneratorInfoProvider implements IGeneratorInfo {
 		result.setSymbolicName("defaultConfigure");
 		result.setVersion("1.0.0");
 		result.setStartLevel(4);
-		result.setSpecialConfigCommands("manipulator.getConfigData().addBundle(bundleToInstall);");
+		result.setSpecialConfigCommands("installBundle(bundle:${artifactId});");
 		return result;
 	}
 
@@ -159,7 +159,7 @@ public class EclipseInstallGeneratorInfoProvider implements IGeneratorInfo {
 		GeneratorBundleInfo result = new GeneratorBundleInfo();
 		result.setSymbolicName("defaultUnconfigure");
 		result.setVersion("1.0.0");
-		result.setSpecialConfigCommands("manipulator.getConfigData().removeBundle(bundleToRemove);");
+		result.setSpecialConfigCommands("uninstallBundle(bundle:${artifactId});");
 		return result;
 	}
 
@@ -211,7 +211,7 @@ public class EclipseInstallGeneratorInfoProvider implements IGeneratorInfo {
 			GeneratorBundleInfo temp = new GeneratorBundleInfo();
 			temp.setSymbolicName(object.getId());
 			temp.setVersion(object.getVersion().toString());
-			temp.setSpecialConfigCommands("manipulator.getLauncherData().addProgramArg('--launcher.library');manipulator.getLauncherData().addProgramArg(artifact);");
+			temp.setSpecialConfigCommands("addProgramArg(programArg:--launcher.library);addProgramArg(programArg:@artifact);");
 			result.add(temp);
 		}
 		return result;
@@ -232,7 +232,7 @@ public class EclipseInstallGeneratorInfoProvider implements IGeneratorInfo {
 		result.setSymbolicName("org.eclipse.equinox.launcher");
 		result.setVersion("0.0.0");
 		//result.setSpecialConfigCommands("manipulator.addProgramArgument('-startup'); manipulator.addProgramArgument(artifact);");
-		result.setSpecialConfigCommands("manipulator.getLauncherData().addProgramArg('-startup');manipulator.getLauncherData().addProgramArg(artifact);");
+		result.setSpecialConfigCommands("addProgramArg(programArg:-startup);addProgramArg(programArg:@artifact);");
 		return result;
 	}
 
@@ -242,7 +242,7 @@ public class EclipseInstallGeneratorInfoProvider implements IGeneratorInfo {
 		result.setVersion("0.0.0");
 		result.setStartLevel(1);
 		result.setMarkedAsStarted(true);
-		result.setSpecialConfigCommands("manipulator.getLauncherData().addJvmArg('-Dorg.eclipse.equinox.simpleconfigurator.useReference=true');");
+		result.setSpecialConfigCommands("addJvmArg(jvmArg:-Dorg.eclipse.equinox.simpleconfigurator.useReference=true);");
 		return result;
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
index fcae8ed..80befdd 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
@@ -179,10 +179,10 @@ public class Generator {
 			if (bundle.getSymbolicName().equals(ORG_ECLIPSE_UPDATE_CONFIGURATOR)) {
 				bundle.setStartLevel(BundleInfo.NO_LEVEL);
 				bundle.setMarkedAsStarted(false);
-				bundle.setSpecialConfigCommands("manipulator.getLauncherData().addJvmArg('-Dorg.eclipse.update.reconcile=false');");
+				bundle.setSpecialConfigCommands("addJvmArg(jvmArg:-Dorg.eclipse.update.reconcile=false);");
 			}
 			if (bundle.getSymbolicName().equals(ORG_ECLIPSE_EQUINOX_SIMPLECONFIGURATOR)) {
-				bundle.setSpecialConfigCommands("manipulator.getLauncherData().addJvmArg('-Dorg.eclipse.equinox.simpleconfigurator.useReference=true');");
+				bundle.setSpecialConfigCommands("addJvmArg(jvmArg:-Dorg.eclipse.equinox.simpleconfigurator.useReference=true);");
 			}
 			IInstallableUnit cu = MetadataGeneratorHelper.createEclipseConfigurationUnit(bundle.getSymbolicName(), new Version(bundle.getVersion()), false, bundle, info.getFlavor());
 			if (cu != null)
@@ -265,14 +265,14 @@ public class Generator {
 				String key = ((String) aProperty.getKey());
 				if (key.equals("osgi.frameworkClassPath") || key.equals("osgi.framework") || key.equals("osgi.bundles") || key.equals("eof"))
 					continue;
-				configurationData += "manipulator.getConfigData().setFwDependentProp('" + key + "', '" + ((String) aProperty.getValue()) + "');";
+				configurationData += "setFwDependentProp(propName:" + key + ", propValue:" + ((String) aProperty.getValue()) + ");";
 			}
 			for (Iterator iterator = configData.getFwIndependentProps().entrySet().iterator(); iterator.hasNext();) {
 				Entry aProperty = (Entry) iterator.next();
 				String key = ((String) aProperty.getKey());
 				if (key.equals("osgi.frameworkClassPath") || key.equals("osgi.framework") || key.equals("osgi.bundles") || key.equals("eof"))
 					continue;
-				configurationData += "manipulator.getConfigData().setFwIndependentProp('" + key + "', '" + ((String) aProperty.getValue()) + "');";
+				configurationData += "setFwIndependentProp(propName:" + key + ", propValue:" + ((String) aProperty.getValue()) + ");";
 			}
 		}
 
@@ -280,14 +280,14 @@ public class Generator {
 		if (launcherData != null) {
 			final String[] jvmArgs = launcherData.getJvmArgs();
 			for (int i = 0; i < jvmArgs.length; i++)
-				configurationData += "manipulator.getLauncherData().addJvmArg('" + jvmArgs[i] + "');";
+				configurationData += "addJvmArg(jvmArg:" + jvmArgs[i] + ");";
 
 			final String[] programArgs = launcherData.getProgramArgs();
 			for (int i = 0; i < programArgs.length; i++) {
 				String programArg = programArgs[i];
 				if (programArg.equals("--launcher.library") || programArg.equals("-startup") || programArg.equals("-configuration"))
 					i++;
-				configurationData += "manipulator.getLauncherData().addProgramArg('" + programArg + "');";
+				configurationData += "addProgramArg(programArg:" + programArg + ");";
 			}
 		}
 		touchpointData.put("configurationData", configurationData);
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
index 1b88057..2b6c28c 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
@@ -59,11 +59,23 @@ public class MetadataGeneratorHelper {
 		iu.setSingleton(false);
 		iu.setId("a.jre"); //$NON-NLS-1$
 		iu.setTouchpointType(new TouchpointType(NATIVE_TOUCHPOINT, NATIVE_TOUCHPOINT_VERSION));
+
+		InstallableUnitFragment cu = new InstallableUnitFragment();
+		cu.setId("config." + iu.getId()); //$NON-NLS-1$
+		cu.setVersion(iu.getVersion());
+		cu.setHost(iu.getId(), new VersionRange(iu.getVersion(), true, versionMax, true));
+		cu.setTouchpointType(new TouchpointType(NATIVE_TOUCHPOINT, NATIVE_TOUCHPOINT_VERSION));
+		Map touchpointData = new HashMap();
+
 		if (jreLocation == null || !jreLocation.exists()) {
 			//set some reasonable defaults
 			iu.setVersion(DEFAULT_JRE_VERSION);
 			iu.setCapabilities(generateJRECapability(null));
 			resultantIUs.add(iu);
+
+			touchpointData.put("configurationData", "");
+			cu.setImmutableTouchpointData(new TouchpointData(touchpointData));
+			resultantIUs.add(cu);
 			return;
 		}
 		generateJREIUData(iu, jreLocation);
@@ -71,19 +83,10 @@ public class MetadataGeneratorHelper {
 		//Generate artifact for JRE
 		IArtifactKey key = new ArtifactKey(ECLIPSE_ARTIFACT_NAMESPACE, NATIVE_TOUCHPOINT, iu.getId(), iu.getVersion());
 		iu.setArtifacts(new IArtifactKey[] {key});
-		iu.setTouchpointType(new TouchpointType(NATIVE_TOUCHPOINT, new Version(1, 0, 0)));
 		resultantIUs.add(iu);
 
-		//Create the CU
-		InstallableUnitFragment cu = new InstallableUnitFragment();
-		cu.setId("config." + iu.getId()); //$NON-NLS-1$
-		cu.setVersion(iu.getVersion());
-		cu.setHost(iu.getId(), new VersionRange(iu.getVersion(), true, versionMax, true));
-
-		cu.setTouchpointType(new TouchpointType(NATIVE_TOUCHPOINT, NATIVE_TOUCHPOINT_VERSION));
-		Map touchpointData = new HashMap();
-		String configurationData = "Zip.unzip(artifact, currentDir, null);";
-		EnvironmentInfo info = (EnvironmentInfo) ServiceHelper.getService(Activator.getContext(), EnvironmentInfo.class.getName());
+		//Create config info for the CU
+		String configurationData = "unzip(source:@artifact, target:${installFolder});";
 		touchpointData.put("configurationData", configurationData);
 		cu.setImmutableTouchpointData(new TouchpointData(touchpointData));
 		resultantIUs.add(cu);
@@ -149,11 +152,11 @@ public class MetadataGeneratorHelper {
 
 		cu.setTouchpointType(new TouchpointType(NATIVE_TOUCHPOINT, NATIVE_TOUCHPOINT_VERSION));
 		Map touchpointData = new HashMap();
-		String configurationData = "Zip.unzip(artifact, currentDir, null);";
+		String configurationData = "unzip(source:@artifact, target:${installFolder});";
 		EnvironmentInfo info = (EnvironmentInfo) ServiceHelper.getService(Activator.getContext(), EnvironmentInfo.class.getName());
 		if (!info.getOS().equals(org.eclipse.osgi.service.environment.Constants.OS_WIN32))
 			// FIXME:  is this correct?  do all non-Windows platforms need execute permissions on the launcher?
-			configurationData += " Permissions.chmod(currentDir, \"" + launcher.getName() + "\", 755);";
+			configurationData += " chmod(targetDir:${installFolder}, targetFile:" + launcher.getName() + ", permissions:755);";
 		touchpointData.put("configurationData", configurationData);
 		cu.setImmutableTouchpointData(new TouchpointData(touchpointData));
 		resultantIUs.add(cu);
@@ -245,63 +248,44 @@ public class MetadataGeneratorHelper {
 	}
 
 	private static String createDefaultConfigScript(GeneratorBundleInfo configInfo) {
-		String configScript = "";//$NON-NLS-1$
-		if (configInfo != null) {
-			if (configInfo.getStartLevel() != BundleInfo.NO_LEVEL) {
-				configScript += "bundleToInstall.setStartLevel(" + configInfo.getStartLevel() + ");";
-			}
-			if (configInfo.isMarkedAsStarted()) {
-				configScript += "bundleToInstall.setMarkedAsStarted(true);";
-			}
-			if (configInfo.getSpecialConfigCommands() != null) {
-				configScript += configInfo.getSpecialConfigCommands();
-			}
-		}
-		return configScript;
+		return createConfigScript(configInfo, false);
 	}
 
 	private static String createDefaultUnconfigScript(GeneratorBundleInfo unconfigInfo) {
-		String unconfigScript = ""; //$NON-NLS-1$
-		if (unconfigInfo != null) {
-			if (unconfigInfo.getSpecialConfigCommands() != null) {
-				unconfigScript += unconfigInfo.getSpecialConfigCommands();
-			}
-		}
-		return unconfigScript;
+		return createUnconfigScript(unconfigInfo, false);
 	}
 
 	private static String createConfigScript(GeneratorBundleInfo configInfo, boolean isBundleFragment) {
-		String configScript = "manipulator.getConfigData().addBundle(bundleToInstall);";
-		if (configInfo != null) {
-			if (!isBundleFragment && configInfo.getStartLevel() != BundleInfo.NO_LEVEL) {
-				configScript += "bundleToInstall.setStartLevel(" + configInfo.getStartLevel() + ");";
-			}
-			if (!isBundleFragment && configInfo.isMarkedAsStarted()) {
-				configScript += "bundleToInstall.setMarkedAsStarted(true);";
-			}
-			if (configInfo.getSpecialConfigCommands() != null) {
-				configScript += configInfo.getSpecialConfigCommands();
-			}
+		if (configInfo == null)
+			return "";
+
+		String configScript = "installBundle(bundle:${artifactId}";//$NON-NLS-1$
+		if (!isBundleFragment && configInfo.getStartLevel() != BundleInfo.NO_LEVEL) {
+			configScript += ", startLevel:" + configInfo.getStartLevel();
+		}
+		if (!isBundleFragment && configInfo.isMarkedAsStarted()) {
+			configScript += ", markStarted: true";
+		}
+		configScript += ");";
+
+		if (configInfo.getSpecialConfigCommands() != null) {
+			configScript += configInfo.getSpecialConfigCommands();
 		}
+
 		return configScript;
 	}
 
-	private static String createUnconfigScript(GeneratorBundleInfo configInfo, boolean isBundleFragment) {
-		String unconfigScript = "";
-		if (configInfo != null) {
-			if (!isBundleFragment && configInfo.getStartLevel() != BundleInfo.NO_LEVEL) {
-				unconfigScript += "bundleToRemove.setStartLevel(" + BundleInfo.NO_LEVEL + ");";
-			}
-			if (!isBundleFragment && configInfo.isMarkedAsStarted()) {
-				unconfigScript += "bundleToRemove.setMarkedAsStarted(false);";
-			}
-			if (configInfo.getSpecialConfigCommands() != null) {
-				// TODO: how should special config commands be removed
-				// unconfigScript += "foobar.remove(" + configInfo.getSpecialConfigCommands() + ");";
+	private static String createUnconfigScript(GeneratorBundleInfo unconfigInfo, boolean isBundleFragment) {
+		if (unconfigInfo == null)
+			return "";
+		String unconfigScript = "uninstallBundle(bundle:${artifactId}";//$NON-NLS-1$
+		if (unconfigInfo != null) {
+			if (unconfigInfo.getSpecialConfigCommands() != null) {
+				unconfigScript += unconfigInfo.getSpecialConfigCommands();
 			}
 		}
-		unconfigScript += "manipulator.getConfigData().removeBundle(bundleToRemove);";
 		return unconfigScript;
+
 	}
 
 	private static boolean requireAFragment(BundleDescription bd, Map manifest) {
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
index 78a61b1..9606696 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
@@ -187,8 +187,8 @@ public class EngineTest extends TestCase {
 				+ " undleresource;x-internal:=true,org.eclipse.osgi.framework.internal.pr\r\n" + " otocol.reference;x-internal:=true,org.eclipse.osgi.framework.internal\r\n" + " .reliablefile;x-internal:=true,org.eclipse.osgi.framework.launcher;x-\r\n" + " internal:=true,org.eclipse.osgi.framework.util;x-internal:=true,org.e\r\n" + " clipse.osgi.internal.baseadaptor;x-internal:=true,org.eclipse.osgi.in\r\n" + " ternal.module;x-internal:=true,org.eclipse.osgi.internal.profile;x-in\r\n" + " ternal:=true,org.eclipse.osgi.internal.resolver;x-internal:=true,org.\r\n" + " eclipse.osgi.internal.verifier;x-internal:=true,org.eclipse.osgi.inte\r\n" + " rnal.provisional.verifier;x-friends:=\"org.eclipse.update.core,org.ecl\r\n" + " ipse.ui.workbench\"\r\n" + "Bundle-Version: 3.3.0.v20060925\r\n"
 				+ "Eclipse-SystemBundle: true\r\n" + "Bundle-Copyright: %copyright\r\n" + "Bundle-Name: %systemBundle\r\n" + "Bundle-Description: %systemBundle\r\n" + "Bundle-DocUrl: http://www.eclipse.org\r\n" + "Bundle-ManifestVersion: 2\r\n" + "Export-Service: org.osgi.service.packageadmin.PackageAdmin,org.osgi.se\r\n" + " rvice.permissionadmin.PermissionAdmin,org.osgi.service.startlevel.Sta\r\n" + " rtLevel,org.eclipse.osgi.service.debug.DebugOptions\r\n" + "Bundle-Vendor: %eclipse.org\r\n" + "Main-Class: org.eclipse.core.runtime.adaptor.EclipseStarter\r\n" + "Bundle-SymbolicName: org.eclipse.osgi; singleton:=true\r\n" + "Bundle-Localization: systembundle\r\n" + "Eclipse-ExtensibleAPI: true\r\n" + "\r\n" + "";
 		touchpointData.put("manifest", manifest);
-		touchpointData.put("configurationData", "manipulator.getConfigData().addBundle(bundleToInstall);bundleToInstall.setMarkedAsStarted(true);");
-		touchpointData.put("unconfigurationData", "bundleToRemove.setMarkedAsStarted(false);manipulator.getConfigData().removeBundle(bundleToRemove);");
+		touchpointData.put("configurationData", "installBundle(bundle:${artifactId}, started:true);");
+		touchpointData.put("unconfigurationData", "uninstallBundle(bundle:${artifactId});");
 
 		IResolvedInstallableUnit[] cus = new IResolvedInstallableUnit[1];
 		InstallableUnitFragment tmp = new InstallableUnitFragment();
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/PhaseTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/PhaseTest.java
index 42967fc..9f451d5 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/PhaseTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/PhaseTest.java
@@ -88,7 +88,7 @@ public class PhaseTest extends TestCase {
 			super(phaseId, weight, phaseName);
 		}
 
-		protected ProvisioningAction[] getActions(Touchpoint touchpoint, Profile profile, Operand currentOperand) {
+		protected ProvisioningAction[] getActions(Touchpoint touchpoint, Operand currentOperand) {
 			return null;
 		}
 
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java b/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
index f688089..73dbd51 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
@@ -21,7 +21,6 @@ import org.eclipse.equinox.p2.engine.*;
 import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.osgi.service.environment.EnvironmentInfo;
 import org.eclipse.osgi.util.ManifestElement;
-import org.mozilla.javascript.*;
 import org.osgi.framework.*;
 import org.osgi.util.tracker.ServiceTracker;
 
@@ -30,10 +29,10 @@ public class EclipseTouchpoint extends Touchpoint {
 	private final static String CONFIG_FOLDER = "eclipse.configurationFolder";
 	private final static String CACHE_PATH = "eclipse.p2.cache";
 
-	private final static String CONFIGURATION_DATA = "configurationData";
-	private final static String UNCONFIGURATION_DATA = "unconfigurationData";
+	//	private final static String CONFIGURATION_DATA = "configurationData";
+	//	private final static String UNCONFIGURATION_DATA = "unconfigurationData";
 
-	private static final boolean DEBUG = false;
+	//	private static final boolean DEBUG = false;
 	static int iuCount = 0;
 
 	private final static String FILTER_OBJECTCLASS = "(" + Constants.OBJECTCLASS + "=" + FrameworkAdmin.class.getName() + ")";
@@ -47,21 +46,40 @@ public class EclipseTouchpoint extends Touchpoint {
 
 	//	TODO Need to find a better way  keep track of this information, is it a generalized cache mechanism? 
 	// moreover there may scenarios where the configuration data is not stored in the same IU than the bundle referring to the artifact
-	private final Set supportedPhases = new HashSet(); //TODO This should probably come from XML
-
-	{
-		supportedPhases.add("collect");
-		supportedPhases.add("install");
-		supportedPhases.add("uninstall");
-	}
+	private final Set supportedPhases = new HashSet(Arrays.asList(new String[] {"collect", "install", "uninstall"})); //TODO This should probably come from XML
 
 	public ProvisioningAction getAction(String actionId) {
+		if (actionId.equals("installBundle")) {
+			return new ProvisioningAction() {
+				public IStatus execute(Map parameters) {
+					return installBundle(parameters);
+				}
+
+				public IStatus undo(Map parameters) {
+					return uninstallBundle(parameters);
+				}
+			};
+		}
+
+		if (actionId.equals("uninstallBundle")) {
+			return new ProvisioningAction() {
+				public IStatus execute(Map parameters) {
+					return uninstallBundle(parameters);
+				}
+
+				public IStatus undo(Map parameters) {
+					return installBundle(parameters);
+				}
+			};
+		}
+
 		if (actionId.equals("collect")) {
 			return new ProvisioningAction() {
 				public IStatus execute(Map parameters) {
 					Profile profile = (Profile) parameters.get("profile");
 					Operand operand = (Operand) parameters.get("operand");
 					IArtifactRequest[] requests = collect(operand.second(), profile);
+
 					Collection artifactRequests = (Collection) parameters.get("artifactRequests");
 					artifactRequests.add(requests);
 					return Status.OK_STATUS;
@@ -73,60 +91,159 @@ public class EclipseTouchpoint extends Touchpoint {
 				}
 			};
 		}
-		if (actionId.equals("install")) {
+
+		if (actionId.equals("addProgramArg")) {
 			return new ProvisioningAction() {
 				public IStatus execute(Map parameters) {
-					Profile profile = (Profile) parameters.get("profile");
-					Operand operand = (Operand) parameters.get("operand");
-					return configure(operand.second(), profile, true, parameters);
+					Manipulator manipulator = (Manipulator) parameters.get("manipulator");
+					String programArg = (String) parameters.get("programArg");
+
+					if (programArg.equals("@artifact")) {
+						Profile profile = (Profile) parameters.get("profile");
+						IInstallableUnit iu = (IInstallableUnit) parameters.get("iu");
+						IArtifactKey artifactKey = iu.getArtifacts()[0];
+
+						File fileLocation = null;
+						try {
+							fileLocation = getBundleFile(artifactKey, isZipped(iu.getTouchpointData()), profile);
+						} catch (IOException e) {
+							// TODO Auto-generated catch block
+							e.printStackTrace();
+						}
+						if (!fileLocation.exists())
+							return new Status(IStatus.ERROR, ID, "The file is not available" + fileLocation.getAbsolutePath());
+						programArg = fileLocation.getAbsolutePath();
+					}
+
+					manipulator.getLauncherData().addProgramArg(programArg);
+					return Status.OK_STATUS;
 				}
 
 				public IStatus undo(Map parameters) {
-					Profile profile = (Profile) parameters.get("profile");
-					Operand operand = (Operand) parameters.get("operand");
-					return configure(operand.second(), profile, false, parameters);
+					Manipulator manipulator = (Manipulator) parameters.get("manipulator");
+					String programArg = (String) parameters.get("programArg");
+					manipulator.getLauncherData().removeProgramArg(programArg);
+					return Status.OK_STATUS;
 				}
 			};
 		}
-		if (actionId.equals("uninstall")) {
+
+		if (actionId.equals("setFwDependentProp")) {
 			return new ProvisioningAction() {
 				public IStatus execute(Map parameters) {
-					Profile profile = (Profile) parameters.get("profile");
-					Operand operand = (Operand) parameters.get("operand");
-					return configure(operand.first(), profile, false, parameters);
+					Manipulator manipulator = (Manipulator) parameters.get("manipulator");
+					String propName = (String) parameters.get("propName");
+					String propValue = (String) parameters.get("propValue");
+					manipulator.getConfigData().setFwDependentProp(propName, propValue);
+					return Status.OK_STATUS;
 				}
 
 				public IStatus undo(Map parameters) {
-					Profile profile = (Profile) parameters.get("profile");
-					Operand operand = (Operand) parameters.get("operand");
-					return configure(operand.first(), profile, true, parameters);
+					Manipulator manipulator = (Manipulator) parameters.get("manipulator");
+					String propName = (String) parameters.get("propName");
+					manipulator.getConfigData().setFwDependentProp(propName, null); // save data?
+					return Status.OK_STATUS;
 				}
 			};
 		}
+
+		if (actionId.equals("setFwIndependentProp")) {
+			return new ProvisioningAction() {
+				public IStatus execute(Map parameters) {
+					Manipulator manipulator = (Manipulator) parameters.get("manipulator");
+					String propName = (String) parameters.get("propName");
+					String propValue = (String) parameters.get("propValue");
+					manipulator.getConfigData().setFwIndependentProp(propName, propValue);
+					return Status.OK_STATUS;
+				}
+
+				public IStatus undo(Map parameters) {
+					Manipulator manipulator = (Manipulator) parameters.get("manipulator");
+					String propName = (String) parameters.get("propName");
+					manipulator.getConfigData().setFwIndependentProp(propName, null); // save data?
+					return Status.OK_STATUS;
+				}
+			};
+		}
+
+		if (actionId.equals("addJvmArg")) {
+			return new ProvisioningAction() {
+				public IStatus execute(Map parameters) {
+					Manipulator manipulator = (Manipulator) parameters.get("manipulator");
+					String jvmArg = (String) parameters.get("jvmArg");
+					manipulator.getLauncherData().addJvmArg(jvmArg);
+					return Status.OK_STATUS;
+				}
+
+				public IStatus undo(Map parameters) {
+					Manipulator manipulator = (Manipulator) parameters.get("manipulator");
+					String jvmArg = (String) parameters.get("jvmArg");
+					manipulator.getLauncherData().removeJvmArg(jvmArg);
+					return Status.OK_STATUS;
+				}
+			};
+		}
+
+		//		if (actionId.equals("OLDinstall")) {
+		//			return new ProvisioningAction() {
+		//				public IStatus execute(Map parameters) {
+		//					Profile profile = (Profile) parameters.get("profile");
+		//					Operand operand = (Operand) parameters.get("operand");
+		//					return configure(operand.second(), profile, true, parameters);
+		//				}
+		//
+		//				public IStatus undo(Map parameters) {
+		//					Profile profile = (Profile) parameters.get("profile");
+		//					Operand operand = (Operand) parameters.get("operand");
+		//					return configure(operand.second(), profile, false, parameters);
+		//				}
+		//			};
+		//		}
+
 		return null;
 	}
 
-	private URL getBundlePoolLocation(Profile profile) {
-		String path = profile.getValue(CACHE_PATH);
-		if (path == null)
-			path = Activator.getContext().getProperty(CACHE_PATH);
-		if (path != null)
-			try {
-				// TODO this is a hack for now.
-				return File.separatorChar == '/' ? new URL("file:" + path) : new URL("file:/" + path);
-			} catch (MalformedURLException e) {
-				// TODO Do nothing and use the default approach
+	protected IStatus uninstallBundle(Map parameters) {
+		Profile profile = (Profile) parameters.get("profile");
+		IInstallableUnit iu = (IInstallableUnit) parameters.get("iu");
+		Manipulator manipulator = (Manipulator) parameters.get("manipulator");
+		String bundleId = (String) parameters.get("bundle");
+
+		//TODO: eventually remove this. What is a fragment doing here??
+		if (iu.isFragment()) {
+			System.out.println("What is a fragment doing here!!! -- " + iu);
+			return Status.OK_STATUS;
+		}
+
+		IArtifactKey[] artifacts = iu.getArtifacts();
+		IArtifactKey artifactKey = null;
+		for (int i = 0; i < artifacts.length; i++) {
+			if (artifacts[i].getId().equals(bundleId)) {
+				artifactKey = artifacts[i];
+				break;
 			}
-		AgentLocation location = getAgentLocation();
-		if (location == null)
-			return null;
-		URL result = location.getTouchpointDataArea("org.eclipse.equinox.p2.touchpoint.eclipse/");
+		}
+		if (artifactKey == null)
+			throw new IllegalArgumentException("No artifact found that matches: " + bundleId);
+
+		boolean isZipped = isZipped(iu.getTouchpointData());
+		File bundleFile;
 		try {
-			return new URL(result, "bundlepool");
-		} catch (MalformedURLException e) {
-			// TODO Auto-generated catch block
-			return null;
+			bundleFile = getBundleFile(artifactKey, isZipped, profile);
+			if (bundleFile == null)
+				return new Status(IStatus.ERROR, ID, "The artifact " + artifactKey.toString() + " to uninstall was not found.");
+
+		} catch (IOException e) {
+			return new Status(IStatus.ERROR, ID, e.getMessage());
 		}
+
+		// TODO: do we really need the manifest here or just the bsn and version?
+		String manifest = getManifest(iu.getTouchpointData());
+
+		BundleInfo bundleInfo = createBundleInfo(bundleFile, manifest);
+		manipulator.getConfigData().removeBundle(bundleInfo);
+
+		return Status.OK_STATUS;
 	}
 
 	private static AgentLocation getAgentLocation() {
@@ -141,16 +258,16 @@ public class EclipseTouchpoint extends Touchpoint {
 			return IArtifactRepositoryManager.NO_ARTIFACT_REQUEST;
 		IArtifactRequest[] requests = new IArtifactRequest[toDownload.length];
 
-		URL poolLocation = getBundlePoolLocation(profile);
-		if (isCompletelyInRepo(getBundlePoolRepo(poolLocation), toDownload))
+		IFileArtifactRepository bundlePool = getBundlePoolRepo(profile);
+		if (isCompletelyInRepo(bundlePool, toDownload))
 			return IArtifactRepositoryManager.NO_ARTIFACT_REQUEST;
 
 		//If the installable unit has installation information, then the artifact is put in the download cache
 		//otherwise it is a jar'ed bundle and we directly store it in the plugin cache
-		if (installableUnit.getTouchpointData().length > 0 && isZipped(installableUnit.getTouchpointData())) {
+		if (isZipped(installableUnit.getTouchpointData())) {
 			targetRepo = getDownloadCacheRepo();
 		} else {
-			targetRepo = getBundlePoolRepo(poolLocation);
+			targetRepo = bundlePool;
 		}
 		int count = 0;
 		for (int i = 0; i < toDownload.length; i++) {
@@ -220,102 +337,208 @@ public class EclipseTouchpoint extends Touchpoint {
 		return false;
 	}
 
-	private IStatus configure(IInstallableUnit unit, Profile profile, boolean isInstall, Map parameters) {
-		if (unit.isFragment())
-			return Status.OK_STATUS;
-
-		// Construct and initialize the java script context
-		Context cx = Context.enter();
-		Scriptable scope = cx.initStandardObjects();
+	private IStatus installBundle(Map parameters) {
 
+		Profile profile = (Profile) parameters.get("profile");
+		IInstallableUnit iu = (IInstallableUnit) parameters.get("iu");
 		Manipulator manipulator = (Manipulator) parameters.get("manipulator");
-		// wrap the manipulator for the configuration in the profile
-		Object wrappedOut = Context.javaToJS(manipulator, scope);
-		ScriptableObject.putProperty(scope, "manipulator", wrappedOut);
-
-		// Get the touchpoint data from the installable unit
-		TouchpointData[] touchpointData = unit.getTouchpointData();
-
-		if (touchpointData.length > 0 && unit.getArtifacts() != null && unit.getArtifacts().length > 0) {
-			boolean zippedPlugin = isZipped(touchpointData);
-			boolean alreadyInCache = false;
-
-			//Always try to check in the cache first
-			IArtifactRepository baseRepo = getBundlePoolRepo(getBundlePoolLocation(profile));
-			IFileArtifactRepository repoToCheck = (IFileArtifactRepository) baseRepo.getAdapter(IFileArtifactRepository.class);
-			IArtifactKey artifactKey = unit.getArtifacts()[0];
-			File fileLocation = repoToCheck.getArtifactFile(artifactKey);
-			if (fileLocation != null) {
-				alreadyInCache = true;
-			} else if (zippedPlugin) {
-				baseRepo = getDownloadCacheRepo();
-				repoToCheck = (IFileArtifactRepository) baseRepo.getAdapter(IFileArtifactRepository.class);
-				fileLocation = repoToCheck.getArtifactFile(artifactKey);
-			}
+		String bundleId = (String) parameters.get("bundle");
+		String startLevel = (String) parameters.get("startLevel");
+		String started = (String) parameters.get("markStarted");
+
+		//TODO: eventually remove this. What is a fragment doing here??
+		if (iu.isFragment()) {
+			System.out.println("What is a fragment doing here!!! -- " + iu);
+			return Status.OK_STATUS;
+		}
 
-			// TODO: Needs fixing - See Bug 204161 
-			if (fileLocation != null) {
-				if (!fileLocation.exists())
-					return new Status(IStatus.ERROR, ID, "The file is not available" + fileLocation.getAbsolutePath());
-			} else if (isInstall) {
-				return new Status(IStatus.ERROR, ID, "The artifact " + artifactKey.toString() + " to install has not been found.");
+		IArtifactKey[] artifacts = iu.getArtifacts();
+		IArtifactKey artifactKey = null;
+		for (int i = 0; i < artifacts.length; i++) {
+			if (artifacts[i].getId().equals(bundleId)) {
+				artifactKey = artifacts[i];
+				break;
 			}
+		}
+		if (artifactKey == null)
+			throw new IllegalArgumentException("No artifact found that matches: " + bundleId);
 
-			// TODO: Here we unzip the plug-in.This is ugly. We need to deal with addition into the plug-in cache
-			// TODO: Will we ever need to unzip in order to remove a bundle?
-			if (!alreadyInCache && zippedPlugin) {
-				if (isInstall) {
-					File extractionFolder = new File(getBundlePoolLocation(profile).getFile(), "/plugins/" + artifactKey.getId() + '_' + artifactKey.getVersion());
-					if (!extractionFolder.exists()) {
-						if (!extractionFolder.mkdir())
-							return new Status(IStatus.ERROR, ID, "can't create the folder: " + extractionFolder);
-						try {
-							FileUtils.unzipFile(fileLocation, extractionFolder.getParentFile());
-						} catch (IOException e) {
-							return new Status(IStatus.ERROR, ID, "can't extract " + fileLocation + " into the folder " + extractionFolder);
-						}
-					}
-					fileLocation = extractionFolder;
-				} else {
-					fileLocation = new File(new File(getBundlePoolLocation(profile).getFile()), "/plugins/" + artifactKey.getId() + '_' + artifactKey.getVersion());
-				}
-				//check if the target folder exists
+		boolean isZipped = isZipped(iu.getTouchpointData());
+		File bundleFile;
+		try {
+			bundleFile = getBundleFile(artifactKey, isZipped, profile);
+			if (bundleFile == null)
+				return new Status(IStatus.ERROR, ID, "The artifact " + artifactKey.toString() + " to install was not found.");
 
-				//if it does then stop
-				//if it does not create the folder and extract the archive... Be careful here with the permissions.... We may need to have a proper unzip technology here that supports file permissions for linux
-				//				request.getProfile().getValue(CACHE_PATH);
-			}
+		} catch (IOException e) {
+			return new Status(IStatus.ERROR, ID, e.getMessage());
+		}
 
-			// TODO: We need to separate install and uninstall actions
-			if (!isInstall && fileLocation == null)
-				return new Status(IStatus.ERROR, ID, "The artifact " + artifactKey.toString() + " to uninstall has not been found.");
+		// TODO: do we really need the manifest here or just the bsn and version?
+		String manifest = getManifest(iu.getTouchpointData());
 
-			ScriptableObject.putProperty(scope, "artifact", fileLocation.getAbsolutePath());
-			BundleInfo bundle = new BundleInfo();
-			try {
-				bundle.setLocation(fileLocation.toURL().toExternalForm());
-			} catch (MalformedURLException e) {
-				// Ignore;
-				e.printStackTrace();
-			}
-			String[] manifestData = getInstructionsFor("manifest", touchpointData); //TODO Here we only take one set of manifest data
-			this.initFromManifest(manifestData[0], bundle);
-			ScriptableObject.putProperty(scope, (isInstall ? "bundleToInstall" : "bundleToRemove"), bundle);
+		BundleInfo bundleInfo = createBundleInfo(bundleFile, manifest);
+
+		if (startLevel != null)
+			bundleInfo.setStartLevel(Integer.parseInt(startLevel));
+
+		if (started != null)
+			bundleInfo.setMarkedAsStarted(Boolean.valueOf(started).booleanValue());
+		manipulator.getConfigData().addBundle(bundleInfo);
+
+		return Status.OK_STATUS;
+	}
+
+	private BundleInfo createBundleInfo(File bundleFile, String manifest) {
+		BundleInfo bundleInfo = new BundleInfo();
+		try {
+			bundleInfo.setLocation(bundleFile.toURL().toExternalForm());
+		} catch (MalformedURLException e) {
+			e.printStackTrace();
 		}
 
-		String[] instructions = getInstructionsFor((isInstall ? CONFIGURATION_DATA : UNCONFIGURATION_DATA), touchpointData);
-		for (int i = 0; i < instructions.length; i++) {
-			logConfiguation(unit, instructions[i], isInstall);
-			try {
-				cx.evaluateString(scope, instructions[i], unit.getId(), 1, null);
-				//TODO Need to get the result of the operations
-			} catch (RuntimeException ex) {
-				return new Status(IStatus.ERROR, Activator.ID, "Exception while executing " + instructions[i], ex);
-			}
+		bundleInfo.setManifest(manifest);
+		try {
+			Headers headers = Headers.parseManifest(new ByteArrayInputStream(manifest.getBytes()));
+			ManifestElement[] element = ManifestElement.parseHeader("bsn", (String) headers.get(Constants.BUNDLE_SYMBOLICNAME));
+			bundleInfo.setSymbolicName(element[0].getValue());
+			bundleInfo.setVersion((String) headers.get(Constants.BUNDLE_VERSION));
+		} catch (BundleException e) {
+			e.printStackTrace();
 		}
-		return Status.OK_STATUS;
+		return bundleInfo;
 	}
 
+	private String getManifest(TouchpointData[] data) {
+		for (int i = 0; i < data.length; i++) {
+			String manifest = data[i].getInstructions("manifest");
+			if (manifest != null)
+				return manifest;
+		}
+		return null;
+	}
+
+	private File getBundleFile(IArtifactKey artifactKey, boolean isZipped, Profile profile) throws IOException {
+
+		if (!isZipped) {
+			IFileArtifactRepository bundlePool = getBundlePoolRepo(profile);
+			File bundleJar = bundlePool.getArtifactFile(artifactKey);
+			return bundleJar;
+		}
+
+		// Handle zipped
+		IFileArtifactRepository downloadCache = getDownloadCacheRepo();
+		File bundleJar = downloadCache.getArtifactFile(artifactKey);
+		if (bundleJar == null)
+			return null;
+
+		File bundleFolder = new File(getBundlePoolLocation(profile).getFile(), "/plugins/" + artifactKey.getId() + '_' + artifactKey.getVersion());
+		if (bundleFolder.exists())
+			return bundleFolder;
+
+		if (!bundleFolder.mkdir())
+			throw new IOException("Can't create the folder: " + bundleFolder);
+
+		FileUtils.unzipFile(bundleJar, bundleFolder.getParentFile());
+		return bundleFolder;
+	}
+
+	//	private IStatus configure(IInstallableUnit unit, Profile profile, boolean isInstall, Map parameters) {
+	//		if (unit.isFragment())
+	//			return Status.OK_STATUS;
+	//
+	//		// Construct and initialize the java script context
+	//		Context cx = Context.enter();
+	//		Scriptable scope = cx.initStandardObjects();
+	//
+	//		Manipulator manipulator = (Manipulator) parameters.get("manipulator");
+	//		// wrap the manipulator for the configuration in the profile
+	//		Object wrappedOut = Context.javaToJS(manipulator, scope);
+	//		ScriptableObject.putProperty(scope, "manipulator", wrappedOut);
+	//
+	//		// Get the touchpoint data from the installable unit
+	//		TouchpointData[] touchpointData = unit.getTouchpointData();
+	//
+	//		if (touchpointData.length > 0 && unit.getArtifacts() != null && unit.getArtifacts().length > 0) {
+	//			boolean zippedPlugin = isZipped(touchpointData);
+	//			boolean alreadyInCache = false;
+	//
+	//			//Always try to check in the cache first
+	//			IArtifactRepository baseRepo = getBundlePoolRepo(profile);
+	//			IFileArtifactRepository repoToCheck = (IFileArtifactRepository) baseRepo.getAdapter(IFileArtifactRepository.class);
+	//			IArtifactKey artifactKey = unit.getArtifacts()[0];
+	//			File fileLocation = repoToCheck.getArtifactFile(artifactKey);
+	//			if (fileLocation != null) {
+	//				alreadyInCache = true;
+	//			} else if (zippedPlugin) {
+	//				baseRepo = getDownloadCacheRepo();
+	//				repoToCheck = (IFileArtifactRepository) baseRepo.getAdapter(IFileArtifactRepository.class);
+	//				fileLocation = repoToCheck.getArtifactFile(artifactKey);
+	//			}
+	//
+	//			// TODO: Needs fixing - See Bug 204161 
+	//			if (fileLocation != null) {
+	//				if (!fileLocation.exists())
+	//					return new Status(IStatus.ERROR, ID, "The file is not available" + fileLocation.getAbsolutePath());
+	//			} else if (isInstall) {
+	//				return new Status(IStatus.ERROR, ID, "The artifact " + artifactKey.toString() + " to install has not been found.");
+	//			}
+	//
+	//			// TODO: Here we unzip the plug-in.This is ugly. We need to deal with addition into the plug-in cache
+	//			// TODO: Will we ever need to unzip in order to remove a bundle?
+	//			if (!alreadyInCache && zippedPlugin) {
+	//				if (isInstall) {
+	//					File extractionFolder = new File(getBundlePoolLocation(profile).getFile(), "/plugins/" + artifactKey.getId() + '_' + artifactKey.getVersion());
+	//					if (!extractionFolder.exists()) {
+	//						if (!extractionFolder.mkdir())
+	//							return new Status(IStatus.ERROR, ID, "can't create the folder: " + extractionFolder);
+	//						try {
+	//							FileUtils.unzipFile(fileLocation, extractionFolder.getParentFile());
+	//						} catch (IOException e) {
+	//							return new Status(IStatus.ERROR, ID, "can't extract " + fileLocation + " into the folder " + extractionFolder);
+	//						}
+	//					}
+	//					fileLocation = extractionFolder;
+	//				} else {
+	//					fileLocation = new File(new File(getBundlePoolLocation(profile).getFile()), "/plugins/" + artifactKey.getId() + '_' + artifactKey.getVersion());
+	//				}
+	//				//check if the target folder exists
+	//
+	//				//if it does then stop
+	//				//if it does not create the folder and extract the archive... Be careful here with the permissions.... We may need to have a proper unzip technology here that supports file permissions for linux
+	//				//				request.getProfile().getValue(CACHE_PATH);
+	//			}
+	//
+	//			// TODO: We need to separate install and uninstall actions
+	//			if (!isInstall && fileLocation == null)
+	//				return new Status(IStatus.ERROR, ID, "The artifact " + artifactKey.toString() + " to uninstall has not been found.");
+	//
+	//			ScriptableObject.putProperty(scope, "artifact", fileLocation.getAbsolutePath());
+	//			BundleInfo bundle = new BundleInfo();
+	//			try {
+	//				bundle.setLocation(fileLocation.toURL().toExternalForm());
+	//			} catch (MalformedURLException e) {
+	//				// Ignore;
+	//				e.printStackTrace();
+	//			}
+	//			String[] manifestData = getInstructionsFor("manifest", touchpointData); //TODO Here we only take one set of manifest data
+	//			this.initFromManifest(manifestData[0], bundle);
+	//			ScriptableObject.putProperty(scope, (isInstall ? "bundleToInstall" : "bundleToRemove"), bundle);
+	//		}
+	//
+	//		String[] instructions = getInstructionsFor((isInstall ? CONFIGURATION_DATA : UNCONFIGURATION_DATA), touchpointData);
+	//		for (int i = 0; i < instructions.length; i++) {
+	//			logConfiguation(unit, instructions[i], isInstall);
+	//			try {
+	//				cx.evaluateString(scope, instructions[i], unit.getId(), 1, null);
+	//				//TODO Need to get the result of the operations
+	//			} catch (RuntimeException ex) {
+	//				return new Status(IStatus.ERROR, Activator.ID, "Exception while executing " + instructions[i], ex);
+	//			}
+	//		}
+	//		return Status.OK_STATUS;
+	//	}
+
 	/**
 	 * Returns the agent location, if possible as a path relative to the configuration
 	 * directory using the @config.dir substitution variable. AgentLocation will
@@ -366,20 +589,20 @@ public class EclipseTouchpoint extends Touchpoint {
 		return (FrameworkAdmin) fwAdminTracker.getService();
 	}
 
-	private String[] getInstructionsFor(String key, TouchpointData[] data) {
-		String[] matches = new String[data.length];
-		int count = 0;
-		for (int i = 0; i < data.length; i++) {
-			matches[count] = data[i].getInstructions(key);
-			if (matches[count] != null)
-				count++;
-		}
-		if (count == data.length)
-			return matches;
-		String[] result = new String[count];
-		System.arraycopy(matches, 0, result, 0, count);
-		return result;
-	}
+	//	private String[] getInstructionsFor(String key, TouchpointData[] data) {
+	//		String[] matches = new String[data.length];
+	//		int count = 0;
+	//		for (int i = 0; i < data.length; i++) {
+	//			matches[count] = data[i].getInstructions(key);
+	//			if (matches[count] != null)
+	//				count++;
+	//		}
+	//		if (count == data.length)
+	//			return matches;
+	//		String[] result = new String[count];
+	//		System.arraycopy(matches, 0, result, 0, count);
+	//		return result;
+	//	}
 
 	public TouchpointType getTouchpointType() {
 		return new TouchpointType("eclipse", new Version("1.0")); //TODO this data probably needs to come from the XML
@@ -415,39 +638,71 @@ public class EclipseTouchpoint extends Touchpoint {
 		return "eclipse"; //$NON-NLS-1$
 	}
 
-	private IArtifactRepository getBundlePoolRepo(URL location) {
+	static private IFileArtifactRepository getBundlePoolRepo(Profile profile) {
+		URL location = getBundlePoolLocation(profile);
 		IArtifactRepositoryManager manager = getArtifactRepositoryManager();
 		IArtifactRepository repository = manager.loadRepository(location, null);
-		if (repository != null) {
-			if (!repository.isModifiable())
-				throw new IllegalArgumentException("BundlePool repository not writeable: " + location); //$NON-NLS-1$
-			return repository;
-		}
-		// 	the given repo location is not an existing repo so we have to create something
-		// TODO for now create a random repo by default.
-		String repositoryName = location + " - bundle pool"; //$NON-NLS-1$
-		IArtifactRepository result = manager.createRepository(location, repositoryName, "org.eclipse.equinox.p2.artifact.repository.simpleRepository");
-		return tagAsImplementation(result);
+		if (repository == null) {
+			// 	the given repo location is not an existing repo so we have to create something
+			// TODO for now create a random repo by default.
+			String repositoryName = location + " - bundle pool"; //$NON-NLS-1$
+			repository = manager.createRepository(location, repositoryName, "org.eclipse.equinox.p2.artifact.repository.simpleRepository");
+			// TODO: do we still need to do this
+			tagAsImplementation(repository);
+		}
+
+		IFileArtifactRepository bundlePool = (IFileArtifactRepository) repository.getAdapter(IFileArtifactRepository.class);
+		if (bundlePool == null) {
+			throw new IllegalArgumentException("BundlePool repository not writeable: " + location); //$NON-NLS-1$
+		}
+		return bundlePool;
+	}
+
+	static private URL getBundlePoolLocation(Profile profile) {
+		String path = profile.getValue(CACHE_PATH);
+		if (path == null)
+			path = Activator.getContext().getProperty(CACHE_PATH);
+		if (path != null)
+			try {
+				// TODO this is a hack for now.
+				return File.separatorChar == '/' ? new URL("file:" + path) : new URL("file:/" + path);
+			} catch (MalformedURLException e) {
+				// TODO Do nothing and use the default approach
+			}
+		AgentLocation location = getAgentLocation();
+		if (location == null)
+			return null;
+		URL result = location.getTouchpointDataArea("org.eclipse.equinox.p2.touchpoint.eclipse/");
+		try {
+			return new URL(result, "bundlepool");
+		} catch (MalformedURLException e) {
+			// TODO Auto-generated catch block
+			return null;
+		}
 	}
 
-	private IArtifactRepositoryManager getArtifactRepositoryManager() {
+	static private IArtifactRepositoryManager getArtifactRepositoryManager() {
 		return (IArtifactRepositoryManager) ServiceHelper.getService(Activator.getContext(), IArtifactRepositoryManager.class.getName());
 	}
 
-	private IArtifactRepository getDownloadCacheRepo() {
-		IArtifactRepositoryManager manager = getArtifactRepositoryManager();
+	static private IFileArtifactRepository getDownloadCacheRepo() {
 		URL location = getDownloadCacheLocation();
+		IArtifactRepositoryManager manager = getArtifactRepositoryManager();
 		IArtifactRepository repository = manager.loadRepository(location, null);
-		if (repository != null) {
-			if (!repository.isModifiable())
-				throw new IllegalArgumentException("Agent download cache not writeable: " + location); //$NON-NLS-1$
-			return repository;
-		}
-		// 	the given repo location is not an existing repo so we have to create something
-		// TODO for now create a random repo by default.
-		String repositoryName = location + " - Agent download cache"; //$NON-NLS-1$
-		IArtifactRepository result = manager.createRepository(location, repositoryName, "org.eclipse.equinox.p2.artifact.repository.simpleRepository");
-		return tagAsImplementation(result);
+		if (repository == null) {
+			// 	the given repo location is not an existing repo so we have to create something
+			// TODO for now create a random repo by default.
+			String repositoryName = location + " - Agent download cache"; //$NON-NLS-1$
+			repository = manager.createRepository(location, repositoryName, "org.eclipse.equinox.p2.artifact.repository.simpleRepository");
+			// TODO: do we still need to do this
+			tagAsImplementation(repository);
+		}
+
+		IFileArtifactRepository downloadCache = (IFileArtifactRepository) repository.getAdapter(IFileArtifactRepository.class);
+		if (downloadCache == null) {
+			throw new IllegalArgumentException("Agent download cache not writeable: " + location); //$NON-NLS-1$
+		}
+		return downloadCache;
 	}
 
 	static private URL getDownloadCacheLocation() {
@@ -457,28 +712,27 @@ public class EclipseTouchpoint extends Touchpoint {
 
 	// TODO: Will there be other repositories to tag as implementation?  Should this
 	//		 method to some utility?
-	static private IArtifactRepository tagAsImplementation(IArtifactRepository repository) {
+	static private void tagAsImplementation(IArtifactRepository repository) {
 		//		if (repository != null && repository.getProperties().getProperty(IRepositoryInfo.IMPLEMENTATION_ONLY_KEY) == null) {
 		//			IWritableRepositoryInfo writableInfo = (IWritableRepositoryInfo) repository.getAdapter(IWritableRepositoryInfo.class);
 		//			if (writableInfo != null) {
 		//				writableInfo.getModifiableProperties().setProperty(IRepositoryInfo.IMPLEMENTATION_ONLY_KEY, Boolean.valueOf(true).toString());
 		//			}
 		//		}
-		return repository;
 	}
 
-	private void logConfiguation(IInstallableUnit unit, String instructions, boolean isInstall) {
-		//  TODO: temporary for debugging; replace by logging
-		if (DEBUG) {
-			System.out.print("[" + iuCount + "] ");
-			if (isInstall) {
-				System.out.println("Installing " + unit + " with: " + instructions);
-			} else {
-				System.out.println("Uninstalling " + unit + " with: " + instructions);
-			}
-			iuCount++;
-		}
-	}
+	//	private void logConfiguation(IInstallableUnit unit, String instructions, boolean isInstall) {
+	//		//  TODO: temporary for debugging; replace by logging
+	//		if (DEBUG) {
+	//			System.out.print("[" + iuCount + "] ");
+	//			if (isInstall) {
+	//				System.out.println("Installing " + unit + " with: " + instructions);
+	//			} else {
+	//				System.out.println("Uninstalling " + unit + " with: " + instructions);
+	//			}
+	//			iuCount++;
+	//		}
+	//	}
 
 	public IStatus completePhase(IProgressMonitor monitor, Profile profile, String phaseId, Map touchpointParameters) {
 		Manipulator manipulator = (Manipulator) touchpointParameters.get("manipulator");
@@ -504,6 +758,7 @@ public class EclipseTouchpoint extends Touchpoint {
 		manipulator.getConfigData().setFwDependentProp("eclipse.p2.profile", profile.getProfileId());
 		manipulator.getConfigData().setFwDependentProp("eclipse.p2.data.area", computeRelativeAgentLocation(profile));
 		touchpointParameters.put("manipulator", manipulator);
+		touchpointParameters.put("installFolder", getInstallFolder(profile));
 		return null;
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
index 832e2c1..b595116 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
@@ -13,18 +13,16 @@ package org.eclipse.equinox.internal.p2.touchpoint.natives;
 import java.io.File;
 import java.net.URL;
 import java.util.*;
-import org.eclipse.core.runtime.IStatus;
-import org.eclipse.core.runtime.Status;
+import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.p2.artifact.repository.*;
 import org.eclipse.equinox.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.p2.core.location.AgentLocation;
 import org.eclipse.equinox.p2.engine.*;
 import org.eclipse.equinox.p2.metadata.*;
-import org.mozilla.javascript.*;
 import org.osgi.framework.Version;
 
 public class NativeTouchpoint extends Touchpoint {
-	private final static String CONFIGURATION_DATA = "configurationData";
+	//	private final static String CONFIGURATION_DATA = "configurationData";
 	private static final String ID = "org.eclipse.equinox.p2.touchpoint.natives"; //$NON-NLS-1$
 
 	private final Set supportedPhases = new HashSet(); //TODO This should probably come from XML
@@ -57,88 +55,137 @@ public class NativeTouchpoint extends Touchpoint {
 			};
 		}
 
-		if (actionId.equals("install")) {
+		if (actionId.equals("unzip")) {
 			return new ProvisioningAction() {
 				public IStatus execute(Map parameters) {
-					Profile profile = (Profile) parameters.get("profile");
-					Operand operand = (Operand) parameters.get("operand");
-					return doInstall(operand.second(), profile);
+					String source = (String) parameters.get("source");
+					String target = (String) parameters.get("target");
+
+					if (source.equals("@artifact")) {
+						IInstallableUnit iu = (IInstallableUnit) parameters.get("iu");
+						//TODO: fix wherever this occurs -- investigate as this is probably not desired
+						if (iu.getArtifacts() == null || iu.getArtifacts().length == 0)
+							return Status.OK_STATUS;
+
+						IArtifactKey artifactKey = iu.getArtifacts()[0];
+
+						IFileArtifactRepository downloadCache = getDownloadCacheRepo();
+						File fileLocation = downloadCache.getArtifactFile(artifactKey);
+						if (!fileLocation.exists())
+							return new Status(IStatus.ERROR, ID, "The file is not available" + fileLocation.getAbsolutePath());
+						source = fileLocation.getAbsolutePath();
+					}
+
+					new Zip().unzip(source, target, null);
+					return Status.OK_STATUS;
 				}
 
 				public IStatus undo(Map parameters) {
-					Profile profile = (Profile) parameters.get("profile");
-					Operand operand = (Operand) parameters.get("operand");
-					return doUninstall(operand.second(), profile);
+					//TODO: implement undo
+					return Status.OK_STATUS;
 				}
 			};
 		}
-		if (actionId.equals("uninstall")) {
+		if (actionId.equals("chmod")) {
 			return new ProvisioningAction() {
 				public IStatus execute(Map parameters) {
-					Profile profile = (Profile) parameters.get("profile");
-					Operand operand = (Operand) parameters.get("operand");
-					return doUninstall(operand.first(), profile);
+					String targetDir = (String) parameters.get("targetDir");
+					String targetFile = (String) parameters.get("targetFile");
+					String permissions = (String) parameters.get("permissions");
+
+					new Permissions().chmod(targetDir, targetFile, null);
+					return Status.OK_STATUS;
 				}
 
 				public IStatus undo(Map parameters) {
-					Profile profile = (Profile) parameters.get("profile");
-					Operand operand = (Operand) parameters.get("operand");
-					return doInstall(operand.first(), profile);
+					//TODO: implement undo ??
+					return Status.OK_STATUS;
 				}
 			};
 		}
 
-		return null;
-	}
+		//		if (actionId.equals("OLDinstall")) {
+		//			return new ProvisioningAction() {
+		//				public IStatus execute(Map parameters) {
+		//					Profile profile = (Profile) parameters.get("profile");
+		//					Operand operand = (Operand) parameters.get("operand");
+		//					return doInstall(operand.second(), profile);
+		//				}
+		//
+		//				public IStatus undo(Map parameters) {
+		//					Profile profile = (Profile) parameters.get("profile");
+		//					Operand operand = (Operand) parameters.get("operand");
+		//					return doUninstall(operand.second(), profile);
+		//				}
+		//			};
+		//		}
+		//		if (actionId.equals("OLDuninstall")) {
+		//			return new ProvisioningAction() {
+		//				public IStatus execute(Map parameters) {
+		//					Profile profile = (Profile) parameters.get("profile");
+		//					Operand operand = (Operand) parameters.get("operand");
+		//					return doUninstall(operand.first(), profile);
+		//				}
+		//
+		//				public IStatus undo(Map parameters) {
+		//					Profile profile = (Profile) parameters.get("profile");
+		//					Operand operand = (Operand) parameters.get("operand");
+		//					return doInstall(operand.first(), profile);
+		//				}
+		//			};
+		//		}
 
-	private IStatus doInstall(IInstallableUnit unitToInstall, Profile profile) {
-		//Get the cache
-		IArtifactRepository dlCache = getDownloadCacheRepo();
-		if (unitToInstall.getArtifacts() == null || unitToInstall.getArtifacts().length == 0)
-			return Status.OK_STATUS;
-
-		IFileArtifactRepository repoToCheck = (IFileArtifactRepository) dlCache.getAdapter(IFileArtifactRepository.class);
-		File fileLocation = repoToCheck.getArtifactFile(unitToInstall.getArtifacts()[0]);
-		if (!fileLocation.exists())
-			return new Status(IStatus.ERROR, ID, "The file is not available" + fileLocation.getAbsolutePath());
-
-		TouchpointData[] touchpointData = unitToInstall.getTouchpointData();
-		Context cx = Context.enter();
-		Scriptable scope = cx.initStandardObjects();
-		ScriptableObject.putProperty(scope, "artifact", fileLocation.getAbsolutePath());
-		ScriptableObject.putProperty(scope, "currentDir", getInstallFolder(profile));
-		ScriptableObject.putProperty(scope, "Zip", new Zip());
-		ScriptableObject.putProperty(scope, "Permissions", new Permissions());
-		String[] configurationData = getInstructionsFor(CONFIGURATION_DATA, touchpointData);
-		for (int i = 0; i < configurationData.length; i++) {
-			try {
-				cx.evaluateString(scope, configurationData[i], unitToInstall.getId(), 1, null);
-			} catch (RuntimeException e) {
-				return new Status(IStatus.ERROR, Activator.ID, "Exception while executing " + configurationData[i], e);
-			}
-		}
-		return Status.OK_STATUS;
+		return null;
 	}
 
-	private IStatus doUninstall(IInstallableUnit unitToInstall, Profile profile) {
-		// TODO: implement uninstall 
-		return Status.OK_STATUS;
-	}
+	//	private IStatus doInstall(IInstallableUnit unitToInstall, Profile profile) {
+	//		//Get the cache
+	//		IArtifactRepository dlCache = getDownloadCacheRepo();
+	//		if (unitToInstall.getArtifacts() == null || unitToInstall.getArtifacts().length == 0)
+	//			return Status.OK_STATUS;
+	//
+	//		IFileArtifactRepository repoToCheck = (IFileArtifactRepository) dlCache.getAdapter(IFileArtifactRepository.class);
+	//		File fileLocation = repoToCheck.getArtifactFile(unitToInstall.getArtifacts()[0]);
+	//		if (!fileLocation.exists())
+	//			return new Status(IStatus.ERROR, ID, "The file is not available" + fileLocation.getAbsolutePath());
+	//
+	//		TouchpointData[] touchpointData = unitToInstall.getTouchpointData();
+	//		Context cx = Context.enter();
+	//		Scriptable scope = cx.initStandardObjects();
+	//		ScriptableObject.putProperty(scope, "artifact", fileLocation.getAbsolutePath());
+	//		ScriptableObject.putProperty(scope, "currentDir", getInstallFolder(profile));
+	//		ScriptableObject.putProperty(scope, "Zip", new Zip());
+	//		ScriptableObject.putProperty(scope, "Permissions", new Permissions());
+	//		String[] configurationData = getInstructionsFor(CONFIGURATION_DATA, touchpointData);
+	//		for (int i = 0; i < configurationData.length; i++) {
+	//			try {
+	//				cx.evaluateString(scope, configurationData[i], unitToInstall.getId(), 1, null);
+	//			} catch (RuntimeException e) {
+	//				return new Status(IStatus.ERROR, Activator.ID, "Exception while executing " + configurationData[i], e);
+	//			}
+	//		}
+	//		return Status.OK_STATUS;
+	//	}
+	//
+	//	private IStatus doUninstall(IInstallableUnit unitToInstall, Profile profile) {
+	//		// TODO: implement uninstall 
+	//		return Status.OK_STATUS;
+	//	}
 
-	private String[] getInstructionsFor(String key, TouchpointData[] data) {
-		String[] matches = new String[data.length];
-		int count = 0;
-		for (int i = 0; i < data.length; i++) {
-			matches[count] = data[i].getInstructions(key);
-			if (matches[count] != null)
-				count++;
-		}
-		if (count == data.length)
-			return matches;
-		String[] result = new String[count];
-		System.arraycopy(matches, 0, result, 0, count);
-		return result;
-	}
+	//	private String[] getInstructionsFor(String key, TouchpointData[] data) {
+	//		String[] matches = new String[data.length];
+	//		int count = 0;
+	//		for (int i = 0; i < data.length; i++) {
+	//			matches[count] = data[i].getInstructions(key);
+	//			if (matches[count] != null)
+	//				count++;
+	//		}
+	//		if (count == data.length)
+	//			return matches;
+	//		String[] result = new String[count];
+	//		System.arraycopy(matches, 0, result, 0, count);
+	//		return result;
+	//	}
 
 	public TouchpointType getTouchpointType() {
 		return new TouchpointType("native", new Version(1, 0, 0));
@@ -167,21 +214,50 @@ public class NativeTouchpoint extends Touchpoint {
 		return profile.getValue(Profile.PROP_INSTALL_FOLDER);
 	}
 
-	private IArtifactRepositoryManager getArtifactRepositoryManager() {
+	private static AgentLocation getAgentLocation() {
+		return (AgentLocation) ServiceHelper.getService(Activator.getContext(), AgentLocation.class.getName());
+	}
+
+	static private IArtifactRepositoryManager getArtifactRepositoryManager() {
 		return (IArtifactRepositoryManager) ServiceHelper.getService(Activator.getContext(), IArtifactRepositoryManager.class.getName());
 	}
 
-	private IArtifactRepository getDownloadCacheRepo() {
-		IArtifactRepository repository = getArtifactRepositoryManager().getRepository(getDownloadCacheLocation());
-		if (!repository.isModifiable())
-			throw new IllegalStateException("Download cache is not writable: " + repository.getLocation()); //$NON-NLS-1$
-		return repository;
+	static private void tagAsImplementation(IArtifactRepository repository) {
+		//		if (repository != null && repository.getProperties().getProperty(IRepositoryInfo.IMPLEMENTATION_ONLY_KEY) == null) {
+		//			IWritableRepositoryInfo writableInfo = (IWritableRepositoryInfo) repository.getAdapter(IWritableRepositoryInfo.class);
+		//			if (writableInfo != null) {
+		//				writableInfo.getModifiableProperties().setProperty(IRepositoryInfo.IMPLEMENTATION_ONLY_KEY, Boolean.valueOf(true).toString());
+		//			}
+		//		}
 	}
 
-	private URL getDownloadCacheLocation() {
-		AgentLocation location = (AgentLocation) ServiceHelper.getService(Activator.getContext(), AgentLocation.class.getName());
-		if (location == null)
-			return null;
-		return location.getArtifactRepositoryURL();
+	static private IFileArtifactRepository getDownloadCacheRepo() {
+		URL location = getDownloadCacheLocation();
+		IArtifactRepositoryManager manager = getArtifactRepositoryManager();
+		IArtifactRepository repository = manager.loadRepository(location, null);
+		if (repository == null) {
+			// 	the given repo location is not an existing repo so we have to create something
+			// TODO for now create a random repo by default.
+			String repositoryName = location + " - Agent download cache"; //$NON-NLS-1$
+			repository = manager.createRepository(location, repositoryName, "org.eclipse.equinox.p2.artifact.repository.simpleRepository");
+			// TODO: do we still need to do this
+			tagAsImplementation(repository);
+		}
+
+		IFileArtifactRepository downloadCache = (IFileArtifactRepository) repository.getAdapter(IFileArtifactRepository.class);
+		if (downloadCache == null) {
+			throw new IllegalArgumentException("Agent download cache not writeable: " + location); //$NON-NLS-1$
+		}
+		return downloadCache;
+	}
+
+	static private URL getDownloadCacheLocation() {
+		AgentLocation location = getAgentLocation();
+		return (location != null ? location.getArtifactRepositoryURL() : null);
+	}
+
+	public IStatus initializePhase(IProgressMonitor monitor, Profile profile, String phaseId, Map touchpointParameters) {
+		touchpointParameters.put("installFolder", getInstallFolder(profile));
+		return null;
 	}
 }
