commit ba0ef9eb2734608349d658bd84438b1879ff666e
Author: Susan Franklin <sfranklin>
Date:   Mon Apr 13 18:26:59 2009 +0000

    Bug 258539 - [ui] Automatic update preference lost

2	8	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.xml
4	1	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateMessages.java
26	1	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
12	9	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
54	46	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPreferencePage.java
0	51	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/ClassicUpdateInitializer.java
104	8	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
4	1	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/messages.properties
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.xml b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.xml
index 526296e..3072ef7 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.xml
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.xml
@@ -2,7 +2,7 @@
 <?eclipse version="3.2"?>
 <plugin>
    	<extension 
-   		id="preferences" point="org.eclipse.core.runtime.preferences" name="%preferences">
+   		id="preferences" point="org.eclipse.core.runtime.preferences" name="%automaticUpdatesPrefPage">
 		<initializer class="org.eclipse.equinox.internal.p2.ui.sdk.scheduler.PreferenceInitializer"/>
 	</extension>
    <extension
@@ -10,13 +10,7 @@
       <startup class="org.eclipse.equinox.internal.p2.ui.sdk.scheduler.AutomaticUpdateScheduler">
       </startup>
    </extension>
-  <extension
-         point="org.eclipse.core.runtime.preferences">
-      <initializer
-            class="org.eclipse.equinox.internal.p2.ui.sdk.scheduler.ClassicUpdateInitializer">
-      </initializer>
-   </extension>
-      <extension
+   <extension
          point="org.eclipse.ui.preferencePages">
           <page
             name="%automaticUpdatesPrefPage"
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateMessages.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateMessages.java
index 8619cde..34a9496 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateMessages.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateMessages.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
+ * Copyright (c) 2008, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -82,4 +82,7 @@ public class AutomaticUpdateMessages extends NLS {
 	public static String AutomaticUpdatesPreferencePage_RemindOnce;
 	public static String AutomaticUpdatesPopup_ClickToReviewDownloaded;
 	public static String AutomaticUpdatesPopup_ClickToReviewNotDownloaded;
+	public static String ErrorSavingPreferences;
+	public static String ErrorSavingClassicPreferences;
+	public static String ErrorLoadingPreferenceKeys;
 }
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
index f28fef0..064a5c3 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
+ * Copyright (c) 2008, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,12 +10,18 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
 
+import org.eclipse.core.runtime.Platform;
+import org.eclipse.core.runtime.preferences.DefaultScope;
 import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
+import org.eclipse.equinox.internal.provisional.p2.ui.ProvUI;
 import org.eclipse.ui.plugin.AbstractUIPlugin;
+import org.eclipse.ui.statushandlers.StatusManager;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.ServiceReference;
 import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.prefs.BackingStoreException;
+import org.osgi.service.prefs.Preferences;
 
 /**
  * Activator class for the automatic updates plugin
@@ -31,6 +37,7 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 	private AutomaticUpdater updater;
 
 	public static final String PLUGIN_ID = "org.eclipse.equinox.p2.ui.sdk.scheduler"; //$NON-NLS-1$
+	public static final String PREFERENCE_ROOT = "/profile/_SELF_/"; //$NON-NLS-1$
 
 	public static BundleContext getContext() {
 		return context;
@@ -50,6 +57,22 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 		}
 		return null;
 	}
+	
+	static Preferences getPreferences() {
+		return Platform.getPreferencesService().getRootNode().node(PREFERENCE_ROOT + PLUGIN_ID);
+	}
+	
+	static Preferences getDefaultPreferences() {
+		return new DefaultScope().getNode(PLUGIN_ID);
+	}
+	
+	static void savePreferences() {
+		try {
+			getPreferences().flush();
+		} catch (BackingStoreException e) {
+			ProvUI.handleException(e, AutomaticUpdateMessages.ErrorSavingPreferences, StatusManager.LOG); 
+		}
+	}
 
 	/**
 	 * Returns the singleton plugin instance
@@ -83,6 +106,8 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 		getBundle("org.eclipse.equinox.frameworkadmin.equinox").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
 		getBundle("org.eclipse.equinox.simpleconfigurator.manipulator").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
 		getBundle("org.eclipse.equinox.p2.updatechecker").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
+		
+		PreferenceInitializer.migratePreferences();
 	}
 
 	public void stop(BundleContext bundleContext) throws Exception {
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
index 40633f8..340eaaa 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
+ * Copyright (c) 2008, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,7 +11,10 @@
 package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
 
 import java.util.Calendar;
-import org.eclipse.core.runtime.*;
+
+import org.eclipse.core.runtime.IStatus;
+import org.osgi.service.prefs.Preferences;
+import org.eclipse.core.runtime.Status;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.internal.provisional.p2.engine.IProfile;
 import org.eclipse.equinox.internal.provisional.p2.engine.IProfileRegistry;
@@ -110,8 +113,8 @@ public class AutomaticUpdateScheduler implements IStartup {
 
 	public void rescheduleUpdate() {
 		removeUpdateListener();
-		Preferences pref = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
-		String schedule = pref.getString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE);
+		Preferences pref = AutomaticUpdatePlugin.getPreferences();
+		String schedule = pref.get(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, "");
 		// See if we have a scheduled check or startup only.  If it is
 		// startup only, there is nothing more to do now, a listener will
 		// be created on the next startup.
@@ -125,11 +128,11 @@ public class AutomaticUpdateScheduler implements IStartup {
 		// Nothing to do if we don't know what profile we are checking
 		if (profileId == null)
 			return;
-		Preferences pref = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
+		Preferences pref = AutomaticUpdatePlugin.getPreferences();
 		// See if automatic search is enabled at all
-		if (pref.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED) == false)
+		if (pref.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, false) == false)
 			return;
-		String schedule = pref.getString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE);
+		String schedule = pref.get(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, "");
 		long delay = IUpdateChecker.ONE_TIME_CHECK;
 		long poll = IUpdateChecker.ONE_TIME_CHECK;
 		if (!schedule.equals(PreferenceConstants.PREF_UPDATE_ON_STARTUP)) {
@@ -157,7 +160,7 @@ public class AutomaticUpdateScheduler implements IStartup {
 	}
 
 	private int getDay(Preferences pref) {
-		String day = pref.getString(P_DAY);
+		String day = pref.get(P_DAY, "");
 		for (int d = 0; d < DAYS.length; d++)
 			if (DAYS[d].equals(day))
 				switch (d) {
@@ -182,7 +185,7 @@ public class AutomaticUpdateScheduler implements IStartup {
 	}
 
 	private int getHour(Preferences pref) {
-		String hour = pref.getString(P_HOUR);
+		String hour = pref.get(P_HOUR, "");
 		for (int h = 0; h < HOURS.length; h++)
 			if (HOURS[h].equals(hour))
 				return h + 1;
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPreferencePage.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPreferencePage.java
index b279bb8..ed94e4f 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPreferencePage.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPreferencePage.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,7 +10,7 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
 
-import org.eclipse.core.runtime.Preferences;
+import org.osgi.service.prefs.Preferences;
 import org.eclipse.jface.dialogs.Dialog;
 import org.eclipse.jface.preference.PreferencePage;
 import org.eclipse.swt.SWT;
@@ -18,8 +18,15 @@ import org.eclipse.swt.events.SelectionAdapter;
 import org.eclipse.swt.events.SelectionEvent;
 import org.eclipse.swt.layout.GridData;
 import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.*;
-import org.eclipse.ui.*;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.ui.IWorkbench;
+import org.eclipse.ui.IWorkbenchPreferencePage;
+import org.eclipse.ui.PlatformUI;
 
 /**
  * Preference page for automated updates.
@@ -193,19 +200,19 @@ public class AutomaticUpdatesPreferencePage extends PreferencePage implements IW
 	}
 
 	private void initialize() {
-		Preferences pref = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
-		enabledCheck.setSelection(pref.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED));
-		setSchedule(pref.getString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE));
-
-		dayCombo.setText(AutomaticUpdateScheduler.DAYS[getDay(pref, false)]);
-		hourCombo.setText(AutomaticUpdateScheduler.HOURS[getHour(pref, false)]);
-
-		remindScheduleRadio.setSelection(pref.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
-		remindOnceRadio.setSelection(!pref.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
-		remindElapseCombo.setText(pref.getString(PreferenceConstants.PREF_REMIND_ELAPSED));
-		searchOnlyRadio.setSelection(!pref.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
-		searchAndDownloadRadio.setSelection(pref.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
-
+		Preferences pref = AutomaticUpdatePlugin.getPreferences();
+		enabledCheck.setSelection(pref.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, false));
+		setSchedule(pref.get(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, ""));
+		
+		dayCombo.setText(AutomaticUpdateScheduler.DAYS[getDay(pref)]);
+		hourCombo.setText(AutomaticUpdateScheduler.HOURS[getHour(pref)]);
+		
+		remindScheduleRadio.setSelection(pref.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE, false));
+		remindOnceRadio.setSelection(!pref.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE, false));
+		remindElapseCombo.setText(pref.get(PreferenceConstants.PREF_REMIND_ELAPSED, ""));
+		searchOnlyRadio.setSelection(!pref.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY, false));
+		searchAndDownloadRadio.setSelection(pref.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY, false));
+		
 		pageChanged();
 	}
 
@@ -235,21 +242,22 @@ public class AutomaticUpdatesPreferencePage extends PreferencePage implements IW
 
 	protected void performDefaults() {
 		super.performDefaults();
-		Preferences pref = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
-		enabledCheck.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED));
+		Preferences defaultPref = AutomaticUpdatePlugin.getDefaultPreferences();
+		enabledCheck.setSelection(defaultPref.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, false));
+
+		setSchedule(defaultPref.get(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, ""));
+		onScheduleRadio.setSelection(defaultPref.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, false));
 
-		setSchedule(pref.getDefaultString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE));
-		onScheduleRadio.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE));
+		dayCombo.setText(AutomaticUpdateScheduler.DAYS[getDay(defaultPref)]);
+		hourCombo.setText(AutomaticUpdateScheduler.HOURS[getHour(defaultPref)]);
 
-		dayCombo.setText(AutomaticUpdateScheduler.DAYS[getDay(pref, true)]);
-		hourCombo.setText(AutomaticUpdateScheduler.HOURS[getHour(pref, true)]);
+		remindOnceRadio.setSelection(!defaultPref.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE, false));
+		remindScheduleRadio.setSelection(defaultPref.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE, false));
+		remindElapseCombo.setText(defaultPref.get(PreferenceConstants.PREF_REMIND_ELAPSED, ""));
 
-		remindOnceRadio.setSelection(!pref.getDefaultBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
-		remindScheduleRadio.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
-		remindElapseCombo.setText(pref.getDefaultString(PreferenceConstants.PREF_REMIND_ELAPSED));
+		searchOnlyRadio.setSelection(!defaultPref.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY, false));
+		searchAndDownloadRadio.setSelection(defaultPref.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY, false));
 
-		searchOnlyRadio.setSelection(!pref.getDefaultBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
-		searchAndDownloadRadio.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
 		pageChanged();
 	}
 
@@ -258,41 +266,41 @@ public class AutomaticUpdatesPreferencePage extends PreferencePage implements IW
 	 * Subclasses should override
 	 */
 	public boolean performOk() {
-		Preferences pref = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
-		pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, enabledCheck.getSelection());
+		Preferences pref = AutomaticUpdatePlugin.getPreferences();
+		pref.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, enabledCheck.getSelection());
 		if (onStartupRadio.getSelection())
-			pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_STARTUP);
+			pref.put(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_STARTUP);
 		else
-			pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_SCHEDULE);
-
+			pref.put(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_SCHEDULE);
+		
 		if (remindScheduleRadio.getSelection()) {
-			pref.setValue(PreferenceConstants.PREF_REMIND_SCHEDULE, true);
-			pref.setValue(PreferenceConstants.PREF_REMIND_ELAPSED, remindElapseCombo.getText());
+			pref.putBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE, true);
+			pref.put(PreferenceConstants.PREF_REMIND_ELAPSED, remindElapseCombo.getText());
 		} else {
-			pref.setValue(PreferenceConstants.PREF_REMIND_SCHEDULE, false);
+			pref.putBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE, false);
 		}
+		
+		pref.put(AutomaticUpdateScheduler.P_DAY, dayCombo.getText());
+		pref.put(AutomaticUpdateScheduler.P_HOUR, hourCombo.getText());
+		
+		pref.putBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY, searchAndDownloadRadio.getSelection());
 
-		pref.setValue(AutomaticUpdateScheduler.P_DAY, dayCombo.getText());
-		pref.setValue(AutomaticUpdateScheduler.P_HOUR, hourCombo.getText());
-
-		pref.setValue(PreferenceConstants.PREF_DOWNLOAD_ONLY, searchAndDownloadRadio.getSelection());
-
-		AutomaticUpdatePlugin.getDefault().savePluginPreferences();
+		AutomaticUpdatePlugin.savePreferences();
 
 		AutomaticUpdatePlugin.getDefault().getScheduler().rescheduleUpdate();
 		return true;
 	}
 
-	private int getDay(Preferences pref, boolean useDefault) {
-		String day = useDefault ? pref.getDefaultString(AutomaticUpdateScheduler.P_DAY) : pref.getString(AutomaticUpdateScheduler.P_DAY);
+	private int getDay(Preferences pref) {
+		String day = pref.get(AutomaticUpdateScheduler.P_DAY, "");
 		for (int i = 0; i < AutomaticUpdateScheduler.DAYS.length; i++)
 			if (AutomaticUpdateScheduler.DAYS[i].equals(day))
 				return i;
 		return 0;
 	}
 
-	private int getHour(Preferences pref, boolean useDefault) {
-		String hour = useDefault ? pref.getDefaultString(AutomaticUpdateScheduler.P_HOUR) : pref.getString(AutomaticUpdateScheduler.P_HOUR);
+	private int getHour(Preferences pref) {
+		String hour = pref.get(AutomaticUpdateScheduler.P_HOUR, "");
 		for (int i = 0; i < AutomaticUpdateScheduler.HOURS.length; i++)
 			if (AutomaticUpdateScheduler.HOURS[i].equals(hour))
 				return i;
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/ClassicUpdateInitializer.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/ClassicUpdateInitializer.java
deleted file mode 100644
index 3c1767e..0000000
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/ClassicUpdateInitializer.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
-
-import org.eclipse.core.runtime.Platform;
-import org.eclipse.core.runtime.Preferences;
-import org.eclipse.core.runtime.preferences.*;
-import org.eclipse.equinox.internal.provisional.p2.ui.ProvUI;
-import org.eclipse.ui.statushandlers.StatusManager;
-import org.osgi.service.prefs.BackingStoreException;
-
-public class ClassicUpdateInitializer extends AbstractPreferenceInitializer {
-
-	private static final String P_ENABLED = "enabled"; //$NON-NLS-1$
-	private static final String UPDATE_PLUGIN_ID = "org.eclipse.update.scheduler"; //$NON-NLS-1$
-
-	public void initializeDefaultPreferences() {
-		Preferences prefP2 = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
-		//only migrate auto-update preference from UM once
-		boolean autoUpdateInit = prefP2.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_INIT);
-		if (!autoUpdateInit) {
-			// get UM automatic update preference
-			IPreferencesService preferencesService = Platform.getPreferencesService();
-			org.osgi.service.prefs.Preferences instanceScope = preferencesService.getRootNode().node(InstanceScope.SCOPE);
-			try {
-				boolean updateNodeExists = instanceScope.nodeExists(UPDATE_PLUGIN_ID);
-				org.osgi.service.prefs.Preferences prefUM = instanceScope.node(UPDATE_PLUGIN_ID);
-				boolean enableUpdate = prefUM.getBoolean(P_ENABLED, false);
-				// set p2 automatic update preference to match UM preference
-				prefP2.setValue(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, enableUpdate);
-				prefP2.setValue(PreferenceConstants.PREF_AUTO_UPDATE_INIT, true);
-				AutomaticUpdatePlugin.getDefault().savePluginPreferences();
-				// turn off UM automatic update preference if it exists
-				if (updateNodeExists) {
-					prefUM.putBoolean(P_ENABLED, false);
-					prefUM.flush();
-				}
-			} catch (BackingStoreException e) {
-				ProvUI.handleException(e, "Error saving classic update preferences", StatusManager.LOG); //$NON-NLS-1$
-			}
-		}
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
index 3a5ebff..46de9ca 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
+ * Copyright (c) 2008, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,19 +10,116 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
 
+import org.eclipse.core.runtime.Platform;
 import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer;
 import org.eclipse.core.runtime.preferences.DefaultScope;
+import org.eclipse.core.runtime.preferences.InstanceScope;
+import org.eclipse.equinox.internal.provisional.p2.ui.ProvUI;
+import org.eclipse.ui.statushandlers.StatusManager;
+import org.osgi.service.prefs.BackingStoreException;
 import org.osgi.service.prefs.Preferences;
 
-/**
- * @since 3.5
- */
 public class PreferenceInitializer extends AbstractPreferenceInitializer {
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer#initializeDefaultPreferences()
-	 */
+	private static final String P_ENABLED = "enabled"; //$NON-NLS-1$
+	private static final String UPDATE_PLUGIN_ID = "org.eclipse.update.scheduler"; //$NON-NLS-1$
+
+	public static void migratePreferences() {
+		// Migrate preference values that were stored in alternate locations.
+		// 1) migrate from instance scope (during 3.5 development) to profile scope (final 3.5 format)
+		// 2) if applicable, migrate from 3.4 prefs kept in a different bundle
+		// 3) if applicable, migrate from 3.3 prefs known by Update Manager
+		Preferences pref = AutomaticUpdatePlugin.getPreferences();
+		try {
+			if (pref.keys().length == 0) {
+				// migrate preferences from instance scope to profile scope
+				org.eclipse.core.runtime.Preferences oldPref = AutomaticUpdatePlugin
+						.getDefault().getPluginPreferences();
+				String[] keys = oldPref.propertyNames();
+				for (int i = 0; i < keys.length; i++)
+					pref.put(keys[i], oldPref.getString(keys[i]));
+
+				if (keys.length > 0)
+					AutomaticUpdatePlugin.savePreferences();
+			}
+		} catch (BackingStoreException e) {
+			ProvUI.handleException(e,
+					AutomaticUpdateMessages.ErrorLoadingPreferenceKeys,
+					StatusManager.LOG);
+		}
+
+		// Have we initialized the auto update prefs from previous
+		// releases?  
+		boolean autoUpdateInit = pref.getBoolean(
+				PreferenceConstants.PREF_AUTO_UPDATE_INIT, false);
+		if (!autoUpdateInit) {
+			// first look for the 3.4 automatic update preferences, which were
+			// located in a different bundle than now, in the instance scope.
+			Preferences node34 = Platform.getPreferencesService().getRootNode()
+					.node(InstanceScope.SCOPE).node(
+							"org.eclipse.equinox.p2.ui.sdk"); //$NON-NLS-1$
+			if (node34 != null) {
+				// We only migrate the preferences associated with auto update.
+				// Other preferences still remain in that bundle and are handled
+				// there.
+				pref.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED,
+						node34.getBoolean("enabled", false));
+				pref.put(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, node34
+						.get("schedule",
+								PreferenceConstants.PREF_UPDATE_ON_STARTUP));
+				pref.putBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY, node34
+						.getBoolean("download", false));
+				pref.putBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE,
+						node34.getBoolean("remindOnSchedule", false)); //$NON-NLS-1$
+				pref
+						.put(
+								PreferenceConstants.PREF_REMIND_ELAPSED,
+								node34
+										.get(
+												"remindElapsedTime",
+												AutomaticUpdateMessages.AutomaticUpdateScheduler_30Minutes));
+				// mark the pref that says we've migrated
+				pref
+						.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_INIT,
+								true);
+				AutomaticUpdatePlugin.savePreferences();
+			}
+			// Look for the 3.3 UM automatic update preferences. We will
+			// not migrate them if we already pulled values from 3.4.
+			// However, we always want to turn off the UM automatic update
+			// checker if it is found to be on.
+			Preferences instanceScope = Platform.getPreferencesService()
+					.getRootNode().node(InstanceScope.SCOPE);
+			try {
+				boolean updateNodeExists = instanceScope
+						.nodeExists(UPDATE_PLUGIN_ID);
+				Preferences prefUM = instanceScope.node(UPDATE_PLUGIN_ID);
+				boolean enableUpdate = prefUM.getBoolean(P_ENABLED, false);
+				// set p2 automatic update preference to match UM preference,
+				// only if we haven't already used 3.4 values
+				if (node34 == null) {
+					pref.putBoolean(
+							PreferenceConstants.PREF_AUTO_UPDATE_ENABLED,
+							enableUpdate);
+					// mark the pref that says we migrated
+					pref.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_INIT,
+							true);
+					AutomaticUpdatePlugin.savePreferences();
+				}
+				// turn off UM automatic update preference if it exists
+				if (updateNodeExists) {
+					prefUM.putBoolean(P_ENABLED, false);
+					prefUM.flush();
+				}
+			} catch (BackingStoreException e) {
+				ProvUI.handleException(e,
+						AutomaticUpdateMessages.ErrorSavingClassicPreferences,
+						StatusManager.LOG);
+			}
+		}
+	}
 	public void initializeDefaultPreferences() {
+		// initialize the default scope
 		Preferences node = new DefaultScope().getNode(AutomaticUpdatePlugin.PLUGIN_ID);
 		node.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, false);
 		node.put(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_STARTUP);
@@ -30,5 +127,4 @@ public class PreferenceInitializer extends AbstractPreferenceInitializer {
 		node.putBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE, false);
 		node.put(PreferenceConstants.PREF_REMIND_ELAPSED, AutomaticUpdateMessages.AutomaticUpdateScheduler_30Minutes);
 	}
-
 }
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/messages.properties b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/messages.properties
index ffa39b8..3608e5c 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/messages.properties
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/messages.properties
@@ -1,5 +1,5 @@
 ###############################################################################
-# Copyright (c) 2007, 2008 IBM Corporation and others.
+# Copyright (c) 2007, 2009 IBM Corporation and others.
 # All rights reserved. This program and the accompanying materials
 # are made available under the terms of the Eclipse Public License v1.0
 # which accompanies this distribution, and is available at
@@ -68,3 +68,6 @@ AutomaticUpdatesPreferencePage_at=at
 AutomaticUpdatesPreferencePage_RemindGroup=&When updates are found
 AutomaticUpdatesPreferencePage_RemindSchedule=&Remind me about updates every:
 AutomaticUpdatesPreferencePage_RemindOnce=Notify me &once about updates
+ErrorSavingPreferences=Error saving update preferences
+ErrorSavingClassicPreferences=Error saving classic update preferences
+ErrorLoadingPreferenceKeys=Error loading preference keys
\ No newline at end of file
commit 84862ed961f90667f5faf03f5c229cf2a179dafd
Author: Susan Franklin <sfranklin>
Date:   Tue Apr 14 20:50:32 2009 +0000

    Bug 258539 - [ui] Automatic update preference lost

1	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceConstants.java
74	41	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceConstants.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceConstants.java
index 91876d4..19f9647 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceConstants.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceConstants.java
@@ -23,4 +23,5 @@ public class PreferenceConstants {
 	public static final String PREF_REMIND_SCHEDULE = "remindOnSchedule"; // value is true or false //$NON-NLS-1$
 	public static final String PREF_REMIND_ELAPSED = "remindElapsedTime";//$NON-NLS-1$
 	public static final String PREF_AUTO_UPDATE_INIT = "autoUpdateInit"; //$NON-NLS-1$
+	public static final String PREF_MIGRATED_34 = "migrated34Prefs"; //$NON-NLS-1$
 }
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
index 46de9ca..717a541 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
@@ -23,10 +23,12 @@ public class PreferenceInitializer extends AbstractPreferenceInitializer {
 
 	private static final String P_ENABLED = "enabled"; //$NON-NLS-1$
 	private static final String UPDATE_PLUGIN_ID = "org.eclipse.update.scheduler"; //$NON-NLS-1$
+	private static final String SDK_UI_PLUGIN_ID = "org.eclipse.equinox.p2.ui.sdk"; //$NON-NLS-1$
 
 	public static void migratePreferences() {
 		// Migrate preference values that were stored in alternate locations.
-		// 1) migrate from instance scope (during 3.5 development) to profile scope (final 3.5 format)
+		// 1) migrate from instance scope (during 3.5 development) to profile
+		// scope (final 3.5 format)
 		// 2) if applicable, migrate from 3.4 prefs kept in a different bundle
 		// 3) if applicable, migrate from 3.3 prefs known by Update Manager
 		Preferences pref = AutomaticUpdatePlugin.getPreferences();
@@ -48,42 +50,69 @@ public class PreferenceInitializer extends AbstractPreferenceInitializer {
 					StatusManager.LOG);
 		}
 
-		// Have we initialized the auto update prefs from previous
-		// releases?  
-		boolean autoUpdateInit = pref.getBoolean(
-				PreferenceConstants.PREF_AUTO_UPDATE_INIT, false);
-		if (!autoUpdateInit) {
+		// Have we migrated from 3.4 pref values?
+		boolean migrated34 = pref.getBoolean(
+				PreferenceConstants.PREF_MIGRATED_34, false);
+		boolean node34exists = false;
+		if (!migrated34) {
 			// first look for the 3.4 automatic update preferences, which were
 			// located in a different bundle than now, in the instance scope.
-			Preferences node34 = Platform.getPreferencesService().getRootNode()
-					.node(InstanceScope.SCOPE).node(
-							"org.eclipse.equinox.p2.ui.sdk"); //$NON-NLS-1$
-			if (node34 != null) {
+			Preferences instanceScope = Platform.getPreferencesService()
+					.getRootNode().node(InstanceScope.SCOPE);
+			try {
+				node34exists = instanceScope.nodeExists(SDK_UI_PLUGIN_ID);
+			} catch (BackingStoreException e1) {
+				// nothing to report, assume node does not exist
+			}
+			if (node34exists) {
+				Preferences node34 = instanceScope.node(SDK_UI_PLUGIN_ID);
 				// We only migrate the preferences associated with auto update.
 				// Other preferences still remain in that bundle and are handled
-				// there.
-				pref.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED,
-						node34.getBoolean("enabled", false));
-				pref.put(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, node34
-						.get("schedule",
-								PreferenceConstants.PREF_UPDATE_ON_STARTUP));
-				pref.putBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY, node34
-						.getBoolean("download", false));
-				pref.putBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE,
-						node34.getBoolean("remindOnSchedule", false)); //$NON-NLS-1$
-				pref
-						.put(
-								PreferenceConstants.PREF_REMIND_ELAPSED,
-								node34
-										.get(
-												"remindElapsedTime",
-												AutomaticUpdateMessages.AutomaticUpdateScheduler_30Minutes));
-				// mark the pref that says we've migrated
-				pref
-						.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_INIT,
-								true);
-				AutomaticUpdatePlugin.savePreferences();
+				// there. We don't migrate if the value was never set.
+				if (node34.get("enabled", null) == null) {
+					pref.putBoolean(
+							PreferenceConstants.PREF_AUTO_UPDATE_ENABLED,
+							node34.getBoolean("enabled", false));
+				}
+				if (node34.get("schedule", null) == null) {
+					pref
+							.put(
+									PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE,
+									node34
+											.get(
+													"schedule",
+													PreferenceConstants.PREF_UPDATE_ON_STARTUP));
+				}
+				if (node34.get("download", null) == null) {
+					pref.putBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY,
+							node34.getBoolean("download", false));
+				}
+				if (node34.get("remindOnSchedule", null) == null) {
+					pref.putBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE,
+							node34.getBoolean("remindOnSchedule", false)); //$NON-NLS-1$
+				}
+				if (node34.get("remindElapsedTime", null) == null) {
+
+					pref
+							.put(
+									PreferenceConstants.PREF_REMIND_ELAPSED,
+									node34
+											.get(
+													"remindElapsedTime",
+													AutomaticUpdateMessages.AutomaticUpdateScheduler_30Minutes));
+				}
 			}
+			// mark the pref that says we've migrated
+			pref.putBoolean(PreferenceConstants.PREF_MIGRATED_34, true);
+			AutomaticUpdatePlugin.savePreferences();
+		}
+		// pref used to track 3.3 migration
+		// Have we initialized the auto update prefs from previous
+		// releases?
+		boolean autoUpdateInit = pref.getBoolean(
+				PreferenceConstants.PREF_AUTO_UPDATE_INIT, false);
+
+		if (!migrated34 && !autoUpdateInit) {
 			// Look for the 3.3 UM automatic update preferences. We will
 			// not migrate them if we already pulled values from 3.4.
 			// However, we always want to turn off the UM automatic update
@@ -96,21 +125,21 @@ public class PreferenceInitializer extends AbstractPreferenceInitializer {
 				Preferences prefUM = instanceScope.node(UPDATE_PLUGIN_ID);
 				boolean enableUpdate = prefUM.getBoolean(P_ENABLED, false);
 				// set p2 automatic update preference to match UM preference,
-				// only if we haven't already used 3.4 values
-				if (node34 == null) {
+				// only if we haven't already set a value.
+				if (pref.get(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, null) == null) {
 					pref.putBoolean(
 							PreferenceConstants.PREF_AUTO_UPDATE_ENABLED,
 							enableUpdate);
-					// mark the pref that says we migrated
-					pref.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_INIT,
-							true);
-					AutomaticUpdatePlugin.savePreferences();
 				}
 				// turn off UM automatic update preference if it exists
 				if (updateNodeExists) {
 					prefUM.putBoolean(P_ENABLED, false);
 					prefUM.flush();
 				}
+				// mark the pref that says we migrated
+				pref.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_INIT,
+						true);
+				AutomaticUpdatePlugin.savePreferences();
 			} catch (BackingStoreException e) {
 				ProvUI.handleException(e,
 						AutomaticUpdateMessages.ErrorSavingClassicPreferences,
@@ -118,13 +147,17 @@ public class PreferenceInitializer extends AbstractPreferenceInitializer {
 			}
 		}
 	}
+
 	public void initializeDefaultPreferences() {
 		// initialize the default scope
-		Preferences node = new DefaultScope().getNode(AutomaticUpdatePlugin.PLUGIN_ID);
+		Preferences node = new DefaultScope()
+				.getNode(AutomaticUpdatePlugin.PLUGIN_ID);
 		node.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, false);
-		node.put(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_STARTUP);
+		node.put(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE,
+				PreferenceConstants.PREF_UPDATE_ON_STARTUP);
 		node.putBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY, false);
 		node.putBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE, false);
-		node.put(PreferenceConstants.PREF_REMIND_ELAPSED, AutomaticUpdateMessages.AutomaticUpdateScheduler_30Minutes);
+		node.put(PreferenceConstants.PREF_REMIND_ELAPSED,
+				AutomaticUpdateMessages.AutomaticUpdateScheduler_30Minutes);
 	}
 }
