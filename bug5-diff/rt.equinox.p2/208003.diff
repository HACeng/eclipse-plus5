commit bc3182cfd26cbd07646491d55420a15aeffaac7d
Author: Dave Stevenson <dstevenso>
Date:   Tue Nov 6 21:26:57 2007 +0000

    Fix for bug 208003 - Many versions of "self" capability in repository.
    
    Change InstallableUnit and InstallableUnitFragment so that do implicitly add the self and fragment capabilities. Changed the metadata generator and test to always explicitly add the appropriate self and fragment capabilities. Did some restructuring in the automated tests so that most creation of IUs use utilities that handle the capabilities appropriately.
    
    Reorganized the xml write/parsers so that reading and writing of IUs can share code (in metadata repositories and the metadata cache).
    
    Miscellaneous cleanup related to the xstream removal.

0	560	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryIO.java
1	1	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepository.java
4	1	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepositoryFactory.java
506	0	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepositoryIO.java
25	9	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/core/helpers/XMLParser.java
1	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/core/helpers/XMLWriter.java
7	0	bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
0	8	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/SimpleProfileRegistry.java
10	613	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/InstallRegistry.java
103	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/MetadataCache.java
2	0	bundles/org.eclipse.equinox.p2.exemplarysetup/META-INF/MANIFEST.MF
25	2	bundles/org.eclipse.equinox.p2.exemplarysetup/src/org/eclipse/equinox/internal/p2/exemplarysetup/Activator.java
1	1	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
3	2	bundles/org.eclipse.equinox.p2.metadata.repository/META-INF/MANIFEST.MF
10	10	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
25	31	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataCache.java
56	710	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryIO.java
14	13	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryManager.java
5	4	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/SimpleMetadataRepositoryFactory.java
13	12	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/URLMetadataRepository.java
438	0	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
169	0	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
72	0	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/XMLConstants.java
3	2	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IInstallableUnit.java
143	137	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/InstallableUnit.java
15	26	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/InstallableUnitFragment.java
134	14	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
25	54	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/AutomatedDirectorTest.java
7	17	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/OracleTest.java
5	15	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/OracleTest2.java
12	24	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/SingletonTest.java
1	4	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UninstallTest.java
5	15	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UpdateTest.java
12	34	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentTest.java
8	33	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/MultipleIUAndFragmentTest.java
0	8	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/OldTest.java
2	9	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/RecommendationTest.java
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryIO.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryIO.java
deleted file mode 100644
index 77d16b8..0000000
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryIO.java
+++ /dev/null
@@ -1,560 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.artifact.repository;
-
-import java.io.*;
-import java.util.*;
-import javax.xml.parsers.ParserConfigurationException;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
-import org.eclipse.equinox.p2.artifact.repository.ArtifactDescriptor;
-import org.eclipse.equinox.p2.artifact.repository.IArtifactRepository;
-import org.eclipse.equinox.p2.artifact.repository.processing.ProcessingStepDescriptor;
-import org.eclipse.equinox.p2.core.helpers.*;
-import org.eclipse.equinox.p2.core.repository.RepositoryCreationException;
-import org.eclipse.equinox.p2.metadata.IArtifactKey;
-import org.eclipse.osgi.service.resolver.VersionRange;
-import org.eclipse.osgi.util.NLS;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.Version;
-import org.xml.sax.*;
-
-/**
- * This class reads and writes artifact repository metadata
- * (e.g. table of contents files);
- * 
- * This class is not used for reading or writing the actual artifacts.
- * 
- * The implementation currently uses XStream.
- */
-
-// TODO: this class should be renamed to SimpleArtifactRepositoryIO
-//		 when the use of XStream is eliminated.
-// TODO: Should a registration/factory mechanism be supported
-//		 for getting a repository reader/writer given a repository type
-class ArtifactRepositoryIO {
-
-	/**
-	 * Writes the given artifact repository to the stream.
-	 * This method performs buffering, and closes the stream when finished.
-	 * 
-	 * Persistence implementation using XStream
-	 * @deprecated
-	 */
-	public static void write(SimpleArtifactRepository repository, OutputStream output) {
-		ArtifactRepositoryIO io = new ArtifactRepositoryIO();
-		io.writeNew(repository, output);
-		//		XStream stream = new XStream();
-		//		OutputStream bufferedOutput = null;
-		//		try {
-		//			try {
-		//				bufferedOutput = new BufferedOutputStream(output);
-		//				stream.toXML(repository, bufferedOutput);
-		//			} finally {
-		//				if (bufferedOutput != null) {
-		//					bufferedOutput.close();
-		//				}
-		//			}
-		//		} catch (FileNotFoundException e) {
-		//			// TODO Auto-generated catch block
-		//			e.printStackTrace();
-		//		} catch (IOException e) {
-		//			// TODO Auto-generated catch block
-		//			e.printStackTrace();
-		//		}
-	}
-
-	/**
-	 * Write the given SimpleArtifactRrepository to the given stream.
-	 * This method closes the stream when finished.
-	 */
-	public void writeNew(SimpleArtifactRepository repository, OutputStream output) {
-		OutputStream bufferedOutput = null;
-		try {
-			try {
-				bufferedOutput = new BufferedOutputStream(output);
-				Writer repositoryWriter = new Writer(bufferedOutput);
-				repositoryWriter.write(repository);
-			} finally {
-				if (bufferedOutput != null) {
-					bufferedOutput.close();
-				}
-			}
-		} catch (IOException ioe) {
-			// TODO shouldn't this throw a core exception?
-			ioe.printStackTrace();
-		}
-	}
-
-	/**
-	 * Reads the artifact repository from the given stream,
-	 * and returns the contained array of abstract artifact repositories.
-	 * 
-	 * This method performs buffering, and closes the stream when finished.
-	 * 
-	 * Persistence implementation using XStream
-	 * @deprecated
-	 */
-	public static IArtifactRepository read(InputStream input) throws RepositoryCreationException {
-		ArtifactRepositoryIO io = new ArtifactRepositoryIO();
-		return io.readNew(input);
-		//		XStream stream = new XStream();
-		//		BufferedInputStream bufferedInput = null;
-		//		try {
-		//			try {
-		//				bufferedInput = new BufferedInputStream(input);
-		//				return (IArtifactRepository) stream.fromXML(bufferedInput);
-		//			} finally {
-		//				if (bufferedInput != null)
-		//					bufferedInput.close();
-		//			}
-		//		} catch (IOException e) {
-		//			throw new RepositoryCreationException(e);
-		//		}
-	}
-
-	/**
-	 * Construct a SimpleArtifactRepository by reading from the given stream.
-	 * This method closes the stream when finished.
-	 */
-	public SimpleArtifactRepository readNew(InputStream input) throws RepositoryCreationException {
-		BufferedInputStream bufferedInput = null;
-		try {
-			try {
-				bufferedInput = new BufferedInputStream(input);
-				Parser repositoryParser = new Parser(Activator.getContext(), Activator.ID);
-				repositoryParser.parse(input);
-				if (!repositoryParser.isValidXML()) {
-					throw new RepositoryCreationException(new CoreException(repositoryParser.getStatus()));
-				}
-				return repositoryParser.getRepository();
-			} finally {
-				if (bufferedInput != null)
-					bufferedInput.close();
-			}
-		} catch (IOException ioe) {
-			throw new RepositoryCreationException(ioe);
-		}
-	}
-
-	private interface XMLConstants extends org.eclipse.equinox.p2.core.helpers.XMLConstants {
-
-		// Constants defining the structure of the XML for a SimpleArtifactRepository
-
-		// A format version number for simple artifact repository XML.
-		public static final String XML_VERSION = "0.0.1"; //$NON-NLS-1$
-		public static final Version CURRENT_VERSION = new Version(XML_VERSION);
-		public static final VersionRange XML_TOLERANCE = new VersionRange(CURRENT_VERSION, true, CURRENT_VERSION, true);
-
-		// Constants for processing instructions
-		public static final String PI_REPOSITORY_TARGET = "artifactRepository"; //$NON-NLS-1$
-		public static XMLWriter.ProcessingInstruction[] PI_DEFAULTS = new XMLWriter.ProcessingInstruction[] {XMLWriter.ProcessingInstruction.makeClassVersionInstruction(PI_REPOSITORY_TARGET, SimpleArtifactRepository.class, CURRENT_VERSION)};
-
-		// Constants for artifact repository elements
-		public static final String REPOSITORY_ELEMENT = "repository"; //$NON-NLS-1$
-		public static final String MAPPING_RULES_ELEMENT = "mappings"; //$NON-NLS-1$
-		public static final String MAPPING_RULE_ELEMENT = "rule"; //$NON-NLS-1$
-		public static final String ARTIFACTS_ELEMENT = "artifacts"; //$NON-NLS-1$
-		public static final String ARTIFACT_ELEMENT = "artifact"; //$NON-NLS-1$
-		public static final String PROCESSING_STEPS_ELEMENT = "processing"; //$NON-NLS-1$
-		public static final String PROCESSING_STEP_ELEMENT = "step"; //$NON-NLS-1$
-
-		// Constants for attributes of artifact repository elements
-		public static final String VERIFY_SIGNATURE_ATTRIBUTE = "verify"; //$NON-NLS-1$
-
-		public static final String MAPPING_RULE_FILTER_ATTRIBUTE = "filter"; //$NON-NLS-1$
-		public static final String MAPPING_RULE_OUTPUT_ATTRIBUTE = "output"; //$NON-NLS-1$
-
-		public static final String ARTIFACT_NAMESPACE_ATTRIBUTE = NAMESPACE_ATTRIBUTE;
-		public static final String ARTIFACT_CLASSIFIER_ATTRIBUTE = CLASSIFIER_ATTRIBUTE;
-
-		public static final String STEP_DATA_ATTRIBUTE = "data"; //$NON-NLS-1$
-		public static final String STEP_REQUIRED_ATTRIBUTE = "required"; //$NON-NLS-1$
-	}
-
-	// XML writer for a SimpleArtifactRepository
-	protected class Writer extends XMLWriter implements XMLConstants {
-
-		public Writer(OutputStream output) throws IOException {
-			super(output, PI_DEFAULTS);
-		}
-
-		/**
-		 * Write the given artifact repository to the output stream.
-		 */
-		public void write(SimpleArtifactRepository repository) {
-			start(REPOSITORY_ELEMENT);
-			attribute(NAME_ATTRIBUTE, repository.getName());
-			attribute(TYPE_ATTRIBUTE, repository.getType());
-			attribute(VERSION_ATTRIBUTE, repository.getVersion());
-			attributeOptional(PROVIDER_ATTRIBUTE, repository.getProvider());
-			attributeOptional(DESCRIPTION_ATTRIBUTE, repository.getDescription()); // TODO: could be cdata?
-			attribute(VERIFY_SIGNATURE_ATTRIBUTE, repository.getSignatureVerification(), false);
-
-			writeProperties(repository.getProperties());
-			writeMappingRules(repository.getRules());
-			writeArtifacts(repository.getDescriptors());
-
-			end(REPOSITORY_ELEMENT);
-			flush();
-		}
-
-		private void writeMappingRules(String[][] rules) {
-			if (rules.length > 0) {
-				start(MAPPING_RULES_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, rules.length);
-				for (int i = 0; i < rules.length; i++) {
-					start(MAPPING_RULE_ELEMENT);
-					attribute(MAPPING_RULE_FILTER_ATTRIBUTE, rules[i][0]);
-					attribute(MAPPING_RULE_OUTPUT_ATTRIBUTE, rules[i][1]);
-					end(MAPPING_RULE_ELEMENT);
-				}
-				end(MAPPING_RULES_ELEMENT);
-			}
-		}
-
-		private void writeArtifacts(Set artifactDescriptors) {
-			start(ARTIFACTS_ELEMENT);
-			attribute(COLLECTION_SIZE_ATTRIBUTE, artifactDescriptors.size());
-			for (Iterator iter = artifactDescriptors.iterator(); iter.hasNext();) {
-				ArtifactDescriptor descriptor = (ArtifactDescriptor) iter.next();
-				IArtifactKey key = descriptor.getArtifactKey();
-				start(ARTIFACT_ELEMENT);
-				attribute(ARTIFACT_NAMESPACE_ATTRIBUTE, key.getNamespace());
-				attribute(ARTIFACT_CLASSIFIER_ATTRIBUTE, key.getClassifier());
-				attribute(ID_ATTRIBUTE, key.getId());
-				attribute(VERSION_ATTRIBUTE, key.getVersion());
-				writeProcessingSteps(descriptor.getProcessingSteps());
-				writeProperties(descriptor.getProperties());
-				end(ARTIFACT_ELEMENT);
-			}
-			end(ARTIFACTS_ELEMENT);
-		}
-
-		private void writeProcessingSteps(ProcessingStepDescriptor[] processingSteps) {
-			if (processingSteps.length > 0) {
-				start(PROCESSING_STEPS_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, processingSteps.length);
-				for (int i = 0; i < processingSteps.length; i++) {
-					start(PROCESSING_STEP_ELEMENT);
-					attribute(ID_ATTRIBUTE, processingSteps[i].getProcessorId());
-					attribute(STEP_DATA_ATTRIBUTE, processingSteps[i].getData());
-					attribute(STEP_REQUIRED_ATTRIBUTE, processingSteps[i].isRequired());
-					end(PROCESSING_STEP_ELEMENT);
-				}
-				end(PROCESSING_STEPS_ELEMENT);
-			}
-		}
-	}
-
-	/*
-	 * Parser for the contents of a SimpleArtifactRepository,
-	 * as written by the Writer class.
-	 */
-	private class Parser extends XMLParser implements XMLConstants {
-
-		private SimpleArtifactRepository theRepository = null;
-
-		public Parser(BundleContext context, String bundleId) {
-			super(context, bundleId);
-		}
-
-		public void parse(File file) throws IOException {
-			parse(new FileInputStream(file));
-		}
-
-		public synchronized void parse(InputStream stream) throws IOException {
-			this.status = null;
-			try {
-				// TODO: currently not caching the parser since we make no assumptions
-				//		 or restrictions on concurrent parsing
-				getParser();
-				RepositoryHandler repositoryHandler = new RepositoryHandler();
-				xmlReader.setContentHandler(new RepositoryDocHandler(REPOSITORY_ELEMENT, repositoryHandler));
-				xmlReader.parse(new InputSource(stream));
-				if (isValidXML()) {
-					theRepository = repositoryHandler.getRepository();
-				}
-			} catch (SAXException e) {
-				throw new IOException(e.getMessage());
-			} catch (ParserConfigurationException e) {
-				throw new IOException(e.getMessage());
-			} finally {
-				stream.close();
-			}
-		}
-
-		public SimpleArtifactRepository getRepository() {
-			return theRepository;
-		}
-
-		protected Object getRootObject() {
-			return theRepository;
-		}
-
-		private final class RepositoryDocHandler extends DocHandler {
-
-			public RepositoryDocHandler(String rootName, RootHandler rootHandler) {
-				super(rootName, rootHandler);
-			}
-
-			public void ProcessingInstruction(String target, String data) throws SAXException {
-				if (PI_REPOSITORY_TARGET.equalsIgnoreCase(target)) {
-					// TODO: should the root handler be constructed based on class
-					// 		 via an extension registry mechanism?
-					// String clazz = extractPIClass(data);
-					// and
-					// TODO: version tolerance by extension
-					Version repositoryVersion = extractPIVersion(target, data);
-					if (!XML_TOLERANCE.isIncluded(repositoryVersion)) {
-						throw new SAXException(NLS.bind(Messages.SimpleArtifactRepositoryIO_Parser_Has_Incompatible_Version, repositoryVersion, XML_TOLERANCE));
-					}
-				}
-			}
-
-		}
-
-		private final class RepositoryHandler extends RootHandler {
-
-			private final String[] required = new String[] {NAME_ATTRIBUTE, TYPE_ATTRIBUTE, VERSION_ATTRIBUTE};
-			private final String[] optional = new String[] {DESCRIPTION_ATTRIBUTE, PROVIDER_ATTRIBUTE, VERIFY_SIGNATURE_ATTRIBUTE};
-
-			private String[] attrValues = new String[required.length + optional.length];
-
-			private MappingRulesHandler mappingRulesHandler = null;
-			private PropertiesHandler propertiesHandler = null;
-			private ArtifactsHandler artifactsHandler = null;
-
-			private SimpleArtifactRepository repository = null;
-
-			public RepositoryHandler() {
-				super();
-			}
-
-			public SimpleArtifactRepository getRepository() {
-				return repository;
-			}
-
-			protected void handleRootAttributes(Attributes attributes) {
-				attrValues = parseAttributes(attributes, required, optional);
-				attrValues[2] = checkVersion(REPOSITORY_ELEMENT, VERSION_ATTRIBUTE, attrValues[2]).toString();
-				attrValues[5] = checkBoolean(REPOSITORY_ELEMENT, VERIFY_SIGNATURE_ATTRIBUTE, attrValues[5], false).toString();
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (MAPPING_RULES_ELEMENT.equalsIgnoreCase(name)) {
-					if (mappingRulesHandler == null) {
-						mappingRulesHandler = new MappingRulesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (ARTIFACTS_ELEMENT.equalsIgnoreCase(name)) {
-					if (artifactsHandler == null) {
-						artifactsHandler = new ArtifactsHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (PROPERTIES_ELEMENT.equalsIgnoreCase(name)) {
-					if (propertiesHandler == null) {
-						propertiesHandler = new PropertiesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			protected void finished() {
-				if (isValidXML()) {
-					String[][] mappingRules = (mappingRulesHandler == null ? new String[0][0] //
-							: mappingRulesHandler.getMappingRules());
-					OrderedProperties properties = (propertiesHandler == null ? new OrderedProperties(0) //
-							: propertiesHandler.getProperties());
-					Set artifacts = (artifactsHandler == null ? new HashSet(0) //
-							: artifactsHandler.getArtifacts());
-					boolean verifySignature = (attrValues[5] == null ? false //
-							: new Boolean(attrValues[5]).booleanValue());
-					repository = new SimpleArtifactRepository(attrValues[0], attrValues[1], attrValues[2], attrValues[3], //
-							attrValues[4], verifySignature, artifacts, mappingRules, properties);
-				}
-			}
-		}
-
-		protected class MappingRulesHandler extends AbstractHandler {
-
-			private List mappingRules;
-
-			public MappingRulesHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, MAPPING_RULES_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				mappingRules = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public String[][] getMappingRules() {
-				String[][] rules = new String[mappingRules.size()][2];
-				for (int index = 0; index < mappingRules.size(); index++) {
-					String[] ruleAttributes = (String[]) mappingRules.get(index);
-					rules[index] = ruleAttributes;
-				}
-				return rules;
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(MAPPING_RULE_ELEMENT)) {
-					new MappingRuleHandler(this, attributes, mappingRules);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class MappingRuleHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {MAPPING_RULE_FILTER_ATTRIBUTE, MAPPING_RULE_OUTPUT_ATTRIBUTE};
-
-			public MappingRuleHandler(AbstractHandler parentHandler, Attributes attributes, List mappingRules) {
-				super(parentHandler, MAPPING_RULE_ELEMENT);
-				mappingRules.add(parseRequiredAttributes(attributes, required));
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				invalidElement(name, attributes);
-			}
-		}
-
-		protected class ArtifactsHandler extends AbstractHandler {
-
-			private Set artifacts;
-
-			public ArtifactsHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, ARTIFACTS_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				artifacts = (size != null ? new LinkedHashSet(new Integer(size).intValue()) : new LinkedHashSet(4));
-			}
-
-			public Set getArtifacts() {
-				return artifacts;
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(ARTIFACT_ELEMENT)) {
-					new ArtifactHandler(this, attributes, artifacts);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class ArtifactHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {ARTIFACT_NAMESPACE_ATTRIBUTE, ARTIFACT_CLASSIFIER_ATTRIBUTE, ID_ATTRIBUTE, VERSION_ATTRIBUTE};
-
-			private Set artifacts;
-			ArtifactDescriptor currentArtifact = null;
-
-			private PropertiesHandler propertiesHandler = null;
-			private ProcessingStepsHandler processingStepsHandler = null;
-
-			public ArtifactHandler(AbstractHandler parentHandler, Attributes attributes, Set artifacts) {
-				super(parentHandler, ARTIFACT_ELEMENT);
-				this.artifacts = artifacts;
-				String[] values = parseRequiredAttributes(attributes, required);
-				Version version = checkVersion(ARTIFACT_ELEMENT, VERSION_ATTRIBUTE, values[3]);
-				// TODO: resolve access restriction on ArtifactKey construction
-				currentArtifact = new ArtifactDescriptor(new ArtifactKey(values[0], values[1], values[2], version));
-			}
-
-			public ArtifactDescriptor getArtifact() {
-				return currentArtifact;
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (PROCESSING_STEPS_ELEMENT.equalsIgnoreCase(name)) {
-					if (processingStepsHandler == null) {
-						processingStepsHandler = new ProcessingStepsHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (PROPERTIES_ELEMENT.equalsIgnoreCase(name)) {
-					if (propertiesHandler == null) {
-						propertiesHandler = new PropertiesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			protected void finished() {
-				if (isValidXML() && currentArtifact != null) {
-					OrderedProperties properties = (propertiesHandler == null ? new OrderedProperties(0) //
-							: propertiesHandler.getProperties());
-					currentArtifact.addProperties(properties);
-					ProcessingStepDescriptor[] processingSteps = (processingStepsHandler == null ? new ProcessingStepDescriptor[0] //
-							: processingStepsHandler.getProcessingSteps());
-					currentArtifact.setProcessingSteps(processingSteps);
-					artifacts.add(currentArtifact);
-				}
-			}
-		}
-
-		protected class ProcessingStepsHandler extends AbstractHandler {
-
-			private List processingSteps;
-
-			public ProcessingStepsHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, PROCESSING_STEPS_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				processingSteps = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public ProcessingStepDescriptor[] getProcessingSteps() {
-				return (ProcessingStepDescriptor[]) processingSteps.toArray(new ProcessingStepDescriptor[processingSteps.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(PROCESSING_STEP_ELEMENT)) {
-					new ProcessingStepHandler(this, attributes, processingSteps);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class ProcessingStepHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {ID_ATTRIBUTE, STEP_DATA_ATTRIBUTE, STEP_REQUIRED_ATTRIBUTE};
-
-			public ProcessingStepHandler(AbstractHandler parentHandler, Attributes attributes, List processingSteps) {
-				super(parentHandler, PROCESSING_STEP_ELEMENT);
-				String[] attributeValues = parseRequiredAttributes(attributes, required);
-				processingSteps.add(new ProcessingStepDescriptor(attributeValues[0], attributeValues[1], checkBoolean(PROCESSING_STEP_ELEMENT, STEP_REQUIRED_ATTRIBUTE, attributeValues[2]).booleanValue()));
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				invalidElement(name, attributes);
-			}
-		}
-
-		protected String getErrorMessage() {
-			return Messages.SimpleArtifactRepositoryIO_Parser_Error_Parsing_Repository;
-		}
-
-		public String toString() {
-			// TODO:
-			return null;
-		}
-
-	}
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepository.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepository.java
index d318d04..c09f914 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepository.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepository.java
@@ -319,7 +319,7 @@ public class SimpleArtifactRepository extends AbstractArtifactRepository impleme
 		try {
 			URL actualLocation = getActualLocation(location);
 			FileOutputStream os = new FileOutputStream(actualLocation.getFile());
-			ArtifactRepositoryIO.write(this, os);
+			new SimpleArtifactRepositoryIO().write(this, os);
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepositoryFactory.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepositoryFactory.java
index e8df779..0dfd128 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepositoryFactory.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepositoryFactory.java
@@ -25,7 +25,8 @@ public class SimpleArtifactRepositoryFactory implements IArtifactRepositoryFacto
 			InputStream descriptorStream = null;
 			try {
 				descriptorStream = new BufferedInputStream(SimpleArtifactRepository.getActualLocation(location).openStream());
-				SimpleArtifactRepository result = (SimpleArtifactRepository) ArtifactRepositoryIO.read(descriptorStream);
+				SimpleArtifactRepositoryIO io = new SimpleArtifactRepositoryIO();
+				SimpleArtifactRepository result = (SimpleArtifactRepository) io.read(descriptorStream);
 				result.initializeAfterLoad(location);
 				return result;
 			} catch (RepositoryCreationException e) {
@@ -36,6 +37,8 @@ public class SimpleArtifactRepositoryFactory implements IArtifactRepositoryFacto
 					descriptorStream.close();
 			}
 		} catch (IOException e) {
+			// TODO: should this distinguish between non-existent file
+			//		 and other IO exceptions.
 		}
 		return null;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepositoryIO.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepositoryIO.java
new file mode 100644
index 0000000..5182b3a
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/SimpleArtifactRepositoryIO.java
@@ -0,0 +1,506 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.artifact.repository;
+
+import java.io.*;
+import java.util.*;
+import javax.xml.parsers.ParserConfigurationException;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
+import org.eclipse.equinox.p2.artifact.repository.ArtifactDescriptor;
+import org.eclipse.equinox.p2.artifact.repository.IArtifactRepository;
+import org.eclipse.equinox.p2.artifact.repository.processing.ProcessingStepDescriptor;
+import org.eclipse.equinox.p2.core.helpers.*;
+import org.eclipse.equinox.p2.core.repository.RepositoryCreationException;
+import org.eclipse.equinox.p2.metadata.IArtifactKey;
+import org.eclipse.osgi.service.resolver.VersionRange;
+import org.eclipse.osgi.util.NLS;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Version;
+import org.xml.sax.*;
+
+/**
+ * This class reads and writes artifact repository metadata
+ * (e.g. table of contents files);
+ * 
+ * This class is not used for reading or writing the actual artifacts.
+ */
+
+// TODO: Should a registration/factory mechanism be supported
+//		 for getting a repository reader/writer given a repository type
+class SimpleArtifactRepositoryIO {
+
+	/**
+	 * Writes the given artifact repository to the stream.
+	 * This method performs buffering, and closes the stream when finished.
+	 */
+	public void write(SimpleArtifactRepository repository, OutputStream output) {
+		OutputStream bufferedOutput = null;
+		try {
+			try {
+				bufferedOutput = new BufferedOutputStream(output);
+				Writer repositoryWriter = new Writer(bufferedOutput);
+				repositoryWriter.write(repository);
+			} finally {
+				if (bufferedOutput != null) {
+					bufferedOutput.close();
+				}
+			}
+		} catch (IOException ioe) {
+			// TODO shouldn't this throw a core exception?
+			ioe.printStackTrace();
+		}
+	}
+
+	/**
+	 * Reads the artifact repository from the given stream,
+	 * and returns the contained array of abstract artifact repositories.
+	 * 
+	 * This method performs buffering, and closes the stream when finished.
+	 */
+	public IArtifactRepository read(InputStream input) throws RepositoryCreationException {
+		BufferedInputStream bufferedInput = null;
+		try {
+			try {
+				bufferedInput = new BufferedInputStream(input);
+				Parser repositoryParser = new Parser(Activator.getContext(), Activator.ID);
+				repositoryParser.parse(input);
+				if (!repositoryParser.isValidXML()) {
+					throw new RepositoryCreationException(new CoreException(repositoryParser.getStatus()));
+				}
+				return repositoryParser.getRepository();
+			} finally {
+				if (bufferedInput != null)
+					bufferedInput.close();
+			}
+		} catch (IOException ioe) {
+			throw new RepositoryCreationException(ioe);
+		}
+	}
+
+	private interface XMLConstants extends org.eclipse.equinox.p2.core.helpers.XMLConstants {
+
+		// Constants defining the structure of the XML for a SimpleArtifactRepository
+
+		// A format version number for simple artifact repository XML.
+		public static final String XML_VERSION = "0.0.1"; //$NON-NLS-1$
+		public static final Version CURRENT_VERSION = new Version(XML_VERSION);
+		public static final VersionRange XML_TOLERANCE = new VersionRange(CURRENT_VERSION, true, CURRENT_VERSION, true);
+
+		// Constants for processing instructions
+		public static final String PI_REPOSITORY_TARGET = "artifactRepository"; //$NON-NLS-1$
+		public static XMLWriter.ProcessingInstruction[] PI_DEFAULTS = new XMLWriter.ProcessingInstruction[] {XMLWriter.ProcessingInstruction.makeClassVersionInstruction(PI_REPOSITORY_TARGET, SimpleArtifactRepository.class, CURRENT_VERSION)};
+
+		// Constants for artifact repository elements
+		public static final String REPOSITORY_ELEMENT = "repository"; //$NON-NLS-1$
+		public static final String MAPPING_RULES_ELEMENT = "mappings"; //$NON-NLS-1$
+		public static final String MAPPING_RULE_ELEMENT = "rule"; //$NON-NLS-1$
+		public static final String ARTIFACTS_ELEMENT = "artifacts"; //$NON-NLS-1$
+		public static final String ARTIFACT_ELEMENT = "artifact"; //$NON-NLS-1$
+		public static final String PROCESSING_STEPS_ELEMENT = "processing"; //$NON-NLS-1$
+		public static final String PROCESSING_STEP_ELEMENT = "step"; //$NON-NLS-1$
+
+		// Constants for attributes of artifact repository elements
+		public static final String VERIFY_SIGNATURE_ATTRIBUTE = "verify"; //$NON-NLS-1$
+
+		public static final String MAPPING_RULE_FILTER_ATTRIBUTE = "filter"; //$NON-NLS-1$
+		public static final String MAPPING_RULE_OUTPUT_ATTRIBUTE = "output"; //$NON-NLS-1$
+
+		public static final String ARTIFACT_NAMESPACE_ATTRIBUTE = NAMESPACE_ATTRIBUTE;
+		public static final String ARTIFACT_CLASSIFIER_ATTRIBUTE = CLASSIFIER_ATTRIBUTE;
+
+		public static final String STEP_DATA_ATTRIBUTE = "data"; //$NON-NLS-1$
+		public static final String STEP_REQUIRED_ATTRIBUTE = "required"; //$NON-NLS-1$
+	}
+
+	// XML writer for a SimpleArtifactRepository
+	protected class Writer extends XMLWriter implements XMLConstants {
+
+		public Writer(OutputStream output) throws IOException {
+			super(output, PI_DEFAULTS);
+		}
+
+		/**
+		 * Write the given artifact repository to the output stream.
+		 */
+		public void write(SimpleArtifactRepository repository) {
+			start(REPOSITORY_ELEMENT);
+			attribute(NAME_ATTRIBUTE, repository.getName());
+			attribute(TYPE_ATTRIBUTE, repository.getType());
+			attribute(VERSION_ATTRIBUTE, repository.getVersion());
+			attributeOptional(PROVIDER_ATTRIBUTE, repository.getProvider());
+			attributeOptional(DESCRIPTION_ATTRIBUTE, repository.getDescription()); // TODO: could be cdata?
+			attribute(VERIFY_SIGNATURE_ATTRIBUTE, repository.getSignatureVerification(), false);
+
+			writeProperties(repository.getProperties());
+			writeMappingRules(repository.getRules());
+			writeArtifacts(repository.getDescriptors());
+
+			end(REPOSITORY_ELEMENT);
+			flush();
+		}
+
+		private void writeMappingRules(String[][] rules) {
+			if (rules.length > 0) {
+				start(MAPPING_RULES_ELEMENT);
+				attribute(COLLECTION_SIZE_ATTRIBUTE, rules.length);
+				for (int i = 0; i < rules.length; i++) {
+					start(MAPPING_RULE_ELEMENT);
+					attribute(MAPPING_RULE_FILTER_ATTRIBUTE, rules[i][0]);
+					attribute(MAPPING_RULE_OUTPUT_ATTRIBUTE, rules[i][1]);
+					end(MAPPING_RULE_ELEMENT);
+				}
+				end(MAPPING_RULES_ELEMENT);
+			}
+		}
+
+		private void writeArtifacts(Set artifactDescriptors) {
+			start(ARTIFACTS_ELEMENT);
+			attribute(COLLECTION_SIZE_ATTRIBUTE, artifactDescriptors.size());
+			for (Iterator iter = artifactDescriptors.iterator(); iter.hasNext();) {
+				ArtifactDescriptor descriptor = (ArtifactDescriptor) iter.next();
+				IArtifactKey key = descriptor.getArtifactKey();
+				start(ARTIFACT_ELEMENT);
+				attribute(ARTIFACT_NAMESPACE_ATTRIBUTE, key.getNamespace());
+				attribute(ARTIFACT_CLASSIFIER_ATTRIBUTE, key.getClassifier());
+				attribute(ID_ATTRIBUTE, key.getId());
+				attribute(VERSION_ATTRIBUTE, key.getVersion());
+				writeProcessingSteps(descriptor.getProcessingSteps());
+				writeProperties(descriptor.getProperties());
+				end(ARTIFACT_ELEMENT);
+			}
+			end(ARTIFACTS_ELEMENT);
+		}
+
+		private void writeProcessingSteps(ProcessingStepDescriptor[] processingSteps) {
+			if (processingSteps.length > 0) {
+				start(PROCESSING_STEPS_ELEMENT);
+				attribute(COLLECTION_SIZE_ATTRIBUTE, processingSteps.length);
+				for (int i = 0; i < processingSteps.length; i++) {
+					start(PROCESSING_STEP_ELEMENT);
+					attribute(ID_ATTRIBUTE, processingSteps[i].getProcessorId());
+					attribute(STEP_DATA_ATTRIBUTE, processingSteps[i].getData());
+					attribute(STEP_REQUIRED_ATTRIBUTE, processingSteps[i].isRequired());
+					end(PROCESSING_STEP_ELEMENT);
+				}
+				end(PROCESSING_STEPS_ELEMENT);
+			}
+		}
+	}
+
+	/*
+	 * Parser for the contents of a SimpleArtifactRepository,
+	 * as written by the Writer class.
+	 */
+	private class Parser extends XMLParser implements XMLConstants {
+
+		private SimpleArtifactRepository theRepository = null;
+
+		public Parser(BundleContext context, String bundleId) {
+			super(context, bundleId);
+		}
+
+		public void parse(File file) throws IOException {
+			parse(new FileInputStream(file));
+		}
+
+		public synchronized void parse(InputStream stream) throws IOException {
+			this.status = null;
+			try {
+				// TODO: currently not caching the parser since we make no assumptions
+				//		 or restrictions on concurrent parsing
+				getParser();
+				RepositoryHandler repositoryHandler = new RepositoryHandler();
+				xmlReader.setContentHandler(new RepositoryDocHandler(REPOSITORY_ELEMENT, repositoryHandler));
+				xmlReader.parse(new InputSource(stream));
+				if (isValidXML()) {
+					theRepository = repositoryHandler.getRepository();
+				}
+			} catch (SAXException e) {
+				throw new IOException(e.getMessage());
+			} catch (ParserConfigurationException e) {
+				throw new IOException(e.getMessage());
+			} finally {
+				stream.close();
+			}
+		}
+
+		public void ProcessingInstruction(String target, String data) throws SAXException {
+			int j = 17;
+			j++;
+		}
+
+		public SimpleArtifactRepository getRepository() {
+			return theRepository;
+		}
+
+		protected Object getRootObject() {
+			return theRepository;
+		}
+
+		private final class RepositoryDocHandler extends DocHandler {
+
+			public RepositoryDocHandler(String rootName, RootHandler rootHandler) {
+				super(rootName, rootHandler);
+			}
+
+			public void ProcessingInstruction(String target, String data) throws SAXException {
+				if (PI_REPOSITORY_TARGET.equalsIgnoreCase(target)) {
+					// TODO: should the root handler be constructed based on class
+					// 		 via an extension registry mechanism?
+					// String clazz = extractPIClass(data);
+					// and
+					// TODO: version tolerance by extension
+					Version repositoryVersion = extractPIVersion(target, data);
+					if (!XML_TOLERANCE.isIncluded(repositoryVersion)) {
+						throw new SAXException(NLS.bind(Messages.SimpleArtifactRepositoryIO_Parser_Has_Incompatible_Version, repositoryVersion, XML_TOLERANCE));
+					}
+				}
+			}
+
+		}
+
+		private final class RepositoryHandler extends RootHandler {
+
+			private final String[] required = new String[] {NAME_ATTRIBUTE, TYPE_ATTRIBUTE, VERSION_ATTRIBUTE};
+			private final String[] optional = new String[] {DESCRIPTION_ATTRIBUTE, PROVIDER_ATTRIBUTE, VERIFY_SIGNATURE_ATTRIBUTE};
+
+			private String[] attrValues = new String[required.length + optional.length];
+
+			private MappingRulesHandler mappingRulesHandler = null;
+			private PropertiesHandler propertiesHandler = null;
+			private ArtifactsHandler artifactsHandler = null;
+
+			private SimpleArtifactRepository repository = null;
+
+			public RepositoryHandler() {
+				super();
+			}
+
+			public SimpleArtifactRepository getRepository() {
+				return repository;
+			}
+
+			protected void handleRootAttributes(Attributes attributes) {
+				attrValues = parseAttributes(attributes, required, optional);
+				attrValues[2] = checkVersion(REPOSITORY_ELEMENT, VERSION_ATTRIBUTE, attrValues[2]).toString();
+				attrValues[5] = checkBoolean(REPOSITORY_ELEMENT, VERIFY_SIGNATURE_ATTRIBUTE, attrValues[5], false).toString();
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (MAPPING_RULES_ELEMENT.equalsIgnoreCase(name)) {
+					if (mappingRulesHandler == null) {
+						mappingRulesHandler = new MappingRulesHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else if (ARTIFACTS_ELEMENT.equalsIgnoreCase(name)) {
+					if (artifactsHandler == null) {
+						artifactsHandler = new ArtifactsHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else if (PROPERTIES_ELEMENT.equalsIgnoreCase(name)) {
+					if (propertiesHandler == null) {
+						propertiesHandler = new PropertiesHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+
+			protected void finished() {
+				if (isValidXML()) {
+					String[][] mappingRules = (mappingRulesHandler == null ? new String[0][0] //
+							: mappingRulesHandler.getMappingRules());
+					OrderedProperties properties = (propertiesHandler == null ? new OrderedProperties(0) //
+							: propertiesHandler.getProperties());
+					Set artifacts = (artifactsHandler == null ? new HashSet(0) //
+							: artifactsHandler.getArtifacts());
+					boolean verifySignature = (attrValues[5] == null ? false //
+							: new Boolean(attrValues[5]).booleanValue());
+					repository = new SimpleArtifactRepository(attrValues[0], attrValues[1], attrValues[2], attrValues[3], //
+							attrValues[4], verifySignature, artifacts, mappingRules, properties);
+				}
+			}
+		}
+
+		protected class MappingRulesHandler extends AbstractHandler {
+
+			private List mappingRules;
+
+			public MappingRulesHandler(AbstractHandler parentHandler, Attributes attributes) {
+				super(parentHandler, MAPPING_RULES_ELEMENT);
+				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+				mappingRules = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
+			}
+
+			public String[][] getMappingRules() {
+				String[][] rules = new String[mappingRules.size()][2];
+				for (int index = 0; index < mappingRules.size(); index++) {
+					String[] ruleAttributes = (String[]) mappingRules.get(index);
+					rules[index] = ruleAttributes;
+				}
+				return rules;
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (name.equalsIgnoreCase(MAPPING_RULE_ELEMENT)) {
+					new MappingRuleHandler(this, attributes, mappingRules);
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+		}
+
+		protected class MappingRuleHandler extends AbstractHandler {
+
+			private final String[] required = new String[] {MAPPING_RULE_FILTER_ATTRIBUTE, MAPPING_RULE_OUTPUT_ATTRIBUTE};
+
+			public MappingRuleHandler(AbstractHandler parentHandler, Attributes attributes, List mappingRules) {
+				super(parentHandler, MAPPING_RULE_ELEMENT);
+				mappingRules.add(parseRequiredAttributes(attributes, required));
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				invalidElement(name, attributes);
+			}
+		}
+
+		protected class ArtifactsHandler extends AbstractHandler {
+
+			private Set artifacts;
+
+			public ArtifactsHandler(AbstractHandler parentHandler, Attributes attributes) {
+				super(parentHandler, ARTIFACTS_ELEMENT);
+				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+				artifacts = (size != null ? new LinkedHashSet(new Integer(size).intValue()) : new LinkedHashSet(4));
+			}
+
+			public Set getArtifacts() {
+				return artifacts;
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (name.equalsIgnoreCase(ARTIFACT_ELEMENT)) {
+					new ArtifactHandler(this, attributes, artifacts);
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+		}
+
+		protected class ArtifactHandler extends AbstractHandler {
+
+			private final String[] required = new String[] {ARTIFACT_NAMESPACE_ATTRIBUTE, ARTIFACT_CLASSIFIER_ATTRIBUTE, ID_ATTRIBUTE, VERSION_ATTRIBUTE};
+
+			private Set artifacts;
+			ArtifactDescriptor currentArtifact = null;
+
+			private PropertiesHandler propertiesHandler = null;
+			private ProcessingStepsHandler processingStepsHandler = null;
+
+			public ArtifactHandler(AbstractHandler parentHandler, Attributes attributes, Set artifacts) {
+				super(parentHandler, ARTIFACT_ELEMENT);
+				this.artifacts = artifacts;
+				String[] values = parseRequiredAttributes(attributes, required);
+				Version version = checkVersion(ARTIFACT_ELEMENT, VERSION_ATTRIBUTE, values[3]);
+				// TODO: resolve access restriction on ArtifactKey construction
+				currentArtifact = new ArtifactDescriptor(new ArtifactKey(values[0], values[1], values[2], version));
+			}
+
+			public ArtifactDescriptor getArtifact() {
+				return currentArtifact;
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (PROCESSING_STEPS_ELEMENT.equalsIgnoreCase(name)) {
+					if (processingStepsHandler == null) {
+						processingStepsHandler = new ProcessingStepsHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else if (PROPERTIES_ELEMENT.equalsIgnoreCase(name)) {
+					if (propertiesHandler == null) {
+						propertiesHandler = new PropertiesHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+
+			protected void finished() {
+				if (isValidXML() && currentArtifact != null) {
+					OrderedProperties properties = (propertiesHandler == null ? new OrderedProperties(0) //
+							: propertiesHandler.getProperties());
+					currentArtifact.addProperties(properties);
+					ProcessingStepDescriptor[] processingSteps = (processingStepsHandler == null ? new ProcessingStepDescriptor[0] //
+							: processingStepsHandler.getProcessingSteps());
+					currentArtifact.setProcessingSteps(processingSteps);
+					artifacts.add(currentArtifact);
+				}
+			}
+		}
+
+		protected class ProcessingStepsHandler extends AbstractHandler {
+
+			private List processingSteps;
+
+			public ProcessingStepsHandler(AbstractHandler parentHandler, Attributes attributes) {
+				super(parentHandler, PROCESSING_STEPS_ELEMENT);
+				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+				processingSteps = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
+			}
+
+			public ProcessingStepDescriptor[] getProcessingSteps() {
+				return (ProcessingStepDescriptor[]) processingSteps.toArray(new ProcessingStepDescriptor[processingSteps.size()]);
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (name.equalsIgnoreCase(PROCESSING_STEP_ELEMENT)) {
+					new ProcessingStepHandler(this, attributes, processingSteps);
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+		}
+
+		protected class ProcessingStepHandler extends AbstractHandler {
+
+			private final String[] required = new String[] {ID_ATTRIBUTE, STEP_DATA_ATTRIBUTE, STEP_REQUIRED_ATTRIBUTE};
+
+			public ProcessingStepHandler(AbstractHandler parentHandler, Attributes attributes, List processingSteps) {
+				super(parentHandler, PROCESSING_STEP_ELEMENT);
+				String[] attributeValues = parseRequiredAttributes(attributes, required);
+				processingSteps.add(new ProcessingStepDescriptor(attributeValues[0], attributeValues[1], checkBoolean(PROCESSING_STEP_ELEMENT, STEP_REQUIRED_ATTRIBUTE, attributeValues[2]).booleanValue()));
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				invalidElement(name, attributes);
+			}
+		}
+
+		protected String getErrorMessage() {
+			return Messages.SimpleArtifactRepositoryIO_Parser_Error_Parsing_Repository;
+		}
+
+		public String toString() {
+			// TODO:
+			return null;
+		}
+
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/core/helpers/XMLParser.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/core/helpers/XMLParser.java
index efb7854..db46c6f 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/core/helpers/XMLParser.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/core/helpers/XMLParser.java
@@ -11,7 +11,7 @@
 package org.eclipse.equinox.p2.core.helpers;
 
 import java.util.List;
-import java.util.regex.Pattern;
+import java.util.StringTokenizer;
 import javax.xml.parsers.*;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Status;
@@ -471,18 +471,28 @@ public abstract class XMLParser extends DefaultHandler implements XMLConstants {
 	}
 
 	// Helpers for processing instructions that include a Class and/or a Version.
-	private static final String PI_CLASS_REGEX = PI_CLASS_ATTRIBUTE + "=['\"]([\\S]*)['\"]$"; //$NON-NLS-1$
-	private static final Pattern PI_CLASS_PATTERN = Pattern.compile(PI_CLASS_REGEX);
-
-	private static final String PI_VERSION_REGEX = PI_VERSION_ATTRIBUTE + "=['\"]([\\w\\d][\\w\\d\\.]*)['\"]$"; //$NON-NLS-1$
-	private static final Pattern PI_VERSION_PATTERN = Pattern.compile(PI_VERSION_REGEX);
 
 	public String extractPIClass(String data) {
-		return PI_CLASS_PATTERN.matcher(data).replaceAll("$1"); //$NON-NLS-1$
+		return extractPIAttribute(data, PI_CLASS_ATTRIBUTE);
 	}
 
 	public Version extractPIVersion(String target, String data) {
-		return checkVersion(target, PI_VERSION_ATTRIBUTE, PI_VERSION_PATTERN.matcher(data).replaceAll("$1")); //$NON-NLS-1$
+		return checkVersion(target, PI_VERSION_ATTRIBUTE, extractPIAttribute(data, PI_VERSION_ATTRIBUTE));
+	}
+
+	private String extractPIAttribute(String data, String key) {
+		StringTokenizer piTokenizer = new StringTokenizer(data, " \'\""); //$NON-NLS-1$
+		String[] tokens = new String[piTokenizer.countTokens()];
+		int index = 0;
+		int valueIndex = -1;
+		while (piTokenizer.hasMoreTokens() && index < tokens.length) {
+			tokens[index] = piTokenizer.nextToken();
+			if (tokens[index].equals(key + '=') && index < tokens.length) {
+				valueIndex = index + 1;
+			}
+			index++;
+		}
+		return (valueIndex >= 0 ? tokens[valueIndex] : ""); //$NON-NLS-1$
 	}
 
 	public class ParserStatus extends Status implements IStatus {
@@ -642,8 +652,10 @@ public abstract class XMLParser extends DefaultHandler implements XMLConstants {
 			return Boolean.valueOf(value);
 		} catch (IllegalArgumentException iae) {
 			invalidAttributeValue(element, attribute, value);
-			return Boolean.FALSE;
+		} catch (NullPointerException npe) {
+			invalidAttributeValue(element, attribute, null);
 		}
+		return Boolean.FALSE;
 	}
 
 	// Check the format of an optional boolean attribute
@@ -664,6 +676,8 @@ public abstract class XMLParser extends DefaultHandler implements XMLConstants {
 			return new Version(value);
 		} catch (IllegalArgumentException iae) {
 			invalidAttributeValue(element, attribute, value);
+		} catch (NullPointerException npe) {
+			invalidAttributeValue(element, attribute, null);
 		}
 		return Version.emptyVersion;
 	}
@@ -673,6 +687,8 @@ public abstract class XMLParser extends DefaultHandler implements XMLConstants {
 			return new VersionRange(value);
 		} catch (IllegalArgumentException iae) {
 			invalidAttributeValue(element, attribute, value);
+		} catch (NullPointerException npe) {
+			invalidAttributeValue(element, attribute, null);
 		}
 		return VersionRange.emptyRange;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/core/helpers/XMLWriter.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/core/helpers/XMLWriter.java
index 03e5b8b..d4a8c14 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/core/helpers/XMLWriter.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/core/helpers/XMLWriter.java
@@ -54,6 +54,7 @@ public class XMLWriter implements XMLConstants {
 
 		public static ProcessingInstruction makeClassVersionInstruction(String target, Class clazz, Version version) {
 			return new ProcessingInstruction(target, new String[] {PI_CLASS_ATTRIBUTE, PI_VERSION_ATTRIBUTE}, new String[] {clazz.getName(), version.toString()});
+			//return new ProcessingInstruction(target, new String[] {PI_CLASS_ATTRIBUTE}, new String[] {clazz.getName()});
 		}
 
 		public String toString() {
diff --git a/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
index 655165e..989818f 100644
--- a/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
@@ -11,13 +11,19 @@ Export-Package: org.eclipse.equinox.internal.p2.engine;x-internal:=true,
  org.eclipse.equinox.p2.installregistry
 Import-Package: javax.xml.parsers,
  org.eclipse.equinox.internal.p2.metadata,
+ org.eclipse.equinox.internal.p2.metadata.repository,
+ org.eclipse.equinox.internal.p2.metadata.repository.io,
  org.eclipse.equinox.p2.artifact.repository,
+ org.eclipse.equinox.p2.core,
  org.eclipse.equinox.p2.core.eventbus,
  org.eclipse.equinox.p2.core.helpers,
  org.eclipse.equinox.p2.core.location,
+ org.eclipse.equinox.p2.core.repository,
  org.eclipse.equinox.p2.download,
  org.eclipse.equinox.p2.metadata,
+ org.eclipse.equinox.p2.metadata.repository,
  org.eclipse.equinox.p2.query,
+ org.eclipse.equinox.spi.p2.core.repository,
  org.eclipse.osgi.service.datalocation;version="1.0.0",
  org.eclipse.osgi.service.resolver;version="1.1.0",
  org.eclipse.osgi.util;version="1.0.0",
@@ -26,6 +32,7 @@ Import-Package: javax.xml.parsers,
  org.xml.sax
 Bundle-Activator: org.eclipse.equinox.internal.p2.engine.EngineActivator
 Eclipse-LazyStart: true
+Eclipse-RegisterBuddy: org.eclipse.equinox.p2.metadata.repository
 Bundle-RequiredExecutionEnvironment: CDC-1.1/Foundation-1.1,
  J2SE-1.4
 Require-Bundle: org.eclipse.equinox.common,
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/SimpleProfileRegistry.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/SimpleProfileRegistry.java
index 61c9b3c..8260f51 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/SimpleProfileRegistry.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/SimpleProfileRegistry.java
@@ -114,11 +114,6 @@ public class SimpleProfileRegistry implements IProfileRegistry {
 			BufferedInputStream bif = null;
 			try {
 				bif = new BufferedInputStream(getRegistryLocation().openStream());
-				//				XStream xml = new XStream();
-				//				Object[] read = (Object[]) xml.fromXML(bif);
-				//				properties = (OrderedProperties) read[0];
-				//				profiles = (LinkedHashMap) read[1];
-
 				Parser parser = new Parser(EngineActivator.getContext(), EngineActivator.ID);
 				parser.parse(bif);
 			} finally {
@@ -150,9 +145,6 @@ public class SimpleProfileRegistry implements IProfileRegistry {
 				throw new RuntimeException("Can't persist profile registry at: " + outputFile);
 			os = new BufferedOutputStream(new FileOutputStream(outputFile));
 			try {
-				//				XStream xstream = new XStream();
-				//				xstream.toXML(new Object[] {properties, profiles}, os);
-
 				Writer writer = new Writer(os);
 				writer.write(this);
 			} finally {
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/InstallRegistry.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/InstallRegistry.java
index 4db1418..70c8141 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/InstallRegistry.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/InstallRegistry.java
@@ -17,13 +17,15 @@ import java.util.*;
 import javax.xml.parsers.ParserConfigurationException;
 import org.eclipse.equinox.internal.p2.engine.EngineActivator;
 import org.eclipse.equinox.internal.p2.engine.Messages;
-import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
+import org.eclipse.equinox.internal.p2.metadata.repository.io.MetadataParser;
+import org.eclipse.equinox.internal.p2.metadata.repository.io.MetadataWriter;
 import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
 import org.eclipse.equinox.p2.core.eventbus.SynchronousProvisioningListener;
 import org.eclipse.equinox.p2.core.helpers.*;
 import org.eclipse.equinox.p2.core.location.AgentLocation;
 import org.eclipse.equinox.p2.engine.*;
-import org.eclipse.equinox.p2.metadata.*;
+import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.metadata.IInstallableUnitConstants;
 import org.eclipse.osgi.service.resolver.VersionRange;
 import org.eclipse.osgi.util.NLS;
 import org.osgi.framework.*;
@@ -105,7 +107,6 @@ public class InstallRegistry implements IInstallRegistry {
 				if (!outputFile.getParentFile().exists() && !outputFile.getParentFile().mkdirs())
 					throw new RuntimeException("Can't persist profile registry");
 				bof = new BufferedOutputStream(new FileOutputStream(outputFile, false));
-				//new XStream().toXML(profileRegistries, bof);
 				Writer writer = new Writer(bof);
 				writer.write(this);
 			} finally {
@@ -126,7 +127,6 @@ public class InstallRegistry implements IInstallRegistry {
 			BufferedInputStream bif = null;
 			try {
 				bif = new BufferedInputStream(getRegistryLocation().openStream());
-				// profileRegistries = (HashMap) new XStream().fromXML(bif);
 				Parser parser = new Parser(EngineActivator.getContext(), EngineActivator.ID);
 				parser.parse(bif);
 				profileRegistries = parser.getProfileInstallRegistries();
@@ -302,57 +302,15 @@ public class InstallRegistry implements IInstallRegistry {
 		public static final String INSTALL_REGISTRY_ELEMENT = "installRegistry"; //$NON-NLS-1$
 		public static final String PROFILE_INSTALL_REGISTRIES_ELEMENT = "profiles"; //$NON-NLS-1$
 		public static final String PROFILE_INSTALL_REGISTRY_ELEMENT = "profile"; //$NON-NLS-1$
-		public static final String INSTALLABLE_UNITS_ELEMENT = "units"; //$NON-NLS-1$
-		public static final String INSTALLABLE_UNIT_ELEMENT = "unit"; //$NON-NLS-1$
 		public static final String IUS_PROPERTIES_ELEMENT = "iusPropertiesMap"; //$NON-NLS-1$
 		public static final String IU_PROPERTIES_ELEMENT = "iusProperties"; //$NON-NLS-1$
 
 		// Constants for attributes of an profile install registry element
 		public static final String PROFILE_ID_ATTRIBUTE = "profileId"; //$NON-NLS-1$
 
-		// Constants for sub-elements of an installable unit element
-		public static final String ARTIFACT_KEYS_ELEMENT = "artifacts"; //$NON-NLS-1$
-		public static final String ARTIFACT_KEY_ELEMENT = "artifact"; //$NON-NLS-1$
-		public static final String REQUIRED_CAPABILITIES_ELEMENT = "requires"; //$NON-NLS-1$
-		public static final String REQUIRED_CAPABILITY_ELEMENT = "required"; //$NON-NLS-1$
-		public static final String PROVIDED_CAPABILITIES_ELEMENT = "provides"; //$NON-NLS-1$
-		public static final String PROVIDED_CAPABILITY_ELEMENT = "provided"; //$NON-NLS-1$
-		public static final String TOUCHPOINT_TYPE_ELEMENT = "touchpoint"; //$NON-NLS-1$
-		public static final String TOUCHPOINT_DATA_ELEMENT = "touchpointData"; //$NON-NLS-1$
-		public static final String IU_FILTER_ELEMENT = "filter"; //$NON-NLS-1$
-		public static final String APPLICABILITY_FILTER_ELEMENT = "applicability"; //$NON-NLS-1$
-
-		// Constants for attributes of an installable unit element
-		public static final String SINGLETON_ATTRIBUTE = "singleton"; //$NON-NLS-1$
-		public static final String FRAGMENT_ATTRIBUTE = "fragment"; //$NON-NLS-1$
-
-		// Constants for attributes of a fragment installable unit element
-		public static final String FRAGMENT_HOST_ID_ATTRIBUTE = "hostId"; //$NON-NLS-1$
-		public static final String FRAGMENT_HOST_RANGE_ATTRIBUTE = "hostRange"; //$NON-NLS-1$
-
-		// Constants for sub-elements of a required capability element
-		public static final String CAPABILITY_FILTER_ELEMENT = "filter"; //$NON-NLS-1$
-		public static final String CAPABILITY_SELECTORS_ELEMENT = "selectors"; //$NON-NLS-1$
-		public static final String CAPABILITY_SELECTOR_ELEMENT = "selector"; //$NON-NLS-1$
-
-		// Constants for attributes of a required capability element
-		public static final String CAPABILITY_OPTIONAL_ATTRIBUTE = "optional"; //$NON-NLS-1$
-		public static final String CAPABILITY_MULTIPLE_ATTRIBUTE = "multiple"; //$NON-NLS-1$
-
-		// Constants for attributes of an artifact key element
-		public static final String ARTIFACT_KEY_NAMESPACE_ATTRIBUTE = NAMESPACE_ATTRIBUTE;
-		public static final String ARTIFACT_KEY_CLASSIFIER_ATTRIBUTE = "classifier"; //$NON-NLS-1$
-
-		// Constants for sub-elements of a touchpoint data element
-		public static final String TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT = "instructions"; //$NON-NLS-1$
-		public static final String TOUCHPOINT_DATA_INSTRUCTION_ELEMENT = "instruction"; //$NON-NLS-1$
-
-		// Constants for attributes of an a touchpoint data instruction element
-		public static final String TOUCHPOINT_DATA_INSTRUCTION_KEY_ATTRIBUTE = "key"; //$NON-NLS-1$
-
 	}
 
-	protected class Writer extends XMLWriter implements XMLConstants {
+	protected class Writer extends MetadataWriter implements XMLConstants {
 
 		public Writer(OutputStream output) throws IOException {
 			super(output, PI_DEFAULTS);
@@ -406,160 +364,13 @@ public class InstallRegistry implements IInstallRegistry {
 				end(IUS_PROPERTIES_ELEMENT);
 			}
 		}
-
-		// TODO: below is a LOT of code duplicated for MetadataRepositoryIO for writing
-		//		 installable units. Need to figure out a cleanway to declare handlers
-		//		 which do not depend on the context of an outer declaring Parser class,
-		//		 so that handlers may be reused in different parsing contexts.
-		private void writeInstallableUnits(IInstallableUnit[] installableUnits) {
-			if (installableUnits.length > 0) {
-				start(INSTALLABLE_UNITS_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, installableUnits.length);
-				for (int i = 0; i < installableUnits.length; i++) {
-					writeInstallableUnit(installableUnits[i]);
-				}
-				end(INSTALLABLE_UNITS_ELEMENT);
-			}
-		}
-
-		private void writeInstallableUnit(IInstallableUnit resolvedIU) {
-			IInstallableUnit iu = (!(resolvedIU instanceof IResolvedInstallableUnit) ? resolvedIU//
-					: ((IResolvedInstallableUnit) resolvedIU).getOriginal());
-			start(INSTALLABLE_UNIT_ELEMENT);
-			attribute(ID_ATTRIBUTE, iu.getId());
-			attribute(VERSION_ATTRIBUTE, iu.getVersion());
-			attribute(SINGLETON_ATTRIBUTE, iu.isSingleton(), true);
-			attribute(FRAGMENT_ATTRIBUTE, iu.isFragment(), false);
-
-			if (iu.isFragment() && iu instanceof IInstallableUnitFragment) {
-				IInstallableUnitFragment fragment = (IInstallableUnitFragment) iu;
-				attribute(FRAGMENT_HOST_ID_ATTRIBUTE, fragment.getHostId());
-				attribute(FRAGMENT_HOST_RANGE_ATTRIBUTE, fragment.getHostVersionRange());
-			}
-
-			writeProperties(iu.getProperties());
-			writeProvidedCapabilities(iu.getProvidedCapabilities());
-			writeRequiredCapabilities(iu.getRequiredCapabilities());
-			writeTrimmedCdata(IU_FILTER_ELEMENT, iu.getFilter());
-			writeTrimmedCdata(APPLICABILITY_FILTER_ELEMENT, iu.getApplicabilityFilter());
-
-			writeArtifactKeys(iu.getArtifacts());
-			writeTouchpointType(iu.getTouchpointType());
-			writeTouchpointData(iu.getTouchpointData());
-
-			end(INSTALLABLE_UNIT_ELEMENT);
-		}
-
-		private void writeProvidedCapabilities(ProvidedCapability[] capabilities) {
-			if (capabilities != null && capabilities.length > 0) {
-				start(PROVIDED_CAPABILITIES_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, capabilities.length);
-				for (int i = 0; i < capabilities.length; i++) {
-					start(PROVIDED_CAPABILITY_ELEMENT);
-					attribute(NAMESPACE_ATTRIBUTE, capabilities[i].getNamespace());
-					attribute(NAME_ATTRIBUTE, capabilities[i].getName());
-					attribute(VERSION_ATTRIBUTE, capabilities[i].getVersion());
-					end(PROVIDED_CAPABILITY_ELEMENT);
-				}
-				end(PROVIDED_CAPABILITIES_ELEMENT);
-			}
-		}
-
-		private void writeRequiredCapabilities(RequiredCapability[] capabilities) {
-			if (capabilities != null && capabilities.length > 0) {
-				start(REQUIRED_CAPABILITIES_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, capabilities.length);
-				for (int i = 0; i < capabilities.length; i++) {
-					writeRequiredCapability(capabilities[i]);
-				}
-				end(REQUIRED_CAPABILITIES_ELEMENT);
-			}
-		}
-
-		private void writeRequiredCapability(RequiredCapability capability) {
-			start(REQUIRED_CAPABILITY_ELEMENT);
-			attribute(NAMESPACE_ATTRIBUTE, capability.getNamespace());
-			attribute(NAME_ATTRIBUTE, capability.getName());
-			attribute(VERSION_RANGE_ATTRIBUTE, capability.getRange());
-			attribute(CAPABILITY_OPTIONAL_ATTRIBUTE, capability.isOptional(), false);
-			attribute(CAPABILITY_MULTIPLE_ATTRIBUTE, capability.isMultiple(), false);
-
-			writeTrimmedCdata(CAPABILITY_FILTER_ELEMENT, capability.getFilter());
-
-			String[] selectors = capability.getSelectors();
-			if (selectors.length > 0) {
-				start(CAPABILITY_SELECTORS_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, selectors.length);
-				for (int j = 0; j < selectors.length; j++) {
-					writeTrimmedCdata(CAPABILITY_SELECTOR_ELEMENT, selectors[j]);
-				}
-				end(CAPABILITY_SELECTORS_ELEMENT);
-			}
-
-			end(REQUIRED_CAPABILITY_ELEMENT);
-		}
-
-		private void writeArtifactKeys(IArtifactKey[] artifactKeys) {
-			if (artifactKeys != null && artifactKeys.length > 0) {
-				start(ARTIFACT_KEYS_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, artifactKeys.length);
-				for (int i = 0; i < artifactKeys.length; i++) {
-					start(ARTIFACT_KEY_ELEMENT);
-					attribute(ARTIFACT_KEY_NAMESPACE_ATTRIBUTE, artifactKeys[i].getNamespace());
-					attribute(ARTIFACT_KEY_CLASSIFIER_ATTRIBUTE, artifactKeys[i].getClassifier());
-					attribute(ID_ATTRIBUTE, artifactKeys[i].getId());
-					attribute(VERSION_ATTRIBUTE, artifactKeys[i].getVersion());
-					end(ARTIFACT_KEY_ELEMENT);
-				}
-				end(ARTIFACT_KEYS_ELEMENT);
-			}
-		}
-
-		private void writeTouchpointType(TouchpointType touchpointType) {
-			start(TOUCHPOINT_TYPE_ELEMENT);
-			attribute(ID_ATTRIBUTE, touchpointType.getId());
-			attribute(VERSION_ATTRIBUTE, touchpointType.getVersion());
-			end(TOUCHPOINT_TYPE_ELEMENT);
-		}
-
-		private void writeTouchpointData(TouchpointData[] touchpointData) {
-			if (touchpointData != null && touchpointData.length > 0) {
-				start(TOUCHPOINT_DATA_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, touchpointData.length);
-				for (int i = 0; i < touchpointData.length; i++) {
-					TouchpointData nextData = touchpointData[i];
-					Map instructions = nextData.getInstructions();
-					if (instructions.size() > 0) {
-						start(TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT);
-						attribute(COLLECTION_SIZE_ATTRIBUTE, instructions.size());
-						for (Iterator iter = instructions.entrySet().iterator(); iter.hasNext();) {
-							Map.Entry entry = (Map.Entry) iter.next();
-							start(TOUCHPOINT_DATA_INSTRUCTION_ELEMENT);
-							attribute(TOUCHPOINT_DATA_INSTRUCTION_KEY_ATTRIBUTE, entry.getKey());
-							cdata((String) entry.getValue(), true);
-							end(TOUCHPOINT_DATA_INSTRUCTION_ELEMENT);
-						}
-					}
-				}
-				end(TOUCHPOINT_DATA_ELEMENT);
-			}
-		}
-
-		private void writeTrimmedCdata(String element, String filter) {
-			String trimmed;
-			if (filter != null && (trimmed = filter.trim()).length() > 0) {
-				start(element);
-				cdata(trimmed);
-				end(element);
-			}
-		}
 	}
 
 	/*
 	 * 	Parser for the contents of an InstallRegistry,
 	 * 	as written by the Writer class.
 	 */
-	private class Parser extends XMLParser implements XMLConstants {
+	private class Parser extends MetadataParser implements XMLConstants {
 
 		private Map profileInstallRegistries = null;
 
@@ -609,13 +420,13 @@ public class InstallRegistry implements IInstallRegistry {
 			public void ProcessingInstruction(String target, String data) throws SAXException {
 				if (PI_REPOSITORY_TARGET.equalsIgnoreCase(target)) {
 					// TODO: should the root handler be constructed based on class
-					// 		 via an extension registry mechanism?
+					// 		 or via an extension registry mechanism?
 					// String clazz = extractPIClass(data);
 					// and
-					// TODO: version tolerance by extension
+					// TODO: version tolerance by extension or by class?
 					Version repositoryVersion = extractPIVersion(target, data);
-					if (!XML_TOLERANCE.isIncluded(repositoryVersion)) {
-						throw new SAXException(NLS.bind(Messages.InstallRegistry_Parser_Has_Incompatible_Version, repositoryVersion, XML_TOLERANCE));
+					if (!XMLConstants.XML_TOLERANCE.isIncluded(repositoryVersion)) {
+						throw new SAXException(NLS.bind(Messages.InstallRegistry_Parser_Has_Incompatible_Version, repositoryVersion, XMLConstants.XML_TOLERANCE));
 					}
 				}
 			}
@@ -788,420 +599,6 @@ public class InstallRegistry implements IInstallRegistry {
 			}
 		}
 
-		// TODO: below is a LOT of code duplicated for MetadataRepositoryIO for writing
-		//		 installable units. Need to figure out a cleanway to declare handlers
-		//		 which do not depend on the context of an outer declaring Parser class,
-		//		 so that handlers may be reused in different parsing contexts.
-		protected class InstallableUnitsHandler extends AbstractHandler {
-
-			private ArrayList units;
-
-			public InstallableUnitsHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, INSTALLABLE_UNITS_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				units = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public IInstallableUnit[] getUnits() {
-				return (IInstallableUnit[]) units.toArray(new IInstallableUnit[units.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(INSTALLABLE_UNIT_ELEMENT)) {
-					new InstallableUnitHandler(this, attributes, units);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class InstallableUnitHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {ID_ATTRIBUTE, VERSION_ATTRIBUTE};
-			private final String[] optional = new String[] {SINGLETON_ATTRIBUTE, FRAGMENT_ATTRIBUTE, FRAGMENT_HOST_ID_ATTRIBUTE, FRAGMENT_HOST_RANGE_ATTRIBUTE};
-
-			InstallableUnit currentUnit = null;
-
-			private PropertiesHandler propertiesHandler = null;
-			private ProvidedCapabilitiesHandler providedCapabilitiesHandler = null;
-			private RequiredCapabilitiesHandler requiredCapabilitiesHandler = null;
-			private TextHandler filterHandler = null;
-			private TextHandler applicabilityHandler = null;
-			private ArtifactsHandler artifactsHandler = null;
-			private TouchpointTypeHandler touchpointTypeHandler = null;
-			private TouchpointDataHandler touchpointDataHandler = null;
-
-			public InstallableUnitHandler(AbstractHandler parentHandler, Attributes attributes, List units) {
-				super(parentHandler, INSTALLABLE_UNIT_ELEMENT);
-				String[] values = parseAttributes(attributes, required, optional);
-
-				Version version = checkVersion(INSTALLABLE_UNIT_ELEMENT, VERSION_ATTRIBUTE, values[1]);
-				boolean singleton = checkBoolean(INSTALLABLE_UNIT_ELEMENT, SINGLETON_ATTRIBUTE, values[2], true).booleanValue();
-				boolean isFragment = checkBoolean(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_ATTRIBUTE, values[3], false).booleanValue();
-				if (isFragment) {
-					// TODO: tooling default fragment does not have a host id
-					// checkRequiredAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_ID_ATTRIBUTE, values[4]);
-					checkRequiredAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_RANGE_ATTRIBUTE, values[5]);
-					VersionRange hostRange = checkVersionRange(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_RANGE_ATTRIBUTE, values[5]);
-					currentUnit = new InstallableUnitFragment(values[0], version, singleton, values[4], hostRange);
-				} else {
-					if (values[4] != null) {
-						unexpectedAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_ID_ATTRIBUTE, values[4]);
-					} else if (values[5] != null) {
-						unexpectedAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_RANGE_ATTRIBUTE, values[4]);
-					}
-					currentUnit = new InstallableUnit(values[0], version, singleton);
-				}
-				units.add(currentUnit);
-			}
-
-			public IInstallableUnit getInstallableUnit() {
-				return currentUnit;
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (PROPERTIES_ELEMENT.equalsIgnoreCase(name)) {
-					if (propertiesHandler == null) {
-						propertiesHandler = new PropertiesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (PROVIDED_CAPABILITIES_ELEMENT.equalsIgnoreCase(name)) {
-					if (providedCapabilitiesHandler == null) {
-						providedCapabilitiesHandler = new ProvidedCapabilitiesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (REQUIRED_CAPABILITIES_ELEMENT.equalsIgnoreCase(name)) {
-					if (requiredCapabilitiesHandler == null) {
-						requiredCapabilitiesHandler = new RequiredCapabilitiesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (IU_FILTER_ELEMENT.equalsIgnoreCase(name)) {
-					if (filterHandler == null) {
-						filterHandler = new TextHandler(this, IU_FILTER_ELEMENT, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (APPLICABILITY_FILTER_ELEMENT.equalsIgnoreCase(name)) {
-					if (applicabilityHandler == null) {
-						applicabilityHandler = new TextHandler(this, APPLICABILITY_FILTER_ELEMENT, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (ARTIFACT_KEYS_ELEMENT.equalsIgnoreCase(name)) {
-					if (artifactsHandler == null) {
-						artifactsHandler = new ArtifactsHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (TOUCHPOINT_TYPE_ELEMENT.equalsIgnoreCase(name)) {
-					if (touchpointTypeHandler == null) {
-						touchpointTypeHandler = new TouchpointTypeHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (TOUCHPOINT_DATA_ELEMENT.equalsIgnoreCase(name)) {
-					if (touchpointDataHandler == null) {
-						touchpointDataHandler = new TouchpointDataHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			protected void finished() {
-				if (isValidXML() && currentUnit != null) {
-					OrderedProperties properties = (propertiesHandler == null ? new OrderedProperties(0) //
-							: propertiesHandler.getProperties());
-					currentUnit.addProperties(properties);
-					ProvidedCapability[] providedCapabilities = (providedCapabilitiesHandler == null ? new ProvidedCapability[0] //
-							: providedCapabilitiesHandler.getProvidedCapabilities());
-					currentUnit.setCapabilities(providedCapabilities);
-					RequiredCapability[] requiredCapabilities = (requiredCapabilitiesHandler == null ? new RequiredCapability[0] //
-							: requiredCapabilitiesHandler.getRequiredCapabilities());
-					currentUnit.setRequiredCapabilities(requiredCapabilities);
-					if (filterHandler != null) {
-						currentUnit.setFilter(filterHandler.getText());
-					}
-					if (applicabilityHandler != null) {
-						currentUnit.setApplicabilityFilter(applicabilityHandler.getText());
-					}
-					IArtifactKey[] artifacts = (artifactsHandler == null ? new IArtifactKey[0] //
-							: artifactsHandler.getArtifactKeys());
-					currentUnit.setArtifacts(artifacts);
-					if (touchpointTypeHandler != null) {
-						currentUnit.setTouchpointType(touchpointTypeHandler.getTouchpointType());
-					} else {
-						// TODO: create an error
-					}
-					TouchpointData[] touchpointData = (touchpointDataHandler == null ? new TouchpointData[0] //
-							: touchpointDataHandler.getTouchpointData());
-					currentUnit.addTouchpointData(touchpointData);
-				}
-			}
-		}
-
-		protected class ProvidedCapabilitiesHandler extends AbstractHandler {
-
-			private List providedCapabilities;
-
-			public ProvidedCapabilitiesHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, PROVIDED_CAPABILITIES_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				providedCapabilities = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public ProvidedCapability[] getProvidedCapabilities() {
-				return (ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(PROVIDED_CAPABILITY_ELEMENT)) {
-					new ProvidedCapabilityHandler(this, attributes, providedCapabilities);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class ProvidedCapabilityHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {NAMESPACE_ATTRIBUTE, NAME_ATTRIBUTE, VERSION_ATTRIBUTE};
-
-			public ProvidedCapabilityHandler(AbstractHandler parentHandler, Attributes attributes, List capabilities) {
-				super(parentHandler, PROVIDED_CAPABILITY_ELEMENT);
-				String[] values = parseRequiredAttributes(attributes, required);
-				Version version = checkVersion(PROVIDED_CAPABILITY_ELEMENT, VERSION_ATTRIBUTE, values[2]);
-				capabilities.add(new ProvidedCapability(values[0], values[1], version));
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				invalidElement(name, attributes);
-			}
-		}
-
-		protected class RequiredCapabilitiesHandler extends AbstractHandler {
-
-			private List requiredCapabilities;
-
-			public RequiredCapabilitiesHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, REQUIRED_CAPABILITIES_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				requiredCapabilities = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public RequiredCapability[] getRequiredCapabilities() {
-				return (RequiredCapability[]) requiredCapabilities.toArray(new RequiredCapability[requiredCapabilities.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(REQUIRED_CAPABILITY_ELEMENT)) {
-					new RequiredCapabilityHandler(this, attributes, requiredCapabilities);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class RequiredCapabilityHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {NAMESPACE_ATTRIBUTE, NAME_ATTRIBUTE, VERSION_RANGE_ATTRIBUTE};
-			private final String[] optional = new String[] {CAPABILITY_OPTIONAL_ATTRIBUTE, CAPABILITY_MULTIPLE_ATTRIBUTE};
-
-			private RequiredCapability currentCapability = null;
-
-			private TextHandler filterHandler = null;
-			private CapabilitySelectorsHandler selectorsHandler = null;
-
-			public RequiredCapabilityHandler(AbstractHandler parentHandler, Attributes attributes, List capabilities) {
-				super(parentHandler, REQUIRED_CAPABILITY_ELEMENT);
-				String[] values = parseAttributes(attributes, required, optional);
-				VersionRange range = checkVersionRange(REQUIRED_CAPABILITY_ELEMENT, VERSION_RANGE_ATTRIBUTE, values[2]);
-				boolean isOptional = checkBoolean(REQUIRED_CAPABILITY_ELEMENT, CAPABILITY_OPTIONAL_ATTRIBUTE, values[3], false).booleanValue();
-				boolean isMultiple = checkBoolean(REQUIRED_CAPABILITY_ELEMENT, CAPABILITY_MULTIPLE_ATTRIBUTE, values[4], false).booleanValue();
-				currentCapability = new RequiredCapability(values[0], values[1], range, null, isOptional, isMultiple);
-				capabilities.add(currentCapability);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(CAPABILITY_FILTER_ELEMENT)) {
-					filterHandler = new TextHandler(this, CAPABILITY_FILTER_ELEMENT, attributes);
-				} else if (name.equalsIgnoreCase(CAPABILITY_SELECTORS_ELEMENT)) {
-					selectorsHandler = new CapabilitySelectorsHandler(this, attributes);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			protected void finished() {
-				if (isValidXML()) {
-					if (currentCapability != null) {
-						if (filterHandler != null) {
-							currentCapability.setFilter(filterHandler.getText());
-						}
-						if (selectorsHandler != null) {
-							currentCapability.setSelectors(selectorsHandler.getSelectors());
-						}
-					}
-				}
-			}
-		}
-
-		protected class ArtifactsHandler extends AbstractHandler {
-
-			private List artifacts;
-
-			public ArtifactsHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, ARTIFACT_KEYS_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				artifacts = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public IArtifactKey[] getArtifactKeys() {
-				return (IArtifactKey[]) artifacts.toArray(new IArtifactKey[artifacts.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(ARTIFACT_KEY_ELEMENT)) {
-					new ArtifactHandler(this, attributes, artifacts);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class ArtifactHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {NAMESPACE_ATTRIBUTE, CLASSIFIER_ATTRIBUTE, ID_ATTRIBUTE, VERSION_ATTRIBUTE};
-
-			public ArtifactHandler(AbstractHandler parentHandler, Attributes attributes, List artifacts) {
-				super(parentHandler, ARTIFACT_KEY_ELEMENT);
-				String[] values = parseRequiredAttributes(attributes, required);
-				Version version = checkVersion(ARTIFACT_KEY_ELEMENT, VERSION_ATTRIBUTE, values[3]);
-				artifacts.add(new ArtifactKey(values[0], values[1], values[2], version));
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				invalidElement(name, attributes);
-			}
-		}
-
-		protected class CapabilitySelectorsHandler extends AbstractHandler {
-
-			private List selectors;
-
-			public CapabilitySelectorsHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, CAPABILITY_SELECTORS_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				selectors = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public String[] getSelectors() {
-				return (String[]) selectors.toArray(new String[selectors.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(CAPABILITY_SELECTOR_ELEMENT)) {
-					new TextHandler(this, CAPABILITY_SELECTOR_ELEMENT, attributes, selectors);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class TouchpointTypeHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {ID_ATTRIBUTE, VERSION_ATTRIBUTE};
-
-			TouchpointType touchpointType = null;
-
-			public TouchpointTypeHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, TOUCHPOINT_TYPE_ELEMENT);
-				String[] values = parseRequiredAttributes(attributes, required);
-				Version version = checkVersion(TOUCHPOINT_TYPE_ELEMENT, VERSION_ATTRIBUTE, values[1]);
-				touchpointType = new TouchpointType(values[0], version);
-			}
-
-			public TouchpointType getTouchpointType() {
-				return touchpointType;
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				invalidElement(name, attributes);
-			}
-		}
-
-		protected class TouchpointDataHandler extends AbstractHandler {
-
-			TouchpointData touchpointData = null;
-
-			List data = null;
-
-			public TouchpointDataHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, TOUCHPOINT_DATA_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				data = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public TouchpointData[] getTouchpointData() {
-				return (TouchpointData[]) data.toArray(new TouchpointData[data.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT)) {
-					new TouchpointInstructionsHandler(this, attributes, data);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class TouchpointInstructionsHandler extends AbstractHandler {
-
-			Map instructions = null;
-
-			public TouchpointInstructionsHandler(AbstractHandler parentHandler, Attributes attributes, List data) {
-				super(parentHandler, TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				instructions = (size != null ? new LinkedHashMap(new Integer(size).intValue()) : new LinkedHashMap(4));
-				data.add(new TouchpointData(instructions));
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(TOUCHPOINT_DATA_INSTRUCTION_ELEMENT)) {
-					new TouchpointInstructionHandler(this, attributes, instructions);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class TouchpointInstructionHandler extends TextHandler {
-
-			private final String[] required = new String[] {TOUCHPOINT_DATA_INSTRUCTION_KEY_ATTRIBUTE};
-
-			Map instructions = null;
-			String key = null;
-
-			public TouchpointInstructionHandler(AbstractHandler parentHandler, Attributes attributes, Map instructions) {
-				super(parentHandler, TOUCHPOINT_DATA_INSTRUCTION_ELEMENT);
-				key = parseRequiredAttributes(attributes, required)[0];
-				this.instructions = instructions;
-			}
-
-			protected void finished() {
-				if (isValidXML()) {
-					if (key != null) {
-						instructions.put(key, getText());
-					}
-				}
-			}
-		}
-
 		protected String getErrorMessage() {
 			return Messages.InstallRegistry_Parser_Error_Parsing_Registry;
 		}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/MetadataCache.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/MetadataCache.java
new file mode 100644
index 0000000..3c43309
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/MetadataCache.java
@@ -0,0 +1,103 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.installregistry;
+
+import java.io.*;
+import java.net.URL;
+import java.util.EventObject;
+import org.eclipse.equinox.internal.p2.engine.EngineActivator;
+import org.eclipse.equinox.internal.p2.metadata.repository.*;
+import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
+import org.eclipse.equinox.p2.core.eventbus.ProvisioningListener;
+import org.eclipse.equinox.p2.core.helpers.ServiceHelper;
+import org.eclipse.equinox.p2.core.location.AgentLocation;
+import org.eclipse.equinox.p2.engine.*;
+import org.eclipse.equinox.p2.metadata.IResolvedInstallableUnit;
+import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
+import org.osgi.framework.ServiceReference;
+
+public class MetadataCache extends URLMetadataRepository {
+
+	static final private String REPOSITORY_NAME = "Agent Metadata Cache"; //$NON-NLS-1$
+	static final private String REPOSITORY_TYPE = MetadataCache.class.getName();
+	static final private Integer REPOSITORY_VERSION = new Integer(1);
+
+	transient private ServiceReference busReference;
+	transient private ProvisioningEventBus bus;
+
+	public MetadataCache() {
+		super();
+	}
+
+	public static MetadataCache getCacheInstance(MetadataRepositoryManager manager) {
+		AgentLocation agentLocation = (AgentLocation) ServiceHelper.getService(EngineActivator.getContext(), AgentLocation.class.getName());
+		URL url = (agentLocation != null ? agentLocation.getMetadataRepositoryURL() : null);
+		URL content = getActualLocation(url);
+		IMetadataRepository repository = manager.loadRepository(content, null);
+		if (repository == null || !(repository instanceof MetadataCache)) {
+			repository = new MetadataCache(url);
+			((MetadataCache) repository).initializeAfterLoad(url);
+			manager.addRepository(repository);
+		}
+		return (MetadataCache) repository;
+	}
+
+	// These are always created with file: URLs.  At least for now...
+	public MetadataCache(URL cacheLocation) {
+		super(REPOSITORY_NAME, REPOSITORY_TYPE, REPOSITORY_VERSION.toString(), cacheLocation, null, null);
+		content = getActualLocation(location);
+		// Set property indicating that the metadata cache is an implementation detail.
+		getModifiableProperties().setProperty(IMPLEMENTATION_ONLY_KEY, Boolean.valueOf(true).toString());
+	}
+
+	public void initializeAfterLoad(URL repoLocation) {
+		super.initializeAfterLoad(repoLocation);
+
+		// TODO: We should check for writing permission here, otherwise it may be too late
+		busReference = EngineActivator.getContext().getServiceReference(ProvisioningEventBus.class.getName());
+		bus = (ProvisioningEventBus) EngineActivator.getContext().getService(busReference);
+		bus.addListener(new ProvisioningListener() {
+			public void notify(EventObject o) {
+				if (o instanceof InstallableUnitEvent) { //TODO This dependency on InstallableUnitEvent is not great
+					InstallableUnitEvent event = (InstallableUnitEvent) o;
+					if (event.isPre())
+						return;
+					// TODO: what about uninstall??
+					if (event.isPost() && event.getResult().isOK() && event.isInstall()) {
+						IResolvedInstallableUnit installedIU = event.getOperand().second();
+						if (installedIU != null)
+							units.add(installedIU.getOriginal());
+						return;
+					}
+				}
+				if (o instanceof CommitOperationEvent)
+					persist();
+				if (o instanceof RollbackOperationEvent)
+					new SimpleMetadataRepositoryFactory().restore(MetadataCache.this, location);
+			}
+		});
+	}
+
+	protected void persist() {
+		if (!getContentURL().getProtocol().equals("file"))
+			throw new IllegalStateException("only file: URLs are supported for the metadata cache");
+		File contentFile = new File(getContentURL().getFile());
+		if (!contentFile.getParentFile().exists() && !contentFile.getParentFile().mkdirs())
+			throw new RuntimeException("can't persist the metadata cache");
+		try {
+			OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(contentFile, false));;
+			new MetadataRepositoryIO().write(this, outputStream);
+		} catch (FileNotFoundException e) {
+			throw new RuntimeException("can't persist the metadata cache");
+		}
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.exemplarysetup/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.exemplarysetup/META-INF/MANIFEST.MF
index 823a816..fdc2486 100644
--- a/bundles/org.eclipse.equinox.p2.exemplarysetup/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.exemplarysetup/META-INF/MANIFEST.MF
@@ -9,6 +9,8 @@ Import-Package: org.eclipse.equinox.internal.p2.artifact.repository,
  org.eclipse.equinox.internal.p2.metadata.repository,
  org.eclipse.equinox.p2.artifact.repository,
  org.eclipse.equinox.p2.core.eventbus,
+ org.eclipse.equinox.p2.core.helpers,
+ org.eclipse.equinox.p2.core.location,
  org.eclipse.equinox.p2.director,
  org.eclipse.equinox.p2.engine,
  org.eclipse.equinox.p2.installregistry,
diff --git a/bundles/org.eclipse.equinox.p2.exemplarysetup/src/org/eclipse/equinox/internal/p2/exemplarysetup/Activator.java b/bundles/org.eclipse.equinox.p2.exemplarysetup/src/org/eclipse/equinox/internal/p2/exemplarysetup/Activator.java
index 12e99cb..cd2dd71 100644
--- a/bundles/org.eclipse.equinox.p2.exemplarysetup/src/org/eclipse/equinox/internal/p2/exemplarysetup/Activator.java
+++ b/bundles/org.eclipse.equinox.p2.exemplarysetup/src/org/eclipse/equinox/internal/p2/exemplarysetup/Activator.java
@@ -15,8 +15,7 @@ import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
 import org.eclipse.equinox.p2.director.*;
 import org.eclipse.equinox.p2.engine.IProfileRegistry;
 import org.eclipse.equinox.p2.engine.SimpleProfileRegistry;
-import org.eclipse.equinox.p2.installregistry.IInstallRegistry;
-import org.eclipse.equinox.p2.installregistry.InstallRegistry;
+import org.eclipse.equinox.p2.installregistry.*;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepositoryManager;
 import org.osgi.framework.*;
 
@@ -29,6 +28,9 @@ public class Activator implements BundleActivator {
 	private IInstallRegistry installRegistry;
 	private ServiceRegistration registrationInstallRegistry;
 
+	private MetadataCache metadataCache;
+	private ServiceRegistration registrationMetadataCache;
+
 	private MetadataRepositoryManager defaultManager;
 	private ServiceRegistration registrationDefaultManager;
 
@@ -53,6 +55,7 @@ public class Activator implements BundleActivator {
 		registerProfileRegistry();
 		//create metadata repositories
 		registerDefaultMetadataRepoManager();
+		registerMetadataCache();
 		registerInstallRegistry();
 
 		//create the director and planner.  The planner must be
@@ -69,6 +72,7 @@ public class Activator implements BundleActivator {
 		unregisterDirector();
 		unregisterPlanner();
 		unregisterInstallRegistry();
+		unregisterMetadataCache();
 		unregisterDefaultMetadataRepoManager();
 		unregisterProfileRegistry();
 		unregisterEventBus();
@@ -83,6 +87,7 @@ public class Activator implements BundleActivator {
 
 	private void unregisterDirector() {
 		registrationDirector.unregister();
+		registrationDirector = null;
 		director = null;
 	}
 
@@ -93,6 +98,7 @@ public class Activator implements BundleActivator {
 
 	private void unregisterPlanner() {
 		registrationPlanner.unregister();
+		registrationPlanner = null;
 		planner = null;
 	}
 
@@ -103,6 +109,7 @@ public class Activator implements BundleActivator {
 
 	private void unregisterProfileRegistry() {
 		registrationProfileRegistry.unregister();
+		registrationProfileRegistry = null;
 		profileRegistry = null;
 	}
 
@@ -114,6 +121,7 @@ public class Activator implements BundleActivator {
 	private void unregisterDefaultMetadataRepoManager() {
 		registrationDefaultManager.unregister();
 		registrationDefaultManager = null;
+		defaultManager = null;
 	}
 
 	//	private void registerDefaultArtifactRepoManager() {
@@ -126,6 +134,21 @@ public class Activator implements BundleActivator {
 	//		artifactRepoManager = null;
 	//	}
 
+	private void registerMetadataCache() {
+		metadataCache = MetadataCache.getCacheInstance(defaultManager);
+		if (metadataCache != null) {
+			registrationMetadataCache = context.registerService(MetadataCache.class.getName(), metadataCache, null);
+		}
+	}
+
+	private void unregisterMetadataCache() {
+		if (registrationMetadataCache != null) {
+			registrationMetadataCache.unregister();
+		}
+		registrationMetadataCache = null;
+		metadataCache = null;
+	}
+
 	private void registerInstallRegistry() {
 		installRegistry = new InstallRegistry();
 		registrationInstallRegistry = context.registerService(IInstallRegistry.class.getName(), installRegistry, null);
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
index 5a6b98d..38c1696 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
@@ -48,7 +48,7 @@ public class MetadataGeneratorHelper {
 	public static final TouchpointType TOUCHPOINT_NATIVE = new TouchpointType("native", new Version(1, 0, 0)); //$NON-NLS-1$
 	public static final TouchpointType TOUCHPOINT_ECLIPSE = new TouchpointType("eclipse", new Version(1, 0, 0)); //$NON-NLS-1$
 
-	public static final ProvidedCapability FRAGMENT_CAPABILITY = new ProvidedCapability(IInstallableUnit.IU_KIND_NAMESPACE, "iu.fragment", new Version(1, 0, 0)); //$NON-NLS-1$
+	public static final ProvidedCapability FRAGMENT_CAPABILITY = InstallableUnitFragment.FRAGMENT_CAPABILITY;
 
 	public static ArtifactDescriptor createArtifactDescriptor(IArtifactKey key, File pathOnDisk, boolean asIs, boolean recurse) {
 		//TODO this size calculation is bogus
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.metadata.repository/META-INF/MANIFEST.MF
index 69d02e4..be6d46e 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/META-INF/MANIFEST.MF
@@ -5,7 +5,8 @@ Bundle-Name: %pluginName
 Bundle-Vendor: %providerName
 Bundle-Localization: plugin
 Bundle-Version: 0.1.0.qualifier
-Export-Package: org.eclipse.equinox.internal.p2.metadata.repository;x-friends:="org.eclipse.equinox.p2.metadata.generator",
+Export-Package: org.eclipse.equinox.internal.p2.metadata.repository;x-friends:="org.eclipse.equinox.p2.metadata.generator,org.eclipse.equinox.p2.engine",
+ org.eclipse.equinox.internal.p2.metadata.repository.io;x-friends:="org.eclipse.equinox.p2.engine",
  org.eclipse.equinox.p2.metadata.repository,
  org.eclipse.equinox.spi.p2.metadata.repository
 Import-Package: org.eclipse.core.runtime.preferences,
@@ -14,7 +15,6 @@ Import-Package: org.eclipse.core.runtime.preferences,
  org.eclipse.equinox.p2.core.helpers,
  org.eclipse.equinox.p2.core.location,
  org.eclipse.equinox.p2.core.repository,
- org.eclipse.equinox.p2.engine,
  org.eclipse.equinox.p2.metadata,
  org.eclipse.equinox.p2.query,
  org.eclipse.equinox.spi.p2.core.repository,
@@ -30,3 +30,4 @@ Bundle-RequiredExecutionEnvironment: CDC-1.1/Foundation-1.1,
  J2SE-1.4
 Require-Bundle: org.eclipse.equinox.common,
  org.eclipse.equinox.registry
+Eclipse-BuddyPolicy: registered
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
index 1405dcc..57016d9 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
@@ -93,7 +93,7 @@ public class LocalMetadataRepository extends AbstractMetadataRepository {
 					file.getParentFile().mkdirs();
 				file.createNewFile();
 			}
-			MetadataRepositoryIO.write(this, new FileOutputStream(file));
+			new MetadataRepositoryIO().write(this, new FileOutputStream(file));
 		} catch (FileNotFoundException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
@@ -118,15 +118,15 @@ public class LocalMetadataRepository extends AbstractMetadataRepository {
 		this.location = location;
 	}
 
-	public void initializeAfterLoad(LocalMetadataRepository source) {
-		name = source.name;
-		type = source.type;
-		version = source.version;
-		location = source.location;
-		description = source.description;
-		provider = source.provider;
-		properties = source.properties;
-		units = source.units;
+	public void revertToBackup(LocalMetadataRepository backup) {
+		name = backup.name;
+		type = backup.type;
+		version = backup.version;
+		location = backup.location;
+		description = backup.description;
+		provider = backup.provider;
+		properties = backup.properties;
+		units = backup.units;
 	}
 
 	public boolean isModifiable() {
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataCache.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataCache.java
index eb92ab9..76ae036 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataCache.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataCache.java
@@ -12,13 +12,7 @@ package org.eclipse.equinox.internal.p2.metadata.repository;
 
 import java.io.*;
 import java.net.URL;
-import java.util.EventObject;
-import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
-import org.eclipse.equinox.p2.core.eventbus.ProvisioningListener;
 import org.eclipse.equinox.p2.core.repository.RepositoryCreationException;
-import org.eclipse.equinox.p2.engine.*;
-import org.eclipse.equinox.p2.metadata.IResolvedInstallableUnit;
-import org.osgi.framework.ServiceReference;
 
 public class MetadataCache extends URLMetadataRepository {
 
@@ -26,8 +20,8 @@ public class MetadataCache extends URLMetadataRepository {
 	static final private String REPOSITORY_TYPE = MetadataCache.class.getName();
 	static final private Integer REPOSITORY_VERSION = new Integer(1);
 
-	transient private ServiceReference busReference;
-	transient private ProvisioningEventBus bus;
+	//	transient private ServiceReference busReference;
+	//	transient private ProvisioningEventBus bus;
 
 	// These are always created with file: URLs.  At least for now...
 	public MetadataCache(URL repoPath) throws RepositoryCreationException {
@@ -38,28 +32,28 @@ public class MetadataCache extends URLMetadataRepository {
 		getModifiableProperties().setProperty(IMPLEMENTATION_ONLY_KEY, Boolean.valueOf(true).toString());
 
 		// TODO: We should check for writing permission here, otherwise it may be too late
-		busReference = Activator.getContext().getServiceReference(ProvisioningEventBus.class.getName());
-		bus = (ProvisioningEventBus) Activator.getContext().getService(busReference);
-		bus.addListener(new ProvisioningListener() {
-			public void notify(EventObject o) {
-				if (o instanceof InstallableUnitEvent) { //TODO This dependency on InstallableUnitEvent is not great
-					InstallableUnitEvent event = (InstallableUnitEvent) o;
-					if (event.isPre())
-						return;
-					//TODO what about uninstall??
-					if (event.isPost() && event.getResult().isOK() && event.isInstall()) {
-						IResolvedInstallableUnit installedIU = event.getOperand().second();
-						if (installedIU != null)
-							units.add(installedIU.getOriginal());
-						return;
-					}
-				}
-				if (o instanceof CommitOperationEvent)
-					persist();
-				if (o instanceof RollbackOperationEvent)
-					new SimpleMetadataRepositoryFactory().restore(MetadataCache.this, location);
-			}
-		});
+		//		busReference = Activator.getContext().getServiceReference(ProvisioningEventBus.class.getName());
+		//		bus = (ProvisioningEventBus) Activator.getContext().getService(busReference);
+		//		bus.addListener(new ProvisioningListener() {
+		//			public void notify(EventObject o) {
+		//				if (o instanceof InstallableUnitEvent) { //TODO This dependency on InstallableUnitEvent is not great
+		//					InstallableUnitEvent event = (InstallableUnitEvent) o;
+		//					if (event.isPre())
+		//						return;
+		//					//TODO what about uninstall??
+		//					if (event.isPost() && event.getResult().isOK() && event.isInstall()) {
+		//						IResolvedInstallableUnit installedIU = event.getOperand().second();
+		//						if (installedIU != null)
+		//							units.add(installedIU.getOriginal());
+		//						return;
+		//					}
+		//				}
+		//				if (o instanceof CommitOperationEvent)
+		//					persist();
+		//				if (o instanceof RollbackOperationEvent)
+		//					new SimpleMetadataRepositoryFactory().restore(MetadataCache.this, location);
+		//			}
+		//		});
 	}
 
 	public MetadataCache() {
@@ -74,7 +68,7 @@ public class MetadataCache extends URLMetadataRepository {
 			throw new RuntimeException("can't persist the metadata cache");
 		try {
 			OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(contentFile, false));;
-			MetadataRepositoryIO.write(this, outputStream);
+			new MetadataRepositoryIO().write(this, outputStream);
 		} catch (FileNotFoundException e) {
 			throw new RuntimeException("can't persist the metadata cache");
 		}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryIO.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryIO.java
index a464323..43ce15e 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryIO.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryIO.java
@@ -12,14 +12,16 @@
 package org.eclipse.equinox.internal.p2.metadata.repository;
 
 import java.io.*;
-import java.util.*;
+import java.util.Set;
 import javax.xml.parsers.ParserConfigurationException;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
-import org.eclipse.equinox.p2.core.helpers.*;
+import org.eclipse.equinox.internal.p2.metadata.repository.io.MetadataParser;
+import org.eclipse.equinox.internal.p2.metadata.repository.io.MetadataWriter;
+import org.eclipse.equinox.p2.core.helpers.OrderedProperties;
+import org.eclipse.equinox.p2.core.helpers.XMLWriter;
 import org.eclipse.equinox.p2.core.repository.RepositoryCreationException;
-import org.eclipse.equinox.p2.metadata.*;
+import org.eclipse.equinox.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.spi.p2.metadata.repository.AbstractMetadataRepository;
 import org.eclipse.equinox.spi.p2.metadata.repository.AbstractMetadataRepository.RepositoryState;
@@ -31,84 +33,15 @@ import org.xml.sax.*;
 
 /**
  * This class reads and writes provisioning metadata.
- * The implementation currently uses XStream.
  */
-class MetadataRepositoryIO {
+public class MetadataRepositoryIO {
 
 	/**
 	 * Reads metadata from the given stream, and returns the contained array
 	 * of abstract metadata repositories.
 	 * This method performs buffering, and closes the stream when finished.
-	 * 
-	 * @deprecated
 	 */
-	public static IMetadataRepository read(InputStream input) throws RepositoryCreationException {
-		MetadataRepositoryIO io = new MetadataRepositoryIO();
-		return io.readNew(input);
-		//		XStream stream = new XStream();
-		//		BufferedInputStream bufferedInput = null;
-		//		try {
-		//			try {
-		//				bufferedInput = new BufferedInputStream(input);
-		//				return (IMetadataRepository) stream.fromXML(bufferedInput);
-		//			} finally {
-		//				if (bufferedInput != null)
-		//					bufferedInput.close();
-		//			}
-		//		} catch (IOException e) {
-		//			throw new RepositoryCreationException(e);
-		//		}
-	}
-
-	/**
-	 * 	@deprecated
-	 */
-	public static void write(IMetadataRepository repository, OutputStream output) {
-		MetadataRepositoryIO io = new MetadataRepositoryIO();
-		io.writeNew(repository, output);
-		//		XStream stream = new XStream();
-		//		OutputStream bufferedOutput = null;
-		//		try {
-		//			try {
-		//				bufferedOutput = new BufferedOutputStream(output);
-		//				stream.toXML(repository, bufferedOutput);
-		//			} finally {
-		//				if (bufferedOutput != null)
-		//					bufferedOutput.close();
-		//			}
-		//		} catch (FileNotFoundException e) {
-		//			// TODO Auto-generated catch block
-		//			e.printStackTrace();
-		//		} catch (IOException e) {
-		//			// TODO Auto-generated catch block
-		//			e.printStackTrace();
-		//		}
-	}
-
-	public void writeNew(IMetadataRepository repository, OutputStream output) {
-		OutputStream bufferedOutput = null;
-		try {
-			try {
-				bufferedOutput = new BufferedOutputStream(output);
-				Writer repositoryWriter = new Writer(bufferedOutput, repository.getClass());
-				repositoryWriter.write(repository);
-			} finally {
-				if (bufferedOutput != null) {
-					bufferedOutput.close();
-				}
-			}
-		} catch (IOException ioe) {
-			// TODO shouldn't this throw a core exception?
-			ioe.printStackTrace();
-		}
-	}
-
-	/**
-	 * Reads metadata from the given stream, and returns the contained array
-	 * of abstract metadata repositories.
-	 * This method performs buffering, and closes the stream when finished.
-	 */
-	public IMetadataRepository readNew(InputStream input) throws RepositoryCreationException {
+	public IMetadataRepository read(InputStream input) throws RepositoryCreationException {
 		BufferedInputStream bufferedInput = null;
 		try {
 			try {
@@ -130,7 +63,28 @@ class MetadataRepositoryIO {
 		}
 	}
 
-	private interface XMLConstants extends org.eclipse.equinox.p2.core.helpers.XMLConstants {
+	/**
+	 *
+	 */
+	public void write(IMetadataRepository repository, OutputStream output) {
+		OutputStream bufferedOutput = null;
+		try {
+			try {
+				bufferedOutput = new BufferedOutputStream(output);
+				Writer repositoryWriter = new Writer(bufferedOutput, repository.getClass());
+				repositoryWriter.write(repository);
+			} finally {
+				if (bufferedOutput != null) {
+					bufferedOutput.close();
+				}
+			}
+		} catch (IOException ioe) {
+			// TODO shouldn't this throw a core exception?
+			ioe.printStackTrace();
+		}
+	}
+
+	private interface XMLConstants extends org.eclipse.equinox.internal.p2.metadata.repository.io.XMLConstants {
 
 		// Constants defining the structure of the XML for a MetadataRepository
 
@@ -141,52 +95,9 @@ class MetadataRepositoryIO {
 
 		// Constants for processing Instructions
 		public static final String PI_REPOSITORY_TARGET = "metadataRepository"; //$NON-NLS-1$
-		//public static XMLWriter.ProcessingInstruction[] PI_DEFAULTS = new XMLWriter.ProcessingInstruction[] {XMLWriter.ProcessingInstruction.makeClassVersionInstruction(PI_REPOSITORY_TARGET, IMetadataRepository.class, CURRENT_VERSION)};
 
 		// Constants for metadata repository elements
 		public static final String REPOSITORY_ELEMENT = "repository"; //$NON-NLS-1$
-		public static final String INSTALLABLE_UNITS_ELEMENT = "units"; //$NON-NLS-1$
-		public static final String INSTALLABLE_UNIT_ELEMENT = "unit"; //$NON-NLS-1$
-
-		// Constants for sub-elements of an installable unit element
-		public static final String ARTIFACT_KEYS_ELEMENT = "artifacts"; //$NON-NLS-1$
-		public static final String ARTIFACT_KEY_ELEMENT = "artifact"; //$NON-NLS-1$
-		public static final String REQUIRED_CAPABILITIES_ELEMENT = "requires"; //$NON-NLS-1$
-		public static final String REQUIRED_CAPABILITY_ELEMENT = "required"; //$NON-NLS-1$
-		public static final String PROVIDED_CAPABILITIES_ELEMENT = "provides"; //$NON-NLS-1$
-		public static final String PROVIDED_CAPABILITY_ELEMENT = "provided"; //$NON-NLS-1$
-		public static final String TOUCHPOINT_TYPE_ELEMENT = "touchpoint"; //$NON-NLS-1$
-		public static final String TOUCHPOINT_DATA_ELEMENT = "touchpointData"; //$NON-NLS-1$
-		public static final String IU_FILTER_ELEMENT = "filter"; //$NON-NLS-1$
-		public static final String APPLICABILITY_FILTER_ELEMENT = "applicability"; //$NON-NLS-1$
-
-		// Constants for attributes of an installable unit element
-		public static final String SINGLETON_ATTRIBUTE = "singleton"; //$NON-NLS-1$
-		public static final String FRAGMENT_ATTRIBUTE = "fragment"; //$NON-NLS-1$
-
-		// Constants for attributes of a fragment installable unit element
-		public static final String FRAGMENT_HOST_ID_ATTRIBUTE = "hostId"; //$NON-NLS-1$
-		public static final String FRAGMENT_HOST_RANGE_ATTRIBUTE = "hostRange"; //$NON-NLS-1$
-
-		// Constants for sub-elements of a required capability element
-		public static final String CAPABILITY_FILTER_ELEMENT = "filter"; //$NON-NLS-1$
-		public static final String CAPABILITY_SELECTORS_ELEMENT = "selectors"; //$NON-NLS-1$
-		public static final String CAPABILITY_SELECTOR_ELEMENT = "selector"; //$NON-NLS-1$
-
-		// Constants for attributes of a required capability element
-		public static final String CAPABILITY_OPTIONAL_ATTRIBUTE = "optional"; //$NON-NLS-1$
-		public static final String CAPABILITY_MULTIPLE_ATTRIBUTE = "multiple"; //$NON-NLS-1$
-
-		// Constants for attributes of an artifact key element
-		public static final String ARTIFACT_KEY_NAMESPACE_ATTRIBUTE = NAMESPACE_ATTRIBUTE;
-		public static final String ARTIFACT_KEY_CLASSIFIER_ATTRIBUTE = "classifier"; //$NON-NLS-1$
-
-		// Constants for sub-elements of a touchpoint data element
-		public static final String TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT = "instructions"; //$NON-NLS-1$
-		public static final String TOUCHPOINT_DATA_INSTRUCTION_ELEMENT = "instruction"; //$NON-NLS-1$
-
-		// Constants for attributes of an a touchpoint data instruction element
-		public static final String TOUCHPOINT_DATA_INSTRUCTION_KEY_ATTRIBUTE = "key"; //$NON-NLS-1$
 
 	}
 
@@ -195,7 +106,7 @@ class MetadataRepositoryIO {
 	}
 
 	// XML writer for a IMetadataRepository
-	protected class Writer extends XMLWriter implements XMLConstants {
+	protected class Writer extends MetadataWriter implements XMLConstants {
 
 		public Writer(OutputStream output, Class repositoryClass) throws IOException {
 			super(output, createPI(repositoryClass));
@@ -221,9 +132,6 @@ class MetadataRepositoryIO {
 
 		private IInstallableUnit[] getInstallableUnits(IMetadataRepository repository) {
 			// TODO: there must be a better solution to the problem.
-			// TODO: Because the implementation of IMetadataRepository.getInstallableUnits
-			//		 in LocalMetadataRepository uses a query, the order of IUs is not preserved
-			//		 write after read. FIX THIS!
 			Set units = null;
 			if (repository instanceof LocalMetadataRepository) {
 				units = ((LocalMetadataRepository) repository).getInstallableUnits();
@@ -235,156 +143,13 @@ class MetadataRepositoryIO {
 			return (units == null ? new IInstallableUnit[0] //
 					: (IInstallableUnit[]) units.toArray(new IInstallableUnit[units.size()]));
 		}
-
-		private void writeInstallableUnits(IInstallableUnit[] installableUnits) {
-			if (installableUnits.length > 0) {
-				start(INSTALLABLE_UNITS_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, installableUnits.length);
-				for (int i = 0; i < installableUnits.length; i++) {
-					writeInstallableUnit(installableUnits[i]);
-				}
-				end(INSTALLABLE_UNITS_ELEMENT);
-			}
-		}
-
-		private void writeInstallableUnit(IInstallableUnit resolvedIU) {
-			IInstallableUnit iu = (!(resolvedIU instanceof IResolvedInstallableUnit) ? resolvedIU//
-					: ((IResolvedInstallableUnit) resolvedIU).getOriginal());
-			start(INSTALLABLE_UNIT_ELEMENT);
-			attribute(ID_ATTRIBUTE, iu.getId());
-			attribute(VERSION_ATTRIBUTE, iu.getVersion());
-			attribute(SINGLETON_ATTRIBUTE, iu.isSingleton(), true);
-			attribute(FRAGMENT_ATTRIBUTE, iu.isFragment(), false);
-
-			if (iu.isFragment() && iu instanceof IInstallableUnitFragment) {
-				IInstallableUnitFragment fragment = (IInstallableUnitFragment) iu;
-				attribute(FRAGMENT_HOST_ID_ATTRIBUTE, fragment.getHostId());
-				attribute(FRAGMENT_HOST_RANGE_ATTRIBUTE, fragment.getHostVersionRange());
-			}
-
-			writeProperties(iu.getProperties());
-			writeProvidedCapabilities(iu.getProvidedCapabilities());
-			writeRequiredCapabilities(iu.getRequiredCapabilities());
-			writeTrimmedCdata(IU_FILTER_ELEMENT, iu.getFilter());
-			writeTrimmedCdata(APPLICABILITY_FILTER_ELEMENT, iu.getApplicabilityFilter());
-
-			writeArtifactKeys(iu.getArtifacts());
-			writeTouchpointType(iu.getTouchpointType());
-			writeTouchpointData(iu.getTouchpointData());
-
-			end(INSTALLABLE_UNIT_ELEMENT);
-		}
-
-		private void writeProvidedCapabilities(ProvidedCapability[] capabilities) {
-			if (capabilities != null && capabilities.length > 0) {
-				start(PROVIDED_CAPABILITIES_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, capabilities.length);
-				for (int i = 0; i < capabilities.length; i++) {
-					start(PROVIDED_CAPABILITY_ELEMENT);
-					attribute(NAMESPACE_ATTRIBUTE, capabilities[i].getNamespace());
-					attribute(NAME_ATTRIBUTE, capabilities[i].getName());
-					attribute(VERSION_ATTRIBUTE, capabilities[i].getVersion());
-					end(PROVIDED_CAPABILITY_ELEMENT);
-				}
-				end(PROVIDED_CAPABILITIES_ELEMENT);
-			}
-		}
-
-		private void writeRequiredCapabilities(RequiredCapability[] capabilities) {
-			if (capabilities != null && capabilities.length > 0) {
-				start(REQUIRED_CAPABILITIES_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, capabilities.length);
-				for (int i = 0; i < capabilities.length; i++) {
-					writeRequiredCapability(capabilities[i]);
-				}
-				end(REQUIRED_CAPABILITIES_ELEMENT);
-			}
-		}
-
-		private void writeRequiredCapability(RequiredCapability capability) {
-			start(REQUIRED_CAPABILITY_ELEMENT);
-			attribute(NAMESPACE_ATTRIBUTE, capability.getNamespace());
-			attribute(NAME_ATTRIBUTE, capability.getName());
-			attribute(VERSION_RANGE_ATTRIBUTE, capability.getRange());
-			attribute(CAPABILITY_OPTIONAL_ATTRIBUTE, capability.isOptional(), false);
-			attribute(CAPABILITY_MULTIPLE_ATTRIBUTE, capability.isMultiple(), false);
-
-			writeTrimmedCdata(CAPABILITY_FILTER_ELEMENT, capability.getFilter());
-
-			String[] selectors = capability.getSelectors();
-			if (selectors.length > 0) {
-				start(CAPABILITY_SELECTORS_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, selectors.length);
-				for (int j = 0; j < selectors.length; j++) {
-					writeTrimmedCdata(CAPABILITY_SELECTOR_ELEMENT, selectors[j]);
-				}
-				end(CAPABILITY_SELECTORS_ELEMENT);
-			}
-
-			end(REQUIRED_CAPABILITY_ELEMENT);
-		}
-
-		private void writeArtifactKeys(IArtifactKey[] artifactKeys) {
-			if (artifactKeys != null && artifactKeys.length > 0) {
-				start(ARTIFACT_KEYS_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, artifactKeys.length);
-				for (int i = 0; i < artifactKeys.length; i++) {
-					start(ARTIFACT_KEY_ELEMENT);
-					attribute(ARTIFACT_KEY_NAMESPACE_ATTRIBUTE, artifactKeys[i].getNamespace());
-					attribute(ARTIFACT_KEY_CLASSIFIER_ATTRIBUTE, artifactKeys[i].getClassifier());
-					attribute(ID_ATTRIBUTE, artifactKeys[i].getId());
-					attribute(VERSION_ATTRIBUTE, artifactKeys[i].getVersion());
-					end(ARTIFACT_KEY_ELEMENT);
-				}
-				end(ARTIFACT_KEYS_ELEMENT);
-			}
-		}
-
-		private void writeTouchpointType(TouchpointType touchpointType) {
-			start(TOUCHPOINT_TYPE_ELEMENT);
-			attribute(ID_ATTRIBUTE, touchpointType.getId());
-			attribute(VERSION_ATTRIBUTE, touchpointType.getVersion());
-			end(TOUCHPOINT_TYPE_ELEMENT);
-		}
-
-		private void writeTouchpointData(TouchpointData[] touchpointData) {
-			if (touchpointData != null && touchpointData.length > 0) {
-				start(TOUCHPOINT_DATA_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, touchpointData.length);
-				for (int i = 0; i < touchpointData.length; i++) {
-					TouchpointData nextData = touchpointData[i];
-					Map instructions = nextData.getInstructions();
-					if (instructions.size() > 0) {
-						start(TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT);
-						attribute(COLLECTION_SIZE_ATTRIBUTE, instructions.size());
-						for (Iterator iter = instructions.entrySet().iterator(); iter.hasNext();) {
-							Map.Entry entry = (Map.Entry) iter.next();
-							start(TOUCHPOINT_DATA_INSTRUCTION_ELEMENT);
-							attribute(TOUCHPOINT_DATA_INSTRUCTION_KEY_ATTRIBUTE, entry.getKey());
-							cdata((String) entry.getValue(), true);
-							end(TOUCHPOINT_DATA_INSTRUCTION_ELEMENT);
-						}
-					}
-				}
-				end(TOUCHPOINT_DATA_ELEMENT);
-			}
-		}
-
-		private void writeTrimmedCdata(String element, String filter) {
-			String trimmed;
-			if (filter != null && (trimmed = filter.trim()).length() > 0) {
-				start(element);
-				cdata(trimmed);
-				end(element);
-			}
-		}
 	}
 
 	/*
-	 * Parser for the contents of a LocalMetadata,
-	 * as written by the Writer class.
+	 * 	Parser for the contents of a metadata repository,
+	 * 	as written by the Writer class.
 	 */
-	private class Parser extends XMLParser implements XMLConstants {
+	private class Parser extends MetadataParser implements XMLConstants {
 
 		private IMetadataRepository theRepository = null;
 		protected Class theRepositoryClass = null;
@@ -430,31 +195,32 @@ class MetadataRepositoryIO {
 			return theRepository;
 		}
 
-		public void ProcessingInstruction(String target, String data) throws SAXException {
-			if (PI_REPOSITORY_TARGET.equalsIgnoreCase(target)) {
-				// TODO: should the root handler be constructed based on class
-				// 		 via an extension registry mechanism?
-				String clazz = extractPIClass(data);
-				try {
-					theRepositoryClass = Class.forName(clazz);
-				} catch (ClassNotFoundException e) {
-					// throw new SAXException(NLS.bind(Messages.MetadataRepositoryIO_Repository_Class_Not_Found, clazz));
-					throw new SAXException("Metadata repository class " + clazz + "not found"); //$NON-NLS-1$//$NON-NLS-2$
-				}
-
-				// TODO: version tolerance by extension
-				Version repositoryVersion = extractPIVersion(target, data);
-				if (!XML_TOLERANCE.isIncluded(repositoryVersion)) {
-					throw new SAXException(NLS.bind(Messages.MetadataRepositoryIO_Parser_Has_Incompatible_Version, repositoryVersion, XML_TOLERANCE));
-				}
-			}
-		}
-
 		private final class RepositoryDocHandler extends DocHandler {
 
 			public RepositoryDocHandler(String rootName, RootHandler rootHandler) {
 				super(rootName, rootHandler);
 			}
+
+			public void processingInstruction(String target, String data) throws SAXException {
+				if (PI_REPOSITORY_TARGET.equalsIgnoreCase(target)) {
+					// TODO: should the root handler be constructed based on class
+					// 		 via an extension registry mechanism?
+					String clazz = extractPIClass(data);
+					try {
+						theRepositoryClass = Class.forName(clazz);
+					} catch (ClassNotFoundException e) {
+						// throw new SAXException(NLS.bind(Messages.MetadataRepositoryIO_Repository_Class_Not_Found, clazz));
+						throw new SAXException("Metadata repository class '" + clazz + "' not found"); //$NON-NLS-1$//$NON-NLS-2$
+					}
+
+					// TODO: version tolerance by extension?
+					Version repositoryVersion = extractPIVersion(target, data);
+					if (!MetadataRepositoryIO.XMLConstants.XML_TOLERANCE.isIncluded(repositoryVersion)) {
+						throw new SAXException(NLS.bind(Messages.MetadataRepositoryIO_Parser_Has_Incompatible_Version, repositoryVersion, MetadataRepositoryIO.XMLConstants.XML_TOLERANCE));
+					}
+				}
+			}
+
 		}
 
 		private final class RepositoryHandler extends RootHandler {
@@ -485,17 +251,7 @@ class MetadataRepositoryIO {
 				state.Version = version;
 				state.Description = values[3];
 				state.Provider = values[4];
-				state.Location = null; // new URL("file://C:/bogus");
-				// TODO: handling of processing instructions is not working,
-				//       so set the class here. FIX THIS!
-				if (theRepositoryClass == null) {
-					try {
-						theRepositoryClass = Class.forName(state.Type);
-					} catch (ClassNotFoundException e) {
-						// throw new SAXException(NLS.bind(Messages.MetadataRepositoryIO_Repository_Class_Not_Found, state.Type));
-						addError("Metadata repository class " + state.Type + "not found"); //$NON-NLS-1$//$NON-NLS-2$
-					}
-				}
+				state.Location = null;
 			}
 
 			public void startElement(String name, Attributes attributes) {
@@ -539,416 +295,6 @@ class MetadataRepositoryIO {
 			}
 		}
 
-		protected class InstallableUnitsHandler extends AbstractHandler {
-
-			private ArrayList units;
-
-			public InstallableUnitsHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, INSTALLABLE_UNITS_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				units = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public IInstallableUnit[] getUnits() {
-				return (IInstallableUnit[]) units.toArray(new IInstallableUnit[units.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(INSTALLABLE_UNIT_ELEMENT)) {
-					new InstallableUnitHandler(this, attributes, units);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class InstallableUnitHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {ID_ATTRIBUTE, VERSION_ATTRIBUTE};
-			private final String[] optional = new String[] {SINGLETON_ATTRIBUTE, FRAGMENT_ATTRIBUTE, FRAGMENT_HOST_ID_ATTRIBUTE, FRAGMENT_HOST_RANGE_ATTRIBUTE};
-
-			InstallableUnit currentUnit = null;
-
-			private PropertiesHandler propertiesHandler = null;
-			private ProvidedCapabilitiesHandler providedCapabilitiesHandler = null;
-			private RequiredCapabilitiesHandler requiredCapabilitiesHandler = null;
-			private TextHandler filterHandler = null;
-			private TextHandler applicabilityHandler = null;
-			private ArtifactsHandler artifactsHandler = null;
-			private TouchpointTypeHandler touchpointTypeHandler = null;
-			private TouchpointDataHandler touchpointDataHandler = null;
-
-			public InstallableUnitHandler(AbstractHandler parentHandler, Attributes attributes, List units) {
-				super(parentHandler, INSTALLABLE_UNIT_ELEMENT);
-				String[] values = parseAttributes(attributes, required, optional);
-
-				Version version = checkVersion(INSTALLABLE_UNIT_ELEMENT, VERSION_ATTRIBUTE, values[1]);
-				boolean singleton = checkBoolean(INSTALLABLE_UNIT_ELEMENT, SINGLETON_ATTRIBUTE, values[2], true).booleanValue();
-				boolean isFragment = checkBoolean(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_ATTRIBUTE, values[3], false).booleanValue();
-				if (isFragment) {
-					// TODO: tooling default fragment does not have a host id
-					// checkRequiredAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_ID_ATTRIBUTE, values[4]);
-					checkRequiredAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_RANGE_ATTRIBUTE, values[5]);
-					VersionRange hostRange = checkVersionRange(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_RANGE_ATTRIBUTE, values[5]);
-					currentUnit = new InstallableUnitFragment(values[0], version, singleton, values[4], hostRange);
-				} else {
-					if (values[4] != null) {
-						unexpectedAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_ID_ATTRIBUTE, values[4]);
-					} else if (values[5] != null) {
-						unexpectedAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_RANGE_ATTRIBUTE, values[4]);
-					}
-					currentUnit = new InstallableUnit(values[0], version, singleton);
-				}
-				units.add(currentUnit);
-			}
-
-			public IInstallableUnit getInstallableUnit() {
-				return currentUnit;
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (PROPERTIES_ELEMENT.equalsIgnoreCase(name)) {
-					if (propertiesHandler == null) {
-						propertiesHandler = new PropertiesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (PROVIDED_CAPABILITIES_ELEMENT.equalsIgnoreCase(name)) {
-					if (providedCapabilitiesHandler == null) {
-						providedCapabilitiesHandler = new ProvidedCapabilitiesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (REQUIRED_CAPABILITIES_ELEMENT.equalsIgnoreCase(name)) {
-					if (requiredCapabilitiesHandler == null) {
-						requiredCapabilitiesHandler = new RequiredCapabilitiesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (IU_FILTER_ELEMENT.equalsIgnoreCase(name)) {
-					if (filterHandler == null) {
-						filterHandler = new TextHandler(this, IU_FILTER_ELEMENT, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (APPLICABILITY_FILTER_ELEMENT.equalsIgnoreCase(name)) {
-					if (applicabilityHandler == null) {
-						applicabilityHandler = new TextHandler(this, APPLICABILITY_FILTER_ELEMENT, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (ARTIFACT_KEYS_ELEMENT.equalsIgnoreCase(name)) {
-					if (artifactsHandler == null) {
-						artifactsHandler = new ArtifactsHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (TOUCHPOINT_TYPE_ELEMENT.equalsIgnoreCase(name)) {
-					if (touchpointTypeHandler == null) {
-						touchpointTypeHandler = new TouchpointTypeHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (TOUCHPOINT_DATA_ELEMENT.equalsIgnoreCase(name)) {
-					if (touchpointDataHandler == null) {
-						touchpointDataHandler = new TouchpointDataHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			protected void finished() {
-				if (isValidXML() && currentUnit != null) {
-					OrderedProperties properties = (propertiesHandler == null ? new OrderedProperties(0) //
-							: propertiesHandler.getProperties());
-					currentUnit.addProperties(properties);
-					ProvidedCapability[] providedCapabilities = (providedCapabilitiesHandler == null ? new ProvidedCapability[0] //
-							: providedCapabilitiesHandler.getProvidedCapabilities());
-					currentUnit.setCapabilities(providedCapabilities);
-					RequiredCapability[] requiredCapabilities = (requiredCapabilitiesHandler == null ? new RequiredCapability[0] //
-							: requiredCapabilitiesHandler.getRequiredCapabilities());
-					currentUnit.setRequiredCapabilities(requiredCapabilities);
-					if (filterHandler != null) {
-						currentUnit.setFilter(filterHandler.getText());
-					}
-					if (applicabilityHandler != null) {
-						currentUnit.setApplicabilityFilter(applicabilityHandler.getText());
-					}
-					IArtifactKey[] artifacts = (artifactsHandler == null ? new IArtifactKey[0] //
-							: artifactsHandler.getArtifactKeys());
-					currentUnit.setArtifacts(artifacts);
-					if (touchpointTypeHandler != null) {
-						currentUnit.setTouchpointType(touchpointTypeHandler.getTouchpointType());
-					} else {
-						// TODO: create an error
-					}
-					TouchpointData[] touchpointData = (touchpointDataHandler == null ? new TouchpointData[0] //
-							: touchpointDataHandler.getTouchpointData());
-					currentUnit.addTouchpointData(touchpointData);
-				}
-			}
-		}
-
-		protected class ProvidedCapabilitiesHandler extends AbstractHandler {
-
-			private List providedCapabilities;
-
-			public ProvidedCapabilitiesHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, PROVIDED_CAPABILITIES_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				providedCapabilities = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public ProvidedCapability[] getProvidedCapabilities() {
-				return (ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(PROVIDED_CAPABILITY_ELEMENT)) {
-					new ProvidedCapabilityHandler(this, attributes, providedCapabilities);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class ProvidedCapabilityHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {NAMESPACE_ATTRIBUTE, NAME_ATTRIBUTE, VERSION_ATTRIBUTE};
-
-			public ProvidedCapabilityHandler(AbstractHandler parentHandler, Attributes attributes, List capabilities) {
-				super(parentHandler, PROVIDED_CAPABILITY_ELEMENT);
-				String[] values = parseRequiredAttributes(attributes, required);
-				Version version = checkVersion(PROVIDED_CAPABILITY_ELEMENT, VERSION_ATTRIBUTE, values[2]);
-				capabilities.add(new ProvidedCapability(values[0], values[1], version));
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				invalidElement(name, attributes);
-			}
-		}
-
-		protected class RequiredCapabilitiesHandler extends AbstractHandler {
-
-			private List requiredCapabilities;
-
-			public RequiredCapabilitiesHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, REQUIRED_CAPABILITIES_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				requiredCapabilities = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public RequiredCapability[] getRequiredCapabilities() {
-				return (RequiredCapability[]) requiredCapabilities.toArray(new RequiredCapability[requiredCapabilities.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(REQUIRED_CAPABILITY_ELEMENT)) {
-					new RequiredCapabilityHandler(this, attributes, requiredCapabilities);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class RequiredCapabilityHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {NAMESPACE_ATTRIBUTE, NAME_ATTRIBUTE, VERSION_RANGE_ATTRIBUTE};
-			private final String[] optional = new String[] {CAPABILITY_OPTIONAL_ATTRIBUTE, CAPABILITY_MULTIPLE_ATTRIBUTE};
-
-			private RequiredCapability currentCapability = null;
-
-			private TextHandler filterHandler = null;
-			private CapabilitySelectorsHandler selectorsHandler = null;
-
-			public RequiredCapabilityHandler(AbstractHandler parentHandler, Attributes attributes, List capabilities) {
-				super(parentHandler, REQUIRED_CAPABILITY_ELEMENT);
-				String[] values = parseAttributes(attributes, required, optional);
-				VersionRange range = checkVersionRange(REQUIRED_CAPABILITY_ELEMENT, VERSION_RANGE_ATTRIBUTE, values[2]);
-				boolean isOptional = checkBoolean(REQUIRED_CAPABILITY_ELEMENT, CAPABILITY_OPTIONAL_ATTRIBUTE, values[3], false).booleanValue();
-				boolean isMultiple = checkBoolean(REQUIRED_CAPABILITY_ELEMENT, CAPABILITY_MULTIPLE_ATTRIBUTE, values[4], false).booleanValue();
-				currentCapability = new RequiredCapability(values[0], values[1], range, null, isOptional, isMultiple);
-				capabilities.add(currentCapability);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(CAPABILITY_FILTER_ELEMENT)) {
-					filterHandler = new TextHandler(this, CAPABILITY_FILTER_ELEMENT, attributes);
-				} else if (name.equalsIgnoreCase(CAPABILITY_SELECTORS_ELEMENT)) {
-					selectorsHandler = new CapabilitySelectorsHandler(this, attributes);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			protected void finished() {
-				if (isValidXML()) {
-					if (currentCapability != null) {
-						if (filterHandler != null) {
-							currentCapability.setFilter(filterHandler.getText());
-						}
-						if (selectorsHandler != null) {
-							currentCapability.setSelectors(selectorsHandler.getSelectors());
-						}
-					}
-				}
-			}
-		}
-
-		protected class ArtifactsHandler extends AbstractHandler {
-
-			private List artifacts;
-
-			public ArtifactsHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, ARTIFACT_KEYS_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				artifacts = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public IArtifactKey[] getArtifactKeys() {
-				return (IArtifactKey[]) artifacts.toArray(new IArtifactKey[artifacts.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(ARTIFACT_KEY_ELEMENT)) {
-					new ArtifactHandler(this, attributes, artifacts);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class ArtifactHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {NAMESPACE_ATTRIBUTE, CLASSIFIER_ATTRIBUTE, ID_ATTRIBUTE, VERSION_ATTRIBUTE};
-
-			public ArtifactHandler(AbstractHandler parentHandler, Attributes attributes, List artifacts) {
-				super(parentHandler, ARTIFACT_KEY_ELEMENT);
-				String[] values = parseRequiredAttributes(attributes, required);
-				Version version = checkVersion(ARTIFACT_KEY_ELEMENT, VERSION_ATTRIBUTE, values[3]);
-				artifacts.add(new ArtifactKey(values[0], values[1], values[2], version));
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				invalidElement(name, attributes);
-			}
-		}
-
-		protected class CapabilitySelectorsHandler extends AbstractHandler {
-
-			private List selectors;
-
-			public CapabilitySelectorsHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, CAPABILITY_SELECTORS_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				selectors = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public String[] getSelectors() {
-				return (String[]) selectors.toArray(new String[selectors.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(CAPABILITY_SELECTOR_ELEMENT)) {
-					new TextHandler(this, CAPABILITY_SELECTOR_ELEMENT, attributes, selectors);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class TouchpointTypeHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {ID_ATTRIBUTE, VERSION_ATTRIBUTE};
-
-			TouchpointType touchpointType = null;
-
-			public TouchpointTypeHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, TOUCHPOINT_TYPE_ELEMENT);
-				String[] values = parseRequiredAttributes(attributes, required);
-				Version version = checkVersion(TOUCHPOINT_TYPE_ELEMENT, VERSION_ATTRIBUTE, values[1]);
-				touchpointType = new TouchpointType(values[0], version);
-			}
-
-			public TouchpointType getTouchpointType() {
-				return touchpointType;
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				invalidElement(name, attributes);
-			}
-		}
-
-		protected class TouchpointDataHandler extends AbstractHandler {
-
-			TouchpointData touchpointData = null;
-
-			List data = null;
-
-			public TouchpointDataHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, TOUCHPOINT_DATA_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				data = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public TouchpointData[] getTouchpointData() {
-				return (TouchpointData[]) data.toArray(new TouchpointData[data.size()]);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT)) {
-					new TouchpointInstructionsHandler(this, attributes, data);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class TouchpointInstructionsHandler extends AbstractHandler {
-
-			Map instructions = null;
-
-			public TouchpointInstructionsHandler(AbstractHandler parentHandler, Attributes attributes, List data) {
-				super(parentHandler, TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				instructions = (size != null ? new LinkedHashMap(new Integer(size).intValue()) : new LinkedHashMap(4));
-				data.add(new TouchpointData(instructions));
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equalsIgnoreCase(TOUCHPOINT_DATA_INSTRUCTION_ELEMENT)) {
-					new TouchpointInstructionHandler(this, attributes, instructions);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class TouchpointInstructionHandler extends TextHandler {
-
-			private final String[] required = new String[] {TOUCHPOINT_DATA_INSTRUCTION_KEY_ATTRIBUTE};
-
-			Map instructions = null;
-			String key = null;
-
-			public TouchpointInstructionHandler(AbstractHandler parentHandler, Attributes attributes, Map instructions) {
-				super(parentHandler, TOUCHPOINT_DATA_INSTRUCTION_ELEMENT);
-				key = parseRequiredAttributes(attributes, required)[0];
-				this.instructions = instructions;
-			}
-
-			protected void finished() {
-				if (isValidXML()) {
-					if (key != null) {
-						instructions.put(key, getText());
-					}
-				}
-			}
-		}
-
 		protected String getErrorMessage() {
 			return Messages.MetadataRepositoryIO_Parser_Error_Parsing_Repository;
 		}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryManager.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryManager.java
index 265b155..3645ae9 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryManager.java
@@ -13,10 +13,11 @@ import java.net.URL;
 import java.util.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.core.runtime.preferences.ConfigurationScope;
-import org.eclipse.equinox.p2.core.helpers.*;
-import org.eclipse.equinox.p2.core.location.AgentLocation;
+import org.eclipse.equinox.p2.core.helpers.LogHelper;
+import org.eclipse.equinox.p2.core.helpers.Utils;
 import org.eclipse.equinox.p2.core.repository.RepositoryCreationException;
-import org.eclipse.equinox.p2.metadata.repository.*;
+import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
+import org.eclipse.equinox.p2.metadata.repository.IMetadataRepositoryManager;
 import org.eclipse.equinox.spi.p2.metadata.repository.IMetadataRepositoryFactory;
 import org.eclipse.osgi.util.NLS;
 import org.osgi.service.prefs.BackingStoreException;
@@ -214,16 +215,16 @@ public class MetadataRepositoryManager implements IMetadataRepositoryManager {
 	public void restoreRepositories() {
 		//TODO we may want to have proxies on repo instead of the real repo object to limit what is activated.
 		URL path = null;
-		try {
-			AgentLocation location = (AgentLocation) ServiceHelper.getService(Activator.getContext(), AgentLocation.class.getName());
-			if (location == null)
-				// TODO should do something here since we are failing to restore.
-				return;
-			path = location.getMetadataRepositoryURL();
-			repositories.add(new MetadataCache(path));
-		} catch (RepositoryCreationException e) {
-			log("Error while restoring repository " + path, e);
-		}
+		//		try {
+		//			AgentLocation location = (AgentLocation) ServiceHelper.getService(Activator.getContext(), AgentLocation.class.getName());
+		//			if (location == null)
+		//				// TODO should do something here since we are failing to restore.
+		//				return;
+		//			path = location.getMetadataRepositoryURL();
+		//			repositories.add(new MetadataCache(path));
+		//		} catch (RepositoryCreationException e) {
+		//			log("Error while restoring repository " + path, e);
+		//		}
 		try {
 			String locationString = Activator.getContext().getProperty("eclipse.p2.metadataRepository");
 			if (locationString != null) {
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/SimpleMetadataRepositoryFactory.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/SimpleMetadataRepositoryFactory.java
index db6084a..40d254e 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/SimpleMetadataRepositoryFactory.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/SimpleMetadataRepositoryFactory.java
@@ -25,14 +25,15 @@ public class SimpleMetadataRepositoryFactory implements IMetadataRepositoryFacto
 		try {
 			InputStream descriptorStream = new BufferedInputStream(URLMetadataRepository.getActualLocation(location).openStream());
 			try {
-				IMetadataRepository result = MetadataRepositoryIO.read(descriptorStream);
+				IMetadataRepository result = new MetadataRepositoryIO().read(descriptorStream);
 				if (result instanceof LocalMetadataRepository)
 					((LocalMetadataRepository) result).initializeAfterLoad(location);
 				if (result instanceof URLMetadataRepository)
 					((URLMetadataRepository) result).initializeAfterLoad(location);
 				return result;
 			} catch (RepositoryCreationException e) {
-				// TODO Auto-generated catch block
+				// TODO: should distinguish between case of nonexistent input file
+				//		 and other creation problems.
 				return null;
 			} finally {
 				if (descriptorStream != null)
@@ -60,8 +61,8 @@ public class SimpleMetadataRepositoryFactory implements IMetadataRepositoryFacto
 		if (repository.getClass() != source.getClass())
 			throw new IllegalArgumentException("Repository type mismatch");
 		if (repository instanceof LocalMetadataRepository)
-			((LocalMetadataRepository) repository).initializeAfterLoad((LocalMetadataRepository) source);
+			((LocalMetadataRepository) repository).revertToBackup((LocalMetadataRepository) source);
 		else if (repository instanceof URLMetadataRepository)
-			((URLMetadataRepository) repository).initializeAfterLoad((URLMetadataRepository) source);
+			((URLMetadataRepository) repository).revertToBackup((URLMetadataRepository) source);
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/URLMetadataRepository.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/URLMetadataRepository.java
index 06129b7..e62a3b7 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/URLMetadataRepository.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/URLMetadataRepository.java
@@ -89,20 +89,21 @@ public class URLMetadataRepository extends AbstractMetadataRepository {
 		return CompoundIterator.asArray(new CompoundIterator(new Iterator[] {units.iterator()}, id, range, requirements, and), null);
 	}
 
-	// use this method to setup any transient fields etc after the object has been restored from a stream
-	public void initializeAfterLoad(URL location) {
-		this.location = location;
+	// Use this method to setup any transient fields etc after the object has been restored from a stream
+	public void initializeAfterLoad(URL repoLocation) {
+		this.location = repoLocation;
+		content = getActualLocation(location);
 	}
 
-	public void initializeAfterLoad(URLMetadataRepository source) {
-		name = source.name;
-		type = source.type;
-		version = source.version;
-		location = source.location;
-		description = source.description;
-		provider = source.provider;
-		properties = source.properties;
-		units = source.units;
+	public void revertToBackup(URLMetadataRepository backup) {
+		name = backup.name;
+		type = backup.type;
+		version = backup.version;
+		location = backup.location;
+		description = backup.description;
+		provider = backup.provider;
+		properties = backup.properties;
+		units = backup.units;
 	}
 
 	public boolean isModifiable() {
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
new file mode 100644
index 0000000..9f69138
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
@@ -0,0 +1,438 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata.repository.io;
+
+import java.util.*;
+import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
+import org.eclipse.equinox.p2.core.helpers.OrderedProperties;
+import org.eclipse.equinox.p2.core.helpers.XMLParser;
+import org.eclipse.equinox.p2.metadata.*;
+import org.eclipse.osgi.service.resolver.VersionRange;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Version;
+import org.xml.sax.Attributes;
+
+public abstract class MetadataParser extends XMLParser implements XMLConstants {
+
+	public MetadataParser(BundleContext context, String bundleId) {
+		super(context, bundleId);
+	}
+
+	protected class InstallableUnitsHandler extends AbstractHandler {
+
+		private ArrayList units;
+
+		public InstallableUnitsHandler(AbstractHandler parentHandler, Attributes attributes) {
+			super(parentHandler, INSTALLABLE_UNITS_ELEMENT);
+			String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+			units = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
+		}
+
+		public IInstallableUnit[] getUnits() {
+			return (IInstallableUnit[]) units.toArray(new IInstallableUnit[units.size()]);
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (name.equalsIgnoreCase(INSTALLABLE_UNIT_ELEMENT)) {
+				new InstallableUnitHandler(this, attributes, units);
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+	}
+
+	protected class InstallableUnitHandler extends AbstractHandler {
+
+		private final String[] required = new String[] {ID_ATTRIBUTE, VERSION_ATTRIBUTE};
+		private final String[] optional = new String[] {SINGLETON_ATTRIBUTE, FRAGMENT_ATTRIBUTE, FRAGMENT_HOST_ID_ATTRIBUTE, FRAGMENT_HOST_RANGE_ATTRIBUTE};
+
+		InstallableUnit currentUnit = null;
+
+		private PropertiesHandler propertiesHandler = null;
+		private ProvidedCapabilitiesHandler providedCapabilitiesHandler = null;
+		private RequiredCapabilitiesHandler requiredCapabilitiesHandler = null;
+		private TextHandler filterHandler = null;
+		private TextHandler applicabilityHandler = null;
+		private ArtifactsHandler artifactsHandler = null;
+		private TouchpointTypeHandler touchpointTypeHandler = null;
+		private TouchpointDataHandler touchpointDataHandler = null;
+
+		public InstallableUnitHandler(AbstractHandler parentHandler, Attributes attributes, List units) {
+			super(parentHandler, INSTALLABLE_UNIT_ELEMENT);
+			String[] values = parseAttributes(attributes, required, optional);
+
+			Version version = checkVersion(INSTALLABLE_UNIT_ELEMENT, VERSION_ATTRIBUTE, values[1]);
+			boolean singleton = checkBoolean(INSTALLABLE_UNIT_ELEMENT, SINGLETON_ATTRIBUTE, values[2], true).booleanValue();
+			boolean isFragment = checkBoolean(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_ATTRIBUTE, values[3], false).booleanValue();
+			if (isFragment) {
+				// TODO: tooling default fragment does not have a host id
+				// checkRequiredAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_ID_ATTRIBUTE, values[4]);
+				checkRequiredAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_RANGE_ATTRIBUTE, values[5]);
+				VersionRange hostRange = checkVersionRange(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_RANGE_ATTRIBUTE, values[5]);
+				currentUnit = new InstallableUnitFragment(values[0], version, singleton, values[4], hostRange);
+			} else {
+				if (values[4] != null) {
+					unexpectedAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_ID_ATTRIBUTE, values[4]);
+				} else if (values[5] != null) {
+					unexpectedAttribute(INSTALLABLE_UNIT_ELEMENT, FRAGMENT_HOST_RANGE_ATTRIBUTE, values[4]);
+				}
+				currentUnit = new InstallableUnit(values[0], version, singleton);
+			}
+			units.add(currentUnit);
+		}
+
+		public IInstallableUnit getInstallableUnit() {
+			return currentUnit;
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (PROPERTIES_ELEMENT.equalsIgnoreCase(name)) {
+				if (propertiesHandler == null) {
+					propertiesHandler = new PropertiesHandler(this, attributes);
+				} else {
+					duplicateElement(this, name, attributes);
+				}
+			} else if (PROVIDED_CAPABILITIES_ELEMENT.equalsIgnoreCase(name)) {
+				if (providedCapabilitiesHandler == null) {
+					providedCapabilitiesHandler = new ProvidedCapabilitiesHandler(this, attributes);
+				} else {
+					duplicateElement(this, name, attributes);
+				}
+			} else if (REQUIRED_CAPABILITIES_ELEMENT.equalsIgnoreCase(name)) {
+				if (requiredCapabilitiesHandler == null) {
+					requiredCapabilitiesHandler = new RequiredCapabilitiesHandler(this, attributes);
+				} else {
+					duplicateElement(this, name, attributes);
+				}
+			} else if (IU_FILTER_ELEMENT.equalsIgnoreCase(name)) {
+				if (filterHandler == null) {
+					filterHandler = new TextHandler(this, IU_FILTER_ELEMENT, attributes);
+				} else {
+					duplicateElement(this, name, attributes);
+				}
+			} else if (APPLICABILITY_FILTER_ELEMENT.equalsIgnoreCase(name)) {
+				if (applicabilityHandler == null) {
+					applicabilityHandler = new TextHandler(this, APPLICABILITY_FILTER_ELEMENT, attributes);
+				} else {
+					duplicateElement(this, name, attributes);
+				}
+			} else if (ARTIFACT_KEYS_ELEMENT.equalsIgnoreCase(name)) {
+				if (artifactsHandler == null) {
+					artifactsHandler = new ArtifactsHandler(this, attributes);
+				} else {
+					duplicateElement(this, name, attributes);
+				}
+			} else if (TOUCHPOINT_TYPE_ELEMENT.equalsIgnoreCase(name)) {
+				if (touchpointTypeHandler == null) {
+					touchpointTypeHandler = new TouchpointTypeHandler(this, attributes);
+				} else {
+					duplicateElement(this, name, attributes);
+				}
+			} else if (TOUCHPOINT_DATA_ELEMENT.equalsIgnoreCase(name)) {
+				if (touchpointDataHandler == null) {
+					touchpointDataHandler = new TouchpointDataHandler(this, attributes);
+				} else {
+					duplicateElement(this, name, attributes);
+				}
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+
+		protected void finished() {
+			if (isValidXML() && currentUnit != null) {
+				OrderedProperties properties = (propertiesHandler == null ? new OrderedProperties(0) //
+						: propertiesHandler.getProperties());
+				currentUnit.addProperties(properties);
+				ProvidedCapability[] providedCapabilities = (providedCapabilitiesHandler == null ? new ProvidedCapability[0] //
+						: providedCapabilitiesHandler.getProvidedCapabilities());
+				currentUnit.setCapabilities(providedCapabilities);
+				RequiredCapability[] requiredCapabilities = (requiredCapabilitiesHandler == null ? new RequiredCapability[0] //
+						: requiredCapabilitiesHandler.getRequiredCapabilities());
+				currentUnit.setRequiredCapabilities(requiredCapabilities);
+				if (filterHandler != null) {
+					currentUnit.setFilter(filterHandler.getText());
+				}
+				if (applicabilityHandler != null) {
+					currentUnit.setApplicabilityFilter(applicabilityHandler.getText());
+				}
+				IArtifactKey[] artifacts = (artifactsHandler == null ? new IArtifactKey[0] //
+						: artifactsHandler.getArtifactKeys());
+				currentUnit.setArtifacts(artifacts);
+				if (touchpointTypeHandler != null) {
+					currentUnit.setTouchpointType(touchpointTypeHandler.getTouchpointType());
+				} else {
+					// TODO: create an error
+				}
+				TouchpointData[] touchpointData = (touchpointDataHandler == null ? new TouchpointData[0] //
+						: touchpointDataHandler.getTouchpointData());
+				currentUnit.addTouchpointData(touchpointData);
+			}
+		}
+	}
+
+	protected class ProvidedCapabilitiesHandler extends AbstractHandler {
+
+		private List providedCapabilities;
+
+		public ProvidedCapabilitiesHandler(AbstractHandler parentHandler, Attributes attributes) {
+			super(parentHandler, PROVIDED_CAPABILITIES_ELEMENT);
+			String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+			providedCapabilities = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
+		}
+
+		public ProvidedCapability[] getProvidedCapabilities() {
+			return (ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]);
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (name.equalsIgnoreCase(PROVIDED_CAPABILITY_ELEMENT)) {
+				new ProvidedCapabilityHandler(this, attributes, providedCapabilities);
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+	}
+
+	protected class ProvidedCapabilityHandler extends AbstractHandler {
+
+		private final String[] required = new String[] {NAMESPACE_ATTRIBUTE, NAME_ATTRIBUTE, VERSION_ATTRIBUTE};
+
+		public ProvidedCapabilityHandler(AbstractHandler parentHandler, Attributes attributes, List capabilities) {
+			super(parentHandler, PROVIDED_CAPABILITY_ELEMENT);
+			String[] values = parseRequiredAttributes(attributes, required);
+			Version version = checkVersion(PROVIDED_CAPABILITY_ELEMENT, VERSION_ATTRIBUTE, values[2]);
+			capabilities.add(new ProvidedCapability(values[0], values[1], version));
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			invalidElement(name, attributes);
+		}
+	}
+
+	protected class RequiredCapabilitiesHandler extends AbstractHandler {
+
+		private List requiredCapabilities;
+
+		public RequiredCapabilitiesHandler(AbstractHandler parentHandler, Attributes attributes) {
+			super(parentHandler, REQUIRED_CAPABILITIES_ELEMENT);
+			String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+			requiredCapabilities = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
+		}
+
+		public RequiredCapability[] getRequiredCapabilities() {
+			return (RequiredCapability[]) requiredCapabilities.toArray(new RequiredCapability[requiredCapabilities.size()]);
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (name.equalsIgnoreCase(REQUIRED_CAPABILITY_ELEMENT)) {
+				new RequiredCapabilityHandler(this, attributes, requiredCapabilities);
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+	}
+
+	protected class RequiredCapabilityHandler extends AbstractHandler {
+
+		private final String[] required = new String[] {NAMESPACE_ATTRIBUTE, NAME_ATTRIBUTE, VERSION_RANGE_ATTRIBUTE};
+		private final String[] optional = new String[] {CAPABILITY_OPTIONAL_ATTRIBUTE, CAPABILITY_MULTIPLE_ATTRIBUTE};
+
+		private RequiredCapability currentCapability = null;
+
+		private TextHandler filterHandler = null;
+		private CapabilitySelectorsHandler selectorsHandler = null;
+
+		public RequiredCapabilityHandler(AbstractHandler parentHandler, Attributes attributes, List capabilities) {
+			super(parentHandler, REQUIRED_CAPABILITY_ELEMENT);
+			String[] values = parseAttributes(attributes, required, optional);
+			VersionRange range = checkVersionRange(REQUIRED_CAPABILITY_ELEMENT, VERSION_RANGE_ATTRIBUTE, values[2]);
+			boolean isOptional = checkBoolean(REQUIRED_CAPABILITY_ELEMENT, CAPABILITY_OPTIONAL_ATTRIBUTE, values[3], false).booleanValue();
+			boolean isMultiple = checkBoolean(REQUIRED_CAPABILITY_ELEMENT, CAPABILITY_MULTIPLE_ATTRIBUTE, values[4], false).booleanValue();
+			currentCapability = new RequiredCapability(values[0], values[1], range, null, isOptional, isMultiple);
+			capabilities.add(currentCapability);
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (name.equalsIgnoreCase(CAPABILITY_FILTER_ELEMENT)) {
+				filterHandler = new TextHandler(this, CAPABILITY_FILTER_ELEMENT, attributes);
+			} else if (name.equalsIgnoreCase(CAPABILITY_SELECTORS_ELEMENT)) {
+				selectorsHandler = new CapabilitySelectorsHandler(this, attributes);
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+
+		protected void finished() {
+			if (isValidXML()) {
+				if (currentCapability != null) {
+					if (filterHandler != null) {
+						currentCapability.setFilter(filterHandler.getText());
+					}
+					if (selectorsHandler != null) {
+						currentCapability.setSelectors(selectorsHandler.getSelectors());
+					}
+				}
+			}
+		}
+	}
+
+	protected class ArtifactsHandler extends AbstractHandler {
+
+		private List artifacts;
+
+		public ArtifactsHandler(AbstractHandler parentHandler, Attributes attributes) {
+			super(parentHandler, ARTIFACT_KEYS_ELEMENT);
+			String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+			artifacts = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
+		}
+
+		public IArtifactKey[] getArtifactKeys() {
+			return (IArtifactKey[]) artifacts.toArray(new IArtifactKey[artifacts.size()]);
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (name.equalsIgnoreCase(ARTIFACT_KEY_ELEMENT)) {
+				new ArtifactHandler(this, attributes, artifacts);
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+	}
+
+	protected class ArtifactHandler extends AbstractHandler {
+
+		private final String[] required = new String[] {NAMESPACE_ATTRIBUTE, CLASSIFIER_ATTRIBUTE, ID_ATTRIBUTE, VERSION_ATTRIBUTE};
+
+		public ArtifactHandler(AbstractHandler parentHandler, Attributes attributes, List artifacts) {
+			super(parentHandler, ARTIFACT_KEY_ELEMENT);
+			String[] values = parseRequiredAttributes(attributes, required);
+			Version version = checkVersion(ARTIFACT_KEY_ELEMENT, VERSION_ATTRIBUTE, values[3]);
+			artifacts.add(new ArtifactKey(values[0], values[1], values[2], version));
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			invalidElement(name, attributes);
+		}
+	}
+
+	protected class CapabilitySelectorsHandler extends AbstractHandler {
+
+		private List selectors;
+
+		public CapabilitySelectorsHandler(AbstractHandler parentHandler, Attributes attributes) {
+			super(parentHandler, CAPABILITY_SELECTORS_ELEMENT);
+			String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+			selectors = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
+		}
+
+		public String[] getSelectors() {
+			return (String[]) selectors.toArray(new String[selectors.size()]);
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (name.equalsIgnoreCase(CAPABILITY_SELECTOR_ELEMENT)) {
+				new TextHandler(this, CAPABILITY_SELECTOR_ELEMENT, attributes, selectors);
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+	}
+
+	protected class TouchpointTypeHandler extends AbstractHandler {
+
+		private final String[] required = new String[] {ID_ATTRIBUTE, VERSION_ATTRIBUTE};
+
+		TouchpointType touchpointType = null;
+
+		public TouchpointTypeHandler(AbstractHandler parentHandler, Attributes attributes) {
+			super(parentHandler, TOUCHPOINT_TYPE_ELEMENT);
+			String[] values = parseRequiredAttributes(attributes, required);
+			Version version = checkVersion(TOUCHPOINT_TYPE_ELEMENT, VERSION_ATTRIBUTE, values[1]);
+			touchpointType = new TouchpointType(values[0], version);
+		}
+
+		public TouchpointType getTouchpointType() {
+			return touchpointType;
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			invalidElement(name, attributes);
+		}
+	}
+
+	protected class TouchpointDataHandler extends AbstractHandler {
+
+		TouchpointData touchpointData = null;
+
+		List data = null;
+
+		public TouchpointDataHandler(AbstractHandler parentHandler, Attributes attributes) {
+			super(parentHandler, TOUCHPOINT_DATA_ELEMENT);
+			String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+			data = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
+		}
+
+		public TouchpointData[] getTouchpointData() {
+			return (TouchpointData[]) data.toArray(new TouchpointData[data.size()]);
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (name.equalsIgnoreCase(TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT)) {
+				new TouchpointInstructionsHandler(this, attributes, data);
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+	}
+
+	protected class TouchpointInstructionsHandler extends AbstractHandler {
+
+		Map instructions = null;
+
+		public TouchpointInstructionsHandler(AbstractHandler parentHandler, Attributes attributes, List data) {
+			super(parentHandler, TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT);
+			String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+			instructions = (size != null ? new LinkedHashMap(new Integer(size).intValue()) : new LinkedHashMap(4));
+			data.add(new TouchpointData(instructions));
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (name.equalsIgnoreCase(TOUCHPOINT_DATA_INSTRUCTION_ELEMENT)) {
+				new TouchpointInstructionHandler(this, attributes, instructions);
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+	}
+
+	protected class TouchpointInstructionHandler extends TextHandler {
+
+		private final String[] required = new String[] {TOUCHPOINT_DATA_INSTRUCTION_KEY_ATTRIBUTE};
+
+		Map instructions = null;
+		String key = null;
+
+		public TouchpointInstructionHandler(AbstractHandler parentHandler, Attributes attributes, Map instructions) {
+			super(parentHandler, TOUCHPOINT_DATA_INSTRUCTION_ELEMENT);
+			key = parseRequiredAttributes(attributes, required)[0];
+			this.instructions = instructions;
+		}
+
+		protected void finished() {
+			if (isValidXML()) {
+				if (key != null) {
+					instructions.put(key, getText());
+				}
+			}
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
new file mode 100644
index 0000000..c2ba8b9
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
@@ -0,0 +1,169 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata.repository.io;
+
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.Iterator;
+import java.util.Map;
+import org.eclipse.equinox.p2.core.helpers.XMLWriter;
+import org.eclipse.equinox.p2.metadata.*;
+
+public abstract class MetadataWriter extends XMLWriter implements XMLConstants {
+
+	public MetadataWriter(OutputStream output, ProcessingInstruction[] piElements) throws UnsupportedEncodingException {
+		super(output, piElements);
+		// TODO: add a processing instruction for the metadata version
+	}
+
+	protected void writeInstallableUnits(IInstallableUnit[] installableUnits) {
+		if (installableUnits.length > 0) {
+			start(INSTALLABLE_UNITS_ELEMENT);
+			attribute(COLLECTION_SIZE_ATTRIBUTE, installableUnits.length);
+			for (int i = 0; i < installableUnits.length; i++) {
+				writeInstallableUnit(installableUnits[i]);
+			}
+			end(INSTALLABLE_UNITS_ELEMENT);
+		}
+	}
+
+	protected void writeInstallableUnit(IInstallableUnit resolvedIU) {
+		IInstallableUnit iu = (!(resolvedIU instanceof IResolvedInstallableUnit) ? resolvedIU//
+				: ((IResolvedInstallableUnit) resolvedIU).getOriginal());
+		start(INSTALLABLE_UNIT_ELEMENT);
+		attribute(ID_ATTRIBUTE, iu.getId());
+		attribute(VERSION_ATTRIBUTE, iu.getVersion());
+		attribute(SINGLETON_ATTRIBUTE, iu.isSingleton(), true);
+		attribute(FRAGMENT_ATTRIBUTE, iu.isFragment(), false);
+
+		if (iu.isFragment() && iu instanceof IInstallableUnitFragment) {
+			IInstallableUnitFragment fragment = (IInstallableUnitFragment) iu;
+			attribute(FRAGMENT_HOST_ID_ATTRIBUTE, fragment.getHostId());
+			attribute(FRAGMENT_HOST_RANGE_ATTRIBUTE, fragment.getHostVersionRange());
+		}
+
+		writeProperties(iu.getProperties());
+		writeProvidedCapabilities(iu.getProvidedCapabilities());
+		writeRequiredCapabilities(iu.getRequiredCapabilities());
+		writeTrimmedCdata(IU_FILTER_ELEMENT, iu.getFilter());
+		writeTrimmedCdata(APPLICABILITY_FILTER_ELEMENT, iu.getApplicabilityFilter());
+
+		writeArtifactKeys(iu.getArtifacts());
+		writeTouchpointType(iu.getTouchpointType());
+		writeTouchpointData(iu.getTouchpointData());
+
+		end(INSTALLABLE_UNIT_ELEMENT);
+	}
+
+	protected void writeProvidedCapabilities(ProvidedCapability[] capabilities) {
+		if (capabilities != null && capabilities.length > 0) {
+			start(PROVIDED_CAPABILITIES_ELEMENT);
+			attribute(COLLECTION_SIZE_ATTRIBUTE, capabilities.length);
+			for (int i = 0; i < capabilities.length; i++) {
+				start(PROVIDED_CAPABILITY_ELEMENT);
+				attribute(NAMESPACE_ATTRIBUTE, capabilities[i].getNamespace());
+				attribute(NAME_ATTRIBUTE, capabilities[i].getName());
+				attribute(VERSION_ATTRIBUTE, capabilities[i].getVersion());
+				end(PROVIDED_CAPABILITY_ELEMENT);
+			}
+			end(PROVIDED_CAPABILITIES_ELEMENT);
+		}
+	}
+
+	protected void writeRequiredCapabilities(RequiredCapability[] capabilities) {
+		if (capabilities != null && capabilities.length > 0) {
+			start(REQUIRED_CAPABILITIES_ELEMENT);
+			attribute(COLLECTION_SIZE_ATTRIBUTE, capabilities.length);
+			for (int i = 0; i < capabilities.length; i++) {
+				writeRequiredCapability(capabilities[i]);
+			}
+			end(REQUIRED_CAPABILITIES_ELEMENT);
+		}
+	}
+
+	protected void writeRequiredCapability(RequiredCapability capability) {
+		start(REQUIRED_CAPABILITY_ELEMENT);
+		attribute(NAMESPACE_ATTRIBUTE, capability.getNamespace());
+		attribute(NAME_ATTRIBUTE, capability.getName());
+		attribute(VERSION_RANGE_ATTRIBUTE, capability.getRange());
+		attribute(CAPABILITY_OPTIONAL_ATTRIBUTE, capability.isOptional(), false);
+		attribute(CAPABILITY_MULTIPLE_ATTRIBUTE, capability.isMultiple(), false);
+
+		writeTrimmedCdata(CAPABILITY_FILTER_ELEMENT, capability.getFilter());
+
+		String[] selectors = capability.getSelectors();
+		if (selectors.length > 0) {
+			start(CAPABILITY_SELECTORS_ELEMENT);
+			attribute(COLLECTION_SIZE_ATTRIBUTE, selectors.length);
+			for (int j = 0; j < selectors.length; j++) {
+				writeTrimmedCdata(CAPABILITY_SELECTOR_ELEMENT, selectors[j]);
+			}
+			end(CAPABILITY_SELECTORS_ELEMENT);
+		}
+
+		end(REQUIRED_CAPABILITY_ELEMENT);
+	}
+
+	protected void writeArtifactKeys(IArtifactKey[] artifactKeys) {
+		if (artifactKeys != null && artifactKeys.length > 0) {
+			start(ARTIFACT_KEYS_ELEMENT);
+			attribute(COLLECTION_SIZE_ATTRIBUTE, artifactKeys.length);
+			for (int i = 0; i < artifactKeys.length; i++) {
+				start(ARTIFACT_KEY_ELEMENT);
+				attribute(ARTIFACT_KEY_NAMESPACE_ATTRIBUTE, artifactKeys[i].getNamespace());
+				attribute(ARTIFACT_KEY_CLASSIFIER_ATTRIBUTE, artifactKeys[i].getClassifier());
+				attribute(ID_ATTRIBUTE, artifactKeys[i].getId());
+				attribute(VERSION_ATTRIBUTE, artifactKeys[i].getVersion());
+				end(ARTIFACT_KEY_ELEMENT);
+			}
+			end(ARTIFACT_KEYS_ELEMENT);
+		}
+	}
+
+	protected void writeTouchpointType(TouchpointType touchpointType) {
+		start(TOUCHPOINT_TYPE_ELEMENT);
+		attribute(ID_ATTRIBUTE, touchpointType.getId());
+		attribute(VERSION_ATTRIBUTE, touchpointType.getVersion());
+		end(TOUCHPOINT_TYPE_ELEMENT);
+	}
+
+	protected void writeTouchpointData(TouchpointData[] touchpointData) {
+		if (touchpointData != null && touchpointData.length > 0) {
+			start(TOUCHPOINT_DATA_ELEMENT);
+			attribute(COLLECTION_SIZE_ATTRIBUTE, touchpointData.length);
+			for (int i = 0; i < touchpointData.length; i++) {
+				TouchpointData nextData = touchpointData[i];
+				Map instructions = nextData.getInstructions();
+				if (instructions.size() > 0) {
+					start(TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT);
+					attribute(COLLECTION_SIZE_ATTRIBUTE, instructions.size());
+					for (Iterator iter = instructions.entrySet().iterator(); iter.hasNext();) {
+						Map.Entry entry = (Map.Entry) iter.next();
+						start(TOUCHPOINT_DATA_INSTRUCTION_ELEMENT);
+						attribute(TOUCHPOINT_DATA_INSTRUCTION_KEY_ATTRIBUTE, entry.getKey());
+						cdata((String) entry.getValue(), true);
+						end(TOUCHPOINT_DATA_INSTRUCTION_ELEMENT);
+					}
+				}
+			}
+			end(TOUCHPOINT_DATA_ELEMENT);
+		}
+	}
+
+	private void writeTrimmedCdata(String element, String filter) {
+		String trimmed;
+		if (filter != null && (trimmed = filter.trim()).length() > 0) {
+			start(element);
+			cdata(trimmed);
+			end(element);
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/XMLConstants.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/XMLConstants.java
new file mode 100644
index 0000000..c7f9b90
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/XMLConstants.java
@@ -0,0 +1,72 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata.repository.io;
+
+import org.eclipse.osgi.service.resolver.VersionRange;
+import org.osgi.framework.Version;
+
+public interface XMLConstants extends org.eclipse.equinox.p2.core.helpers.XMLConstants {
+
+	// Constants defining the structure of the XML for metadata objects
+
+	// A format version number for metadata XML.
+	public static final String XML_VERSION = "0.0.1"; //$NON-NLS-1$
+	public static final Version CURRENT_VERSION = new Version(XML_VERSION);
+	public static final VersionRange XML_TOLERANCE = new VersionRange(CURRENT_VERSION, true, CURRENT_VERSION, true);
+
+	// Constants for processing Instructions
+	public static final String PI_METADATA_TARGET = "metadata"; //$NON-NLS-1$
+
+	// Constants for metadata elements
+	public static final String INSTALLABLE_UNITS_ELEMENT = "units"; //$NON-NLS-1$
+	public static final String INSTALLABLE_UNIT_ELEMENT = "unit"; //$NON-NLS-1$
+
+	// Constants for sub-elements of an installable unit element
+	public static final String ARTIFACT_KEYS_ELEMENT = "artifacts"; //$NON-NLS-1$
+	public static final String ARTIFACT_KEY_ELEMENT = "artifact"; //$NON-NLS-1$
+	public static final String REQUIRED_CAPABILITIES_ELEMENT = "requires"; //$NON-NLS-1$
+	public static final String REQUIRED_CAPABILITY_ELEMENT = "required"; //$NON-NLS-1$
+	public static final String PROVIDED_CAPABILITIES_ELEMENT = "provides"; //$NON-NLS-1$
+	public static final String PROVIDED_CAPABILITY_ELEMENT = "provided"; //$NON-NLS-1$
+	public static final String TOUCHPOINT_TYPE_ELEMENT = "touchpoint"; //$NON-NLS-1$
+	public static final String TOUCHPOINT_DATA_ELEMENT = "touchpointData"; //$NON-NLS-1$
+	public static final String IU_FILTER_ELEMENT = "filter"; //$NON-NLS-1$
+	public static final String APPLICABILITY_FILTER_ELEMENT = "applicability"; //$NON-NLS-1$
+
+	// Constants for attributes of an installable unit element
+	public static final String SINGLETON_ATTRIBUTE = "singleton"; //$NON-NLS-1$
+	public static final String FRAGMENT_ATTRIBUTE = "fragment"; //$NON-NLS-1$
+
+	// Constants for attributes of a fragment installable unit element
+	public static final String FRAGMENT_HOST_ID_ATTRIBUTE = "hostId"; //$NON-NLS-1$
+	public static final String FRAGMENT_HOST_RANGE_ATTRIBUTE = "hostRange"; //$NON-NLS-1$
+
+	// Constants for sub-elements of a required capability element
+	public static final String CAPABILITY_FILTER_ELEMENT = "filter"; //$NON-NLS-1$
+	public static final String CAPABILITY_SELECTORS_ELEMENT = "selectors"; //$NON-NLS-1$
+	public static final String CAPABILITY_SELECTOR_ELEMENT = "selector"; //$NON-NLS-1$
+
+	// Constants for attributes of a required capability element
+	public static final String CAPABILITY_OPTIONAL_ATTRIBUTE = "optional"; //$NON-NLS-1$
+	public static final String CAPABILITY_MULTIPLE_ATTRIBUTE = "multiple"; //$NON-NLS-1$
+
+	// Constants for attributes of an artifact key element
+	public static final String ARTIFACT_KEY_NAMESPACE_ATTRIBUTE = NAMESPACE_ATTRIBUTE;
+	public static final String ARTIFACT_KEY_CLASSIFIER_ATTRIBUTE = "classifier"; //$NON-NLS-1$
+
+	// Constants for sub-elements of a touchpoint data element
+	public static final String TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT = "instructions"; //$NON-NLS-1$
+	public static final String TOUCHPOINT_DATA_INSTRUCTION_ELEMENT = "instruction"; //$NON-NLS-1$
+
+	// Constants for attributes of an a touchpoint data instruction element
+	public static final String TOUCHPOINT_DATA_INSTRUCTION_KEY_ATTRIBUTE = "key"; //$NON-NLS-1$
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IInstallableUnit.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IInstallableUnit.java
index 899a00a..9d4b8f4 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IInstallableUnit.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IInstallableUnit.java
@@ -16,7 +16,7 @@ public interface IInstallableUnit extends Comparable {
 	/**
 	 * A capability namespace representing a particular kind of installable unit.
 	 * For example, an InstallableUnit may specify that it provides the "group" kind
-	 * capability to express that it represents a group of instalable units. 
+	 * capability to express that it represents a group of installable units. 
 	 */
 	public static final String IU_KIND_NAMESPACE = "org.eclipse.equinox.p2.type"; //$NON-NLS-1$
 	/**
@@ -30,7 +30,8 @@ public interface IInstallableUnit extends Comparable {
 	 * A capability namespace representing a particular profile flavor.
 	 */
 	public static final String FLAVOR_NAMESPACE = "flavor"; //$NON-NLS-1$
-	//These two constants needs to be moved somewhere more appropriate...
+
+	// TODO: These two constants need to be moved somewhere more appropriate...
 	public static final String CAPABILITY_ECLIPSE_TYPES = "org.eclipse.equinox.p2.eclipsetouchpoint.types"; //$NON-NLS-1$
 	public static final String CAPABILITY_ECLIPSE_BUNDLE = "bundle"; //$NON-NLS-1$
 
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/InstallableUnit.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/InstallableUnit.java
index 5f5428f..ddef432 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/InstallableUnit.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/InstallableUnit.java
@@ -15,26 +15,28 @@ import org.eclipse.equinox.p2.core.helpers.UnmodifiableProperties;
 import org.osgi.framework.Version;
 
 public class InstallableUnit implements IInstallableUnitConstants, IInstallableUnit, InternalInstallableUnit {
-	private static final OrderedProperties NO_PROPERTIES = new OrderedProperties();
-	private static final RequiredCapability[] NO_REQUIRES = new RequiredCapability[0];
 
-	String applicabilityFilter;
-	private IArtifactKey[] artifacts;
-	private String filter;
+	private static final ProvidedCapability[] NO_PROVIDES = new ProvidedCapability[0];
+	private static final RequiredCapability[] NO_REQUIRES = new RequiredCapability[0];
+	private static final OrderedProperties NO_PROPERTIES = new OrderedProperties();
 
 	private String id;
+	private Version version;
+	private boolean singleton;
 
 	private OrderedProperties properties;
-	ProvidedCapability[] providedCapabilities = new ProvidedCapability[0];
-	private RequiredCapability[] requires;
-
-	private boolean singleton;
 
+	private IArtifactKey[] artifacts;
+	private TouchpointType touchpointType;
 	private ArrayList touchpointData = null;
 
-	private TouchpointType touchpointType;
+	private RequiredCapability[] requires;
 
-	private Version version;
+	private String filter;
+
+	String applicabilityFilter;
+
+	ProvidedCapability[] providedCapabilities = NO_PROVIDES;
 
 	public InstallableUnit() {
 		super();
@@ -43,105 +45,44 @@ public class InstallableUnit implements IInstallableUnitConstants, IInstallableU
 	public InstallableUnit(String id, Version version, boolean singleton) {
 		super();
 		this.id = id;
-		this.version = version == null ? Version.emptyVersion : version;
+		this.version = (version != null ? version : Version.emptyVersion);
 		this.singleton = singleton;
 	}
 
-	public void accept(IMetadataVisitor visitor) {
-		visitor.visitInstallableUnit(this);
-	}
-
-	public void addProperties(OrderedProperties newProperties) {
-		if (properties == null)
-			properties = new OrderedProperties(newProperties.size());
-		properties.putAll(newProperties);
-	}
-
-	public void addTouchpointData(TouchpointData[] newData) {
-		ensureTouchpointDataCapacity(newData.length);
-		for (int i = 0; i < newData.length; i++) {
-			touchpointData.add(newData[i]);
-		}
-	}
-
-	public int compareTo(Object toCompareTo) {
-		if (!(toCompareTo instanceof IInstallableUnit)) {
-			return -1;
-		}
-		IInstallableUnit other = (IInstallableUnit) toCompareTo;
-		if (getId().compareTo(other.getId()) == 0)
-			return (getVersion().compareTo(other.getVersion()));
-		return getId().compareTo(other.getId());
+	public TouchpointType getTouchpointType() {
+		return touchpointType != null ? touchpointType : TouchpointType.NONE;
 	}
 
-	private void ensureTouchpointDataCapacity(int size) {
-		if (touchpointData != null) {
-			touchpointData.ensureCapacity(size);
-		} else {
-			touchpointData = new ArrayList(size);
-		}
+	public String getId() {
+		return id;
 	}
 
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (!(obj instanceof IInstallableUnit))
-			return false;
-		final IInstallableUnit other = (IInstallableUnit) obj;
-		if (id == null) {
-			if (other.getId() != null)
-				return false;
-		} else if (!id.equals(other.getId()))
-			return false;
-		if (getVersion() == null) {
-			if (other.getVersion() != null)
-				return false;
-		} else if (!getVersion().equals(other.getVersion()))
-			return false;
-		return true;
+	public String getFilter() {
+		return filter;
 	}
 
-	public String getApplicabilityFilter() {
-		return applicabilityFilter;
+	public Version getVersion() {
+		return version;
 	}
 
 	public IArtifactKey[] getArtifacts() {
 		return artifacts;
 	}
 
-	public String getFilter() {
-		return filter;
-	}
-
-	public String getId() {
-		return id;
+	public void setId(String id) {
+		this.id = id;
 	}
 
-	/**
-	 * Get an <i>unmodifiable copy</i> of the properties
-	 * associated with the installable unit.
-	 * 
-	 * @return an <i>unmodifiable copy</i> of the IU properties.
-	 */
-	public OrderedProperties getProperties() {
-		return new UnmodifiableProperties(properties());
+	public void setVersion(Version newVersion) {
+		this.version = (newVersion != null ? newVersion : Version.emptyVersion);
 	}
 
-	public String getProperty(String key) {
-		return getProperties().getProperty(key);
+	public void setTouchpointType(TouchpointType type) {
+		this.touchpointType = (type != TouchpointType.NONE ? type : null);
 	}
 
-	public ProvidedCapability[] getProvidedCapabilities() {
-		ProvidedCapability self = new ProvidedCapability(IU_NAMESPACE, id, getVersion());
-		if (providedCapabilities == null)
-			return new ProvidedCapability[] {self};
-		//		return providedCapabilities;
-		ProvidedCapability[] result = new ProvidedCapability[providedCapabilities.length + 1];
-		result[0] = self;
-		System.arraycopy(providedCapabilities, 0, result, 1, providedCapabilities.length);
-		return result;
+	public void setArtifacts(IArtifactKey[] value) {
+		artifacts = value;
 	}
 
 	public RequiredCapability[] getRequiredCapabilities() {
@@ -149,61 +90,98 @@ public class InstallableUnit implements IInstallableUnitConstants, IInstallableU
 
 	}
 
-	public IResolvedInstallableUnit getResolved() {
-		return new ResolvedInstallableUnit(this);
-	}
-
-	public TouchpointData[] getTouchpointData() {
-		return (touchpointData == null ? TouchpointData.NO_TOUCHPOINT_DATA //
-				: (TouchpointData[]) touchpointData.toArray(new TouchpointData[touchpointData.size()]));
+	public void setRequiredCapabilities(RequiredCapability[] capabilities) {
+		if (capabilities == NO_REQUIRES) {
+			this.requires = null;
+		} else {
+			//copy array for safety
+			this.requires = (RequiredCapability[]) capabilities.clone();
+		}
 	}
 
-	public TouchpointType getTouchpointType() {
-		return touchpointType == null ? TouchpointType.NONE : touchpointType;
+	public ProvidedCapability[] getProvidedCapabilities() {
+		return (providedCapabilities != null ? providedCapabilities : NO_PROVIDES);
 	}
 
-	public Version getVersion() {
-		return version;
+	protected void addProvidedCapability(ProvidedCapability capability) {
+		if (providedCapabilities != null && providedCapabilities.length > 0) {
+			ProvidedCapability[] result = new ProvidedCapability[providedCapabilities.length + 1];
+			result[0] = capability;
+			System.arraycopy(providedCapabilities, 0, result, 1, providedCapabilities.length);
+			providedCapabilities = result;
+		} else {
+			providedCapabilities = new ProvidedCapability[] {capability};
+		}
 	}
 
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((id == null) ? 0 : id.hashCode());
-		result = prime * result + ((getVersion() == null) ? 0 : getVersion().hashCode());
-		return result;
+	public void setCapabilities(ProvidedCapability[] exportedCapabilities) {
+		providedCapabilities = exportedCapabilities;
 	}
 
-	public boolean isFragment() {
-		return false;
+	public void accept(IMetadataVisitor visitor) {
+		visitor.visitInstallableUnit(this);
 	}
 
 	public boolean isSingleton() {
 		return singleton;
 	}
 
-	private OrderedProperties properties() {
-		return (properties != null ? properties : NO_PROPERTIES);
+	public void setSingleton(boolean singleton) {
+		this.singleton = singleton;
 	}
 
-	public void setApplicabilityFilter(String ldapFilter) {
-		applicabilityFilter = ldapFilter;
+	public String getProperty(String key) {
+		return getProperties().getProperty(key);
 	}
 
-	public void setArtifacts(IArtifactKey[] value) {
-		artifacts = value;
+	public String setProperty(String key, String value) {
+		if (value == null)
+			return (properties != null ? (String) properties.remove(key) : null);
+		if (properties == null)
+			properties = new OrderedProperties();
+		return (String) properties.setProperty(key, value);
 	}
 
-	public void setCapabilities(ProvidedCapability[] exportedCapabilities) {
-		providedCapabilities = exportedCapabilities;
+	public String toString() {
+		return id + ' ' + getVersion();
+	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((id == null) ? 0 : id.hashCode());
+		result = prime * result + ((getVersion() == null) ? 0 : getVersion().hashCode());
+		return result;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (!(obj instanceof IInstallableUnit))
+			return false;
+		final IInstallableUnit other = (IInstallableUnit) obj;
+		if (id == null) {
+			if (other.getId() != null)
+				return false;
+		} else if (!id.equals(other.getId()))
+			return false;
+		if (getVersion() == null) {
+			if (other.getVersion() != null)
+				return false;
+		} else if (!getVersion().equals(other.getVersion()))
+			return false;
+		return true;
 	}
 
 	public void setFilter(String filter) {
 		this.filter = filter;
 	}
 
-	public void setId(String id) {
-		this.id = id;
+	public TouchpointData[] getTouchpointData() {
+		return (touchpointData == null ? TouchpointData.NO_TOUCHPOINT_DATA //
+				: (TouchpointData[]) touchpointData.toArray(new TouchpointData[touchpointData.size()]));
 	}
 
 	// TODO: resolve the schizophrenia between the singleton immutable data
@@ -213,36 +191,64 @@ public class InstallableUnit implements IInstallableUnitConstants, IInstallableU
 		touchpointData.add(immutableData);
 	}
 
-	public String setProperty(String key, String value) {
-		if (value == null)
-			return (properties != null ? (String) properties.remove(key) : null);
-		if (properties == null)
-			properties = new OrderedProperties();
-		return (String) properties.setProperty(key, value);
+	public void addTouchpointData(TouchpointData[] newData) {
+		ensureTouchpointDataCapacity(newData.length);
+		for (int i = 0; i < newData.length; i++) {
+			touchpointData.add(newData[i]);
+		}
 	}
 
-	public void setRequiredCapabilities(RequiredCapability[] capabilities) {
-		if (capabilities == NO_REQUIRES) {
-			this.requires = null;
+	private void ensureTouchpointDataCapacity(int size) {
+		if (touchpointData != null) {
+			touchpointData.ensureCapacity(size);
 		} else {
-			//copy array for safety
-			this.requires = (RequiredCapability[]) capabilities.clone();
+			touchpointData = new ArrayList(size);
 		}
 	}
 
-	public void setSingleton(boolean singleton) {
-		this.singleton = singleton;
+	private OrderedProperties properties() {
+		return (properties != null ? properties : NO_PROPERTIES);
 	}
 
-	public void setTouchpointType(TouchpointType type) {
-		this.touchpointType = type == TouchpointType.NONE ? null : type;
+	/**
+	 * Get an <i>unmodifiable copy</i> of the properties
+	 * associated with the installable unit.
+	 * 
+	 * @return an <i>unmodifiable copy</i> of the IU properties.
+	 */
+	public OrderedProperties getProperties() {
+		return new UnmodifiableProperties(properties());
 	}
 
-	public void setVersion(Version newVersion) {
-		this.version = newVersion == null ? Version.emptyVersion : newVersion;
+	public void addProperties(OrderedProperties newProperties) {
+		if (properties == null)
+			properties = new OrderedProperties(newProperties.size());
+		properties.putAll(newProperties);
 	}
 
-	public String toString() {
-		return id + ' ' + getVersion();
+	public boolean isFragment() {
+		return false;
+	}
+
+	public void setApplicabilityFilter(String ldapFilter) {
+		applicabilityFilter = ldapFilter;
+	}
+
+	public String getApplicabilityFilter() {
+		return applicabilityFilter;
+	}
+
+	public IResolvedInstallableUnit getResolved() {
+		return new ResolvedInstallableUnit(this);
+	}
+
+	public int compareTo(Object toCompareTo) {
+		if (!(toCompareTo instanceof IInstallableUnit)) {
+			return -1;
+		}
+		IInstallableUnit other = (IInstallableUnit) toCompareTo;
+		if (getId().compareTo(other.getId()) == 0)
+			return (getVersion().compareTo(other.getVersion()));
+		return getId().compareTo(other.getId());
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/InstallableUnitFragment.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/InstallableUnitFragment.java
index 20294ed..0e494ea 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/InstallableUnitFragment.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/InstallableUnitFragment.java
@@ -31,12 +31,12 @@ public class InstallableUnitFragment extends InstallableUnit implements IInstall
 			this.hostRange = hostRange;
 	}
 
-	private void addRequiredCapability(RequiredCapability toAdd) {
-		RequiredCapability[] current = super.getRequiredCapabilities();
-		RequiredCapability[] result = new RequiredCapability[current.length + 1];
-		System.arraycopy(current, 0, result, 0, current.length);
-		result[current.length] = toAdd;
-		setRequiredCapabilities(result);
+	public void setHost(String iuId, VersionRange versionRange) {
+		if (iuId == null || versionRange == null)
+			throw new IllegalArgumentException();
+		hostId = iuId;
+		hostRange = versionRange;
+		addRequiredCapability(RequiredCapability.createRequiredCapabilityForName(iuId, versionRange, false));
 	}
 
 	public String getHostId() {
@@ -47,30 +47,19 @@ public class InstallableUnitFragment extends InstallableUnit implements IInstall
 		return hostRange;
 	}
 
-	public ProvidedCapability[] getProvidedCapabilities() {
-		ProvidedCapability[] otherCapabilities = super.getProvidedCapabilities();
-		if (otherCapabilities.length == 0)
-			return new ProvidedCapability[] {FRAGMENT_CAPABILITY};
-		//		return otherCapabilities;
-		ProvidedCapability[] result = new ProvidedCapability[otherCapabilities.length + 1];
-		System.arraycopy(otherCapabilities, 0, result, 1, otherCapabilities.length);
-		result[0] = FRAGMENT_CAPABILITY;
-		return result;
-	}
-
-	public IResolvedInstallableUnit getResolved() {
-		return new ResolvedInstallableUnitFragment(this);
+	private void addRequiredCapability(RequiredCapability toAdd) {
+		RequiredCapability[] current = super.getRequiredCapabilities();
+		RequiredCapability[] result = new RequiredCapability[current.length + 1];
+		System.arraycopy(current, 0, result, 0, current.length);
+		result[current.length] = toAdd;
+		setRequiredCapabilities(result);
 	}
 
 	public boolean isFragment() {
 		return true;
 	}
 
-	public void setHost(String iuId, VersionRange versionRange) {
-		if (iuId == null || versionRange == null)
-			throw new IllegalArgumentException();
-		hostId = iuId;
-		hostRange = versionRange;
-		addRequiredCapability(RequiredCapability.createRequiredCapabilityForName(iuId, versionRange, false));
+	public IResolvedInstallableUnit getResolved() {
+		return new ResolvedInstallableUnitFragment(this);
 	}
-}
\ No newline at end of file
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
index c893a9f..2988b3e 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
@@ -16,8 +16,7 @@ import org.eclipse.equinox.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.p2.director.IDirector;
 import org.eclipse.equinox.p2.director.IPlanner;
 import org.eclipse.equinox.p2.engine.Profile;
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
+import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepositoryManager;
 import org.eclipse.osgi.service.resolver.VersionRange;
@@ -27,6 +26,8 @@ import org.osgi.framework.Version;
  * Base class for provisioning tests with convenience methods used by multiple tests.
  */
 public class AbstractProvisioningTest extends TestCase {
+
+	protected static Version DEFAULT_VERSION = new Version(1, 0, 0);
 	protected static VersionRange ANY_VERSION = new VersionRange(Version.emptyVersion, true, new Version(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE), true);
 
 	/**
@@ -96,7 +97,7 @@ public class AbstractProvisioningTest extends TestCase {
 		super(name);
 	}
 
-	public void assertEmptyProfile(Profile p) {
+	public static void assertEmptyProfile(Profile p) {
 		assertNotNull("The profile should not be null", p);
 		boolean containsIU = false;
 		for (Iterator iterator = p.getInstallableUnits(); iterator.hasNext();) {
@@ -106,7 +107,7 @@ public class AbstractProvisioningTest extends TestCase {
 			fail("The profile should be empty,profileId=" + p);
 	}
 
-	protected void assertNotIUs(IInstallableUnit[] ius, Iterator installableUnits) {
+	protected static void assertNotIUs(IInstallableUnit[] ius, Iterator installableUnits) {
 		Set notexpected = new HashSet();
 		notexpected.addAll(Arrays.asList(ius));
 
@@ -118,11 +119,11 @@ public class AbstractProvisioningTest extends TestCase {
 		}
 	}
 
-	protected void assertNotOK(IStatus result) {
+	protected static void assertNotOK(IStatus result) {
 		assertTrue("The status should not have been OK", !result.isOK());
 	}
 
-	protected void assertOK(IStatus result) {
+	protected static void assertOK(IStatus result) {
 		if (result.isOK())
 			return;
 
@@ -144,7 +145,7 @@ public class AbstractProvisioningTest extends TestCase {
 	/**
 	 * Asserts that the given profile contains *only* the given IUs.
 	 */
-	protected void assertProfileContains(String message, Profile profile, IInstallableUnit[] expectedUnits) {
+	protected static void assertProfileContains(String message, Profile profile, IInstallableUnit[] expectedUnits) {
 		HashSet expected = new HashSet(Arrays.asList(expectedUnits));
 		for (Iterator it = profile.getInstallableUnits(); it.hasNext();) {
 			IInstallableUnit actual = (IInstallableUnit) it.next();
@@ -158,7 +159,7 @@ public class AbstractProvisioningTest extends TestCase {
 	/**
 	 * Asserts that the given profile contains all the given IUs.
 	 */
-	protected void assertProfileContainsAll(String message, Profile profile, IInstallableUnit[] expectedUnits) {
+	protected static void assertProfileContainsAll(String message, Profile profile, IInstallableUnit[] expectedUnits) {
 		HashSet expected = new HashSet(Arrays.asList(expectedUnits));
 		for (Iterator it = profile.getInstallableUnits(); it.hasNext();) {
 			IInstallableUnit actual = (IInstallableUnit) it.next();
@@ -168,36 +169,155 @@ public class AbstractProvisioningTest extends TestCase {
 			fail(message + " profile " + profile.getProfileId() + " did not contain expected units: " + expected);
 	}
 
-	public IDirector createDirector() {
+	public static IDirector createDirector() {
 		return (IDirector) ServiceHelper.getService(TestActivator.getContext(), IDirector.class.getName());
 	}
 
 	/**
 	 * Creates and returns a correctly formatted LDAP filter with the given key and value.
 	 */
-	protected String createFilter(String filterKey, String filterValue) {
+	protected static String createFilter(String filterKey, String filterValue) {
 		return "(" + filterKey + '=' + filterValue + ')';
 	}
 
-	public IPlanner createPlanner() {
+	public static IPlanner createPlanner() {
 		return (IPlanner) ServiceHelper.getService(TestActivator.getContext(), IPlanner.class.getName());
 	}
 
 	/**
 	 * Creates and returns a required capability with the provided attributes.
 	 */
-	protected RequiredCapability[] createRequiredCapabilities(String namespace, String name, String filter) {
+	protected static RequiredCapability[] createRequiredCapabilities(String namespace, String name, String filter) {
 		return createRequiredCapabilities(namespace, name, ANY_VERSION, filter);
 	}
 
 	/**
 	 * Creates and returns a required capability with the provided attributes.
 	 */
-	protected RequiredCapability[] createRequiredCapabilities(String namespace, String name, VersionRange range, String filter) {
+	protected static RequiredCapability[] createRequiredCapabilities(String namespace, String name, VersionRange range, String filter) {
 		return new RequiredCapability[] {new RequiredCapability(namespace, name, range, filter, false, false)};
 	}
 
 	/**
+	 * 	Get the 'self' capability for the given installable unit.
+	 */
+	private static ProvidedCapability getSelfCapability(InstallableUnit iu) {
+		return new ProvidedCapability(IInstallableUnit.IU_NAMESPACE, iu.getId(), iu.getVersion());
+	}
+
+	/**
+	 * 	Create a basic InstallableUnit with the given name. The IU has the default version
+	 *  and the default self capability is added to the IU.
+	 */
+	public static InstallableUnit createIU(String name) {
+		return createIU(name, DEFAULT_VERSION);
+	}
+
+	/**
+	 * 	Create a basic InstallableUnit with the given name and version.
+	 * 	The default self capability is added to the IU.
+	 */
+	public static InstallableUnit createIU(String name, Version version) {
+		InstallableUnit iu = new InstallableUnit(name, version, false);
+		ProvidedCapability[] provides = new ProvidedCapability[] {getSelfCapability(iu)};
+		iu.setCapabilities(provides);
+		return iu;
+	}
+
+	/**
+	 * 	Create a basic InstallableUnit with the given name and additional provided capabilities.
+	 *  The IU has the default version and the default self capability is also added to the IU.
+	 */
+	public static InstallableUnit createIU(String name, ProvidedCapability[] additionalProvides) {
+		return createIU(name, DEFAULT_VERSION, additionalProvides);
+	}
+
+	/**
+	 * 	Create a basic InstallableUnit with the given name, version, and additional
+	 *  provided capabilities. The default self capability is also added to the IU.
+	 */
+	public static InstallableUnit createIU(String name, Version version, ProvidedCapability[] additionalProvides) {
+		InstallableUnit iu = new InstallableUnit(name, version, false);
+		ProvidedCapability[] provides = new ProvidedCapability[additionalProvides.length + 1];
+		provides[0] = getSelfCapability(iu);
+		for (int i = 0; i < additionalProvides.length; i++) {
+			provides[i + 1] = additionalProvides[i];
+		}
+		iu.setCapabilities(provides);
+		return iu;
+	}
+
+	/**
+	 * 	Create an eclipse InstallableUnit with the given name and the eclipse touchpoint type.
+	 *  The IU has the default version and the default self capability is added to the IU.
+	 */
+	public static InstallableUnit createEclipseIU(String name) {
+		return createEclipseIU(name, DEFAULT_VERSION);
+	}
+
+	/**
+	 * 	Create a basic InstallableUnitFragment with the given name. The IU has the default version
+	 *  and the self and fragment provided capabilities are added to the IU.
+	 */
+	public static InstallableUnitFragment createIUFragment(String name) {
+		return createIUFragment(name, DEFAULT_VERSION);
+	}
+
+	/**
+	 * 	Create a basic InstallableUnitFragment with the given name and version.
+	 * 	The default self and fragment provided capabilities are added to the IU.
+	 */
+	public static InstallableUnitFragment createIUFragment(String name, Version version) {
+		InstallableUnitFragment iu = new InstallableUnitFragment();
+		iu.setId(name);
+		iu.setVersion(version);
+		ProvidedCapability[] cap = new ProvidedCapability[] {getSelfCapability(iu), InstallableUnitFragment.FRAGMENT_CAPABILITY};
+		iu.setCapabilities(cap);
+		return iu;
+	}
+
+	/**
+	 * 	Create an eclipse InstallableUnitFragment with the given name that is hosted
+	 *  by any bundle. The fragment has the default version, and the default self and
+	 *  fragment provided capabilities are added to the IU.
+	 */
+	public static InstallableUnitFragment createBundleFragment(String name) {
+		return createBundleFragment(name, DEFAULT_VERSION);
+	}
+
+	// TODO: The following group of utilities are (somewhat) specific to eclipse test cases
+	//		 so could be moved to a separate base class (e.g. AbstractEclipseProvisioningTestCase)
+	//		 that extends AbstractProvisioningTestCase.
+
+	private static TouchpointType ECLIPSE_TOUCHPOINT = new TouchpointType("eclipse", new Version(1, 0, 0));
+	private static ProvidedCapability[] BUNDLE_CAPABILITY = new ProvidedCapability[] {new ProvidedCapability("eclipse.touchpoint", "bundle", new Version(1, 0, 0))};
+	private static RequiredCapability[] BUNDLE_REQUIREMENT = new RequiredCapability[] {new RequiredCapability("eclipse.touchpoint", "bundle", VersionRange.emptyRange, null, false, true)};
+
+	/**
+	 * 	Create an eclipse InstallableUnit with the given name, version, and the eclipse touchpoint type.
+	 *  The IU has the default version and the default self capability is added to the IU.
+	 */
+	public static InstallableUnit createEclipseIU(String name, Version version) {
+		InstallableUnit iu = createIU(name, version, BUNDLE_CAPABILITY);
+		iu.setTouchpointType(ECLIPSE_TOUCHPOINT);
+		return iu;
+	}
+
+	/**
+	 * 	Create an eclipse InstallableUnitFragment with the given name and version
+	 *  that is hosted by any bundle. The default self and fragment provided capabilities
+	 *  are added to the IU.
+	 */
+	public static InstallableUnitFragment createBundleFragment(String name, Version version) {
+		InstallableUnitFragment fragment = createIUFragment(name, version);
+		fragment.setTouchpointType(ECLIPSE_TOUCHPOINT);
+		fragment.setRequiredCapabilities(BUNDLE_REQUIREMENT);
+		return fragment;
+	}
+
+	// End of eclipse specific utilities.
+
+	/**
 	 * Adds a test metadata repository to the system that provides the given units. 
 	 * The repository will automatically be removed in the tearDown method.
 	 */
@@ -209,7 +329,7 @@ public class AbstractProvisioningTest extends TestCase {
 		metadataRepos.add(repo);
 	}
 
-	public void printProfile(Profile toPrint) {
+	public static void printProfile(Profile toPrint) {
 		boolean containsIU = false;
 		for (Iterator iterator = toPrint.getInstallableUnits(); iterator.hasNext();) {
 			System.out.println(iterator.next());
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/AutomatedDirectorTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/AutomatedDirectorTest.java
index 11c84e5..591784b 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/AutomatedDirectorTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/AutomatedDirectorTest.java
@@ -16,13 +16,12 @@ import org.eclipse.equinox.p2.director.IDirector;
 import org.eclipse.equinox.p2.engine.Profile;
 import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
-import org.osgi.framework.Version;
 
 /**
  * Various automated tests of the {@link IDirector} API.
  */
 public class AutomatedDirectorTest extends AbstractProvisioningTest {
-	private static Version version = new Version(1, 0, 0);
+	//private static Version version = new Version(1, 0, 0);
 
 	public static Test suite() {
 		return new TestSuite(AutomatedDirectorTest.class);
@@ -43,14 +42,11 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	 * and the second IU should not be installed.
 	 */
 	public void testInstallFilteredCapability() {
-		//The IU that is required
-		InstallableUnit requiredIU = new InstallableUnit();
-		requiredIU.setId("required." + getName());
-		requiredIU.setVersion(version);
-
-		InstallableUnit toInstallIU = new InstallableUnit();
-		toInstallIU.setId("toInstall." + getName());
-		toInstallIU.setVersion(version);
+		// The IU that is required
+		InstallableUnit requiredIU = createIU("required." + getName());
+
+		// The IU to be installed
+		InstallableUnit toInstallIU = createIU("toInstall." + getName());
 		String filter = createFilter("FilterKey", "true");
 		RequiredCapability capability = new RequiredCapability(IInstallableUnit.IU_NAMESPACE, requiredIU.getId(), ANY_VERSION, filter, false, false);
 		toInstallIU.setRequiredCapabilities(new RequiredCapability[] {capability});
@@ -78,17 +74,12 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	 */
 	public void testInstallOptionalAvailable() {
 		String capabilityId = "test." + getName();
-		//The IU that exports the capability
-		InstallableUnit requiredIU = new InstallableUnit();
-		requiredIU.setId("required." + getName());
-		requiredIU.setVersion(version);
-		requiredIU.setCapabilities(new ProvidedCapability[] {new ProvidedCapability("test.capability", capabilityId, version)});
-
-		//The IU that optionally requires the capability
-		InstallableUnit toInstallIU = new InstallableUnit();
-		toInstallIU.setId("toInstall." + getName());
-		toInstallIU.setVersion(version);
-		RequiredCapability required = new RequiredCapability("test.capability", capabilityId, ANY_VERSION, null, true, false);
+		// The IU that exports the capability
+		InstallableUnit requiredIU = createIU("required." + getName(), new ProvidedCapability[] {new ProvidedCapability("test.capability", capabilityId, DEFAULT_VERSION)});
+
+		// The IU that optionally requires the capability
+		InstallableUnit toInstallIU = createIU("toInstall." + getName());
+		RequiredCapability required = new RequiredCapability("test.capability", capabilityId, ANY_VERSION, null, /* optional=> */true, /* multiple=> */false);
 		toInstallIU.setRequiredCapabilities(new RequiredCapability[] {required});
 
 		IInstallableUnit[] allUnits = new IInstallableUnit[] {toInstallIU, requiredIU};
@@ -109,9 +100,7 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	 */
 	public void testInstallOptionalUnavailable() {
 		String capabilityId = "test." + getName();
-		InstallableUnit toInstallIU = new InstallableUnit();
-		toInstallIU.setId("toInstall." + getName());
-		toInstallIU.setVersion(version);
+		InstallableUnit toInstallIU = createIU("toInstall." + getName());
 		//no IU will be available that exports this capability
 		RequiredCapability required = new RequiredCapability("test.capability", capabilityId, ANY_VERSION, null, true, false);
 		toInstallIU.setRequiredCapabilities(new RequiredCapability[] {required});
@@ -135,15 +124,10 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	public void testInstallPlatformFilter() {
 		//The IU that exports the capability
 		String capabilityId = "test." + getName();
-		InstallableUnit requiredIU = new InstallableUnit();
-		requiredIU.setId("required." + getName());
-		requiredIU.setVersion(version);
-		requiredIU.setCapabilities(new ProvidedCapability[] {new ProvidedCapability("test.capability", capabilityId, version)});
+		InstallableUnit requiredIU = createIU("required." + getName(), new ProvidedCapability[] {new ProvidedCapability("test.capability", capabilityId, DEFAULT_VERSION)});
 		requiredIU.setFilter(createFilter("osgi.os", "blort"));
 
-		InstallableUnit toInstallIU = new InstallableUnit();
-		toInstallIU.setId("toInstall." + getName());
-		toInstallIU.setVersion(version);
+		InstallableUnit toInstallIU = createIU("toInstall." + getName());
 		toInstallIU.setRequiredCapabilities(createRequiredCapabilities("test.capability", capabilityId, ANY_VERSION, null));
 
 		IInstallableUnit[] allUnits = new IInstallableUnit[] {requiredIU, toInstallIU};
@@ -168,14 +152,9 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	public void testSimpleInstallRequired() {
 		String capabilityId = "test." + getName();
 		//The IU that exports the capability
-		InstallableUnit requiredIU = new InstallableUnit();
-		requiredIU.setId("required." + getName());
-		requiredIU.setVersion(version);
-		requiredIU.setCapabilities(new ProvidedCapability[] {new ProvidedCapability("test.capability", capabilityId, version)});
-
-		InstallableUnit toInstallIU = new InstallableUnit();
-		toInstallIU.setId("toInstall." + getName());
-		toInstallIU.setVersion(version);
+		InstallableUnit requiredIU = createIU("required." + getName(), new ProvidedCapability[] {new ProvidedCapability("test.capability", capabilityId, DEFAULT_VERSION)});
+
+		InstallableUnit toInstallIU = createIU("toInstall." + getName());
 		toInstallIU.setRequiredCapabilities(createRequiredCapabilities("test.capability", capabilityId, ANY_VERSION, null));
 
 		IInstallableUnit[] allUnits = new IInstallableUnit[] {requiredIU, toInstallIU};
@@ -197,14 +176,10 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	 * specifying a version range (any version will do).
 	 */
 	public void testInstallRequiredNoVersion() {
-		//The IU that is needed
-		InstallableUnit requiredIU = new InstallableUnit();
-		requiredIU.setId("required." + getName());
-		requiredIU.setVersion(version);
-
-		InstallableUnit toInstallIU = new InstallableUnit();
-		toInstallIU.setId("toInstall." + getName());
-		toInstallIU.setVersion(version);
+		// The IU that is needed
+		InstallableUnit requiredIU = createIU("required." + getName());
+
+		InstallableUnit toInstallIU = createIU("toInstall." + getName());
 		RequiredCapability capability = new RequiredCapability(IInstallableUnit.IU_NAMESPACE, requiredIU.getId(), null, null, false, false);
 		toInstallIU.setRequiredCapabilities(new RequiredCapability[] {capability});
 
@@ -228,14 +203,10 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	 * capability on the IU namespace.
 	 */
 	public void testSimpleInstallRequiredIU() {
-		//The IU that exports the capability
-		InstallableUnit requiredIU = new InstallableUnit();
-		requiredIU.setId("required." + getName());
-		requiredIU.setVersion(version);
+		// The IU that exports the capability
+		InstallableUnit requiredIU = createIU("required." + getName());
 
-		InstallableUnit toInstallIU = new InstallableUnit();
-		toInstallIU.setId("toInstall." + getName());
-		toInstallIU.setVersion(version);
+		InstallableUnit toInstallIU = createIU("toInstall." + getName());
 		RequiredCapability capability = new RequiredCapability(IInstallableUnit.IU_NAMESPACE, requiredIU.getId(), ANY_VERSION, null, false, false);
 		toInstallIU.setRequiredCapabilities(new RequiredCapability[] {capability});
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/OracleTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/OracleTest.java
index a9e9a36..954bcb4 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/OracleTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/OracleTest.java
@@ -29,32 +29,22 @@ public class OracleTest extends AbstractProvisioningTest {
 	Profile profile;
 
 	protected void setUp() throws Exception {
-		a1 = new InstallableUnit();
-		a1.setId("A");
-		a1.setVersion(new Version(1, 0, 0));
+		a1 = createIU("A");
 		a1.setSingleton(true);
 		a1.setRequiredCapabilities(createRequiredCapabilities(IInstallableUnit.IU_NAMESPACE, "C", new VersionRange("[1.0.0, 2.0.0)"), null));
 
-		c1 = new InstallableUnit();
-		c1.setId("C");
-		c1.setVersion(new Version(1, 0, 0));
+		c1 = createIU("C");
 		c1.setSingleton(true);
 		c1.setRequiredCapabilities(createRequiredCapabilities(IInstallableUnit.IU_NAMESPACE, "D", new VersionRange("[1.0.0, 3.0.0)"), null));
 
-		d1 = new InstallableUnit();
-		d1.setId("D");
-		d1.setVersion(new Version(1, 0, 0));
+		d1 = createIU("D");
 		d1.setSingleton(true);
 
-		b1 = new InstallableUnit();
-		b1.setId("B");
-		b1.setVersion(new Version(1, 0, 0));
+		b1 = createIU("B");
 		b1.setSingleton(true);
 		b1.setRequiredCapabilities(createRequiredCapabilities(IInstallableUnit.IU_NAMESPACE, "D", new VersionRange("[2.0.0, 3.0.0)"), null));
 
-		d2 = new InstallableUnit();
-		d2.setId("D");
-		d2.setVersion(new Version(2, 0, 0));
+		d2 = createIU("D", new Version(2, 0, 0));
 		d2.setSingleton(true);
 
 		createTestMetdataRepository(new IInstallableUnit[] {a1, c1, d1, b1});
@@ -65,10 +55,10 @@ public class OracleTest extends AbstractProvisioningTest {
 	}
 
 	public void testInstallA1() {
-		assertEquals(director.install(new IInstallableUnit[] {a1}, profile, null).getSeverity(), IStatus.OK);
+		assertEquals(IStatus.OK, director.install(new IInstallableUnit[] {a1}, profile, null).getSeverity());
 
 		createTestMetdataRepository(new IInstallableUnit[] {d2});
 		//		assertEquals(new Oracle().canInstall(new IInstallableUnit[] {b1}, profile, null), true);
-		assertEquals(director.install(new IInstallableUnit[] {b1}, profile, null).getSeverity(), IStatus.OK);
+		assertEquals(IStatus.OK, director.install(new IInstallableUnit[] {b1}, profile, null).getSeverity());
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/OracleTest2.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/OracleTest2.java
index 7017463..507ed4d 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/OracleTest2.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/OracleTest2.java
@@ -27,34 +27,24 @@ public class OracleTest2 extends AbstractProvisioningTest {
 	Profile profile;
 
 	protected void setUp() throws Exception {
-		a1 = new InstallableUnit();
-		a1.setId("A");
-		a1.setVersion(new Version(1, 0, 0));
+		a1 = createIU("A");
 		a1.setSingleton(true);
 		a1.setRequiredCapabilities(createRequiredCapabilities(IInstallableUnit.IU_NAMESPACE, "C", new VersionRange("[1.0.0, 2.0.0)"), null));
 
-		c1 = new InstallableUnit();
-		c1.setId("C");
-		c1.setVersion(new Version(1, 0, 0));
+		c1 = createIU("C");
 		c1.setSingleton(true);
 
-		a2 = new InstallableUnit();
-		a2.setId("A");
-		a2.setVersion(new Version(2, 0, 0));
+		a2 = createIU("A", new Version(2, 0, 0));
 		a2.setSingleton(true);
 		a2.setProperty(IInstallableUnitConstants.UPDATE_FROM, "A");
 		a2.setProperty(IInstallableUnitConstants.UPDATE_RANGE, "[1.0.0, 2.3.0)");
 		a2.setRequiredCapabilities(createRequiredCapabilities(IInstallableUnit.IU_NAMESPACE, "C", new VersionRange("[2.0.0, 3.0.0)"), null));
 
-		b1 = new InstallableUnit();
-		b1.setId("B");
-		b1.setVersion(new Version(1, 0, 0));
+		b1 = createIU("B");
 		b1.setSingleton(true);
 		b1.setRequiredCapabilities(createRequiredCapabilities(IInstallableUnit.IU_NAMESPACE, "C", new VersionRange("[2.0.0, 3.0.0)"), null));
 
-		c2 = new InstallableUnit();
-		c2.setId("C");
-		c2.setVersion(new Version(2, 0, 0));
+		c2 = createIU("C", new Version(2, 0, 0));
 		c2.setSingleton(true);
 		c2.setProperty(IInstallableUnitConstants.UPDATE_FROM, "C");
 		c2.setProperty(IInstallableUnitConstants.UPDATE_RANGE, "[1.0.0, 2.3.0)");
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/SingletonTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/SingletonTest.java
index 87f0f59..d6eef66 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/SingletonTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/SingletonTest.java
@@ -31,32 +31,20 @@ public class SingletonTest extends AbstractProvisioningTest {
 	Profile profile;
 
 	protected void setUp() throws Exception {
-		f1 = new InstallableUnit();
-		f1.setId("f1");
-		f1.setVersion(new Version(1, 0, 0));
+		f1 = createIU("f1");
 		f1.setSingleton(true);
 
-		f1_1 = new InstallableUnit();
-		f1_1.setId("f1");
-		f1_1.setVersion(new Version(1, 1, 0));
+		f1_1 = createIU("f1", new Version(1, 1, 0));
 		f1_1.setSingleton(true);
 
-		f2 = new InstallableUnit();
-		f2.setId("f2");
-		f2.setVersion(new Version(1, 0, 0));
+		f2 = createIU("f2");
 		f2.setSingleton(true);
 
-		f2_1 = new InstallableUnit();
-		f2_1.setId("f2");
-		f2_1.setVersion(new Version(1, 0, 1));
+		f2_1 = createIU("f2", new Version(1, 0, 1));
 
-		junit38 = new InstallableUnit();
-		junit38.setId("junit");
-		junit38.setVersion(new Version(3, 8, 1));
+		junit38 = createIU("junit", new Version(3, 8, 1));
 
-		junit40 = new InstallableUnit();
-		junit40.setId("junit");
-		junit40.setVersion(new Version(4, 0, 1));
+		junit40 = createIU("junit", new Version(4, 0, 1));
 
 		createTestMetdataRepository(new IInstallableUnit[] {f1, f1_1, junit38, junit40, f2, f2_1});
 
@@ -65,17 +53,17 @@ public class SingletonTest extends AbstractProvisioningTest {
 	}
 
 	public void testMultipleVersionNonSingleton() {
-		//The installation of junit38 and junit 40 together should succeed
-		assertEquals(director.install(new IInstallableUnit[] {junit38, junit40}, profile, new NullProgressMonitor()).getSeverity(), IStatus.OK);
+		// The installation of junit38 and junit 40 together should succeed
+		assertEquals(IStatus.OK, director.install(new IInstallableUnit[] {junit38, junit40}, profile, new NullProgressMonitor()).getSeverity());
 	}
 
 	public void testMultipleVersionSingleton() {
-		//The installation of junit38 and junit 40 together should succeed
-		assertEquals(director.install(new IInstallableUnit[] {f1, f1_1}, profile, new NullProgressMonitor()).getSeverity(), IStatus.ERROR);
+		// The installation of junit38 and junit 40 together should succeed
+		assertEquals(IStatus.ERROR, director.install(new IInstallableUnit[] {f1, f1_1}, profile, new NullProgressMonitor()).getSeverity());
 	}
 
 	public void testMultipleVersionSingleton2() {
-		//The installation of junit38 and junit 40 together should succeed
-		assertEquals(director.install(new IInstallableUnit[] {f2, f2_1}, profile, new NullProgressMonitor()).getSeverity(), IStatus.ERROR);
+		// The installation of junit38 and junit 40 together should succeed
+		assertEquals(IStatus.ERROR, director.install(new IInstallableUnit[] {f2, f2_1}, profile, new NullProgressMonitor()).getSeverity());
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UninstallTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UninstallTest.java
index 0a844dc..dadfa9e 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UninstallTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UninstallTest.java
@@ -13,7 +13,6 @@ import org.eclipse.equinox.p2.engine.Profile;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.p2.metadata.InstallableUnit;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
-import org.osgi.framework.Version;
 
 public class UninstallTest extends AbstractProvisioningTest {
 	private InstallableUnit a1;
@@ -21,9 +20,7 @@ public class UninstallTest extends AbstractProvisioningTest {
 	private IDirector director;
 
 	protected void setUp() throws Exception {
-		a1 = new InstallableUnit();
-		a1.setId("A");
-		a1.setVersion(new Version(1, 0, 0));
+		a1 = createIU("A");
 		a1.setSingleton(true);
 
 		profile = new Profile("TestProfile." + getName());
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UpdateTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UpdateTest.java
index 463c3e9..adf9075 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UpdateTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UpdateTest.java
@@ -30,29 +30,19 @@ public class UpdateTest extends AbstractProvisioningTest {
 	Profile profile;
 
 	protected void setUp() throws Exception {
-		f1 = new InstallableUnit();
-		f1.setId("f1");
-		f1.setVersion(new Version(1, 0, 0));
+		f1 = createIU("f1");
 		f1.setSingleton(true);
 
-		f1_1 = new InstallableUnit();
-		f1_1.setId("f1");
-		f1_1.setVersion(new Version(1, 1, 0));
+		f1_1 = createIU("f1", new Version(1, 1, 0));
 		f1_1.setSingleton(true);
 
-		f1_4 = new InstallableUnit();
-		f1_4.setId("f1");
-		f1_4.setVersion(new Version(1, 4, 0));
+		f1_4 = createIU("f1", new Version(1, 4, 0));
 		f1_4.setSingleton(true);
 
-		fa = new InstallableUnit();
-		fa.setId("fa");
-		fa.setVersion(new Version(1, 0, 0));
+		fa = createIU("fa");
 		fa.setRequiredCapabilities(createRequiredCapabilities(IInstallableUnit.IU_NAMESPACE, "f1", new VersionRange("[1.0.0, 1.3.0)"), null));
 
-		fap = new InstallableUnit();
-		fap.setId("fa");
-		fap.setVersion(new Version(1, 1, 0));
+		fap = createIU("fa", new Version(1, 1, 0));
 		fap.setRequiredCapabilities(createRequiredCapabilities(IInstallableUnit.IU_NAMESPACE, "f1", new VersionRange("[1.0.0, 1.4.0)"), null));
 
 		createTestMetdataRepository(new IInstallableUnit[] {f1, fa});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentTest.java
index db9a72c..ca752fb 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentTest.java
@@ -12,16 +12,15 @@ package org.eclipse.equinox.p2.tests.metadata;
 
 import java.util.*;
 import junit.framework.AssertionFailedError;
-import junit.framework.TestCase;
 import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.resolution.ResolutionHelper;
-import org.eclipse.osgi.service.resolver.VersionRange;
-import org.osgi.framework.Version;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
+
+public class FragmentTest extends AbstractProvisioningTest {
 
-public class FragmentTest extends TestCase {
 	public void testAssociation() {
-		IInstallableUnit iu1 = createIU("ui.test1");
-		IInstallableUnit iu2 = createIUFragment("iuFragment.test1");
+		IInstallableUnit iu1 = createEclipseIU("ui.test1");
+		IInstallableUnit iu2 = createBundleFragment("iuFragment.test1");
 		ResolutionHelper rh = new ResolutionHelper(new Hashtable(), null);
 		HashSet set = new HashSet();
 		set.add(iu1);
@@ -37,9 +36,9 @@ public class FragmentTest extends TestCase {
 	}
 
 	public void testAssociation2() {
-		IInstallableUnit iu1 = createIU("ui.test1");
-		IInstallableUnit iu3 = createIU("ui.test3");
-		IInstallableUnit iu2 = createIUFragment("iuFragment.test1");
+		IInstallableUnit iu1 = createEclipseIU("ui.test1");
+		IInstallableUnit iu3 = createEclipseIU("ui.test3");
+		IInstallableUnit iu2 = createBundleFragment("iuFragment.test1");
 		ResolutionHelper rh = new ResolutionHelper(new Hashtable(), null);
 		HashSet set = new HashSet();
 		set.add(iu1);
@@ -78,17 +77,16 @@ public class FragmentTest extends TestCase {
 	}
 
 	public void testFragmentCapability() {
-		IInstallableUnit iu = createIUFragment("iuFragment.test1");
+		IInstallableUnit iu = createBundleFragment("iuFragment.test1");
 		ProvidedCapability[] all = iu.getProvidedCapabilities();
 		assertContains(all, InstallableUnitFragment.FRAGMENT_CAPABILITY);
 	}
 
 	public void testDefaultIUCapability() {
-		IInstallableUnit iu = createIU("ui.test1");
+		IInstallableUnit iu = createEclipseIU("ui.test1");
 		ProvidedCapability[] cap = iu.getProvidedCapabilities();
 		for (int i = 0; i < cap.length; i++) {
 			if (cap[i].getNamespace().equals(IInstallableUnit.IU_NAMESPACE)) {
-
 				assertEquals(cap[i].getNamespace(), IInstallableUnit.IU_NAMESPACE);
 				assertEquals(cap[i].getName(), iu.getId());
 				return;
@@ -113,34 +111,14 @@ public class FragmentTest extends TestCase {
 		throw new AssertionFailedError("The array does not contain the searched element");
 	}
 
-	public static InstallableUnit createIUFragment(String name) {
-		InstallableUnitFragment iu = new InstallableUnitFragment();
-		iu.setId(name);
-		iu.setVersion(new Version(1, 0, 0));
-		iu.setTouchpointType(new TouchpointType("eclipse", new Version(1, 0, 0)));
-		iu.setRequiredCapabilities(new RequiredCapability[] {new RequiredCapability("eclipse.touchpoint", "bundle", VersionRange.emptyRange, null, false, true)});
-		return iu;
-	}
-
-	public static InstallableUnit createIU(String name) {
-		InstallableUnit iu = new InstallableUnit();
-		iu.setId(name);
-		iu.setVersion(new Version(1, 0, 0));
-		iu.setTouchpointType(new TouchpointType("eclipse", new Version(1, 0, 0)));
-
-		ProvidedCapability[] cap = new ProvidedCapability[] {new ProvidedCapability("eclipse.touchpoint", "bundle", new Version(1, 0, 0))};
-		iu.setCapabilities(cap);
-		return iu;
-	}
-
 	private IInstallableUnit createIUWithTouchpointData() {
-		InstallableUnit unit = createIU("ui.test1");
+		InstallableUnit unit = createEclipseIU("ui.test1");
 		unit.setImmutableTouchpointData(new TouchpointData(new HashMap()));
 		return unit;
 	}
 
 	private IInstallableUnit createIUFragmentWithTouchpointData() {
-		InstallableUnit unit = createIUFragment("iuFragment.test1");
+		InstallableUnit unit = createBundleFragment("iuFragment.test1");
 		unit.setImmutableTouchpointData(new TouchpointData(new HashMap()));
 		return unit;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/MultipleIUAndFragmentTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/MultipleIUAndFragmentTest.java
index bce261e..ca8533d 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/MultipleIUAndFragmentTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/MultipleIUAndFragmentTest.java
@@ -11,22 +11,22 @@
 package org.eclipse.equinox.p2.tests.metadata;
 
 import java.util.*;
-import junit.framework.TestCase;
 import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.resolution.ResolutionHelper;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
 import org.eclipse.osgi.service.resolver.VersionRange;
-import org.osgi.framework.Version;
 
-public class MultipleIUAndFragmentTest extends TestCase {
+public class MultipleIUAndFragmentTest extends AbstractProvisioningTest {
+
 	IInstallableUnit iu1;
 	IInstallableUnit iu2;
 	IInstallableUnit iu3;
 	Collection result;
 
 	protected void setUp() throws Exception {
-		iu1 = createIU("one");
+		iu1 = createEclipseIU("one");
 		iu2 = createIUWithDependencyOn("two", "one");
-		iu3 = createIUFragment("fragment");
+		iu3 = createBundleFragment("fragment");
 		HashSet set = new HashSet();
 		set.add(iu1);
 		set.add(iu2);
@@ -35,6 +35,7 @@ public class MultipleIUAndFragmentTest extends TestCase {
 	}
 
 	protected void tearDown() throws Exception {
+		super.tearDown();
 		iu1 = null;
 		iu2 = null;
 		iu3 = null;
@@ -58,34 +59,8 @@ public class MultipleIUAndFragmentTest extends TestCase {
 
 	}
 
-	private IInstallableUnit createIUFragment(String name) {
-		InstallableUnitFragment iu = new InstallableUnitFragment();
-		iu.setId(name);
-		iu.setVersion(new Version(1, 0, 0));
-		iu.setTouchpointType(new TouchpointType("eclipse", new Version(1, 0, 0)));
-
-		RequiredCapability[] reqs = new RequiredCapability[] {new RequiredCapability("eclipse.touchpoint", "bundle", VersionRange.emptyRange, null, false, true)};
-		iu.setRequiredCapabilities(reqs);
-		return iu;
-	}
-
-	private static IInstallableUnit createIU(String name) {
-		InstallableUnit iu = new InstallableUnit();
-		iu.setId(name);
-		iu.setVersion(new Version(1, 0, 0));
-		iu.setTouchpointType(new TouchpointType("eclipse", new Version(1, 0, 0)));
-
-		ProvidedCapability[] cap = new ProvidedCapability[] {new ProvidedCapability("eclipse.touchpoint", "bundle", new Version(1, 0, 0))};
-		iu.setCapabilities(cap);
-		return iu;
-	}
-
-	private static IInstallableUnit createIUWithDependencyOn(String name, String dependencyOn) {
-		InstallableUnit iu = new InstallableUnit();
-		iu.setId(name);
-		iu.setVersion(new Version(1, 0, 0));
-		iu.setTouchpointType(new TouchpointType("eclipse", new Version(1, 0, 0)));
-		iu.setCapabilities(new ProvidedCapability[] {new ProvidedCapability("eclipse.touchpoint", "bundle", new Version(1, 0, 0))});
+	private static IInstallableUnit createIUWithDependencyOn(String iuName, String dependencyOn) {
+		InstallableUnit iu = createEclipseIU(iuName);
 		iu.setRequiredCapabilities(new RequiredCapability[] {new RequiredCapability(IInstallableUnit.IU_NAMESPACE, dependencyOn, VersionRange.emptyRange, null, false, true)});
 		return iu;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/OldTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/OldTest.java
index b627c61..706f39a 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/OldTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/OldTest.java
@@ -93,13 +93,5 @@ public class OldTest {
 		jre.setCapabilities(new ProvidedCapability[] {new ProvidedCapability("java.runtime", "JRE", new Version(1, 4, 2, "sr2"))});
 
 		throw new IllegalStateException("XStream has been removed.  Should this test be fixed? or removed?");
-		//		ArrayList all = new ArrayList();
-		//		all.add(osgi);
-		//		try {
-		//			new XStream().toXML(all, new FileOutputStream(new File("d:/tmp/m2.xml")));
-		//		} catch (FileNotFoundException e) {
-		//			// TODO Auto-generated catch block
-		//			e.printStackTrace();
-		//		}
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/RecommendationTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/RecommendationTest.java
index eb5d2ec..6ad3442 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/RecommendationTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/RecommendationTest.java
@@ -13,14 +13,14 @@ package org.eclipse.equinox.p2.tests.metadata;
 import java.lang.reflect.Method;
 import java.util.HashSet;
 import java.util.Set;
-import junit.framework.TestCase;
 import org.eclipse.core.runtime.Status;
 import org.eclipse.equinox.internal.p2.director.Picker;
 import org.eclipse.equinox.p2.metadata.*;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
 import org.eclipse.osgi.service.resolver.VersionRange;
 import org.osgi.framework.Version;
 
-public class RecommendationTest extends TestCase {
+public class RecommendationTest extends AbstractProvisioningTest {
 	//test name dependency over
 	//test
 	//check that the picker is returning something in the range
@@ -168,11 +168,4 @@ public class RecommendationTest extends TestCase {
 			fail("Usage of reflection failed");
 		}
 	}
-
-	private static InstallableUnit createIU(String name, Version version) {
-		InstallableUnit iu = new InstallableUnit();
-		iu.setId(name);
-		iu.setVersion(version);
-		return iu;
-	}
 }
