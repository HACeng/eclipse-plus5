commit 976e79aa1c9468acbdcd05ae484db38f807a4287
Author: John Arthorne <johna>
Date:   Thu Apr 2 18:42:04 2009 +0000

    Bug 262333 A backup/restore mechanism is required during install

25	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
4	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/FoldersRepositoryTest.java
1	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AllTests.java
262	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/BackupTest.java
1	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/MetadataRepositoryManagerTest.java
2	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/AllTests.java
2	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/ChmodActionTest.java
16	5	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/CleanupzipActionTest.java
236	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/CopyActionTest.java
87	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/RemoveActionTest.java
14	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/RmdirActionTest.java
70	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/UnzipActionTest.java
2	0	bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/aFolder/a.txt
3	0	bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/aFolder/b.txt
2	0	bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/bcFolder/b.txt
2	0	bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/xFolder/x.txt
2	0	bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/xFolder/y.txt
33	0	bundles/org.eclipse.equinox.p2.touchpoint.natives/plugin.xml
712	0	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/BackupStore.java
24	0	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/ClosedBackupStoreException.java
105	0	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/IBackupStore.java
82	0	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/LazyBackupStore.java
33	0	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/Messages.java
58	2	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
104	6	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/Util.java
3	0	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/ActionConstants.java
102	0	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupcopyAction.java
32	11	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupzipAction.java
161	0	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CopyAction.java
29	5	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/LinkAction.java
12	3	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/MkdirAction.java
50	0	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/RemoveAction.java
24	4	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/RmdirAction.java
17	10	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/UnzipAction.java
33	2	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/messages.properties
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
index 02e691b..f5b9c54 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
@@ -907,6 +907,31 @@ public abstract class AbstractProvisioningTest extends TestCase {
 				assertTrue(message + ".3." + i, false);
 	}
 
+	/**
+	 * Asserts that the first line of text in f equals the content.
+	 * @param f
+	 * @param content
+	 */
+	public static void assertFileContent(String message, File f, String content) {
+		BufferedReader reader = null;
+		try {
+			reader = new BufferedReader(new InputStreamReader(new FileInputStream(f)));
+			String line = reader.readLine();
+			assertEquals(message, content, line);
+		} catch (FileNotFoundException e) {
+			fail("Getting copy target", e);
+		} catch (IOException e) {
+			fail("reading copy target", e);
+		} finally {
+			try {
+				if (reader != null)
+					reader.close();
+			} catch (IOException e) {
+				//ignore
+			}
+		}
+	}
+
 	protected IProvisioningEventBus getEventBus() {
 		IProvisioningEventBus bus = (IProvisioningEventBus) ServiceHelper.getService(TestActivator.getContext(), IProvisioningEventBus.SERVICE_NAME);
 		assertNotNull(bus);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/FoldersRepositoryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/FoldersRepositoryTest.java
index 24e10a3..ed92349 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/FoldersRepositoryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/FoldersRepositoryTest.java
@@ -27,6 +27,7 @@ public class FoldersRepositoryTest extends TestCase {
 
 	private ServiceReference managerRef;
 	private IArtifactRepositoryManager manager;
+	private File testRepo;
 
 	public FoldersRepositoryTest(String name) {
 		super(name);
@@ -44,11 +45,13 @@ public class FoldersRepositoryTest extends TestCase {
 	protected void tearDown() throws Exception {
 		manager = null;
 		TestActivator.getContext().ungetService(managerRef);
+		if (testRepo != null)
+			AbstractProvisioningTest.delete(testRepo);
 	}
 
 	public void testFolderRepository() throws Exception {
 		String tempDir = System.getProperty("java.io.tmpdir");
-		File testRepo = new File(tempDir, "testRepo");
+		testRepo = new File(tempDir, "testRepo");
 		AbstractProvisioningTest.delete(testRepo);
 		testRepo.mkdir();
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AllTests.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AllTests.java
index 5f817e4..296b16f 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AllTests.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AllTests.java
@@ -26,6 +26,7 @@ public class AllTests extends TestCase {
 		suite.addTestSuite(AggregateQueryTest.class);
 		suite.addTestSuite(CompoundQueryableTest.class);
 		suite.addTestSuite(URLUtilTest.class);
+		suite.addTestSuite(BackupTest.class);
 		return suite;
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/BackupTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/BackupTest.java
new file mode 100644
index 0000000..b22ad8a
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/BackupTest.java
@@ -0,0 +1,262 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.tests.core;
+
+import java.io.*;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.BackupStore;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
+
+public class BackupTest extends AbstractProvisioningTest {
+	private static final String BUPREFIX = "BackupTest";
+	private File sourceDir;
+	private File aDir;
+	private File aaDir;
+	private File bDir;
+	private File aTxt;
+	private File bTxt;
+
+	/**
+	 * Sets up directories and files under user.home
+	 * <ul><li>P2BUTEST/</li>
+	 *     <ul><li>A/</li>
+	 *         <ul><li>AA/</li>
+	 *             <ul><li>a.txt</li>
+	 *                 <li>b.txt</li>
+	 *             </ul>
+	 *         </ul>
+	 *         <li>B/</li>
+	 *     </ul>
+	 * </ul>
+	 */
+	public void setUp() {
+		// create some test files under user.home
+		// do not want them under /tmp as it may be on its own file system (and even 
+		// be an in-memory file system).
+		//
+		String userHome = System.getProperty("user.home");
+		sourceDir = new File(new File(userHome), "P2BUTEST");
+		aDir = new File(sourceDir, "A");
+		aDir.mkdirs();
+		aaDir = new File(aDir, "AA");
+		aaDir.mkdir();
+		bDir = new File(sourceDir, "B");
+		bDir.mkdirs();
+		aTxt = new File(aaDir, "a.txt");
+		bTxt = new File(aaDir, "b.txt");
+		try {
+			writeToFile(aTxt, "A\nA file with an A");
+			writeToFile(bTxt, "B\nA file with a B");
+		} catch (IOException e) {
+			fail();
+		}
+
+	}
+
+	private void writeToFile(File file, String content) throws IOException {
+		file.getParentFile().mkdirs();
+		file.createNewFile();
+		Writer writer = new BufferedWriter(new FileWriter(file));
+		try {
+			writer.write(content);
+		} finally {
+			writer.close();
+		}
+	}
+
+	public void tearDown() {
+		fullyDelete(sourceDir);
+	}
+
+	/**
+	 * Deletes a file, or a directory with all of it's children.
+	 * @param file the file or directory to fully delete
+	 * @return true if, and only if the file is deleted
+	 */
+	private boolean fullyDelete(File file) {
+		if (!file.exists())
+			return true;
+		if (file.isDirectory()) {
+			File[] children = file.listFiles();
+			for (int i = 0; i < children.length; i++)
+				if (!fullyDelete(new File(file, children[i].getName())))
+					return false;
+		}
+		return file.delete();
+	}
+
+	public void testBackupRestore() {
+		BackupStore store = new BackupStore(null, BUPREFIX);
+		// backup and overwrite a.txt
+		try {
+			store.backup(aTxt);
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("IO Exception when backing up aTxt");
+		}
+		if (aTxt.exists())
+			fail("File not moved to backup - still exists");
+		try {
+			writeToFile(aTxt, "XXXX\n- This file should be restored with A");
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("Could not write a file for testing purposes.");
+		}
+
+		// backup the empty B directory
+		try {
+			store.backup(bDir);
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("IO Exception when backing up bDir");
+		}
+		if (bDir.exists())
+			fail("Backed up directory was not moved");
+
+		// backup b as a copy
+		try {
+			store.backupCopy(bTxt);
+			assertFileContent("File should have been copied", bTxt, "B");
+		} catch (IOException e) {
+			fail("Could not backupCopy bTxt");
+		}
+
+		// restore
+		try {
+			store.restore();
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("Restore operation failed with IOException");
+		}
+
+		// assert restore
+		assertFileContent("Restore of A failed - not original content", aTxt, "A");
+		if (!bDir.isDirectory() && bDir.listFiles().length != 0)
+			fail("Empty directory not restored ok");
+
+		assertNoGarbage(store);
+	}
+
+	public void testBackupDiscard() {
+		BackupStore store = new BackupStore(null, BUPREFIX);
+		// backup and overwrite a.txt
+		try {
+			store.backup(aTxt);
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("IO Exception when backing up aTxt");
+		}
+		if (aTxt.exists())
+			fail("File not moved to backup - still exists");
+		try {
+			writeToFile(aTxt, "XXXX\n- This file should be restored with A");
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("Could not write a file for testing purposes.");
+		}
+
+		// backup the empty B directory
+		try {
+			store.backup(bDir);
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("IO Exception when backing up bDir");
+		}
+		if (bDir.exists())
+			fail("Backed up directory was not moved");
+
+		// restore
+		store.discard();
+
+		// assert discard
+		assertFileContent("Discard of A failed - not new content", aTxt, "XXXX");
+		if (bDir.isDirectory())
+			fail("Remove of empty directory not discarded ok");
+
+		assertNoGarbage(store);
+	}
+
+	public void testBackupAll() {
+		BackupStore store = new BackupStore(null, BUPREFIX);
+		// backup and overwrite a.txt
+		try {
+			store.backupAll(aDir);
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("IO Exception when backing up aDir");
+		}
+		if (aTxt.exists())
+			fail("File not moved to backup - still exists");
+		if (bTxt.exists())
+			fail("File bTxt not moved to backup - still exists");
+
+		try {
+			writeToFile(aTxt, "XXXX\n- This file should be restored with A");
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("Could not write a file for testing purposes.");
+		}
+		try {
+			store.restore();
+		} catch (IOException e) {
+			fail("Restore failed");
+		}
+		assertFileContent("A not restored", aTxt, "A");
+		assertFileContent("B not restored", bTxt, "B");
+		assertNoGarbage(store);
+	}
+
+	public void testBackupCopyAll() {
+		BackupStore store = new BackupStore(null, BUPREFIX);
+		// backup and overwrite a.txt
+		try {
+			store.backupCopyAll(aDir);
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("IO Exception when backing up aDir");
+		}
+		if (!aTxt.exists())
+			fail("File not copied to backup - does not exist");
+		if (!bTxt.exists())
+			fail("File bTxt not copied to backup - does not exists");
+
+		try {
+			writeToFile(aTxt, "XXXX\n- This file should be restored with A");
+			writeToFile(bTxt, "XXXX\n- This file should be restored with B");
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("Could not write a file for testing purposes.");
+		}
+		try {
+			store.restore();
+		} catch (IOException e) {
+			fail("Restore failed");
+		}
+		assertFileContent("A not restored", aTxt, "A");
+		assertFileContent("B not restored", bTxt, "B");
+		assertNoGarbage(store);
+	}
+
+	private void assertNoGarbage(BackupStore store) {
+		File buDir = new File(store.getBackupRoot(), BUPREFIX);
+		if (buDir.exists())
+			fail("Backup directory not cleaned up");
+
+		//		Set roots = store.getBackupRoots();
+		//		if (roots.size() == 0)
+		//			assertTrue("Root set is empty", true);
+		//		for (Iterator itor = roots.iterator(); itor.hasNext();) {
+		//			File root = (File) itor.next();
+		//			File buDir = new File(root, BUPREFIX);
+		//			if (buDir.exists())
+		//				fail("Backup directory not cleaned up");
+		//		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/MetadataRepositoryManagerTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/MetadataRepositoryManagerTest.java
index a9643db..bf60372 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/MetadataRepositoryManagerTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/MetadataRepositoryManagerTest.java
@@ -462,6 +462,7 @@ public class MetadataRepositoryManagerTest extends AbstractProvisioningTest {
 		File tempFile = new File(tempDir, "MetadataRepositoryManagerTest");
 		delete(tempFile);
 		assertTrue(!tempFile.exists());
+		toDelete.add(tempFile);
 		return tempFile;
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/AllTests.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/AllTests.java
index ab563b8..6d28690 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/AllTests.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/AllTests.java
@@ -27,6 +27,8 @@ public class AllTests extends TestCase {
 		suite.addTestSuite(NativeTouchpointTest.class);
 		suite.addTestSuite(RmdirActionTest.class);
 		suite.addTestSuite(UnzipActionTest.class);
+		suite.addTestSuite(CopyActionTest.class);
+		suite.addTestSuite(RemoveActionTest.class);
 		return suite;
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/ChmodActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/ChmodActionTest.java
index 0a7855f..7fe7636 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/ChmodActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/ChmodActionTest.java
@@ -33,7 +33,7 @@ public class ChmodActionTest extends AbstractProvisioningTest {
 		Properties profileProperties = new Properties();
 		File installFolder = getTempFolder();
 		profileProperties.setProperty(IProfile.PROP_INSTALL_FOLDER, installFolder.toString());
-		IProfile profile = createProfile("test", null, profileProperties);
+		IProfile profile = createProfile("testExecuteUndo", null, profileProperties);
 
 		File zipSource = getTestData("1.0", "/testData/nativeTouchpoint/a.zip");
 		File zipTarget = new File(installFolder, "a.zip");
@@ -47,7 +47,7 @@ public class ChmodActionTest extends AbstractProvisioningTest {
 		parameters.put(ActionConstants.PARM_PROFILE, profile);
 		parameters.put(InstallableUnitPhase.PARM_ARTIFACT_REQUESTS, new ArrayList());
 		NativeTouchpoint touchpoint = new NativeTouchpoint();
-		touchpoint.initializePhase(null, profile, "test", parameters);
+		touchpoint.initializePhase(null, profile, "testExecuteUndo", parameters);
 
 		parameters.put(ActionConstants.PARM_TARGET_DIR, installFolder.getAbsolutePath());
 		parameters.put(ActionConstants.PARM_TARGET_FILE, "a.zip");
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/CleanupzipActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/CleanupzipActionTest.java
index bc314bf..5c1be8b 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/CleanupzipActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/CleanupzipActionTest.java
@@ -12,6 +12,7 @@ package org.eclipse.equinox.p2.tests.touchpoint.natives;
 
 import java.io.File;
 import java.util.*;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.IBackupStore;
 import org.eclipse.equinox.internal.p2.touchpoint.natives.NativeTouchpoint;
 import org.eclipse.equinox.internal.p2.touchpoint.natives.actions.*;
 import org.eclipse.equinox.internal.provisional.p2.engine.*;
@@ -30,11 +31,20 @@ public class CleanupzipActionTest extends AbstractProvisioningTest {
 		super("");
 	}
 
+	IBackupStore store;
+
+	@Override
+	protected void tearDown() throws Exception {
+		super.tearDown();
+		if (store != null)
+			store.discard();
+	}
+
 	public void testExecuteUndo() {
 		Properties profileProperties = new Properties();
 		File installFolder = getTempFolder();
 		profileProperties.setProperty(IProfile.PROP_INSTALL_FOLDER, installFolder.toString());
-		IProfile profile = createProfile("test", null, profileProperties);
+		IProfile profile = createProfile("testExecuteUndo", null, profileProperties);
 
 		File zipSource = getTestData("1.0", "/testData/nativeTouchpoint/a.zip");
 		File zipTarget = new File(installFolder, "a.zip");
@@ -43,7 +53,7 @@ public class CleanupzipActionTest extends AbstractProvisioningTest {
 		InstallableUnitDescription iuDesc = new MetadataFactory.InstallableUnitDescription();
 		iuDesc.setId("test");
 		iuDesc.setVersion(DEFAULT_VERSION);
-		IArtifactKey key = PublisherHelper.createBinaryArtifactKey("test", DEFAULT_VERSION);
+		IArtifactKey key = PublisherHelper.createBinaryArtifactKey("testExecuteUndo", DEFAULT_VERSION);
 		iuDesc.setArtifacts(new IArtifactKey[] {key});
 		iuDesc.setTouchpointType(PublisherHelper.TOUCHPOINT_NATIVE);
 		IInstallableUnit iu = MetadataFactory.createInstallableUnit(iuDesc);
@@ -55,7 +65,8 @@ public class CleanupzipActionTest extends AbstractProvisioningTest {
 		parameters.put("iu", operand.second());
 		parameters.put(ActionConstants.PARM_OPERAND, operand);
 		NativeTouchpoint touchpoint = new NativeTouchpoint();
-		touchpoint.initializePhase(null, profile, "test", parameters);
+		touchpoint.initializePhase(null, profile, "testExecuteUndo", parameters);
+		store = (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP);
 
 		parameters.put(ActionConstants.PARM_SOURCE, zipTarget.getAbsolutePath());
 		parameters.put(ActionConstants.PARM_TARGET, installFolder.getAbsolutePath());
@@ -75,14 +86,13 @@ public class CleanupzipActionTest extends AbstractProvisioningTest {
 		action.undo(parameters);
 		assertTrue(aTxt.exists());
 		assertEquals(1, profile.getInstallableUnitProperties(iu).size());
-
 	}
 
 	public void testExecuteUndoWhereInstallFolderIsDifferent() {
 		Properties profileProperties = new Properties();
 		File installFolder = getTempFolder();
 		profileProperties.setProperty(IProfile.PROP_INSTALL_FOLDER, installFolder.toString());
-		IProfile profile = createProfile("test", null, profileProperties);
+		IProfile profile = createProfile("testExecuteUndoWhereInstallFolderIsDifferent", null, profileProperties);
 
 		File zipSource = getTestData("1.0", "/testData/nativeTouchpoint/a.zip");
 		File zipTarget = new File(installFolder, "a.zip");
@@ -104,6 +114,7 @@ public class CleanupzipActionTest extends AbstractProvisioningTest {
 		parameters.put(ActionConstants.PARM_OPERAND, operand);
 		NativeTouchpoint touchpoint = new NativeTouchpoint();
 		touchpoint.initializePhase(null, profile, "test", parameters);
+		store = (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP);
 
 		parameters.put(ActionConstants.PARM_SOURCE, zipTarget.getAbsolutePath());
 		parameters.put(ActionConstants.PARM_TARGET, installFolder.getAbsolutePath());
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/CopyActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/CopyActionTest.java
new file mode 100644
index 0000000..62f0d81
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/CopyActionTest.java
@@ -0,0 +1,236 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.tests.touchpoint.natives;
+
+import java.io.File;
+import java.util.*;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.NativeTouchpoint;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.actions.ActionConstants;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.actions.CopyAction;
+import org.eclipse.equinox.internal.provisional.p2.engine.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
+import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;
+
+public class CopyActionTest extends AbstractProvisioningTest {
+
+	public CopyActionTest(String name) {
+		super(name);
+	}
+
+	public CopyActionTest() {
+		super("");
+	}
+
+	public void testExecuteUndo() {
+		Map parameters = createParameters("/testData/nativeTouchpoint/aFolder/a.txt", "a.txt", false);
+		Map safeParameters = Collections.unmodifiableMap(parameters);
+
+		CopyAction action = new CopyAction();
+		action.execute(safeParameters);
+
+		// Verify that the right file was copied
+		File target = new File((String) parameters.get(ActionConstants.PARM_COPY_TARGET));
+		assertFileContent("copied content", target, "A");
+
+		// does nothing so should not alter parameters
+		action.undo(safeParameters);
+		assertFalse("Target should be removed after undo", target.exists());
+	}
+
+	public void testCopyDirectory() {
+		Map parameters = createParameters("/testData/nativeTouchpoint/aFolder/", "aFolder", false);
+		Map safeParameters = Collections.unmodifiableMap(parameters);
+
+		CopyAction action = new CopyAction();
+		action.execute(safeParameters);
+
+		// Verify that the right files was copied
+		File target = new File((String) parameters.get(ActionConstants.PARM_COPY_TARGET));
+		assertFileContent("copied content A", new File(target, "a.txt"), "A");
+		assertFileContent("copied content B", new File(target, "b.txt"), "B");
+
+		// does nothing so should not alter parameters
+		action.undo(safeParameters);
+		assertFalse("Target should be removed after undo", target.exists());
+	}
+
+	public void testMergeDirectory() {
+		Map parameters1 = createParameters("/testData/nativeTouchpoint/xFolder/", "aFolder", true);
+		Map safeParameters1 = Collections.unmodifiableMap(parameters1);
+
+		CopyAction action1 = new CopyAction();
+		action1.execute(safeParameters1);
+
+		// Verify that the right files was copied
+		File target = new File((String) parameters1.get(ActionConstants.PARM_COPY_TARGET));
+		assertFileContent("copied content X", new File(target, "x.txt"), "X");
+		assertFileContent("copied content Y", new File(target, "y.txt"), "Y");
+
+		Map parameters2 = new HashMap();
+		parameters2.putAll(parameters1);
+		parameters2.put(ActionConstants.PARM_COPY_SOURCE, getTestData("get folder A", "/testData/nativeTouchpoint/aFolder/").getAbsolutePath());
+		Map safeParameters2 = Collections.unmodifiableMap(parameters2);
+
+		CopyAction action2 = new CopyAction();
+		action2.execute(safeParameters2);
+		assertFileContent("copied content A", new File(target, "a.txt"), "A");
+		assertFileContent("copied content B", new File(target, "b.txt"), "B");
+
+		// undo copy of x and y
+		action1.undo(safeParameters1);
+		assertTrue("Target should exist after undo", target.exists());
+		File tmp = new File(target, "x.txt");
+		assertFalse("File x should not exist", tmp.exists());
+		tmp = new File(target, "y.txt");
+		assertFalse("File y should not exist", tmp.exists());
+		assertFileContent("copied content A", new File(target, "a.txt"), "A");
+		assertFileContent("copied content B", new File(target, "b.txt"), "B");
+
+		// undo copy of a and b
+		action2.undo(safeParameters2);
+		assertFalse("Target should not exist after undo", target.exists());
+	}
+
+	public void testMergeOverwrite() {
+		Map parameters1 = createParameters("/testData/nativeTouchpoint/bcFolder/", "aFolder", true);
+		Map safeParameters1 = Collections.unmodifiableMap(parameters1);
+
+		CopyAction action1 = new CopyAction();
+		action1.execute(safeParameters1);
+
+		// Verify that the right file was copied (a b.txt with a C in it [sic])
+		File target = new File((String) parameters1.get(ActionConstants.PARM_COPY_TARGET));
+		assertFileContent("copied content C", new File(target, "b.txt"), "C"); // [sic]
+
+		Map parameters2 = new HashMap();
+		parameters2.putAll(parameters1);
+		parameters2.put(ActionConstants.PARM_COPY_SOURCE, getTestData("get folder A", "/testData/nativeTouchpoint/aFolder/").getAbsolutePath());
+		Map safeParameters2 = Collections.unmodifiableMap(parameters2);
+
+		CopyAction action2 = new CopyAction();
+		action2.execute(safeParameters2);
+		assertFileContent("copied content A", new File(target, "a.txt"), "A");
+		assertFileContent("copied content B", new File(target, "b.txt"), "B");
+
+		// undo copy of a and b
+		action2.undo(safeParameters2);
+		assertFalse("Target should not exist after undo", target.exists());
+	}
+
+	public void testBlockedMergeOverwrite() {
+		Map parameters1 = createParameters("/testData/nativeTouchpoint/bcFolder/", "aFolder", false);
+		Map safeParameters1 = Collections.unmodifiableMap(parameters1);
+
+		CopyAction action1 = new CopyAction();
+		action1.execute(safeParameters1);
+
+		// Verify that the right file was copied (a b.txt with a C in it [sic])
+		File target = new File((String) parameters1.get(ActionConstants.PARM_COPY_TARGET));
+		assertFileContent("copied content B", new File(target, "b.txt"), "C"); // [sic]
+
+		Map parameters2 = new HashMap();
+		parameters2.putAll(parameters1);
+		parameters2.put(ActionConstants.PARM_COPY_SOURCE, getTestData("get folder A", "/testData/nativeTouchpoint/aFolder/").getAbsolutePath());
+		Map safeParameters2 = Collections.unmodifiableMap(parameters2);
+
+		CopyAction action2 = new CopyAction();
+		assertFalse("Overwrite of b.txt should not succeed", action2.execute(safeParameters2).isOK());
+		assertFileContent("copied content B", new File(target, "b.txt"), "C"); // [sic]
+
+	}
+
+	public void testOverwrite() {
+		Map parameters = createParameters("/testData/nativeTouchpoint/aFolder/a.txt", "a.txt", true);
+		Map safeParameters = Collections.unmodifiableMap(parameters);
+
+		File source = new File((String) parameters.get(ActionConstants.PARM_COPY_SOURCE));
+		File target = new File((String) parameters.get(ActionConstants.PARM_COPY_TARGET));
+
+		// test an overwrite - by first copying the b file
+		copy("2.0", getTestData("1.0", "/testData/nativeTouchpoint/aFolder/b.txt"), target);
+
+		CopyAction action = new CopyAction();
+		action.execute(safeParameters);
+		// Verify that the right file was copied
+		assertFileContent("copied content", target, "A");
+		// and that we did nothing bad to the source
+		assertFileContent("source content", source, "A");
+
+		assertTrue("copy action status", action.undo(safeParameters).isOK());
+		assertFalse("Target should be removed after undo", target.exists());
+	}
+
+	public void testBlockedOverwrite() {
+		Map parameters = createParameters("/testData/nativeTouchpoint/aFolder/a.txt", "a.txt", false);
+		Map safeParameters = Collections.unmodifiableMap(parameters);
+
+		File source = new File((String) parameters.get(ActionConstants.PARM_COPY_SOURCE));
+		File target = new File((String) parameters.get(ActionConstants.PARM_COPY_TARGET));
+
+		// test an overwrite - by first copying the b file
+		copy("2.0", getTestData("1.0", "/testData/nativeTouchpoint/aFolder/b.txt"), target);
+
+		CopyAction action = new CopyAction();
+		assertFalse("copy action status", action.execute(safeParameters).isOK());
+
+		// Verify that nothing was copied
+		assertFileContent("original content", target, "B");
+		// and that we did nothing bad to the source
+		assertFileContent("source content", source, "A");
+
+		// there is nothing to undo - the B file should still be there
+		action.undo(safeParameters);
+		assertTrue("Target should remain after undo", target.exists());
+		assertFileContent("original content", target, "B");
+	}
+
+	/*
+	 * TODO: testing of the following
+	 * - copy of directory - check that it merges
+	 * - copy of directory with overwrite false/true
+	 */
+	private Map createParameters(String sourceName, String targetName, boolean overwrite) {
+		Properties profileProperties = new Properties();
+		File installFolder = getTempFolder();
+		profileProperties.setProperty(IProfile.PROP_INSTALL_FOLDER, installFolder.toString());
+		IProfile profile = createProfile("test", null, profileProperties);
+
+		File source = getTestData("1.0", sourceName);
+		File target = new File(installFolder, targetName);
+
+		InstallableUnitDescription iuDesc = new MetadataFactory.InstallableUnitDescription();
+		iuDesc.setId("test");
+		iuDesc.setVersion(DEFAULT_VERSION);
+		IArtifactKey key = PublisherHelper.createBinaryArtifactKey("test", DEFAULT_VERSION);
+		iuDesc.setArtifacts(new IArtifactKey[] {key});
+		iuDesc.setTouchpointType(PublisherHelper.TOUCHPOINT_NATIVE);
+		IInstallableUnit iu = MetadataFactory.createInstallableUnit(iuDesc);
+
+		Map parameters = new HashMap();
+		parameters.put(ActionConstants.PARM_PROFILE, profile);
+		parameters.put(InstallableUnitPhase.PARM_ARTIFACT_REQUESTS, new ArrayList());
+		InstallableUnitOperand operand = new InstallableUnitOperand(null, iu);
+		parameters.put("iu", operand.second());
+		parameters.put(ActionConstants.PARM_OPERAND, operand);
+		parameters.put(ActionConstants.PARM_PROFILE, profile);
+
+		NativeTouchpoint touchpoint = new NativeTouchpoint();
+		touchpoint.initializePhase(null, profile, "test", parameters);
+
+		parameters.put(ActionConstants.PARM_COPY_SOURCE, source.getAbsolutePath());
+		parameters.put(ActionConstants.PARM_COPY_TARGET, target.getAbsolutePath());
+		parameters.put(ActionConstants.PARM_COPY_OVERWRITE, Boolean.toString(overwrite));
+		return parameters;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/RemoveActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/RemoveActionTest.java
new file mode 100644
index 0000000..1191675
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/RemoveActionTest.java
@@ -0,0 +1,87 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.touchpoint.natives;
+
+import java.io.*;
+import java.util.*;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.IBackupStore;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.NativeTouchpoint;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.actions.ActionConstants;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.actions.RemoveAction;
+import org.eclipse.equinox.internal.provisional.p2.engine.IProfile;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
+
+public class RemoveActionTest extends AbstractProvisioningTest {
+
+	public RemoveActionTest(String name) {
+		super(name);
+	}
+
+	public RemoveActionTest() {
+		super("");
+	}
+
+	public void testExecuteUndo() {
+		Properties profileProperties = new Properties();
+		File installFolder = getTempFolder();
+		profileProperties.setProperty(IProfile.PROP_INSTALL_FOLDER, installFolder.toString());
+		IProfile profile = createProfile("testExecuteUndo", null, profileProperties);
+
+		Map parameters = new HashMap();
+		parameters.put(ActionConstants.PARM_PROFILE, profile);
+		NativeTouchpoint touchpoint = new NativeTouchpoint();
+		touchpoint.initializePhase(null, profile, "testExecuteUndo", parameters);
+
+		File testFolder = new File(installFolder, "testExecuteUndo");
+		File testFile = new File(testFolder, "data.txt");
+
+		parameters.put(ActionConstants.PARM_PATH, testFolder.getAbsolutePath());
+		parameters = Collections.unmodifiableMap(parameters);
+
+		testFolder.mkdir();
+		assertTrue(testFolder.exists());
+		try {
+			writeToFile(testFile, "AA\nTestfile with AA on first line.");
+		} catch (IOException e1) {
+			fail("Could not write test data to test file");
+		}
+		assertFileContent("Should contain AA", testFile, "AA");
+
+		RemoveAction action = new RemoveAction();
+		action.execute(parameters);
+		assertFalse(testFolder.exists());
+		assertFalse(testFile.exists());
+
+		action.undo(parameters);
+		IBackupStore store = (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP);
+		if (store != null)
+			try {
+				store.restore();
+			} catch (IOException e) {
+				fail("Restore of backup failed");
+			}
+		assertTrue(testFolder.exists());
+		assertFileContent("Should contain AA", testFile, "AA");
+		if (store != null)
+			store.discard();
+	}
+
+	private static void writeToFile(File file, String content) throws IOException {
+		file.getParentFile().mkdirs();
+		file.createNewFile();
+		FileWriter writer = new FileWriter(file);
+		BufferedWriter out = new BufferedWriter(writer);
+		out.write(content);
+		out.close();
+	}
+
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/RmdirActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/RmdirActionTest.java
index a1168a7..b27713f 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/RmdirActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/RmdirActionTest.java
@@ -9,7 +9,9 @@
 package org.eclipse.equinox.p2.tests.touchpoint.natives;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.*;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.IBackupStore;
 import org.eclipse.equinox.internal.p2.touchpoint.natives.NativeTouchpoint;
 import org.eclipse.equinox.internal.p2.touchpoint.natives.actions.ActionConstants;
 import org.eclipse.equinox.internal.p2.touchpoint.natives.actions.RmdirAction;
@@ -30,14 +32,14 @@ public class RmdirActionTest extends AbstractProvisioningTest {
 		Properties profileProperties = new Properties();
 		File installFolder = getTempFolder();
 		profileProperties.setProperty(IProfile.PROP_INSTALL_FOLDER, installFolder.toString());
-		IProfile profile = createProfile("test", null, profileProperties);
+		IProfile profile = createProfile("testExecuteUndo", null, profileProperties);
 
 		Map parameters = new HashMap();
 		parameters.put(ActionConstants.PARM_PROFILE, profile);
 		NativeTouchpoint touchpoint = new NativeTouchpoint();
-		touchpoint.initializePhase(null, profile, "test", parameters);
+		touchpoint.initializePhase(null, profile, "testExecuteUndo", parameters);
 
-		File testFolder = new File(installFolder, "test");
+		File testFolder = new File(installFolder, "testExecuteUndo");
 
 		parameters.put(ActionConstants.PARM_PATH, testFolder.getAbsolutePath());
 		parameters = Collections.unmodifiableMap(parameters);
@@ -50,6 +52,15 @@ public class RmdirActionTest extends AbstractProvisioningTest {
 		assertFalse(testFolder.exists());
 
 		action.undo(parameters);
+		IBackupStore store = (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP);
+		if (store != null)
+			try {
+				store.restore();
+			} catch (IOException e) {
+				fail("Restore of backup failed");
+			}
 		assertTrue(testFolder.exists());
+		if (store != null)
+			store.discard();
 	}
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/UnzipActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/UnzipActionTest.java
index cb34394..af47dd9 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/UnzipActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/natives/UnzipActionTest.java
@@ -8,8 +8,9 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.touchpoint.natives;
 
-import java.io.File;
+import java.io.*;
 import java.util.*;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.IBackupStore;
 import org.eclipse.equinox.internal.p2.touchpoint.natives.NativeTouchpoint;
 import org.eclipse.equinox.internal.p2.touchpoint.natives.actions.ActionConstants;
 import org.eclipse.equinox.internal.p2.touchpoint.natives.actions.UnzipAction;
@@ -21,14 +22,23 @@ import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;
 
 public class UnzipActionTest extends AbstractProvisioningTest {
 
-	public UnzipActionTest(String name) {
-		super(name);
+	private static void writeToFile(File file, String content) throws IOException {
+		file.getParentFile().mkdirs();
+		file.createNewFile();
+		FileWriter writer = new FileWriter(file);
+		BufferedWriter out = new BufferedWriter(writer);
+		out.write(content);
+		out.close();
 	}
 
 	public UnzipActionTest() {
 		super("");
 	}
 
+	public UnzipActionTest(String name) {
+		super(name);
+	}
+
 	public void testExecuteUndo() {
 		Properties profileProperties = new Properties();
 		File installFolder = getTempFolder();
@@ -73,4 +83,61 @@ public class UnzipActionTest extends AbstractProvisioningTest {
 		assertFalse(aTxt.exists());
 	}
 
+	public void testExecuteUndoBackup() {
+		Properties profileProperties = new Properties();
+		File installFolder = getTempFolder();
+		profileProperties.setProperty(IProfile.PROP_INSTALL_FOLDER, installFolder.toString());
+		IProfile profile = createProfile("testExecuteUndoBackup", null, profileProperties);
+
+		File zipSource = getTestData("1.0", "/testData/nativeTouchpoint/a.zip");
+		File zipTarget = new File(installFolder, "a.zip");
+		copy("2.0", zipSource, zipTarget);
+
+		InstallableUnitDescription iuDesc = new MetadataFactory.InstallableUnitDescription();
+		iuDesc.setId("testExecuteUndoBackup");
+		iuDesc.setVersion(DEFAULT_VERSION);
+		IArtifactKey key = PublisherHelper.createBinaryArtifactKey("testExecuteUndoBackup", DEFAULT_VERSION);
+		iuDesc.setArtifacts(new IArtifactKey[] {key});
+		iuDesc.setTouchpointType(PublisherHelper.TOUCHPOINT_NATIVE);
+		IInstallableUnit iu = MetadataFactory.createInstallableUnit(iuDesc);
+
+		Map parameters = new HashMap();
+		parameters.put(ActionConstants.PARM_PROFILE, profile);
+		parameters.put(InstallableUnitPhase.PARM_ARTIFACT_REQUESTS, new ArrayList());
+		InstallableUnitOperand operand = new InstallableUnitOperand(null, iu);
+		parameters.put("iu", operand.second());
+		parameters.put(ActionConstants.PARM_OPERAND, operand);
+		parameters.put(ActionConstants.PARM_PROFILE, profile);
+		parameters.put(InstallableUnitPhase.PARM_ARTIFACT_REQUESTS, new ArrayList());
+		NativeTouchpoint touchpoint = new NativeTouchpoint();
+		touchpoint.initializePhase(null, profile, "testExecuteUndoBackup", parameters);
+
+		parameters.put(ActionConstants.PARM_SOURCE, zipTarget.getAbsolutePath());
+		parameters.put(ActionConstants.PARM_TARGET, installFolder.getAbsolutePath());
+		parameters = Collections.unmodifiableMap(parameters);
+
+		File aTxt = new File(installFolder, "a.txt");
+		try {
+			writeToFile(aTxt, "ORIGINAL-A");
+		} catch (IOException e) {
+			fail("Can not write to aTxt");
+		}
+		assertTrue(aTxt.exists());
+
+		UnzipAction action = new UnzipAction();
+		action.execute(parameters);
+		assertTrue(aTxt.exists());
+		assertFileContent("Should contain text 'nothing'", aTxt, "nothing");
+		// does nothing so should not alter parameters
+		action.undo(parameters);
+		IBackupStore backup = (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP);
+		try {
+			backup.restore();
+		} catch (IOException e) {
+			fail("Restore of backup failed", e);
+		}
+		assertFileContent("Should contain text 'ORIGINAL-A'", aTxt, "ORIGINAL-A");
+
+		backup.discard();
+	}
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/aFolder/a.txt b/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/aFolder/a.txt
new file mode 100644
index 0000000..c78a316
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/aFolder/a.txt
@@ -0,0 +1,2 @@
+A
+// This a.txt should have the first line being a single A
diff --git a/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/aFolder/b.txt b/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/aFolder/b.txt
new file mode 100644
index 0000000..36dcd28
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/aFolder/b.txt
@@ -0,0 +1,3 @@
+B
+// This b.txt should have the first line being a single B
+
diff --git a/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/bcFolder/b.txt b/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/bcFolder/b.txt
new file mode 100644
index 0000000..a6ed197
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/bcFolder/b.txt
@@ -0,0 +1,2 @@
+C
+// This b.txt should have the first line being a single C
diff --git a/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/xFolder/x.txt b/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/xFolder/x.txt
new file mode 100644
index 0000000..7779c7b
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/xFolder/x.txt
@@ -0,0 +1,2 @@
+X
+// This x.txt should have the first line being a single X
diff --git a/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/xFolder/y.txt b/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/xFolder/y.txt
new file mode 100644
index 0000000..4ff6bdb
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/testData/nativeTouchpoint/xFolder/y.txt
@@ -0,0 +1,2 @@
+Y
+// This y.txt should have the first line being a single Y
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/plugin.xml b/bundles/org.eclipse.equinox.p2.touchpoint.natives/plugin.xml
index 44df1af..690324f 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/plugin.xml
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/plugin.xml
@@ -75,4 +75,37 @@
           version="1.0.0">
     </action>
  </extension>
+ <extension
+       point="org.eclipse.equinox.p2.engine.actions">
+    <action
+          class="org.eclipse.equinox.internal.p2.touchpoint.natives.actions.CopyAction"
+          description="copy(source,target[,overwrite])"
+          name="copy"
+          touchpointType="org.eclipse.equinox.p2.native"
+          touchpointVersion="1.0.0"
+          version="1.0.0">
+    </action>
+ </extension>
+ <extension
+       point="org.eclipse.equinox.p2.engine.actions">
+    <action
+          class="org.eclipse.equinox.internal.p2.touchpoint.natives.actions.CleanupcopyAction"
+          description="cleanupcopy(source,target)"
+          name="cleanupcopy"
+          touchpointType="org.eclipse.equinox.p2.native"
+          touchpointVersion="1.0.0"
+          version="1.0.0">
+    </action>
+ </extension>
+ <extension
+       point="org.eclipse.equinox.p2.engine.actions">
+    <action
+          class="org.eclipse.equinox.internal.p2.touchpoint.natives.actions.RemoveAction"
+          description="remove(path)"
+          name="remove"
+          touchpointType="org.eclipse.equinox.p2.native"
+          touchpointVersion="1.0.0"
+          version="1.0.0">
+    </action>
+ </extension>
 </plugin>
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/BackupStore.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/BackupStore.java
new file mode 100644
index 0000000..bc5580c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/BackupStore.java
@@ -0,0 +1,712 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.internal.p2.touchpoint.natives;
+
+import java.io.*;
+import java.net.*;
+import java.util.*;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * Stores files by copying them to a uniquely named temporary directory.
+ * The BackupStore remembers filenames and can recreate them in their original location.
+ * 
+ * <h3>Usage</h3>
+ * The user of this class should instantiate the BackupStore with some prefix that is 
+ * meaningful to a human. Uniqueness is obtained without the prefix - the prefix is used to 
+ * be able to differentiate between different backup directories by a human (in case of crashes etc).
+ * 
+ * If instantiated with a directory this directory will be used to store the backup root directory. If
+ * this directory is null, the users home directory is used by default.
+ * 
+ * Once instantiated, use the {@link #backup(File)} and {@link #backupDirectory(File)} methods
+ * to move files to backup instead of deleting them. A file that
+ * is backed up should not be deleted - it is simply moved out of the way. 
+ * Use {@link #backupCopy(File)} to
+ * move the file out of harms way, but keep a copy of it in the original location.
+ * The methods {@link #backupAll(File)} and {@link #backupCopyAll(File)} backs up an entire structure.
+ * 
+ * When backup is finished - the user should either call {@link #restore()} to put all 
+ * of the files back, or call {@link #discard()} to remove all of the backed up "copies".
+ * 
+ * If {@link #restore()} or {@link #discard()} is not called the backup files will never be deleted.
+ * 
+ * The backup store does not synchronize directories - actions that write new files are
+ * responsible for removing them. Overwriting existing files should be done by first backing
+ * up the file, and then creating a new file. Modifying a file, should be done by 
+ * using {@link #backupCopy(File)} or 
+ * first making a copy, then backing up the original, and then renaming the copy.
+ *  
+ * <h3>Read Only and Permissions</h3>
+ * Directories that are read only (to current user) can not be backed up.
+ * Backup is performed using {@link File#renameTo(File)} and handling of permissions
+ * is operating system dependent. It is expected that a Un*x type system retains the
+ * permissions as a file is moved to the backup store and later gets restored.
+ * Backup directories are created as they are needed and will (at least on Un*x) inherit the
+ * permissions from its parent directory. 
+ * 
+ * If a rename can not be performed, the backup store will make a copy and delete the original
+ * file. This makes it possible to backup and restore across volume boundaries.
+ * 
+ * When restoring directories they
+ * will be created with permissions in a platform specific way (on UN*IX they will inherit the permissions 
+ * of the parent directory).
+ * 
+ * <h3>Checkpointing</h3> 
+ * Checkpointing (i.e. to be able to rollback to a particular point) can be implemented by using
+ * multiple instances of BackupStore. The client code will need to remember the individual order
+ * among the backup stores.
+ * 
+ * <h3>Restartability</h3>
+ * Not implemented - it is possible to obtain the name of the backup directories,
+ * so manual restore is possible after a crash. An idea is to add persistence to a file, and
+ * be able to read it back in again.
+ * 
+ * <h3>A note about exceptions</h3>
+ * In general {@link IllegalArgumentException} is thrown when attempting an operation
+ * that is considered "wrong use", and an {@link IllegalStateException} or subclass thereof is thrown on an overall
+ * wrong use of BackupStore (i.e. attempt to backup when store has been restored). Some cases of
+ * "wrong use" can not be differentiated from I/O errors (like a "file not found" as this could
+ * be caused by an entire disk disappearing - in these case an {@link IOException} is thrown.
+ * 
+ * <h3>Implementation Note</h3>
+ * The backup root directory will contain folders that reflects file system roots. These are encoded using 
+ * "_" for the UNI*X root directory, "__" for a Windows network mounted directory, and single "drive letter" folders
+ * corresponding to Windows drive letters. Typically, on UN*X there will only be a "_" directory in the backup root,
+ * and on windows there will typically be a single directory called "C".
+ * 
+ * @author henrik.lindberg@cloudsmith.com
+ *
+ */
+public class BackupStore implements IBackupStore {
+
+	/**
+	 * The name to use for a directory that represents leading separator (i.e. "/" or "\").
+	 */
+	private static final String ROOTCHAR = "_"; //$NON-NLS-1$
+
+	/**
+	 * Map of directory File to backup root (File) - the backup root has 
+	 * a directory named {@link #backupName} where the backup is found.
+	 */
+	//private Map backups = new HashMap();
+	private final File backupRoot;
+
+	/**
+	 * The name of the backup directory (no path - relative to the backup root).
+	 */
+	private String backupName;
+
+	/**
+	 * The name of a dummy file used to backup empty directories
+	 */
+	private String dummyName;
+
+	/**
+	 * A server socket that is used to obtain a port (a shared resource on this machine)
+	 * and thus create a unique number. Used as part of the unique id of backup directories
+	 * and probe files.
+	 */
+	private ServerSocket socket = null;
+
+	/**
+	 * Counter of how many files where backed up. Used as a simple check mechanism if
+	 * everything was restored (a guard against manual/external tampering with the backup directories).
+	 */
+	private long backupCounter;
+
+	/**
+	 * Counter of how many files where restored. See {@link #backupCounter}.
+	 */
+	private long restoreCounter;
+
+	/**
+	 * Flag indicating if this BackupStore has been restored or canceled.
+	 */
+	private boolean closed;
+
+	/**
+	 * Generates a BackupStore with a default prefix of ".p2bu" for backup directory and
+	 * probe file. 
+	 * The full id of the store is on the format "prefix_hextime_hexIPport" 
+	 * - see {@link #genUnique()} for more info.
+	 */
+	public BackupStore() {
+		this(null, ".p2bu"); //$NON-NLS-1$
+	}
+
+	/**
+	 * Generates a BackupStore with a specified prefix for backup directories and
+	 * probe file.
+	 * The full id of the store is on the format "prefix_hextime_hexipport" 
+	 * - see {@link #genUnique()} for more info.
+	 * 
+	 * @param buParentDirectory - name of directory where the backup directory should be created - if null, java.io.tmpdir is used
+	 * @param prefix - prefix used for human identification of backup directories
+	 */
+	public BackupStore(File buParentDirectory, String prefix) {
+		if (buParentDirectory == null)
+			buParentDirectory = new File(System.getProperty("java.io.tmpdir")); //$NON-NLS-1$
+		backupRoot = buParentDirectory;
+
+		// generate a name for the backup store and the dummy file used for empty directories
+		String unique = genUnique();
+		dummyName = prefix + "d_" + unique; //$NON-NLS-1$
+		backupName = prefix + "_" + unique; //$NON-NLS-1$
+		backupCounter = 0;
+		restoreCounter = 0;
+		closed = false;
+	}
+
+	/**
+	 * Since a socket port is used to create a unique number, the socket
+	 * must be closed if this instance is garbage collected and the user
+	 * of the instance has not either restored or discarded.
+	 */
+	protected void finalize() throws Throwable {
+		try {
+			if (socket != null && !socket.isClosed())
+				socket.close();
+		} finally {
+			super.finalize();
+		}
+	}
+
+	/**
+	 * Returns the unique backup name (this is the name of generated backup directories).
+	 * @return the backup name.
+	 */
+	public String getBackupName() {
+		return backupName;
+	}
+
+	public File getBackupRoot() {
+		return backupRoot;
+	}
+
+	/**
+	 * Backup the file by moving it to the backup store (for later (optional) restore).
+	 * Calling this method with a file that represents a directory is equivalent to calling 
+	 * {@link #backupDirectory(File)}.
+	 * 
+	 * A file (path) can only be backed up once per BackupStore instance.
+	 * When the file is backed up, it is moved to a directory under this BackupStore instance's directory 
+	 * with a relative path corresponding to the original relative path from the backup root e.g.
+	 * the file /A/B/C/foo.txt could be moved to /A/.p2bu_ffffff_ffffff/B/C/foo.txt when /A is the
+	 * backup root.
+	 * 
+	 * If a directory is first backed up, and later replaced by a regular file, and this file
+	 * is backed up (or vice versa) - an {@link IllegalArgumentException} is thrown
+	 * 
+	 * A backup can not be performed on a closed BackupStore. 
+	 * 
+	 * @param file - the file (or directory) to backup
+	 * @return true if the file was backed up, false if this file (path) has already been backed up (the file is not moved to the store).
+	 * @throws IOException - if the backup operation fails, or the file does not exist
+	 * @throws ClosedBackupStoreException - if the BackupStore has been closed
+	 * @throws IllegalArgumentException - on type mismatch (file vs. directory) of earlier backup, or if file does not exist 
+	 */
+	public boolean backup(File file) throws IOException {
+		if (closed)
+			throw new ClosedBackupStoreException("Can not perform backup()"); //$NON-NLS-1$
+		if (!file.exists())
+			throw new IOException(NLS.bind(Messages.BackupStore_file_not_found, file.getAbsolutePath()));
+		if (file.isDirectory())
+			return backupDirectory(file);
+
+		File buRoot = backupRoot;
+		// File buRoot = findBackupRoot(file);
+		File buDir = new File(buRoot, backupName);
+		// move the file
+		// create the relative path from root and use that in buDir
+		File buFile = new File(buDir, makeRelativeFromRoot(file).getPath());
+		// already backed up, but was a directory = wrong usage
+		if (buFile.isDirectory())
+			throw new IllegalArgumentException(NLS.bind(Messages.BackupStore_directory_file_mismatch, buFile.getAbsolutePath()));
+		// has already been backed up - can only be done once with one BackupStore
+		if (buFile.exists())
+			return false;
+
+		// make sure all of the directories exist / gets created
+		buFile.getParentFile().mkdirs();
+		if (buFile.getParentFile().exists() && !buFile.getParentFile().isDirectory())
+			throw new IllegalArgumentException(NLS.bind(Messages.BackupStore_file_directory_mismatch, buFile.getParentFile().getAbsolutePath()));
+		if (file.renameTo(buFile)) {
+			backupCounter++;
+			return true;
+		}
+		// could not move - this can happen because source and target are on different volumes, or
+		// that source is locked "in use" on a windows machine. The copy will work across volumes,
+		// but the locked file will fail on the subsequent delete.
+		//
+		Util.copyStream(new FileInputStream(file), true, new FileOutputStream(buFile), true);
+		backupCounter++;
+
+		// need to remove the backed up file
+		if (!file.delete())
+			throw new IOException(NLS.bind(Messages.BackupStore_can_not_delete_after_copy_0, file));
+
+		return true;
+	}
+
+	/**
+	 * Backs up a file, or everything under a directory.
+	 * 
+	 * @param file - file to backup or directory
+	 * @throws IOException if backup operation failed
+	 */
+	public void backupAll(File file) throws IOException {
+		if (!file.exists())
+			return;
+		if (file.isDirectory()) {
+			File[] files = file.listFiles();
+			if (files != null)
+				for (int i = 0; i < files.length; i++)
+					backupAll(files[i]);
+		}
+		backup(file);
+	}
+
+	/**
+	 * Backs up a file, or everything under a directory.
+	 * A copy of the backup is left in the original place.
+	 * @param file
+	 * @throws IOException
+	 */
+	public void backupCopyAll(File file) throws IOException {
+		if (!file.exists())
+			return;
+		if (file.isDirectory()) {
+			File[] files = file.listFiles();
+			if (files != null)
+				for (int i = 0; i < files.length; i++)
+					backupCopyAll(files[i]);
+			// if directory was empty, it needs to be backed up and then recreated
+			//
+			if (files == null || files.length == 0) {
+				backupDirectory(file);
+				file.mkdir();
+			}
+		} else
+			backupCopy(file);
+	}
+
+	/**
+	 * Backup the file by moving it to the backup store (for later (optional) restore) but leaving
+	 * a copy of the contents in the original location.
+	 * Calling this method with a file that represents a directory throws an {@link IllegalArgumentException}.
+	 * 
+	 * A file (path) can only be backed up once per BackupStore instance.
+	 * When the file is backed up, it is moved to a directory under this BackupStore instance's directory 
+	 * with a relative path corresponding to the original relative path from the backup root e.g.
+	 * the file /A/B/C/foo.txt could be moved to /A/.p2bu_ffffff_ffffff/B/C/foo.txt when /A is the
+	 * backup root.
+	 * 
+	 * If a directory is first backed up, and later replaced by a regular file, and this file
+	 * is backed up (or vice versa) - an {@link IllegalArgumentException} is thrown
+	 * 
+	 * A backup can not be performed on a closed BackupStore. 
+	 * 
+	 * @param file - the file (or directory) to backup
+	 * @return true if the file was backed up, false if this file (path) has already been backed up (the file is not moved to the store).
+	 * @throws IOException - if the backup operation fails, or the file does not exist
+	 * @throws ClosedBackupStoreException - if the BackupStore has been closed
+	 * @throws IllegalArgumentException - on type mismatch (file vs. directory) of earlier backup, or if file is a Directory
+	 */
+	public boolean backupCopy(File file) throws IOException {
+		if (closed)
+			throw new ClosedBackupStoreException(Messages.BackupStore_backupCopy_closed_store);
+		if (!file.exists())
+			throw new IOException(NLS.bind(Messages.BackupStore_file_not_found, file.getAbsolutePath()));
+		if (file.isDirectory())
+			throw new IllegalArgumentException(NLS.bind(Messages.BackupStore_can_not_copy_directory, file.getAbsolutePath()));
+
+		//File buRoot = backupRoot;
+		// File buRoot = findBackupRoot(file);
+		File buDir = new File(backupRoot, backupName);
+		// move the file
+		// create the relative path from root and use that in buDir
+		File buFile = new File(buDir, makeRelativeFromRoot(file).getPath());
+		// already backed up, but was a directory = wrong usage
+		if (buFile.isDirectory())
+			throw new IllegalArgumentException(NLS.bind(Messages.BackupStore_directory_file_mismatch, buFile.getAbsolutePath()));
+		// has already been backed up - can only be done once with one BackupStore
+		if (buFile.exists())
+			return false;
+
+		// make sure all of the directories exist / gets created
+		buFile.getParentFile().mkdirs();
+		if (buFile.getParentFile().exists() && !buFile.getParentFile().isDirectory())
+			throw new IllegalArgumentException(NLS.bind(Messages.BackupStore_file_directory_mismatch, buFile.getParentFile().getAbsolutePath()));
+
+		// just make a copy - one has to be made in one direction anyway
+		// A renameTo followed by a copy is preferred as it preserves file permissions on the moved file
+		// but it is easier to just copy and keep original.
+		Util.copyStream(new FileInputStream(file), true, new FileOutputStream(buFile), true);
+		backupCounter++;
+		return true;
+	}
+
+	/**
+	 * Performs backup of an empty directory. The directory must be empty before it can be backed up (i.e.
+	 * similar to a delete of a directory). Backup the files of the directory first.
+	 * A call to backup a directory is really only needed for empty directories as a restore
+	 * of a file will also restore all of its parent directories.
+	 * @param file - the (empty) directory to back up
+	 * @return true if the directory was moved to backup. false if the directory was already backed up and remains.
+	 * @throws IllegalArgumentException if file is not a directory, or is not empty.
+	 * @throws IOException if directory can not be moved to the backup store, or if the directory is not writeable
+	 */
+	public boolean backupDirectory(File file) throws IOException {
+		if (!file.isDirectory())
+			throw new IllegalArgumentException(NLS.bind(Messages.BackupStore_not_a_directory, file.getAbsolutePath()));
+		if (file.list().length != 0)
+			throw new IllegalArgumentException(NLS.bind(Messages.BackupStore_directory_not_empty, file.getAbsolutePath()));
+		// the easiest is to create a dummy file and back that up (the dummy is simply ignored when restoring).
+		File dummy = new File(file, dummyName);
+		if (!dummy.createNewFile())
+			throw new IOException(NLS.bind(Messages.BackupStore_can_not_create_dummy, dummy.getAbsolutePath()));
+		boolean result = backup(dummy);
+		// if already backed up - do not delete the directory
+		if (result && !file.delete())
+			throw new IOException(NLS.bind(Messages.BackupStore_can_not_remove, dummy.getAbsolutePath()));
+		return result;
+	}
+
+	/**
+	 * Restores all backup files from backup store.
+	 * Note that restore of a (non directory) file deletes an existing file or directory found
+	 * in the restore location.
+	 * When the backup has been restored this BackupStore instance is closed and can not be
+	 * used for further backup or restore.
+	 * 
+	 * If there are unrestorable items (non writable directories, or general IO exceptions) these items
+	 * are written to the log, and the backup copies remain in the file system and can be manually restored
+	 * (using a simple zip of the backup directory, and an unzip to the buRoot once the problem has been corrected).
+	 * 
+	 * @throws IOException if the backup was not fully restored - unrestored items have been logged.
+	 * @throws ClosedBackupStoreException if the backup is already closed.
+	 */
+	public void restore() throws IOException {
+		if (closed)
+			throw new ClosedBackupStoreException(Messages.BackupStore_restore_closed_store);
+		// put back all files 
+		// collect things that could not be restored (so final status can be reported)
+		Set unrestorable = new HashSet();
+		boolean restored = true;
+		if (!backupRoot.exists()) {
+			logError(NLS.bind(Messages.BackupStore_missing_backup_directory, backupRoot.getAbsolutePath()));
+			restored = false;
+		} else
+			restoreRoots(new File(backupRoot, backupName), unrestorable);
+
+		logUnrestorables(unrestorable);
+		if (unrestorable.size() > 0)
+			restored = false;
+		close(restored);
+		closed = true;
+	}
+
+	private void logUnrestorables(Set unrestorable) {
+		// if there are unrestorable units log them
+		//
+		if (unrestorable != null && unrestorable.size() > 0) {
+			for (Iterator itor = unrestorable.iterator(); itor.hasNext();)
+				logError(NLS.bind(Messages.BackupStore_manual_restore_needed, ((File) itor.next()).getAbsolutePath()));
+		}
+	}
+
+	/**
+	 * Discards and closes this BackupStore. Does nothing if this store is already
+	 * restored or discarded.
+	 */
+	public void discard() {
+		if (closed)
+			return;
+		closeSocket();
+		removeBackups();
+		closed = true;
+	}
+
+	private void close(boolean fullyRestored) throws IOException {
+		closeSocket();
+		// check external tampering with backup store
+		if (backupCounter != restoreCounter) {
+			if (!fullyRestored)
+				logError(NLS.bind(Messages.BackupStore_0_of_1_items_restored, new Long(restoreCounter), new Long(backupCounter)));
+			else {
+				logError(NLS.bind(Messages.BackupStore_externally_modified_0_of_1_restored, new Long(restoreCounter), new Long(backupCounter)));
+				fullyRestored = false;
+			}
+		}
+		if (!fullyRestored)
+			throw new IOException(Messages.BackupStore_errors_while_restoring_see_log);
+		// everything has been restored - the backup can now be removed
+		removeBackups();
+	}
+
+	private void closeSocket() {
+		if (socket != null && !socket.isClosed())
+			try {
+				socket.close();
+			} catch (IOException e) { /* ignored */
+				logWarning(NLS.bind(Messages.BackupStore_can_not_close_tcp_port, new Integer(socket.getLocalPort())));
+			}
+	}
+
+	private void removeBackups() {
+		File buRoot = new File(backupRoot, backupName);
+		if (!fullyDelete(buRoot))
+			logWarning(NLS.bind(Messages.BackupStore_can_not_remove_bu_directory, buRoot.getAbsolutePath()));
+	}
+
+	private static void logWarning(String message) {
+		LogHelper.log(createWarning(message));
+	}
+
+	private static IStatus createWarning(String message) {
+		return new Status(IStatus.WARNING, Activator.ID, message);
+	}
+
+	private static void logError(String message) {
+		LogHelper.log(createError(message));
+	}
+
+	private static IStatus createError(String message) {
+		return new Status(IStatus.ERROR, Activator.ID, message);
+	}
+
+	/**
+	 * Deletes a file, or a directory with all of it's children.
+	 * @param file the file or directory to fully delete
+	 * @return true if, and only if the file is deleted without errors
+	 */
+	private boolean fullyDelete(File file) {
+		if (!file.exists())
+			return true;
+		if (file.isDirectory()) {
+			File[] children = file.listFiles();
+			if (children == null)
+				return false;
+			for (int i = 0; i < children.length; i++)
+				if (!fullyDelete(new File(file, children[i].getName())))
+					return false;
+		}
+		return file.delete();
+	}
+
+	private void restore(File root, File buRoot, Set unrestorable) {
+		File[] children = buRoot.listFiles();
+		if (children == null) { // error - can't read the backup directory
+			unrestorable.add(buRoot);
+			return;
+		}
+		for (int i = 0; i < children.length; i++) {
+			File bu = new File(buRoot, children[i].getName());
+			File target = new File(root, bu.getName());
+			if (bu.isDirectory()) {
+				if (!target.exists() && !target.mkdir()) {
+					unrestorable.add(bu);
+					continue; // give up on this branch
+				} else if (target.exists() && !target.isDirectory()) {
+					// ouch, there is a file where we need a directory
+					// that must be deleted.
+					target.delete();
+					if (!target.mkdir()) {
+						unrestorable.add(bu);
+						continue; // give up on branch
+					}
+				}
+				restore(target, bu, unrestorable);
+			} else {
+				// do not restore the dummies (as they are used to trigger creation of
+				// empty directories and are not wanted in the restored location.
+				if (bu.getName().equals(dummyName)) {
+					restoreCounter++; // count of the restored directory in this case.
+					continue;
+				}
+				// if the original was overwritten by something and this file was not
+				// removed, it needs to be deleted now. If it can't be deleted, the
+				// renameTo will fail, and the bu is reported as not restorable.
+				// fullyDelete will remove a directory completely - we are restoring a file so it can 
+				// not be kept.
+				if (target.exists())
+					fullyDelete(target);
+
+				// rename if possible, but must copy if not possible to just rename
+				if (!bu.renameTo(target)) {
+					// did not work to rename, probably because of volume boundaries. Try to copy instead,
+					try {
+						Util.copyStream(new FileInputStream(bu), true, new FileOutputStream(target), true);
+						restoreCounter++; // consider it restored
+					} catch (FileNotFoundException e) {
+						unrestorable.add(bu);
+						continue;
+					} catch (IOException e) {
+						unrestorable.add(bu);
+						continue;
+					}
+					if (!bu.delete()) { // cleanup
+						// could not remove the backup after copy - log, safe to remove manually
+						logWarning(NLS.bind(Messages.BackupStore_can_not_delete_tmp_file, bu.getAbsolutePath()));
+					}
+				} else
+					restoreCounter++;
+			}
+		}
+	}
+
+	/**
+	 * Restores everything backed up in the buRoot. Responsible for decoding the specially named root
+	 * target directories (i.e. _/, __/, C/, etc.) into the real system names.
+	 * @param buRoot
+	 * @param unrestorable
+	 */
+	private void restoreRoots(File buRoot, Set unrestorable) {
+		File[] children = buRoot.listFiles();
+		if (children == null) { // error - can't read the backup directory
+			unrestorable.add(buRoot);
+			return;
+		}
+		for (int i = 0; i < children.length; i++) {
+			// Names are  root-chars, or drive letters in the root bu directory 
+			String name = children[i].getName();
+			String rName = name;
+			String prefix = ""; //$NON-NLS-1$
+			while (rName.startsWith(ROOTCHAR)) {
+				prefix += File.separator;
+				rName = rName.substring(1);
+			}
+			if (prefix.length() < 1) {
+				// The name is a drive name
+				rName = rName + ":" + File.separator; //$NON-NLS-1$
+			} else
+				rName = prefix + rName;
+			// File root = new File(rName);
+			File bu = new File(buRoot, name);
+			File target = new File(rName);
+			if (!bu.isDirectory()) {
+				// the roots should all be directories - so this can only happen if someone manually
+				// stored files in the backup root - mark them as unrestorable and continue.
+				unrestorable.add(bu);
+				continue;
+			}
+			// the backup roots are system roots, and can not be created - but check root is directory and exists.
+			// (Network drives could have gone away etc).
+			//
+			if (!(target.exists() && target.isDirectory())) {
+				unrestorable.add(bu);
+				continue; // give up on this branch
+			}
+			// then perform a recursive restore
+			restore(target, bu, unrestorable);
+		}
+	}
+
+	private static long msCounter = 0;
+
+	/**
+	 * Generates a unique hex string by taking currentTimeMillis + sequence 
+	 * number at the end allowing for 32 numbers to be generated per ms.
+	 * This is sufficient uniqueness in the same VM. (And is still just a fallback solution 
+	 * if there is no access to a TCP port)
+	 * 
+	 * To make number unique over multiple VMs - the PID of the process would be enough, but
+	 * it is complicated to get hold of - a separate program must be launched and its PPID 
+	 * investigated. There is no standard API in Java to get the PID. Instead, a socket port is bound
+	 * to ensure local uniqueness.
+	 * 
+	 * To make number unique across multiple hosts (we may be provisioning over NFS), the
+	 * 48 LS bits of the IP address is used (this is more than enough for an IPv4 address). 
+	 * (If there is no IP address, the machine is not on a
+	 * network) - unfortunately the MAC address can not be used as this requires Java 6 (where 
+	 * there also is a UUID that should be used instead of this method).
+	 * 
+	 * This method needs to be modified when IPv6 addressing is the norm - at that time, the
+	 * restriction on Java 1.4 has hopefully been lifted, and it is possible to use the MAC address,
+	 * or the UUID provided since java 1.6
+	 * 
+	 * @return a unique string
+	 */
+	private String genUnique() {
+		// use 5 LSB bits for counter within ms - i.e. 32 instances can be created
+		// per millisecond.
+		long timePart = (System.currentTimeMillis() << 5) | (msCounter++ & 31);
+		// can't use the MAC address - but take IP address if provisioning across NFS
+		long ipPart = 0;
+		try {
+			// the returned address can be 32 bits IPv4, or 128 bits IPv6 (?)
+			// In any case use the LSB bits (as many as will fit
+			byte[] address = InetAddress.getLocalHost().getAddress();
+			for (int i = 0; i < address.length; i++)
+				ipPart = ((ipPart << 8) | (address[i] & 0xff));
+		} catch (UnknownHostException e) {
+			// there is no IP address, and there and hence no concurrency from other machines.
+			// use the default ip part 0
+		}
+		int port = 0;
+		try {
+			socket = new ServerSocket(0);
+			port = socket.getLocalPort();
+		} catch (IOException e) {
+			try {
+				if (socket != null)
+					socket.close();
+			} catch (IOException e1) { // ignore failure to close - 
+			}
+			// use a random number as port in this case
+			port = new Random().nextInt() & 0xffff;
+		}
+		// port is never > 0xffff
+		long aPart = (ipPart << 16) | (port & 0xffff);
+		return Long.toHexString(timePart) + "_" + Long.toHexString(aPart); //$NON-NLS-1$
+
+	}
+
+	/**
+	 * Turns a file into a "relativized" absolute file.
+	 * A leading "root" is transformed to the ROOTCHAR character. On Windows, network mapped drives starts
+	 * with two separators - and are encoded as two ROOTCHAR.
+	 * e.g.
+	 * \\Host\C$\File becomes __\Host\C$\File
+	 * /users/test/file becomes _/users/test/file
+	 * C:/somewhere/file becomes C/somewhere/file
+	 * 
+	 * @param file
+	 * @return a relativized absolute abstract file
+	 */
+	private File makeRelativeFromRoot(File file) {
+		File absolute = file.getAbsoluteFile();
+		String path = absolute.getPath();
+		String prefix = ""; //$NON-NLS-1$
+		while (path.startsWith(File.separator)) {
+			prefix += ROOTCHAR;
+			path = path.substring(1);
+		}
+		if (prefix.length() > 0) {
+			path = prefix + File.separator + path;
+			return new File(path);
+		}
+		// it is a windows drive letter first.
+		// Transform C:/foo to C/foo
+		//
+		int idx = path.indexOf(":"); //$NON-NLS-1$
+		if (idx < 1)
+			throw new InternalError("File is neither absolute nor has a drive name: " + path); //$NON-NLS-1$
+		path = path.substring(0, idx) + path.substring(idx + 1);
+		return new File(path);
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/ClosedBackupStoreException.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/ClosedBackupStoreException.java
new file mode 100644
index 0000000..7a19da5
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/ClosedBackupStoreException.java
@@ -0,0 +1,24 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.touchpoint.natives;
+
+public class ClosedBackupStoreException extends IllegalStateException {
+	private static final long serialVersionUID = -5030940685029643678L;
+
+	public ClosedBackupStoreException() {
+		super();
+	}
+
+	public ClosedBackupStoreException(String message) {
+		super(message);
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/IBackupStore.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/IBackupStore.java
new file mode 100644
index 0000000..4b08dca
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/IBackupStore.java
@@ -0,0 +1,105 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.internal.p2.touchpoint.natives;
+
+import java.io.File;
+import java.io.IOException;
+
+public interface IBackupStore {
+
+	/**
+	 * Backup the file.
+	 * Calling this method with a file that represents a directory is equivalent to calling 
+	 * {@link #backupDirectory(File)}.
+	 * 
+	 * A file (path) can only be backed up once per IBackupStore instance.
+	 * 
+	 * If a directory is first backed up, and later replaced by a regular file, and this file
+	 * is also backed up (or vice versa) - an {@link IllegalArgumentException} is thrown
+	 * 
+	 * A backup can not be performed on a closed IBackupStore. 
+	 * 
+	 * @param file - the file (or directory) to backup
+	 * @return true if the file was backed up, false if this file (path) has already been backed up (the file is not moved to the store).
+	 * @throws IOException - if the backup operation fails, or the file does not exist
+	 * @throws IllegalStateException - if the IBackupStore has been closed
+	 * @throws IllegalArgumentException - on type mismatch (file vs. directory) of earlier backup, or if file does not exist 
+	 */
+	public boolean backup(File file) throws IOException;
+
+	/**
+	 * Same as {@link #backup(File)} except that a copy is kept in the original location.
+	 * Can not be used to copy directories.
+	 * @param file to backup and copy
+	 * @return true if the file was backed up, false if this file (path) has already been backed up (the file is not moved to the store).
+	 * @throws IOException - if the backup operation fails, if the file does not exist, or if the copy can not be created.
+	 * @throws IllegalStateException - if the IBackupStore has been closed
+	 * @throws IllegalArgumentException - on type mismatch (file vs. directory) of earlier backup, or if file is a directory. 
+	 */
+	public boolean backupCopy(File file) throws IOException;
+
+	/**
+	 * Performs backup of an empty directory. The directory must be empty before it can be backed up (i.e.
+	 * similar to a delete of a directory). Backup the files of the directory first.
+	 * A call to backup a directory is really only needed for empty directories as a restore
+	 * of a file will also restore all of its parent directories.
+	 * @param file - the (empty) directory to back up
+	 * @return true if the directory was moved to backup. false if the directory was already backed up and remains.
+	 * @throws IllegalArgumentException if file is not a directory, or is not empty.
+	 * @throws IOException if directory can not be moved to the backup store, or if the directory is not writeable
+	 */
+	public boolean backupDirectory(File file) throws IOException;
+
+	/**
+	 * Discards and closes this BackupStore. Does nothing if this store is already
+	 * restored or discarded.
+	 */
+	public void discard();
+
+	/**
+	 * Restores all backup files from backup store.
+	 * Note that restore of a (non directory) file deletes an existing file or directory found
+	 * in the restore location.
+	 * When the backup has been restored it can not be
+	 * used for further backup or restore.
+	 * 
+	 * If there are unrestorable items (non writeable directories, or general IO exceptions) these items
+	 * should be written to the log, and the backup copies should be retained
+	 * for manual restore.
+	 * 
+	 * @throws IOException if the backup was not fully restored - unrestored items should have been logged.
+	 * @throws IllegalStateException if the backup is already closed.
+	 */
+	public void restore() throws IOException;
+
+	/**
+	 * Returns the unique backup name (this is the name of generated backup directories).
+	 * @return the backup name.
+	 */
+	public String getBackupName();
+
+	/**
+	 * Backs up a file, or everything under a directory.
+	 * 
+	 * @param file - file to backup or directory
+	 * @throws IOException if backup operation failed
+	 */
+	public void backupAll(File file) throws IOException;
+
+	/**
+	 * Backs up a file, or everything under a directory.
+	 * A copy of the backup is left in the original place.
+	 * @param file
+	 * @throws IOException
+	 */
+	public void backupCopyAll(File file) throws IOException;
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/LazyBackupStore.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/LazyBackupStore.java
new file mode 100644
index 0000000..b0ef233
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/LazyBackupStore.java
@@ -0,0 +1,82 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.touchpoint.natives;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * LazyBackupStore is a BackupStore that only instantiates a real backup store
+ * when needed.
+ * 
+ * @author henrik.lindberg@cloudsmith.com
+ *
+ */
+public class LazyBackupStore implements IBackupStore {
+	private BackupStore delegate;
+	private final String prefix;
+
+	/**
+	 * Creates a new lazy backup store
+	 * @param prefix The prefix to use in constructing the backup store directory
+	 */
+	public LazyBackupStore(String prefix) {
+		this.prefix = prefix;
+	}
+
+	public boolean backup(File file) throws IOException {
+		loadDelegate();
+		return delegate.backup(file);
+	}
+
+	public boolean backupDirectory(File file) throws IOException {
+		loadDelegate();
+		return delegate.backupDirectory(file);
+	}
+
+	public void discard() {
+		if (delegate == null)
+			return;
+		delegate.discard();
+	}
+
+	public void restore() throws IOException {
+		if (delegate == null)
+			return;
+		delegate.restore();
+	}
+
+	private void loadDelegate() {
+		if (delegate != null)
+			return;
+		delegate = new BackupStore(null, prefix);
+	}
+
+	public String getBackupName() {
+		loadDelegate();
+		return delegate.getBackupName();
+	}
+
+	public boolean backupCopy(File file) throws IOException {
+		loadDelegate();
+		return delegate.backupCopy(file);
+	}
+
+	public void backupCopyAll(File file) throws IOException {
+		loadDelegate();
+		delegate.backupCopyAll(file);
+	}
+
+	public void backupAll(File file) throws IOException {
+		loadDelegate();
+		delegate.backupAll(file);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/Messages.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/Messages.java
index eaebfcb..74114fe 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/Messages.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/Messages.java
@@ -20,6 +20,30 @@ public class Messages extends NLS {
 		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
 	}
 
+	public static String BackupStore_0_of_1_items_restored;
+	public static String BackupStore_backup_root_for_0_not_determinable;
+	public static String BackupStore_backupCopy_closed_store;
+	public static String BackupStore_can_not_close_tcp_port;
+	public static String BackupStore_can_not_copy_directory;
+	public static String BackupStore_can_not_create_backup_dir;
+	public static String BackupStore_can_not_create_dummy;
+	public static String BackupStore_can_not_delete_after_copy_0;
+	public static String BackupStore_can_not_delete_tmp_file;
+	public static String BackupStore_can_not_move_file_to;
+	public static String BackupStore_can_not_remove;
+	public static String BackupStore_can_not_remove_bu_directory;
+	public static String BackupStore_directory_file_mismatch;
+	public static String BackupStore_directory_not_empty;
+	public static String BackupStore_errors_while_restoring_see_log;
+	public static String BackupStore_externally_modified_0_of_1_restored;
+	public static String BackupStore_file_0_must_be_related_to_1;
+	public static String BackupStore_file_directory_mismatch;
+	public static String BackupStore_file_not_found;
+	public static String BackupStore_manual_restore_needed;
+	public static String BackupStore_missing_backup_directory;
+	public static String BackupStore_not_a_directory;
+	public static String BackupStore_restore_closed_store;
+
 	public static String artifact_not_available;
 	public static String artifact_repo_not_found;
 	public static String could_not_obtain_download_cache;
@@ -27,5 +51,14 @@ public class Messages extends NLS {
 	public static String unzipping;
 	public static String restoring;
 	public static String param_not_set;
+	public static String copy_failed;
+	public static String failed_backup_restore;
+	public static String backup_file_failed;
+	public static String Error_list_children_0;
+	public static String link_failed;
+	public static String mkdir_failed;
+	public static String rmdir_failed;
+	public static String Util_Invalid_Zip_File_Format;
+	public static String Util_Error_Unzipping;
 
 }
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
index 1aae150..163e0de 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
@@ -10,22 +10,78 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.touchpoint.natives;
 
+import java.io.IOException;
 import java.util.Map;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.IStatus;
+import java.util.WeakHashMap;
+import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.provisional.p2.engine.IProfile;
 import org.eclipse.equinox.internal.provisional.p2.engine.Touchpoint;
+import org.eclipse.osgi.util.NLS;
 
 public class NativeTouchpoint extends Touchpoint {
 
 	public static final String PARM_INSTALL_FOLDER = "installFolder"; //$NON-NLS-1$
+	public static final String PARM_BACKUP = "backup"; //$NON-NLS-1$
+
+	private static Map backups = new WeakHashMap();
 
 	public IStatus initializePhase(IProgressMonitor monitor, IProfile profile, String phaseId, Map touchpointParameters) {
 		touchpointParameters.put(PARM_INSTALL_FOLDER, Util.getInstallFolder(profile));
+		touchpointParameters.put(PARM_BACKUP, getBackupStore(profile));
+
 		return null;
 	}
 
 	public String qualifyAction(String actionId) {
 		return Activator.ID + "." + actionId; //$NON-NLS-1$
 	}
+
+	public IStatus prepare(IProfile profile) {
+		// does not have to do anything - everything is already in the correct place
+		// the commit means that the backup is discarded - if that fails it is not a 
+		// terrible problem.
+		return super.prepare(profile);
+	}
+
+	public IStatus commit(IProfile profile) {
+		IBackupStore store = getBackupStore(profile);
+		store.discard();
+		return Status.OK_STATUS;
+	}
+
+	public IStatus rollback(IProfile profile) {
+		IStatus returnStatus = Status.OK_STATUS;
+		IBackupStore store = getBackupStore(profile);
+		try {
+			store.restore();
+		} catch (IOException e) {
+			returnStatus = new Status(IStatus.ERROR, Activator.ID, NLS.bind(Messages.failed_backup_restore, store.getBackupName()), e);
+		} catch (ClosedBackupStoreException e) {
+			returnStatus = new Status(IStatus.ERROR, Activator.ID, NLS.bind(Messages.failed_backup_restore, store.getBackupName()), e);
+		}
+		clearProfileState(profile);
+		return returnStatus;
+	}
+
+	/**
+	 * Cleans up the transactional state associated with a profile.
+	 */
+	private static synchronized void clearProfileState(IProfile profile) {
+		backups.remove(profile);
+	}
+
+	/**
+	 * Gets the transactional state associated with a profile. A transactional state is
+	 * created if it did not exist.
+	 * @param profile
+	 * @return a lazily initialized backup store
+	 */
+	private static synchronized IBackupStore getBackupStore(IProfile profile) {
+		IBackupStore store = (IBackupStore) backups.get(profile);
+		if (store == null) {
+			store = new LazyBackupStore(profile.getProfileId());
+			backups.put(profile, store);
+		}
+		return store;
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/Util.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/Util.java
index 59c3f06..b9f7972 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/Util.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/Util.java
@@ -1,18 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
 package org.eclipse.equinox.internal.p2.touchpoint.natives;
 
-import org.eclipse.equinox.internal.provisional.p2.repository.IRepository;
-
+import java.io.*;
 import java.net.URI;
-import java.util.HashMap;
-import java.util.Map;
-import org.eclipse.core.runtime.IStatus;
-import org.eclipse.core.runtime.Status;
+import java.util.*;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.*;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
 import org.eclipse.equinox.internal.provisional.p2.core.location.AgentLocation;
 import org.eclipse.equinox.internal.provisional.p2.engine.IProfile;
+import org.eclipse.equinox.internal.provisional.p2.repository.IRepository;
 import org.eclipse.osgi.util.NLS;
 
 public class Util {
@@ -65,4 +75,92 @@ public class Util {
 		AgentLocation location = getAgentLocation();
 		return (location != null ? location.getArtifactRepositoryURI() : null);
 	}
+
+	/**
+	 * Unzip from a File to an output directory, with progress indication and backup.
+	 * monitor and backup store may be null.
+	 */
+	public static File[] unzipFile(File zipFile, File outputDir, IBackupStore store, String taskName, IProgressMonitor monitor) throws IOException {
+		InputStream in = new FileInputStream(zipFile);
+		try {
+			return unzipStream(in, zipFile.length(), outputDir, store, taskName, monitor);
+		} catch (IOException e) {
+			// add the file name to the message
+			throw new IOException(NLS.bind(Messages.Util_Error_Unzipping, zipFile, e.getMessage()));
+		} finally {
+			in.close();
+		}
+	}
+
+	/**
+	 * Unzip from an InputStream to an output directory using backup of overwritten files
+	 * if backup store is not null.
+	 */
+	public static File[] unzipStream(InputStream stream, long size, File outputDir, IBackupStore store, String taskName, IProgressMonitor monitor) throws IOException {
+		InputStream is = monitor == null ? stream : stream; // new ProgressMonitorInputStream(stream, size, size, taskName, monitor); TODO Commented code
+		ZipInputStream in = new ZipInputStream(new BufferedInputStream(is));
+		ZipEntry ze = in.getNextEntry();
+		if (ze == null) {
+			// There must be at least one entry in a zip file.
+			// When there isn't getNextEntry returns null.
+			in.close();
+			throw new IOException(Messages.Util_Invalid_Zip_File_Format);
+		}
+		ArrayList unzippedFiles = new ArrayList();
+		do {
+			File outFile = new File(outputDir, ze.getName());
+			unzippedFiles.add(outFile);
+			if (ze.isDirectory()) {
+				outFile.mkdirs();
+			} else {
+				if (outFile.exists()) {
+					if (store != null)
+						store.backup(outFile);
+					else
+						outFile.delete();
+				} else {
+					outFile.getParentFile().mkdirs();
+				}
+				try {
+					copyStream(in, false, new FileOutputStream(outFile), true);
+				} catch (FileNotFoundException e) {
+					// TEMP: ignore this for now in case we're trying to replace
+					// a running eclipse.exe
+				}
+				outFile.setLastModified(ze.getTime());
+			}
+			in.closeEntry();
+		} while ((ze = in.getNextEntry()) != null);
+		in.close();
+
+		return (File[]) unzippedFiles.toArray(new File[unzippedFiles.size()]);
+	}
+
+	/**
+	 * Copy an input stream to an output stream.
+	 * Optionally close the streams when done.
+	 * Return the number of bytes written.
+	 */
+	public static int copyStream(InputStream in, boolean closeIn, OutputStream out, boolean closeOut) throws IOException {
+		try {
+			int written = 0;
+			byte[] buffer = new byte[16 * 1024];
+			int len;
+			while ((len = in.read(buffer)) != -1) {
+				out.write(buffer, 0, len);
+				written += len;
+			}
+			return written;
+		} finally {
+			try {
+				if (closeIn) {
+					in.close();
+				}
+			} finally {
+				if (closeOut) {
+					out.close();
+				}
+			}
+		}
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/ActionConstants.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/ActionConstants.java
index a9cfaba..23c432f 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/ActionConstants.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/ActionConstants.java
@@ -17,4 +17,7 @@ public class ActionConstants {
 	public static final String PARM_LINK_NAME = "linkName"; //$NON-NLS-1$
 	public static final String PARM_LINK_TARGET = "linkTarget"; //$NON-NLS-1$
 	public static final String PARM_LINK_FORCE = "force"; //$NON-NLS-1$
+	public static final String PARM_COPY_TARGET = "target"; //$NON-NLS-1$
+	public static final String PARM_COPY_SOURCE = "source"; //$NON-NLS-1$
+	public static final String PARM_COPY_OVERWRITE = "overwrite"; //$NON-NLS-1$
 }
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupcopyAction.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupcopyAction.java
new file mode 100644
index 0000000..a8da31b
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupcopyAction.java
@@ -0,0 +1,102 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.touchpoint.natives.actions;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.*;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.*;
+import org.eclipse.equinox.internal.provisional.p2.engine.IProfile;
+import org.eclipse.equinox.internal.provisional.p2.engine.ProvisioningAction;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.osgi.util.NLS;
+
+public class CleanupcopyAction extends ProvisioningAction {
+
+	public static final String ACTION_CLEANUPCOPY = "cleanupcopy"; //$NON-NLS-1$
+
+	public IStatus execute(Map parameters) {
+		return cleanupcopy(parameters, true);
+	}
+
+	public IStatus undo(Map parameters) {
+		return CopyAction.copy(parameters, false);
+	}
+
+	/**
+	 * Perform a cleanup of a previously made copy action.
+	 * @param parameters action parameters
+	 * @param restoreable flag indicating if the operation should be backed up
+	 * @return status
+	 */
+	public static IStatus cleanupcopy(Map parameters, boolean restoreable) {
+		String source = (String) parameters.get(ActionConstants.PARM_SOURCE);
+		if (source == null)
+			return Util.createError(NLS.bind(Messages.param_not_set, ActionConstants.PARM_SOURCE, ACTION_CLEANUPCOPY));
+		String target = (String) parameters.get(ActionConstants.PARM_TARGET);
+		if (target == null)
+			return Util.createError(NLS.bind(Messages.param_not_set, ActionConstants.PARM_TARGET, ACTION_CLEANUPCOPY));
+		IBackupStore backupStore = (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP);
+
+		IInstallableUnit iu = (IInstallableUnit) parameters.get(ActionConstants.PARM_IU);
+		IProfile profile = (IProfile) parameters.get(ActionConstants.PARM_PROFILE);
+
+		String copied = profile.getInstallableUnitProperty(iu, "copied" + ActionConstants.PIPE + source + ActionConstants.PIPE + target); //$NON-NLS-1$
+
+		if (copied == null)
+			return Status.OK_STATUS;
+
+		StringTokenizer tokenizer = new StringTokenizer(copied, ActionConstants.PIPE);
+		List directories = new ArrayList();
+		while (tokenizer.hasMoreTokens()) {
+			String fileName = tokenizer.nextToken();
+			File file = new File(fileName);
+			if (!file.exists())
+				continue;
+
+			if (file.isDirectory())
+				directories.add(file);
+			else {
+				if (restoreable)
+					try {
+						backupStore.backup(file);
+					} catch (IOException e) {
+						return Util.createError(NLS.bind(Messages.backup_file_failed, file));
+					}
+				else
+					file.delete();
+			}
+		}
+
+		for (Iterator it = directories.iterator(); it.hasNext();) {
+			File directory = (File) it.next();
+			File[] children = directory.listFiles();
+			if (children == null)
+				return Util.createError(NLS.bind(Messages.Error_list_children_0, directory));
+
+			if (children.length == 0) {
+				if (restoreable)
+					try {
+						backupStore.backup(directory);
+					} catch (IOException e) {
+						return Util.createError(NLS.bind(Messages.backup_file_failed, directory));
+					}
+				else
+					directory.delete();
+			}
+		}
+
+		return Status.OK_STATUS;
+	}
+
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupzipAction.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupzipAction.java
index 4b2fc9d..c5938e7 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupzipAction.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupzipAction.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
+ * Copyright (c) 2008, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,12 +11,12 @@
 package org.eclipse.equinox.internal.p2.touchpoint.natives.actions;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.*;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Status;
 import org.eclipse.equinox.internal.p2.engine.Profile;
-import org.eclipse.equinox.internal.p2.touchpoint.natives.Messages;
-import org.eclipse.equinox.internal.p2.touchpoint.natives.Util;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.*;
 import org.eclipse.equinox.internal.provisional.p2.engine.ProvisioningAction;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.osgi.util.NLS;
@@ -27,14 +27,14 @@ public class CleanupzipAction extends ProvisioningAction {
 	public static final String ACTION_CLEANUPZIP = "cleanupzip"; //$NON-NLS-1$
 
 	public IStatus execute(Map parameters) {
-		return cleanupzip(parameters);
+		return cleanupzip(parameters, true);
 	}
 
 	public IStatus undo(Map parameters) {
-		return UnzipAction.unzip(parameters);
+		return UnzipAction.unzip(parameters, false);
 	}
 
-	public static IStatus cleanupzip(Map parameters) {
+	public static IStatus cleanupzip(Map parameters, boolean restoreable) {
 		String source = (String) parameters.get(ActionConstants.PARM_SOURCE);
 		if (source == null)
 			return Util.createError(NLS.bind(Messages.param_not_set, ActionConstants.PARM_SOURCE, ACTION_CLEANUPZIP));
@@ -69,6 +69,7 @@ public class CleanupzipAction extends ProvisioningAction {
 				return Status.OK_STATUS;
 		}
 
+		IBackupStore store = restoreable ? (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP) : null;
 		StringTokenizer tokenizer = new StringTokenizer(unzipped, ActionConstants.PIPE);
 		List directories = new ArrayList();
 		while (tokenizer.hasMoreTokens()) {
@@ -79,13 +80,34 @@ public class CleanupzipAction extends ProvisioningAction {
 
 			if (file.isDirectory())
 				directories.add(file);
-			else
-				file.delete();
+			else {
+				if (store != null)
+					try {
+						store.backup(file);
+					} catch (IOException e) {
+						return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, NLS.bind(Messages.backup_file_failed, file.getPath()), e);
+					}
+				else
+					file.delete();
+			}
 		}
-
+		// TODO: this will most likely leave garbage behind as directories must
+		// be empty to be deleted - there is not guarantee that this structure has
+		// the leafs first in the list of directories.
+		// Since backup will deny backup of non empty directory a check must be made
+		// 
 		for (Iterator it = directories.iterator(); it.hasNext();) {
 			File directory = (File) it.next();
-			directory.delete();
+			if (store != null) {
+				File[] children = directory.listFiles();
+				if (children == null || children.length == 0)
+					try {
+						store.backupDirectory(directory);
+					} catch (IOException e) {
+						return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, NLS.bind(Messages.backup_file_failed, directory.getPath()), e);
+					}
+			} else
+				directory.delete();
 		}
 
 		profile.removeInstallableUnitProperty(iu, iuPropertyKey);
@@ -106,5 +128,4 @@ public class CleanupzipAction extends ProvisioningAction {
 		}
 		return buffer.toString();
 	}
-
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CopyAction.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CopyAction.java
new file mode 100644
index 0000000..ee1f952
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CopyAction.java
@@ -0,0 +1,161 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.touchpoint.natives.actions;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.Map;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.equinox.internal.p2.engine.Profile;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.*;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IFileArtifactRepository;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.engine.ProvisioningAction;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IArtifactKey;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * Copies from PARM_COPY_SOURCE to PARAM_COPY_TARGET
+ * The optional parameter PARAM_COPY_OVERWRITE overwrites and existing file if set to true, else
+ * and existing file with the same name is an error. The default is false.
+ * If the source is a directory, a merge copy to the target is performed.
+ * Copy will copy files and directories (recursively).
+ *  
+ * @author henrik.lindberg@cloudsmith.com
+ */
+public class CopyAction extends ProvisioningAction {
+	public static final String ID = "cp"; //$NON-NLS-1$
+
+	public IStatus execute(Map parameters) {
+		return copy(parameters, true);
+	}
+
+	/** Perform the copy.
+	 * 
+	 * @param parameters action parameters
+	 * @param restoreable  flag indicating if the operation should be backed up
+	 * @return status
+	 */
+	public static IStatus copy(Map parameters, boolean restoreable) {
+		String target = (String) parameters.get(ActionConstants.PARM_COPY_TARGET);
+		IBackupStore backupStore = restoreable ? (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP) : null;
+
+		if (target == null)
+			return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, NLS.bind(Messages.param_not_set, ActionConstants.PARM_COPY_TARGET, ID), null);
+
+		String source = (String) parameters.get(ActionConstants.PARM_COPY_SOURCE);
+		if (source == null)
+			return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, NLS.bind(Messages.param_not_set, ActionConstants.PARM_COPY_SOURCE, ID), null);
+
+		String overwrite = (String) parameters.get(ActionConstants.PARM_COPY_OVERWRITE);
+		Profile profile = (Profile) parameters.get(ActionConstants.PARM_PROFILE);
+		IInstallableUnit iu = (IInstallableUnit) parameters.get(ActionConstants.PARM_IU);
+
+		String originalSource = source;
+		if (source.equals(ActionConstants.PARM_ARTIFACT)) {
+			//TODO: fix wherever this occurs -- investigate as this is probably not desired
+			if (iu.getArtifacts() == null || iu.getArtifacts().length == 0)
+				return Status.OK_STATUS;
+
+			IArtifactKey artifactKey = iu.getArtifacts()[0];
+
+			IFileArtifactRepository downloadCache;
+			try {
+				downloadCache = Util.getDownloadCacheRepo();
+			} catch (ProvisionException e) {
+				return e.getStatus();
+			}
+			File fileLocation = downloadCache.getArtifactFile(artifactKey);
+			if ((fileLocation == null) || !fileLocation.exists())
+				return Util.createError(NLS.bind(Messages.artifact_not_available, artifactKey));
+			source = fileLocation.getAbsolutePath();
+		}
+
+		File sourceFile = new File(source);
+		File targetFile = new File(target);
+		File[] copiedFiles = null;
+		try {
+			copiedFiles = mergeCopy(sourceFile, targetFile, Boolean.valueOf(overwrite).booleanValue(), backupStore);
+		} catch (IOException e) {
+			return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, NLS.bind(Messages.copy_failed, sourceFile.getPath()), e);
+		}
+		// keep copied file in the profile as memento for CleanupCopy
+		StringBuffer copiedFileNameBuffer = new StringBuffer();
+		for (int i = 0; i < copiedFiles.length; i++)
+			copiedFileNameBuffer.append(copiedFiles[i].getAbsolutePath()).append(ActionConstants.PIPE);
+
+		profile.setInstallableUnitProperty(iu, "copied" + ActionConstants.PIPE + originalSource + ActionConstants.PIPE + target, copiedFileNameBuffer.toString()); //$NON-NLS-1$
+
+		return Status.OK_STATUS;
+	}
+
+	public IStatus undo(Map parameters) {
+		return CleanupcopyAction.cleanupcopy(parameters, false);
+	}
+
+	/**
+	 * Merge-copy file or directory.
+	 * @param source
+	 * @param target
+	 * @param overwrite
+	 * @throws IOException
+	 */
+	private static File[] mergeCopy(File source, File target, boolean overwrite, IBackupStore backupStore) throws IOException {
+		ArrayList copiedFiles = new ArrayList();
+		xcopy(copiedFiles, source, target, overwrite, backupStore);
+		return (File[]) copiedFiles.toArray(new File[copiedFiles.size()]);
+	}
+
+	/**
+	 * Merge-copy file or directory.
+	 * @param copiedFiles - ArrayList where copied files are collected
+	 * @param source
+	 * @param target
+	 * @param overwrite
+	 * @throws IOException
+	 */
+	private static void xcopy(ArrayList copiedFiles, File source, File target, boolean overwrite, IBackupStore backupStore) throws IOException {
+		if (!source.exists())
+			throw new IOException("Source: " + source + "does not exists"); //$NON-NLS-1$//$NON-NLS-2$
+
+		if (source.isDirectory()) {
+			if (target.exists() && target.isFile()) {
+				if (!overwrite)
+					throw new IOException("Target: " + target + " already exists"); //$NON-NLS-1$//$NON-NLS-2$
+				if (backupStore != null)
+					backupStore.backup(target);
+				else
+					target.delete();
+			}
+			if (!target.exists())
+				target.mkdirs();
+			copiedFiles.add(target);
+			File[] children = source.listFiles();
+			if (children == null)
+				throw new IOException("Error while retrieving children of directory: " + source); //$NON-NLS-1$
+			for (int i = 0; i < children.length; i++)
+				xcopy(copiedFiles, children[i], new File(target, children[i].getName()), overwrite, backupStore);
+			return;
+		} else if (target.exists() && !overwrite)
+			throw new IOException("Target: " + target + " already exists"); //$NON-NLS-1$//$NON-NLS-2$
+
+		try {
+			Util.copyStream(new FileInputStream(source), true, new FileOutputStream(target), true);
+		} catch (IOException e) {
+			// get the original IOException to the log
+			e.printStackTrace();
+			throw new IOException("Error while copying:" + source.getAbsolutePath()); //$NON-NLS-1$
+		}
+		copiedFiles.add(target);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/LinkAction.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/LinkAction.java
index 3f5df71..8fc8eea 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/LinkAction.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/LinkAction.java
@@ -8,11 +8,12 @@
  ******************************************************************************/
 package org.eclipse.equinox.internal.p2.touchpoint.natives.actions;
 
+import org.eclipse.equinox.internal.p2.touchpoint.natives.IBackupStore;
+
 import java.io.*;
 import java.util.Map;
 import org.eclipse.core.runtime.*;
-import org.eclipse.equinox.internal.p2.touchpoint.natives.Activator;
-import org.eclipse.equinox.internal.p2.touchpoint.natives.Messages;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.*;
 import org.eclipse.equinox.internal.provisional.p2.engine.ProvisioningAction;
 import org.eclipse.osgi.util.NLS;
 
@@ -34,7 +35,13 @@ public class LinkAction extends ProvisioningAction {
 
 		String force = (String) parameters.get(ActionConstants.PARM_LINK_FORCE);
 
-		ln(targetDir, linkTarget, linkName, Boolean.valueOf(force).booleanValue());
+		IBackupStore store = (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP);
+
+		try {
+			ln(targetDir, linkTarget, linkName, Boolean.valueOf(force).booleanValue(), store);
+		} catch (IOException e) {
+			return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, NLS.bind(Messages.link_failed, ActionConstants.PARM_LINK_NAME, ID), e);
+		}
 		return Status.OK_STATUS;
 	}
 
@@ -44,12 +51,29 @@ public class LinkAction extends ProvisioningAction {
 
 		if (linkTarget != null && linkName != null) {
 			File linkFile = new File(linkTarget, linkName);
-			linkFile.delete();
+			linkFile.delete(); // ok since if something was overwritten - it is restored from backup
 		}
 		return null;
 	}
 
-	private void ln(String targetDir, String linkTarget, String linkName, boolean force) {
+	/**
+	 * Creates a link to the source file linkTarget - the created link is targetDir/linkName. 
+	 * TODO: Only runs on systems with a "ln -s" command supported.
+	 * TODO: Does not report errors if the "ln -s" fails
+	 * @param targetDir the directory where the link is created
+	 * @param linkTarget the source
+	 * @param linkName the name of the created link
+	 * @param force if overwrite of existing file should be performed.
+	 * @param store an (optional - set to null) backup store to use
+	 * @throws IOException if backup of existing file fails
+	 */
+	private void ln(String targetDir, String linkTarget, String linkName, boolean force, IBackupStore store) throws IOException {
+		// backup a file that would be overwritten using "force == true"
+		if (force && store != null) {
+			File xFile = new File(targetDir, linkName);
+			if (xFile.exists())
+				store.backup(xFile);
+		}
 		Runtime r = Runtime.getRuntime();
 		try {
 			Process process = r.exec(new String[] {"ln", "-s" + (force ? "f" : ""), linkTarget, targetDir + IPath.SEPARATOR + linkName}); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/MkdirAction.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/MkdirAction.java
index 2dccc3a..57c0b5d 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/MkdirAction.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/MkdirAction.java
@@ -24,15 +24,24 @@ public class MkdirAction extends ProvisioningAction {
 		String path = (String) parameters.get(ActionConstants.PARM_PATH);
 		if (path == null)
 			return Util.createError(NLS.bind(Messages.param_not_set, ActionConstants.PARM_PATH, ID));
-		new File(path).mkdir();
-		return Status.OK_STATUS;
+		File dir = new File(path);
+		// A created or existing directory is ok
+		dir.mkdir();
+		if (dir.isDirectory())
+			return Status.OK_STATUS;
+		// mkdir could have failed because of permissions, or because of an existing file
+		return Util.createError(NLS.bind(Messages.mkdir_failed, ActionConstants.PARM_PATH, ID));
 	}
 
 	public IStatus undo(Map parameters) {
 		String path = (String) parameters.get(ActionConstants.PARM_PATH);
 		if (path == null)
 			return Util.createError(NLS.bind(Messages.param_not_set, ActionConstants.PARM_PATH, ID));
-		new File(path).delete();
+		File dir = new File(path);
+		// although not perfect, it at least prevents a faulty mkdir to delete a file on undo
+		// worst case is that an empty directory could be deleted
+		if (dir.isDirectory())
+			dir.delete();
 		return Status.OK_STATUS;
 	}
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/RemoveAction.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/RemoveAction.java
new file mode 100644
index 0000000..ab442c4
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/RemoveAction.java
@@ -0,0 +1,50 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.touchpoint.natives.actions;
+
+import org.eclipse.equinox.internal.p2.touchpoint.natives.IBackupStore;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Map;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.*;
+import org.eclipse.equinox.internal.provisional.p2.engine.ProvisioningAction;
+import org.eclipse.osgi.util.NLS;
+
+public class RemoveAction extends ProvisioningAction {
+	public static final String ID = "remove"; //$NON-NLS-1$
+
+	public IStatus execute(Map parameters) {
+		String path = (String) parameters.get(ActionConstants.PARM_PATH);
+		if (path == null)
+			return Util.createError(NLS.bind(Messages.param_not_set, ActionConstants.PARM_PATH, ID));
+		File file = new File(path);
+		// ignore if the file is already removed
+		if (!file.exists())
+			return Status.OK_STATUS;
+		IBackupStore store = (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP);
+		if (store == null)
+			return Util.createError(NLS.bind(Messages.param_not_set, NativeTouchpoint.PARM_BACKUP, ID));
+		try {
+			store.backupAll(file);
+		} catch (IOException e) {
+			return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, NLS.bind(Messages.backup_file_failed, file.getPath()), e);
+		}
+		return Status.OK_STATUS;
+	}
+
+	public IStatus undo(Map parameters) {
+		// Does not have to do anything as the backup will restore what was deleted
+		return Status.OK_STATUS;
+	}
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/RmdirAction.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/RmdirAction.java
index b8eccc8..1accd8c 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/RmdirAction.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/RmdirAction.java
@@ -8,12 +8,14 @@
  ******************************************************************************/
 package org.eclipse.equinox.internal.p2.touchpoint.natives.actions;
 
+import org.eclipse.equinox.internal.p2.touchpoint.natives.IBackupStore;
+
 import java.io.File;
+import java.io.IOException;
 import java.util.Map;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Status;
-import org.eclipse.equinox.internal.p2.touchpoint.natives.Messages;
-import org.eclipse.equinox.internal.p2.touchpoint.natives.Util;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.*;
 import org.eclipse.equinox.internal.provisional.p2.engine.ProvisioningAction;
 import org.eclipse.osgi.util.NLS;
 
@@ -24,15 +26,33 @@ public class RmdirAction extends ProvisioningAction {
 		String path = (String) parameters.get(ActionConstants.PARM_PATH);
 		if (path == null)
 			return Util.createError(NLS.bind(Messages.param_not_set, ActionConstants.PARM_PATH, ID));
-		new File(path).delete();
+
+		IBackupStore store = (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP);
+
+		File dir = new File(path);
+		if (!dir.isDirectory())
+			return Util.createError(NLS.bind(Messages.rmdir_failed, ActionConstants.PARM_PATH, ID));
+		if (store != null)
+			try {
+				store.backupDirectory(dir);
+			} catch (IOException e) {
+				return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, NLS.bind(Messages.rmdir_failed, ActionConstants.PARM_PATH, ID), e);
+			} catch (IllegalArgumentException e) {
+				return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, NLS.bind(Messages.rmdir_failed, ActionConstants.PARM_PATH, ID), e);
+			}
+		else
+			dir.delete();
 		return Status.OK_STATUS;
 	}
 
 	public IStatus undo(Map parameters) {
 		String path = (String) parameters.get(ActionConstants.PARM_PATH);
+		IBackupStore store = (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP);
 		if (path == null)
 			return Util.createError(NLS.bind(Messages.param_not_set, ActionConstants.PARM_PATH, ID));
-		new File(path).mkdir();
+		// only need to create a dir if backup was not used
+		if (store == null)
+			new File(path).mkdir();
 		return Status.OK_STATUS;
 	}
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/UnzipAction.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/UnzipAction.java
index 4109fe3..215b4bd 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/UnzipAction.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/UnzipAction.java
@@ -10,14 +10,14 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.touchpoint.natives.actions;
 
+import org.eclipse.equinox.internal.p2.touchpoint.natives.Util;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.Map;
 import org.eclipse.core.runtime.*;
-import org.eclipse.equinox.internal.p2.core.helpers.FileUtils;
 import org.eclipse.equinox.internal.p2.engine.Profile;
-import org.eclipse.equinox.internal.p2.touchpoint.natives.Messages;
-import org.eclipse.equinox.internal.p2.touchpoint.natives.Util;
+import org.eclipse.equinox.internal.p2.touchpoint.natives.*;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IFileArtifactRepository;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
 import org.eclipse.equinox.internal.provisional.p2.engine.ProvisioningAction;
@@ -30,14 +30,21 @@ public class UnzipAction extends ProvisioningAction {
 	public static final String ACTION_UNZIP = "unzip"; //$NON-NLS-1$
 
 	public IStatus execute(Map parameters) {
-		return unzip(parameters);
+		return unzip(parameters, true);
 	}
 
 	public IStatus undo(Map parameters) {
-		return CleanupzipAction.cleanupzip(parameters);
+		return CleanupzipAction.cleanupzip(parameters, false);
 	}
 
-	public static IStatus unzip(Map parameters) {
+	/**
+	 * Unzip as directed by parameters.
+	 * Record what was zipped in the profile.
+	 * @param parameters
+	 * @param restoreable - if the unzip should be backed up
+	 * @return status
+	 */
+	public static IStatus unzip(Map parameters, boolean restoreable) {
 		String source = (String) parameters.get(ActionConstants.PARM_SOURCE);
 		if (source == null)
 			return Util.createError(NLS.bind(Messages.param_not_set, ActionConstants.PARM_SOURCE, ACTION_UNZIP));
@@ -68,8 +75,8 @@ public class UnzipAction extends ProvisioningAction {
 				return Util.createError(NLS.bind(Messages.artifact_not_available, artifactKey));
 			source = fileLocation.getAbsolutePath();
 		}
-
-		File[] unzippedFiles = unzip(source, target, null);
+		IBackupStore store = restoreable ? (IBackupStore) parameters.get(NativeTouchpoint.PARM_BACKUP) : null;
+		File[] unzippedFiles = unzip(source, target, store);
 		StringBuffer unzippedFileNameBuffer = new StringBuffer();
 		for (int i = 0; i < unzippedFiles.length; i++)
 			unzippedFileNameBuffer.append(unzippedFiles[i].getAbsolutePath()).append(ActionConstants.PIPE);
@@ -81,7 +88,7 @@ public class UnzipAction extends ProvisioningAction {
 
 	// this is a drastically simplified version of the code that was in org.eclipse.equinox.internal.p2.touchpoint.natives (Zip, BackupFiles)
 	// In particular backing up files might be useful to look at 
-	private static File[] unzip(String source, String destination, String backupDir) {
+	private static File[] unzip(String source, String destination, IBackupStore store) {
 		File zipFile = new File(source);
 		if (zipFile == null || !zipFile.exists()) {
 			Util.log(UnzipAction.class.getName() + " the files to be unzipped is not here"); //$NON-NLS-1$
@@ -89,7 +96,7 @@ public class UnzipAction extends ProvisioningAction {
 
 		try {
 			String taskName = NLS.bind(Messages.unzipping, source);
-			return FileUtils.unzipFile(zipFile, new File(destination), taskName, new NullProgressMonitor());
+			return Util.unzipFile(zipFile, new File(destination), store, taskName, new NullProgressMonitor());
 		} catch (IOException e) {
 			Util.log(UnzipAction.class.getName() + " error unzipping zipfile: " + zipFile.getAbsolutePath() + "destination: " + destination); //$NON-NLS-1$ //$NON-NLS-2$
 		}
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/messages.properties b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/messages.properties
index 50d361b..f0b43ed 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/messages.properties
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/messages.properties
@@ -9,6 +9,30 @@
 #     IBM Corporation - initial API and implementation
 ###############################################################################
 
+BackupStore_backup_root_for_0_not_determinable=Can not determine backup root for file: {0}
+BackupStore_backupCopy_closed_store=Can not perform backup on closed backup store.
+BackupStore_0_of_1_items_restored={0} items out of {1} items restored.
+BackupStore_can_not_close_tcp_port=Could not close tcp socket for port: {0}
+BackupStore_can_not_copy_directory=Can not copy a directory: {0}
+BackupStore_can_not_create_backup_dir=Can not create backup directory: {0}
+BackupStore_can_not_create_dummy=Can not create dummy file: {0}
+BackupStore_can_not_delete_after_copy_0=File that was copied to backup could not be deleted: {0}
+BackupStore_can_not_delete_tmp_file=Can not delete temporary file - it is safe to delete it manually: {0}
+BackupStore_can_not_move_file_to=Could not move the file: {0} to: {1}
+BackupStore_can_not_remove=Can not remove : {0}
+BackupStore_can_not_remove_bu_directory=Could not remove temporary backup directory (it is safe to manually delete it and its contents): {0}
+BackupStore_directory_file_mismatch=File already backed up as a directory: {0}
+BackupStore_directory_not_empty=Directory is not empty: {0}
+BackupStore_errors_while_restoring_see_log=Errors while restoring - see earlier logged errors
+BackupStore_externally_modified_0_of_1_restored=Backup store modified externally\! {0} items out of {1} items restored. Remaining items can not be found.
+BackupStore_file_0_must_be_related_to_1=File: {0} must be related to File: {1}.
+BackupStore_file_directory_mismatch=File already backed up as a file - and is now required as a directory: {0}
+BackupStore_file_not_found=File does not exist: {0}.
+BackupStore_manual_restore_needed=Manual restore of backup needed for: {0}
+BackupStore_missing_backup_directory=Missing backup directory - can not restore: {0}
+BackupStore_not_a_directory=File is not a directory: {0}
+BackupStore_restore_closed_store=Can not perform restore on closed backup store
+
 artifact_not_available=The artifact for {0} is not available.
 restoring=Restoring {0}
 unzipping=Extracting {0}
@@ -16,5 +40,12 @@ param_not_set=The \"{0}\" parameter was not set in the \"{1}\" action.
 artifact_repo_not_found=The artifact repository manager could not be found.
 could_not_obtain_download_cache=Could not obtain the download cache location.
 download_cache_not_writeable=Agent download cache not writeable: {0}.
-
-
+copy_failed=I/O Error while copying {0} - see details.
+failed_backup_restore=Restore of backup failed - see log for details. Backup directory name: {0}.
+backup_file_failed=Backup of file {0} failed.
+Error_list_children_0=Error while retrieving children of directory: {0}
+link_failed=Could not create link {0}.
+mkdir_failed=Could not create directory {0}.
+rmdir_failed=Could not remove directory {0}.
+Util_Invalid_Zip_File_Format=Invalid zip file format
+Util_Error_Unzipping=Error unzipping {0}: {1}
commit d7c1c81091c8d4dc06d4c45449b0e2046272cff1
Author: John Arthorne <johna>
Date:   Thu Apr 2 19:46:53 2009 +0000

    Bug 262333 A backup/restore mechanism is required during install

3	1	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupcopyAction.java
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupcopyAction.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupcopyAction.java
index a8da31b..862c529 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupcopyAction.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/actions/CleanupcopyAction.java
@@ -64,8 +64,10 @@ public class CleanupcopyAction extends ProvisioningAction {
 			if (!file.exists())
 				continue;
 
+			//directories need to be deleted from the bottom-up, but directories are listed 
+			//in traversal order during copy, so we need to reverse the directory list
 			if (file.isDirectory())
-				directories.add(file);
+				directories.add(0, file);
 			else {
 				if (restoreable)
 					try {
