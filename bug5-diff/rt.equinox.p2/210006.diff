commit b1b0bee2900b68aa9b659db738b8a207f9aa7220
Author: John Arthorne <johna>
Date:   Thu Nov 15 20:49:48 2007 +0000

    Bug 210006 [prov] First pass engine cleanup

2	2	bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
0	63	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/CommonDef.java
56	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/InstructionParser.java
57	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/ParameterizedProvisioningAction.java
355	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/SimpleProfileRegistry.java
1	1	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/TouchpointManager.java
171	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/IInstallRegistry.java
31	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/IProfileInstallRegistry.java
613	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/InstallRegistry.java
103	0	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/MetadataCache.java
0	55	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/InstructionParser.java
0	56	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ParameterizedProvisioningAction.java
2	2	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Profile.java
0	21	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ProvisioningConfigurationException.java
0	355	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/SimpleProfileRegistry.java
0	171	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/IInstallRegistry.java
0	31	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/IProfileInstallRegistry.java
0	614	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/InstallRegistry.java
0	103	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/MetadataCache.java
2	1	bundles/org.eclipse.equinox.p2.exemplarysetup/META-INF/MANIFEST.MF
4	3	bundles/org.eclipse.equinox.p2.exemplarysetup/src/org/eclipse/equinox/internal/p2/exemplarysetup/Activator.java
1	1	bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
2	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
1	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/InstallRegistryTest.java
diff --git a/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
index ff7f7d5..236e20c 100644
--- a/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
@@ -6,9 +6,9 @@ Bundle-Vendor: %providerName
 Bundle-Localization: plugin
 Bundle-Version: 0.1.0.qualifier
 Export-Package: org.eclipse.equinox.internal.p2.engine;x-internal:=true,
+ org.eclipse.equinox.internal.p2.installregistry,
  org.eclipse.equinox.p2.engine,
- org.eclipse.equinox.p2.engine.phases,
- org.eclipse.equinox.p2.installregistry
+ org.eclipse.equinox.p2.engine.phases
 Import-Package: javax.xml.parsers,
  org.eclipse.equinox.internal.p2.core.helpers,
  org.eclipse.equinox.internal.p2.metadata,
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/CommonDef.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/CommonDef.java
deleted file mode 100644
index 9816a19..0000000
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/CommonDef.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.engine;
-
-/*
- *  This interface contains global constant definitions.
- *  
- *  Use this interface to define constants that are likely to be used
- *  widely in different contexts with share a common intended meaning.
- *
- */
-public interface CommonDef {
-
-	public static final String EmptyString = ""; //$NON-NLS-1$
-	public static final String SpaceString = " "; //$NON-NLS-1$
-	public static final String Underscore = "_"; //$NON-NLS-1$
-	public static final String Dot = "."; //$NON-NLS-1$
-	public static final String DotDot = ".."; //$NON-NLS-1$
-
-	public static final String EncodedSpaceString = "%20"; //$NON-NLS-1$ 
-
-	public static final String UncPrefix = "\\\\"; //$NON-NLS-1$
-	public static final char ColonChar = ':';
-
-	/*
-	 * Strings used as the type for the native and eclipse touchpoints,
-	 * including the type in the touchpoints extension point.
-	 */
-	public static final String NativeTouchpoint = "native"; //$NON-NLS-1$
-	public static final String EclipseTouchpoint = "eclipse"; //$NON-NLS-1$   
-
-	public static final int MaxPathLength_Win32 = 256;
-	public static final int MaxPathLength_Linux = 1024;
-	//    
-	//    /*
-	//     * Different protocols
-	//     */
-	//    public interface Protocols {
-	//        public static final String File = "file"; //$NON-NLS-1$
-	//        public static final String Http = "http"; //$NON-NLS-1$
-	//        public static final String Https = "https"; //$NON-NLS-1$
-	//        public static final String Ftp = "ftp"; //$NON-NLS-1$
-	//        public static final String Socks = "SOCKS"; //$NON-NLS-1$
-	//    }
-	//
-	//    /*
-	//     * File name extensions.
-	//     */
-	//    public interface Extensions {
-	//        public static final String Xml = ".xml"; //$NON-NLS-1$
-	//        public static final String Zip = ".zip"; //$NON-NLS-1$
-	//        public static final String Jar = ".jar"; //$NON-NLS-1$
-	//        public static final String Properties = ".properties"; //$NON-NLS-1$
-	//    }
-}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/InstructionParser.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/InstructionParser.java
new file mode 100644
index 0000000..349002a
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/InstructionParser.java
@@ -0,0 +1,56 @@
+package org.eclipse.equinox.internal.p2.engine;
+
+import java.util.*;
+import org.eclipse.equinox.p2.engine.*;
+
+public class InstructionParser {
+
+	Phase phase;
+	Touchpoint touchpoint;
+
+	public InstructionParser(Phase phase, Touchpoint touchpoint) {
+		this.phase = phase;
+		this.touchpoint = touchpoint;
+	}
+
+	public ProvisioningAction[] parseActions(String instruction) {
+		List actions = new ArrayList();
+		StringTokenizer tokenizer = new StringTokenizer(instruction, ";"); //$NON-NLS-1$
+		while (tokenizer.hasMoreTokens()) {
+			actions.add(parseAction(tokenizer.nextToken()));
+		}
+
+		return (ProvisioningAction[]) actions.toArray(new ProvisioningAction[actions.size()]);
+	}
+
+	private ProvisioningAction parseAction(String statement) {
+		int openBracket = statement.indexOf('(');
+		int closeBracket = statement.lastIndexOf(')');
+		String actionName = statement.substring(0, openBracket).trim();
+		ProvisioningAction action = lookupAction(actionName);
+
+		String nameValuePairs = statement.substring(openBracket + 1, closeBracket);
+		StringTokenizer tokenizer = new StringTokenizer(nameValuePairs, ","); //$NON-NLS-1$
+		Map parameters = new HashMap();
+		while (tokenizer.hasMoreTokens()) {
+			String nameValuePair = tokenizer.nextToken();
+			int colonIndex = nameValuePair.indexOf(":"); //$NON-NLS-1$
+			String name = nameValuePair.substring(0, colonIndex).trim();
+			String value = nameValuePair.substring(colonIndex + 1).trim();
+			parameters.put(name, value);
+		}
+		return new ParameterizedProvisioningAction(action, parameters);
+	}
+
+	private ProvisioningAction lookupAction(String actionId) {
+
+		ProvisioningAction action = phase.getAction(actionId);
+		if (action == null)
+			action = touchpoint.getAction(actionId);
+
+		if (action == null)
+			throw new IllegalArgumentException("No action found for " + actionId + "."); //$NON-NLS-2$
+
+		return action;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/ParameterizedProvisioningAction.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/ParameterizedProvisioningAction.java
new file mode 100644
index 0000000..7053190
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/ParameterizedProvisioningAction.java
@@ -0,0 +1,57 @@
+package org.eclipse.equinox.internal.p2.engine;
+
+import java.util.*;
+import java.util.Map.Entry;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.p2.engine.ProvisioningAction;
+
+public class ParameterizedProvisioningAction extends ProvisioningAction {
+
+	private ProvisioningAction action;
+	private Map actionParameters;
+
+	public ParameterizedProvisioningAction(ProvisioningAction action, Map actionParameters) {
+		if (action == null || actionParameters == null)
+			throw new IllegalArgumentException("Both action and action pararameters must not be null.");
+		this.action = action;
+		this.actionParameters = actionParameters;
+	}
+
+	public IStatus execute(Map parameters) {
+		parameters = processActionParameters(parameters);
+		return action.execute(parameters);
+	}
+
+	public IStatus undo(Map parameters) {
+		parameters = processActionParameters(parameters);
+		return action.undo(parameters);
+	}
+
+	private Map processActionParameters(Map parameters) {
+		Map result = new HashMap(parameters);
+		for (Iterator it = actionParameters.entrySet().iterator(); it.hasNext();) {
+			Entry entry = (Entry) it.next();
+			String name = (String) entry.getKey();
+			String value = processVariables((String) entry.getValue(), parameters);
+			result.put(name, value);
+		}
+		return Collections.unmodifiableMap(result);
+	}
+
+	private String processVariables(String parameterValue, Map parameters) {
+
+		int variableBeginIndex = parameterValue.indexOf("${");
+		if (variableBeginIndex == -1)
+			return parameterValue;
+
+		int variableEndIndex = parameterValue.indexOf("}", variableBeginIndex + 2);
+		if (variableEndIndex == -1)
+			return parameterValue;
+
+		String preVariable = parameterValue.substring(0, variableBeginIndex);
+		String variableName = parameterValue.substring(variableBeginIndex + 2, variableEndIndex);
+		String variableValue = parameters.get(variableName).toString();
+		String postVariable = processVariables(parameterValue.substring(variableEndIndex + 1), parameters);
+		return preVariable + variableValue + postVariable;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/SimpleProfileRegistry.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/SimpleProfileRegistry.java
new file mode 100644
index 0000000..9f45302
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/SimpleProfileRegistry.java
@@ -0,0 +1,355 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.equinox.internal.p2.engine;
+
+import java.io.*;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import javax.xml.parsers.ParserConfigurationException;
+import org.eclipse.equinox.internal.p2.core.helpers.OrderedProperties;
+import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
+import org.eclipse.equinox.internal.p2.persistence.XMLWriter;
+import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
+import org.eclipse.equinox.p2.core.location.AgentLocation;
+import org.eclipse.equinox.p2.engine.*;
+import org.eclipse.osgi.service.datalocation.Location;
+import org.eclipse.osgi.service.resolver.VersionRange;
+import org.eclipse.osgi.util.NLS;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Version;
+import org.xml.sax.*;
+
+public class SimpleProfileRegistry implements IProfileRegistry {
+	private static String STORAGE = "profileRegistry.xml"; //$NON-NLS-1$
+
+	/**
+	 * Map of String(Profile id)->Profile. 
+	 */
+	LinkedHashMap profiles = new LinkedHashMap(8);
+
+	OrderedProperties properties = new OrderedProperties();
+
+	private String self;
+
+	public SimpleProfileRegistry() {
+		self = EngineActivator.getContext().getProperty("eclipse.p2.profile"); //$NON-NLS-1$
+		restore();
+		updateRoamingProfile();
+	}
+
+	/**
+	 * If the current profile for self is marked as a roaming profile, we need
+	 * to update its install and bundle pool locations.
+	 */
+	private void updateRoamingProfile() {
+		Profile selfProfile = getProfile(SELF);
+		if (selfProfile == null)
+			return;
+		//only update if self is a roaming profile
+		if (!Boolean.valueOf(selfProfile.getValue(Profile.PROP_ROAMING)).booleanValue())
+			return;
+		Location installLocation = (Location) ServiceHelper.getService(EngineActivator.getContext(), Location.class.getName(), Location.INSTALL_FILTER);
+		String locationString = installLocation.getURL().getPath();
+		boolean changed = false;
+		if (!locationString.equals(selfProfile.getValue(Profile.PROP_INSTALL_FOLDER))) {
+			selfProfile.setValue(Profile.PROP_INSTALL_FOLDER, locationString);
+			changed = true;
+		}
+		if (!locationString.equals(selfProfile.getValue(Profile.PROP_CACHE))) {
+			selfProfile.setValue(Profile.PROP_CACHE, locationString);
+			changed = true;
+		}
+		if (changed)
+			persist();
+	}
+
+	public String toString() {
+		return this.profiles.toString();
+	}
+
+	public Profile getProfile(String id) {
+		if (SELF.equals(id))
+			id = self;
+		return (Profile) profiles.get(id);
+	}
+
+	public Profile[] getProfiles() {
+		return (Profile[]) profiles.values().toArray(new Profile[profiles.size()]);
+	}
+
+	public void addProfile(Profile toAdd) throws IllegalArgumentException {
+		if (isNamedSelf(toAdd))
+			throw new IllegalArgumentException(NLS.bind(Messages.Profile_Not_Named_Self, toAdd.getProfileId()));
+		String id = toAdd.getProfileId();
+		if (getProfile(id) == null) {
+			profiles.put(id, toAdd);
+		} else
+			throw new IllegalArgumentException(NLS.bind(Messages.Profile_Duplicate_Root_Profile_Id, id));
+		broadcastChangeEvent(toAdd, ProfileEvent.ADDED);
+		persist(); //TODO This is not enough to keep track of the changes that are being done in a profile. This will likely have to be based on some event like commit
+	}
+
+	private void broadcastChangeEvent(Profile profile, byte reason) {
+		((ProvisioningEventBus) ServiceHelper.getService(EngineActivator.getContext(), ProvisioningEventBus.class.getName())).publishEvent(new ProfileEvent(profile, reason));
+	}
+
+	private URL getRegistryLocation() {
+		AgentLocation agent = (AgentLocation) ServiceHelper.getService(EngineActivator.getContext(), AgentLocation.class.getName());
+		try {
+			return new URL(agent.getDataArea(EngineActivator.ID), STORAGE);
+		} catch (MalformedURLException e) {
+			//this is not possible because we know the above URL is valid
+		}
+		return null;
+	}
+
+	private void restore() {
+		try {
+			BufferedInputStream bif = null;
+			try {
+				bif = new BufferedInputStream(getRegistryLocation().openStream());
+				Parser parser = new Parser(EngineActivator.getContext(), EngineActivator.ID);
+				parser.parse(bif);
+			} finally {
+				if (bif != null)
+					bif.close();
+			}
+		} catch (FileNotFoundException e) {
+			//This is ok.
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+
+	private void persist() {
+		OutputStream os;
+		try {
+			Location agent = (Location) ServiceHelper.getService(EngineActivator.getContext(), AgentLocation.class.getName());
+			if (agent == null)
+				// TODO should likely do something here since we failed to persist.
+				return;
+
+			URL registryLocation = getRegistryLocation();
+			if (!registryLocation.getProtocol().equals("file")) //$NON-NLS-1$
+				throw new IOException(NLS.bind(Messages.SimpleProfileRegistry_Persist_To_Non_File_URL_Error, registryLocation));
+
+			File outputFile = new File(registryLocation.toExternalForm().substring(5));
+			if (!outputFile.getParentFile().exists() && !outputFile.getParentFile().mkdirs())
+				throw new RuntimeException(NLS.bind(Messages.SimpleProfileRegistry_Cannot_Create_File_Error, outputFile));
+			os = new BufferedOutputStream(new FileOutputStream(outputFile));
+			try {
+				Writer writer = new Writer(os);
+				writer.write(this);
+			} finally {
+				os.close();
+			}
+		} catch (FileNotFoundException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+
+	}
+
+	public void removeProfile(Profile toRemove) {
+		if (isNamedSelf(toRemove))
+			throw new IllegalArgumentException(NLS.bind(Messages.Profile_Not_Named_Self, toRemove.getProfileId()));
+		if (profiles.remove(toRemove.getProfileId()) == null)
+			return;
+		broadcastChangeEvent(toRemove, ProfileEvent.REMOVED);
+		persist();
+	}
+
+	private boolean isNamedSelf(Profile p) {
+		if (SELF.equals(p.getParentProfile()))
+			return true;
+		return false;
+	}
+
+	public Map getProperties() {
+		return properties;
+	}
+
+	public String getProperty(String key) {
+		return properties.getProperty(key);
+	}
+
+	public void setProperty(String key, String value) {
+		properties.setProperty(key, value);
+	}
+
+	public void removeProperty(String key) {
+		properties.remove(key);
+	}
+
+	private SimpleProfileRegistry getRegistry() {
+		return this;
+	}
+
+	private interface XMLConstants extends org.eclipse.equinox.internal.p2.persistence.XMLConstants {
+
+		// Constants defining the structure of the XML for a SimpleProfileRegistry
+
+		// A format version number for simple profile registry XML.
+		public static final String XML_CURRENT = "0.0.2"; //$NON-NLS-1$
+		public static final Version CURRENT_VERSION = new Version(XML_CURRENT);
+		public static final String XML_COMPATIBLE = "0.0.1"; //$NON-NLS-1$
+		public static final Version COMPATIBLE_VERSION = new Version(XML_CURRENT);
+		public static final VersionRange XML_TOLERANCE = new VersionRange(COMPATIBLE_VERSION, true, CURRENT_VERSION, true);
+
+		// Constants for processing instructions
+		public static final String PI_REPOSITORY_TARGET = "profileRegistry"; //$NON-NLS-1$
+		public static XMLWriter.ProcessingInstruction[] PI_DEFAULTS = new XMLWriter.ProcessingInstruction[] {XMLWriter.ProcessingInstruction.makeClassVersionInstruction(PI_REPOSITORY_TARGET, SimpleProfileRegistry.class, CURRENT_VERSION)};
+
+		// Constants for profile registry elements
+		public static final String REGISTRY_ELEMENT = "profileRegistry"; //$NON-NLS-1$
+
+	}
+
+	protected class Writer extends ProfileWriter implements XMLConstants {
+
+		public Writer(OutputStream output) throws IOException {
+			super(output, PI_DEFAULTS);
+		}
+
+		/**
+		 * Write the given SimpleProfileRegistry to the output stream.
+		 */
+		public void write(SimpleProfileRegistry registry) {
+			start(REGISTRY_ELEMENT);
+			writeProperties(registry.getProperties());
+			writeProfiles(registry.getProfiles());
+			end(REGISTRY_ELEMENT);
+			flush();
+		}
+	}
+
+	/*
+	 * 	Parser for the contents of a SimpleProfileRegistry,
+	 * 	as written by the Writer class.
+	 */
+	private class Parser extends ProfileParser implements XMLConstants {
+
+		public Parser(BundleContext context, String bundleId) {
+			super(context, bundleId);
+		}
+
+		public void parse(File file) throws IOException {
+			parse(new FileInputStream(file));
+		}
+
+		public synchronized void parse(InputStream stream) throws IOException {
+			this.status = null;
+			try {
+				// TODO: currently not caching the parser since we make no assumptions
+				//		 or restrictions on concurrent parsing
+				getParser();
+				RegistryHandler registryHandler = new RegistryHandler();
+				xmlReader.setContentHandler(new ProfileRegistryDocHandler(REGISTRY_ELEMENT, registryHandler));
+				xmlReader.parse(new InputSource(stream));
+			} catch (SAXException e) {
+				throw new IOException(e.getMessage());
+			} catch (ParserConfigurationException e) {
+				throw new IOException(e.getMessage());
+			} finally {
+				stream.close();
+			}
+		}
+
+		public SimpleProfileRegistry getContainingRegistry() {
+			return getRegistry();
+		}
+
+		protected Object getRootObject() {
+			return getRegistry();
+		}
+
+		private final class ProfileRegistryDocHandler extends DocHandler {
+
+			public ProfileRegistryDocHandler(String rootName, RootHandler rootHandler) {
+				super(rootName, rootHandler);
+			}
+
+			public void ProcessingInstruction(String target, String data) throws SAXException {
+				if (PI_REPOSITORY_TARGET.equals(target)) {
+					// TODO: should the root handler be constructed based on class
+					// 		 via an extension registry mechanism?
+					// String clazz = extractPIClass(data);
+					// and
+					// TODO: version tolerance by extension
+					Version repositoryVersion = extractPIVersion(target, data);
+					if (!XMLConstants.XML_TOLERANCE.isIncluded(repositoryVersion)) {
+						throw new SAXException(NLS.bind(Messages.SimpleProfileRegistry_Parser_Has_Incompatible_Version, repositoryVersion, XMLConstants.XML_TOLERANCE));
+					}
+				}
+			}
+
+		}
+
+		private final class RegistryHandler extends RootHandler {
+
+			private ProfilesHandler profilesHandler = null;
+			private PropertiesHandler propertiesHandler = null;
+
+			public RegistryHandler() {
+				super();
+			}
+
+			protected void handleRootAttributes(Attributes attributes) {
+				parseRequiredAttributes(attributes, noAttributes);
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (PROPERTIES_ELEMENT.equals(name)) {
+					if (propertiesHandler == null) {
+						propertiesHandler = new PropertiesHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else if (PROFILES_ELEMENT.equals(name)) {
+					if (profilesHandler == null) {
+						profilesHandler = new ProfilesHandler(this, attributes, null /*no parent*/);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+
+			protected void finished() {
+				if (isValidXML()) {
+					Profile[] profyles = (profilesHandler == null ? new Profile[0] //
+							: profilesHandler.getProfiles());
+					for (int i = 0; i < profyles.length; i++) {
+						Profile nextProfile = profyles[i];
+						profiles.put(nextProfile.getProfileId(), nextProfile);
+					}
+					properties = (propertiesHandler == null ? new OrderedProperties(0) //
+							: propertiesHandler.getProperties());
+				}
+			}
+		}
+
+		protected String getErrorMessage() {
+			return Messages.SimpleProfileRegistry_Parser_Error_Parsing_Registry;
+		}
+
+		public String toString() {
+			// TODO:
+			return null;
+		}
+
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/TouchpointManager.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/TouchpointManager.java
index 6e718f9..34f81b7 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/TouchpointManager.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/TouchpointManager.java
@@ -109,7 +109,7 @@ public class TouchpointManager implements IRegistryChangeListener {
 	 * or <code>null</code> if none are registered.
 	 */
 	public Touchpoint getTouchpoint(TouchpointType id) {
-		if (id == null || CommonDef.EmptyString.equals(id.getId()))
+		if (id == null || "".equals(id.getId())) //$NON-NLS-1$
 			throw new IllegalArgumentException(Messages.TouchpointManager_Null_Touchpoint_Type_Argument);
 		if (touchpointEntries == null) {
 			initializeTouchpoints();
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/IInstallRegistry.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/IInstallRegistry.java
new file mode 100644
index 0000000..f074fde
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/IInstallRegistry.java
@@ -0,0 +1,171 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.installregistry;
+
+import java.util.Collection;
+import org.eclipse.equinox.p2.engine.Profile;
+
+public interface IInstallRegistry {
+
+	/**
+	 * Save the registry as XML.  If exception is thrown, no change was made.
+	 */
+	//	public void saveXML() throws IOException {
+	//		checkMetadata();
+	//		File xmlFile = getLocation();
+	//		plog.start(plog.debug("Saving {0}", xmlFile)); //$NON-NLS-1$
+	//		if (isEmpty()) { // delete when empty
+	//			xmlFile.delete();
+	//			if (xmlFile.exists()) {
+	//				throw new IOException(NLS.bind(Messages.InstallRegistry_Failed_To_Delete_Install_Registry, xmlFile));
+	//			}
+	//		} else {
+	//			new FileUtil.SafeUpdate(xmlFile) {
+	//				public void write(FileOutputStream stream) throws IOException {
+	//					XMLWriter writer = new XMLWriter(stream, XML.getProcessingInstruction());
+	//					XML.write(writer);
+	//					writer.flush();
+	//					stream.getFD().sync();
+	//					writer.close();
+	//				}
+	//			}.write();
+	//		}
+	//		plog.stop();
+	//	}
+	//	private static class XML implements InstallRegistryXML {
+	//		public static XMLWriter.ProcessingInstruction getProcessingInstruction() {
+	//			return new XMLWriter.ProcessingInstruction(PI.INSTALL_REGISTRY, MetaInfo.formatVersion(MetaInfo.INSTALL_REGISTRY_VERSION));
+	//		}
+	//
+	//		public static void write(XMLWriter writer) {
+	//			InstallRegistry ir = InstallRegistry.getInstance();
+	//			writer.start(Elements.INSTALL_REGISTRY);
+	//			writer.write(ir.profileRegistry.getProperties());
+	//			for (Iterator i = ir.getProfileInstallRegistries().iterator(); i.hasNext();) {
+	//				ProfileInstallRegistry registry = (ProfileInstallRegistry) i.next();
+	//				if (!registry.isEmpty()) {
+	//					writer.start(Elements.PROFILE);
+	//					Profile profile = registry.getProfile();
+	//					writer.attribute(Attrs.ID, profile.getProfileId());
+	//					writer.attribute(Attrs.KIND, profile.getProfileKind());
+	//					writer.writeProperty(Profile.INSTALL_LOCATION, profile.getInstallLocation());
+	//					writer.write(profile.getAllData());
+	//					InstallContext rootContext = profile.getRootContext();
+	//					if (rootContext != null) {
+	//						write(writer, rootContext);
+	//					}
+	//					registry.emitXML(writer);
+	//					writer.end(Elements.PROFILE);
+	//				}
+	//			}
+	//			writer.end(Elements.INSTALL_REGISTRY);
+	//		}
+	//
+	//		private static void write(XMLWriter writer, InstallContext installContext) {
+	//			writer.start(Elements.INSTALL_CONTEXT);
+	//			writer.attribute(Attrs.ID, installContext.getId());
+	//			writer.attribute(Attrs.NAME, installContext.getName());
+	//			writer.attribute(Attrs.DESCRIPTION, installContext.getDescription());
+	//			writer.attribute(Attrs.SHAREABLE, installContext.isShareable(), true);
+	//			writer.attribute(Attrs.QUALIFIABLE, installContext.isQualifiable(), false);
+	//			InstallationContextScope scope = installContext.getScope();
+	//			if (scope != InstallationContextScope.NONE_SCOPE) {
+	//				writer.attribute(Attrs.SCOPE, scope.getName());
+	//			}
+	//			writer.write(installContext.getLocalProperties());
+	//			String[] adapterTypes = installContext.getAdaptorTypes();
+	//			for (int i = 0; i < adapterTypes.length; i += 1) {
+	//				writer.start(Elements.ADAPTER);
+	//				writer.attribute(Attrs.TYPE, adapterTypes[i]);
+	//				writer.end();
+	//			}
+	//			InstallContext[] subcontexts = installContext.getSubcontexts();
+	//			for (int i = 0; i < subcontexts.length; i += 1) {
+	//				write(writer, subcontexts[i]);
+	//			}
+	//			writer.end(Elements.INSTALL_CONTEXT);
+	//		}
+	//	}
+	//	/**
+	//	 * The file of the install registry.
+	//	 */
+	//	public File getLocation() {
+	//		return this.location;
+	//	}
+	//	// The location of the old install registry directory.
+	//	// This is where the metadata is still stored.
+	//	private File getLegacyLocation(String subdir) {
+	//		String path = getLocation().getPath();
+	//		if (path.endsWith(CommonDef.Extensions.Xml)) {
+	//			path = path.substring(0, path.length() - CommonDef.Extensions.Xml.length());
+	//		} else {
+	//			path += ".dir"; //$NON-NLS-1$
+	//		}
+	//		return new File(path, subdir);
+	//	}
+	public abstract IProfileInstallRegistry getProfileInstallRegistry(Profile profile);
+
+	/**
+	 * Open the install registry.  It must be open before any operations can be performed.
+	 */
+	//	public void open() throws IOException {
+	//		//		openFile(Agent.getInstance().getInstallRegistryLocation());
+	//	}
+	//
+	//	// This form is for AbstractAgentTestCase because the preferences aren't set correctly
+	//	// when it needs the install registry.
+	//	public void open(File dir) throws IOException {
+	//		openFile(new File(dir, Agent.FILENAME_INSTALL_REGISTRY));
+	//	}
+	//
+	//	private void openFile(File file) throws IOException {
+	//		if (isOpen()) {
+	//			throw new InstallRegistryException(Messages2.InstallRegistry_Install_Registry_Is_Already_Open);
+	//		}
+	//		this.location = file;
+	//		if (this.location.isDirectory()) {
+	//			throw new InstallRegistryException(NLS.bind(Messages2.InstallRegistry_Install_Registry_Exists_And_Is_A_Directory, this.location));
+	//		} else if (!this.location.exists()) {
+	//			// verify we can write it
+	//			this.location.getParentFile().mkdirs();
+	//			new FileOutputStream(this.location).close();
+	//			this.location.delete();
+	//		}
+	//
+	//		// TODO: move to cache
+	//		File metadataDir = getLegacyLocation(METADATA_DIR);
+	//		try {
+	//			this.metadataRepo = StandardRepository.create(this.installedMetadata.getRepositoryGroup(), metadataDir);
+	//		} catch (RuntimeException e) {
+	//			// report error below
+	//		}
+	//		if (this.metadataRepo == null) {
+	//			throw new InstallRegistryException(NLS.bind(Messages.InstallRegistry_Failed_To_Create_Install_Registry_Repo, metadataDir));
+	//		}
+	//		this.metadataRepo.setOpen(true);
+	//		load();
+	//		checkMetadata();
+	//	}
+	//
+	//	public void close() {
+	//		this.installedMetadata.getRepositoryGroup().removeRepository(this.metadataRepo);
+	//		this.metadataRepo = null;
+	//		if (isEmpty()) {
+	//			purge();
+	//		}
+	//	}
+	//	public void purge() {
+	//		getLocation().delete();
+	//		FileUtil.rm_r(getLegacyLocation(""), /*removeRoot*/true); //$NON-NLS-1$
+	//	}
+	public abstract Collection getProfileInstallRegistries();
+
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/IProfileInstallRegistry.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/IProfileInstallRegistry.java
new file mode 100644
index 0000000..e778b92
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/IProfileInstallRegistry.java
@@ -0,0 +1,31 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.installregistry;
+
+import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+
+public interface IProfileInstallRegistry {
+
+	public IInstallableUnit[] getInstallableUnits();
+
+	public IInstallableUnit getInstallableUnit(String id, String version);
+
+	public void addInstallableUnits(IInstallableUnit toAdd);
+
+	public void removeInstallableUnits(IInstallableUnit toRemove);
+
+	public String getProfileId();
+
+	public String getInstallableUnitProfileProperty(IInstallableUnit iu, String key);
+
+	public String setInstallableUnitProfileProperty(IInstallableUnit iu, String key, String value);
+
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/InstallRegistry.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/InstallRegistry.java
new file mode 100644
index 0000000..6b2e6ff
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/InstallRegistry.java
@@ -0,0 +1,613 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.installregistry;
+
+import java.io.*;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.*;
+import javax.xml.parsers.ParserConfigurationException;
+import org.eclipse.equinox.internal.p2.core.helpers.OrderedProperties;
+import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
+import org.eclipse.equinox.internal.p2.engine.*;
+import org.eclipse.equinox.internal.p2.metadata.repository.io.MetadataParser;
+import org.eclipse.equinox.internal.p2.metadata.repository.io.MetadataWriter;
+import org.eclipse.equinox.internal.p2.persistence.XMLWriter;
+import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
+import org.eclipse.equinox.p2.core.eventbus.SynchronousProvisioningListener;
+import org.eclipse.equinox.p2.core.location.AgentLocation;
+import org.eclipse.equinox.p2.engine.*;
+import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.osgi.service.resolver.VersionRange;
+import org.eclipse.osgi.util.NLS;
+import org.osgi.framework.*;
+import org.xml.sax.*;
+
+public class InstallRegistry implements IInstallRegistry {
+	private static String STORAGE = "installRegistry.xml"; //$NON-NLS-1$
+
+	// what is installed in each profile
+	Map profileRegistries = new LinkedHashMap(); // Profile id -> ProfileInstallRegistry
+	//	private ProfileRegistry profileRegistry; // the corresponding ProfileRegistry
+	//	private File location; // XML file containing install registry
+	//	private IRepository metadataRepo;
+	//	private final MetadataCache installedMetadata = new MetadataCache(
+	//            new RepositoryGroup("InstallRegistry"), //$NON-NLS-1$
+	//            MetadataCache.POLICY_NONE);
+
+	private transient ServiceReference busReference;
+	private transient ProvisioningEventBus bus;
+
+	public InstallRegistry() {
+		busReference = EngineActivator.getContext().getServiceReference(ProvisioningEventBus.class.getName());
+		bus = (ProvisioningEventBus) EngineActivator.getContext().getService(busReference);
+		restore();
+		bus.addListener(new SynchronousProvisioningListener() {
+			public void notify(EventObject o) {
+				if (o instanceof InstallableUnitEvent) {
+					InstallableUnitEvent event = (InstallableUnitEvent) o;
+					if (event.isPre() || !event.getResult().isOK())
+						return;
+					IProfileInstallRegistry registry = getProfileInstallRegistry(event.getProfile());
+					if (event.isInstall() && event.getOperand().second() != null) {
+						registry.addInstallableUnits(event.getOperand().second().unresolved());
+					} else if (event.isUninstall() && event.getOperand().first() != null) {
+						IInstallableUnit original = event.getOperand().first().unresolved();
+						String value = registry.getInstallableUnitProfileProperty(original, IInstallableUnit.PROP_PROFILE_ROOT_IU);
+						boolean isRoot = value != null && value.equals(Boolean.toString(true));
+						registry.removeInstallableUnits(original);
+						// TODO this is odd because I'm setting up a property for something
+						// not yet installed in the registry.  The implementation allows it and
+						// the assumption is that the second operand will get installed or else 
+						// this change will never be committed.  The alternative is to remember
+						// a transitory root value that we set when the install is received.
+						// The ideal solution is that this is handled in a profile delta by
+						// the engine.
+						// https://bugs.eclipse.org/bugs/show_bug.cgi?id=206077 
+						if (isRoot && event.getOperand().second() != null) {
+							registry.setInstallableUnitProfileProperty(event.getOperand().second().unresolved(), IInstallableUnit.PROP_PROFILE_ROOT_IU, Boolean.toString(true));
+						}
+					}
+				} else if (o instanceof CommitOperationEvent) {
+					persist();
+					return;
+				} else if (o instanceof RollbackOperationEvent) {
+					restore();
+					return;
+				} else if (o instanceof ProfileEvent) {
+					ProfileEvent pe = (ProfileEvent) o;
+					if (pe.getReason() == ProfileEvent.REMOVED) {
+						profileRegistries.remove(pe.getProfile().getProfileId());
+						persist();
+					} else if (pe.getReason() == ProfileEvent.CHANGED) {
+						// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=197701
+						persist();
+					}
+				}
+			}
+		});
+	}
+
+	synchronized void persist() {
+		try {
+			BufferedOutputStream bof = null;
+			try {
+				URL registryLocation = getRegistryLocation();
+				if (!registryLocation.getProtocol().equals("file")) //$NON-NLS-1$
+					throw new IOException("Can't write install registry at: " + registryLocation);
+				File outputFile = new File(registryLocation.toExternalForm().substring(5));
+				if (!outputFile.getParentFile().exists() && !outputFile.getParentFile().mkdirs())
+					throw new RuntimeException("Can't persist profile registry");
+				bof = new BufferedOutputStream(new FileOutputStream(outputFile, false));
+				Writer writer = new Writer(bof);
+				writer.write(this);
+			} finally {
+				if (bof != null)
+					bof.close();
+			}
+		} catch (FileNotFoundException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+
+	synchronized void restore() {
+		try {
+			BufferedInputStream bif = null;
+			try {
+				bif = new BufferedInputStream(getRegistryLocation().openStream());
+				Parser parser = new Parser(EngineActivator.getContext(), EngineActivator.ID);
+				parser.parse(bif);
+				profileRegistries = parser.getProfileInstallRegistries();
+			} finally {
+				if (bif != null)
+					bif.close();
+			}
+		} catch (FileNotFoundException e) {
+			//This is ok.
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+
+	public IProfileInstallRegistry getProfileInstallRegistry(Profile profile) {
+		String profileId = profile.getProfileId();
+		IProfileInstallRegistry result = (IProfileInstallRegistry) this.profileRegistries.get(profileId);
+		if (result == null) {
+			result = new ProfileInstallRegistry(profileId);
+			this.profileRegistries.put(profileId, result);
+		}
+		return result;
+	}
+
+	public Collection getProfileInstallRegistries() {
+		return this.profileRegistries.values();
+	}
+
+	public InstallRegistry getInstallRegistry() {
+		return this;
+	}
+
+	private URL getRegistryLocation() {
+		AgentLocation agent = (AgentLocation) ServiceHelper.getService(EngineActivator.getContext(), AgentLocation.class.getName());
+		try {
+			return new URL(agent.getDataArea(EngineActivator.ID), STORAGE);
+		} catch (MalformedURLException e) {
+			//this is not possible because we know the above URL is valid
+		}
+		return null;
+	}
+
+	class IUIdentity {
+
+		String id;
+		Version version;
+
+		public IUIdentity(String id, Version version) {
+			this.id = (id != null ? id : ""); //$NON-NLS-1$
+			this.version = (version != null ? version : Version.emptyVersion);
+		}
+
+		public IUIdentity(IInstallableUnit iu) {
+			this(iu.getId(), iu.getVersion());
+		}
+
+		public String toString() {
+			return id + ' ' + version;
+		}
+
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + ((id == null) ? 0 : id.hashCode());
+			result = prime * result + ((version == null) ? 0 : version.hashCode());
+			return result;
+		}
+
+		public boolean equals(Object obj) {
+			final IUIdentity objAsIdentity = //
+			(obj instanceof IUIdentity ? (IUIdentity) obj : null);
+			if (objAsIdentity != null) {
+				return this.id.equals(objAsIdentity.id) && this.version.equals(objAsIdentity.version);
+			}
+			return false;
+		}
+	}
+
+	/**
+	 * Install registry for a single profile.
+	 */
+	public class ProfileInstallRegistry implements IProfileInstallRegistry {
+		private String profileId; // id profile this data applies to
+		Set installableUnits; //id 
+		private Map iuPropertiesMap; // iu->OrderedProperties
+
+		public ProfileInstallRegistry(String profileId) {
+			this.profileId = profileId;
+			this.installableUnits = new LinkedHashSet();
+			this.iuPropertiesMap = new LinkedHashMap();
+		}
+
+		protected ProfileInstallRegistry(String profileId, IInstallableUnit[] units, Map iuPropertiesMap) {
+			this.profileId = profileId;
+			this.installableUnits = new LinkedHashSet(units.length);
+			this.iuPropertiesMap = new LinkedHashMap(iuPropertiesMap.size());
+			addInstallableUnits(units);
+			this.iuPropertiesMap.putAll(iuPropertiesMap);
+		}
+
+		public IInstallableUnit[] getInstallableUnits() {
+			IInstallableUnit[] result = new IInstallableUnit[installableUnits.size()];
+			return (IInstallableUnit[]) installableUnits.toArray(result);
+		}
+
+		public void addInstallableUnits(IInstallableUnit toAdd) {
+			installableUnits.add(toAdd);
+		}
+
+		public void addInstallableUnits(IInstallableUnit[] toAdd) {
+			for (int i = 0; i < toAdd.length; i++) {
+				installableUnits.add(toAdd[i]);
+			}
+		}
+
+		public void removeInstallableUnits(IInstallableUnit toRemove) {
+			installableUnits.remove(toRemove);
+			iuPropertiesMap.remove(new IUIdentity(toRemove));
+		}
+
+		public String getProfileId() {
+			return profileId;
+		}
+
+		public IInstallableUnit getInstallableUnit(String id, String version) {
+			for (Iterator i = installableUnits.iterator(); i.hasNext();) {
+				IInstallableUnit iu = (IInstallableUnit) i.next();
+				if (iu.getId().equals(id) && iu.getVersion().equals(new Version(version)))
+					return iu;
+			}
+			return null;
+		}
+
+		public String getInstallableUnitProfileProperty(IInstallableUnit toGet, String key) {
+			OrderedProperties properties = getInstallableUnitProfileProperties(toGet);
+			return properties.getProperty(key);
+		}
+
+		public String setInstallableUnitProfileProperty(IInstallableUnit toSet, String key, String value) {
+			OrderedProperties properties = getInstallableUnitProfileProperties(toSet);
+			return (String) properties.setProperty(key, value);
+		}
+
+		private OrderedProperties getInstallableUnitProfileProperties(IInstallableUnit toGet) {
+			OrderedProperties properties = (OrderedProperties) iuPropertiesMap.get(new IUIdentity(toGet));
+			if (properties == null) {
+				properties = new OrderedProperties();
+				iuPropertiesMap.put(new IUIdentity(toGet), properties);
+			}
+			return properties;
+		}
+
+		public Map getIUIdentityToPropertiesMap() {
+			return Collections.unmodifiableMap(iuPropertiesMap);
+		}
+	}
+
+	private interface XMLConstants extends org.eclipse.equinox.internal.p2.persistence.XMLConstants {
+
+		// Constants defining the structure of the XML for a SimpleProfileRegistry
+
+		// A format version number for install registry XML.
+		public static final String XML_VERSION = "0.0.1"; //$NON-NLS-1$
+		public static final Version CURRENT_VERSION = new Version(XML_VERSION);
+		public static final VersionRange XML_TOLERANCE = new VersionRange(CURRENT_VERSION, true, CURRENT_VERSION, true);
+
+		// Constants for processing instructions
+		public static final String PI_REPOSITORY_TARGET = "installRegistry"; //$NON-NLS-1$
+		public static XMLWriter.ProcessingInstruction[] PI_DEFAULTS = new XMLWriter.ProcessingInstruction[] {XMLWriter.ProcessingInstruction.makeClassVersionInstruction(PI_REPOSITORY_TARGET, SimpleProfileRegistry.class, CURRENT_VERSION)};
+
+		// Constants for install registry elements
+		public static final String INSTALL_REGISTRY_ELEMENT = "installRegistry"; //$NON-NLS-1$
+		public static final String PROFILE_INSTALL_REGISTRIES_ELEMENT = "profiles"; //$NON-NLS-1$
+		public static final String PROFILE_INSTALL_REGISTRY_ELEMENT = "profile"; //$NON-NLS-1$
+		public static final String IUS_PROPERTIES_ELEMENT = "iusPropertiesMap"; //$NON-NLS-1$
+		public static final String IU_PROPERTIES_ELEMENT = "iusProperties"; //$NON-NLS-1$
+
+		// Constants for attributes of an profile install registry element
+		public static final String PROFILE_ID_ATTRIBUTE = "profileId"; //$NON-NLS-1$
+
+	}
+
+	protected class Writer extends MetadataWriter implements XMLConstants {
+
+		public Writer(OutputStream output) throws IOException {
+			super(output, PI_DEFAULTS);
+		}
+
+		/**
+		 * Write the given artifact repository to the output stream.
+		 */
+		public void write(InstallRegistry istregistryry) {
+			start(INSTALL_REGISTRY_ELEMENT);
+			writeProfileRegistries(istregistryry.profileRegistries);
+			end(INSTALL_REGISTRY_ELEMENT);
+			flush();
+		}
+
+		private void writeProfileRegistries(Map registries) {
+			if (registries.size() > 0) {
+				start(PROFILE_INSTALL_REGISTRIES_ELEMENT);
+				attribute(COLLECTION_SIZE_ATTRIBUTE, registries.size());
+				for (Iterator iter = registries.keySet().iterator(); iter.hasNext();) {
+					String nextProfileId = (String) iter.next();
+					ProfileInstallRegistry nextProfileRegistry = (ProfileInstallRegistry) registries.get(nextProfileId);
+					writeProfileRegistry(nextProfileId, nextProfileRegistry);
+				}
+				end(PROFILE_INSTALL_REGISTRIES_ELEMENT);
+			}
+		}
+
+		private void writeProfileRegistry(String profileId, ProfileInstallRegistry profileRegistry) {
+			start(PROFILE_INSTALL_REGISTRY_ELEMENT);
+			attribute(PROFILE_ID_ATTRIBUTE, profileId);
+			Set ius = profileRegistry.installableUnits;
+			writeInstallableUnits((IInstallableUnit[]) ius.toArray(new IInstallableUnit[ius.size()]));
+			writeIUPropertyMap(profileRegistry.getIUIdentityToPropertiesMap());
+			end(PROFILE_INSTALL_REGISTRY_ELEMENT);
+		}
+
+		private void writeIUPropertyMap(Map iuPropertiesMap) {
+			if (iuPropertiesMap.size() > 0) {
+				start(IUS_PROPERTIES_ELEMENT);
+				attribute(COLLECTION_SIZE_ATTRIBUTE, iuPropertiesMap.size());
+				for (Iterator iter = iuPropertiesMap.keySet().iterator(); iter.hasNext();) {
+					IUIdentity nextIdentity = (IUIdentity) iter.next();
+					OrderedProperties properties = (OrderedProperties) iuPropertiesMap.get(nextIdentity);
+					start(IU_PROPERTIES_ELEMENT);
+					attribute(ID_ATTRIBUTE, nextIdentity.id);
+					attribute(VERSION_ATTRIBUTE, nextIdentity.version);
+					writeProperties(properties);
+					end(IU_PROPERTIES_ELEMENT);
+				}
+				end(IUS_PROPERTIES_ELEMENT);
+			}
+		}
+	}
+
+	/*
+	 * 	Parser for the contents of an InstallRegistry,
+	 * 	as written by the Writer class.
+	 */
+	private class Parser extends MetadataParser implements XMLConstants {
+
+		private Map profileInstallRegistries = null;
+
+		public Parser(BundleContext context, String bundleId) {
+			super(context, bundleId);
+		}
+
+		public void parse(File file) throws IOException {
+			parse(new FileInputStream(file));
+		}
+
+		public synchronized void parse(InputStream stream) throws IOException {
+			this.status = null;
+			try {
+				// TODO: currently not caching the parser since we make no assumptions
+				//		 or restrictions on concurrent parsing
+				getParser();
+				InstallRegistryHandler registryHandler = new InstallRegistryHandler();
+				xmlReader.setContentHandler(new InstallRegistryDocHandler(INSTALL_REGISTRY_ELEMENT, registryHandler));
+				xmlReader.parse(new InputSource(stream));
+				if (this.isValidXML()) {
+					profileInstallRegistries = registryHandler.getProfileInstallRegistries();
+				}
+			} catch (SAXException e) {
+				throw new IOException(e.getMessage());
+			} catch (ParserConfigurationException e) {
+				throw new IOException(e.getMessage());
+			} finally {
+				stream.close();
+			}
+		}
+
+		public Map getProfileInstallRegistries() {
+			return profileInstallRegistries;
+		}
+
+		protected Object getRootObject() {
+			return profileInstallRegistries;
+		}
+
+		private final class InstallRegistryDocHandler extends DocHandler {
+
+			public InstallRegistryDocHandler(String rootName, RootHandler rootHandler) {
+				super(rootName, rootHandler);
+			}
+
+			public void ProcessingInstruction(String target, String data) throws SAXException {
+				if (PI_REPOSITORY_TARGET.equals(target)) {
+					// TODO: should the root handler be constructed based on class
+					// 		 or via an extension registry mechanism?
+					// String clazz = extractPIClass(data);
+					// and
+					// TODO: version tolerance by extension or by class?
+					Version repositoryVersion = extractPIVersion(target, data);
+					if (!XMLConstants.XML_TOLERANCE.isIncluded(repositoryVersion)) {
+						throw new SAXException(NLS.bind(Messages.InstallRegistry_Parser_Has_Incompatible_Version, repositoryVersion, XMLConstants.XML_TOLERANCE));
+					}
+				}
+			}
+		}
+
+		private final class InstallRegistryHandler extends RootHandler {
+
+			private ProfileInstallRegistriesHandler profilesHandler = null;
+
+			private Map profyleRegistries = null;
+
+			public InstallRegistryHandler() {
+				super();
+			}
+
+			protected void handleRootAttributes(Attributes attributes) {
+				parseRequiredAttributes(attributes, noAttributes);
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (PROFILE_INSTALL_REGISTRIES_ELEMENT.equals(name)) {
+					if (profilesHandler == null) {
+						profilesHandler = new ProfileInstallRegistriesHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+
+			public Map getProfileInstallRegistries() {
+				return (profyleRegistries != null ? profyleRegistries : new LinkedHashMap(0));
+			}
+
+			protected void finished() {
+				if (isValidXML()) {
+					ProfileInstallRegistry[] registries = (profilesHandler == null ? new ProfileInstallRegistry[0] //
+							: profilesHandler.getProfileInstallRegistries());
+					profyleRegistries = new LinkedHashMap(registries.length);
+					for (int i = 0; i < registries.length; i++) {
+						ProfileInstallRegistry nextProfileRegistry = registries[i];
+						profyleRegistries.put(nextProfileRegistry.getProfileId(), nextProfileRegistry);
+					}
+				}
+			}
+		}
+
+		protected class ProfileInstallRegistriesHandler extends AbstractHandler {
+
+			private List registries = null;
+
+			public ProfileInstallRegistriesHandler(AbstractHandler parentHandler, Attributes attributes) {
+				super(parentHandler, PROFILE_INSTALL_REGISTRIES_ELEMENT);
+				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+				registries = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (name.equals(PROFILE_INSTALL_REGISTRY_ELEMENT)) {
+					new ProfileInstallRegistryHandler(this, attributes, registries);
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+
+			public ProfileInstallRegistry[] getProfileInstallRegistries() {
+				return (ProfileInstallRegistry[]) registries.toArray(new ProfileInstallRegistry[registries.size()]);
+			}
+		}
+
+		protected class ProfileInstallRegistryHandler extends AbstractHandler {
+
+			private final String[] required = new String[] {PROFILE_ID_ATTRIBUTE};
+
+			List registries = null;
+
+			private String profileId = null;
+
+			private InstallableUnitsHandler unitsHandler = null;
+			private IUsPropertiesHandler iusPropertiesHandler = null;
+
+			public ProfileInstallRegistryHandler(AbstractHandler parentHandler, Attributes attributes, List registries) {
+				super(parentHandler, PROFILE_INSTALL_REGISTRY_ELEMENT);
+				profileId = parseRequiredAttributes(attributes, required)[0];
+				this.registries = registries;
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (INSTALLABLE_UNITS_ELEMENT.equals(name)) {
+					if (unitsHandler == null) {
+						unitsHandler = new InstallableUnitsHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else if (IUS_PROPERTIES_ELEMENT.equals(name)) {
+					if (iusPropertiesHandler == null) {
+						iusPropertiesHandler = new IUsPropertiesHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+
+			protected void finished() {
+				if (isValidXML() && profileId != null) {
+					IInstallableUnit[] units = (unitsHandler == null ? new IInstallableUnit[0] //
+							: unitsHandler.getUnits());
+					Map iusPropertiesMap = (iusPropertiesHandler == null ? new LinkedHashMap() //
+							: iusPropertiesHandler.getIUsPropertiesMap());
+					ProfileInstallRegistry registry = new ProfileInstallRegistry(profileId, units, iusPropertiesMap);
+					registries.add(registry);
+				}
+			}
+		}
+
+		protected class IUsPropertiesHandler extends AbstractHandler {
+
+			private Map iusPropertiesMap;
+
+			public IUsPropertiesHandler(AbstractHandler parentHandler, Attributes attributes) {
+				super(parentHandler, IUS_PROPERTIES_ELEMENT);
+				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+				iusPropertiesMap = (size != null ? new LinkedHashMap(new Integer(size).intValue()) : new LinkedHashMap(4));
+			}
+
+			public Map getIUsPropertiesMap() {
+				return iusPropertiesMap;
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (name.equals(IU_PROPERTIES_ELEMENT)) {
+					new IUPropertiesHandler(this, attributes, iusPropertiesMap);
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+		}
+
+		protected class IUPropertiesHandler extends AbstractHandler {
+
+			private final String[] required = new String[] {ID_ATTRIBUTE, VERSION_ATTRIBUTE};
+
+			private IUIdentity iuIdentity = null;
+			private PropertiesHandler propertiesHandler = null;
+			private Map iusPropertiesMap = null;
+
+			public IUPropertiesHandler(AbstractHandler parentHandler, Attributes attributes, Map iusPropertiesMap) {
+				super(parentHandler, IU_PROPERTIES_ELEMENT);
+				String values[] = parseRequiredAttributes(attributes, required);
+				Version version = checkVersion(IU_PROPERTIES_ELEMENT, VERSION_ATTRIBUTE, values[1]);
+				iuIdentity = new IUIdentity(values[0], version);
+				this.iusPropertiesMap = iusPropertiesMap;
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (name.equals(PROPERTIES_ELEMENT)) {
+					propertiesHandler = new PropertiesHandler(this, attributes);
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+
+			protected void finished() {
+				if (isValidXML() && iuIdentity != null && propertiesHandler != null) {
+					iusPropertiesMap.put(iuIdentity, propertiesHandler.getProperties());
+				}
+			}
+		}
+
+		protected String getErrorMessage() {
+			return Messages.InstallRegistry_Parser_Error_Parsing_Registry;
+		}
+
+		public String toString() {
+			// TODO:
+			return null;
+		}
+
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/MetadataCache.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/MetadataCache.java
new file mode 100644
index 0000000..5b7877a
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/installregistry/MetadataCache.java
@@ -0,0 +1,103 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.installregistry;
+
+import java.io.*;
+import java.net.URL;
+import java.util.EventObject;
+import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
+import org.eclipse.equinox.internal.p2.engine.EngineActivator;
+import org.eclipse.equinox.internal.p2.metadata.repository.*;
+import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
+import org.eclipse.equinox.p2.core.eventbus.ProvisioningListener;
+import org.eclipse.equinox.p2.core.location.AgentLocation;
+import org.eclipse.equinox.p2.engine.*;
+import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
+import org.osgi.framework.ServiceReference;
+
+public class MetadataCache extends URLMetadataRepository {
+
+	static final private String REPOSITORY_NAME = "Agent Metadata Cache"; //$NON-NLS-1$
+	static final private String REPOSITORY_TYPE = MetadataCache.class.getName();
+	static final private Integer REPOSITORY_VERSION = new Integer(1);
+
+	transient private ServiceReference busReference;
+	transient private ProvisioningEventBus bus;
+
+	public MetadataCache() {
+		super();
+	}
+
+	public static MetadataCache getCacheInstance(MetadataRepositoryManager manager) {
+		AgentLocation agentLocation = (AgentLocation) ServiceHelper.getService(EngineActivator.getContext(), AgentLocation.class.getName());
+		URL url = (agentLocation != null ? agentLocation.getMetadataRepositoryURL() : null);
+		URL content = getActualLocation(url);
+		IMetadataRepository repository = manager.loadRepository(content, null);
+		if (repository == null || !(repository instanceof MetadataCache)) {
+			repository = new MetadataCache(url);
+			((MetadataCache) repository).initializeAfterLoad(url);
+			manager.addRepository(repository);
+		}
+		return (MetadataCache) repository;
+	}
+
+	// These are always created with file: URLs.  At least for now...
+	public MetadataCache(URL cacheLocation) {
+		super(REPOSITORY_NAME, REPOSITORY_TYPE, REPOSITORY_VERSION.toString(), cacheLocation, null, null);
+		content = getActualLocation(location);
+		// Set property indicating that the metadata cache is an implementation detail.
+		getModifiableProperties().put(IMPLEMENTATION_ONLY_KEY, Boolean.valueOf(true).toString());
+	}
+
+	public void initializeAfterLoad(URL repoLocation) {
+		super.initializeAfterLoad(repoLocation);
+
+		// TODO: We should check for writing permission here, otherwise it may be too late
+		busReference = EngineActivator.getContext().getServiceReference(ProvisioningEventBus.class.getName());
+		bus = (ProvisioningEventBus) EngineActivator.getContext().getService(busReference);
+		bus.addListener(new ProvisioningListener() {
+			public void notify(EventObject o) {
+				if (o instanceof InstallableUnitEvent) { //TODO This dependency on InstallableUnitEvent is not great
+					InstallableUnitEvent event = (InstallableUnitEvent) o;
+					if (event.isPre())
+						return;
+					// TODO: what about uninstall??
+					if (event.isPost() && event.getResult().isOK() && event.isInstall()) {
+						IInstallableUnit installedIU = event.getOperand().second();
+						if (installedIU != null)
+							units.add(installedIU.unresolved());
+						return;
+					}
+				}
+				if (o instanceof CommitOperationEvent)
+					persist();
+				if (o instanceof RollbackOperationEvent)
+					new SimpleMetadataRepositoryFactory().restore(MetadataCache.this, location);
+			}
+		});
+	}
+
+	protected void persist() {
+		if (!getContentURL().getProtocol().equals("file"))
+			throw new IllegalStateException("only file: URLs are supported for the metadata cache");
+		File contentFile = new File(getContentURL().getFile());
+		if (!contentFile.getParentFile().exists() && !contentFile.getParentFile().mkdirs())
+			throw new RuntimeException("can't persist the metadata cache");
+		try {
+			OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(contentFile, false));;
+			new MetadataRepositoryIO().write(this, outputStream);
+		} catch (FileNotFoundException e) {
+			throw new RuntimeException("can't persist the metadata cache");
+		}
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/InstructionParser.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/InstructionParser.java
deleted file mode 100644
index c195fc8..0000000
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/InstructionParser.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.eclipse.equinox.p2.engine;
-
-import java.util.*;
-
-public class InstructionParser {
-
-	Phase phase;
-	Touchpoint touchpoint;
-
-	public InstructionParser(Phase phase, Touchpoint touchpoint) {
-		this.phase = phase;
-		this.touchpoint = touchpoint;
-	}
-
-	public ProvisioningAction[] parseActions(String instruction) {
-		List actions = new ArrayList();
-		StringTokenizer tokenizer = new StringTokenizer(instruction, ";"); //$NON-NLS-1$
-		while (tokenizer.hasMoreTokens()) {
-			actions.add(parseAction(tokenizer.nextToken()));
-		}
-
-		return (ProvisioningAction[]) actions.toArray(new ProvisioningAction[actions.size()]);
-	}
-
-	private ProvisioningAction parseAction(String statement) {
-		int openBracket = statement.indexOf('(');
-		int closeBracket = statement.lastIndexOf(')');
-		String actionName = statement.substring(0, openBracket).trim();
-		ProvisioningAction action = lookupAction(actionName);
-
-		String nameValuePairs = statement.substring(openBracket + 1, closeBracket);
-		StringTokenizer tokenizer = new StringTokenizer(nameValuePairs, ","); //$NON-NLS-1$
-		Map parameters = new HashMap();
-		while (tokenizer.hasMoreTokens()) {
-			String nameValuePair = tokenizer.nextToken();
-			int colonIndex = nameValuePair.indexOf(":"); //$NON-NLS-1$
-			String name = nameValuePair.substring(0, colonIndex).trim();
-			String value = nameValuePair.substring(colonIndex + 1).trim();
-			parameters.put(name, value);
-		}
-		return new ParameterizedProvisioningAction(action, parameters);
-	}
-
-	private ProvisioningAction lookupAction(String actionId) {
-
-		ProvisioningAction action = phase.getAction(actionId);
-		if (action == null)
-			action = touchpoint.getAction(actionId);
-
-		if (action == null)
-			throw new IllegalArgumentException("No action found for " + actionId + "."); //$NON-NLS-2$
-
-		return action;
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ParameterizedProvisioningAction.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ParameterizedProvisioningAction.java
deleted file mode 100644
index 10f86b0..0000000
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ParameterizedProvisioningAction.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.eclipse.equinox.p2.engine;
-
-import java.util.*;
-import java.util.Map.Entry;
-import org.eclipse.core.runtime.IStatus;
-
-public class ParameterizedProvisioningAction extends ProvisioningAction {
-
-	private ProvisioningAction action;
-	private Map actionParameters;
-
-	public ParameterizedProvisioningAction(ProvisioningAction action, Map actionParameters) {
-		if (action == null || actionParameters == null)
-			throw new IllegalArgumentException("Both action and action pararameters must not be null.");
-		this.action = action;
-		this.actionParameters = actionParameters;
-	}
-
-	public IStatus execute(Map parameters) {
-		parameters = processActionParameters(parameters);
-		return action.execute(parameters);
-	}
-
-	public IStatus undo(Map parameters) {
-		parameters = processActionParameters(parameters);
-		return action.undo(parameters);
-	}
-
-	private Map processActionParameters(Map parameters) {
-		Map result = new HashMap(parameters);
-		for (Iterator it = actionParameters.entrySet().iterator(); it.hasNext();) {
-			Entry entry = (Entry) it.next();
-			String name = (String) entry.getKey();
-			String value = processVariables((String) entry.getValue(), parameters);
-			result.put(name, value);
-		}
-		return Collections.unmodifiableMap(result);
-	}
-
-	private String processVariables(String parameterValue, Map parameters) {
-
-		int variableBeginIndex = parameterValue.indexOf("${");
-		if (variableBeginIndex == -1)
-			return parameterValue;
-
-		int variableEndIndex = parameterValue.indexOf("}", variableBeginIndex + 2);
-		if (variableEndIndex == -1)
-			return parameterValue;
-
-		String preVariable = parameterValue.substring(0, variableBeginIndex);
-		String variableName = parameterValue.substring(variableBeginIndex + 2, variableEndIndex);
-		String variableValue = parameters.get(variableName).toString();
-		String postVariable = processVariables(parameterValue.substring(variableEndIndex + 1), parameters);
-		return preVariable + variableValue + postVariable;
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Profile.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Profile.java
index 578e18d..690e998 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Profile.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Profile.java
@@ -14,9 +14,9 @@ import org.eclipse.equinox.internal.p2.core.helpers.OrderedProperties;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.internal.p2.engine.EngineActivator;
 import org.eclipse.equinox.internal.p2.engine.Messages;
+import org.eclipse.equinox.internal.p2.installregistry.IInstallRegistry;
+import org.eclipse.equinox.internal.p2.installregistry.IProfileInstallRegistry;
 import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
-import org.eclipse.equinox.p2.installregistry.IInstallRegistry;
-import org.eclipse.equinox.p2.installregistry.IProfileInstallRegistry;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.p2.metadata.RequiredCapability;
 import org.eclipse.equinox.p2.query.IQueryable;
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ProvisioningConfigurationException.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ProvisioningConfigurationException.java
deleted file mode 100644
index 6ccf042..0000000
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/ProvisioningConfigurationException.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.engine;
-
-public class ProvisioningConfigurationException extends RuntimeException {
-
-	private static final long serialVersionUID = -712627437440533809L;
-
-	public ProvisioningConfigurationException(String name) {
-		super(name);
-	}
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/SimpleProfileRegistry.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/SimpleProfileRegistry.java
deleted file mode 100644
index f3009b6..0000000
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/SimpleProfileRegistry.java
+++ /dev/null
@@ -1,355 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: IBM Corporation - initial API and implementation
- ******************************************************************************/
-package org.eclipse.equinox.p2.engine;
-
-import java.io.*;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import javax.xml.parsers.ParserConfigurationException;
-import org.eclipse.equinox.internal.p2.core.helpers.OrderedProperties;
-import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
-import org.eclipse.equinox.internal.p2.engine.*;
-import org.eclipse.equinox.internal.p2.persistence.XMLWriter;
-import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
-import org.eclipse.equinox.p2.core.location.AgentLocation;
-import org.eclipse.osgi.service.datalocation.Location;
-import org.eclipse.osgi.service.resolver.VersionRange;
-import org.eclipse.osgi.util.NLS;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.Version;
-import org.xml.sax.*;
-
-public class SimpleProfileRegistry implements IProfileRegistry {
-	private static String STORAGE = "profileRegistry.xml"; //$NON-NLS-1$
-
-	/**
-	 * Map of String(Profile id)->Profile. 
-	 */
-	LinkedHashMap profiles = new LinkedHashMap(8);
-
-	OrderedProperties properties = new OrderedProperties();
-
-	private String self;
-
-	public SimpleProfileRegistry() {
-		self = EngineActivator.getContext().getProperty("eclipse.p2.profile"); //$NON-NLS-1$
-		restore();
-		updateRoamingProfile();
-	}
-
-	/**
-	 * If the current profile for self is marked as a roaming profile, we need
-	 * to update its install and bundle pool locations.
-	 */
-	private void updateRoamingProfile() {
-		Profile selfProfile = getProfile(SELF);
-		if (selfProfile == null)
-			return;
-		//only update if self is a roaming profile
-		if (!Boolean.valueOf(selfProfile.getValue(Profile.PROP_ROAMING)).booleanValue())
-			return;
-		Location installLocation = (Location) ServiceHelper.getService(EngineActivator.getContext(), Location.class.getName(), Location.INSTALL_FILTER);
-		String locationString = installLocation.getURL().getPath();
-		boolean changed = false;
-		if (!locationString.equals(selfProfile.getValue(Profile.PROP_INSTALL_FOLDER))) {
-			selfProfile.setValue(Profile.PROP_INSTALL_FOLDER, locationString);
-			changed = true;
-		}
-		if (!locationString.equals(selfProfile.getValue(Profile.PROP_CACHE))) {
-			selfProfile.setValue(Profile.PROP_CACHE, locationString);
-			changed = true;
-		}
-		if (changed)
-			persist();
-	}
-
-	public String toString() {
-		return this.profiles.toString();
-	}
-
-	public Profile getProfile(String id) {
-		if (SELF.equals(id))
-			id = self;
-		return (Profile) profiles.get(id);
-	}
-
-	public Profile[] getProfiles() {
-		return (Profile[]) profiles.values().toArray(new Profile[profiles.size()]);
-	}
-
-	public void addProfile(Profile toAdd) throws IllegalArgumentException {
-		if (isNamedSelf(toAdd))
-			throw new IllegalArgumentException(NLS.bind(Messages.Profile_Not_Named_Self, toAdd.getProfileId()));
-		String id = toAdd.getProfileId();
-		if (getProfile(id) == null) {
-			profiles.put(id, toAdd);
-		} else
-			throw new IllegalArgumentException(NLS.bind(Messages.Profile_Duplicate_Root_Profile_Id, id));
-		broadcastChangeEvent(toAdd, ProfileEvent.ADDED);
-		persist(); //TODO This is not enough to keep track of the changes that are being done in a profile. This will likely have to be based on some event like commit
-	}
-
-	private void broadcastChangeEvent(Profile profile, byte reason) {
-		((ProvisioningEventBus) ServiceHelper.getService(EngineActivator.getContext(), ProvisioningEventBus.class.getName())).publishEvent(new ProfileEvent(profile, reason));
-	}
-
-	private URL getRegistryLocation() {
-		AgentLocation agent = (AgentLocation) ServiceHelper.getService(EngineActivator.getContext(), AgentLocation.class.getName());
-		try {
-			return new URL(agent.getDataArea(EngineActivator.ID), STORAGE);
-		} catch (MalformedURLException e) {
-			//this is not possible because we know the above URL is valid
-		}
-		return null;
-	}
-
-	private void restore() {
-		try {
-			BufferedInputStream bif = null;
-			try {
-				bif = new BufferedInputStream(getRegistryLocation().openStream());
-				Parser parser = new Parser(EngineActivator.getContext(), EngineActivator.ID);
-				parser.parse(bif);
-			} finally {
-				if (bif != null)
-					bif.close();
-			}
-		} catch (FileNotFoundException e) {
-			//This is ok.
-		} catch (IOException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-	}
-
-	private void persist() {
-		OutputStream os;
-		try {
-			Location agent = (Location) ServiceHelper.getService(EngineActivator.getContext(), AgentLocation.class.getName());
-			if (agent == null)
-				// TODO should likely do something here since we failed to persist.
-				return;
-
-			URL registryLocation = getRegistryLocation();
-			if (!registryLocation.getProtocol().equals("file")) //$NON-NLS-1$
-				throw new IOException(NLS.bind(Messages.SimpleProfileRegistry_Persist_To_Non_File_URL_Error, registryLocation));
-
-			File outputFile = new File(registryLocation.toExternalForm().substring(5));
-			if (!outputFile.getParentFile().exists() && !outputFile.getParentFile().mkdirs())
-				throw new RuntimeException(NLS.bind(Messages.SimpleProfileRegistry_Cannot_Create_File_Error, outputFile));
-			os = new BufferedOutputStream(new FileOutputStream(outputFile));
-			try {
-				Writer writer = new Writer(os);
-				writer.write(this);
-			} finally {
-				os.close();
-			}
-		} catch (FileNotFoundException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		} catch (IOException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-
-	}
-
-	public void removeProfile(Profile toRemove) {
-		if (isNamedSelf(toRemove))
-			throw new IllegalArgumentException(NLS.bind(Messages.Profile_Not_Named_Self, toRemove.getProfileId()));
-		if (profiles.remove(toRemove.getProfileId()) == null)
-			return;
-		broadcastChangeEvent(toRemove, ProfileEvent.REMOVED);
-		persist();
-	}
-
-	private boolean isNamedSelf(Profile p) {
-		if (SELF.equals(p.getParentProfile()))
-			return true;
-		return false;
-	}
-
-	public Map getProperties() {
-		return properties;
-	}
-
-	public String getProperty(String key) {
-		return properties.getProperty(key);
-	}
-
-	public void setProperty(String key, String value) {
-		properties.setProperty(key, value);
-	}
-
-	public void removeProperty(String key) {
-		properties.remove(key);
-	}
-
-	private SimpleProfileRegistry getRegistry() {
-		return this;
-	}
-
-	private interface XMLConstants extends org.eclipse.equinox.internal.p2.persistence.XMLConstants {
-
-		// Constants defining the structure of the XML for a SimpleProfileRegistry
-
-		// A format version number for simple profile registry XML.
-		public static final String XML_CURRENT = "0.0.2"; //$NON-NLS-1$
-		public static final Version CURRENT_VERSION = new Version(XML_CURRENT);
-		public static final String XML_COMPATIBLE = "0.0.1"; //$NON-NLS-1$
-		public static final Version COMPATIBLE_VERSION = new Version(XML_CURRENT);
-		public static final VersionRange XML_TOLERANCE = new VersionRange(COMPATIBLE_VERSION, true, CURRENT_VERSION, true);
-
-		// Constants for processing instructions
-		public static final String PI_REPOSITORY_TARGET = "profileRegistry"; //$NON-NLS-1$
-		public static XMLWriter.ProcessingInstruction[] PI_DEFAULTS = new XMLWriter.ProcessingInstruction[] {XMLWriter.ProcessingInstruction.makeClassVersionInstruction(PI_REPOSITORY_TARGET, SimpleProfileRegistry.class, CURRENT_VERSION)};
-
-		// Constants for profile registry elements
-		public static final String REGISTRY_ELEMENT = "profileRegistry"; //$NON-NLS-1$
-
-	}
-
-	protected class Writer extends ProfileWriter implements XMLConstants {
-
-		public Writer(OutputStream output) throws IOException {
-			super(output, PI_DEFAULTS);
-		}
-
-		/**
-		 * Write the given SimpleProfileRegistry to the output stream.
-		 */
-		public void write(SimpleProfileRegistry registry) {
-			start(REGISTRY_ELEMENT);
-			writeProperties(registry.getProperties());
-			writeProfiles(registry.getProfiles());
-			end(REGISTRY_ELEMENT);
-			flush();
-		}
-	}
-
-	/*
-	 * 	Parser for the contents of a SimpleProfileRegistry,
-	 * 	as written by the Writer class.
-	 */
-	private class Parser extends ProfileParser implements XMLConstants {
-
-		public Parser(BundleContext context, String bundleId) {
-			super(context, bundleId);
-		}
-
-		public void parse(File file) throws IOException {
-			parse(new FileInputStream(file));
-		}
-
-		public synchronized void parse(InputStream stream) throws IOException {
-			this.status = null;
-			try {
-				// TODO: currently not caching the parser since we make no assumptions
-				//		 or restrictions on concurrent parsing
-				getParser();
-				RegistryHandler registryHandler = new RegistryHandler();
-				xmlReader.setContentHandler(new ProfileRegistryDocHandler(REGISTRY_ELEMENT, registryHandler));
-				xmlReader.parse(new InputSource(stream));
-			} catch (SAXException e) {
-				throw new IOException(e.getMessage());
-			} catch (ParserConfigurationException e) {
-				throw new IOException(e.getMessage());
-			} finally {
-				stream.close();
-			}
-		}
-
-		public SimpleProfileRegistry getContainingRegistry() {
-			return getRegistry();
-		}
-
-		protected Object getRootObject() {
-			return getRegistry();
-		}
-
-		private final class ProfileRegistryDocHandler extends DocHandler {
-
-			public ProfileRegistryDocHandler(String rootName, RootHandler rootHandler) {
-				super(rootName, rootHandler);
-			}
-
-			public void ProcessingInstruction(String target, String data) throws SAXException {
-				if (PI_REPOSITORY_TARGET.equals(target)) {
-					// TODO: should the root handler be constructed based on class
-					// 		 via an extension registry mechanism?
-					// String clazz = extractPIClass(data);
-					// and
-					// TODO: version tolerance by extension
-					Version repositoryVersion = extractPIVersion(target, data);
-					if (!XMLConstants.XML_TOLERANCE.isIncluded(repositoryVersion)) {
-						throw new SAXException(NLS.bind(Messages.SimpleProfileRegistry_Parser_Has_Incompatible_Version, repositoryVersion, XMLConstants.XML_TOLERANCE));
-					}
-				}
-			}
-
-		}
-
-		private final class RegistryHandler extends RootHandler {
-
-			private ProfilesHandler profilesHandler = null;
-			private PropertiesHandler propertiesHandler = null;
-
-			public RegistryHandler() {
-				super();
-			}
-
-			protected void handleRootAttributes(Attributes attributes) {
-				parseRequiredAttributes(attributes, noAttributes);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (PROPERTIES_ELEMENT.equals(name)) {
-					if (propertiesHandler == null) {
-						propertiesHandler = new PropertiesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (PROFILES_ELEMENT.equals(name)) {
-					if (profilesHandler == null) {
-						profilesHandler = new ProfilesHandler(this, attributes, null /*no parent*/);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			protected void finished() {
-				if (isValidXML()) {
-					Profile[] profyles = (profilesHandler == null ? new Profile[0] //
-							: profilesHandler.getProfiles());
-					for (int i = 0; i < profyles.length; i++) {
-						Profile nextProfile = profyles[i];
-						profiles.put(nextProfile.getProfileId(), nextProfile);
-					}
-					properties = (propertiesHandler == null ? new OrderedProperties(0) //
-							: propertiesHandler.getProperties());
-				}
-			}
-		}
-
-		protected String getErrorMessage() {
-			return Messages.SimpleProfileRegistry_Parser_Error_Parsing_Registry;
-		}
-
-		public String toString() {
-			// TODO:
-			return null;
-		}
-
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/IInstallRegistry.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/IInstallRegistry.java
deleted file mode 100644
index bf5b6b4..0000000
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/IInstallRegistry.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.installregistry;
-
-import java.util.Collection;
-import org.eclipse.equinox.p2.engine.Profile;
-
-public interface IInstallRegistry {
-
-	/**
-	 * Save the registry as XML.  If exception is thrown, no change was made.
-	 */
-	//	public void saveXML() throws IOException {
-	//		checkMetadata();
-	//		File xmlFile = getLocation();
-	//		plog.start(plog.debug("Saving {0}", xmlFile)); //$NON-NLS-1$
-	//		if (isEmpty()) { // delete when empty
-	//			xmlFile.delete();
-	//			if (xmlFile.exists()) {
-	//				throw new IOException(NLS.bind(Messages.InstallRegistry_Failed_To_Delete_Install_Registry, xmlFile));
-	//			}
-	//		} else {
-	//			new FileUtil.SafeUpdate(xmlFile) {
-	//				public void write(FileOutputStream stream) throws IOException {
-	//					XMLWriter writer = new XMLWriter(stream, XML.getProcessingInstruction());
-	//					XML.write(writer);
-	//					writer.flush();
-	//					stream.getFD().sync();
-	//					writer.close();
-	//				}
-	//			}.write();
-	//		}
-	//		plog.stop();
-	//	}
-	//	private static class XML implements InstallRegistryXML {
-	//		public static XMLWriter.ProcessingInstruction getProcessingInstruction() {
-	//			return new XMLWriter.ProcessingInstruction(PI.INSTALL_REGISTRY, MetaInfo.formatVersion(MetaInfo.INSTALL_REGISTRY_VERSION));
-	//		}
-	//
-	//		public static void write(XMLWriter writer) {
-	//			InstallRegistry ir = InstallRegistry.getInstance();
-	//			writer.start(Elements.INSTALL_REGISTRY);
-	//			writer.write(ir.profileRegistry.getProperties());
-	//			for (Iterator i = ir.getProfileInstallRegistries().iterator(); i.hasNext();) {
-	//				ProfileInstallRegistry registry = (ProfileInstallRegistry) i.next();
-	//				if (!registry.isEmpty()) {
-	//					writer.start(Elements.PROFILE);
-	//					Profile profile = registry.getProfile();
-	//					writer.attribute(Attrs.ID, profile.getProfileId());
-	//					writer.attribute(Attrs.KIND, profile.getProfileKind());
-	//					writer.writeProperty(Profile.INSTALL_LOCATION, profile.getInstallLocation());
-	//					writer.write(profile.getAllData());
-	//					InstallContext rootContext = profile.getRootContext();
-	//					if (rootContext != null) {
-	//						write(writer, rootContext);
-	//					}
-	//					registry.emitXML(writer);
-	//					writer.end(Elements.PROFILE);
-	//				}
-	//			}
-	//			writer.end(Elements.INSTALL_REGISTRY);
-	//		}
-	//
-	//		private static void write(XMLWriter writer, InstallContext installContext) {
-	//			writer.start(Elements.INSTALL_CONTEXT);
-	//			writer.attribute(Attrs.ID, installContext.getId());
-	//			writer.attribute(Attrs.NAME, installContext.getName());
-	//			writer.attribute(Attrs.DESCRIPTION, installContext.getDescription());
-	//			writer.attribute(Attrs.SHAREABLE, installContext.isShareable(), true);
-	//			writer.attribute(Attrs.QUALIFIABLE, installContext.isQualifiable(), false);
-	//			InstallationContextScope scope = installContext.getScope();
-	//			if (scope != InstallationContextScope.NONE_SCOPE) {
-	//				writer.attribute(Attrs.SCOPE, scope.getName());
-	//			}
-	//			writer.write(installContext.getLocalProperties());
-	//			String[] adapterTypes = installContext.getAdaptorTypes();
-	//			for (int i = 0; i < adapterTypes.length; i += 1) {
-	//				writer.start(Elements.ADAPTER);
-	//				writer.attribute(Attrs.TYPE, adapterTypes[i]);
-	//				writer.end();
-	//			}
-	//			InstallContext[] subcontexts = installContext.getSubcontexts();
-	//			for (int i = 0; i < subcontexts.length; i += 1) {
-	//				write(writer, subcontexts[i]);
-	//			}
-	//			writer.end(Elements.INSTALL_CONTEXT);
-	//		}
-	//	}
-	//	/**
-	//	 * The file of the install registry.
-	//	 */
-	//	public File getLocation() {
-	//		return this.location;
-	//	}
-	//	// The location of the old install registry directory.
-	//	// This is where the metadata is still stored.
-	//	private File getLegacyLocation(String subdir) {
-	//		String path = getLocation().getPath();
-	//		if (path.endsWith(CommonDef.Extensions.Xml)) {
-	//			path = path.substring(0, path.length() - CommonDef.Extensions.Xml.length());
-	//		} else {
-	//			path += ".dir"; //$NON-NLS-1$
-	//		}
-	//		return new File(path, subdir);
-	//	}
-	public abstract IProfileInstallRegistry getProfileInstallRegistry(Profile profile);
-
-	/**
-	 * Open the install registry.  It must be open before any operations can be performed.
-	 */
-	//	public void open() throws IOException {
-	//		//		openFile(Agent.getInstance().getInstallRegistryLocation());
-	//	}
-	//
-	//	// This form is for AbstractAgentTestCase because the preferences aren't set correctly
-	//	// when it needs the install registry.
-	//	public void open(File dir) throws IOException {
-	//		openFile(new File(dir, Agent.FILENAME_INSTALL_REGISTRY));
-	//	}
-	//
-	//	private void openFile(File file) throws IOException {
-	//		if (isOpen()) {
-	//			throw new InstallRegistryException(Messages2.InstallRegistry_Install_Registry_Is_Already_Open);
-	//		}
-	//		this.location = file;
-	//		if (this.location.isDirectory()) {
-	//			throw new InstallRegistryException(NLS.bind(Messages2.InstallRegistry_Install_Registry_Exists_And_Is_A_Directory, this.location));
-	//		} else if (!this.location.exists()) {
-	//			// verify we can write it
-	//			this.location.getParentFile().mkdirs();
-	//			new FileOutputStream(this.location).close();
-	//			this.location.delete();
-	//		}
-	//
-	//		// TODO: move to cache
-	//		File metadataDir = getLegacyLocation(METADATA_DIR);
-	//		try {
-	//			this.metadataRepo = StandardRepository.create(this.installedMetadata.getRepositoryGroup(), metadataDir);
-	//		} catch (RuntimeException e) {
-	//			// report error below
-	//		}
-	//		if (this.metadataRepo == null) {
-	//			throw new InstallRegistryException(NLS.bind(Messages.InstallRegistry_Failed_To_Create_Install_Registry_Repo, metadataDir));
-	//		}
-	//		this.metadataRepo.setOpen(true);
-	//		load();
-	//		checkMetadata();
-	//	}
-	//
-	//	public void close() {
-	//		this.installedMetadata.getRepositoryGroup().removeRepository(this.metadataRepo);
-	//		this.metadataRepo = null;
-	//		if (isEmpty()) {
-	//			purge();
-	//		}
-	//	}
-	//	public void purge() {
-	//		getLocation().delete();
-	//		FileUtil.rm_r(getLegacyLocation(""), /*removeRoot*/true); //$NON-NLS-1$
-	//	}
-	public abstract Collection getProfileInstallRegistries();
-
-}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/IProfileInstallRegistry.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/IProfileInstallRegistry.java
deleted file mode 100644
index e0b778a..0000000
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/IProfileInstallRegistry.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.installregistry;
-
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-
-public interface IProfileInstallRegistry {
-
-	public IInstallableUnit[] getInstallableUnits();
-
-	public IInstallableUnit getInstallableUnit(String id, String version);
-
-	public void addInstallableUnits(IInstallableUnit toAdd);
-
-	public void removeInstallableUnits(IInstallableUnit toRemove);
-
-	public String getProfileId();
-
-	public String getInstallableUnitProfileProperty(IInstallableUnit iu, String key);
-
-	public String setInstallableUnitProfileProperty(IInstallableUnit iu, String key, String value);
-
-}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/InstallRegistry.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/InstallRegistry.java
deleted file mode 100644
index 78af1f0..0000000
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/InstallRegistry.java
+++ /dev/null
@@ -1,614 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.installregistry;
-
-import java.io.*;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.*;
-import javax.xml.parsers.ParserConfigurationException;
-import org.eclipse.equinox.internal.p2.core.helpers.OrderedProperties;
-import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
-import org.eclipse.equinox.internal.p2.engine.EngineActivator;
-import org.eclipse.equinox.internal.p2.engine.Messages;
-import org.eclipse.equinox.internal.p2.metadata.repository.io.MetadataParser;
-import org.eclipse.equinox.internal.p2.metadata.repository.io.MetadataWriter;
-import org.eclipse.equinox.internal.p2.persistence.XMLWriter;
-import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
-import org.eclipse.equinox.p2.core.eventbus.SynchronousProvisioningListener;
-import org.eclipse.equinox.p2.core.location.AgentLocation;
-import org.eclipse.equinox.p2.engine.*;
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.osgi.service.resolver.VersionRange;
-import org.eclipse.osgi.util.NLS;
-import org.osgi.framework.*;
-import org.xml.sax.*;
-
-public class InstallRegistry implements IInstallRegistry {
-	private static String STORAGE = "installRegistry.xml"; //$NON-NLS-1$
-
-	// what is installed in each profile
-	Map profileRegistries = new LinkedHashMap(); // Profile id -> ProfileInstallRegistry
-	//	private ProfileRegistry profileRegistry; // the corresponding ProfileRegistry
-	//	private File location; // XML file containing install registry
-	//	private IRepository metadataRepo;
-	//	private final MetadataCache installedMetadata = new MetadataCache(
-	//            new RepositoryGroup("InstallRegistry"), //$NON-NLS-1$
-	//            MetadataCache.POLICY_NONE);
-
-	private transient ServiceReference busReference;
-	private transient ProvisioningEventBus bus;
-
-	public InstallRegistry() {
-		busReference = EngineActivator.getContext().getServiceReference(ProvisioningEventBus.class.getName());
-		bus = (ProvisioningEventBus) EngineActivator.getContext().getService(busReference);
-		restore();
-		bus.addListener(new SynchronousProvisioningListener() {
-			public void notify(EventObject o) {
-				if (o instanceof InstallableUnitEvent) {
-					InstallableUnitEvent event = (InstallableUnitEvent) o;
-					if (event.isPre() || !event.getResult().isOK())
-						return;
-					IProfileInstallRegistry registry = getProfileInstallRegistry(event.getProfile());
-					if (event.isInstall() && event.getOperand().second() != null) {
-						registry.addInstallableUnits(event.getOperand().second().unresolved());
-					} else if (event.isUninstall() && event.getOperand().first() != null) {
-						IInstallableUnit original = event.getOperand().first().unresolved();
-						String value = registry.getInstallableUnitProfileProperty(original, IInstallableUnit.PROP_PROFILE_ROOT_IU);
-						boolean isRoot = value != null && value.equals(Boolean.toString(true));
-						registry.removeInstallableUnits(original);
-						// TODO this is odd because I'm setting up a property for something
-						// not yet installed in the registry.  The implementation allows it and
-						// the assumption is that the second operand will get installed or else 
-						// this change will never be committed.  The alternative is to remember
-						// a transitory root value that we set when the install is received.
-						// The ideal solution is that this is handled in a profile delta by
-						// the engine.
-						// https://bugs.eclipse.org/bugs/show_bug.cgi?id=206077 
-						if (isRoot && event.getOperand().second() != null) {
-							registry.setInstallableUnitProfileProperty(event.getOperand().second().unresolved(), IInstallableUnit.PROP_PROFILE_ROOT_IU, Boolean.toString(true));
-						}
-					}
-				} else if (o instanceof CommitOperationEvent) {
-					persist();
-					return;
-				} else if (o instanceof RollbackOperationEvent) {
-					restore();
-					return;
-				} else if (o instanceof ProfileEvent) {
-					ProfileEvent pe = (ProfileEvent) o;
-					if (pe.getReason() == ProfileEvent.REMOVED) {
-						profileRegistries.remove(pe.getProfile().getProfileId());
-						persist();
-					} else if (pe.getReason() == ProfileEvent.CHANGED) {
-						// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=197701
-						persist();
-					}
-				}
-			}
-		});
-	}
-
-	synchronized void persist() {
-		try {
-			BufferedOutputStream bof = null;
-			try {
-				URL registryLocation = getRegistryLocation();
-				if (!registryLocation.getProtocol().equals("file")) //$NON-NLS-1$
-					throw new IOException("Can't write install registry at: " + registryLocation);
-				File outputFile = new File(registryLocation.toExternalForm().substring(5));
-				if (!outputFile.getParentFile().exists() && !outputFile.getParentFile().mkdirs())
-					throw new RuntimeException("Can't persist profile registry");
-				bof = new BufferedOutputStream(new FileOutputStream(outputFile, false));
-				Writer writer = new Writer(bof);
-				writer.write(this);
-			} finally {
-				if (bof != null)
-					bof.close();
-			}
-		} catch (FileNotFoundException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		} catch (IOException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-	}
-
-	synchronized void restore() {
-		try {
-			BufferedInputStream bif = null;
-			try {
-				bif = new BufferedInputStream(getRegistryLocation().openStream());
-				Parser parser = new Parser(EngineActivator.getContext(), EngineActivator.ID);
-				parser.parse(bif);
-				profileRegistries = parser.getProfileInstallRegistries();
-			} finally {
-				if (bif != null)
-					bif.close();
-			}
-		} catch (FileNotFoundException e) {
-			//This is ok.
-		} catch (IOException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-	}
-
-	public IProfileInstallRegistry getProfileInstallRegistry(Profile profile) {
-		String profileId = profile.getProfileId();
-		IProfileInstallRegistry result = (IProfileInstallRegistry) this.profileRegistries.get(profileId);
-		if (result == null) {
-			result = new ProfileInstallRegistry(profileId);
-			this.profileRegistries.put(profileId, result);
-		}
-		return result;
-	}
-
-	public Collection getProfileInstallRegistries() {
-		return this.profileRegistries.values();
-	}
-
-	public InstallRegistry getInstallRegistry() {
-		return this;
-	}
-
-	private URL getRegistryLocation() {
-		AgentLocation agent = (AgentLocation) ServiceHelper.getService(EngineActivator.getContext(), AgentLocation.class.getName());
-		try {
-			return new URL(agent.getDataArea(EngineActivator.ID), STORAGE);
-		} catch (MalformedURLException e) {
-			//this is not possible because we know the above URL is valid
-		}
-		return null;
-	}
-
-	class IUIdentity {
-
-		String id;
-		Version version;
-
-		public IUIdentity(String id, Version version) {
-			this.id = (id != null ? id : ""); //$NON-NLS-1$
-			this.version = (version != null ? version : Version.emptyVersion);
-		}
-
-		public IUIdentity(IInstallableUnit iu) {
-			this(iu.getId(), iu.getVersion());
-		}
-
-		public String toString() {
-			return id + ' ' + version;
-		}
-
-		public int hashCode() {
-			final int prime = 31;
-			int result = 1;
-			result = prime * result + ((id == null) ? 0 : id.hashCode());
-			result = prime * result + ((version == null) ? 0 : version.hashCode());
-			return result;
-		}
-
-		public boolean equals(Object obj) {
-			final IUIdentity objAsIdentity = //
-			(obj instanceof IUIdentity ? (IUIdentity) obj : null);
-			if (objAsIdentity != null) {
-				return this.id.equals(objAsIdentity.id) && this.version.equals(objAsIdentity.version);
-			}
-			return false;
-		}
-	}
-
-	/**
-	 * Install registry for a single profile.
-	 */
-	public class ProfileInstallRegistry implements IProfileInstallRegistry {
-		private String profileId; // id profile this data applies to
-		Set installableUnits; //id 
-		private Map iuPropertiesMap; // iu->OrderedProperties
-
-		public ProfileInstallRegistry(String profileId) {
-			this.profileId = profileId;
-			this.installableUnits = new LinkedHashSet();
-			this.iuPropertiesMap = new LinkedHashMap();
-		}
-
-		protected ProfileInstallRegistry(String profileId, IInstallableUnit[] units, Map iuPropertiesMap) {
-			this.profileId = profileId;
-			this.installableUnits = new LinkedHashSet(units.length);
-			this.iuPropertiesMap = new LinkedHashMap(iuPropertiesMap.size());
-			addInstallableUnits(units);
-			this.iuPropertiesMap.putAll(iuPropertiesMap);
-		}
-
-		public IInstallableUnit[] getInstallableUnits() {
-			IInstallableUnit[] result = new IInstallableUnit[installableUnits.size()];
-			return (IInstallableUnit[]) installableUnits.toArray(result);
-		}
-
-		public void addInstallableUnits(IInstallableUnit toAdd) {
-			installableUnits.add(toAdd);
-		}
-
-		public void addInstallableUnits(IInstallableUnit[] toAdd) {
-			for (int i = 0; i < toAdd.length; i++) {
-				installableUnits.add(toAdd[i]);
-			}
-		}
-
-		public void removeInstallableUnits(IInstallableUnit toRemove) {
-			installableUnits.remove(toRemove);
-			iuPropertiesMap.remove(new IUIdentity(toRemove));
-		}
-
-		public String getProfileId() {
-			return profileId;
-		}
-
-		public IInstallableUnit getInstallableUnit(String id, String version) {
-			for (Iterator i = installableUnits.iterator(); i.hasNext();) {
-				IInstallableUnit iu = (IInstallableUnit) i.next();
-				if (iu.getId().equals(id) && iu.getVersion().equals(new Version(version)))
-					return iu;
-			}
-			return null;
-		}
-
-		public String getInstallableUnitProfileProperty(IInstallableUnit toGet, String key) {
-			OrderedProperties properties = getInstallableUnitProfileProperties(toGet);
-			return properties.getProperty(key);
-		}
-
-		public String setInstallableUnitProfileProperty(IInstallableUnit toSet, String key, String value) {
-			OrderedProperties properties = getInstallableUnitProfileProperties(toSet);
-			return (String) properties.setProperty(key, value);
-		}
-
-		private OrderedProperties getInstallableUnitProfileProperties(IInstallableUnit toGet) {
-			OrderedProperties properties = (OrderedProperties) iuPropertiesMap.get(new IUIdentity(toGet));
-			if (properties == null) {
-				properties = new OrderedProperties();
-				iuPropertiesMap.put(new IUIdentity(toGet), properties);
-			}
-			return properties;
-		}
-
-		public Map getIUIdentityToPropertiesMap() {
-			return Collections.unmodifiableMap(iuPropertiesMap);
-		}
-	}
-
-	private interface XMLConstants extends org.eclipse.equinox.internal.p2.persistence.XMLConstants {
-
-		// Constants defining the structure of the XML for a SimpleProfileRegistry
-
-		// A format version number for install registry XML.
-		public static final String XML_VERSION = "0.0.1"; //$NON-NLS-1$
-		public static final Version CURRENT_VERSION = new Version(XML_VERSION);
-		public static final VersionRange XML_TOLERANCE = new VersionRange(CURRENT_VERSION, true, CURRENT_VERSION, true);
-
-		// Constants for processing instructions
-		public static final String PI_REPOSITORY_TARGET = "installRegistry"; //$NON-NLS-1$
-		public static XMLWriter.ProcessingInstruction[] PI_DEFAULTS = new XMLWriter.ProcessingInstruction[] {XMLWriter.ProcessingInstruction.makeClassVersionInstruction(PI_REPOSITORY_TARGET, SimpleProfileRegistry.class, CURRENT_VERSION)};
-
-		// Constants for install registry elements
-		public static final String INSTALL_REGISTRY_ELEMENT = "installRegistry"; //$NON-NLS-1$
-		public static final String PROFILE_INSTALL_REGISTRIES_ELEMENT = "profiles"; //$NON-NLS-1$
-		public static final String PROFILE_INSTALL_REGISTRY_ELEMENT = "profile"; //$NON-NLS-1$
-		public static final String IUS_PROPERTIES_ELEMENT = "iusPropertiesMap"; //$NON-NLS-1$
-		public static final String IU_PROPERTIES_ELEMENT = "iusProperties"; //$NON-NLS-1$
-
-		// Constants for attributes of an profile install registry element
-		public static final String PROFILE_ID_ATTRIBUTE = "profileId"; //$NON-NLS-1$
-
-	}
-
-	protected class Writer extends MetadataWriter implements XMLConstants {
-
-		public Writer(OutputStream output) throws IOException {
-			super(output, PI_DEFAULTS);
-		}
-
-		/**
-		 * Write the given artifact repository to the output stream.
-		 */
-		public void write(InstallRegistry istregistryry) {
-			start(INSTALL_REGISTRY_ELEMENT);
-			writeProfileRegistries(istregistryry.profileRegistries);
-			end(INSTALL_REGISTRY_ELEMENT);
-			flush();
-		}
-
-		private void writeProfileRegistries(Map registries) {
-			if (registries.size() > 0) {
-				start(PROFILE_INSTALL_REGISTRIES_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, registries.size());
-				for (Iterator iter = registries.keySet().iterator(); iter.hasNext();) {
-					String nextProfileId = (String) iter.next();
-					ProfileInstallRegistry nextProfileRegistry = (ProfileInstallRegistry) registries.get(nextProfileId);
-					writeProfileRegistry(nextProfileId, nextProfileRegistry);
-				}
-				end(PROFILE_INSTALL_REGISTRIES_ELEMENT);
-			}
-		}
-
-		private void writeProfileRegistry(String profileId, ProfileInstallRegistry profileRegistry) {
-			start(PROFILE_INSTALL_REGISTRY_ELEMENT);
-			attribute(PROFILE_ID_ATTRIBUTE, profileId);
-			Set ius = profileRegistry.installableUnits;
-			writeInstallableUnits((IInstallableUnit[]) ius.toArray(new IInstallableUnit[ius.size()]));
-			writeIUPropertyMap(profileRegistry.getIUIdentityToPropertiesMap());
-			end(PROFILE_INSTALL_REGISTRY_ELEMENT);
-		}
-
-		private void writeIUPropertyMap(Map iuPropertiesMap) {
-			if (iuPropertiesMap.size() > 0) {
-				start(IUS_PROPERTIES_ELEMENT);
-				attribute(COLLECTION_SIZE_ATTRIBUTE, iuPropertiesMap.size());
-				for (Iterator iter = iuPropertiesMap.keySet().iterator(); iter.hasNext();) {
-					IUIdentity nextIdentity = (IUIdentity) iter.next();
-					OrderedProperties properties = (OrderedProperties) iuPropertiesMap.get(nextIdentity);
-					start(IU_PROPERTIES_ELEMENT);
-					attribute(ID_ATTRIBUTE, nextIdentity.id);
-					attribute(VERSION_ATTRIBUTE, nextIdentity.version);
-					writeProperties(properties);
-					end(IU_PROPERTIES_ELEMENT);
-				}
-				end(IUS_PROPERTIES_ELEMENT);
-			}
-		}
-	}
-
-	/*
-	 * 	Parser for the contents of an InstallRegistry,
-	 * 	as written by the Writer class.
-	 */
-	private class Parser extends MetadataParser implements XMLConstants {
-
-		private Map profileInstallRegistries = null;
-
-		public Parser(BundleContext context, String bundleId) {
-			super(context, bundleId);
-		}
-
-		public void parse(File file) throws IOException {
-			parse(new FileInputStream(file));
-		}
-
-		public synchronized void parse(InputStream stream) throws IOException {
-			this.status = null;
-			try {
-				// TODO: currently not caching the parser since we make no assumptions
-				//		 or restrictions on concurrent parsing
-				getParser();
-				InstallRegistryHandler registryHandler = new InstallRegistryHandler();
-				xmlReader.setContentHandler(new InstallRegistryDocHandler(INSTALL_REGISTRY_ELEMENT, registryHandler));
-				xmlReader.parse(new InputSource(stream));
-				if (this.isValidXML()) {
-					profileInstallRegistries = registryHandler.getProfileInstallRegistries();
-				}
-			} catch (SAXException e) {
-				throw new IOException(e.getMessage());
-			} catch (ParserConfigurationException e) {
-				throw new IOException(e.getMessage());
-			} finally {
-				stream.close();
-			}
-		}
-
-		public Map getProfileInstallRegistries() {
-			return profileInstallRegistries;
-		}
-
-		protected Object getRootObject() {
-			return profileInstallRegistries;
-		}
-
-		private final class InstallRegistryDocHandler extends DocHandler {
-
-			public InstallRegistryDocHandler(String rootName, RootHandler rootHandler) {
-				super(rootName, rootHandler);
-			}
-
-			public void ProcessingInstruction(String target, String data) throws SAXException {
-				if (PI_REPOSITORY_TARGET.equals(target)) {
-					// TODO: should the root handler be constructed based on class
-					// 		 or via an extension registry mechanism?
-					// String clazz = extractPIClass(data);
-					// and
-					// TODO: version tolerance by extension or by class?
-					Version repositoryVersion = extractPIVersion(target, data);
-					if (!XMLConstants.XML_TOLERANCE.isIncluded(repositoryVersion)) {
-						throw new SAXException(NLS.bind(Messages.InstallRegistry_Parser_Has_Incompatible_Version, repositoryVersion, XMLConstants.XML_TOLERANCE));
-					}
-				}
-			}
-		}
-
-		private final class InstallRegistryHandler extends RootHandler {
-
-			private ProfileInstallRegistriesHandler profilesHandler = null;
-
-			private Map profyleRegistries = null;
-
-			public InstallRegistryHandler() {
-				super();
-			}
-
-			protected void handleRootAttributes(Attributes attributes) {
-				parseRequiredAttributes(attributes, noAttributes);
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (PROFILE_INSTALL_REGISTRIES_ELEMENT.equals(name)) {
-					if (profilesHandler == null) {
-						profilesHandler = new ProfileInstallRegistriesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			public Map getProfileInstallRegistries() {
-				return (profyleRegistries != null ? profyleRegistries : new LinkedHashMap(0));
-			}
-
-			protected void finished() {
-				if (isValidXML()) {
-					ProfileInstallRegistry[] registries = (profilesHandler == null ? new ProfileInstallRegistry[0] //
-							: profilesHandler.getProfileInstallRegistries());
-					profyleRegistries = new LinkedHashMap(registries.length);
-					for (int i = 0; i < registries.length; i++) {
-						ProfileInstallRegistry nextProfileRegistry = registries[i];
-						profyleRegistries.put(nextProfileRegistry.getProfileId(), nextProfileRegistry);
-					}
-				}
-			}
-		}
-
-		protected class ProfileInstallRegistriesHandler extends AbstractHandler {
-
-			private List registries = null;
-
-			public ProfileInstallRegistriesHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, PROFILE_INSTALL_REGISTRIES_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				registries = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equals(PROFILE_INSTALL_REGISTRY_ELEMENT)) {
-					new ProfileInstallRegistryHandler(this, attributes, registries);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			public ProfileInstallRegistry[] getProfileInstallRegistries() {
-				return (ProfileInstallRegistry[]) registries.toArray(new ProfileInstallRegistry[registries.size()]);
-			}
-		}
-
-		protected class ProfileInstallRegistryHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {PROFILE_ID_ATTRIBUTE};
-
-			List registries = null;
-
-			private String profileId = null;
-
-			private InstallableUnitsHandler unitsHandler = null;
-			private IUsPropertiesHandler iusPropertiesHandler = null;
-
-			public ProfileInstallRegistryHandler(AbstractHandler parentHandler, Attributes attributes, List registries) {
-				super(parentHandler, PROFILE_INSTALL_REGISTRY_ELEMENT);
-				profileId = parseRequiredAttributes(attributes, required)[0];
-				this.registries = registries;
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (INSTALLABLE_UNITS_ELEMENT.equals(name)) {
-					if (unitsHandler == null) {
-						unitsHandler = new InstallableUnitsHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else if (IUS_PROPERTIES_ELEMENT.equals(name)) {
-					if (iusPropertiesHandler == null) {
-						iusPropertiesHandler = new IUsPropertiesHandler(this, attributes);
-					} else {
-						duplicateElement(this, name, attributes);
-					}
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			protected void finished() {
-				if (isValidXML() && profileId != null) {
-					IInstallableUnit[] units = (unitsHandler == null ? new IInstallableUnit[0] //
-							: unitsHandler.getUnits());
-					Map iusPropertiesMap = (iusPropertiesHandler == null ? new LinkedHashMap() //
-							: iusPropertiesHandler.getIUsPropertiesMap());
-					ProfileInstallRegistry registry = new ProfileInstallRegistry(profileId, units, iusPropertiesMap);
-					registries.add(registry);
-				}
-			}
-		}
-
-		protected class IUsPropertiesHandler extends AbstractHandler {
-
-			private Map iusPropertiesMap;
-
-			public IUsPropertiesHandler(AbstractHandler parentHandler, Attributes attributes) {
-				super(parentHandler, IUS_PROPERTIES_ELEMENT);
-				String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
-				iusPropertiesMap = (size != null ? new LinkedHashMap(new Integer(size).intValue()) : new LinkedHashMap(4));
-			}
-
-			public Map getIUsPropertiesMap() {
-				return iusPropertiesMap;
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equals(IU_PROPERTIES_ELEMENT)) {
-					new IUPropertiesHandler(this, attributes, iusPropertiesMap);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-		}
-
-		protected class IUPropertiesHandler extends AbstractHandler {
-
-			private final String[] required = new String[] {ID_ATTRIBUTE, VERSION_ATTRIBUTE};
-
-			private IUIdentity iuIdentity = null;
-			private PropertiesHandler propertiesHandler = null;
-			private Map iusPropertiesMap = null;
-
-			public IUPropertiesHandler(AbstractHandler parentHandler, Attributes attributes, Map iusPropertiesMap) {
-				super(parentHandler, IU_PROPERTIES_ELEMENT);
-				String values[] = parseRequiredAttributes(attributes, required);
-				Version version = checkVersion(IU_PROPERTIES_ELEMENT, VERSION_ATTRIBUTE, values[1]);
-				iuIdentity = new IUIdentity(values[0], version);
-				this.iusPropertiesMap = iusPropertiesMap;
-			}
-
-			public void startElement(String name, Attributes attributes) {
-				if (name.equals(PROPERTIES_ELEMENT)) {
-					propertiesHandler = new PropertiesHandler(this, attributes);
-				} else {
-					invalidElement(name, attributes);
-				}
-			}
-
-			protected void finished() {
-				if (isValidXML() && iuIdentity != null && propertiesHandler != null) {
-					iusPropertiesMap.put(iuIdentity, propertiesHandler.getProperties());
-				}
-			}
-		}
-
-		protected String getErrorMessage() {
-			return Messages.InstallRegistry_Parser_Error_Parsing_Registry;
-		}
-
-		public String toString() {
-			// TODO:
-			return null;
-		}
-
-	}
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/MetadataCache.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/MetadataCache.java
deleted file mode 100644
index ee2d5ed..0000000
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/installregistry/MetadataCache.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.installregistry;
-
-import java.io.*;
-import java.net.URL;
-import java.util.EventObject;
-import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
-import org.eclipse.equinox.internal.p2.engine.EngineActivator;
-import org.eclipse.equinox.internal.p2.metadata.repository.*;
-import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
-import org.eclipse.equinox.p2.core.eventbus.ProvisioningListener;
-import org.eclipse.equinox.p2.core.location.AgentLocation;
-import org.eclipse.equinox.p2.engine.*;
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
-import org.osgi.framework.ServiceReference;
-
-public class MetadataCache extends URLMetadataRepository {
-
-	static final private String REPOSITORY_NAME = "Agent Metadata Cache"; //$NON-NLS-1$
-	static final private String REPOSITORY_TYPE = MetadataCache.class.getName();
-	static final private Integer REPOSITORY_VERSION = new Integer(1);
-
-	transient private ServiceReference busReference;
-	transient private ProvisioningEventBus bus;
-
-	public MetadataCache() {
-		super();
-	}
-
-	public static MetadataCache getCacheInstance(MetadataRepositoryManager manager) {
-		AgentLocation agentLocation = (AgentLocation) ServiceHelper.getService(EngineActivator.getContext(), AgentLocation.class.getName());
-		URL url = (agentLocation != null ? agentLocation.getMetadataRepositoryURL() : null);
-		URL content = getActualLocation(url);
-		IMetadataRepository repository = manager.loadRepository(content, null);
-		if (repository == null || !(repository instanceof MetadataCache)) {
-			repository = new MetadataCache(url);
-			((MetadataCache) repository).initializeAfterLoad(url);
-			manager.addRepository(repository);
-		}
-		return (MetadataCache) repository;
-	}
-
-	// These are always created with file: URLs.  At least for now...
-	public MetadataCache(URL cacheLocation) {
-		super(REPOSITORY_NAME, REPOSITORY_TYPE, REPOSITORY_VERSION.toString(), cacheLocation, null, null);
-		content = getActualLocation(location);
-		// Set property indicating that the metadata cache is an implementation detail.
-		getModifiableProperties().put(IMPLEMENTATION_ONLY_KEY, Boolean.valueOf(true).toString());
-	}
-
-	public void initializeAfterLoad(URL repoLocation) {
-		super.initializeAfterLoad(repoLocation);
-
-		// TODO: We should check for writing permission here, otherwise it may be too late
-		busReference = EngineActivator.getContext().getServiceReference(ProvisioningEventBus.class.getName());
-		bus = (ProvisioningEventBus) EngineActivator.getContext().getService(busReference);
-		bus.addListener(new ProvisioningListener() {
-			public void notify(EventObject o) {
-				if (o instanceof InstallableUnitEvent) { //TODO This dependency on InstallableUnitEvent is not great
-					InstallableUnitEvent event = (InstallableUnitEvent) o;
-					if (event.isPre())
-						return;
-					// TODO: what about uninstall??
-					if (event.isPost() && event.getResult().isOK() && event.isInstall()) {
-						IInstallableUnit installedIU = event.getOperand().second();
-						if (installedIU != null)
-							units.add(installedIU.unresolved());
-						return;
-					}
-				}
-				if (o instanceof CommitOperationEvent)
-					persist();
-				if (o instanceof RollbackOperationEvent)
-					new SimpleMetadataRepositoryFactory().restore(MetadataCache.this, location);
-			}
-		});
-	}
-
-	protected void persist() {
-		if (!getContentURL().getProtocol().equals("file"))
-			throw new IllegalStateException("only file: URLs are supported for the metadata cache");
-		File contentFile = new File(getContentURL().getFile());
-		if (!contentFile.getParentFile().exists() && !contentFile.getParentFile().mkdirs())
-			throw new RuntimeException("can't persist the metadata cache");
-		try {
-			OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(contentFile, false));;
-			new MetadataRepositoryIO().write(this, outputStream);
-		} catch (FileNotFoundException e) {
-			throw new RuntimeException("can't persist the metadata cache");
-		}
-	}
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.exemplarysetup/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.exemplarysetup/META-INF/MANIFEST.MF
index 7035ced..1f40951 100644
--- a/bundles/org.eclipse.equinox.p2.exemplarysetup/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.exemplarysetup/META-INF/MANIFEST.MF
@@ -7,13 +7,14 @@ Bundle-Localization: plugin
 Bundle-Version: 0.1.0.qualifier
 Import-Package: org.eclipse.equinox.internal.p2.artifact.repository,
  org.eclipse.equinox.internal.p2.director,
+ org.eclipse.equinox.internal.p2.engine,
+ org.eclipse.equinox.internal.p2.installregistry,
  org.eclipse.equinox.internal.p2.metadata.repository,
  org.eclipse.equinox.p2.artifact.repository,
  org.eclipse.equinox.p2.core.eventbus,
  org.eclipse.equinox.p2.core.location,
  org.eclipse.equinox.p2.director,
  org.eclipse.equinox.p2.engine,
- org.eclipse.equinox.p2.installregistry,
  org.eclipse.equinox.p2.metadata,
  org.eclipse.equinox.p2.metadata.repository,
  org.osgi.framework;version="1.3.0"
diff --git a/bundles/org.eclipse.equinox.p2.exemplarysetup/src/org/eclipse/equinox/internal/p2/exemplarysetup/Activator.java b/bundles/org.eclipse.equinox.p2.exemplarysetup/src/org/eclipse/equinox/internal/p2/exemplarysetup/Activator.java
index 6fbfef4..982fc22 100644
--- a/bundles/org.eclipse.equinox.p2.exemplarysetup/src/org/eclipse/equinox/internal/p2/exemplarysetup/Activator.java
+++ b/bundles/org.eclipse.equinox.p2.exemplarysetup/src/org/eclipse/equinox/internal/p2/exemplarysetup/Activator.java
@@ -12,12 +12,13 @@ package org.eclipse.equinox.internal.p2.exemplarysetup;
 
 import org.eclipse.equinox.internal.p2.director.SimpleDirector;
 import org.eclipse.equinox.internal.p2.director.SimplePlanner;
+import org.eclipse.equinox.internal.p2.engine.SimpleProfileRegistry;
+import org.eclipse.equinox.internal.p2.installregistry.*;
 import org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager;
 import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
-import org.eclipse.equinox.p2.director.*;
+import org.eclipse.equinox.p2.director.IDirector;
+import org.eclipse.equinox.p2.director.IPlanner;
 import org.eclipse.equinox.p2.engine.IProfileRegistry;
-import org.eclipse.equinox.p2.engine.SimpleProfileRegistry;
-import org.eclipse.equinox.p2.installregistry.*;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepositoryManager;
 import org.osgi.framework.*;
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
index 996d76f..85bb093 100644
--- a/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
@@ -19,6 +19,7 @@ Import-Package: ie.wombat.jbdiff,
  org.eclipse.equinox.internal.p2.core.helpers,
  org.eclipse.equinox.internal.p2.director,
  org.eclipse.equinox.internal.p2.engine,
+ org.eclipse.equinox.internal.p2.installregistry,
  org.eclipse.equinox.internal.p2.metadata,
  org.eclipse.equinox.internal.p2.persistence,
  org.eclipse.equinox.internal.p2.resolution,
@@ -29,7 +30,6 @@ Import-Package: ie.wombat.jbdiff,
  org.eclipse.equinox.p2.director,
  org.eclipse.equinox.p2.directorywatcher,
  org.eclipse.equinox.p2.engine,
- org.eclipse.equinox.p2.installregistry,
  org.eclipse.equinox.p2.metadata,
  org.eclipse.equinox.p2.metadata.repository,
  org.eclipse.equinox.p2.query,
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
index 1e35815..feaf6dd 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
@@ -13,12 +13,12 @@ import java.util.*;
 import junit.framework.TestCase;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
+import org.eclipse.equinox.internal.p2.installregistry.IInstallRegistry;
+import org.eclipse.equinox.internal.p2.installregistry.IProfileInstallRegistry;
 import org.eclipse.equinox.p2.director.IDirector;
 import org.eclipse.equinox.p2.director.IPlanner;
 import org.eclipse.equinox.p2.engine.IProfileRegistry;
 import org.eclipse.equinox.p2.engine.Profile;
-import org.eclipse.equinox.p2.installregistry.IInstallRegistry;
-import org.eclipse.equinox.p2.installregistry.IProfileInstallRegistry;
 import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.metadata.MetadataFactory.InstallableUnitFragmentDescription;
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/InstallRegistryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/InstallRegistryTest.java
index 7142c04..61cf516 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/InstallRegistryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/InstallRegistryTest.java
@@ -11,8 +11,8 @@
 package org.eclipse.equinox.p2.tests.engine;
 
 import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.equinox.internal.p2.installregistry.IInstallRegistry;
 import org.eclipse.equinox.p2.engine.*;
-import org.eclipse.equinox.p2.installregistry.IInstallRegistry;
 import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
