commit 8224959a0df027d3c8301fb8e99a78aa1062e103
Author: Susan Franklin <sfranklin>
Date:   Mon Apr 6 22:29:47 2009 +0000

    Bug 270323 - [ui] Provide repository selection combo as reusable ui component

29	435	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/dialogs/AvailableIUsPage.java
1	1	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/dialogs/ComboAutoCompleteField.java
15	0	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/AvailableIUGroup.java
29	0	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/IRepositorySelectionListener.java
560	0	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/RepositorySelectionGroup.java
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/dialogs/AvailableIUsPage.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/dialogs/AvailableIUsPage.java
index 154a65e..bb4c951 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/dialogs/AvailableIUsPage.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/dialogs/AvailableIUsPage.java
@@ -11,43 +11,30 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.ui.dialogs;
 
-import com.ibm.icu.text.Collator;
-import java.lang.reflect.InvocationTargetException;
 import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.*;
-import org.eclipse.core.runtime.*;
-import org.eclipse.equinox.internal.p2.ui.*;
+import org.eclipse.equinox.internal.p2.ui.ProvUIActivator;
+import org.eclipse.equinox.internal.p2.ui.ProvUIMessages;
 import org.eclipse.equinox.internal.p2.ui.model.EmptyElementExplanation;
 import org.eclipse.equinox.internal.p2.ui.viewers.IUDetailsLabelProvider;
-import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
 import org.eclipse.equinox.internal.provisional.p2.engine.ProvisioningContext;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.internal.provisional.p2.repository.*;
 import org.eclipse.equinox.internal.provisional.p2.ui.*;
-import org.eclipse.equinox.internal.provisional.p2.ui.dialogs.AddRepositoryDialog;
-import org.eclipse.equinox.internal.provisional.p2.ui.dialogs.AvailableIUGroup;
-import org.eclipse.equinox.internal.provisional.p2.ui.operations.*;
-import org.eclipse.equinox.internal.provisional.p2.ui.policy.*;
+import org.eclipse.equinox.internal.provisional.p2.ui.dialogs.*;
+import org.eclipse.equinox.internal.provisional.p2.ui.policy.IUViewQueryContext;
+import org.eclipse.equinox.internal.provisional.p2.ui.policy.Policy;
 import org.eclipse.equinox.internal.provisional.p2.ui.viewers.StructuredViewerProvisioningListener;
 import org.eclipse.jface.action.Action;
 import org.eclipse.jface.action.IAction;
 import org.eclipse.jface.dialogs.IDialogConstants;
 import org.eclipse.jface.dialogs.IDialogSettings;
-import org.eclipse.jface.fieldassist.ControlDecoration;
-import org.eclipse.jface.fieldassist.FieldDecorationRegistry;
-import org.eclipse.jface.operation.IRunnableWithProgress;
 import org.eclipse.jface.resource.JFaceResources;
 import org.eclipse.jface.viewers.*;
-import org.eclipse.osgi.util.NLS;
 import org.eclipse.swt.SWT;
 import org.eclipse.swt.dnd.*;
 import org.eclipse.swt.events.*;
-import org.eclipse.swt.graphics.Image;
 import org.eclipse.swt.layout.GridData;
 import org.eclipse.swt.layout.GridLayout;
 import org.eclipse.swt.widgets.*;
-import org.eclipse.ui.statushandlers.StatusManager;
 
 public class AvailableIUsPage extends ProvisioningWizardPage implements ISelectableIUsPage {
 
@@ -58,12 +45,6 @@ public class AvailableIUsPage extends ProvisioningWizardPage implements ISelecta
 	private static final String RESOLVE_ALL = "ResolveInstallWithAllSites"; //$NON-NLS-1$
 	private static final String LINKACTION = "linkAction"; //$NON-NLS-1$
 	private static final int DEFAULT_WIDTH = 300;
-	private static final String SITE_NONE = ProvUIMessages.AvailableIUsPage_NoSites;
-	private static final int INDEX_SITE_NONE = 0;
-	private static final String SITE_ALL = ProvUIMessages.AvailableIUsPage_AllSites;
-	private static final int INDEX_SITE_ALL = 1;
-	private static final String SITE_LOCAL = ProvUIMessages.AvailableIUsPage_LocalSites;
-	private static final int DEC_MARGIN_WIDTH = 2;
 
 	String profileId;
 	Policy policy;
@@ -72,18 +53,13 @@ public class AvailableIUsPage extends ProvisioningWizardPage implements ISelecta
 	IUViewQueryContext queryContext;
 	AvailableIUGroup availableIUGroup;
 	Composite availableIUButtonBar;
-	Combo repoCombo;
-	Link repoLink, installLink;
+	Link installLink;
 	Button useCategoriesCheckbox, hideInstalledCheckbox, showLatestVersionsCheckbox, resolveAllCheckbox;
 	Text detailsArea;
 	StructuredViewerProvisioningListener profileListener;
-	ProvUIProvisioningListener comboRepoListener;
 	Display display;
-	ControlDecoration repoDec;
-	Image info, warning, error;
 	int batchCount = 0;
-	URI[] comboRepos;
-	ComboAutoCompleteField repoAutoComplete;
+	RepositorySelectionGroup repoSelector;
 	IUDetailsGroup iuDetailsGroup;
 
 	public AvailableIUsPage(Policy policy, String profileId, QueryableMetadataRepositoryManager manager) {
@@ -238,125 +214,24 @@ public class AvailableIUsPage extends ProvisioningWizardPage implements ISelecta
 	private void createRepoArea(Composite parent) {
 		// Site controls are only available if a repository manipulator
 		// is specified.
-		final RepositoryManipulator repoMan = policy.getRepositoryManipulator();
-		if (repoMan != null) {
-			// Get the possible field error indicators
-			info = FieldDecorationRegistry.getDefault().getFieldDecoration(FieldDecorationRegistry.DEC_INFORMATION).getImage();
-			warning = FieldDecorationRegistry.getDefault().getFieldDecoration(FieldDecorationRegistry.DEC_WARNING).getImage();
-			error = FieldDecorationRegistry.getDefault().getFieldDecoration(FieldDecorationRegistry.DEC_ERROR).getImage();
-			// Combo that filters sites
-			Composite comboComposite = new Composite(parent, SWT.NONE);
-			GridLayout layout = new GridLayout();
-			layout.marginTop = 0;
-			layout.marginBottom = IDialogConstants.VERTICAL_SPACING;
-			layout.numColumns = 3;
-			comboComposite.setLayout(layout);
-			GridData gd = new GridData(SWT.FILL, SWT.FILL, true, false);
-			comboComposite.setLayoutData(gd);
-
-			Label label = new Label(comboComposite, SWT.NONE);
-			label.setText(ProvUIMessages.AvailableIUsPage_RepoFilterLabel);
-
-			repoCombo = new Combo(comboComposite, SWT.DROP_DOWN);
-			repoCombo.addSelectionListener(new SelectionListener() {
-
-				public void widgetDefaultSelected(SelectionEvent e) {
-					repoComboSelectionChanged();
-				}
-
-				public void widgetSelected(SelectionEvent e) {
-					repoComboSelectionChanged();
-				}
-
-			});
-			// Auto complete - install before our own key listeners, so that auto complete gets first shot.
-			repoAutoComplete = new ComboAutoCompleteField(repoCombo);
-
-			repoCombo.addKeyListener(new KeyAdapter() {
-
-				public void keyPressed(KeyEvent e) {
-					if (e.keyCode == SWT.CR)
-						addRepository(false);
-				}
-			});
-
-			// We don't ever want this to be interpreted as a default
-			// button event
-			repoCombo.addTraverseListener(new TraverseListener() {
-				public void keyTraversed(TraverseEvent e) {
-					if (e.detail == SWT.TRAVERSE_RETURN) {
-						e.doit = false;
-					}
-				}
-			});
-
-			gd = new GridData(SWT.FILL, SWT.FILL, true, false);
-			// breathing room for info dec
-			gd.horizontalIndent = DEC_MARGIN_WIDTH * 2;
-			repoCombo.setLayoutData(gd);
-			repoCombo.addModifyListener(new ModifyListener() {
-				public void modifyText(ModifyEvent event) {
-					URI location = null;
-					IStatus status = null;
-					try {
-						String text = repoCombo.getText();
-						int index = getComboIndex(text);
-						// only validate text that doesn't match existing text in combo
-						if (index < 0) {
-							location = URIUtil.fromString(repoCombo.getText());
-							RepositoryLocationValidator validator = repoMan.getRepositoryLocationValidator(getShell());
-							status = validator.validateRepositoryLocation(location, false, new NullProgressMonitor());
-						} else {
-							// user typed or pasted an existing location.  Select it.
-							repoComboSelectionChanged();
-						}
-					} catch (URISyntaxException e) {
-						status = RepositoryLocationValidator.getInvalidLocationStatus(repoCombo.getText());
-					}
-					setRepoComboDecoration(status);
-				}
-			});
-
-			repoDec = new ControlDecoration(repoCombo, SWT.LEFT | SWT.TOP);
-			repoDec.setMarginWidth(DEC_MARGIN_WIDTH);
-
-			DropTarget target = new DropTarget(repoCombo, DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK);
-			target.setTransfer(new Transfer[] {URLTransfer.getInstance(), FileTransfer.getInstance()});
-			target.addDropListener(new URLDropAdapter(true) {
-				/* (non-Javadoc)
-				 * @see org.eclipse.equinox.internal.provisional.p2.ui.dialogs.URLDropAdapter#handleURLString(java.lang.String, org.eclipse.swt.dnd.DropTargetEvent)
-				 */
-				protected void handleDrop(String urlText, DropTargetEvent event) {
-					repoCombo.setText(urlText);
-					event.detail = DND.DROP_LINK;
-					addRepository(false);
-				}
-			});
-
-			Button button = new Button(comboComposite, SWT.PUSH);
-			button.setText(ProvUIMessages.AvailableIUsPage_AddButton);
-			button.addSelectionListener(new SelectionListener() {
-				public void widgetDefaultSelected(SelectionEvent e) {
-					addRepository(true);
-				}
-
-				public void widgetSelected(SelectionEvent e) {
-					addRepository(true);
+		if (policy.getRepositoryManipulator() != null) {
+			repoSelector = new RepositorySelectionGroup(getContainer(), parent, policy, queryContext);
+			repoSelector.addRepositorySelectionListener(new IRepositorySelectionListener() {
+				public void repositorySelectionChanged(int repoChoice, URI repoLocation) {
+					repoComboSelectionChanged(repoChoice, repoLocation);
 				}
 			});
+		}
+	}
 
-			// Link to repository manipulator
-			repoLink = createLink(comboComposite, new Action() {
-				public void runWithEvent(Event event) {
-					policy.getRepositoryManipulator().manipulateRepositories(getShell());
-				}
-			}, policy.getRepositoryManipulator().getManipulatorLinkLabel());
-			gd = new GridData(SWT.END, SWT.FILL, true, false);
-			gd.horizontalSpan = 3;
-			repoLink.setLayoutData(gd);
-
-			addComboProvisioningListeners();
+	void repoComboSelectionChanged(int repoChoice, URI repoLocation) {
+		if (repoChoice == AvailableIUGroup.AVAILABLE_NONE) {
+			setDescription(ProvUIMessages.AvailableIUsPage_SelectASite);
+		} else {
+			setDescription(ProvUIMessages.AvailableIUsPage_Description);
 		}
+		availableIUGroup.setRepositoryFilter(repoChoice, repoLocation);
+		validateNextButton();
 	}
 
 	void validateNextButton() {
@@ -421,8 +296,8 @@ public class AvailableIUsPage extends ProvisioningWizardPage implements ISelecta
 
 		// Focus should go on site combo unless it's not there.  In that case, go to the filter text.
 		Control focusControl = null;
-		if (repoCombo != null)
-			focusControl = repoCombo;
+		if (repoSelector != null)
+			focusControl = repoSelector.getDefaultFocusControl();
 		else
 			focusControl = availableIUGroup.getDefaultFocusControl();
 		if (focusControl != null)
@@ -431,9 +306,8 @@ public class AvailableIUsPage extends ProvisioningWizardPage implements ISelecta
 		iuDetailsGroup.enablePropertyLink(availableIUGroup.getSelectedIUElements().length == 1);
 		validateNextButton();
 
-		if (repoCombo != null) {
-			fillRepoCombo(SITE_NONE);
-			setRepoComboDecoration(null);
+		if (repoSelector != null) {
+			repoSelector.setRepositorySelection(AvailableIUGroup.AVAILABLE_NONE, null);
 			setDescription(ProvUIMessages.AvailableIUsPage_SelectASite);
 		}
 
@@ -605,220 +479,6 @@ public class AvailableIUsPage extends ProvisioningWizardPage implements ISelecta
 			availableIUGroup.setChecked(elements);
 	}
 
-	/*
-	 *  Add a repository using the text in the combo or launch a dialog if the text
-	 *  represents an already known repo.  For any add operation spawned by this
-	 *  method, we do not want to notify the UI with a special listener.  This is to
-	 *  prevent a multiple update flash because we intend to reset the available IU
-	 *  filter as soon as the new repo is added.
-	 */
-	void addRepository(boolean alwaysPrompt) {
-		final RepositoryManipulator repoMan = policy.getRepositoryManipulator();
-		if (repoMan == null)
-			return;
-		final String selectedRepo = repoCombo.getText();
-		int selectionIndex = getComboIndex(selectedRepo);
-		final boolean isNewText = selectionIndex < 0;
-		// If we are adding something already in the combo, just
-		// select that item.
-		if (!alwaysPrompt && !isNewText && selectionIndex != repoCombo.getSelectionIndex()) {
-			repoComboSelectionChanged();
-		} else if (alwaysPrompt) {
-			AddRepositoryDialog dialog = new AddRepositoryDialog(getShell(), policy) {
-				protected AddRepositoryOperation getOperation(URI repositoryLocation) {
-					AddRepositoryOperation op = repoMan.getAddOperation(repositoryLocation);
-					op.setNotify(false);
-					return op;
-				}
-
-				protected String getInitialLocationText() {
-					if (isNewText)
-						return selectedRepo;
-					return super.getInitialLocationText();
-				}
-
-			};
-			dialog.setTitle(repoMan.getAddOperationLabel());
-			dialog.open();
-			URI location = dialog.getAddedLocation();
-			if (location != null)
-				fillRepoCombo(getSiteString(location));
-		} else if (isNewText) {
-			try {
-				getContainer().run(false, false, new IRunnableWithProgress() {
-					public void run(IProgressMonitor monitor) {
-						URI location = null;
-						IStatus status;
-						try {
-							location = URIUtil.fromString(selectedRepo);
-							RepositoryLocationValidator validator = repoMan.getRepositoryLocationValidator(getShell());
-							status = validator.validateRepositoryLocation(location, false, monitor);
-						} catch (URISyntaxException e) {
-							status = RepositoryLocationValidator.getInvalidLocationStatus(selectedRepo);
-						}
-						if (status.isOK() && location != null) {
-							try {
-								RepositoryOperation op = repoMan.getAddOperation(location);
-								op.setNotify(false);
-								op.execute(monitor);
-								fillRepoCombo(getSiteString(location));
-							} catch (ProvisionException e) {
-								// TODO Auto-generated catch block
-								ProvUI.handleException(e, null, StatusManager.SHOW);
-							}
-						}
-						setRepoComboDecoration(status);
-					}
-				});
-			} catch (InvocationTargetException e) {
-				// ignore
-			} catch (InterruptedException e) {
-				// ignore
-			}
-		}
-	}
-
-	void fillRepoCombo(final String selection) {
-		if (repoCombo == null || policy.getRepositoryManipulator() == null)
-			return;
-		URI[] sites = policy.getRepositoryManipulator().getKnownRepositories();
-		boolean hasLocalSites = getLocalSites().length > 0;
-		final String[] items;
-		if (hasLocalSites) {
-			// None, All, repo1, repo2....repo n, Local
-			comboRepos = new URI[sites.length + 3];
-			items = new String[sites.length + 3];
-		} else {
-			// None, All, repo1, repo2....repo n
-			comboRepos = new URI[sites.length + 2];
-			items = new String[sites.length + 2];
-		}
-		items[INDEX_SITE_NONE] = SITE_NONE;
-		items[INDEX_SITE_ALL] = SITE_ALL;
-		for (int i = 0; i < sites.length; i++) {
-			items[i + 2] = getSiteString(sites[i]);
-			comboRepos[i + 2] = sites[i];
-		}
-		if (hasLocalSites)
-			items[items.length - 1] = SITE_LOCAL;
-		if (sites.length > 0)
-			sortRepoItems(items, comboRepos, hasLocalSites);
-		Runnable runnable = new Runnable() {
-			public void run() {
-				if (repoCombo == null || repoCombo.isDisposed())
-					return;
-				// If the combo is open and something is selected, use that index if we
-				// weren't given a string to select.
-				int selIndex = repoCombo.getSelectionIndex();
-				if (selIndex < 0)
-					selIndex = 0;
-				String repoToSelect = selection == null ? repoCombo.getItem(selIndex) : selection;
-				repoCombo.setItems(items);
-				boolean selected = false;
-				for (int i = 0; i < items.length; i++)
-					if (items[i].equals(repoToSelect)) {
-						selected = true;
-						if (repoCombo.getListVisible())
-							repoCombo.select(i);
-						repoCombo.setText(repoToSelect);
-						break;
-					}
-				if (!selected) {
-					if (repoCombo.getListVisible())
-						repoCombo.select(INDEX_SITE_NONE);
-					repoCombo.setText(SITE_NONE);
-				}
-				repoComboSelectionChanged();
-			}
-		};
-		// Only run the UI code async if we have to.  If we always async the code,
-		// the automated tests (which are in the UI thread) can get out of sync
-		if (Display.getCurrent() == null)
-			display.asyncExec(runnable);
-		else
-			runnable.run();
-	}
-
-	String getSiteString(URI uri) {
-		try {
-			String nickname = ProvisioningUtil.getMetadataRepositoryProperty(uri, IRepository.PROP_NICKNAME);
-			if (nickname != null && nickname.length() > 0)
-				return NLS.bind(ProvUIMessages.AvailableIUsPage_NameWithLocation, nickname, URIUtil.toUnencodedString(uri));
-		} catch (ProvisionException e) {
-			// No error, just use the location string
-		}
-		return URIUtil.toUnencodedString(uri);
-	}
-
-	private void sortRepoItems(String[] strings, URI[] locations, boolean hasLocalSites) {
-		int sortStart = 2;
-		int sortEnd = hasLocalSites ? strings.length - 2 : strings.length - 1;
-		if (sortStart >= sortEnd)
-			return;
-		final Collator collator = Collator.getInstance(Locale.getDefault());
-		Comparator stringComparator = new Comparator() {
-			public int compare(Object a, Object b) {
-				return collator.compare(a, b);
-			}
-		};
-		Comparator uriComparator = new Comparator() {
-			public int compare(Object a, Object b) {
-				return collator.compare(getSiteString((URI) a), getSiteString((URI) b));
-			}
-		};
-
-		Arrays.sort(strings, sortStart, sortEnd, stringComparator);
-		Arrays.sort(locations, sortStart, sortEnd, uriComparator);
-	}
-
-	private URI[] getLocalSites() {
-		// use our current visibility flags plus the local filter
-		int flags = queryContext.getMetadataRepositoryFlags() | IRepositoryManager.REPOSITORIES_LOCAL;
-		try {
-			return ProvisioningUtil.getMetadataRepositories(flags);
-		} catch (ProvisionException e) {
-			return null;
-		}
-	}
-
-	int getComboIndex(String repoText) {
-		int index = -1;
-		if (repoText.length() > 0) {
-			String[] items = repoCombo.getItems();
-			for (int i = 0; i < items.length; i++)
-				if (repoText.equals(items[i])) {
-					index = i;
-					break;
-				}
-		}
-		return index;
-	}
-
-	void repoComboSelectionChanged() {
-		int selection = -1;
-		if (repoCombo.getListVisible())
-			selection = repoCombo.getSelectionIndex();
-		else {
-			selection = getComboIndex(repoCombo.getText());
-		}
-		int localIndex = getLocalSites().length == 0 ? repoCombo.getItemCount() : repoCombo.getItemCount() - 1;
-		if (comboRepos == null || selection < 0)
-			selection = INDEX_SITE_NONE;
-		String description = ProvUIMessages.AvailableIUsPage_Description;
-		if (selection == INDEX_SITE_NONE) {
-			availableIUGroup.setRepositoryFilter(AvailableIUGroup.AVAILABLE_NONE, null);
-			description = ProvUIMessages.AvailableIUsPage_SelectASite;
-		} else if (selection == INDEX_SITE_ALL) {
-			availableIUGroup.setRepositoryFilter(AvailableIUGroup.AVAILABLE_ALL, null);
-		} else if (selection >= localIndex) {
-			availableIUGroup.setRepositoryFilter(AvailableIUGroup.AVAILABLE_LOCAL, null);
-		} else {
-			availableIUGroup.setRepositoryFilter(AvailableIUGroup.AVAILABLE_SPECIFIED, comboRepos[selection]);
-		}
-		validateNextButton();
-		setDescription(description);
-	}
-
 	void addViewerProvisioningListeners() {
 		// We might need to adjust the content of the available IU group's viewer
 		// according to installation changes.  We want to be very selective about refreshing,
@@ -842,62 +502,11 @@ public class AvailableIUsPage extends ProvisioningWizardPage implements ISelecta
 		ProvUI.addProvisioningListener(profileListener);
 	}
 
-	void addComboProvisioningListeners() {
-		// We need to monitor repository events so that we can adjust the repo combo.
-		comboRepoListener = new ProvUIProvisioningListener(ProvUIProvisioningListener.PROV_EVENT_METADATA_REPOSITORY) {
-			protected void repositoryAdded(RepositoryEvent e) {
-				if (e instanceof UIRepositoryEvent) {
-					fillRepoCombo(getSiteString(e.getRepositoryLocation()));
-				}
-			}
-
-			protected void repositoryRemoved(RepositoryEvent e) {
-				fillRepoCombo(null);
-			}
-
-			protected void refreshAll() {
-				fillRepoCombo(null);
-			}
-		};
-		ProvUI.addProvisioningListener(comboRepoListener);
-
-	}
-
 	void removeProvisioningListeners() {
 		if (profileListener != null) {
 			ProvUI.removeProvisioningListener(profileListener);
 			profileListener = null;
 		}
-		if (comboRepoListener != null) {
-			ProvUI.removeProvisioningListener(comboRepoListener);
-			comboRepoListener = null;
-		}
-
-	}
-
-	void setRepoComboDecoration(IStatus status) {
-		if (status == null || status.isOK() || status.getSeverity() == IStatus.CANCEL) {
-			repoDec.setShowOnlyOnFocus(true);
-			repoDec.setDescriptionText(ProvUIMessages.AvailableIUsPage_RepoFilterInstructions);
-			repoDec.setImage(info);
-			// We may have been previously showing an error or warning
-			// hover.  We will need to dismiss it, but if there is no text
-			// typed, don't do this, so that the user gets the info cue
-			if (repoCombo.getText().length() > 0)
-				repoDec.showHoverText(null);
-			return;
-		}
-		Image image;
-		if (status.getSeverity() == IStatus.WARNING)
-			image = warning;
-		else if (status.getSeverity() == IStatus.ERROR)
-			image = error;
-		else
-			image = info;
-		repoDec.setImage(image);
-		repoDec.setDescriptionText(status.getMessage());
-		repoDec.setShowOnlyOnFocus(false);
-		repoDec.showHoverText(status.getMessage());
 	}
 
 	protected String getClipboardText(Control control) {
@@ -909,29 +518,14 @@ public class AvailableIUsPage extends ProvisioningWizardPage implements ISelecta
 
 	public ProvisioningContext getProvisioningContext() {
 		// If the user can't manipulate repos, always resolve against everything
-		if (policy.getRepositoryManipulator() == null)
+		if (policy.getRepositoryManipulator() == null || repoSelector == null) {
 			return new ProvisioningContext();
+		}
 		// Consult the checkbox to see if we should resolve against everything,
 		// or use the combo to determine what to do.
 		if (resolveAllCheckbox.getSelection())
 			return new ProvisioningContext();
-		int siteSel = getComboIndex(repoCombo.getText());
-		if (siteSel < 0 || siteSel == INDEX_SITE_ALL || siteSel == INDEX_SITE_NONE)
-			return new ProvisioningContext();
-		URI[] locals = getLocalSites();
-		// If there are local sites, the last item in the combo is "Local Sites Only"
-		// Use all local sites in this case
-		// We have to set metadata repositories and artifact repositories in the
-		// provisioning context because the artifact repositories are used for
-		// sizing.
-		if (locals.length > 0 && siteSel == repoCombo.getItemCount() - 1) {
-			ProvisioningContext context = new ProvisioningContext(locals);
-			context.setArtifactRepositories(locals);
-			return context;
-		}
-		// A single site is selected.
-		ProvisioningContext context = new ProvisioningContext(new URI[] {comboRepos[siteSel]});
-		context.setArtifactRepositories(new URI[] {comboRepos[siteSel]});
-		return context;
+		// Use the contents of the combo to determine the context
+		return repoSelector.getProvisioningContext();
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/dialogs/ComboAutoCompleteField.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/dialogs/ComboAutoCompleteField.java
index 155d3d0..dfe3b2d 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/dialogs/ComboAutoCompleteField.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/dialogs/ComboAutoCompleteField.java
@@ -27,7 +27,7 @@ public class ComboAutoCompleteField {
 	ContentProposalAdapter adapter;
 	Combo combo;
 
-	ComboAutoCompleteField(Combo c) {
+	public ComboAutoCompleteField(Combo c) {
 		this.combo = c;
 		adapter = new ContentProposalAdapter(combo, new ComboContentAdapter(), getProposalProvider(), null, null);
 		adapter.setPropagateKeys(true);
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/AvailableIUGroup.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/AvailableIUGroup.java
index e00bec7..3b78ec9 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/AvailableIUGroup.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/AvailableIUGroup.java
@@ -54,9 +54,24 @@ public class AvailableIUGroup extends StructuredIUGroup {
 	private static final int SITE_COLUMN_WIDTH_IN_DLUS = 300;
 	private static final int OTHER_COLUMN_WIDTH_IN_DLUS = 350;
 
+	/**
+	 * Show contents from all repositories
+	 */
 	public static final int AVAILABLE_ALL = 1;
+
+	/**
+	 * Don't show any repository content
+	 */
 	public static final int AVAILABLE_NONE = 2;
+
+	/**
+	 * Show local repository content
+	 */
 	public static final int AVAILABLE_LOCAL = 3;
+
+	/**
+	 * Show content for a specific repository
+	 */
 	public static final int AVAILABLE_SPECIFIED = 4;
 
 	QueryableMetadataRepositoryManager queryableManager;
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/IRepositorySelectionListener.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/IRepositorySelectionListener.java
new file mode 100644
index 0000000..acbcdfa
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/IRepositorySelectionListener.java
@@ -0,0 +1,29 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.ui.dialogs;
+
+import java.net.URI;
+
+/**
+ * Listener for the repository selection combo.  Whenever the selected repository changes (menu selection, 
+ * text modified, new repo added) this listener will be notified.
+ * 
+ * @since 3.5
+ */
+public interface IRepositorySelectionListener {
+	/**
+	 * Called whenever the selected repository in the combo changes.
+	 * 
+	 * @param repoChoice one of AvailableIUGroup.AVAILABLE_NONE, AvailableIUGroup.AVAILABLE_ALL, AvailableIUGroup.AVAILABLE_LOCAL, AvailableIUGroup.AVAILABLE_SPECIFIED  
+	 * @param repoLocation if the repoChoice is set to AvailableIUGroup.AVAILABLE_SPECIFIED, this field will contain the URI of the selected repo, otherwise <code>null</code>
+	 */
+	public void repositorySelectionChanged(int repoChoice, URI repoLocation);
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/RepositorySelectionGroup.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/RepositorySelectionGroup.java
new file mode 100644
index 0000000..594d7e0
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/dialogs/RepositorySelectionGroup.java
@@ -0,0 +1,560 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.ui.dialogs;
+
+import com.ibm.icu.text.Collator;
+import java.lang.reflect.InvocationTargetException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.*;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.ui.ProvUIMessages;
+import org.eclipse.equinox.internal.p2.ui.UIRepositoryEvent;
+import org.eclipse.equinox.internal.p2.ui.dialogs.ComboAutoCompleteField;
+import org.eclipse.equinox.internal.p2.ui.dialogs.URLDropAdapter;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.engine.ProvisioningContext;
+import org.eclipse.equinox.internal.provisional.p2.repository.*;
+import org.eclipse.equinox.internal.provisional.p2.ui.ProvUI;
+import org.eclipse.equinox.internal.provisional.p2.ui.ProvUIProvisioningListener;
+import org.eclipse.equinox.internal.provisional.p2.ui.operations.*;
+import org.eclipse.equinox.internal.provisional.p2.ui.policy.*;
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.dialogs.IDialogConstants;
+import org.eclipse.jface.fieldassist.ControlDecoration;
+import org.eclipse.jface.fieldassist.FieldDecorationRegistry;
+import org.eclipse.jface.operation.IRunnableWithProgress;
+import org.eclipse.jface.wizard.IWizardContainer;
+import org.eclipse.osgi.util.NLS;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.dnd.*;
+import org.eclipse.swt.events.*;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.*;
+import org.eclipse.ui.statushandlers.StatusManager;
+
+/**
+ * A RepositorySelectionGroup is a reusable UI component that displays 
+ * available repositories and allows the user to select them.  
+ * 
+ * @since 3.5
+ */
+public class RepositorySelectionGroup {
+
+	private static final String SITE_NONE = ProvUIMessages.AvailableIUsPage_NoSites;
+	private static final String SITE_ALL = ProvUIMessages.AvailableIUsPage_AllSites;
+	private static final String SITE_LOCAL = ProvUIMessages.AvailableIUsPage_LocalSites;
+	private static final int INDEX_SITE_NONE = 0;
+	private static final int INDEX_SITE_ALL = 1;
+	private static final int DEC_MARGIN_WIDTH = 2;
+	private static final String LINKACTION = "linkAction"; //$NON-NLS-1$
+
+	IWizardContainer container;
+	Policy policy;
+	IUViewQueryContext queryContext;
+
+	ListenerList listeners = new ListenerList();
+
+	Combo repoCombo;
+	Link repoManipulatorLink;
+	ControlDecoration repoDec;
+	ComboAutoCompleteField repoAutoComplete;
+	ProvUIProvisioningListener comboRepoListener;
+
+	Image info, warning, error;
+	URI[] comboRepos;
+
+	public RepositorySelectionGroup(IWizardContainer container, Composite parent, Policy policy, IUViewQueryContext queryContext) {
+		this.container = container;
+		this.queryContext = queryContext;
+		this.policy = policy;
+		createControl(parent);
+	}
+
+	public Control getDefaultFocusControl() {
+		return repoCombo;
+	}
+
+	public void addRepositorySelectionListener(IRepositorySelectionListener listener) {
+		listeners.add(listener);
+	}
+
+	protected void createControl(Composite parent) {
+		// Get the possible field error indicators
+		info = FieldDecorationRegistry.getDefault().getFieldDecoration(FieldDecorationRegistry.DEC_INFORMATION).getImage();
+		warning = FieldDecorationRegistry.getDefault().getFieldDecoration(FieldDecorationRegistry.DEC_WARNING).getImage();
+		error = FieldDecorationRegistry.getDefault().getFieldDecoration(FieldDecorationRegistry.DEC_ERROR).getImage();
+
+		// Combo that filters sites
+		Composite comboComposite = new Composite(parent, SWT.NONE);
+		GridLayout layout = new GridLayout();
+		layout.marginTop = 0;
+		layout.marginBottom = IDialogConstants.VERTICAL_SPACING;
+		layout.numColumns = 3;
+		comboComposite.setLayout(layout);
+		GridData gd = new GridData(SWT.FILL, SWT.FILL, true, false);
+		comboComposite.setLayoutData(gd);
+
+		Label label = new Label(comboComposite, SWT.NONE);
+		label.setText(ProvUIMessages.AvailableIUsPage_RepoFilterLabel);
+
+		repoCombo = new Combo(comboComposite, SWT.DROP_DOWN);
+		repoCombo.addSelectionListener(new SelectionListener() {
+
+			public void widgetDefaultSelected(SelectionEvent e) {
+				repoComboSelectionChanged();
+			}
+
+			public void widgetSelected(SelectionEvent e) {
+				repoComboSelectionChanged();
+			}
+
+		});
+		// Auto complete - install before our own key listeners, so that auto complete gets first shot.
+		repoAutoComplete = new ComboAutoCompleteField(repoCombo);
+
+		repoCombo.addKeyListener(new KeyAdapter() {
+
+			public void keyPressed(KeyEvent e) {
+				if (e.keyCode == SWT.CR)
+					addRepository(false);
+			}
+		});
+
+		// We don't ever want this to be interpreted as a default
+		// button event
+		repoCombo.addTraverseListener(new TraverseListener() {
+			public void keyTraversed(TraverseEvent e) {
+				if (e.detail == SWT.TRAVERSE_RETURN) {
+					e.doit = false;
+				}
+			}
+		});
+
+		gd = new GridData(SWT.FILL, SWT.FILL, true, false);
+		// breathing room for info dec
+		gd.horizontalIndent = DEC_MARGIN_WIDTH * 2;
+		repoCombo.setLayoutData(gd);
+		repoCombo.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent event) {
+				URI location = null;
+				IStatus status = null;
+				try {
+					String text = repoCombo.getText();
+					int index = getComboIndex(text);
+					// only validate text that doesn't match existing text in combo
+					if (index < 0) {
+						location = URIUtil.fromString(repoCombo.getText());
+						RepositoryLocationValidator validator = policy.getRepositoryManipulator().getRepositoryLocationValidator(repoCombo.getShell());
+						status = validator.validateRepositoryLocation(location, false, new NullProgressMonitor());
+					} else {
+						// user typed or pasted an existing location.  Select it.
+						repoComboSelectionChanged();
+					}
+				} catch (URISyntaxException e) {
+					status = RepositoryLocationValidator.getInvalidLocationStatus(repoCombo.getText());
+				}
+				setRepoComboDecoration(status);
+			}
+		});
+
+		repoDec = new ControlDecoration(repoCombo, SWT.LEFT | SWT.TOP);
+		repoDec.setMarginWidth(DEC_MARGIN_WIDTH);
+
+		DropTarget target = new DropTarget(repoCombo, DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK);
+		target.setTransfer(new Transfer[] {URLTransfer.getInstance(), FileTransfer.getInstance()});
+		target.addDropListener(new URLDropAdapter(true) {
+			/* (non-Javadoc)
+			 * @see org.eclipse.equinox.internal.provisional.p2.ui.dialogs.URLDropAdapter#handleURLString(java.lang.String, org.eclipse.swt.dnd.DropTargetEvent)
+			 */
+			protected void handleDrop(String urlText, DropTargetEvent event) {
+				repoCombo.setText(urlText);
+				event.detail = DND.DROP_LINK;
+				addRepository(false);
+			}
+		});
+
+		Button button = new Button(comboComposite, SWT.PUSH);
+		button.setText(ProvUIMessages.AvailableIUsPage_AddButton);
+		button.addSelectionListener(new SelectionListener() {
+			public void widgetDefaultSelected(SelectionEvent e) {
+				addRepository(true);
+			}
+
+			public void widgetSelected(SelectionEvent e) {
+				addRepository(true);
+			}
+		});
+
+		// Link to repository manipulator
+		repoManipulatorLink = createLink(comboComposite, new Action() {
+			public void runWithEvent(Event event) {
+				policy.getRepositoryManipulator().manipulateRepositories(repoCombo.getShell());
+			}
+		}, policy.getRepositoryManipulator().getManipulatorLinkLabel());
+		gd = new GridData(SWT.END, SWT.FILL, true, false);
+		gd.horizontalSpan = 3;
+		repoManipulatorLink.setLayoutData(gd);
+
+		addComboProvisioningListeners();
+		parent.addDisposeListener(new DisposeListener() {
+			public void widgetDisposed(DisposeEvent e) {
+				removeProvisioningListeners();
+			}
+
+		});
+	}
+
+	public void setRepositorySelection(int scope, URI location) {
+		switch (scope) {
+			case AvailableIUGroup.AVAILABLE_ALL :
+				fillRepoCombo(SITE_ALL);
+				break;
+			case AvailableIUGroup.AVAILABLE_LOCAL :
+				fillRepoCombo(SITE_LOCAL);
+				break;
+			case AvailableIUGroup.AVAILABLE_SPECIFIED :
+				fillRepoCombo(getSiteString(location));
+				break;
+			default :
+				fillRepoCombo(SITE_NONE);
+		}
+		setRepoComboDecoration(null);
+	}
+
+	protected void setRepoComboDecoration(IStatus status) {
+		if (status == null || status.isOK() || status.getSeverity() == IStatus.CANCEL) {
+			repoDec.setShowOnlyOnFocus(true);
+			repoDec.setDescriptionText(ProvUIMessages.AvailableIUsPage_RepoFilterInstructions);
+			repoDec.setImage(info);
+			// We may have been previously showing an error or warning
+			// hover.  We will need to dismiss it, but if there is no text
+			// typed, don't do this, so that the user gets the info cue
+			if (repoCombo.getText().length() > 0)
+				repoDec.showHoverText(null);
+			return;
+		}
+		Image image;
+		if (status.getSeverity() == IStatus.WARNING)
+			image = warning;
+		else if (status.getSeverity() == IStatus.ERROR)
+			image = error;
+		else
+			image = info;
+		repoDec.setImage(image);
+		repoDec.setDescriptionText(status.getMessage());
+		repoDec.setShowOnlyOnFocus(false);
+		repoDec.showHoverText(status.getMessage());
+	}
+
+	/*
+	 * Fill the repo combo and use the specified string
+	 * as the selection.  If the selection is null, then the
+	 * current selection should be preserved if applicable.
+	 */
+	void fillRepoCombo(final String selection) {
+		URI[] sites = policy.getRepositoryManipulator().getKnownRepositories();
+		boolean hasLocalSites = getLocalSites().length > 0;
+		final String[] items;
+		if (hasLocalSites) {
+			// None, All, repo1, repo2....repo n, Local
+			comboRepos = new URI[sites.length + 3];
+			items = new String[sites.length + 3];
+		} else {
+			// None, All, repo1, repo2....repo n
+			comboRepos = new URI[sites.length + 2];
+			items = new String[sites.length + 2];
+		}
+		items[INDEX_SITE_NONE] = SITE_NONE;
+		items[INDEX_SITE_ALL] = SITE_ALL;
+		for (int i = 0; i < sites.length; i++) {
+			items[i + 2] = getSiteString(sites[i]);
+			comboRepos[i + 2] = sites[i];
+		}
+		if (hasLocalSites)
+			items[items.length - 1] = SITE_LOCAL;
+		if (sites.length > 0)
+			sortRepoItems(items, comboRepos, hasLocalSites);
+		Runnable runnable = new Runnable() {
+			public void run() {
+				if (repoCombo == null || repoCombo.isDisposed())
+					return;
+				String repoToSelect = selection;
+				if (repoToSelect == null) {
+					// If the combo is open and something is selected, use that index if we
+					// weren't given a string to select.
+					int selIndex = repoCombo.getSelectionIndex();
+					if (selIndex >= 0)
+						repoToSelect = repoCombo.getItem(selIndex);
+					else
+						repoToSelect = repoCombo.getText();
+				}
+				repoCombo.setItems(items);
+				boolean selected = false;
+				for (int i = 0; i < items.length; i++)
+					if (items[i].equals(repoToSelect)) {
+						selected = true;
+						if (repoCombo.getListVisible())
+							repoCombo.select(i);
+						repoCombo.setText(repoToSelect);
+						break;
+					}
+				if (!selected) {
+					if (repoCombo.getListVisible())
+						repoCombo.select(INDEX_SITE_NONE);
+					repoCombo.setText(SITE_NONE);
+				}
+				repoComboSelectionChanged();
+			}
+		};
+		// Only run the UI code async if we have to.  If we always async the code,
+		// the automated tests (which are in the UI thread) can get out of sync
+		if (Display.getCurrent() == null)
+			repoCombo.getDisplay().asyncExec(runnable);
+		else
+			runnable.run();
+	}
+
+	String getSiteString(URI uri) {
+		try {
+			String nickname = ProvisioningUtil.getMetadataRepositoryProperty(uri, IRepository.PROP_NICKNAME);
+			if (nickname != null && nickname.length() > 0)
+				return NLS.bind(ProvUIMessages.AvailableIUsPage_NameWithLocation, nickname, URIUtil.toUnencodedString(uri));
+		} catch (ProvisionException e) {
+			// No error, just use the location string
+		}
+		return URIUtil.toUnencodedString(uri);
+	}
+
+	private Link createLink(Composite parent, IAction action, String text) {
+		Link link = new Link(parent, SWT.PUSH);
+		link.setText(text);
+
+		link.addListener(SWT.Selection, new Listener() {
+			public void handleEvent(Event event) {
+				IAction linkAction = getLinkAction(event.widget);
+				if (linkAction != null) {
+					linkAction.runWithEvent(event);
+				}
+			}
+		});
+		link.setToolTipText(action.getToolTipText());
+		link.setData(LINKACTION, action);
+		return link;
+	}
+
+	IAction getLinkAction(Widget widget) {
+		Object data = widget.getData(LINKACTION);
+		if (data == null || !(data instanceof IAction)) {
+			return null;
+		}
+		return (IAction) data;
+	}
+
+	private void sortRepoItems(String[] strings, URI[] locations, boolean hasLocalSites) {
+		int sortStart = 2;
+		int sortEnd = hasLocalSites ? strings.length - 2 : strings.length - 1;
+		if (sortStart >= sortEnd)
+			return;
+		final Collator collator = Collator.getInstance(Locale.getDefault());
+		Comparator stringComparator = new Comparator() {
+			public int compare(Object a, Object b) {
+				return collator.compare(a, b);
+			}
+		};
+		Comparator uriComparator = new Comparator() {
+			public int compare(Object a, Object b) {
+				return collator.compare(getSiteString((URI) a), getSiteString((URI) b));
+			}
+		};
+
+		Arrays.sort(strings, sortStart, sortEnd, stringComparator);
+		Arrays.sort(locations, sortStart, sortEnd, uriComparator);
+	}
+
+	private URI[] getLocalSites() {
+		// use our current visibility flags plus the local filter
+		int flags = queryContext.getMetadataRepositoryFlags() | IRepositoryManager.REPOSITORIES_LOCAL;
+		try {
+			return ProvisioningUtil.getMetadataRepositories(flags);
+		} catch (ProvisionException e) {
+			return null;
+		}
+	}
+
+	int getComboIndex(String repoText) {
+		int index = -1;
+		if (repoText.length() > 0) {
+			String[] items = repoCombo.getItems();
+			for (int i = 0; i < items.length; i++)
+				if (repoText.equals(items[i])) {
+					index = i;
+					break;
+				}
+		}
+		return index;
+	}
+
+	void addComboProvisioningListeners() {
+		// We need to monitor repository events so that we can adjust the repo combo.
+		comboRepoListener = new ProvUIProvisioningListener(ProvUIProvisioningListener.PROV_EVENT_METADATA_REPOSITORY) {
+			protected void repositoryAdded(RepositoryEvent e) {
+				if (e instanceof UIRepositoryEvent) {
+					fillRepoCombo(getSiteString(e.getRepositoryLocation()));
+				}
+			}
+
+			protected void repositoryRemoved(RepositoryEvent e) {
+				fillRepoCombo(null);
+			}
+
+			protected void refreshAll() {
+				fillRepoCombo(null);
+			}
+		};
+		ProvUI.addProvisioningListener(comboRepoListener);
+	}
+
+	void removeProvisioningListeners() {
+		if (comboRepoListener != null) {
+			ProvUI.removeProvisioningListener(comboRepoListener);
+			comboRepoListener = null;
+		}
+
+	}
+
+	/*
+	 *  Add a repository using the text in the combo or launch a dialog if the text
+	 *  represents an already known repo.  For any add operation spawned by this
+	 *  method, we do not want to notify the UI with a special listener.  This is to
+	 *  prevent a multiple update flash because we intend to reset the available IU
+	 *  filter as soon as the new repo is added.
+	 */
+	void addRepository(boolean alwaysPrompt) {
+		final RepositoryManipulator manipulator = policy.getRepositoryManipulator();
+		final String selectedRepo = repoCombo.getText();
+		int selectionIndex = getComboIndex(selectedRepo);
+		final boolean isNewText = selectionIndex < 0;
+		// If we are adding something already in the combo, just
+		// select that item.
+		if (!alwaysPrompt && !isNewText && selectionIndex != repoCombo.getSelectionIndex()) {
+			repoComboSelectionChanged();
+		} else if (alwaysPrompt) {
+			AddRepositoryDialog dialog = new AddRepositoryDialog(repoCombo.getShell(), policy) {
+				protected AddRepositoryOperation getOperation(URI repositoryLocation) {
+					AddRepositoryOperation op = manipulator.getAddOperation(repositoryLocation);
+					op.setNotify(false);
+					return op;
+				}
+
+				protected String getInitialLocationText() {
+					if (isNewText)
+						return selectedRepo;
+					return super.getInitialLocationText();
+				}
+
+			};
+			dialog.setTitle(manipulator.getAddOperationLabel());
+			dialog.open();
+			URI location = dialog.getAddedLocation();
+			if (location != null)
+				fillRepoCombo(getSiteString(location));
+		} else if (isNewText) {
+			try {
+				container.run(false, false, new IRunnableWithProgress() {
+					public void run(IProgressMonitor monitor) {
+						URI location = null;
+						IStatus status;
+						try {
+							location = URIUtil.fromString(selectedRepo);
+							RepositoryLocationValidator validator = manipulator.getRepositoryLocationValidator(repoCombo.getShell());
+							status = validator.validateRepositoryLocation(location, false, monitor);
+						} catch (URISyntaxException e) {
+							status = RepositoryLocationValidator.getInvalidLocationStatus(selectedRepo);
+						}
+						if (status.isOK() && location != null) {
+							try {
+								RepositoryOperation op = manipulator.getAddOperation(location);
+								op.setNotify(false);
+								op.execute(monitor);
+								fillRepoCombo(getSiteString(location));
+							} catch (ProvisionException e) {
+								// TODO Auto-generated catch block
+								ProvUI.handleException(e, null, StatusManager.SHOW);
+							}
+						}
+						setRepoComboDecoration(status);
+					}
+				});
+			} catch (InvocationTargetException e) {
+				// ignore
+			} catch (InterruptedException e) {
+				// ignore
+			}
+		}
+	}
+
+	public ProvisioningContext getProvisioningContext() {
+		int siteSel = getComboIndex(repoCombo.getText());
+		if (siteSel < 0 || siteSel == INDEX_SITE_ALL || siteSel == INDEX_SITE_NONE)
+			return new ProvisioningContext();
+		URI[] locals = getLocalSites();
+		// If there are local sites, the last item in the combo is "Local Sites Only"
+		// Use all local sites in this case
+		// We have to set metadata repositories and artifact repositories in the
+		// provisioning context because the artifact repositories are used for
+		// sizing.
+		if (locals.length > 0 && siteSel == repoCombo.getItemCount() - 1) {
+			ProvisioningContext context = new ProvisioningContext(locals);
+			context.setArtifactRepositories(locals);
+			return context;
+		}
+		// A single site is selected.
+		ProvisioningContext context = new ProvisioningContext(new URI[] {comboRepos[siteSel]});
+		context.setArtifactRepositories(new URI[] {comboRepos[siteSel]});
+		return context;
+	}
+
+	void repoComboSelectionChanged() {
+		int repoChoice = -1;
+		URI repoLocation = null;
+
+		int selection = -1;
+		if (repoCombo.getListVisible()) {
+			selection = repoCombo.getSelectionIndex();
+		} else {
+			selection = getComboIndex(repoCombo.getText());
+		}
+		int localIndex = getLocalSites().length == 0 ? repoCombo.getItemCount() : repoCombo.getItemCount() - 1;
+		if (comboRepos == null || selection < 0) {
+			selection = INDEX_SITE_NONE;
+		}
+
+		if (selection == INDEX_SITE_NONE) {
+			repoChoice = AvailableIUGroup.AVAILABLE_NONE;
+		} else if (selection == INDEX_SITE_ALL) {
+			repoChoice = AvailableIUGroup.AVAILABLE_ALL;
+		} else if (selection >= localIndex) {
+			repoChoice = AvailableIUGroup.AVAILABLE_LOCAL;
+		} else {
+			repoChoice = AvailableIUGroup.AVAILABLE_SPECIFIED;
+			repoLocation = comboRepos[selection];
+		}
+
+		Object[] selectionListeners = listeners.getListeners();
+		for (int i = 0; i < selectionListeners.length; i++) {
+			((IRepositorySelectionListener) selectionListeners[i]).repositorySelectionChanged(repoChoice, repoLocation);
+		}
+	}
+}
