commit 2d3e4454cfdde906ded295743e8d03056290c84a
Author: Andrew Niefer <aniefer>
Date:   Sat Feb 21 00:08:40 2009 +0000

    bug 190041 - signing zips with jarprocessor ant task
    bug 219832 - signing with keypass
    bug 265564 - signing and packing artifact repos

1	0	bundles/org.eclipse.equinox.p2.jarprocessor/.classpath
19	0	bundles/org.eclipse.equinox.p2.jarprocessor/.externalToolBuilders/AntTaskBuilder.launch
10	0	bundles/org.eclipse.equinox.p2.jarprocessor/.project
1	0	bundles/org.eclipse.equinox.p2.jarprocessor/META-INF/MANIFEST.MF
10	1	bundles/org.eclipse.equinox.p2.jarprocessor/build.properties
1	0	bundles/org.eclipse.equinox.p2.jarprocessor/lib/.cvsignore
12	0	bundles/org.eclipse.equinox.p2.jarprocessor/localbuild.xml
21	0	bundles/org.eclipse.equinox.p2.jarprocessor/plugin.xml
56	70	bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/ZipProcessor.java
37	0	bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/unsigner/UnsignCommand.java
147	0	bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/unsigner/Unsigner.java
3	7	bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/internal/provisional/equinox/p2/jarprocessor/JarProcessorExecutor.java
36	0	bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/AntBasedProcessorExecutor.java
59	0	bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/AntSignCommand.java
110	0	bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/JarProcessorTask.java
3	0	bundles/org.eclipse.equinox.p2.repository.tools/META-INF/MANIFEST.MF
2	1	bundles/org.eclipse.equinox.p2.repository.tools/build.properties
7	4	bundles/org.eclipse.equinox.p2.repository.tools/plugin.xml
2	1	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/Messages.java
140	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/RecreateRepositoryApplication.java
57	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/RepositoryUtilities.java
4	1	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/messages.properties
129	0	bundles/org.eclipse.equinox.p2.repository.tools/src_ant/org/eclipse/equinox/p2/internal/repository/tools/tasks/ProcessRepoTask.java
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/.classpath b/bundles/org.eclipse.equinox.p2.jarprocessor/.classpath
index 7cdeb73..0179ed6 100644
--- a/bundles/org.eclipse.equinox.p2.jarprocessor/.classpath
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/.classpath
@@ -1,6 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
 	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" output="bin_ant" path="src_ant"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/CDC-1.1%Foundation-1.1"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="output" path="bin"/>
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/.externalToolBuilders/AntTaskBuilder.launch b/bundles/org.eclipse.equinox.p2.jarprocessor/.externalToolBuilders/AntTaskBuilder.launch
new file mode 100644
index 0000000..ae56944
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/.externalToolBuilders/AntTaskBuilder.launch
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<launchConfiguration type="org.eclipse.ant.AntBuilderLaunchConfigurationType">
+<booleanAttribute key="org.eclipse.ant.ui.ATTR_TARGETS_UPDATED" value="true"/>
+<booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS">
+<listEntry value="/org.eclipse.equinox.p2.jarprocessor/localbuild.xml"/>
+</listAttribute>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES">
+<listEntry value="1"/>
+</listAttribute>
+<booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
+<stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="true"/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value="org.eclipse.equinox.p2.jarprocessor"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${workspace_loc:/org.eclipse.equinox.p2.jarprocessor/localbuild.xml}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS" value="full,incremental,"/>
+<booleanAttribute key="org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED" value="true"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${workspace_loc:/org.eclipse.equinox.p2.jarprocessor}"/>
+</launchConfiguration>
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/.project b/bundles/org.eclipse.equinox.p2.jarprocessor/.project
index b3a3e9e..a81ef80 100644
--- a/bundles/org.eclipse.equinox.p2.jarprocessor/.project
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/.project
@@ -20,6 +20,16 @@
 			<arguments>
 			</arguments>
 		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>LaunchConfigHandle</key>
+					<value>&lt;project&gt;/.externalToolBuilders/AntTaskBuilder.launch</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
 	</buildSpec>
 	<natures>
 		<nature>org.eclipse.pde.PluginNature</nature>
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.jarprocessor/META-INF/MANIFEST.MF
index 23b25c5..6556242 100644
--- a/bundles/org.eclipse.equinox.p2.jarprocessor/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/META-INF/MANIFEST.MF
@@ -8,5 +8,6 @@ Bundle-Version: 1.0.0.qualifier
 Bundle-RequiredExecutionEnvironment: CDC-1.1/Foundation-1.1,
  J2SE-1.4
 Export-Package: org.eclipse.equinox.internal.p2.jarprocessor;x-friends:="org.eclipse.equinox.p2.artifact.repository,org.eclipse.pde.build",
+ org.eclipse.equinox.internal.p2.jarprocessor.unsigner;x-internal:=true,
  org.eclipse.equinox.internal.p2.jarprocessor.verifier;x-internal:=true,
  org.eclipse.internal.provisional.equinox.p2.jarprocessor;x-friends:="org.eclipse.equinox.p2.artifact.optimizers,org.eclipse.equinox.p2.artifact.repository,org.eclipse.pde.build"
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/build.properties b/bundles/org.eclipse.equinox.p2.jarprocessor/build.properties
index a6b8330..d8902a1 100644
--- a/bundles/org.eclipse.equinox.p2.jarprocessor/build.properties
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/build.properties
@@ -13,5 +13,14 @@ output.. = bin/
 bin.includes = META-INF/,\
                .,\
                about.html,\
-               plugin.properties
+               plugin.properties,\
+               plugin.xml,\
+               lib/jarprocessor-ant.jar
 src.includes = about.html
+
+source.lib/jarprocessor-ant.jar = src_ant/
+output.lib/jarprocessor-ant.jar = bin_ant/
+
+jars.extra.classpath = platform:/plugin/org.apache.ant/lib/ant.jar
+jars.compile.order = .,\
+                     lib/jarprocessor-ant.jar
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/lib/.cvsignore b/bundles/org.eclipse.equinox.p2.jarprocessor/lib/.cvsignore
new file mode 100644
index 0000000..c45d3e9
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/lib/.cvsignore
@@ -0,0 +1 @@
+jarprocessor-ant.jar
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/localbuild.xml b/bundles/org.eclipse.equinox.p2.jarprocessor/localbuild.xml
new file mode 100644
index 0000000..107dcb2
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/localbuild.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0"?>
+<project name="project" default="workspaceBinaries">
+	<description>
+    	 Build the jarprocessor-ant.jar by gathering up the results of a workspace build from bin_ant.
+    </description>
+
+	<target name="workspaceBinaries" description="Jar up the binaries that were compiled by the jdt builder" >
+		<mkdir dir="lib" />
+		<delete file="lib/jarprocessor-ant.jar" failonerror="false"/>
+		<jar destfile="lib/jarprocessor-ant.jar" basedir="bin_ant"/>
+	</target>
+</project>
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/plugin.xml b/bundles/org.eclipse.equinox.p2.jarprocessor/plugin.xml
new file mode 100644
index 0000000..36d254f
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/plugin.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<?eclipse version="3.0"?>
+<plugin>
+	<!-- Tasks -->
+   <extension
+         point="org.eclipse.ant.core.antTasks">
+      <antTask
+            class="org.eclipse.equinox.internal.p2.jarprocessor.ant.JarProcessorTask"
+            headless="true"
+            library="lib/jarprocessor-ant.jar"
+            name="eclipse.jarProcessor">
+      </antTask>
+   </extension>
+	<!-- Extra Classpath -->
+   <extension
+         point="org.eclipse.ant.core.extraClasspathEntries">
+      <extraClasspathEntry
+            library="lib/jarprocessor-ant.jar">
+      </extraClasspathEntry>
+   </extension>
+</plugin>
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/ZipProcessor.java b/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/ZipProcessor.java
index 92a1cf8..15b7a74 100644
--- a/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/ZipProcessor.java
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/ZipProcessor.java
@@ -10,11 +10,21 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.jarprocessor;
 
-import java.io.*;
-import java.util.*;
-import java.util.zip.*;
-import org.eclipse.internal.provisional.equinox.p2.jarprocessor.IProcessStep;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Enumeration;
+import java.util.Properties;
+import java.util.Set;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipException;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
+
 import org.eclipse.internal.provisional.equinox.p2.jarprocessor.JarProcessor;
+import org.eclipse.internal.provisional.equinox.p2.jarprocessor.JarProcessorExecutor;
 
 /**
  * @author aniefer@ca.ibm.com
@@ -22,23 +32,22 @@ import org.eclipse.internal.provisional.equinox.p2.jarprocessor.JarProcessor;
  */
 public class ZipProcessor {
 
-	private IProcessStep signStep = null;
-	private IProcessStep packStep = null;
-	private IProcessStep packUnpackStep = null;
-	private IProcessStep unpackStep = null;
-
+	private JarProcessorExecutor executor = null;
+	private JarProcessorExecutor.Options options = null;
+	
 	private String workingDirectory = null;
 	private Properties properties = null;
 	private Set packExclusions = null;
 	private Set signExclusions = null;
-	private String command = null;
-	private boolean packing = false;
-	private boolean signing = false;
-	private boolean repacking = false;
-	private boolean unpacking = false;
-	private boolean verbose = false;
-	private boolean processAll = false;
-
+	
+	public void setExecutor(JarProcessorExecutor executor) {
+		this.executor = executor;
+	}
+	
+	public void setOptions(JarProcessorExecutor.Options options) {
+		this.options = options;
+	}
+	
 	public void setWorkingDirectory(String dir) {
 		workingDirectory = dir;
 	}
@@ -49,45 +58,24 @@ public class ZipProcessor {
 		return workingDirectory;
 	}
 
-	public void setSignCommand(String command) {
-		this.command = command;
-		this.signing = (command != null);
-	}
-
-	public void setPack(boolean pack) {
-		this.packing = pack;
-	}
-
-	public void setRepack(boolean repack) {
-		this.repacking = repack;
-	}
-
-	public void setUnpack(boolean unpack) {
-		this.unpacking = unpack;
-	}
-
-	public void setVerbose(boolean verbose) {
-		this.verbose = verbose;
-	}
-
-	public void setProcessAll(boolean all) {
-		this.processAll = all;
+	private boolean repacking() {
+		return options.repack || (options.pack && options.signCommand != null);
 	}
-
+	
 	public void processZip(File zipFile) throws ZipException, IOException {
-		if (verbose)
+		if (options.verbose)
 			System.out.println("Processing " + zipFile.getPath()); //$NON-NLS-1$
 		ZipFile zip = new ZipFile(zipFile);
 		initialize(zip);
 
-		String extension = unpacking ? "pack.gz" : ".jar"; //$NON-NLS-1$ //$NON-NLS-2$
+		String extension = options.unpack ? "pack.gz" : ".jar"; //$NON-NLS-1$ //$NON-NLS-2$
 		File tempDir = new File(getWorkingDirectory(), "temp_" + zipFile.getName()); //$NON-NLS-1$
 		JarProcessor processor = new JarProcessor();
-		processor.setVerbose(verbose);
-		processor.setProcessAll(processAll);
+		processor.setVerbose(options.verbose);
+		processor.setProcessAll(options.processAll);
 		processor.setWorkingDirectory(tempDir.getCanonicalPath());
-		if (unpacking) {
-			processor.addProcessStep(unpackStep);
+		if (options.unpack) {
+			executor.addPackUnpackStep(processor, properties, options);
 		}
 
 		File outputFile = new File(getWorkingDirectory(), zipFile.getName() + ".temp"); //$NON-NLS-1$
@@ -102,31 +90,31 @@ public class ZipProcessor {
 
 				InputStream entryStream = zip.getInputStream(entry);
 
-				boolean pack = packing && !packExclusions.contains(name);
-				boolean sign = signing && !signExclusions.contains(name);
-				boolean repack = repacking && !packExclusions.contains(name);
+				boolean pack = options.pack && !packExclusions.contains(name);
+				boolean sign = options.signCommand != null && !signExclusions.contains(name);
+				boolean repack = repacking() && !packExclusions.contains(name);
 
 				File extractedFile = null;
 
-				if (entry.getName().endsWith(extension) && (pack || sign || repack || unpacking)) {
+				if (entry.getName().endsWith(extension) && (pack || sign || repack || options.unpack)) {
 					extractedFile = new File(tempDir, name);
 					parent = extractedFile.getParentFile();
 					if (!parent.exists())
 						parent.mkdirs();
-					if (verbose)
+					if (options.verbose)
 						System.out.println("Extracting " + entry.getName()); //$NON-NLS-1$
 					FileOutputStream extracted = new FileOutputStream(extractedFile);
 					Utils.transferStreams(entryStream, extracted, true); // this will close the stream
 					entryStream = null;
 
-					boolean skip = Utils.shouldSkipJar(extractedFile, processAll, verbose);
+					boolean skip = Utils.shouldSkipJar(extractedFile, options.processAll, options.verbose);
 					if (skip) {
 						//skipping this file 
 						entryStream = new FileInputStream(extractedFile);
-						if (verbose)
+						if (options.verbose)
 							System.out.println(entry.getName() + " is not marked, skipping."); //$NON-NLS-1$
 					} else {
-						if (unpacking) {
+						if (options.unpack) {
 							File result = processor.processJar(extractedFile);
 							name = name.substring(0, name.length() - extractedFile.getName().length()) + result.getName();
 							extractedFile = result;
@@ -134,19 +122,19 @@ public class ZipProcessor {
 							if (repack || sign) {
 								processor.clearProcessSteps();
 								if (repack)
-									processor.addProcessStep(packUnpackStep);
+									executor.addPackUnpackStep(processor, properties, options);
 								if (sign)
-									processor.addProcessStep(signStep);
+									executor.addSignStep(processor, properties, options);
 								extractedFile = processor.processJar(extractedFile);
 							}
 							if (pack) {
 								processor.clearProcessSteps();
-								processor.addProcessStep(packStep);
+								executor.addPackStep(processor, properties, options);
 								File modifiedFile = processor.processJar(extractedFile);
 								if (modifiedFile.exists()) {
 									try {
 										String newName = name.substring(0, name.length() - extractedFile.getName().length()) + modifiedFile.getName();
-										if (verbose) {
+										if (options.verbose) {
 											System.out.println("Adding " + newName + " to " + outputFile.getPath()); //$NON-NLS-1$ //$NON-NLS-2$
 											System.out.println();
 										}
@@ -158,13 +146,13 @@ public class ZipProcessor {
 										Utils.clear(modifiedFile);
 									} catch (IOException e) {
 										Utils.close(entryStream);
-										if (verbose) {
+										if (options.verbose) {
 											e.printStackTrace();
 											System.out.println("Warning: Problem reading " + modifiedFile.getPath() + ".");
 										}
 									}
 									entryStream = null;
-								} else if (verbose) {
+								} else if (options.verbose) {
 									System.out.println("Warning: " + modifiedFile.getPath() + " not found.");
 								}
 							}
@@ -173,14 +161,14 @@ public class ZipProcessor {
 							try {
 								entryStream = new FileInputStream(extractedFile);
 							} catch (IOException e) {
-								if (verbose) {
+								if (options.verbose) {
 									e.printStackTrace();
 									System.out.println("Warning: Problem reading " + extractedFile.getPath() + ".");
 								}
 							}
 						}
 
-						if (verbose && entryStream != null) {
+						if (options.verbose && entryStream != null) {
 							System.out.println("Adding " + name + " to " + outputFile.getPath()); //$NON-NLS-1$ //$NON-NLS-2$
 						}
 					}
@@ -192,7 +180,7 @@ public class ZipProcessor {
 						Utils.transferStreams(entryStream, zipOut, false);
 						zipOut.closeEntry();
 					} catch (ZipException e) {
-						if(verbose) {
+						if(options.verbose) {
 							System.out.println("Warning: " + name + " already exists in " + outputFile.getName() + ".  Skipping.");
 						}
 					}
@@ -202,7 +190,7 @@ public class ZipProcessor {
 				if (extractedFile != null)
 					Utils.clear(extractedFile);
 				
-				if (verbose) {
+				if (options.verbose) {
 					System.out.println();
 					System.out.println("Processing " + zipFile.getPath()); //$NON-NLS-1$
 				}
@@ -227,7 +215,7 @@ public class ZipProcessor {
 				stream = zip.getInputStream(entry);
 				properties.load(stream);
 			} catch (IOException e) {
-				if (verbose)
+				if (options.verbose)
 					e.printStackTrace();
 			} finally {
 				Utils.close(stream);
@@ -237,9 +225,7 @@ public class ZipProcessor {
 		packExclusions = Utils.getPackExclusions(properties);
 		signExclusions = Utils.getSignExclusions(properties);
 
-		packUnpackStep = new PackUnpackStep(properties, verbose);
-		packStep = new PackStep(properties, verbose);
-		signStep = new SignCommandStep(properties, command, verbose);
-		unpackStep = new UnpackStep(properties, verbose);
+		if (executor == null)
+			executor = new JarProcessorExecutor();
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/unsigner/UnsignCommand.java b/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/unsigner/UnsignCommand.java
new file mode 100644
index 0000000..0ef56d0
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/unsigner/UnsignCommand.java
@@ -0,0 +1,37 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM - Initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.jarprocessor.unsigner;
+
+import java.io.File;
+import java.util.List;
+import java.util.Properties;
+import org.eclipse.equinox.internal.p2.jarprocessor.SignCommandStep;
+
+public class UnsignCommand extends SignCommandStep {
+
+	public UnsignCommand(Properties options, String command, boolean verbose) {
+		super(options, command, verbose);
+	}
+
+	public File postProcess(File input, File workingDirectory, List containers) {
+		if (command != null && input != null && shouldSign(input, containers)) {
+			execute(input);
+		}
+		return null;
+	}
+
+	private void execute(File input) {
+		Unsigner jarUnsigner = new Unsigner();
+		jarUnsigner.setJar(input);
+		jarUnsigner.setKeepManifestEntries(false);
+		jarUnsigner.execute();
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/unsigner/Unsigner.java b/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/unsigner/Unsigner.java
new file mode 100644
index 0000000..9557019
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/equinox/internal/p2/jarprocessor/unsigner/Unsigner.java
@@ -0,0 +1,147 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.jarprocessor.unsigner;
+import java.io.*;
+import java.util.Enumeration;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
+import java.util.zip.*;
+
+/**
+ * This class removes the signature files from a jar and clean up the manifest.   
+ */
+public class Unsigner {
+	private static final String META_INF = "META-INF"; //$NON-NLS-1$
+	private static final String DSA_EXT = ".DSA"; //$NON-NLS-1$
+	private static final String RSA_EXT = ".RSA"; //$NON-NLS-1$
+	private static final String SF_EXT = ".SF"; //$NON-NLS-1$
+	private static final String META_INF_PREFIX = META_INF + '/';
+	
+	private String[] signers;
+	private File jarFile;
+	private boolean keepManifestContent = false;
+	
+	private boolean isSigned(File file) {
+		ZipFile jar = null;
+		try {
+			jar = new ZipFile(file);
+
+			if (signers != null) {
+				for (int i = 0; i < signers.length; i++) {
+					if (jar.getEntry((META_INF_PREFIX + signers[i] + SF_EXT).toUpperCase()) != null)
+						return true;
+				}
+			} else {
+				Enumeration entries = jar.entries();
+				while (entries.hasMoreElements()) {
+					ZipEntry entry = (ZipEntry) entries.nextElement();
+					String entryName = entry.getName();
+					if(entryName.endsWith(SF_EXT) && entryName.startsWith(META_INF))
+						return true;
+				}
+			}
+			return false;
+		} catch (ZipException e) {
+			return false;
+		} catch (IOException e) {
+			return false;
+		} finally {
+			if (jar != null)
+				try {
+					jar.close();
+				} catch (IOException e) {
+					//Ignore
+				}
+		}
+	}
+	
+	public void execute() {
+		processJar(jarFile);
+	}
+	
+	private void processJar(File inputFile) {
+		if (!isSigned(inputFile))
+			return;
+
+		try {
+			ZipInputStream input = new ZipInputStream(new BufferedInputStream(new FileInputStream(inputFile)));
+			File outputFile = File.createTempFile("removing.", ".signature", inputFile.getParentFile()); //$NON-NLS-1$ //$NON-NLS-2$
+			ZipOutputStream output = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(outputFile)));
+
+			ZipEntry inputZe = input.getNextEntry();
+			byte[] b = new byte[8192];
+			while (inputZe != null) {
+				byte remove = shouldRemove(inputZe);
+				if (remove == 2) {
+					inputZe = input.getNextEntry();
+					continue;
+				}
+
+				//copy the file or modify the manifest.mf
+				if (remove == 1) {
+					output.putNextEntry(new ZipEntry(inputZe.getName()));
+					Manifest m = new Manifest();
+					m.read(input);
+					m.getEntries().clear(); //This is probably not subtle enough
+					m.write(output);
+				} else {
+					output.putNextEntry(inputZe);
+					while (input.available() != 0) {
+						int read = input.read(b);
+						if (read != -1)
+							output.write(b, 0, read);
+					}
+				}
+				output.closeEntry();
+				input.closeEntry();
+
+				inputZe = input.getNextEntry();
+			}
+			output.close();
+			input.close();
+			inputFile.delete();
+			outputFile.renameTo(inputFile);
+		} catch (FileNotFoundException e) {
+			//this can't happen we have checked before
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+	
+	private byte shouldRemove(ZipEntry entry) {
+		String entryName = entry.getName();
+		if(keepManifestContent == false && entryName.equalsIgnoreCase(JarFile.MANIFEST_NAME)) {
+			return 1;
+		}
+		if (signers != null) {
+			for (int i = 0; i < signers.length; i++) {
+				if (entryName.equalsIgnoreCase(META_INF_PREFIX + signers[i] + SF_EXT) || entryName.equalsIgnoreCase(META_INF_PREFIX + signers[i] + RSA_EXT) || entryName.equalsIgnoreCase(META_INF_PREFIX + signers[i] + DSA_EXT))
+					return 2;
+			}
+		} else {
+			if (entryName.startsWith(META_INF) && (entryName.endsWith(SF_EXT) || entryName.endsWith(RSA_EXT) || entryName.endsWith(DSA_EXT)))
+				return 2;
+		}
+		return 0;
+	}
+	
+	public void setRemoveSigners(String[] fileName) {
+		signers = fileName;
+	}
+	
+	public void setJar(File file) {
+		jarFile = file;
+	}
+	
+	public void setKeepManifestEntries(boolean keep) {
+		keepManifestContent = keep;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/internal/provisional/equinox/p2/jarprocessor/JarProcessorExecutor.java b/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/internal/provisional/equinox/p2/jarprocessor/JarProcessorExecutor.java
index 29a560e..6fed1b2 100644
--- a/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/internal/provisional/equinox/p2/jarprocessor/JarProcessorExecutor.java
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/src/org/eclipse/internal/provisional/equinox/p2/jarprocessor/JarProcessorExecutor.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -32,12 +32,8 @@ public class JarProcessorExecutor {
 		if (options.input.isFile() && options.input.getName().endsWith(".zip")) { //$NON-NLS-1$
 			ZipProcessor processor = new ZipProcessor();
 			processor.setWorkingDirectory(options.outputDir);
-			processor.setSignCommand(options.signCommand);
-			processor.setPack(options.pack);
-			processor.setRepack(options.repack || (options.pack && options.signCommand != null));
-			processor.setUnpack(options.unpack);
-			processor.setVerbose(options.verbose);
-			processor.setProcessAll(options.processAll);
+			processor.setOptions(options);
+			processor.setExecutor(this);
 			try {
 				processor.processZip(options.input);
 			} catch (ZipException e) {
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/AntBasedProcessorExecutor.java b/bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/AntBasedProcessorExecutor.java
new file mode 100644
index 0000000..62e995e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/AntBasedProcessorExecutor.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM - Initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.jarprocessor.ant;
+
+import java.util.Properties;
+import org.apache.tools.ant.Project;
+import org.eclipse.equinox.internal.p2.jarprocessor.unsigner.UnsignCommand;
+import org.eclipse.internal.provisional.equinox.p2.jarprocessor.JarProcessor;
+import org.eclipse.internal.provisional.equinox.p2.jarprocessor.JarProcessorExecutor;
+
+public class AntBasedProcessorExecutor extends JarProcessorExecutor {
+	private final Project project;
+	private final Properties signArguments;
+	private final String antTaskName;
+
+	public AntBasedProcessorExecutor(Properties signArguments, Project project, String antTaskName) {
+		this.signArguments = signArguments;
+		this.project = project;
+		this.antTaskName = antTaskName;
+	}
+
+	public void addSignStep(JarProcessor processor, Properties properties, Options options) {
+		if (signArguments.get(JarProcessorTask.UNSIGN) != null)
+			processor.addProcessStep(new UnsignCommand(properties, options.signCommand, options.verbose));
+		if (signArguments.get(JarProcessorTask.SIGN) != null)
+			processor.addProcessStep(new AntSignCommand(properties, signArguments, project, antTaskName, options.signCommand, options.verbose));
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/AntSignCommand.java b/bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/AntSignCommand.java
new file mode 100644
index 0000000..591cf8c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/AntSignCommand.java
@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM - Initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.jarprocessor.ant;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.List;
+import java.util.Properties;
+import org.apache.tools.ant.BuildException;
+import org.apache.tools.ant.Project;
+import org.apache.tools.ant.taskdefs.SignJar;
+import org.eclipse.equinox.internal.p2.jarprocessor.SignCommandStep;
+
+public class AntSignCommand extends SignCommandStep {
+	private final Project project;
+	private final Properties jarSignerArguments;
+	private final String antTaskName;
+
+	public AntSignCommand(Properties options, Properties signArguments, Project project, String antTaskName, String command, boolean verbose) {
+		super(options, command, verbose);
+		this.project = project;
+		this.jarSignerArguments = signArguments;
+		this.antTaskName = antTaskName;
+	}
+
+	public File postProcess(File input, File workingDirectory, List containers) {
+		if (command != null && input != null && shouldSign(input, containers)) {
+			execute(input);
+		}
+		return null;
+	}
+
+	private void execute(File input) {
+		try {
+			SignJar jarSigner = new SignJar();
+			jarSigner.setJar(input);
+			jarSigner.setAlias(jarSignerArguments.getProperty(JarProcessorTask.ALIAS));
+			jarSigner.setKeystore(jarSignerArguments.getProperty(JarProcessorTask.KEYSTORE));
+			jarSigner.setStorepass(jarSignerArguments.getProperty(JarProcessorTask.STOREPASS));
+			jarSigner.setKeypass(jarSignerArguments.getProperty(JarProcessorTask.KEYPASS));
+			jarSigner.setProject(project);
+			jarSigner.setTaskName(antTaskName);
+			jarSigner.execute();
+		} catch (BuildException e) {
+			if (e.getCause() instanceof IOException) {
+				throw new BuildException("The jarsigner could not be found. Make sure to run with the build with a JDK.", e); //$NON-NLS-1$
+			}
+			throw e;
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/JarProcessorTask.java b/bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/JarProcessorTask.java
new file mode 100644
index 0000000..9989bca
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.jarprocessor/src_ant/org/eclipse/equinox/internal/p2/jarprocessor/ant/JarProcessorTask.java
@@ -0,0 +1,110 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM - Initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.jarprocessor.ant;
+
+import java.io.File;
+import java.util.Properties;
+import org.apache.tools.ant.BuildException;
+import org.apache.tools.ant.Task;
+import org.eclipse.internal.provisional.equinox.p2.jarprocessor.JarProcessorExecutor.Options;
+
+/**
+ * This task provides massaging facilities for jar files.
+ * It supports: signing, unsigning, normalization, packing
+ * 	- 
+ */
+public class JarProcessorTask extends Task {
+	private final Options options = new Options();
+	private final Properties signArgs = new Properties();
+
+	public static final String ALIAS = "alias"; //$NON-NLS-1$
+	public static final String KEYSTORE = "keystore"; //$NON-NLS-1$
+	public static final String STOREPASS = "storepass"; //$NON-NLS-1$
+	public static final String KEYPASS = "keypass"; //$NON-NLS-1$
+	public static final String UNSIGN = "unsign"; //$NON-NLS-1$
+	public static final String SIGN = "sign"; //$NON-NLS-1$
+
+	private static final String FAKE_COMMAND = "fake"; //$NON-NLS-1$
+
+	public void setAlias(String alias) {
+		signArgs.setProperty(ALIAS, alias);
+	}
+
+	public void setKeystore(String keystore) {
+		signArgs.setProperty(KEYSTORE, keystore);
+	}
+
+	public void setJar(File jar) {
+		options.input = jar;
+		options.outputDir = jar.getParentFile().getAbsolutePath();
+	}
+
+	public void setInputFolder(File folder) {
+		options.input = folder;
+		options.outputDir = folder.getAbsolutePath();
+	}
+
+	public void setStorepass(String storepass) {
+		signArgs.setProperty(STOREPASS, storepass);
+	}
+
+	public void setKeypass(String keypass) {
+		if (keypass != null && keypass.length() > 0 && !keypass.startsWith("${")) //$NON-NLS-1$
+			signArgs.setProperty(KEYPASS, keypass);
+	}
+
+	public void setPack(boolean pack) {
+		options.pack = pack;
+	}
+
+	public void setNormalize(boolean normalize) {
+		options.repack = normalize;
+	}
+
+	public void setUnsign(boolean unsign) {
+		if (unsign) {
+			signArgs.put(UNSIGN, Boolean.TRUE.toString());
+			options.signCommand = FAKE_COMMAND;
+		}
+	}
+
+	public void setSign(boolean sign) {
+		if (sign) {
+			signArgs.put(SIGN, Boolean.TRUE.toString());
+			options.signCommand = FAKE_COMMAND;
+		}
+	}
+
+	private void adjustAndValidateConfiguration() {
+		//Sign and pack implies a normalization
+		if (options.signCommand != null && options.pack)
+			options.repack = true;
+
+		//Check that alias, and storepass are set
+		if (options.signCommand != null && signArgs.getProperty(UNSIGN) == null) {
+			if (signArgs.getProperty(ALIAS) == null)
+				throw new BuildException("Alias must be set"); //$NON-NLS-1$
+
+			if (signArgs.getProperty(STOREPASS) == null)
+				throw new BuildException("Storepass must be set"); //$NON-NLS-1$
+		}
+	}
+
+	public void execute() {
+		options.processAll = true;
+		adjustAndValidateConfiguration();
+		new AntBasedProcessorExecutor(signArgs, getProject(), getTaskName()).runJarProcessor(options);
+	}
+
+	public void setVerbose(boolean verbose) {
+		options.verbose = verbose;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.repository.tools/META-INF/MANIFEST.MF
index fc7b62d..3acb7f2 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/META-INF/MANIFEST.MF
@@ -12,10 +12,12 @@ Import-Package: org.apache.tools.ant,
  org.eclipse.equinox.app;version="1.0.0",
  org.eclipse.equinox.internal.p2.artifact.mirror,
  org.eclipse.equinox.internal.p2.artifact.repository,
+ org.eclipse.equinox.internal.p2.artifact.repository.simple,
  org.eclipse.equinox.internal.p2.core.helpers,
  org.eclipse.equinox.internal.p2.director,
  org.eclipse.equinox.internal.p2.metadata.repository,
  org.eclipse.equinox.internal.provisional.p2.artifact.repository,
+ org.eclipse.equinox.internal.provisional.p2.artifact.repository.processing,
  org.eclipse.equinox.internal.provisional.p2.core,
  org.eclipse.equinox.internal.provisional.p2.core.repository,
  org.eclipse.equinox.internal.provisional.p2.engine,
@@ -24,6 +26,7 @@ Import-Package: org.apache.tools.ant,
  org.eclipse.equinox.internal.provisional.p2.metadata.query,
  org.eclipse.equinox.internal.provisional.p2.metadata.repository,
  org.eclipse.equinox.internal.provisional.p2.query,
+ org.eclipse.internal.provisional.equinox.p2.jarprocessor,
  org.eclipse.osgi.util;version="1.1.0",
  org.osgi.framework;version="1.5.0",
  org.osgi.service.packageadmin;version="1.2.0"
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/build.properties b/bundles/org.eclipse.equinox.p2.repository.tools/build.properties
index 112892e..1faf16e 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/build.properties
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/build.properties
@@ -20,5 +20,6 @@ extra.lib/repository-tools-ant.jar = ../org.apache.ant/ant.jar
 jars.compile.order = ., lib/repository-tools-ant.jar
 source.lib/repository-tools-ant.jar = src_ant/
 output.lib/repository-tools-ant.jar = bin_ant/
-jars.extra.classpath=platform:/plugin/org.apache.ant/lib/ant.jar
+jars.extra.classpath=platform:/plugin/org.apache.ant/lib/ant.jar,\
+                     platform:/plugin/org.eclipse.equinox.p2.jarprocessor/lib/jarprocessor-ant.jar
 src.includes = about.html
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/plugin.xml b/bundles/org.eclipse.equinox.p2.repository.tools/plugin.xml
index d823e84..2399269 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/plugin.xml
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/plugin.xml
@@ -9,15 +9,18 @@
             library="lib/repository-tools-ant.jar"
             name="p2.repo2runnable">
       </antTask>
-  </extension>
-  
-  <extension
-         point="org.eclipse.ant.core.antTasks">
+
      <antTask
             class="org.eclipse.equinox.p2.internal.repository.tools.tasks.MirrorTask"
             library="lib/repository-tools-ant.jar"
             name="p2.mirror">
       </antTask>
+      
+      <antTask
+			library="lib/repository-tools-ant.jar"
+			name="p2.process.artifacts"
+			class="org.eclipse.equinox.p2.internal.repository.tools.tasks.ProcessRepoTask" >
+	  </antTask>
   </extension>
   
   <extension
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/Messages.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/Messages.java
index 3cca3b9..f238147 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/Messages.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/Messages.java
@@ -15,7 +15,8 @@ import org.eclipse.osgi.util.NLS;
 public class Messages extends NLS {
 	private static final String BUNDLE_NAME = "org.eclipse.equinox.p2.internal.repository.tools.messages"; //$NON-NLS-1$
 	public static String exception_destinationNotModifiable;
-
+	public static String exception_unableToRemoveRepo;
+	public static String exception_notLocalFileRepo;
 	static {
 		// initialize resource bundles
 		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/RecreateRepositoryApplication.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/RecreateRepositoryApplication.java
new file mode 100644
index 0000000..1d826de
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/RecreateRepositoryApplication.java
@@ -0,0 +1,140 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.internal.repository.tools;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URI;
+import java.util.*;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.*;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.processing.ProcessingStepDescriptor;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IArtifactKey;
+import org.eclipse.osgi.util.NLS;
+
+public class RecreateRepositoryApplication {
+
+	private RepositoryDescriptor descriptor;
+	private String repoName = null;
+	private Map repoProperties = null;
+	private Map repoMap = null;
+
+	public IStatus run(IProgressMonitor monitor) throws ProvisionException, IOException {
+
+		IArtifactRepository repository = initialize(monitor);
+		removeRepository(repository, monitor);
+		recreateRepository(monitor);
+
+		return null;
+	}
+
+	public void setArtifactRepository(RepositoryDescriptor descriptor) {
+		this.descriptor = descriptor;
+	}
+
+	private IArtifactRepository initialize(IProgressMonitor monitor) throws ProvisionException {
+		IArtifactRepositoryManager repositoryManager = Activator.getArtifactRepositoryManager();
+
+		IArtifactRepository repository = repositoryManager.loadRepository(descriptor.getRepoLocation(), IRepositoryManager.REPOSITORY_HINT_MODIFIABLE, monitor);
+
+		if (repository == null || !repository.isModifiable())
+			throw new ProvisionException(NLS.bind(Messages.exception_destinationNotModifiable, repository.getLocation()));
+		if (!(repository instanceof IFileArtifactRepository))
+			throw new ProvisionException(NLS.bind(Messages.exception_notLocalFileRepo, repository.getLocation()));
+
+		repoName = repository.getName();
+		repoProperties = repository.getProperties();
+
+		repoMap = new HashMap();
+		IArtifactKey[] keys = repository.getArtifactKeys();
+		for (int i = 0; i < keys.length; i++) {
+			IArtifactDescriptor[] descriptors = repository.getArtifactDescriptors(keys[i]);
+			repoMap.put(keys[i], descriptors);
+		}
+
+		return repository;
+	}
+
+	private void removeRepository(IArtifactRepository repository, IProgressMonitor monitor) throws ProvisionException, IOException {
+		IArtifactRepositoryManager manager = Activator.getArtifactRepositoryManager();
+		manager.removeRepository(repository.getLocation());
+
+		boolean compressed = Boolean.valueOf((String) repoProperties.get(IRepository.PROP_COMPRESSED)).booleanValue();
+		URI realLocation = SimpleArtifactRepository.getActualLocation(repository.getLocation(), compressed);
+		File realFile = URIUtil.toFile(realLocation);
+
+		if (!realFile.exists() || !realFile.delete())
+			throw new ProvisionException(NLS.bind(Messages.exception_unableToRemoveRepo, realFile.toString()));
+	}
+
+	private void recreateRepository(IProgressMonitor monitor) throws ProvisionException {
+		IArtifactRepositoryManager manager = Activator.getArtifactRepositoryManager();
+
+		IArtifactRepository repository = manager.createRepository(descriptor.getRepoLocation(), repoName, IArtifactRepositoryManager.TYPE_SIMPLE_REPOSITORY, repoProperties);
+		if (!(repository instanceof IFileArtifactRepository))
+			throw new ProvisionException(NLS.bind(Messages.exception_notLocalFileRepo, repository.getLocation()));
+
+		IFileArtifactRepository simple = (IFileArtifactRepository) repository;
+		for (Iterator iterator = repoMap.keySet().iterator(); iterator.hasNext();) {
+			IArtifactKey key = (IArtifactKey) iterator.next();
+			IArtifactDescriptor[] descriptors = (IArtifactDescriptor[]) repoMap.get(key);
+
+			String unpackedSize = null;
+			File packFile = null;
+			Set files = new HashSet();
+			for (int i = 0; i < descriptors.length; i++) {
+				File artifactFile = simple.getArtifactFile(descriptors[i]);
+				files.add(artifactFile);
+
+				String size = Long.toString(artifactFile.length());
+
+				ArtifactDescriptor newDescriptor = new ArtifactDescriptor(descriptors[i]);
+				newDescriptor.setProperty(IArtifactDescriptor.ARTIFACT_SIZE, size);
+				newDescriptor.setProperty(IArtifactDescriptor.DOWNLOAD_SIZE, size);
+				//only set an MD5 if there was one to start with
+				if (newDescriptor.getProperties().containsKey(IArtifactDescriptor.DOWNLOAD_MD5))
+					newDescriptor.setProperty(IArtifactDescriptor.DOWNLOAD_MD5, RepositoryUtilities.computeMD5(artifactFile));
+
+				File temp = new File(artifactFile.getParentFile(), artifactFile.getName() + ".pack.gz"); //$NON-NLS-1$
+				if (temp.exists()) {
+					packFile = temp;
+					unpackedSize = size;
+				}
+
+				repository.addDescriptor(newDescriptor);
+			}
+			if (packFile != null && !files.contains(packFile)) {
+				ArtifactDescriptor packDescriptor = createPack200ArtifactDescriptor(key, packFile, unpackedSize);
+				repository.addDescriptor(packDescriptor);
+			}
+		}
+	}
+
+	private ArtifactDescriptor createPack200ArtifactDescriptor(IArtifactKey key, File packFile, String installSize) {
+		final String PACKED_FORMAT = "packed"; //$NON-NLS-1$
+
+		if (packFile != null && packFile.exists()) {
+			ArtifactDescriptor result = new ArtifactDescriptor(key);
+			result.setProperty(IArtifactDescriptor.ARTIFACT_SIZE, installSize);
+			result.setProperty(IArtifactDescriptor.DOWNLOAD_SIZE, Long.toString(packFile.length()));
+			ProcessingStepDescriptor[] steps = new ProcessingStepDescriptor[] {new ProcessingStepDescriptor("org.eclipse.equinox.p2.processing.Pack200Unpacker", null, true)}; //$NON-NLS-1$
+			result.setProcessingSteps(steps);
+			result.setProperty(IArtifactDescriptor.FORMAT, PACKED_FORMAT);
+			return result;
+		}
+		return null;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/RepositoryUtilities.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/RepositoryUtilities.java
new file mode 100644
index 0000000..11e3e32
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/RepositoryUtilities.java
@@ -0,0 +1,57 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.internal.repository.tools;
+
+import java.io.*;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+public class RepositoryUtilities {
+
+	public static String computeMD5(File file) {
+		if (file == null || file.isDirectory() || !file.exists())
+			return null;
+		MessageDigest md5Checker;
+		try {
+			md5Checker = MessageDigest.getInstance("MD5"); //$NON-NLS-1$
+		} catch (NoSuchAlgorithmException e) {
+			return null;
+		}
+		InputStream fis = null;
+		try {
+			fis = new BufferedInputStream(new FileInputStream(file));
+			int read = -1;
+			while ((read = fis.read()) != -1) {
+				md5Checker.update((byte) read);
+			}
+			byte[] digest = md5Checker.digest();
+			StringBuffer buf = new StringBuffer();
+			for (int i = 0; i < digest.length; i++) {
+				if ((digest[i] & 0xFF) < 0x10)
+					buf.append('0');
+				buf.append(Integer.toHexString(digest[i] & 0xFF));
+			}
+			return buf.toString();
+		} catch (FileNotFoundException e) {
+			return null;
+		} catch (IOException e) {
+			return null;
+		} finally {
+			if (fis != null)
+				try {
+					fis.close();
+				} catch (IOException e) {
+					// ignore
+				}
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/messages.properties b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/messages.properties
index b7e7f02..894db79 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/messages.properties
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/messages.properties
@@ -8,4 +8,7 @@
 # Contributors:
 #     IBM Corporation - initial API and implementation
 ###############################################################################
-exception_destinationNotModifiable = The destination repository must be modifiable: {0}.
\ No newline at end of file
+exception_destinationNotModifiable = The destination repository must be modifiable: {0}.
+
+exception_unableToRemoveRepo=Unable to remove artifact repository file: {0}.
+exception_notLocalFileRepo= {0} is not a local file based repository.
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src_ant/org/eclipse/equinox/p2/internal/repository/tools/tasks/ProcessRepoTask.java b/bundles/org.eclipse.equinox.p2.repository.tools/src_ant/org/eclipse/equinox/p2/internal/repository/tools/tasks/ProcessRepoTask.java
new file mode 100644
index 0000000..302a153
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src_ant/org/eclipse/equinox/p2/internal/repository/tools/tasks/ProcessRepoTask.java
@@ -0,0 +1,129 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.internal.repository.tools.tasks;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import org.apache.tools.ant.BuildException;
+import org.apache.tools.ant.Task;
+import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.core.runtime.URIUtil;
+import org.eclipse.equinox.internal.p2.jarprocessor.ant.JarProcessorTask;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.p2.internal.repository.tools.RecreateRepositoryApplication;
+import org.eclipse.equinox.p2.internal.repository.tools.RepositoryDescriptor;
+
+public class ProcessRepoTask extends Task {
+
+	public static class SigningOptions {
+		public String alias;
+		public String keystore;
+		public String storepass;
+		public String keypass;
+		public boolean unsign;
+
+		public void setAlias(String alias) {
+			this.alias = alias;
+		}
+
+		public void setKeystore(String keystore) {
+			this.keystore = keystore;
+		}
+
+		public void setKeypass(String keypass) {
+			this.keypass = keypass;
+		}
+
+		public void setStorepass(String storepass) {
+			this.storepass = storepass;
+		}
+
+		public void setUnsign(String unsign) {
+			this.unsign = Boolean.valueOf(unsign).booleanValue();
+		}
+	}
+
+	private URI repository = null;
+
+	private boolean pack = false;
+	private boolean repack = false;
+	private SigningOptions signing = null;
+
+	public void execute() throws BuildException {
+		File file = URIUtil.toFile(repository);
+		if (file == null || !file.exists()) {
+			throw new BuildException("Repository must be local: " + repository.toString()); //$NON-NLS-1$
+		}
+		if (pack | repack | signing != null) {
+			JarProcessorTask task = new JarProcessorTask();
+			if (signing != null) {
+				task.setAlias(signing.alias);
+				task.setKeypass(signing.keypass);
+				task.setKeystore(signing.keystore);
+				task.setStorepass(signing.storepass);
+				task.setUnsign(signing.unsign);
+
+				if (signing.alias != null && signing.alias.length() > 0 && !signing.alias.startsWith("${")) //$NON-NLS-1$
+					task.setSign(true);
+			}
+			task.setPack(pack);
+			task.setNormalize(repack);
+			task.setInputFolder(new File(repository));
+			task.setProject(getProject());
+			task.execute();
+		}
+
+		recreateRepository();
+	}
+
+	private void recreateRepository() {
+		RepositoryDescriptor descriptor = new RepositoryDescriptor();
+		descriptor.setAppend(true);
+		descriptor.setFormat(null);
+		descriptor.setKind("artifact"); //$NON-NLS-1$
+		descriptor.setLocation(repository);
+
+		RecreateRepositoryApplication application = new RecreateRepositoryApplication();
+		application.setArtifactRepository(descriptor);
+		try {
+			application.run(new NullProgressMonitor());
+		} catch (ProvisionException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+
+	public void setRepositoryPath(String repository) {
+		try {
+			this.repository = URIUtil.fromString(repository);
+		} catch (URISyntaxException e) {
+			throw new IllegalArgumentException("Repository location (" + repository + ") must be a URL."); //$NON-NLS-1$ //$NON-NLS-2$
+		}
+	}
+
+	public void setPack(boolean pack) {
+		this.pack = pack;
+	}
+
+	public void setNormalize(boolean normalize) {
+		this.repack = normalize;
+	}
+
+	public void addConfiguredSign(SigningOptions options) {
+		this.signing = options;
+	}
+}
