commit b3643b00aca537d576ecc0109a451bfa59475959
Author: DJ Houghton <dj>
Date:   Tue Mar 25 19:50:50 2008 +0000

    Bug 223423 - Drop-ins reconciler should try to install best effort

26	0	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PatchingIU.java
442	0	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
20	0	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/QueryableArray.java
26	12	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
150	0	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Slicer.java
10	1	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/provisional/p2/engine/ProvisioningContext.java
62	7	bundles/org.eclipse.equinox.p2.reconciler.dropins/src/org/eclipse/equinox/internal/p2/reconciler/dropins/ProfileSynchronizer.java
62	7	bundles/org.eclipse.equinox.p2.reconciler/src/org/eclipse/equinox/internal/p2/reconciler/dropins/ProfileSynchronizer.java
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PatchingIU.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PatchingIU.java
new file mode 100644
index 0000000..1328f98
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PatchingIU.java
@@ -0,0 +1,26 @@
+package org.eclipse.equinox.internal.p2.director;
+
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.RequiredCapability;
+import org.eclipse.equinox.internal.provisional.p2.query.Query;
+
+public class PatchingIU extends Query {
+
+	public PatchingIU(RequiredCapability req) {
+	}
+
+	public boolean isMatch(Object candidate) {
+		if (!(candidate instanceof IInstallableUnit))
+			return false;
+
+		IInstallableUnit iu = (IInstallableUnit) candidate;
+		if (iu.getProperty("patch").equals("true"))
+			return true;
+		return hasApplicablePatch(iu);
+	}
+
+	private boolean hasApplicablePatch(IInstallableUnit iu) {
+		//iu.getPatches
+		return true;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
new file mode 100644
index 0000000..75888bd
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
@@ -0,0 +1,442 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.equinox.internal.p2.director;
+
+import java.io.*;
+import java.util.*;
+import java.util.Map.Entry;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
+import org.eclipse.equinox.internal.provisional.p2.metadata.query.CapabilityQuery;
+import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
+import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import org.eclipse.equinox.internal.provisional.p2.query.IQueryable;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.Version;
+import org.sat4j.pb.IPBSolver;
+import org.sat4j.pb.SolverFactory;
+import org.sat4j.pb.core.PBSolverCP;
+import org.sat4j.pb.orders.VarOrderHeapObjective;
+import org.sat4j.pb.reader.OPBEclipseReader2007;
+import org.sat4j.reader.ParseFormatException;
+import org.sat4j.specs.*;
+
+/**
+ * This class is the interface between SAT4J and the planner. It produces a
+ * boolean satisfiability problem, invokes the solver, and converts the solver result
+ * back into information understandable by the planner.
+ */
+public class Projector {
+	private static boolean DEBUG = false;
+	private IQueryable picker;
+
+	private Map variables; //key IU, value corresponding variable in the problem
+	private Map variableForSyntheticIUs; //key IU, value corresponding variable in the problem.
+
+	private TwoTierMap slice; //The IUs that have been considered to be part of the problem
+
+	private Dictionary selectionContext;
+
+	private final static int shift = 1;
+
+	private ArrayList constraints;
+	private ArrayList dependencies;
+	private ArrayList tautologies;
+	private String objective;
+
+	private Collection solution;
+
+	private File problemFile;
+	private MultiStatus result;
+
+	public Projector(IQueryable q, Dictionary context) {
+		picker = q;
+		variables = new HashMap();
+		variableForSyntheticIUs = new HashMap();
+		slice = new TwoTierMap();
+		constraints = new ArrayList();
+		tautologies = new ArrayList();
+		dependencies = new ArrayList();
+		selectionContext = context;
+		result = new MultiStatus(DirectorActivator.PI_DIRECTOR, IStatus.OK, "Problems resolving provisioning plan.", null);
+	}
+
+	public void encode(IInstallableUnit[] ius, IProgressMonitor monitor) {
+		try {
+			long start = 0;
+			if (DEBUG) {
+				start = System.currentTimeMillis();
+				System.out.println("Start projection: " + start); //$NON-NLS-1$
+			}
+
+			Iterator iusToEncode = picker.query(InstallableUnitQuery.ANY, new Collector(), null).iterator();
+			while (iusToEncode.hasNext()) {
+				processIU((IInstallableUnit) iusToEncode.next(), true);
+			}
+			createConstraintsForSingleton();
+			for (int i = 0; i < ius.length; i++) {
+				createMustHaves(ius[i]);
+			}
+			createOptimizationFunction();
+			persist();
+			if (DEBUG) {
+				long stop = System.currentTimeMillis();
+				System.out.println("Projection complete: " + (stop - start)); //$NON-NLS-1$
+			}
+		} catch (IllegalStateException e) {
+			result.add(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, e.getMessage(), e));
+		}
+	}
+
+	//Create an optimization function favoring the highest version of each IU  
+	private void createOptimizationFunction() {
+		objective = "min:"; //$NON-NLS-1$
+		Set s = slice.entrySet();
+		for (Iterator iterator = s.iterator(); iterator.hasNext();) {
+			Map.Entry entry = (Map.Entry) iterator.next();
+			HashMap conflictingEntries = (HashMap) entry.getValue();
+			if (conflictingEntries.size() <= 1) {
+				objective += " 1 " + getVariable((IInstallableUnit) conflictingEntries.values().iterator().next()); //$NON-NLS-1$
+				continue;
+			}
+			List toSort = new ArrayList(conflictingEntries.values());
+			Collections.sort(toSort);
+			int weight = toSort.size();
+			for (Iterator iterator2 = toSort.iterator(); iterator2.hasNext();) {
+				objective += " " + weight-- + " " + getVariable((IInstallableUnit) iterator2.next()); //$NON-NLS-1$//$NON-NLS-2$
+			}
+		}
+		objective += " ;"; //$NON-NLS-1$
+	}
+
+	private void createMustHaves(IInstallableUnit iu) {
+		tautologies.add(" +1 " + getVariable(iu) + " = 1;"); //$NON-NLS-1$ //$NON-NLS-2$
+	}
+
+	private void createNegation(IInstallableUnit iu) {
+		tautologies.add(" +1" + getVariable(iu) + " = 0;"); //$NON-NLS-1$//$NON-NLS-2$
+	}
+
+	// Check whether the requirement is applicable
+	private boolean isApplicable(RequiredCapability req) {
+		String filter = req.getFilter();
+		if (filter == null)
+			return true;
+		try {
+			return DirectorActivator.context.createFilter(filter).match(selectionContext);
+		} catch (InvalidSyntaxException e) {
+			return false;
+		}
+	}
+
+	//Write the problem generated into a temporary file
+	private void persist() {
+		try {
+			problemFile = File.createTempFile("p2Encoding", ".opb"); //$NON-NLS-1$//$NON-NLS-2$
+			BufferedWriter w = new BufferedWriter(new FileWriter(problemFile));
+			int clauseCount = tautologies.size() + dependencies.size() + constraints.size();
+
+			int variableCount = variables.size();
+			w.write("* #variable= " + variableCount + " #constraint= " + clauseCount + "  "); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+			w.newLine();
+			w.write("*"); //$NON-NLS-1$
+			w.newLine();
+
+			if (variableCount == 0 && clauseCount == 0) {
+				w.close();
+				return;
+			}
+			w.write(objective);
+			w.newLine();
+			w.newLine();
+
+			w.write(explanation + " ;"); //$NON-NLS-1$
+			w.newLine();
+			w.newLine();
+
+			for (Iterator iterator = dependencies.iterator(); iterator.hasNext();) {
+				w.write((String) iterator.next());
+				w.newLine();
+			}
+			for (Iterator iterator = constraints.iterator(); iterator.hasNext();) {
+				w.write((String) iterator.next());
+				w.newLine();
+			}
+			for (Iterator iterator = tautologies.iterator(); iterator.hasNext();) {
+				w.write((String) iterator.next());
+				w.newLine();
+			}
+			w.close();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	private boolean isApplicable(IInstallableUnit iu) {
+		String enablementFilter = iu.getFilter();
+		if (enablementFilter == null)
+			return true;
+		try {
+			return DirectorActivator.context.createFilter(enablementFilter).match(selectionContext);
+		} catch (InvalidSyntaxException e) {
+			return false;
+		}
+	}
+
+	String explanation = "explain: "; //$NON-NLS-1$
+
+	public void processIU(IInstallableUnit iu, boolean expandOptionalRequirements) {
+		slice.put(iu.getId(), iu.getVersion(), iu);
+		explanation += " " + getVariable(iu); //$NON-NLS-1$
+		if (!isApplicable(iu)) {
+			createNegation(iu);
+			return;
+		}
+
+		RequiredCapability[] reqs = iu.getRequiredCapabilities();
+		if (expandOptionalRequirements) {
+			if (sortDependencies(iu)[OPT].size() != 0) {
+				expandIUs(iu, sortDependencies(iu));
+				return;
+			}
+		}
+		if (reqs.length == 0) {
+			return;
+		}
+		for (int i = 0; i < reqs.length; i++) {
+			if (!isApplicable(reqs[i]))
+				continue;
+
+			try {
+				expandRequirement(iu, reqs[i]);
+			} catch (IllegalStateException ise) {
+				result.add(new Status(IStatus.WARNING, DirectorActivator.PI_DIRECTOR, ise.getMessage(), ise));
+				createNegation(iu);
+			}
+		}
+	}
+
+	private void expandIUs(IInstallableUnit iu, List[] list) {
+		List combinationsOfRequirements = new ArrayList();
+		getCombinations(list[CORE], list[OPT], combinationsOfRequirements);
+		combinationsOfRequirements.add(list[CORE]);
+		String expression = "-1 " + getVariable(iu); //$NON-NLS-1$
+		int count = combinationsOfRequirements.size();
+		String generatedIUId = iu.getId() + '-' + System.currentTimeMillis();
+		for (Iterator iterator = combinationsOfRequirements.iterator(); iterator.hasNext();) {
+			RequiredCapability[] reqs = (RequiredCapability[]) ((ArrayList) iterator.next()).toArray(new RequiredCapability[0]);
+
+			InstallableUnitDescription iud = new MetadataFactory.InstallableUnitDescription();
+			iud.setId(generatedIUId);
+			iud.setVersion(new Version(0, reqs.length, count--));
+			iud.setRequiredCapabilities(reqs);
+			iud.setSingleton(true);
+			IInstallableUnit generated = MetadataFactory.createInstallableUnit(iud);
+
+			processIU(generated, false);
+			expression += " +1 " + getVariable(generated); //$NON-NLS-1$
+			variableForSyntheticIUs.put(generated, getVariable(generated));
+		}
+		expression += ">= 0;"; //$NON-NLS-1$
+		dependencies.add(expression);
+	}
+
+	private void getCombinations(List seed, List elts, List solutions) {
+		if (elts.isEmpty()) {
+			solutions.add(seed);
+			return;
+		}
+
+		Object head = elts.get(0);
+		ArrayList solutionElt = new ArrayList(seed);
+		solutionElt.add(head);
+		solutions.add(solutionElt);
+
+		List tail = elts.subList(1, elts.size());
+		if (!tail.isEmpty()) {
+			getCombinations(seed, tail, solutions);
+			ArrayList nextSeed = new ArrayList(seed);
+			nextSeed.add(head);
+			getCombinations(nextSeed, tail, solutions);
+		}
+	}
+
+	final byte OPT = 0;
+	final byte CORE = 1;
+
+	private ArrayList[] sortDependencies(IInstallableUnit iu) {
+		RequiredCapability[] reqs = iu.getRequiredCapabilities();
+		ArrayList opt = new ArrayList(reqs.length);
+		ArrayList nonOpt = new ArrayList(reqs.length);
+		for (int i = 0; i < reqs.length; i++) {
+			if (reqs[i].isOptional())
+				opt.add(reqs[i]);
+			else
+				nonOpt.add(reqs[i]);
+		}
+		ArrayList[] sorted = new ArrayList[2];
+		sorted[CORE] = nonOpt;
+		sorted[OPT] = opt;
+		return sorted;
+	}
+
+	private void expandRequirement(IInstallableUnit iu, RequiredCapability req) {
+		String expression = "-1 " + getVariable(iu); //$NON-NLS-1$
+		Collector matches = picker.query(new CapabilityQuery(req), new Collector(), null);
+
+		int countMatches = 0;
+		for (Iterator iterator = matches.iterator(); iterator.hasNext();) {
+			IInstallableUnit match = (IInstallableUnit) iterator.next();
+			if (!isApplicable(match))
+				continue;
+			countMatches++;
+			expression += " +1 " + getVariable(match); //$NON-NLS-1$
+		}
+		if (countMatches > 0) {
+			dependencies.add(expression + (countMatches == 1 ? " >= 0;" : " >= 0;")); //$NON-NLS-1$ //$NON-NLS-2$
+		} else {
+			if (req.isOptional()) {
+				if (DEBUG)
+					System.out.println("No IU found to satisfy optional dependency of " + iu + " req " + req); //$NON-NLS-1$//$NON-NLS-2$
+			} else {
+				throw new IllegalStateException("No IU found to satisfy dependency of " + iu + " req " + req); //$NON-NLS-1$//$NON-NLS-2$
+			}
+		}
+	}
+
+	//Create constraints to deal with singleton
+	//When there is a mix of singleton and non singleton, several constraints are generated 
+	private void createConstraintsForSingleton() {
+		Set s = slice.entrySet();
+		for (Iterator iterator = s.iterator(); iterator.hasNext();) {
+			Map.Entry entry = (Map.Entry) iterator.next();
+			HashMap conflictingEntries = (HashMap) entry.getValue();
+			if (conflictingEntries.size() < 2)
+				continue;
+
+			Collection conflictingVersions = conflictingEntries.values();
+			String singletonRule = ""; //$NON-NLS-1$
+			ArrayList nonSingleton = new ArrayList();
+			int countSingleton = 0;
+			for (Iterator conflictIterator = conflictingVersions.iterator(); conflictIterator.hasNext();) {
+				IInstallableUnit conflictElt = (IInstallableUnit) conflictIterator.next();
+				if (conflictElt.isSingleton()) {
+					singletonRule += " -1 " + getVariable(conflictElt); //$NON-NLS-1$
+					countSingleton++;
+				} else {
+					nonSingleton.add(conflictElt);
+				}
+			}
+			if (countSingleton == 0)
+				continue;
+
+			for (Iterator iterator2 = nonSingleton.iterator(); iterator2.hasNext();) {
+				constraints.add(singletonRule + " -1 " + getVariable((IInstallableUnit) iterator2.next()) + " >= -1;"); //$NON-NLS-1$ //$NON-NLS-2$
+			}
+			singletonRule += " >= -1;"; //$NON-NLS-1$
+			constraints.add(singletonRule);
+		}
+	}
+
+	//Return the corresponding variable 
+	private String getVariable(IInstallableUnit iu) {
+		String v = (String) variables.get(iu);
+		if (v == null) {
+			//			v = new String("x" + (variables.size() + shift) + iu.toString()); //$NON-NLS-1$
+			v = new String("x" + (variables.size() + shift)); //$NON-NLS-1$
+			variables.put(iu, v);
+		}
+		return v;
+	}
+
+	public IStatus invokeSolver(IProgressMonitor monitor) {
+		if (result.getSeverity() == IStatus.ERROR)
+			return result;
+		IPBSolver solver = SolverFactory.newEclipseP2();
+		solver.setTimeout(60);
+		OPBEclipseReader2007 reader = new OPBEclipseReader2007(solver);
+		// CNF filename is given on the command line 
+		long start = System.currentTimeMillis();
+		if (DEBUG)
+			System.out.println("Invoking solver: " + start); //$NON-NLS-1$
+		FileReader fr = null;
+		try {
+			fr = new FileReader(problemFile);
+			PBSolverCP problem = (PBSolverCP) reader.parseInstance(fr);
+			if (problem.getOrder() instanceof VarOrderHeapObjective) {
+				((VarOrderHeapObjective) problem.getOrder()).setObjectiveFunction(reader.getObjectiveFunction());
+			}
+			if (problem.isSatisfiable()) {
+				if (DEBUG) {
+					System.out.println("Satisfiable !"); //$NON-NLS-1$
+					System.out.println(reader.decode(problem.model()));
+				}
+				backToIU(problem);
+				long stop = System.currentTimeMillis();
+				if (DEBUG)
+					System.out.println("Solver solution found: " + (stop - start)); //$NON-NLS-1$
+			} else {
+				if (DEBUG)
+					System.out.println("Unsatisfiable !"); //$NON-NLS-1$
+				result.merge(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, 1, "No solution found", null));
+			}
+		} catch (FileNotFoundException e) {
+			//Ignore we are producing the input file
+			if (DEBUG)
+				e.printStackTrace();
+		} catch (ParseFormatException e) {
+			//Ignore we are producing the input file
+			if (DEBUG)
+				e.printStackTrace();
+		} catch (ContradictionException e) {
+			result.merge(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, 1, "No solution found because of a trivial contradiction", e));
+		} catch (TimeoutException e) {
+			result.merge(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, 1, "No solution found.", e));
+		} catch (Exception e) {
+			e.printStackTrace();
+		} finally {
+			try {
+				if (fr != null)
+					fr.close();
+			} catch (IOException e) {
+				//ignore
+			}
+			problemFile.delete();
+		}
+		return result;
+	}
+
+	private void backToIU(IProblem problem) {
+		solution = new ArrayList();
+		for (Iterator allIUs = variables.entrySet().iterator(); allIUs.hasNext();) {
+			Entry entry = (Entry) allIUs.next();
+			int match = Integer.parseInt(((String) entry.getValue()).substring(1));
+			if (problem.model(match)) {
+				if (variableForSyntheticIUs.get(entry.getKey()) == null)
+					solution.add(((IInstallableUnit) entry.getKey()).unresolved());
+			}
+		}
+	}
+
+	private void printSolution(Collection state) {
+		ArrayList l = new ArrayList(state);
+		Collections.sort(l);
+		System.out.println("Numbers of IUs selected:" + l.size()); //$NON-NLS-1$
+		for (Iterator iterator = l.iterator(); iterator.hasNext();) {
+			System.out.println(iterator.next());
+		}
+	}
+
+	public Collection extractSolution() {
+		if (DEBUG)
+			printSolution(solution);
+		return solution;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/QueryableArray.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/QueryableArray.java
new file mode 100644
index 0000000..d274bae
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/QueryableArray.java
@@ -0,0 +1,20 @@
+package org.eclipse.equinox.internal.p2.director;
+
+import java.util.Arrays;
+import java.util.List;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.query.*;
+
+public class QueryableArray implements IQueryable {
+	List dataSet;
+
+	public QueryableArray(IInstallableUnit[] ius) {
+		dataSet = Arrays.asList(ius);
+	}
+
+	public Collector query(Query query, Collector collector, IProgressMonitor monitor) {
+		return query.perform(dataSet.iterator(), collector);
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
index 612eacb..58942ff 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
@@ -25,6 +25,7 @@ import org.eclipse.equinox.internal.provisional.p2.metadata.query.UpdateQuery;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import org.eclipse.equinox.internal.provisional.p2.query.IQueryable;
 import org.eclipse.osgi.service.resolver.VersionRange;
 import org.eclipse.osgi.util.NLS;
 
@@ -169,7 +170,7 @@ public class SimplePlanner implements IPlanner {
 			//We need to get all the ius that were part of the profile and give that to be what to become
 
 			Dictionary snapshotSelectionContext = createSelectionContext(getSnapshotProperties(profileSnapshot));
-			IInstallableUnit[] availableIUs = gatherAvailableInstallableUnits(new IInstallableUnit[] {profileSnapshot}, context.getMetadataRepositories(), sub.newChild(ExpandWork / 2));
+			IInstallableUnit[] availableIUs = gatherAvailableInstallableUnits(new IInstallableUnit[] {profileSnapshot}, context.getMetadataRepositories(), context, sub.newChild(ExpandWork / 2));
 			NewDependencyExpander toExpander = new NewDependencyExpander(new IInstallableUnit[] {profileSnapshot}, null, availableIUs, snapshotSelectionContext, true);
 			toExpander.expand(sub.newChild(ExpandWork / 2));
 			ResolutionHelper newStateHelper = new ResolutionHelper(snapshotSelectionContext, toExpander.getRecommendations());
@@ -272,7 +273,7 @@ public class SimplePlanner implements IPlanner {
 		return request;
 	}
 
-	protected IInstallableUnit[] gatherAvailableInstallableUnits(IInstallableUnit[] additionalSource, URL[] repositories, IProgressMonitor monitor) {
+	protected IInstallableUnit[] gatherAvailableInstallableUnits(IInstallableUnit[] additionalSource, URL[] repositories, ProvisioningContext context, IProgressMonitor monitor) {
 		Map resultsMap = new HashMap();
 		if (additionalSource != null) {
 			for (int i = 0; i < additionalSource.length; i++) {
@@ -280,6 +281,11 @@ public class SimplePlanner implements IPlanner {
 				resultsMap.put(key, additionalSource[i]);
 			}
 		}
+		for (Iterator iter = context.getExtraIUs().iterator(); iter.hasNext();) {
+			IInstallableUnit iu = (IInstallableUnit) iter.next();
+			String key = iu.getId() + '_' + iu.getVersion().toString();
+			resultsMap.put(key, iu);
+		}
 
 		IMetadataRepositoryManager repoMgr = (IMetadataRepositoryManager) ServiceHelper.getService(DirectorActivator.context, IMetadataRepositoryManager.class.getName());
 		if (repositories == null)
@@ -327,20 +333,28 @@ public class SimplePlanner implements IPlanner {
 			extraIUs.addAll(Arrays.asList(profileChangeRequest.getRemovedInstallableUnits()));
 			extraIUs.addAll(profileChangeRequest.getProfile().query(InstallableUnitQuery.ANY, new Collector(), null).toCollection());
 
-			IInstallableUnit[] availableIUs = gatherAvailableInstallableUnits((IInstallableUnit[]) extraIUs.toArray(new IInstallableUnit[extraIUs.size()]), metadataRepositories, sub.newChild(ExpandWork / 4));
-			PBProjector pb = new PBProjector(new Picker(availableIUs, null), newSelectionContext);
-			pb.encode(allIUs, sub.newChild(ExpandWork / 4));
-			IStatus s = pb.invokeSolver(sub.newChild(ExpandWork / 4));
+			IInstallableUnit[] availableIUs = gatherAvailableInstallableUnits((IInstallableUnit[]) extraIUs.toArray(new IInstallableUnit[extraIUs.size()]), metadataRepositories, context, sub.newChild(ExpandWork / 4));
+
+			Slicer slicer = new Slicer(allIUs, availableIUs, newSelectionContext);
+			IQueryable slice = slicer.slice(allIUs, monitor);
+			if (slice == null)
+				return new ProvisioningPlan(slicer.getStatus());
+			Projector projector = new Projector(slice, newSelectionContext);
+			projector.encode(allIUs, sub.newChild(ExpandWork / 4));
+			IStatus s = projector.invokeSolver(sub.newChild(ExpandWork / 4));
+
 			if (s.getSeverity() == IStatus.ERROR) {
-				//We invoke the old resolver to get explanations for now
-				IStatus newStatus = new NewDependencyExpander(allIUs, null, availableIUs, newSelectionContext, false).expand(sub.newChild(ExpandWork / 4));
-				if (newStatus.isOK())
-					return new ProvisioningPlan(s);
 				//log the error from the new solver so it is not lost
 				LogHelper.log(s);
-				return new ProvisioningPlan(newStatus);
+				if (!"true".equalsIgnoreCase(context == null ? null : context.getProperty("org.eclipse.equinox.p2.disable.error.reporting"))) {
+					//We invoke the old resolver to get explanations for now
+					IStatus oldResolverStatus = new NewDependencyExpander(allIUs, null, availableIUs, newSelectionContext, false).expand(sub.newChild(ExpandWork / 4));
+					if (!oldResolverStatus.isOK())
+						s = oldResolverStatus;
+				}
+				return new ProvisioningPlan(s);
 			}
-			Collection newState = pb.extractSolution();
+			Collection newState = projector.extractSolution();
 
 			ResolutionHelper newStateHelper = new ResolutionHelper(newSelectionContext, null);
 			newState = newStateHelper.attachCUs(newState);
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Slicer.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Slicer.java
new file mode 100644
index 0000000..ff3f7d3
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Slicer.java
@@ -0,0 +1,150 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.equinox.internal.p2.director;
+
+import java.util.*;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.RequiredCapability;
+import org.eclipse.equinox.internal.provisional.p2.metadata.query.CapabilityQuery;
+import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import org.eclipse.equinox.internal.provisional.p2.query.IQueryable;
+import org.osgi.framework.InvalidSyntaxException;
+
+public class Slicer {
+	private static boolean DEBUG = false;
+	private IQueryable possibilites;
+
+	private List toConsider; //IUs to add to the slice
+	private TwoTierMap slice; //The IUs that have been considered to be part of the problem
+
+	private Dictionary selectionContext;
+	private MultiStatus result;
+
+	public Slicer(IQueryable input, Dictionary context) {
+		possibilites = input;
+		slice = new TwoTierMap();
+		selectionContext = context;
+		result = new MultiStatus(DirectorActivator.PI_DIRECTOR, IStatus.OK, "Problems resolving provisioning plan.", null);
+	}
+
+	public Slicer(IInstallableUnit[] installRoots, IInstallableUnit[] gatherAvailableInstallableUnits, Dictionary selectionContext) {
+		this(new QueryableArray(gatherAvailableInstallableUnits), selectionContext);
+	}
+
+	public IQueryable slice(IInstallableUnit[] ius, IProgressMonitor monitor) {
+		try {
+			long start = 0;
+			if (DEBUG) {
+				start = System.currentTimeMillis();
+				System.out.println("Start slicing: " + start); //$NON-NLS-1$
+			}
+
+			validateInput(ius);
+			toConsider = new ArrayList();
+			toConsider.addAll(Arrays.asList(ius));
+			for (int i = 0; i < toConsider.size(); i++) {
+				processIU((IInstallableUnit) toConsider.get(i));
+			}
+			if (DEBUG) {
+				long stop = System.currentTimeMillis();
+				System.out.println("Slicing complete: " + (stop - start)); //$NON-NLS-1$
+			}
+		} catch (IllegalStateException e) {
+			result.add(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, e.getMessage(), e));
+		}
+		if (!result.isOK())
+			LogHelper.log(result);
+		if (result.getSeverity() == IStatus.ERROR)
+			return null;
+		return new QueryableArray((IInstallableUnit[]) toConsider.toArray(new IInstallableUnit[toConsider.size()]));
+	}
+
+	public MultiStatus getStatus() {
+		return result;
+	}
+
+	//This is a shortcut to simplify the error reporting when the filter of the ius we are being asked to install does not pass 
+	private void validateInput(IInstallableUnit[] ius) {
+		//TODO Need to see what is done in validateInput of PBProjector
+		for (int i = 0; i < ius.length; i++) {
+			if (!isApplicable(ius[i]))
+				throw new IllegalStateException("The IU " + ius[i] + " can't be installed in this environment because its filter does not match."); //$NON-NLS-1$//$NON-NLS-2$
+		}
+	}
+
+	// Check whether the requirement is applicable
+	private boolean isApplicable(RequiredCapability req) {
+		String filter = req.getFilter();
+		if (filter == null)
+			return true;
+		try {
+			return DirectorActivator.context.createFilter(filter).match(selectionContext);
+		} catch (InvalidSyntaxException e) {
+			return false;
+		}
+	}
+
+	private boolean isApplicable(IInstallableUnit iu) {
+		String enablementFilter = iu.getFilter();
+		if (enablementFilter == null)
+			return true;
+		try {
+			return DirectorActivator.context.createFilter(enablementFilter).match(selectionContext);
+		} catch (InvalidSyntaxException e) {
+			return false;
+		}
+	}
+
+	private void processIU(IInstallableUnit iu) {
+		slice.put(iu.getId(), iu.getVersion(), iu);
+		if (!isApplicable(iu)) {
+			return;
+		}
+
+		RequiredCapability[] reqs = iu.getRequiredCapabilities();
+		if (reqs.length == 0) {
+			return;
+		}
+		for (int i = 0; i < reqs.length; i++) {
+			if (!isApplicable(reqs[i]))
+				continue;
+
+			if (!reqs[i].isGreedy()) {
+				continue;
+			}
+
+			expandRequirement(iu, reqs[i]);
+		}
+	}
+
+	private void expandRequirement(IInstallableUnit iu, RequiredCapability req) {
+		Collector matches = possibilites.query(new CapabilityQuery(req), new Collector(), null);
+		int validMatches = 0;
+		for (Iterator iterator = matches.iterator(); iterator.hasNext();) {
+			IInstallableUnit match = (IInstallableUnit) iterator.next();
+			if (!isApplicable(match))
+				continue;
+			validMatches++;
+			if (!slice.containsKey(match.getId(), match.getVersion()))
+				if (!toConsider.contains(match))
+					toConsider.add(match);
+		}
+
+		if (validMatches == 0) {
+			if (req.isOptional()) {
+				if (DEBUG)
+					System.out.println("No IU found to satisfy optional dependency of " + iu + " on req " + req); //$NON-NLS-1$//$NON-NLS-2$
+			} else {
+				result.add(new Status(IStatus.WARNING, DirectorActivator.PI_DIRECTOR, "No IU found to satisfy dependency of " + iu + " on req " + req)); //$NON-NLS-1$//$NON-NLS-2$
+			}
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/provisional/p2/engine/ProvisioningContext.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/provisional/p2/engine/ProvisioningContext.java
index 028a4f3..6b8bf5d 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/provisional/p2/engine/ProvisioningContext.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/provisional/p2/engine/ProvisioningContext.java
@@ -9,11 +9,12 @@
 package org.eclipse.equinox.internal.provisional.p2.engine;
 
 import java.net.URL;
-import java.util.Properties;
+import java.util.*;
 
 public class ProvisioningContext {
 	private URL[] metadataRepositories;
 	private Properties properties = new Properties();
+	private List extraIUs = new ArrayList();
 
 	public ProvisioningContext() {
 		// null repos means look at them all
@@ -35,4 +36,12 @@ public class ProvisioningContext {
 	public void setProperty(String key, String value) {
 		properties.setProperty(key, value);
 	}
+
+	public List getExtraIUs() {
+		return extraIUs;
+	}
+
+	public void setExtraIUs(List extraIUs) {
+		this.extraIUs = extraIUs;
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.reconciler.dropins/src/org/eclipse/equinox/internal/p2/reconciler/dropins/ProfileSynchronizer.java b/bundles/org.eclipse.equinox.p2.reconciler.dropins/src/org/eclipse/equinox/internal/p2/reconciler/dropins/ProfileSynchronizer.java
index 9180ba2..59316f3 100644
--- a/bundles/org.eclipse.equinox.p2.reconciler.dropins/src/org/eclipse/equinox/internal/p2/reconciler/dropins/ProfileSynchronizer.java
+++ b/bundles/org.eclipse.equinox.p2.reconciler.dropins/src/org/eclipse/equinox/internal/p2/reconciler/dropins/ProfileSynchronizer.java
@@ -22,13 +22,13 @@ import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IFileArti
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
 import org.eclipse.equinox.internal.provisional.p2.director.*;
 import org.eclipse.equinox.internal.provisional.p2.engine.*;
-import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.internal.provisional.p2.query.Collector;
 import org.eclipse.equinox.internal.provisional.p2.query.Query;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.ServiceReference;
+import org.osgi.framework.*;
 
 /**
  * Synchronizes a profile with a set of repositories.
@@ -69,14 +69,14 @@ public class ProfileSynchronizer {
 		if (!status.isOK())
 			return status;
 
-		ProfileChangeRequest request = createProfileChangeRequest();
+		ProvisioningContext context = getContext();
+		ProfileChangeRequest request = createProfileChangeRequest(context);
 		if (request == null)
 			return Status.OK_STATUS;
 
 		SubMonitor sub = SubMonitor.convert(monitor, 100);
 		try {
 			//create the provisioning plan
-			ProvisioningContext context = new ProvisioningContext(new URL[0]);
 			ProvisioningPlan plan = createProvisioningPlan(request, context, sub.newChild(50));
 			status = plan.getStatus();
 			if (status.getSeverity() == IStatus.ERROR || plan.getOperands().length == 0)
@@ -94,6 +94,18 @@ public class ProfileSynchronizer {
 		}
 	}
 
+	private ProvisioningContext getContext() {
+		ArrayList repoURLs = new ArrayList();
+		for (Iterator iterator = repositoryMap.keySet().iterator(); iterator.hasNext();) {
+			try {
+				repoURLs.add(new URL((String) iterator.next()));
+			} catch (MalformedURLException e) {
+				//ignore
+			}
+		}
+		return new ProvisioningContext((URL[]) repoURLs.toArray(new URL[repoURLs.size()]));
+	}
+
 	private IStatus synchronizeCacheExtensions() {
 		List currentExtensions = new ArrayList();
 		StringBuffer buffer = new StringBuffer();
@@ -134,13 +146,29 @@ public class ProfileSynchronizer {
 		return executeOperands(new ProvisioningContext(new URL[0]), new Operand[] {operand}, null);
 	}
 
-	private ProfileChangeRequest createProfileChangeRequest() {
+	private IInstallableUnit createRootIU(List children) {
+		InstallableUnitDescription iu = new MetadataFactory.InstallableUnitDescription();
+		iu.setId("org.eclipse.equinox.p2.dropins");
+		iu.setVersion(new Version("1.0.0.v" + System.currentTimeMillis()));
+		List required = new ArrayList();
+		for (Iterator iter = children.iterator(); iter.hasNext();) {
+			IInstallableUnit next = (IInstallableUnit) iter.next();
+			required.add(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, next.getId(), null, null, false /* optional */, false, true));
+		}
+		if (required.size() > 0)
+			iu.setRequiredCapabilities((RequiredCapability[]) required.toArray(new RequiredCapability[required.size()]));
+		return MetadataFactory.createInstallableUnit(iu);
+	}
+
+	private ProfileChangeRequest createProfileChangeRequest(ProvisioningContext context) {
 		boolean modified = false;
 		Collection profileIUs = getProfileIUs();
 		Collection toRemove = getStaleIUs();
 		profileIUs.removeAll(toRemove);
 
 		ProfileChangeRequest request = new ProfileChangeRequest(profile);
+		List toAdd = new ArrayList();
+		List defaults = new ArrayList();
 		for (Iterator it = repositoryMap.entrySet().iterator(); it.hasNext();) {
 			Entry entry = (Entry) it.next();
 			String repositoryId = (String) entry.getKey();
@@ -156,7 +184,8 @@ public class ProfileSynchronizer {
 					toRemove.remove(iu);
 				} else {
 					//the IU exists in the repository, but not in the profile, so it needs to be added
-					request.addInstallableUnits(new IInstallableUnit[] {iu});
+					defaults.add(createDefaultIU(iu));
+					toAdd.add(createIncludedIU(iu));
 					if (Boolean.valueOf(iu.getProperty(IInstallableUnit.PROP_TYPE_GROUP)).booleanValue())
 						request.setInstallableUnitProfileProperty(iu, IInstallableUnit.PROP_PROFILE_ROOT_IU, Boolean.TRUE.toString());
 				}
@@ -166,6 +195,15 @@ public class ProfileSynchronizer {
 				modified = true;
 			}
 		}
+
+		List extra = new ArrayList();
+		extra.addAll(defaults);
+		extra.addAll(toAdd);
+		context.setExtraIUs(extra);
+		// only add one IU to the request. it will contain all the other IUs we want to install
+		IInstallableUnit rootIU = createRootIU(toAdd);
+		request.addInstallableUnits(new IInstallableUnit[] {rootIU});
+
 		//the remaining IUs in toRemove don't exist in any repository, so remove from profile
 		if (!toRemove.isEmpty()) {
 			request.removeInstallableUnits((IInstallableUnit[]) toRemove.toArray(new IInstallableUnit[0]));
@@ -178,6 +216,23 @@ public class ProfileSynchronizer {
 		return request;
 	}
 
+	private IInstallableUnit createIncludedIU(IInstallableUnit iu) {
+		InstallableUnitDescription iud = new MetadataFactory.InstallableUnitDescription();
+		iud.setId(iu.getId());
+		iud.setVersion(new Version(0, 0, 0, Long.toString(System.currentTimeMillis())));
+		RequiredCapability[] reqs = new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, iu.getId(), null, null, false, false, true)};
+		iud.setRequiredCapabilities(reqs);
+		return MetadataFactory.createInstallableUnit(iud);
+	}
+
+	private IInstallableUnit createDefaultIU(IInstallableUnit iu) {
+		InstallableUnitDescription iud = new MetadataFactory.InstallableUnitDescription();
+		iud.setId(iu.getId());
+		iud.setVersion(new Version(0, 0, 0));
+		iud.setCapabilities(new ProvidedCapability[] {MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_IU_ID, iu.getId(), new Version(0, 0, 0))});
+		return MetadataFactory.createInstallableUnit(iud);
+	}
+
 	/**
 	 * Returns all IUs that are no longer in the repository they were in last
 	 * time we synchronized.
diff --git a/bundles/org.eclipse.equinox.p2.reconciler/src/org/eclipse/equinox/internal/p2/reconciler/dropins/ProfileSynchronizer.java b/bundles/org.eclipse.equinox.p2.reconciler/src/org/eclipse/equinox/internal/p2/reconciler/dropins/ProfileSynchronizer.java
index 9180ba2..59316f3 100644
--- a/bundles/org.eclipse.equinox.p2.reconciler/src/org/eclipse/equinox/internal/p2/reconciler/dropins/ProfileSynchronizer.java
+++ b/bundles/org.eclipse.equinox.p2.reconciler/src/org/eclipse/equinox/internal/p2/reconciler/dropins/ProfileSynchronizer.java
@@ -22,13 +22,13 @@ import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IFileArti
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
 import org.eclipse.equinox.internal.provisional.p2.director.*;
 import org.eclipse.equinox.internal.provisional.p2.engine.*;
-import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.internal.provisional.p2.query.Collector;
 import org.eclipse.equinox.internal.provisional.p2.query.Query;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.ServiceReference;
+import org.osgi.framework.*;
 
 /**
  * Synchronizes a profile with a set of repositories.
@@ -69,14 +69,14 @@ public class ProfileSynchronizer {
 		if (!status.isOK())
 			return status;
 
-		ProfileChangeRequest request = createProfileChangeRequest();
+		ProvisioningContext context = getContext();
+		ProfileChangeRequest request = createProfileChangeRequest(context);
 		if (request == null)
 			return Status.OK_STATUS;
 
 		SubMonitor sub = SubMonitor.convert(monitor, 100);
 		try {
 			//create the provisioning plan
-			ProvisioningContext context = new ProvisioningContext(new URL[0]);
 			ProvisioningPlan plan = createProvisioningPlan(request, context, sub.newChild(50));
 			status = plan.getStatus();
 			if (status.getSeverity() == IStatus.ERROR || plan.getOperands().length == 0)
@@ -94,6 +94,18 @@ public class ProfileSynchronizer {
 		}
 	}
 
+	private ProvisioningContext getContext() {
+		ArrayList repoURLs = new ArrayList();
+		for (Iterator iterator = repositoryMap.keySet().iterator(); iterator.hasNext();) {
+			try {
+				repoURLs.add(new URL((String) iterator.next()));
+			} catch (MalformedURLException e) {
+				//ignore
+			}
+		}
+		return new ProvisioningContext((URL[]) repoURLs.toArray(new URL[repoURLs.size()]));
+	}
+
 	private IStatus synchronizeCacheExtensions() {
 		List currentExtensions = new ArrayList();
 		StringBuffer buffer = new StringBuffer();
@@ -134,13 +146,29 @@ public class ProfileSynchronizer {
 		return executeOperands(new ProvisioningContext(new URL[0]), new Operand[] {operand}, null);
 	}
 
-	private ProfileChangeRequest createProfileChangeRequest() {
+	private IInstallableUnit createRootIU(List children) {
+		InstallableUnitDescription iu = new MetadataFactory.InstallableUnitDescription();
+		iu.setId("org.eclipse.equinox.p2.dropins");
+		iu.setVersion(new Version("1.0.0.v" + System.currentTimeMillis()));
+		List required = new ArrayList();
+		for (Iterator iter = children.iterator(); iter.hasNext();) {
+			IInstallableUnit next = (IInstallableUnit) iter.next();
+			required.add(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, next.getId(), null, null, false /* optional */, false, true));
+		}
+		if (required.size() > 0)
+			iu.setRequiredCapabilities((RequiredCapability[]) required.toArray(new RequiredCapability[required.size()]));
+		return MetadataFactory.createInstallableUnit(iu);
+	}
+
+	private ProfileChangeRequest createProfileChangeRequest(ProvisioningContext context) {
 		boolean modified = false;
 		Collection profileIUs = getProfileIUs();
 		Collection toRemove = getStaleIUs();
 		profileIUs.removeAll(toRemove);
 
 		ProfileChangeRequest request = new ProfileChangeRequest(profile);
+		List toAdd = new ArrayList();
+		List defaults = new ArrayList();
 		for (Iterator it = repositoryMap.entrySet().iterator(); it.hasNext();) {
 			Entry entry = (Entry) it.next();
 			String repositoryId = (String) entry.getKey();
@@ -156,7 +184,8 @@ public class ProfileSynchronizer {
 					toRemove.remove(iu);
 				} else {
 					//the IU exists in the repository, but not in the profile, so it needs to be added
-					request.addInstallableUnits(new IInstallableUnit[] {iu});
+					defaults.add(createDefaultIU(iu));
+					toAdd.add(createIncludedIU(iu));
 					if (Boolean.valueOf(iu.getProperty(IInstallableUnit.PROP_TYPE_GROUP)).booleanValue())
 						request.setInstallableUnitProfileProperty(iu, IInstallableUnit.PROP_PROFILE_ROOT_IU, Boolean.TRUE.toString());
 				}
@@ -166,6 +195,15 @@ public class ProfileSynchronizer {
 				modified = true;
 			}
 		}
+
+		List extra = new ArrayList();
+		extra.addAll(defaults);
+		extra.addAll(toAdd);
+		context.setExtraIUs(extra);
+		// only add one IU to the request. it will contain all the other IUs we want to install
+		IInstallableUnit rootIU = createRootIU(toAdd);
+		request.addInstallableUnits(new IInstallableUnit[] {rootIU});
+
 		//the remaining IUs in toRemove don't exist in any repository, so remove from profile
 		if (!toRemove.isEmpty()) {
 			request.removeInstallableUnits((IInstallableUnit[]) toRemove.toArray(new IInstallableUnit[0]));
@@ -178,6 +216,23 @@ public class ProfileSynchronizer {
 		return request;
 	}
 
+	private IInstallableUnit createIncludedIU(IInstallableUnit iu) {
+		InstallableUnitDescription iud = new MetadataFactory.InstallableUnitDescription();
+		iud.setId(iu.getId());
+		iud.setVersion(new Version(0, 0, 0, Long.toString(System.currentTimeMillis())));
+		RequiredCapability[] reqs = new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, iu.getId(), null, null, false, false, true)};
+		iud.setRequiredCapabilities(reqs);
+		return MetadataFactory.createInstallableUnit(iud);
+	}
+
+	private IInstallableUnit createDefaultIU(IInstallableUnit iu) {
+		InstallableUnitDescription iud = new MetadataFactory.InstallableUnitDescription();
+		iud.setId(iu.getId());
+		iud.setVersion(new Version(0, 0, 0));
+		iud.setCapabilities(new ProvidedCapability[] {MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_IU_ID, iu.getId(), new Version(0, 0, 0))});
+		return MetadataFactory.createInstallableUnit(iud);
+	}
+
 	/**
 	 * Returns all IUs that are no longer in the repository they were in last
 	 * time we synchronized.
