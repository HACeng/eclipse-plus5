commit a6eb4a1aaa8891bdcadd0cec519f82fcabf7165c
Author: John Arthorne <johna>
Date:   Wed Jan 14 20:13:38 2009 +0000

    Bug 260913 [metadata] Move concrete metadata classes to an internal package

10	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/MetadataFactory.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/MetadataFactory.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/MetadataFactory.java
index 0371814..d62fd28 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/MetadataFactory.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/MetadataFactory.java
@@ -266,6 +266,16 @@ public class MetadataFactory {
 	}
 
 	/**
+	 * Returns a new requirement change.
+	 * @param applyOn The source of the requirement change - the kind of requirement to apply the change to
+	 * @param newValue The result of the requirement change - the requirement to replace the source requirement with
+	 * @return a requirement change
+	 */
+	public static IRequirementChange createRequirementChange(IRequiredCapability applyOn, IRequiredCapability newValue) {
+		return new RequirementChange(applyOn, newValue);
+	}
+
+	/**
 	 * Returns an {@link IInstallableUnit} that represents the given
 	 * unit bound to the given fragments.
 	 * 
commit a201b7a9ba65b4c632c203e7bd25236ee3e95dcd
Author: John Arthorne <johna>
Date:   Thu Feb 12 22:33:06 2009 +0000

    Bug 260913 [metadata] Move concrete metadata classes to an internal package

3	1	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
3	1	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
65	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/Copyright.java
147	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/License.java
81	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
184	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/RequiredCapability.java
117	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/RequirementChange.java
91	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointData.java
163	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointInstruction.java
56	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointType.java
0	63	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Copyright.java
1	1	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/ILicense.java
0	145	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/License.java
0	79	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/ProvidedCapability.java
0	182	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/RequiredCapability.java
0	115	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/RequirementChange.java
0	90	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointData.java
0	161	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointInstruction.java
0	55	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointType.java
3	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
4	3	bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/dialogs/IUPropertyPagesTest.java
1	1	bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/query/IUPropertyUtilsTest.java
5	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPatchPersistenceTest.java
8	6	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
3	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
5	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/Bug249605.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/Bug252638.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PP2ShouldFailToInstall.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchFailingToInstall.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest10.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest11.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest12.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest13.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1b.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1c.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest2.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest3.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest4.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest5.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest6.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest7.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest7b.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest8.java
5	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest9.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestMultiplePatch.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional2.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional3.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUninstall.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate2.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate3.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate4.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate5.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SDKPatchingTest1.java
4	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SDKPatchingTest2.java
2	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/eclipse/AddRepositoryActionTest.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
index 369c4fa..93594b9 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
@@ -11,6 +11,8 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.provisional.p2.metadata.generator;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import java.io.*;
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -851,7 +853,7 @@ public class MetadataGeneratorHelper {
 			}
 			if (entries[i].isPlugin()) {
 				IRequiredCapability from = MetadataFactory.createRequiredCapability(IU_NAMESPACE, getTransformedId(entries[i].getId(), entries[i].isPlugin(), /*isGroup*/true), VersionRange.emptyRange, getFilter(entries[i]), entries[i].isOptional(), false);
-				requirementChanges.add(new RequirementChange(from, req));
+				requirementChanges.add(MetadataFactory.createRequirementChange(from, req));
 				continue;
 			}
 			patchRequirements.add(req);
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
index 1d089e8..53e3384 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
@@ -12,6 +12,8 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.metadata.repository.io;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import java.net.URI;
 import java.util.*;
 import org.eclipse.equinox.internal.p2.core.helpers.OrderedProperties;
@@ -407,7 +409,7 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 		}
 
 		protected void finished() {
-			requirementChanges.add(new RequirementChange(from.size() == 0 ? null : (IRequiredCapability) from.get(0), to.size() == 0 ? null : (IRequiredCapability) to.get(0)));
+			requirementChanges.add(MetadataFactory.createRequirementChange(from.size() == 0 ? null : (IRequiredCapability) from.get(0), to.size() == 0 ? null : (IRequiredCapability) to.get(0)));
 		}
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/Copyright.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/Copyright.java
new file mode 100644
index 0000000..b29e5f3
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/Copyright.java
@@ -0,0 +1,65 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata;
+
+import org.eclipse.equinox.internal.provisional.p2.metadata.ICopyright;
+
+import java.net.URI;
+
+/**
+ * The <code>Copyright</code> class represents a software copyright.  A copyright has 
+ * required body text which may be the full text or a summary.  An optional location field can be specified
+ * which links to full text.  
+ */
+public class Copyright implements ICopyright {
+	/**
+	 * The <code>body</code> contains the descriptive text for the copyright. This may
+	 * be a summary for a copyright specified in a URL.
+	 */
+	private final String body;
+
+	/**
+	 * The <code>location</code> is the location of a document containing a copyright notice.
+	 */
+	private URI location;
+
+	/**
+	 * Creates a new copyright. The body must contain the full text of the copyright.
+	 * 
+	 * @param location the location of a document containing the copyright notice, or <code>null</code>
+	 * @param body the copyright body, cannot be <code>null</code>
+	 * @throws IllegalArgumentException when the <code>body</code> is <code>null</code>
+	 */
+	public Copyright(URI location, String body) {
+		if (body == null)
+			throw new IllegalArgumentException("body cannot be null"); //$NON-NLS-1$
+		this.location = location;
+		this.body = body;
+	}
+
+	/**
+	 * Returns the location of a document containing the copyright notice.
+	 * 
+	 * @return The location of the copyright notice, or <code>null</code>
+	 */
+	public URI getLocation() {
+		return location;
+	}
+
+	/**
+	 * Returns the license body.
+	 * 
+	 * @return the license body, never <code>null</code>
+	 */
+	public String getBody() {
+		return body;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/License.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/License.java
new file mode 100644
index 0000000..b89285f
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/License.java
@@ -0,0 +1,147 @@
+/*******************************************************************************
+ * Copyright (c) 2008, 2009 Genuitec, LLC and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: 
+ * 		Genuitec, LLC - initial API and implementation
+ * 		IBM Corporation - ongoing development
+ *      EclipseSource - ongoing development
+ ******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata;
+
+import org.eclipse.equinox.internal.provisional.p2.metadata.ILicense;
+
+import java.io.UnsupportedEncodingException;
+import java.math.BigInteger;
+import java.net.URI;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * The <code>License</code> class represents a software license.  A license has required body text
+ * which may be the full text or an annotation.  An optional URL field can be specified
+ * which links to full text.  Licenses can be easily compared using their digests.
+ */
+public class License implements ILicense {
+	/**
+	 * The <code>body</code> contains the descriptive text for the license. This may
+	 * be a summary for a full license specified in a URL.
+	 */
+	private final String body;
+
+	/**
+	 * The <code>location</code> is the URL of the license.
+	 */
+	private URI location;
+
+	/**
+	 * The <code>digest</code> is the cached message digest of the normalized body
+	 */
+	private BigInteger digest;
+
+	/**
+	 * Creates a new license object which is identified by users using the <code>body</code> field.
+	 * The body should contain either the full text of the license or an summary for a license
+	 * fully specified in the given location.
+	 * 
+	 * @param location the location of a document containing the full license, or <code>null</code>
+	 * @param body the license body, cannot be <code>null</code>
+	 * @throws IllegalArgumentException when the <code>body</code> is <code>null</code>
+	 */
+	public License(URI location, String body) {
+		if (body == null)
+			throw new IllegalArgumentException("body cannot be null"); //$NON-NLS-1$
+		this.body = body;
+		this.location = location;
+	}
+
+	/**
+	 * Returns the location of a document containing the full license.
+	 * 
+	 * @return the location of the license document, or <code>null</code>
+	 */
+	public URI getLocation() {
+		return location;
+	}
+
+	/**
+	 * Returns the license body.
+	 * @return the license body, never <code>null</code>
+	 */
+	public String getBody() {
+		return body;
+	}
+
+	/**
+	 * Returns the message digest of the license body.  The digest is calculated on a normalized
+	 * version of the license where all whitespace has been reduced to one space.
+	 * @return the message digest as a <code>BigInteger</code>, never <code>null</code>
+	 */
+	public synchronized BigInteger getDigest() {
+		if (digest == null)
+			digest = calculateLicenseDigest();
+		return digest;
+	}
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#equals(java.lang.Object)
+	 */
+	public boolean equals(Object obj) {
+		if (obj == this)
+			return true;
+		if (obj == null)
+			return false;
+		if (obj instanceof ILicense) {
+			ILicense other = (ILicense) obj;
+			if (other.getDigest().equals(getDigest()))
+				return true;
+		}
+		return false;
+	}
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#hashCode()
+	 */
+	public int hashCode() {
+		return getDigest().hashCode();
+	}
+
+	private BigInteger calculateLicenseDigest() {
+		String message = normalize(getBody());
+		try {
+			MessageDigest algorithm = MessageDigest.getInstance("MD5"); //$NON-NLS-1$
+			algorithm.reset();
+			algorithm.update(message.getBytes("UTF-8")); //$NON-NLS-1$
+			byte[] digestBytes = algorithm.digest();
+			return new BigInteger(1, digestBytes);
+		} catch (NoSuchAlgorithmException e) {
+			throw new RuntimeException(e);
+		} catch (UnsupportedEncodingException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	/**
+	 * Replace all sequences of whitespace with a single whitespace character.
+	 */
+	private String normalize(String license) {
+		String text = license.trim();
+		StringBuffer result = new StringBuffer();
+		int length = text.length();
+		for (int i = 0; i < length; i++) {
+			char c = text.charAt(i);
+			boolean foundWhitespace = false;
+			while (Character.isWhitespace(c) && i < length) {
+				foundWhitespace = true;
+				c = text.charAt(++i);
+			}
+			if (foundWhitespace)
+				result.append(' ');
+			if (i < length)
+				result.append(c);
+		}
+		return result.toString();
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
new file mode 100644
index 0000000..4c8b307
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
@@ -0,0 +1,81 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata;
+
+import org.eclipse.core.runtime.Assert;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IProvidedCapability;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IRequiredCapability;
+
+/**
+ * Describes a capability as exposed or required by an installable unit
+ */
+public class ProvidedCapability implements IProvidedCapability {
+	private final String name;
+	private final String namespace;
+	private final Version version;
+
+	public ProvidedCapability(String namespace, String name, Version version) {
+		Assert.isNotNull(namespace);
+		Assert.isNotNull(name);
+		this.namespace = namespace;
+		this.name = name;
+		this.version = version == null ? Version.emptyVersion : version;
+	}
+
+	public boolean equals(Object other) {
+		if (other == null)
+			return false;
+		if (!(other instanceof IProvidedCapability))
+			return false;
+		IProvidedCapability otherCapability = (IProvidedCapability) other;
+		if (!(namespace.equals(otherCapability.getNamespace())))
+			return false;
+		if (!(name.equals(otherCapability.getName())))
+			return false;
+		return version.equals(otherCapability.getVersion());
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public String getNamespace() {
+		return namespace;
+	}
+
+	public Version getVersion() {
+		return version;
+	}
+
+	public int hashCode() {
+		return namespace.hashCode() * name.hashCode() * version.hashCode();
+	}
+
+	/**
+	 * Returns whether this provided capability satisfies the given required capability.
+	 * @return <code>true</code> if this capability satisfies the given required
+	 * capability, and <code>false</code> otherwise.
+	 */
+	public boolean satisfies(IRequiredCapability candidate) {
+		if (getName() == null || !getName().equals(candidate.getName()))
+			return false;
+		if (getNamespace() == null || !getNamespace().equals(candidate.getNamespace()))
+			return false;
+		return candidate.getRange().isIncluded(version);
+	}
+
+	public String toString() {
+		return namespace + '/' + name + '/' + version;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/RequiredCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/RequiredCapability.java
new file mode 100644
index 0000000..fbb1730
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/RequiredCapability.java
@@ -0,0 +1,184 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: 
+ *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
+ ******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata;
+
+import org.eclipse.core.runtime.Assert;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IRequiredCapability;
+
+/**
+ * A required capability represents some external constraint on an {@link IInstallableUnit}.
+ * Each capability represents something an {@link IInstallableUnit} needs that
+ * it expects to be provided by another {@link IInstallableUnit}. Capabilities are
+ * entirely generic, and are intended to be capable of representing anything that
+ * an {@link IInstallableUnit} may need either at install time, or at runtime.
+ * <p>
+ * Capabilities are segmented into namespaces.  Anyone can introduce new 
+ * capability namespaces. Some well-known namespaces are introduced directly
+ * by the provisioning framework.
+ * 
+ * @see IInstallableUnit#NAMESPACE_IU_ID
+ */
+public class RequiredCapability implements IRequiredCapability {
+	private static final String[] NO_SELECTORS = new String[0];
+
+	private String filter;
+	private final boolean multiple;
+	private final String name;//never null
+	private final String namespace;//never null
+	private boolean optional;
+	private boolean greedy = true;
+	private final VersionRange range;//never null
+	private String[] selectors = NO_SELECTORS;//never null
+
+	/**
+	 * TODO replace booleans with int options flag.
+	 */
+	public RequiredCapability(String namespace, String name, VersionRange range, String filter, boolean optional, boolean multiple) {
+		Assert.isNotNull(namespace);
+		Assert.isNotNull(name);
+		this.namespace = namespace;
+		this.name = name;
+		this.range = range == null ? VersionRange.emptyRange : range;
+		this.optional = optional;
+		this.filter = filter;
+		this.multiple = multiple;
+	}
+
+	public RequiredCapability(String namespace, String name, VersionRange range, String filter, boolean optional, boolean multiple, boolean greedy) {
+		this(namespace, name, range, filter, optional, multiple);
+		this.greedy = greedy;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (!(obj instanceof IRequiredCapability))
+			return false;
+		final IRequiredCapability other = (IRequiredCapability) obj;
+		if (filter == null) {
+			if (other.getFilter() != null)
+				return false;
+		} else if (!filter.equals(other.getFilter()))
+			return false;
+		if (multiple != other.isMultiple())
+			return false;
+		if (!name.equals(other.getName()))
+			return false;
+		if (!namespace.equals(other.getNamespace()))
+			return false;
+		if (optional != other.isOptional())
+			return false;
+		if (!range.equals(other.getRange()))
+			return false;
+		return true;
+	}
+
+	public String getFilter() {
+		return filter;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public String getNamespace() {
+		return namespace;
+	}
+
+	/**
+	 * Returns the range of versions that satisfy this required capability. Returns
+	 * an empty version range ({@link VersionRange#emptyRange} if any version
+	 * will satisfy the capability.
+	 * @return the range of versions that satisfy this required capability.
+	 */
+	public VersionRange getRange() {
+		return range;
+	}
+
+	/**
+	 * Returns the properties to use for evaluating required capability filters 
+	 * downstream from this capability. For example, if the selector "doc"
+	 * is provided, then a downstream InstallableUnit with a required capability
+	 * filtered with "doc=true" will be included.
+	 */
+	public String[] getSelectors() {
+		return selectors;
+	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((filter == null) ? 0 : filter.hashCode());
+		result = prime * result + (multiple ? 1231 : 1237);
+		result = prime * result + name.hashCode();
+		result = prime * result + namespace.hashCode();
+		result = prime * result + (optional ? 1231 : 1237);
+		result = prime * result + range.hashCode();
+		return result;
+	}
+
+	public boolean isMultiple() {
+		return multiple;
+	}
+
+	public boolean isOptional() {
+		return optional;
+	}
+
+	/**
+	 * TODO This object shouldn't be mutable since it makes equality unstable, and
+	 * introduces lifecycle issues (how are the changes persisted, etc)
+	 */
+	public void setFilter(String filter) {
+		this.filter = filter;
+	}
+
+	/**
+	 * TODO This object shouldn't be mutable since it makes equality unstable, and
+	 * introduces lifecycle issues (how are the changes persisted, etc)
+	 */
+	public void setSelectors(String[] selectors) {
+		this.selectors = selectors;
+	}
+
+	public boolean isGreedy() {
+		return greedy;
+	}
+
+	public String toString() {
+		StringBuffer result = new StringBuffer();
+
+		if (IInstallableUnit.NAMESPACE_IU_ID.equals(getNamespace())) {
+			//print nothing for an IU id dependency because this is the default (most common) case
+			result.append(""); //$NON-NLS-1$
+		} else if ("osgi.bundle".equals(getNamespace())) { //$NON-NLS-1$
+			result.append("bundle"); //$NON-NLS-1$
+		} else if ("java.package".equals(getNamespace())) { //$NON-NLS-1$
+			result.append("package"); //$NON-NLS-1$
+		} else {
+			result.append(getNamespace());
+		}
+		if (result.length() > 0)
+			result.append(' ');
+		result.append(getName());
+		result.append(' ');
+		//for an exact version match, print a simpler expression
+		if (range.getMinimum().equals(range.getMaximum()))
+			result.append('[').append(range.getMinimum()).append(']');
+		else
+			result.append(range);
+		return result.toString();
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/RequirementChange.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/RequirementChange.java
new file mode 100644
index 0000000..3c70bcf
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/RequirementChange.java
@@ -0,0 +1,117 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IRequiredCapability;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IRequirementChange;
+
+public class RequirementChange implements IRequirementChange {
+	private IRequiredCapability applyOn;
+	private IRequiredCapability newValue;
+
+	public RequirementChange(IRequiredCapability applyOn2, IRequiredCapability newValue2) {
+		if (applyOn2 == null && newValue2 == null)
+			throw new IllegalArgumentException();
+		this.applyOn = applyOn2;
+		this.newValue = newValue2;
+	}
+
+	public IRequiredCapability applyOn() {
+		return applyOn;
+	}
+
+	public IRequiredCapability newValue() {
+		return newValue;
+	}
+
+	public boolean matches(IRequiredCapability toMatch) {
+		if (!toMatch.getNamespace().equals(applyOn.getNamespace()))
+			return false;
+		if (!toMatch.getName().equals(applyOn.getName()))
+			return false;
+		if (toMatch.getRange().equals(applyOn.getRange()))
+			return true;
+
+		return intersect(toMatch.getRange(), applyOn.getRange()) == null ? false : true;
+	}
+
+	private VersionRange intersect(VersionRange r1, VersionRange r2) {
+		Version resultMin = null;
+		boolean resultMinIncluded = false;
+		Version resultMax = null;
+		boolean resultMaxIncluded = false;
+
+		int minCompare = r1.getMinimum().compareTo(r2.getMinimum());
+		if (minCompare < 0) {
+			resultMin = r2.getMinimum();
+			resultMinIncluded = r2.getIncludeMinimum();
+		} else if (minCompare > 0) {
+			resultMin = r1.getMinimum();
+			resultMinIncluded = r1.getIncludeMinimum();
+		} else if (minCompare == 0) {
+			resultMin = r1.getMinimum();
+			resultMinIncluded = r1.getIncludeMinimum() && r2.getIncludeMinimum();
+		}
+
+		int maxCompare = r1.getMaximum().compareTo(r2.getMaximum());
+		if (maxCompare > 0) {
+			resultMax = r2.getMaximum();
+			resultMaxIncluded = r2.getIncludeMaximum();
+		} else if (maxCompare < 0) {
+			resultMax = r1.getMaximum();
+			resultMaxIncluded = r1.getIncludeMaximum();
+		} else if (maxCompare == 0) {
+			resultMax = r1.getMaximum();
+			resultMaxIncluded = r1.getIncludeMaximum() && r2.getIncludeMaximum();
+		}
+
+		int resultRangeComparison = resultMin.compareTo(resultMax);
+		if (resultRangeComparison < 0)
+			return new VersionRange(resultMin, resultMinIncluded, resultMax, resultMaxIncluded);
+		else if (resultRangeComparison == 0 && resultMinIncluded == resultMaxIncluded)
+			return new VersionRange(resultMin, resultMinIncluded, resultMax, resultMaxIncluded);
+		else
+			return null;
+	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((applyOn == null) ? 0 : applyOn.hashCode());
+		result = prime * result + ((newValue == null) ? 0 : newValue.hashCode());
+		return result;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (!(obj instanceof IRequirementChange))
+			return false;
+		final IRequirementChange other = (IRequirementChange) obj;
+		if (applyOn == null) {
+			if (other.applyOn() != null)
+				return false;
+		} else if (!applyOn.equals(other.applyOn()))
+			return false;
+		if (newValue == null) {
+			if (other.newValue() != null)
+				return false;
+		} else if (!newValue.equals(other.newValue()))
+			return false;
+		return true;
+	}
+
+	public String toString() {
+		return applyOn + " --> " + newValue; //$NON-NLS-1$
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointData.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointData.java
new file mode 100644
index 0000000..71b1d4b
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointData.java
@@ -0,0 +1,91 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata;
+
+import java.util.*;
+import java.util.Map.Entry;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+
+/**
+ * Touchpoint data instances contain the additional information needed by a touchpoint
+ * to execute each engine phase it participates in. This includes the sequence of
+ * instruction statements to be executed during each phase, and any additional
+ * supporting data needed to perform the phase.
+ *
+ * @noextend This class is not intended to be subclassed by clients.
+ * @see MetadataFactory#createTouchpointData(Map)
+ */
+public class TouchpointData implements ITouchpointData {
+
+	/**
+	 * Map of (String->TouchpointInstruction). The set
+	 * of keys supported is up to the touchpoint that will process these
+	 * instructions. This map is never null.
+	 */
+	private Map instructions;
+
+	public int hashCode() {
+		return 31 * 1 + ((instructions == null) ? 0 : instructions.hashCode());
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (!(obj instanceof ITouchpointData))
+			return false;
+		final ITouchpointData other = (ITouchpointData) obj;
+		if (instructions == null) {
+			if (other.getInstructions() != null)
+				return false;
+		} else if (!instructions.equals(other.getInstructions()))
+			return false;
+		return true;
+	}
+
+	/**
+	 * Clients must use the factory method on {@link MetadataFactory}.
+	 */
+	public TouchpointData(Map instructions) {
+		this.instructions = instructions;
+	}
+
+	/**
+	 * Returns the touchpoint instruction corresponding to the given key.
+	 */
+	public ITouchpointInstruction getInstruction(String instructionKey) {
+		return (ITouchpointInstruction) instructions.get(instructionKey);
+	}
+
+	/**
+	 * Returns an unmodifiable map of the touchpoint instructions. The map
+	 * keys are strings, and the values are instances of {@link ITouchpointInstruction}.
+	 *
+	 * @return the touchpoint instructions
+	 */
+	public Map getInstructions() {
+		return Collections.unmodifiableMap(instructions);
+	}
+
+	/**
+	 * Returns a string representation of the touchpoint data for debugging purposes only.
+	 */
+	public String toString() {
+		StringBuffer result = new StringBuffer();
+		for (Iterator iterator = instructions.entrySet().iterator(); iterator.hasNext();) {
+			Entry instruction = (Entry) iterator.next();
+			result.append(instruction.getKey()).append(" -> ").append(instruction.getValue()).append('\n'); //$NON-NLS-1$
+		}
+		return result.toString();
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointInstruction.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointInstruction.java
new file mode 100644
index 0000000..48a0f70
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointInstruction.java
@@ -0,0 +1,163 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata;
+
+import java.util.Iterator;
+import java.util.Map;
+import org.eclipse.equinox.internal.provisional.p2.metadata.ITouchpointInstruction;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
+/**
+ * A touchpoint instruction contains either a sequence of instruction statements
+ * to be executed during a particular engine phase, or some simple string value
+ * that is needed by a touchpoint to execute its phases.
+ * <p>
+ * The format of a touchpoint instruction statement sequence is as follows:
+ * 
+ *   statement-sequence :
+ *     | statement ';'
+ *      | statement-sequence statement
+ *      ;
+ *
+ *Where a statement is of the format:
+ *
+ *  statement :
+ *      | actionName '(' parameters ')'
+ *      ;
+ *
+ *  parameters :
+ *      | // empty
+ *      | parameter
+ *      | parameters ',' parameter
+ *      ;
+ *
+ *   parameter : 
+ *      | paramName ':' paramValue
+ *      ;
+ *
+ * actionName, paramName, paramValue :
+ *      | String 
+ *      ;
+ *
+ * @noextend This class is not intended to be subclassed by clients.
+ * @see MetadataFactory#createTouchpointInstruction(String, String)
+ */
+public class TouchpointInstruction implements ITouchpointInstruction {
+
+	private final String body;
+	private final String importAttribute;
+
+	/**
+	 * Encodes an action statement in string form. This method will
+	 * take care of escaping any illegal characters in function parameter values.
+	 * 
+	 * @param actionName The name of the action.
+	 * @param parameters The function's parameters. This is a Map<String,String>
+	 * where the keys are parameter names, and the values are parameter values
+	 * @return An encoded touchpoint instruction statement
+	 */
+	public static String encodeAction(String actionName, Map parameters) {
+		StringBuffer result = new StringBuffer(actionName);
+		result.append('(');
+		for (Iterator it = parameters.entrySet().iterator(); it.hasNext();) {
+			Map.Entry entry = (Map.Entry) it.next();
+			result.append(entry.getKey());
+			result.append(':');
+			appendEncoded(result, (String) entry.getValue());
+			if (it.hasNext())
+				result.append(',');
+		}
+		result.append(')').append(';');
+		return result.toString();
+	}
+
+	/**
+	 * Append the given value to the given buffer, encoding any illegal characters
+	 * with appropriate escape sequences.
+	 */
+	private static void appendEncoded(StringBuffer buf, String value) {
+		char[] chars = value.toCharArray();
+		for (int i = 0; i < chars.length; i++) {
+			switch (chars[i]) {
+				case '$' :
+				case ',' :
+				case ':' :
+				case ';' :
+				case '{' :
+				case '}' :
+					buf.append("${#").append(Integer.toString(chars[i])).append('}'); //$NON-NLS-1$
+					break;
+				default :
+					buf.append(chars[i]);
+			}
+		}
+	}
+
+	/**
+	 * Clients must use the factory method on {@link MetadataFactory}.
+	 */
+	public TouchpointInstruction(String body, String importAttribute) {
+		this.body = body;
+		this.importAttribute = importAttribute;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (!(obj instanceof ITouchpointInstruction))
+			return false;
+		ITouchpointInstruction other = (ITouchpointInstruction) obj;
+		if (body == null) {
+			if (other.getBody() != null)
+				return false;
+		} else if (!body.equals(other.getBody()))
+			return false;
+		if (importAttribute == null) {
+			if (other.getImportAttribute() != null)
+				return false;
+		} else if (!importAttribute.equals(other.getImportAttribute()))
+			return false;
+		return true;
+	}
+
+	/**
+	 * Returns the body of this touchpoint instruction. The body is either a sequence
+	 * of instruction statements, or a simple string value.
+	 * 
+	 * @return The body of this touchpoint instruction
+	 */
+	public String getBody() {
+		return body;
+	}
+
+	//TODO What is this? Please doc
+	public String getImportAttribute() {
+		return importAttribute;
+	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((body == null) ? 0 : body.hashCode());
+		result = prime * result + ((importAttribute == null) ? 0 : importAttribute.hashCode());
+		return result;
+	}
+
+	/**
+	 * Returns a string representation of this instruction for debugging purposes only.
+	 */
+	public String toString() {
+		return "Instruction[" + body + ',' + importAttribute + ']'; //$NON-NLS-1$
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointType.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointType.java
new file mode 100644
index 0000000..517506c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/TouchpointType.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing Development
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.metadata.ITouchpointType;
+
+/**
+ * Identifies a particular touchpoint. A touchpoint is identified by an id 
+ * and a version.
+ */
+public class TouchpointType implements ITouchpointType {
+	private String id;//never null
+	private Version version;//never null
+
+	public TouchpointType(String id, Version aVersion) {
+		this.id = id;
+		this.version = aVersion;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (super.equals(obj))
+			return true;
+		if (obj == null || !(obj instanceof ITouchpointType))
+			return false;
+		ITouchpointType other = (ITouchpointType) obj;
+		return id.equals(other.getId()) && version.equals(other.getVersion());
+	}
+
+	public String getId() {
+		return id;
+	}
+
+	public Version getVersion() {
+		return version;
+	}
+
+	public int hashCode() {
+		return 31 * id.hashCode() + version.hashCode();
+	}
+
+	public String toString() {
+		return "Touchpoint: " + id + ' ' + getVersion(); //$NON-NLS-1$
+	}
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Copyright.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Copyright.java
deleted file mode 100644
index 91e3cec..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Copyright.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.provisional.p2.metadata;
-
-import java.net.URI;
-
-/**
- * The <code>Copyright</code> class represents a software copyright.  A copyright has 
- * required body text which may be the full text or a summary.  An optional location field can be specified
- * which links to full text.  
- */
-public class Copyright implements ICopyright {
-	/**
-	 * The <code>body</code> contains the descriptive text for the copyright. This may
-	 * be a summary for a copyright specified in a URL.
-	 */
-	private final String body;
-
-	/**
-	 * The <code>location</code> is the location of a document containing a copyright notice.
-	 */
-	private URI location;
-
-	/**
-	 * Creates a new copyright. The body must contain the full text of the copyright.
-	 * 
-	 * @param location the location of a document containing the copyright notice, or <code>null</code>
-	 * @param body the copyright body, cannot be <code>null</code>
-	 * @throws IllegalArgumentException when the <code>body</code> is <code>null</code>
-	 */
-	public Copyright(URI location, String body) {
-		if (body == null)
-			throw new IllegalArgumentException("body cannot be null"); //$NON-NLS-1$
-		this.location = location;
-		this.body = body;
-	}
-
-	/**
-	 * Returns the location of a document containing the copyright notice.
-	 * 
-	 * @return The location of the copyright notice, or <code>null</code>
-	 */
-	public URI getLocation() {
-		return location;
-	}
-
-	/**
-	 * Returns the license body.
-	 * 
-	 * @return the license body, never <code>null</code>
-	 */
-	public String getBody() {
-		return body;
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/ILicense.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/ILicense.java
index 546245d..8d0bbb7 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/ILicense.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/ILicense.java
@@ -40,7 +40,7 @@ public interface ILicense {
 	 * version of the license where all whitespace has been reduced to one space.
 	 * 
 	 * Any SPI must maintain the same semantics as:
-	 * <code>{@link org.eclipse.equinox.internal.provisional.p2.metadata.License#getDigest()}</code>
+	 * <code>{@link org.eclipse.equinox.internal.provisional.p2.metadata.ILicense#getDigest()}</code>
 	 * @return the message digest as a <code>BigInteger</code>, never <code>null</code>
 	 */
 	public BigInteger getDigest();
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/License.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/License.java
deleted file mode 100644
index a6f91f7..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/License.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 Genuitec, LLC and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: 
- * 		Genuitec, LLC - initial API and implementation
- * 		IBM Corporation - optional URL field instead of required name
- *      EclipseSource - ongoing development
- ******************************************************************************/
-package org.eclipse.equinox.internal.provisional.p2.metadata;
-
-import java.io.UnsupportedEncodingException;
-import java.math.BigInteger;
-import java.net.URI;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-/**
- * The <code>License</code> class represents a software license.  A license has required body text
- * which may be the full text or an annotation.  An optional URL field can be specified
- * which links to full text.  Licenses can be easily compared using their digests.
- */
-public class License implements ILicense {
-	/**
-	 * The <code>body</code> contains the descriptive text for the license. This may
-	 * be a summary for a full license specified in a URL.
-	 */
-	private final String body;
-
-	/**
-	 * The <code>location</code> is the URL of the license.
-	 */
-	private URI location;
-
-	/**
-	 * The <code>digest</code> is the cached message digest of the normalized body
-	 */
-	private BigInteger digest;
-
-	/**
-	 * Creates a new license object which is identified by users using the <code>body</code> field.
-	 * The body should contain either the full text of the license or an summary for a license
-	 * fully specified in the given location.
-	 * 
-	 * @param location the location of a document containing the full license, or <code>null</code>
-	 * @param body the license body, cannot be <code>null</code>
-	 * @throws IllegalArgumentException when the <code>body</code> is <code>null</code>
-	 */
-	public License(URI location, String body) {
-		if (body == null)
-			throw new IllegalArgumentException("body cannot be null"); //$NON-NLS-1$
-		this.body = body;
-		this.location = location;
-	}
-
-	/**
-	 * Returns the location of a document containing the full license.
-	 * 
-	 * @return the location of the license document, or <code>null</code>
-	 */
-	public URI getLocation() {
-		return location;
-	}
-
-	/**
-	 * Returns the license body.
-	 * @return the license body, never <code>null</code>
-	 */
-	public String getBody() {
-		return body;
-	}
-
-	/**
-	 * Returns the message digest of the license body.  The digest is calculated on a normalized
-	 * version of the license where all whitespace has been reduced to one space.
-	 * @return the message digest as a <code>BigInteger</code>, never <code>null</code>
-	 */
-	public synchronized BigInteger getDigest() {
-		if (digest == null)
-			digest = calculateLicenseDigest();
-		return digest;
-	}
-
-	/* (non-Javadoc)
-	 * @see java.lang.Object#equals(java.lang.Object)
-	 */
-	public boolean equals(Object obj) {
-		if (obj == this)
-			return true;
-		if (obj == null)
-			return false;
-		if (obj instanceof ILicense) {
-			ILicense other = (ILicense) obj;
-			if (other.getDigest().equals(getDigest()))
-				return true;
-		}
-		return false;
-	}
-
-	/* (non-Javadoc)
-	 * @see java.lang.Object#hashCode()
-	 */
-	public int hashCode() {
-		return getDigest().hashCode();
-	}
-
-	private BigInteger calculateLicenseDigest() {
-		String message = normalize(getBody());
-		try {
-			MessageDigest algorithm = MessageDigest.getInstance("MD5"); //$NON-NLS-1$
-			algorithm.reset();
-			algorithm.update(message.getBytes("UTF-8")); //$NON-NLS-1$
-			byte[] digestBytes = algorithm.digest();
-			return new BigInteger(1, digestBytes);
-		} catch (NoSuchAlgorithmException e) {
-			throw new RuntimeException(e);
-		} catch (UnsupportedEncodingException e) {
-			throw new RuntimeException(e);
-		}
-	}
-
-	/**
-	 * Replace all sequences of whitespace with a single whitespace character.
-	 */
-	private String normalize(String license) {
-		String text = license.trim();
-		StringBuffer result = new StringBuffer();
-		int length = text.length();
-		for (int i = 0; i < length; i++) {
-			char c = text.charAt(i);
-			boolean foundWhitespace = false;
-			while (Character.isWhitespace(c) && i < length) {
-				foundWhitespace = true;
-				c = text.charAt(++i);
-			}
-			if (foundWhitespace)
-				result.append(' ');
-			if (i < length)
-				result.append(c);
-		}
-		return result.toString();
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/ProvidedCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/ProvidedCapability.java
deleted file mode 100644
index 0e88b9f..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/ProvidedCapability.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2009 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *     EclipseSource - ongoing development
- *******************************************************************************/
-package org.eclipse.equinox.internal.provisional.p2.metadata;
-
-import org.eclipse.core.runtime.Assert;
-import org.eclipse.equinox.internal.provisional.p2.core.Version;
-
-/**
- * Describes a capability as exposed or required by an installable unit
- */
-public class ProvidedCapability implements IProvidedCapability {
-	private final String name;
-	private final String namespace;
-	private final Version version;
-
-	ProvidedCapability(String namespace, String name, Version version) {
-		Assert.isNotNull(namespace);
-		Assert.isNotNull(name);
-		this.namespace = namespace;
-		this.name = name;
-		this.version = version == null ? Version.emptyVersion : version;
-	}
-
-	public boolean equals(Object other) {
-		if (other == null)
-			return false;
-		if (!(other instanceof IProvidedCapability))
-			return false;
-		IProvidedCapability otherCapability = (IProvidedCapability) other;
-		if (!(namespace.equals(otherCapability.getNamespace())))
-			return false;
-		if (!(name.equals(otherCapability.getName())))
-			return false;
-		return version.equals(otherCapability.getVersion());
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public String getNamespace() {
-		return namespace;
-	}
-
-	public Version getVersion() {
-		return version;
-	}
-
-	public int hashCode() {
-		return namespace.hashCode() * name.hashCode() * version.hashCode();
-	}
-
-	/**
-	 * Returns whether this provided capability satisfies the given required capability.
-	 * @return <code>true</code> if this capability satisfies the given required
-	 * capability, and <code>false</code> otherwise.
-	 */
-	public boolean satisfies(IRequiredCapability candidate) {
-		if (getName() == null || !getName().equals(candidate.getName()))
-			return false;
-		if (getNamespace() == null || !getNamespace().equals(candidate.getNamespace()))
-			return false;
-		return candidate.getRange().isIncluded(version);
-	}
-
-	public String toString() {
-		return namespace + '/' + name + '/' + version;
-	}
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/RequiredCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/RequiredCapability.java
deleted file mode 100644
index 45e2635..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/RequiredCapability.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: 
- *     IBM Corporation - initial API and implementation
- *     EclipseSource - ongoing development
- ******************************************************************************/
-package org.eclipse.equinox.internal.provisional.p2.metadata;
-
-import org.eclipse.core.runtime.Assert;
-import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
-
-/**
- * A required capability represents some external constraint on an {@link IInstallableUnit}.
- * Each capability represents something an {@link IInstallableUnit} needs that
- * it expects to be provided by another {@link IInstallableUnit}. Capabilities are
- * entirely generic, and are intended to be capable of representing anything that
- * an {@link IInstallableUnit} may need either at install time, or at runtime.
- * <p>
- * Capabilities are segmented into namespaces.  Anyone can introduce new 
- * capability namespaces. Some well-known namespaces are introduced directly
- * by the provisioning framework.
- * 
- * @see IInstallableUnit#NAMESPACE_IU_ID
- */
-public class RequiredCapability implements IRequiredCapability {
-	private static final String[] NO_SELECTORS = new String[0];
-
-	private String filter;
-	private final boolean multiple;
-	private final String name;//never null
-	private final String namespace;//never null
-	private boolean optional;
-	private boolean greedy = true;
-	private final VersionRange range;//never null
-	private String[] selectors = NO_SELECTORS;//never null
-
-	/**
-	 * TODO replace booleans with int options flag.
-	 */
-	RequiredCapability(String namespace, String name, VersionRange range, String filter, boolean optional, boolean multiple) {
-		Assert.isNotNull(namespace);
-		Assert.isNotNull(name);
-		this.namespace = namespace;
-		this.name = name;
-		this.range = range == null ? VersionRange.emptyRange : range;
-		this.optional = optional;
-		this.filter = filter;
-		this.multiple = multiple;
-	}
-
-	RequiredCapability(String namespace, String name, VersionRange range, String filter, boolean optional, boolean multiple, boolean greedy) {
-		this(namespace, name, range, filter, optional, multiple);
-		this.greedy = greedy;
-	}
-
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (!(obj instanceof IRequiredCapability))
-			return false;
-		final IRequiredCapability other = (IRequiredCapability) obj;
-		if (filter == null) {
-			if (other.getFilter() != null)
-				return false;
-		} else if (!filter.equals(other.getFilter()))
-			return false;
-		if (multiple != other.isMultiple())
-			return false;
-		if (!name.equals(other.getName()))
-			return false;
-		if (!namespace.equals(other.getNamespace()))
-			return false;
-		if (optional != other.isOptional())
-			return false;
-		if (!range.equals(other.getRange()))
-			return false;
-		return true;
-	}
-
-	public String getFilter() {
-		return filter;
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public String getNamespace() {
-		return namespace;
-	}
-
-	/**
-	 * Returns the range of versions that satisfy this required capability. Returns
-	 * an empty version range ({@link VersionRange#emptyRange} if any version
-	 * will satisfy the capability.
-	 * @return the range of versions that satisfy this required capability.
-	 */
-	public VersionRange getRange() {
-		return range;
-	}
-
-	/**
-	 * Returns the properties to use for evaluating required capability filters 
-	 * downstream from this capability. For example, if the selector "doc"
-	 * is provided, then a downstream InstallableUnit with a required capability
-	 * filtered with "doc=true" will be included.
-	 */
-	public String[] getSelectors() {
-		return selectors;
-	}
-
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((filter == null) ? 0 : filter.hashCode());
-		result = prime * result + (multiple ? 1231 : 1237);
-		result = prime * result + name.hashCode();
-		result = prime * result + namespace.hashCode();
-		result = prime * result + (optional ? 1231 : 1237);
-		result = prime * result + range.hashCode();
-		return result;
-	}
-
-	public boolean isMultiple() {
-		return multiple;
-	}
-
-	public boolean isOptional() {
-		return optional;
-	}
-
-	/**
-	 * TODO This object shouldn't be mutable since it makes equality unstable, and
-	 * introduces lifecycle issues (how are the changes persisted, etc)
-	 */
-	public void setFilter(String filter) {
-		this.filter = filter;
-	}
-
-	/**
-	 * TODO This object shouldn't be mutable since it makes equality unstable, and
-	 * introduces lifecycle issues (how are the changes persisted, etc)
-	 */
-	public void setSelectors(String[] selectors) {
-		this.selectors = selectors;
-	}
-
-	public boolean isGreedy() {
-		return greedy;
-	}
-
-	public String toString() {
-		StringBuffer result = new StringBuffer();
-
-		if (IInstallableUnit.NAMESPACE_IU_ID.equals(getNamespace())) {
-			//print nothing for an IU id dependency because this is the default (most common) case
-			result.append(""); //$NON-NLS-1$
-		} else if ("osgi.bundle".equals(getNamespace())) { //$NON-NLS-1$
-			result.append("bundle"); //$NON-NLS-1$
-		} else if ("java.package".equals(getNamespace())) { //$NON-NLS-1$
-			result.append("package"); //$NON-NLS-1$
-		} else {
-			result.append(getNamespace());
-		}
-		if (result.length() > 0)
-			result.append(' ');
-		result.append(getName());
-		result.append(' ');
-		//for an exact version match, print a simpler expression
-		if (range.getMinimum().equals(range.getMaximum()))
-			result.append('[').append(range.getMinimum()).append(']');
-		else
-			result.append(range);
-		return result.toString();
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/RequirementChange.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/RequirementChange.java
deleted file mode 100644
index 8a94f26..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/RequirementChange.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: IBM Corporation - initial API and implementation
- ******************************************************************************/
-package org.eclipse.equinox.internal.provisional.p2.metadata;
-
-import org.eclipse.equinox.internal.provisional.p2.core.Version;
-import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
-
-public class RequirementChange implements IRequirementChange {
-	private IRequiredCapability applyOn;
-	private IRequiredCapability newValue;
-
-	public RequirementChange(IRequiredCapability applyOn2, IRequiredCapability newValue2) {
-		if (applyOn2 == null && newValue2 == null)
-			throw new IllegalArgumentException();
-		this.applyOn = applyOn2;
-		this.newValue = newValue2;
-	}
-
-	public IRequiredCapability applyOn() {
-		return applyOn;
-	}
-
-	public IRequiredCapability newValue() {
-		return newValue;
-	}
-
-	public boolean matches(IRequiredCapability toMatch) {
-		if (!toMatch.getNamespace().equals(applyOn.getNamespace()))
-			return false;
-		if (!toMatch.getName().equals(applyOn.getName()))
-			return false;
-		if (toMatch.getRange().equals(applyOn.getRange()))
-			return true;
-
-		return intersect(toMatch.getRange(), applyOn.getRange()) == null ? false : true;
-	}
-
-	private VersionRange intersect(VersionRange r1, VersionRange r2) {
-		Version resultMin = null;
-		boolean resultMinIncluded = false;
-		Version resultMax = null;
-		boolean resultMaxIncluded = false;
-
-		int minCompare = r1.getMinimum().compareTo(r2.getMinimum());
-		if (minCompare < 0) {
-			resultMin = r2.getMinimum();
-			resultMinIncluded = r2.getIncludeMinimum();
-		} else if (minCompare > 0) {
-			resultMin = r1.getMinimum();
-			resultMinIncluded = r1.getIncludeMinimum();
-		} else if (minCompare == 0) {
-			resultMin = r1.getMinimum();
-			resultMinIncluded = r1.getIncludeMinimum() && r2.getIncludeMinimum();
-		}
-
-		int maxCompare = r1.getMaximum().compareTo(r2.getMaximum());
-		if (maxCompare > 0) {
-			resultMax = r2.getMaximum();
-			resultMaxIncluded = r2.getIncludeMaximum();
-		} else if (maxCompare < 0) {
-			resultMax = r1.getMaximum();
-			resultMaxIncluded = r1.getIncludeMaximum();
-		} else if (maxCompare == 0) {
-			resultMax = r1.getMaximum();
-			resultMaxIncluded = r1.getIncludeMaximum() && r2.getIncludeMaximum();
-		}
-
-		int resultRangeComparison = resultMin.compareTo(resultMax);
-		if (resultRangeComparison < 0)
-			return new VersionRange(resultMin, resultMinIncluded, resultMax, resultMaxIncluded);
-		else if (resultRangeComparison == 0 && resultMinIncluded == resultMaxIncluded)
-			return new VersionRange(resultMin, resultMinIncluded, resultMax, resultMaxIncluded);
-		else
-			return null;
-	}
-
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((applyOn == null) ? 0 : applyOn.hashCode());
-		result = prime * result + ((newValue == null) ? 0 : newValue.hashCode());
-		return result;
-	}
-
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (!(obj instanceof IRequirementChange))
-			return false;
-		final IRequirementChange other = (IRequirementChange) obj;
-		if (applyOn == null) {
-			if (other.applyOn() != null)
-				return false;
-		} else if (!applyOn.equals(other.applyOn()))
-			return false;
-		if (newValue == null) {
-			if (other.newValue() != null)
-				return false;
-		} else if (!newValue.equals(other.newValue()))
-			return false;
-		return true;
-	}
-
-	public String toString() {
-		return applyOn + " --> " + newValue; //$NON-NLS-1$
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointData.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointData.java
deleted file mode 100644
index baef222..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointData.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *     EclipseSource - ongoing development
- *******************************************************************************/
-package org.eclipse.equinox.internal.provisional.p2.metadata;
-
-import java.util.*;
-import java.util.Map.Entry;
-
-/**
- * Touchpoint data instances contain the additional information needed by a touchpoint
- * to execute each engine phase it participates in. This includes the sequence of
- * instruction statements to be executed during each phase, and any additional
- * supporting data needed to perform the phase.
- *
- * @noextend This class is not intended to be subclassed by clients.
- * @see MetadataFactory#createTouchpointData(Map)
- */
-public class TouchpointData implements ITouchpointData {
-
-	/**
-	 * Map of (String->TouchpointInstruction). The set
-	 * of keys supported is up to the touchpoint that will process these
-	 * instructions. This map is never null.
-	 */
-	private Map instructions;
-
-	public int hashCode() {
-		return 31 * 1 + ((instructions == null) ? 0 : instructions.hashCode());
-	}
-
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (!(obj instanceof ITouchpointData))
-			return false;
-		final ITouchpointData other = (ITouchpointData) obj;
-		if (instructions == null) {
-			if (other.getInstructions() != null)
-				return false;
-		} else if (!instructions.equals(other.getInstructions()))
-			return false;
-		return true;
-	}
-
-	/**
-	 * Clients must use the factory method on {@link MetadataFactory}.
-	 */
-	TouchpointData(Map instructions) {
-		this.instructions = instructions;
-	}
-
-	/**
-	 * Returns the touchpoint instruction corresponding to the given key.
-	 */
-	public ITouchpointInstruction getInstruction(String instructionKey) {
-		return (ITouchpointInstruction) instructions.get(instructionKey);
-	}
-
-	/**
-	 * Returns an unmodifiable map of the touchpoint instructions. The map
-	 * keys are strings, and the values are instances of {@link ITouchpointInstruction}.
-	 *
-	 * @return the touchpoint instructions
-	 */
-	public Map getInstructions() {
-		return Collections.unmodifiableMap(instructions);
-	}
-
-	/**
-	 * Returns a string representation of the touchpoint data for debugging purposes only.
-	 */
-	public String toString() {
-		StringBuffer result = new StringBuffer();
-		for (Iterator iterator = instructions.entrySet().iterator(); iterator.hasNext();) {
-			Entry instruction = (Entry) iterator.next();
-			result.append(instruction.getKey()).append(" -> ").append(instruction.getValue()).append('\n'); //$NON-NLS-1$
-		}
-		return result.toString();
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointInstruction.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointInstruction.java
deleted file mode 100644
index 96fa830..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointInstruction.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *     EclipseSource - ongoing development
- *******************************************************************************/
-package org.eclipse.equinox.internal.provisional.p2.metadata;
-
-import java.util.Iterator;
-import java.util.Map;
-
-/**
- * A touchpoint instruction contains either a sequence of instruction statements
- * to be executed during a particular engine phase, or some simple string value
- * that is needed by a touchpoint to execute its phases.
- * <p>
- * The format of a touchpoint instruction statement sequence is as follows:
- * 
- *   statement-sequence :
- *     | statement ';'
- *      | statement-sequence statement
- *      ;
- *
- *Where a statement is of the format:
- *
- *  statement :
- *      | actionName '(' parameters ')'
- *      ;
- *
- *  parameters :
- *      | // empty
- *      | parameter
- *      | parameters ',' parameter
- *      ;
- *
- *   parameter : 
- *      | paramName ':' paramValue
- *      ;
- *
- * actionName, paramName, paramValue :
- *      | String 
- *      ;
- *
- * @noextend This class is not intended to be subclassed by clients.
- * @see MetadataFactory#createTouchpointInstruction(String, String)
- */
-public class TouchpointInstruction implements ITouchpointInstruction {
-
-	private final String body;
-	private final String importAttribute;
-
-	/**
-	 * Encodes an action statement in string form. This method will
-	 * take care of escaping any illegal characters in function parameter values.
-	 * 
-	 * @param actionName The name of the action.
-	 * @param parameters The function's parameters. This is a Map<String,String>
-	 * where the keys are parameter names, and the values are parameter values
-	 * @return An encoded touchpoint instruction statement
-	 */
-	public static String encodeAction(String actionName, Map parameters) {
-		StringBuffer result = new StringBuffer(actionName);
-		result.append('(');
-		for (Iterator it = parameters.entrySet().iterator(); it.hasNext();) {
-			Map.Entry entry = (Map.Entry) it.next();
-			result.append(entry.getKey());
-			result.append(':');
-			appendEncoded(result, (String) entry.getValue());
-			if (it.hasNext())
-				result.append(',');
-		}
-		result.append(')').append(';');
-		return result.toString();
-	}
-
-	/**
-	 * Append the given value to the given buffer, encoding any illegal characters
-	 * with appropriate escape sequences.
-	 */
-	private static void appendEncoded(StringBuffer buf, String value) {
-		char[] chars = value.toCharArray();
-		for (int i = 0; i < chars.length; i++) {
-			switch (chars[i]) {
-				case '$' :
-				case ',' :
-				case ':' :
-				case ';' :
-				case '{' :
-				case '}' :
-					buf.append("${#").append(Integer.toString(chars[i])).append('}'); //$NON-NLS-1$
-					break;
-				default :
-					buf.append(chars[i]);
-			}
-		}
-	}
-
-	/**
-	 * Clients must use the factory method on {@link MetadataFactory}.
-	 */
-	TouchpointInstruction(String body, String importAttribute) {
-		this.body = body;
-		this.importAttribute = importAttribute;
-	}
-
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (!(obj instanceof ITouchpointInstruction))
-			return false;
-		ITouchpointInstruction other = (ITouchpointInstruction) obj;
-		if (body == null) {
-			if (other.getBody() != null)
-				return false;
-		} else if (!body.equals(other.getBody()))
-			return false;
-		if (importAttribute == null) {
-			if (other.getImportAttribute() != null)
-				return false;
-		} else if (!importAttribute.equals(other.getImportAttribute()))
-			return false;
-		return true;
-	}
-
-	/**
-	 * Returns the body of this touchpoint instruction. The body is either a sequence
-	 * of instruction statements, or a simple string value.
-	 * 
-	 * @return The body of this touchpoint instruction
-	 */
-	public String getBody() {
-		return body;
-	}
-
-	//TODO What is this? Please doc
-	public String getImportAttribute() {
-		return importAttribute;
-	}
-
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((body == null) ? 0 : body.hashCode());
-		result = prime * result + ((importAttribute == null) ? 0 : importAttribute.hashCode());
-		return result;
-	}
-
-	/**
-	 * Returns a string representation of this instruction for debugging purposes only.
-	 */
-	public String toString() {
-		return "Instruction[" + body + ',' + importAttribute + ']'; //$NON-NLS-1$
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointType.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointType.java
deleted file mode 100644
index 957e443..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/TouchpointType.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *     EclipseSource - ongoing Development
- *******************************************************************************/
-package org.eclipse.equinox.internal.provisional.p2.metadata;
-
-import org.eclipse.equinox.internal.provisional.p2.core.Version;
-
-/**
- * Identifies a particular touchpoint. A touchpoint is identified by an id 
- * and a version.
- */
-public class TouchpointType implements ITouchpointType {
-	private String id;//never null
-	private Version version;//never null
-
-	TouchpointType(String id, Version aVersion) {
-		this.id = id;
-		this.version = aVersion;
-	}
-
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (super.equals(obj))
-			return true;
-		if (obj == null || !(obj instanceof ITouchpointType))
-			return false;
-		ITouchpointType other = (ITouchpointType) obj;
-		return id.equals(other.getId()) && version.equals(other.getVersion());
-	}
-
-	public String getId() {
-		return id;
-	}
-
-	public Version getVersion() {
-		return version;
-	}
-
-	public int hashCode() {
-		return 31 * id.hashCode() + version.hashCode();
-	}
-
-	public String toString() {
-		return "Touchpoint: " + id + ' ' + getVersion(); //$NON-NLS-1$
-	}
-}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
index 7ee3152..c637f20 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
@@ -10,6 +10,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.publisher.eclipse;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import java.io.*;
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -342,7 +344,7 @@ public class FeaturesAction extends AbstractPublisherAction {
 			}
 			if (entries[i].isPlugin()) {
 				IRequiredCapability from = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, getTransformedId(entries[i].getId(), entries[i].isPlugin(), /*isGroup*/true), VersionRange.emptyRange, getFilter(entries[i]), entries[i].isOptional(), false);
-				requirementChanges.add(new RequirementChange(from, req));
+				requirementChanges.add(MetadataFactory.createRequirementChange(from, req));
 				continue;
 			}
 			patchRequirements.add(req);
diff --git a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/dialogs/IUPropertyPagesTest.java b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/dialogs/IUPropertyPagesTest.java
index 784b9ce..5fc10be 100644
--- a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/dialogs/IUPropertyPagesTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/dialogs/IUPropertyPagesTest.java
@@ -13,7 +13,8 @@ package org.eclipse.equinox.p2.tests.ui.dialogs;
 import java.net.URI;
 import java.net.URISyntaxException;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
-import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
 import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.tests.ui.AbstractProvisioningUITest;
 import org.eclipse.ui.PlatformUI;
@@ -68,8 +69,8 @@ public class IUPropertyPagesTest extends AbstractProvisioningUITest {
 		iuDescription.setProperty(IInstallableUnit.PROP_PROVIDER, "Test Cases");
 		iuDescription.setProperty(IInstallableUnit.PROP_DESCRIPTION, "A description");
 		iuDescription.setProperty(IInstallableUnit.PROP_NAME, "The Biggest Baddest Test IU");
-		iuDescription.setLicense(new License(new URI("http://example.com"), "This is an example license"));
-		iuDescription.setCopyright(new Copyright(new URI("http://example.com"), "This is an example copyright"));
+		iuDescription.setLicense(MetadataFactory.createLicense(new URI("http://example.com"), "This is an example license"));
+		iuDescription.setCopyright(MetadataFactory.createCopyright(new URI("http://example.com"), "This is an example copyright"));
 		return MetadataFactory.createInstallableUnit(iuDescription);
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/query/IUPropertyUtilsTest.java b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/query/IUPropertyUtilsTest.java
index 1440834..808c8eb 100644
--- a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/query/IUPropertyUtilsTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/query/IUPropertyUtilsTest.java
@@ -77,7 +77,7 @@ public class IUPropertyUtilsTest extends AbstractQueryTest {
 		InstallableUnitDescription iuDescription = new InstallableUnitDescription();
 		iuDescription.setId("some IU");
 		iuDescription.setVersion(new Version(1, 0, 0));
-		iuDescription.setLicense(new License(new URI("http://example.com"), "%license"));
+		iuDescription.setLicense(MetadataFactory.createLicense(new URI("http://example.com"), "%license"));
 		IInstallableUnit iu = MetadataFactory.createInstallableUnit(iuDescription);
 
 		// Create a bunch of fragments which spec our IU as their host
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPatchPersistenceTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPatchPersistenceTest.java
index 5401c74..651ad07 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPatchPersistenceTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPatchPersistenceTest.java
@@ -10,6 +10,8 @@
  *******************************************************************************/
 package org.eclipse.equinox.p2.tests.metadata;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import java.io.*;
 import java.util.*;
 import javax.xml.parsers.ParserConfigurationException;
@@ -286,9 +288,9 @@ public class IUPatchPersistenceTest extends AbstractProvisioningTest {
 		ITouchpointData tpData = createTouchpointData(instructions);
 		IUpdateDescriptor update = createUpdateDescriptor();
 		boolean singleton = false;
-		IRequirementChange change1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
-		IRequirementChange change2 = new RequirementChange(null, MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
-		IRequirementChange change3 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), null);
+		IRequirementChange change1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change2 = MetadataFactory.createRequirementChange(null, MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change3 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), null);
 		IRequiredCapability[][] scope = new IRequiredCapability[][] { {MetadataFactory.createRequiredCapability("foo", "bar", null, null, true, true), MetadataFactory.createRequiredCapability("foo", "bar", null, null, true, true)}, {MetadataFactory.createRequiredCapability("zoo", "far", null, null, true, true)}};
 		IRequiredCapability lifeCycle = MetadataFactory.createRequiredCapability("zoo", "x", null, null, false, false, false);
 		IInstallableUnitPatch iu = createIUPatch(id, version, filter, requirements, additionalProvides, propertyMap, TOUCHPOINT_OSGI, tpData, singleton, update, new IRequirementChange[] {change1, change2, change3}, scope, lifeCycle);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
index f4b22ae..31ed9b4 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
@@ -10,6 +10,8 @@
  *******************************************************************************/
 package org.eclipse.equinox.p2.tests.metadata;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import java.io.*;
 import java.util.*;
 import javax.xml.parsers.ParserConfigurationException;
@@ -264,9 +266,9 @@ public class IUPersistenceTest extends AbstractProvisioningTest {
 		ITouchpointData tpData = createTouchpointData(instructions);
 		IUpdateDescriptor update = createUpdateDescriptor();
 		boolean singleton = false;
-		IRequirementChange change1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
-		IRequirementChange change2 = new RequirementChange(null, MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
-		IRequirementChange change3 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), null);
+		IRequirementChange change1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change2 = MetadataFactory.createRequirementChange(null, MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change3 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), null);
 		IRequiredCapability[][] scope = new IRequiredCapability[][] { {MetadataFactory.createRequiredCapability("foo", "bar", null, null, true, true), MetadataFactory.createRequiredCapability("foo", "bar", null, null, true, true)}, {MetadataFactory.createRequiredCapability("zoo", "far", null, null, true, true)}};
 		IInstallableUnitPatch iu = createIUPatch(id, version, filter, requirements, additionalProvides, propertyMap, TOUCHPOINT_OSGI, tpData, singleton, update, new IRequirementChange[] {change1, change2, change3}, scope, null);
 		return iu;
@@ -280,9 +282,9 @@ public class IUPersistenceTest extends AbstractProvisioningTest {
 		ITouchpointData tpData = createTouchpointData(instructions);
 		IUpdateDescriptor update = createUpdateDescriptor();
 		boolean singleton = false;
-		IRequirementChange change1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
-		IRequirementChange change2 = new RequirementChange(null, MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
-		IRequirementChange change3 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), null);
+		IRequirementChange change1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change2 = MetadataFactory.createRequirementChange(null, MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change3 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), null);
 		IRequiredCapability[][] scope = new IRequiredCapability[][] {{}};
 		IInstallableUnitPatch iu = createIUPatch(id, version, filter, requirements, additionalProvides, propertyMap, TOUCHPOINT_OSGI, tpData, singleton, update, new IRequirementChange[] {change1, change2, change3}, scope, null);
 		return iu;
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
index a2f3563..55254d9 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
@@ -9,6 +9,9 @@
 ******************************************************************************/
 package org.eclipse.equinox.p2.tests.metadata.repository;
 
+import org.eclipse.equinox.internal.p2.metadata.ProvidedCapability;
+import org.eclipse.equinox.internal.p2.metadata.RequiredCapability;
+
 import java.io.File;
 import java.io.UnsupportedEncodingException;
 import java.math.BigInteger;
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/Bug249605.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/Bug249605.java
index 08d4f55..e30bddc 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/Bug249605.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/Bug249605.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import java.util.HashMap;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.NullProgressMonitor;
@@ -34,13 +36,13 @@ public class Bug249605 extends AbstractProvisioningTest {
 		b2 = createIU("B", new Version(1, 2, 0), true);
 		b3 = createIU("B", new Version(1, 3, 0), true);
 
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.2.0)"), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.2.0)"), null, false, false, true));
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
-		IRequirementChange change2 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.2.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.2.0, 1.3.0)"), null, false, false, true));
 		p2 = createIUPatch("P", new Version("1.2.0"), null, new IRequiredCapability[0], new IProvidedCapability[0], new HashMap(), null, null, true, MetadataFactory.createUpdateDescriptor("P", new VersionRange("[1.0.0, 1.2.0)"), 0, null), new IRequirementChange[] {change2}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
-		IRequirementChange change3 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.3.0, 1.4.0)"), null, false, false, true));
+		IRequirementChange change3 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.3.0, 1.4.0)"), null, false, false, true));
 		p3 = createIUPatch("P", new Version("1.3.0"), null, new IRequiredCapability[0], new IProvidedCapability[0], new HashMap(), null, null, true, MetadataFactory.createUpdateDescriptor("P", new VersionRange("[1.0.0, 1.3.0)"), 0, null), new IRequirementChange[] {change3}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, b2, b3, p1, p2, p3});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/Bug252638.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/Bug252638.java
index e7b873b..12a372a 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/Bug252638.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/Bug252638.java
@@ -1,5 +1,7 @@
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -20,7 +22,7 @@ public class Bug252638 extends AbstractProvisioningTest {
 	protected void setUp() throws Exception {
 		super.setUp();
 		a1 = createIU("A", new Version("1.0.0"), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		IRequiredCapability lifeCycle = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[2.0.0, 3.0.0)"), null, false, false, false);
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, lifeCycle);
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PP2ShouldFailToInstall.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PP2ShouldFailToInstall.java
index 1e21f9d..2464f77 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PP2ShouldFailToInstall.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PP2ShouldFailToInstall.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -37,12 +39,12 @@ public class PP2ShouldFailToInstall extends AbstractProvisioningTest {
 		p1b = createIU("P1", new Version(1, 1, 1), true);
 		p2b = createIU("P2", new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "P1", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "P1", new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "P1", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "P1", new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "p2.feature", new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "p2.feature", new VersionRange("[1.0.0,1.0.0]"), null, false, false)}};
 		pp1 = createIUPatch("PP1", new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
 
-		IRequirementChange changepp2 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "P2", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "P2", new VersionRange("[3.1.1, 3.1.1]"), null, false, false, true));
+		IRequirementChange changepp2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "P2", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "P2", new VersionRange("[3.1.1, 3.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "p2.feature", new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp2 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "p2.feature", new VersionRange("[1.0.0, 1.0.0]"), null, false, false)}};
 		pp2 = createIUPatch("PP2", new Version("5.0.0"), true, new IRequirementChange[] {changepp2}, scopepp2, lifeCyclepp2);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchFailingToInstall.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchFailingToInstall.java
index 43be5c6..2c5596c 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchFailingToInstall.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchFailingToInstall.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -37,12 +39,12 @@ public class PatchFailingToInstall extends AbstractProvisioningTest {
 		p1b = createIU("P1", new Version(1, 1, 1), true);
 		p2b = createIU("P2", new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "p2.feature", new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "P1", new VersionRange("[1.1.1,1.1.1]"), null, false, false)}};
 		pp1 = createIUPatch("PP1", new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
 
-		IRequirementChange changepp2 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange changepp2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		IRequiredCapability lifeCyclepp2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "p2.feature", new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp2 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "P2", new VersionRange("[1.1.1,1.1.1]"), null, false, false)}};
 		pp2 = createIUPatch("PP2", new Version("5.0.0"), true, new IRequirementChange[] {changepp2}, scopepp2, lifeCyclepp2);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1.java
index a8c8106..d0020a0 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -30,7 +32,7 @@ public class PatchTest1 extends AbstractProvisioningTest {
 		super.setUp();
 		a1 = createIU("A", new Version("1.0.0"), new IRequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.0.0, 1.1.0)"), null, false, true)});
 		b1 = createIU("B", new Version(1, 2, 0), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, p1});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest10.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest10.java
index 50385da..9fcfa7d 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest10.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest10.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -35,10 +37,10 @@ public class PatchTest10 extends AbstractProvisioningTest {
 		b1 = createIU("B", new Version(1, 0, 0), true);
 		b2 = createIU("B", new Version(1, 2, 0), true);
 		b3 = createIU("B", new Version(1, 3, 0), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.2.0, 1.2.0]"), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.2.0, 1.2.0]"), null, false, false, true));
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
-		IRequirementChange anotherChangeB = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.3.0, 1.3.0]"), null, false, false, true));
+		IRequirementChange anotherChangeB = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.3.0, 1.3.0]"), null, false, false, true));
 		pp1 = createIUPatch("PP", new Version("1.0.0"), true, new IRequirementChange[] {anotherChangeB}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, b2, b3, p1, pp1});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest11.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest11.java
index a71d3bd..4ca0838 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest11.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest11.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -32,7 +34,7 @@ public class PatchTest11 extends AbstractProvisioningTest {
 		a1 = createIU("A", new Version("1.0.0"), new IRequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.0.0, 1.1.0)"), null, false, true, true)});
 		b1 = createIU("B", new Version(1, 0, 0), true);
 		b2 = createIU("B", new Version(1, 2, 0), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), "foo=bar", false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), "foo=bar", false, false, true));
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, b2, p1});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest12.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest12.java
index 8b26884..88b4e2c 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest12.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest12.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -32,7 +34,7 @@ public class PatchTest12 extends AbstractProvisioningTest {
 		a1 = createIU("A", new Version("1.0.0"), new IRequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.0.0, 1.1.0)"), null, false, true, true)});
 		b1 = createIU("B", new Version(1, 0, 0), true);
 		b2 = createIU("B", new Version(1, 2, 0), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.4.0, 1.5.0)"), null, false, true, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.4.0, 1.5.0)"), null, false, true, true));
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, b2, p1});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest13.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest13.java
index 3eaa826..ad3ef3f 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest13.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest13.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -34,7 +36,7 @@ public class PatchTest13 extends AbstractProvisioningTest {
 		b1 = createIU("B", new Version(1, 0, 0), true);
 		d1 = createIU("D", new Version(1, 0, 0), true);
 		c1 = createIU("C", new Version(1, 0, 0), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", new VersionRange("[1.0.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", new VersionRange("[1.0.0, 1.3.0)"), null, false, false, true));
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, c1, d1, p1});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1b.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1b.java
index 5553630..eb217e6 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1b.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1b.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -32,7 +34,7 @@ public class PatchTest1b extends AbstractProvisioningTest {
 		a1 = createIU("A", new Version("1.0.0"), new IRequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.0.0, 1.1.0)"), null, false, true)});
 		b1 = createIU("B", new Version(1, 0, 0), true);
 		b2 = createIU("B", new Version(1, 2, 0), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, b2, p1});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1c.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1c.java
index 439397d..ff98dad 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1c.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest1c.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -34,7 +36,7 @@ public class PatchTest1c extends AbstractProvisioningTest {
 		b1 = createIU("B", new Version(1, 0, 0), true);
 		b2 = createIU("B", new Version(1, 2, 0), true);
 		b3 = createIU("B", new Version(1, 3, 0), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.2.0, 1.2.0]"), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.2.0, 1.2.0]"), null, false, false, true));
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, b2, p1});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest2.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest2.java
index bc04ead..7d81a4b 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest2.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest2.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -36,7 +38,7 @@ public class PatchTest2 extends AbstractProvisioningTest {
 		IProvidedCapability[] cap = new IProvidedCapability[] {MetadataFactory.createProvidedCapability("foo", "bar", new Version(1, 0, 0))};
 		a1 = createIU("A", new Version("1.0.0"), null, new IRequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.0.0, 1.1.0)"), null, false, false)}, cap, NO_PROPERTIES, ITouchpointType.NONE, NO_TP_DATA, false, null);
 		b1 = createIU("B", new Version(1, 2, 0), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[1.0.0, 1.1.0]"), null, false, false, false)}}, null);
 		p2 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[1.3.0, 1.5.0]"), null, false, false, false)}}, null);
 		p3 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] { {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[1.0.0, 1.1.0]"), null, false, false, false)}, {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[1.3.0, 1.5.0]"), null, false, false, false)}}, null);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest3.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest3.java
index 6fdbb49..ef392a1 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest3.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest3.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -37,7 +39,7 @@ public class PatchTest3 extends AbstractProvisioningTest {
 		a3 = createIU("A", new Version(3, 0, 0), true);
 		b1 = createIU("B", new Version(1, 0, 0), true);
 		b2 = createIU("B", new Version(2, 0, 0), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[2.0.0, 2.1.0)"), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[2.0.0, 2.1.0)"), null, false, false, true));
 		IRequiredCapability lifeCycle = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "F", new VersionRange("[1.0.0, 1.1.0)"), null, false, false, false);
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[1.0.0, 1.1.0]"), null, false, false, false)}}, lifeCycle);
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, b2, p1, a3, f1, f2});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest4.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest4.java
index a0d2e5d..de63609 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest4.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest4.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -42,8 +44,8 @@ public class PatchTest4 extends AbstractProvisioningTest {
 		b2 = createIU("B", new Version(2, 0, 0), new IRequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", new VersionRange("[2.0.0, 3.1.0)"), null, false, false, true)});
 		d2 = createIU("D", new Version(2, 0, 0), true);
 
-		IRequirementChange changeA = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[2.0.0, 2.1.0)"), null, false, false, true));
-		IRequirementChange changeC = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", new VersionRange("[2.0.0, 2.1.0)"), null, false, false, true));
+		IRequirementChange changeA = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[2.0.0, 2.1.0)"), null, false, false, true));
+		IRequirementChange changeC = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", new VersionRange("[2.0.0, 2.1.0)"), null, false, false, true));
 
 		IRequiredCapability lifeCycle = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "F", VersionRange.emptyRange, null, false, false, false);
 		IRequiredCapability[][] scope = new IRequiredCapability[][] { {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[1.0.0, 1.1.0]"), null, false, false, false)}, {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", new VersionRange("[1.0.0, 1.1.0]"), null, false, false, false)}};
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest5.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest5.java
index 5d7b6cc..d226598 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest5.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest5.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -34,7 +36,7 @@ public class PatchTest5 extends AbstractProvisioningTest {
 		f1 = createIU("F", new Version(1, 0, 0), new IRequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true)});
 		a1 = createIU("A", new Version("1.0.0"), new IRequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.0.0, 1.1.0)"), null, false, true)});
 		b1 = createIU("B", new Version(1, 2, 0), true);
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		IRequiredCapability lifeCycle = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "F", new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scope = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[1.0.0,1.0.0]"), null, false, false)}};
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, scope, lifeCycle);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest6.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest6.java
index 85ebdcd..cb5831b 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest6.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest6.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -38,12 +40,12 @@ public class PatchTest6 extends AbstractProvisioningTest {
 		c1 = createIU("C", new Version("1.0.0"), new IRequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", new VersionRange("[1.0.0, 1.1.0)"), null, false, true)});
 		d1 = createIU("D", new Version(1, 2, 0), true);
 
-		IRequirementChange changeA = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange changeA = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		IRequiredCapability[][] scopeP1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false, false)}};
 		IRequiredCapability[] reqOnPP = new IRequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "PP", new VersionRange("[1.0.0, 2.0.0)"), null, false, false, true)};
 		p1 = createIUPatch("P", new Version("1.0.0"), null, reqOnPP, NO_PROVIDES, NO_PROPERTIES, ITouchpointType.NONE, NO_TP_DATA, false, null, new IRequirementChange[] {changeA}, scopeP1, null);
 
-		IRequirementChange changeC = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange changeC = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "D", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		IRequiredCapability[][] scopePP1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", VersionRange.emptyRange, null, false, false, false)}};
 		pp1 = createIUPatch("PP", new Version("1.0.0"), true, new IRequirementChange[] {changeC}, scopePP1, null);
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, c1, d1, p1, pp1});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest7.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest7.java
index 74252e5..918d53b 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest7.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest7.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -52,7 +54,7 @@ public class PatchTest7 extends AbstractProvisioningTest {
 		//		RequiredCapability[][] scope = new RequiredCapability[0][0]; //new RequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false, false)}};
 		//		p1 = createIUPatch("P", new Version("1.0.0"), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, TouchpointType.NONE, NO_TP_DATA, false, null, new RequirementChange[] {changeX}, scope, null);
 
-		IRequirementChange changeY = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "Y", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "Y", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange changeY = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "Y", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "Y", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		IRequiredCapability[][] scopePP = new IRequiredCapability[0][0]; //new RequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", VersionRange.emptyRange, null, false, false, false)}};
 		pp1 = createIUPatch("PP", new Version("1.0.0"), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, ITouchpointType.NONE, NO_TP_DATA, false, null, new IRequirementChange[] {changeY}, scopePP, null);
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest7b.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest7b.java
index ae181fb..a39c5f3 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest7b.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest7b.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -48,11 +50,11 @@ public class PatchTest7b extends AbstractProvisioningTest {
 		req[0] = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", new VersionRange("[1.0.0, 1.1.0)"), null, false, true);
 		f1 = createIU("F", new Version(1, 0, 0), req);
 
-		IRequirementChange changeX = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "X", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "X", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange changeX = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "X", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "X", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		IRequiredCapability[][] scope = new IRequiredCapability[0][0]; //new RequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false, false)}};
 		p1 = createIUPatch("P", new Version("1.0.0"), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, ITouchpointType.NONE, NO_TP_DATA, false, null, new IRequirementChange[] {changeX}, scope, null);
 
-		IRequirementChange changeY = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "Y", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "Y", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange changeY = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "Y", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "Y", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		IRequiredCapability[][] scopePP = new IRequiredCapability[0][0]; //new RequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", VersionRange.emptyRange, null, false, false, false)}};
 		pp1 = createIUPatch("PP", new Version("1.0.0"), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, ITouchpointType.NONE, NO_TP_DATA, false, null, new IRequirementChange[] {changeY}, scopePP, null);
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest8.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest8.java
index be09d16..83e0199 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest8.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest8.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -46,11 +48,11 @@ public class PatchTest8 extends AbstractProvisioningTest {
 		req[2] = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", new VersionRange("[2.0.0, 3.1.0)"), null, false, true);
 		f1 = createIU("F", new Version(1, 0, 0), req);
 
-		IRequirementChange changeA = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[2.0.0, 3.0.0)"), null, false, false, true));
+		IRequirementChange changeA = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[2.0.0, 3.0.0)"), null, false, false, true));
 		IRequiredCapability[][] scope = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "F", VersionRange.emptyRange, null, false, false, false)}};
 		p1 = createIUPatch("P", new Version("1.0.0"), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, ITouchpointType.NONE, NO_TP_DATA, false, null, new IRequirementChange[] {changeA}, scope, null);
 
-		IRequirementChange changeB = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[2.0.0, 3.0.0)"), null, false, false, true));
+		IRequirementChange changeB = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[2.0.0, 3.0.0)"), null, false, false, true));
 		IRequiredCapability[][] scopePP = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "F", VersionRange.emptyRange, null, false, false, false)}};
 		r1 = createIUPatch("R", new Version("1.0.0"), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, ITouchpointType.NONE, NO_TP_DATA, false, null, new IRequirementChange[] {changeB}, scopePP, null);
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest9.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest9.java
index 78893a2..47b4a43 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest9.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest9.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -35,11 +37,11 @@ public class PatchTest9 extends AbstractProvisioningTest {
 		b1 = createIU("B", new Version(1, 0, 0), true);
 		b2 = createIU("B", new Version(1, 2, 0), true);
 		c1 = createIU("C", new Version(1, 0, 0), true);
-		IRequirementChange changeB = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
-		IRequirementChange changeC = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange changeB = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirementChange changeC = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
 		p1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {changeB, changeC}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
-		IRequirementChange anotherChangeC = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", new VersionRange("[1.1.0, 1.3.0)"), null, true, false, true));
+		IRequirementChange anotherChangeC = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "C", new VersionRange("[1.1.0, 1.3.0)"), null, true, false, true));
 		pp1 = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {changeB, anotherChangeC}, new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, null);
 
 		createTestMetdataRepository(new IInstallableUnit[] {a1, b1, b2, c1, p1, pp1});
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestMultiplePatch.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestMultiplePatch.java
index f22f9d0..2199e27 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestMultiplePatch.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestMultiplePatch.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.IPlanner;
@@ -44,12 +46,12 @@ public class PatchTestMultiplePatch extends AbstractProvisioningTest {
 		p2b = createIU(P2, new Version(1, 1, 1), true);
 		p3 = createIU(P3, new Version(1, 0, 0), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0,1.0.0]"), null, false, false)}};
 		pp1 = createIUPatch(PP1, new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
 
-		IRequirementChange changepp2 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp2 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false)}};
 		pp2 = createIUPatch(PP2, new Version("5.0.0"), true, new IRequirementChange[] {changepp2}, scopepp2, lifeCyclepp2);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional.java
index 3cdc142..8fd0656 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.IPlanner;
@@ -39,7 +41,7 @@ public class PatchTestOptional extends AbstractProvisioningTest {
 		p1b = createIU(P1, new Version(1, 1, 1), true);
 		p2b = createIU(P2, new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, true, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, true, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0,1.0.0]"), null, false, false)}};
 		pp1 = createIUPatch(PP1, new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional2.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional2.java
index 208b268..ffdd0d8 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional2.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional2.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.IPlanner;
@@ -37,7 +39,7 @@ public class PatchTestOptional2 extends AbstractProvisioningTest {
 		p2 = createIU(P2, new Version(1, 0, 0), true);
 		p2b = createIU(P2, new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, true, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, true, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0,1.0.0]"), null, false, false)}};
 		pp1 = createIUPatch(PP1, new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional3.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional3.java
index 5163a70..d2f6e70 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional3.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestOptional3.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.IPlanner;
@@ -38,8 +40,8 @@ public class PatchTestOptional3 extends AbstractProvisioningTest {
 		p2 = createIU(P2, new Version(1, 0, 0), true);
 		p2b = createIU(P2, new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, true, false, true));
-		IRequirementChange changepp2 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, true, false, true));
+		IRequirementChange changepp2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0,1.0.0]"), null, false, false)}};
 		pp1 = createIUPatch(PP1, new Version("3.0.0"), true, new IRequirementChange[] {changepp1, changepp2}, scopepp1, lifeCyclepp1);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUninstall.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUninstall.java
index a9897c0..11c4ae2 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUninstall.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUninstall.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -42,12 +44,12 @@ public class PatchTestUninstall extends AbstractProvisioningTest {
 		p1b = createIU(P1, new Version(1, 1, 1), true);
 		p2b = createIU(P2, new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0,1.0.0]"), null, false, false)}};
 		pp1 = createIUPatch(PP1, new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
 
-		IRequirementChange changepp2 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp2 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false)}};
 		pp2 = createIUPatch(PP2, new Version("5.0.0"), true, new IRequirementChange[] {changepp2}, scopepp2, lifeCyclepp2);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate.java
index 863d54b..f099c2c 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -43,12 +45,12 @@ public class PatchTestUpdate extends AbstractProvisioningTest {
 		p1b = createIU(P1, new Version(1, 1, 1), true);
 		p2b = createIU(P2, new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0,1.0.0]"), null, false, false)}};
 		pp1 = createIUPatch(PP1, new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
 
-		IRequirementChange changepp2 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp2 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false)}};
 		pp2 = createIUPatch(PP2, new Version("5.0.0"), true, new IRequirementChange[] {changepp2}, scopepp2, lifeCyclepp2);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate2.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate2.java
index ab438d2..64d23ad 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate2.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate2.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -42,12 +44,12 @@ public class PatchTestUpdate2 extends AbstractProvisioningTest {
 		p1b = createIU(P1, new Version(1, 1, 1), true);
 		p2b = createIU(P2, new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0,1.0.0]"), null, false, false)}};
 		pp1 = createIUPatch(PP1, new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
 
-		IRequirementChange changepp2 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp2 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false)}};
 		pp2 = createIUPatch(PP2, new Version("5.0.0"), true, new IRequirementChange[] {changepp2}, scopepp2, lifeCyclepp2);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate3.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate3.java
index a375296..cbf1825 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate3.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate3.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -42,12 +44,12 @@ public class PatchTestUpdate3 extends AbstractProvisioningTest {
 		p1b = createIU(P1, new Version(1, 1, 1), true);
 		p2b = createIU(P2, new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 3.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 3.0.0]"), null, false, false)}};
 		pp1 = createIUPatch(PP1, new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
 
-		IRequirementChange changepp2 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp2 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 1.0.0]"), null, false, false)}};
 		pp2 = createIUPatch(PP2, new Version("5.0.0"), true, new IRequirementChange[] {changepp2}, scopepp2, lifeCyclepp2);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate4.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate4.java
index 39f479a..d75f73d 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate4.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate4.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -41,7 +43,7 @@ public class PatchTestUpdate4 extends AbstractProvisioningTest {
 		p1b = createIU(P1, new Version(1, 1, 1), true);
 		p2b = createIU(P2, new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 3.0.0]"), null, false, false)}};
 		pp1 = createIUPatch(PP1, new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate5.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate5.java
index 883ad94..b746bab 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate5.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate5.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -42,7 +44,7 @@ public class PatchTestUpdate5 extends AbstractProvisioningTest {
 		p1b = createIU(P1, new Version(1, 1, 1), true);
 		p2b = createIU(P2, new Version(1, 1, 1), true);
 
-		IRequirementChange changepp1 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
+		IRequirementChange changepp1 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.1.1, 1.1.1]"), null, false, false, true));
 		IRequiredCapability lifeCyclepp1 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P1, new VersionRange("[1.0.0, 1.0.0]"), null, false, false, true);
 		IRequiredCapability[][] scopepp1 = new IRequiredCapability[][] {{MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, P2_FEATURE, new VersionRange("[1.0.0, 3.0.0]"), null, false, false)}};
 		pp1 = createIUPatch(PP1, new Version("3.0.0"), true, new IRequirementChange[] {changepp1}, scopepp1, lifeCyclepp1);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SDKPatchingTest1.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SDKPatchingTest1.java
index 37df7d7..e29a728 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SDKPatchingTest1.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SDKPatchingTest1.java
@@ -1,5 +1,7 @@
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import java.io.File;
 import java.util.ArrayList;
 import org.eclipse.core.runtime.NullProgressMonitor;
@@ -33,7 +35,7 @@ public class SDKPatchingTest1 extends AbstractProvisioningTest {
 		changeVersion(newCommon, newVersionCommon);
 		newIUs.add(MetadataFactory.createInstallableUnit(newCommon));
 
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.equinox.common", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.equinox.common", new VersionRange(newVersionCommon, true, newVersionCommon, true), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.equinox.common", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.equinox.common", new VersionRange(newVersionCommon, true, newVersionCommon, true), null, false, false, true));
 		IRequiredCapability lifeCycle = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.rcp.feature.group", new VersionRange("[3.5.0.v20081110-9E9vFtpFlN1yW2Ray4WRVBYE, 3.5.0.v20081110-9E9vFtpFlN1yW2Ray4WRVBYE]"), null, false, false, true);
 		patchInstallingCommon = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[0][0], lifeCycle);
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SDKPatchingTest2.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SDKPatchingTest2.java
index 056b0a6..4ee03b3 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SDKPatchingTest2.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SDKPatchingTest2.java
@@ -1,5 +1,7 @@
 package org.eclipse.equinox.p2.tests.planner;
 
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+
 import java.io.File;
 import java.util.ArrayList;
 import org.eclipse.core.runtime.NullProgressMonitor;
@@ -35,7 +37,7 @@ public class SDKPatchingTest2 extends AbstractProvisioningTest {
 		changeVersion(newJDTLaunching, newJDTLaunchingVersion);
 		newIUs.add(MetadataFactory.createInstallableUnit(newJDTLaunching));
 
-		IRequirementChange change = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.jdt.launching", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.jdt.launching", new VersionRange(newJDTLaunchingVersion, true, newJDTLaunchingVersion, true), null, false, false, true));
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.jdt.launching", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.jdt.launching", new VersionRange(newJDTLaunchingVersion, true, newJDTLaunchingVersion, true), null, false, false, true));
 		IRequiredCapability lifeCycle = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.jdt.feature.group", new VersionRange("[3.5.0.v20081202-0800-7p83FGDFHmHuj2mNpJBSKZe, 3.5.0.v20081202-0800-7p83FGDFHmHuj2mNpJBSKZe]"), null, false, false, true);
 		patchInstallingJDTLaunching = createIUPatch("P", new Version("1.0.0"), true, new IRequirementChange[] {change}, new IRequiredCapability[0][0], lifeCycle);
 
@@ -47,7 +49,7 @@ public class SDKPatchingTest2 extends AbstractProvisioningTest {
 		changeVersion(newDebugUI, newDebugVersion);
 		newIUs.add(MetadataFactory.createInstallableUnit(newDebugUI));
 
-		IRequirementChange change2 = new RequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.jdt.debug.ui", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.jdt.debug.ui", new VersionRange(newDebugVersion, true, newDebugVersion, true), null, false, false, true));
+		IRequirementChange change2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.jdt.debug.ui", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.jdt.debug.ui", new VersionRange(newDebugVersion, true, newDebugVersion, true), null, false, false, true));
 		IRequiredCapability lifeCycle2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "org.eclipse.jdt.feature.group", new VersionRange("[3.5.0.v20081202-0800-7p83FGDFHmHuj2mNpJBSKZe, 3.5.0.v20081202-0800-7p83FGDFHmHuj2mNpJBSKZe]"), null, false, false, true);
 		patchInstallingDebugUI = createIUPatch("P2", new Version("1.0.0"), true, new IRequirementChange[] {change2}, new IRequiredCapability[0][0], lifeCycle2);
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/eclipse/AddRepositoryActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/eclipse/AddRepositoryActionTest.java
index 0ff1cdd..acb49b1 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/eclipse/AddRepositoryActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/touchpoint/eclipse/AddRepositoryActionTest.java
@@ -10,6 +10,8 @@
  *******************************************************************************/
 package org.eclipse.equinox.p2.tests.touchpoint.eclipse;
 
+import org.eclipse.equinox.internal.p2.metadata.TouchpointInstruction;
+
 import java.net.URI;
 import java.util.HashMap;
 import java.util.Map;
