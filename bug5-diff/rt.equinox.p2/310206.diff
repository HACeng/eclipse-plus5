commit b3748ee2e855e58ac1d07ad02a207af6cca35a92
Author: Susan Franklin <sfranklin>
Date:   Thu Apr 22 22:51:29 2010 +0000

    Bug 310206 -  [ui] how and when does UI make use of ProvisioningContext repo referencing?

1	1	bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
1	0	bundles/org.eclipse.equinox.p2.operations/META-INF/MANIFEST.MF
25	0	bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/IFailedStatusEvaluator.java
13	12	bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/PlannerResolutionJob.java
2	2	bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/SearchForUpdatesResolutionJob.java
28	10	bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/InstallOperation.java
7	3	bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/ProfileChangeOperation.java
8	4	bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/UninstallOperation.java
1	1	bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/UpdateOperation.java
3	3	bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/AllTests.java
94	0	bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/InstallOperationTests.java
0	41	bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/InstallerPlanTest.java
51	0	bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UninstallOperationTests.java
0	51	bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UninstallTest.java
202	0	bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UpdateOperationTests.java
0	202	bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UpdatePlanning.java
diff --git a/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
index c12c926..a9490e1 100644
--- a/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
@@ -7,7 +7,7 @@ Bundle-ClassPath: .
 Bundle-Activator: org.eclipse.equinox.internal.p2.director.DirectorActivator
 Bundle-Vendor: %providerName
 Bundle-Localization: plugin
-Export-Package: org.eclipse.equinox.internal.p2.director;x-friends:="org.eclipse.equinox.p2.repository.tools,org.eclipse.pde.core",
+Export-Package: org.eclipse.equinox.internal.p2.director;x-friends:="org.eclipse.equinox.p2.repository.tools,org.eclipse.equinox.p2.operations,org.eclipse.pde.core",
  org.eclipse.equinox.internal.p2.rollback;x-internal:=true,
  org.eclipse.equinox.internal.provisional.p2.director;
   x-friends:="org.eclipse.equinox.p2.console,
diff --git a/bundles/org.eclipse.equinox.p2.operations/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.operations/META-INF/MANIFEST.MF
index c3abdaf..9acb2cc 100644
--- a/bundles/org.eclipse.equinox.p2.operations/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.operations/META-INF/MANIFEST.MF
@@ -15,6 +15,7 @@ Bundle-RequiredExecutionEnvironment: J2SE-1.5,
  CDC-1.1/Foundation-1.1
 Bundle-ActivationPolicy: lazy
 Import-Package: org.eclipse.equinox.internal.p2.core.helpers,
+ org.eclipse.equinox.internal.p2.director,
  org.eclipse.equinox.internal.p2.repository.helpers,
  org.eclipse.equinox.internal.provisional.configurator,
  org.eclipse.equinox.internal.provisional.p2.core.eventbus,
diff --git a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/IFailedStatusEvaluator.java b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/IFailedStatusEvaluator.java
new file mode 100644
index 0000000..3c47f24
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/IFailedStatusEvaluator.java
@@ -0,0 +1,25 @@
+/*******************************************************************************
+ *  Copyright (c) 2010 IBM Corporation and others.
+ *  All rights reserved. This program and the accompanying materials
+ *  are made available under the terms of the Eclipse Public License v1.0
+ *  which accompanies this distribution, and is available at
+ *  http://www.eclipse.org/legal/epl-v10.html
+ * 
+ *  Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.operations;
+
+import org.eclipse.equinox.p2.engine.IProvisioningPlan;
+import org.eclipse.equinox.p2.engine.ProvisioningContext;
+
+/**
+ * IFailedStatusEvaluator determines what to do (if anything)
+ * when a profile change cannot be resolved successfully.
+ * 
+ * @since 2.0
+ * @noimplement This interface is not intended to be implemented by clients.
+ */
+public interface IFailedStatusEvaluator {
+	public ProvisioningContext getSecondPassProvisioningContext(IProvisioningPlan failedPlan);
+}
diff --git a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/PlannerResolutionJob.java b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/PlannerResolutionJob.java
index 823534e..f083b2b 100644
--- a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/PlannerResolutionJob.java
+++ b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/PlannerResolutionJob.java
@@ -29,21 +29,22 @@ public class PlannerResolutionJob extends ProvisioningJob implements IProfileCha
 	IProvisioningPlan plan;
 	MultiStatus additionalStatus;
 	ResolutionResult report;
-	ProvisioningContext firstPass, secondPass, successful;
+	ProvisioningContext firstPass, successful;
+	IFailedStatusEvaluator evaluator;
 
 	public static MultiStatus getProfileChangeRequestAlteredStatus() {
 		return PlanAnalyzer.getProfileChangeAlteredStatus();
 	}
 
-	public PlannerResolutionJob(String label, ProvisioningSession session, String profileId, ProfileChangeRequest request, ProvisioningContext firstPass, ProvisioningContext secondPass, MultiStatus additionalStatus) {
+	public PlannerResolutionJob(String label, ProvisioningSession session, String profileId, ProfileChangeRequest request, ProvisioningContext context, IFailedStatusEvaluator evaluator, MultiStatus additionalStatus) {
 		super(label, session);
 		this.request = request;
 		this.profileId = profileId;
-		if (firstPass == null)
-			this.firstPass = new ProvisioningContext(session.getProvisioningAgent());
+		if (context == null)
+			firstPass = new ProvisioningContext(session.getProvisioningAgent());
 		else
-			this.firstPass = firstPass;
-		this.secondPass = secondPass;
+			firstPass = context;
+		this.evaluator = evaluator;
 		Assert.isNotNull(additionalStatus);
 		this.additionalStatus = additionalStatus;
 	}
@@ -64,13 +65,9 @@ public class PlannerResolutionJob extends ProvisioningJob implements IProfileCha
 		this.firstPass = firstPass;
 	}
 
-	public void setSecondPassProvisioningContext(ProvisioningContext secondPass) {
-		this.secondPass = firstPass;
-	}
-
 	public IStatus runModal(IProgressMonitor monitor) {
 		SubMonitor sub;
-		if (secondPass != null) {
+		if (evaluator != null) {
 			sub = SubMonitor.convert(monitor, 1000);
 		} else {
 			sub = SubMonitor.convert(monitor, 500);
@@ -84,12 +81,16 @@ public class PlannerResolutionJob extends ProvisioningJob implements IProfileCha
 			status = plan.getStatus();
 		}
 
-		if (status.getSeverity() != IStatus.ERROR || secondPass == null) {
+		if (status.getSeverity() != IStatus.ERROR || evaluator == null) {
 			successful = firstPass;
 			return status;
 		}
 
 		// First resolution was in error, try again with an alternate provisioning context
+		ProvisioningContext secondPass = evaluator.getSecondPassProvisioningContext(plan);
+		if (secondPass == null)
+			return status;
+
 		successful = secondPass;
 		plan = ((IPlanner) getSession().getProvisioningAgent().getService(IPlanner.SERVICE_NAME)).getProvisioningPlan(request, secondPass, sub.newChild(500));
 		if (plan == null) {
diff --git a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/SearchForUpdatesResolutionJob.java b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/SearchForUpdatesResolutionJob.java
index ef99f08..d60e9b3 100644
--- a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/SearchForUpdatesResolutionJob.java
+++ b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/internal/p2/operations/SearchForUpdatesResolutionJob.java
@@ -24,8 +24,8 @@ public class SearchForUpdatesResolutionJob extends PlannerResolutionJob {
 	ProfileChangeRequest[] requestHolder;
 	UpdateOperation operation;
 
-	public SearchForUpdatesResolutionJob(String label, ProvisioningSession session, String profileId, ProfileChangeRequest request, ProvisioningContext firstPass, ProvisioningContext secondPass, MultiStatus additionalStatus, IRunnableWithProgress searchForUpdatesRunnable, ProfileChangeRequest[] requestHolder, UpdateOperation operation) {
-		super(label, session, profileId, request, firstPass, secondPass, additionalStatus);
+	public SearchForUpdatesResolutionJob(String label, ProvisioningSession session, String profileId, ProfileChangeRequest request, ProvisioningContext context, IFailedStatusEvaluator evaluator, MultiStatus additionalStatus, IRunnableWithProgress searchForUpdatesRunnable, ProfileChangeRequest[] requestHolder, UpdateOperation operation) {
+		super(label, session, profileId, request, context, evaluator, additionalStatus);
 		this.searchForUpdatesRunnable = searchForUpdatesRunnable;
 		this.requestHolder = requestHolder;
 		this.operation = operation;
diff --git a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/InstallOperation.java b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/InstallOperation.java
index 97113f6..0da9c62 100644
--- a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/InstallOperation.java
+++ b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/InstallOperation.java
@@ -14,10 +14,10 @@ package org.eclipse.equinox.p2.operations;
 
 import java.util.Collection;
 import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.p2.operations.*;
-import org.eclipse.equinox.internal.provisional.p2.director.ProfileChangeRequest;
-import org.eclipse.equinox.p2.engine.IProfile;
-import org.eclipse.equinox.p2.engine.ProvisioningContext;
+import org.eclipse.equinox.internal.provisional.p2.director.*;
+import org.eclipse.equinox.p2.engine.*;
 import org.eclipse.equinox.p2.engine.query.UserVisibleRootQuery;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.p2.planner.ProfileInclusionRules;
@@ -46,7 +46,6 @@ import org.eclipse.equinox.p2.query.QueryUtil;
 public class InstallOperation extends ProfileChangeOperation {
 
 	private Collection<IInstallableUnit> toInstall;
-	private static final String CUSTOM_PROVISIONING_CONTEXT_MARKER = "org.eclipse.equinox.p2.operations.customContext"; //$NON-NLS-1$
 
 	/**
 	 * Create an install operation on the specified provisioning session that installs
@@ -147,12 +146,31 @@ public class InstallOperation extends ProfileChangeOperation {
 	}
 
 	@Override
-	ProvisioningContext getSecondPassProvisioningContext() {
-		// If we were already contacting all sites, then let's go ahead
-		// and follow references if the first try fails
-		if (context.getProperty(CUSTOM_PROVISIONING_CONTEXT_MARKER) == null) {
-			context.setProperty(ProvisioningContext.FOLLOW_REPOSITORY_REFERENCES, Boolean.toString(true));
-		}
+	ProvisioningContext getFirstPassProvisioningContext() {
+		// Set it back to no referencing for first pass in case we reuse this context.
+		context.setProperty(ProvisioningContext.FOLLOW_REPOSITORY_REFERENCES, null);
 		return context;
 	}
+
+	@Override
+	IFailedStatusEvaluator getSecondPassEvaluator() {
+		return new IFailedStatusEvaluator() {
+			public ProvisioningContext getSecondPassProvisioningContext(IProvisioningPlan failedPlan) {
+				// Follow metadata repository references if the first try fails
+				// There should be real API for this!
+				if (missingRequirement(failedPlan))
+					context.setProperty(ProvisioningContext.FOLLOW_REPOSITORY_REFERENCES, Boolean.toString(true));
+				return context;
+			}
+		};
+	}
+
+	// this is very reachy
+	private boolean missingRequirement(IProvisioningPlan failedPlan) {
+		IStatus status = failedPlan.getStatus();
+		RequestStatus requestStatus = null;
+		if (status instanceof PlannerStatus)
+			requestStatus = ((PlannerStatus) status).getRequestStatus();
+		return requestStatus != null && requestStatus.getShortExplanation() == Explanation.MISSING_REQUIREMENT;
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/ProfileChangeOperation.java b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/ProfileChangeOperation.java
index 65b2ba6..63ed0e2 100644
--- a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/ProfileChangeOperation.java
+++ b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/ProfileChangeOperation.java
@@ -178,7 +178,7 @@ public abstract class ProfileChangeOperation implements IProfileChangeJob {
 	protected abstract void computeProfileChangeRequest(MultiStatus status, IProgressMonitor monitor);
 
 	private void createPlannerResolutionJob() {
-		job = new PlannerResolutionJob(getResolveJobName(), session, profileId, request, getFirstPassProvisioningContext(), getSecondPassProvisioningContext(), noChangeRequest);
+		job = new PlannerResolutionJob(getResolveJobName(), session, profileId, request, getFirstPassProvisioningContext(), getSecondPassEvaluator(), noChangeRequest);
 	}
 
 	/**
@@ -368,8 +368,12 @@ public abstract class ProfileChangeOperation implements IProfileChangeJob {
 		return getProvisioningContext();
 	}
 
-	ProvisioningContext getSecondPassProvisioningContext() {
-		return null;
+	IFailedStatusEvaluator getSecondPassEvaluator() {
+		return new IFailedStatusEvaluator() {
+			public ProvisioningContext getSecondPassProvisioningContext(IProvisioningPlan failedPlan) {
+				return null;
+			}
+		};
 	}
 
 	protected void updateJobProvisioningContexts(PlannerResolutionJob job, ProvisioningContext context) {
diff --git a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/UninstallOperation.java b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/UninstallOperation.java
index d0bebec..45a0f03 100644
--- a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/UninstallOperation.java
+++ b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/UninstallOperation.java
@@ -16,10 +16,10 @@ import java.net.URI;
 import java.util.Collection;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.MultiStatus;
+import org.eclipse.equinox.internal.p2.operations.IFailedStatusEvaluator;
 import org.eclipse.equinox.internal.p2.operations.Messages;
 import org.eclipse.equinox.internal.provisional.p2.director.ProfileChangeRequest;
-import org.eclipse.equinox.p2.engine.IProfile;
-import org.eclipse.equinox.p2.engine.ProvisioningContext;
+import org.eclipse.equinox.p2.engine.*;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
 
 /**
@@ -96,7 +96,11 @@ public class UninstallOperation extends ProfileChangeOperation {
 	}
 
 	@Override
-	ProvisioningContext getSecondPassProvisioningContext() {
-		return context;
+	IFailedStatusEvaluator getSecondPassEvaluator() {
+		return new IFailedStatusEvaluator() {
+			public ProvisioningContext getSecondPassProvisioningContext(IProvisioningPlan failedPlan) {
+				return context;
+			}
+		};
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/UpdateOperation.java b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/UpdateOperation.java
index d306cde..03fee84 100644
--- a/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/UpdateOperation.java
+++ b/bundles/org.eclipse.equinox.p2.operations/src/org/eclipse/equinox/p2/operations/UpdateOperation.java
@@ -316,7 +316,7 @@ public class UpdateOperation extends ProfileChangeOperation {
 		// for the resolution job to get the request from the operation after it has been
 		// computed.
 		final ProfileChangeRequest[] requestHolder = new ProfileChangeRequest[1];
-		job = new SearchForUpdatesResolutionJob(getResolveJobName(), session, profileId, request, getFirstPassProvisioningContext(), getSecondPassProvisioningContext(), noChangeRequest, new IRunnableWithProgress() {
+		job = new SearchForUpdatesResolutionJob(getResolveJobName(), session, profileId, request, getFirstPassProvisioningContext(), getSecondPassEvaluator(), noChangeRequest, new IRunnableWithProgress() {
 			public void run(IProgressMonitor mon) throws OperationCanceledException {
 				// We only check for other jobs running if this job is *not* scheduled
 				if (job.getState() == Job.NONE && session.hasScheduledOperationsFor(profileId)) {
diff --git a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/AllTests.java b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/AllTests.java
index d79be13..2b76647 100644
--- a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/AllTests.java
+++ b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/AllTests.java
@@ -20,9 +20,9 @@ public class AllTests extends TestCase {
 	public static Test suite() {
 		TestSuite suite = new TestSuite(AllTests.class.getName());
 		suite.addTestSuite(SizingTest.class);
-		suite.addTestSuite(InstallerPlanTest.class);
-		suite.addTestSuite(UpdatePlanning.class);
-		suite.addTestSuite(UninstallTest.class);
+		suite.addTestSuite(InstallOperationTests.class);
+		suite.addTestSuite(UpdateOperationTests.class);
+		suite.addTestSuite(UninstallOperationTests.class);
 		return suite;
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/InstallOperationTests.java b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/InstallOperationTests.java
new file mode 100644
index 0000000..fc0c29e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/InstallOperationTests.java
@@ -0,0 +1,94 @@
+/*******************************************************************************
+ *  Copyright (c) 2010 IBM Corporation and others.
+ *  All rights reserved. This program and the accompanying materials
+ *  are made available under the terms of the Eclipse Public License v1.0
+ *  which accompanies this distribution, and is available at
+ *  http://www.eclipse.org/legal/epl-v10.html
+ * 
+ *  Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.tests.ui.operations;
+
+import java.net.URI;
+import java.util.Collections;
+import java.util.Set;
+import org.eclipse.core.runtime.OperationCanceledException;
+import org.eclipse.equinox.p2.core.ProvisionException;
+import org.eclipse.equinox.p2.engine.ProvisioningContext;
+import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.operations.InstallOperation;
+import org.eclipse.equinox.p2.query.QueryUtil;
+import org.eclipse.equinox.p2.repository.IRepository;
+import org.eclipse.equinox.p2.repository.metadata.IMetadataRepository;
+import org.eclipse.equinox.p2.repository.spi.RepositoryReference;
+import org.eclipse.equinox.p2.tests.ui.AbstractProvisioningUITest;
+
+/**
+ * Tests various aspects of install operations
+ */
+public class InstallOperationTests extends AbstractProvisioningUITest {
+	public void testInstallerPlan() throws ProvisionException {
+		URI uri = getTestData("InstallHandler", "testData/installPlan").toURI();
+		Set<IInstallableUnit> ius = getMetadataRepositoryManager().loadRepository(uri, getMonitor()).query(QueryUtil.createIUQuery("A"), getMonitor()).toSet();
+		assertTrue("One IU", ius.size() == 1);
+		InstallOperation op = new InstallOperation(getSession(), ius);
+		op.setProfileId(TESTPROFILE);
+		ProvisioningContext pc = new ProvisioningContext(getAgent());
+		pc.setArtifactRepositories(new URI[] {uri});
+		pc.setMetadataRepositories(new URI[] {uri});
+		op.setProvisioningContext(pc);
+		assertTrue("Should resolve", op.resolveModal(getMonitor()).isOK());
+		assertTrue("Should install", op.getProvisioningJob(null).runModal(getMonitor()).isOK());
+		assertFalse("Action1 should have been installed", getProfile(TESTPROFILE).query(QueryUtil.createIUQuery("Action1"), getMonitor()).isEmpty());
+	}
+
+	public void testDetectMissingRequirement() throws ProvisionException, OperationCanceledException {
+		URI uriA, uriB, uriC;
+		IMetadataRepository repoA, repoB, repoC;
+		String testDataFileLocation = "testData/provisioningContextTests/";
+		uriA = getTestData("A", testDataFileLocation + "A").toURI();
+		uriB = getTestData("B", testDataFileLocation + "B").toURI();
+		uriC = getTestData("C", testDataFileLocation + "C").toURI();
+
+		repoA = getMetadataRepositoryManager().loadRepository(uriA, getMonitor());
+		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=305565
+		repoA.addReferences(Collections.singletonList(new RepositoryReference(uriA, null, IRepository.TYPE_ARTIFACT, IRepository.ENABLED)));
+
+		// now create a second set of repos and refer from the first
+		repoB = getMetadataRepositoryManager().loadRepository(uriB, getMonitor());
+		repoB.addReferences(Collections.singletonList(new RepositoryReference(uriB, null, IRepository.TYPE_ARTIFACT, IRepository.ENABLED)));
+		repoA.addReferences(Collections.singletonList(new RepositoryReference(repoB.getLocation(), null, IRepository.TYPE_METADATA, IRepository.ENABLED)));
+
+		// this repo is referred by the previous one
+		repoC = getMetadataRepositoryManager().loadRepository(uriC, getMonitor());
+		repoC.addReferences(Collections.singletonList(new RepositoryReference(uriC, null, IRepository.TYPE_ARTIFACT, IRepository.ENABLED)));
+		repoB.addReferences(Collections.singletonList(new RepositoryReference(repoC.getLocation(), null, IRepository.TYPE_METADATA, IRepository.ENABLED)));
+
+		String id = "TestProfileIDForMissingRequirement";
+		createProfile(id);
+		ProvisioningContext context = new ProvisioningContext(getAgent());
+		context.setMetadataRepositories(new URI[] {repoA.getLocation()});
+		context.setArtifactRepositories(new URI[0]);
+		IInstallableUnit[] units = repoA.query(QueryUtil.createIUQuery("A"), getMonitor()).toArray(IInstallableUnit.class);
+		assertTrue("should find A in main repo", units.length > 0);
+
+		// NOW WE CAN TEST!
+		assertNull("ProvisioningContext does not follow by default", context.getProperty(ProvisioningContext.FOLLOW_REPOSITORY_REFERENCES));
+
+		InstallOperation op = new InstallOperation(getSession(), Collections.singleton(units[0]));
+		op.setProvisioningContext(context);
+		op.setProfileId(id);
+		assertTrue("Should resolve", op.resolveModal(getMonitor()).isOK());
+
+		assertNotNull("Context was reset to follow", context.getProperty(ProvisioningContext.FOLLOW_REPOSITORY_REFERENCES));
+
+		getArtifactRepositoryManager().removeRepository(uriA);
+		getArtifactRepositoryManager().removeRepository(uriB);
+		getArtifactRepositoryManager().removeRepository(uriC);
+		getMetadataRepositoryManager().removeRepository(uriA);
+		getMetadataRepositoryManager().removeRepository(uriB);
+		getMetadataRepositoryManager().removeRepository(uriC);
+
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/InstallerPlanTest.java b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/InstallerPlanTest.java
deleted file mode 100644
index 6f2b9f1..0000000
--- a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/InstallerPlanTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*******************************************************************************
- *  Copyright (c) 2010 IBM Corporation and others.
- *  All rights reserved. This program and the accompanying materials
- *  are made available under the terms of the Eclipse Public License v1.0
- *  which accompanies this distribution, and is available at
- *  http://www.eclipse.org/legal/epl-v10.html
- * 
- *  Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.tests.ui.operations;
-
-import java.net.URI;
-import java.util.Set;
-import org.eclipse.equinox.p2.core.ProvisionException;
-import org.eclipse.equinox.p2.engine.ProvisioningContext;
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.operations.InstallOperation;
-import org.eclipse.equinox.p2.query.QueryUtil;
-import org.eclipse.equinox.p2.tests.ui.AbstractProvisioningUITest;
-
-/**
- * Tests for the ability to install an IU that has an installer plan by
- * using the operation API.
- */
-public class InstallerPlanTest extends AbstractProvisioningUITest {
-	public void testInstallerPlan() throws ProvisionException {
-		URI uri = getTestData("InstallHandler", "testData/installPlan").toURI();
-		Set<IInstallableUnit> ius = getMetadataRepositoryManager().loadRepository(uri, getMonitor()).query(QueryUtil.createIUQuery("A"), getMonitor()).toSet();
-		assertTrue("One IU", ius.size() == 1);
-		InstallOperation op = new InstallOperation(getSession(), ius);
-		op.setProfileId(TESTPROFILE);
-		ProvisioningContext pc = new ProvisioningContext(getAgent());
-		pc.setArtifactRepositories(new URI[] {uri});
-		pc.setMetadataRepositories(new URI[] {uri});
-		op.setProvisioningContext(pc);
-		assertTrue("Should resolve", op.resolveModal(getMonitor()).isOK());
-		assertTrue("Should install", op.getProvisioningJob(null).runModal(getMonitor()).isOK());
-		assertFalse("Action1 should have been installed", getProfile(TESTPROFILE).query(QueryUtil.createIUQuery("Action1"), getMonitor()).isEmpty());
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UninstallOperationTests.java b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UninstallOperationTests.java
new file mode 100644
index 0000000..76b3f40
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UninstallOperationTests.java
@@ -0,0 +1,51 @@
+/*******************************************************************************
+ *  Copyright (c) 2010 IBM Corporation and others.
+ *  All rights reserved. This program and the accompanying materials
+ *  are made available under the terms of the Eclipse Public License v1.0
+ *  which accompanies this distribution, and is available at
+ *  http://www.eclipse.org/legal/epl-v10.html
+ * 
+ *  Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.tests.ui.operations;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.HashSet;
+import org.eclipse.equinox.p2.core.ProvisionException;
+import org.eclipse.equinox.p2.engine.ProvisioningContext;
+import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.metadata.expression.ExpressionUtil;
+import org.eclipse.equinox.p2.operations.UninstallOperation;
+import org.eclipse.equinox.p2.query.*;
+import org.eclipse.equinox.p2.repository.artifact.IArtifactRepository;
+import org.eclipse.equinox.p2.tests.ui.AbstractProvisioningUITest;
+
+/**
+ * Tests for the ability to install an IU that has an installer plan by
+ * using the operation API.
+ */
+public class UninstallOperationTests extends AbstractProvisioningUITest {
+	public void testUninstallContactsNoRepositories() throws ProvisionException, URISyntaxException {
+
+		HashSet<IInstallableUnit> ius = new HashSet<IInstallableUnit>();
+		ius.add(top1);
+		UninstallOperation op = new UninstallOperation(getSession(), ius);
+		// We set the provisioning context to the same one we use for install
+		ProvisioningContext pc = new ProvisioningContext(getAgent());
+		pc.setArtifactRepositories(new URI[] {testRepoLocation});
+		pc.setMetadataRepositories(new URI[] {testRepoLocation});
+		op.setProvisioningContext(pc);
+		op.setProfileId(TESTPROFILE);
+		assertTrue("Should resolve", op.resolveModal(getMonitor()).isOK());
+
+		// The provisioning context actually used should have nothing (because the first pass is to try with no repos)
+		pc = op.getProvisioningPlan().getContext();
+		IQueryable<IInstallableUnit> queryable = pc.getMetadata(getMonitor());
+		assertTrue("metadata queryable should be empty", queryable.query(QueryUtil.ALL_UNITS, getMonitor()).isEmpty());
+		IQueryable<IArtifactRepository> artifactQueryable = pc.getArtifactRepositories(getMonitor());
+		IQuery<IArtifactRepository> all = new ExpressionMatchQuery<IArtifactRepository>(IArtifactRepository.class, ExpressionUtil.TRUE_EXPRESSION);
+		assertTrue("artifact queryable should be empty", artifactQueryable.query(all, getMonitor()).isEmpty());
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UninstallTest.java b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UninstallTest.java
deleted file mode 100644
index 6622e78..0000000
--- a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UninstallTest.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*******************************************************************************
- *  Copyright (c) 2010 IBM Corporation and others.
- *  All rights reserved. This program and the accompanying materials
- *  are made available under the terms of the Eclipse Public License v1.0
- *  which accompanies this distribution, and is available at
- *  http://www.eclipse.org/legal/epl-v10.html
- * 
- *  Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.tests.ui.operations;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.HashSet;
-import org.eclipse.equinox.p2.core.ProvisionException;
-import org.eclipse.equinox.p2.engine.ProvisioningContext;
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.expression.ExpressionUtil;
-import org.eclipse.equinox.p2.operations.UninstallOperation;
-import org.eclipse.equinox.p2.query.*;
-import org.eclipse.equinox.p2.repository.artifact.IArtifactRepository;
-import org.eclipse.equinox.p2.tests.ui.AbstractProvisioningUITest;
-
-/**
- * Tests for the ability to install an IU that has an installer plan by
- * using the operation API.
- */
-public class UninstallTest extends AbstractProvisioningUITest {
-	public void testUninstallContactsNoRepositories() throws ProvisionException, URISyntaxException {
-
-		HashSet<IInstallableUnit> ius = new HashSet<IInstallableUnit>();
-		ius.add(top1);
-		UninstallOperation op = new UninstallOperation(getSession(), ius);
-		// We set the provisioning context to the same one we use for install
-		ProvisioningContext pc = new ProvisioningContext(getAgent());
-		pc.setArtifactRepositories(new URI[] {testRepoLocation});
-		pc.setMetadataRepositories(new URI[] {testRepoLocation});
-		op.setProvisioningContext(pc);
-		op.setProfileId(TESTPROFILE);
-		assertTrue("Should resolve", op.resolveModal(getMonitor()).isOK());
-
-		// The provisioning context actually used should have nothing (because the first pass is to try with no repos)
-		pc = op.getProvisioningPlan().getContext();
-		IQueryable<IInstallableUnit> queryable = pc.getMetadata(getMonitor());
-		assertTrue("metadata queryable should be empty", queryable.query(QueryUtil.ALL_UNITS, getMonitor()).isEmpty());
-		IQueryable<IArtifactRepository> artifactQueryable = pc.getArtifactRepositories(getMonitor());
-		IQuery<IArtifactRepository> all = new ExpressionMatchQuery<IArtifactRepository>(IArtifactRepository.class, ExpressionUtil.TRUE_EXPRESSION);
-		assertTrue("artifact queryable should be empty", artifactQueryable.query(all, getMonitor()).isEmpty());
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UpdateOperationTests.java b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UpdateOperationTests.java
new file mode 100644
index 0000000..8feaa50
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UpdateOperationTests.java
@@ -0,0 +1,202 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.tests.ui.operations;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import org.eclipse.equinox.internal.p2.operations.SearchForUpdatesResolutionJob;
+import org.eclipse.equinox.internal.provisional.p2.director.ProfileChangeRequest;
+import org.eclipse.equinox.p2.core.ProvisionException;
+import org.eclipse.equinox.p2.metadata.*;
+import org.eclipse.equinox.p2.operations.*;
+import org.eclipse.equinox.p2.planner.IProfileChangeRequest;
+import org.eclipse.equinox.p2.tests.ui.AbstractProvisioningUITest;
+
+public class UpdateOperationTests extends AbstractProvisioningUITest {
+	IInstallableUnit a1, b1;
+	IInstallableUnit b12;
+	IInstallableUnit a120WithDifferentId;
+	IInstallableUnit a130;
+	IInstallableUnit a140WithDifferentId;
+	IInstallableUnitPatch firstPatchForA1, secondPatchForA1, thirdPatchForA1, patchFora2;
+
+	protected void setUp() throws Exception {
+		super.setUp();
+		a1 = createIU("A", Version.create("1.0.0"));
+		IUpdateDescriptor update = MetadataFactory.createUpdateDescriptor("A", new VersionRange("[1.0.0, 1.0.0]"), 0, "update description");
+		a120WithDifferentId = createIU("UpdateA", Version.createOSGi(1, 2, 0), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, null, NO_TP_DATA, false, update, NO_REQUIRES);
+		a130 = createIU("A", Version.createOSGi(1, 3, 0), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, null, NO_TP_DATA, false, update, NO_REQUIRES);
+		a140WithDifferentId = createIU("UpdateForA", Version.createOSGi(1, 4, 0), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, null, NO_TP_DATA, false, update, NO_REQUIRES);
+		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirement lifeCycle = MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[1.0.0, 1.0.0]"), null, false, false);
+		firstPatchForA1 = createIUPatch("P", Version.create("1.0.0"), true, new IRequirementChange[] {change}, new IRequirement[][] {{MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, lifeCycle);
+		secondPatchForA1 = createIUPatch("P", Version.create("2.0.0"), true, new IRequirementChange[] {change}, new IRequirement[][] {{MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, lifeCycle);
+		thirdPatchForA1 = createIUPatch("P2", Version.create("1.0.0"), true, new IRequirementChange[] {change}, new IRequirement[][] {{MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, lifeCycle);
+
+		IRequirementChange change2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
+		IRequirement lifeCycle2 = MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[2.0.0, 3.2.0]"), null, false, false);
+		patchFora2 = createIUPatch("P", Version.create("1.0.0"), true, new IRequirementChange[] {change2}, new IRequirement[][] {{MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, lifeCycle2);
+
+		b1 = createIU("B", Version.create("1.0.0"));
+		update = MetadataFactory.createUpdateDescriptor("B", new VersionRange("[1.0.0, 1.0.0]"), 0, "update description");
+		b12 = createIU("B", Version.createOSGi(1, 2, 0), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, null, NO_TP_DATA, false, update, NO_REQUIRES);
+		// Ensure that all versions, not just the latest, are considered by the UI
+		getPolicy().setShowLatestVersionsOnly(false);
+	}
+
+	public void testChooseUpdateOverPatch() throws ProvisionException {
+		createTestMetdataRepository(new IInstallableUnit[] {a1, a120WithDifferentId, a130, firstPatchForA1, patchFora2});
+		install(a1, true, false);
+		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
+		iusInvolved.add(a1);
+		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
+		op.resolveModal(getMonitor());
+		ProfileChangeRequest request = op.getProfileChangeRequest();
+		assertTrue("1.0", request.getAdditions().size() == 1);
+		assertTrue("1.1", request.getAdditions().iterator().next().equals(a130));
+		assertTrue("1.2", request.getRemovals().size() == 1);
+		assertTrue("1.3", request.getRemovals().iterator().next().equals(a1));
+	}
+
+	public void testForcePatchOverUpdate() throws ProvisionException {
+		createTestMetdataRepository(new IInstallableUnit[] {a1, a120WithDifferentId, a130, firstPatchForA1, patchFora2});
+		install(a1, true, false);
+		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
+		iusInvolved.add(a1);
+		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
+		op.resolveModal(getMonitor());
+		Update[] updates = op.getPossibleUpdates();
+		Update firstPatch = null;
+		for (int i = 0; i < updates.length; i++) {
+			if (updates[i].replacement.equals(firstPatchForA1)) {
+				firstPatch = updates[i];
+				break;
+			}
+		}
+		assertNotNull(".99", firstPatch);
+		op.setSelectedUpdates(new Update[] {firstPatch});
+		op.resolveModal(getMonitor());
+		ProfileChangeRequest request = op.getProfileChangeRequest();
+		assertTrue("1.0", request.getAdditions().size() == 1);
+		assertTrue("1.1", request.getAdditions().iterator().next().equals(firstPatchForA1));
+		assertTrue("1.2", request.getRemovals().size() == 0);
+	}
+
+	public void testRecognizePatchIsInstalled() throws ProvisionException {
+		createTestMetdataRepository(new IInstallableUnit[] {a1, a120WithDifferentId, a130, firstPatchForA1, patchFora2});
+		install(a1, true, false);
+		install(firstPatchForA1, true, false);
+		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
+		iusInvolved.add(a1);
+		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
+		op.resolveModal(getMonitor());
+		IProfileChangeRequest request = op.getProfileChangeRequest();
+		// update was favored, that would happen even if patch was not installed
+		assertTrue("1.0", request.getAdditions().size() == 1);
+		assertTrue("1.1", request.getAdditions().iterator().next().equals(a130));
+		// the patch is not being shown to the user because we figured out it was already installed
+		// The elements showing are a130 and a120WithDifferentId
+		assertEquals("1.2", 2, op.getPossibleUpdates().length);
+	}
+
+	public void testChooseNotTheNewest() throws ProvisionException {
+		createTestMetdataRepository(new IInstallableUnit[] {a1, a120WithDifferentId, a130, firstPatchForA1, patchFora2});
+		install(a1, true, false);
+		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
+		iusInvolved.add(a1);
+		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
+		op.resolveModal(getMonitor());
+		Update[] updates = op.getPossibleUpdates();
+		Update notNewest = null;
+		for (int i = 0; i < updates.length; i++) {
+			if (updates[i].replacement.equals(a120WithDifferentId)) {
+				notNewest = updates[i];
+				break;
+			}
+		}
+		assertNotNull(".99", notNewest);
+		op.setSelectedUpdates(new Update[] {notNewest});
+		op.resolveModal(getMonitor());
+		IProfileChangeRequest request = op.getProfileChangeRequest();
+		// selected was favored
+		assertTrue("1.0", request.getAdditions().size() == 1);
+		assertTrue("1.1", request.getAdditions().iterator().next().equals(a120WithDifferentId));
+		// The two updates and the patch were recognized
+		assertEquals("1.2", 3, op.getPossibleUpdates().length);
+	}
+
+	public void testChooseLatestPatches() throws ProvisionException {
+		createTestMetdataRepository(new IInstallableUnit[] {a1, firstPatchForA1, secondPatchForA1, thirdPatchForA1});
+		install(a1, true, false);
+		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
+		iusInvolved.add(a1);
+		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
+		op.resolveModal(getMonitor());
+		IProfileChangeRequest request = op.getProfileChangeRequest();
+		// the latest two patches were selected
+		HashSet chosen = new HashSet();
+		assertTrue("1.0", request.getAdditions().size() == 2);
+		chosen.addAll(request.getAdditions());
+		assertTrue("1.1", chosen.contains(secondPatchForA1));
+		assertTrue("1.2", chosen.contains(thirdPatchForA1));
+
+		assertEquals("1.2", 3, op.getPossibleUpdates().length);
+	}
+
+	public void testLatestHasDifferentId() throws ProvisionException {
+		createTestMetdataRepository(new IInstallableUnit[] {a1, firstPatchForA1, secondPatchForA1, thirdPatchForA1, a120WithDifferentId, a130, a140WithDifferentId});
+		install(a1, true, false);
+		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
+		iusInvolved.add(a1);
+		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
+		op.resolveModal(getMonitor());
+		IProfileChangeRequest request = op.getProfileChangeRequest();
+		// update 140 was recognized as the latest even though it had a different id
+		assertTrue("1.0", request.getAdditions().size() == 1);
+		assertTrue("1.1", request.getAdditions().iterator().next().equals(a140WithDifferentId));
+		// All three patches and all three updates can be chosen
+		assertEquals("1.2", 6, op.getPossibleUpdates().length);
+	}
+
+	// bug 300445
+	public void testRemoveSelectionAfterResolve() throws ProvisionException {
+		createTestMetdataRepository(new IInstallableUnit[] {a1, a130, b1, b12});
+		install(a1, true, false);
+		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
+		iusInvolved.add(a1);
+		iusInvolved.add(b1);
+		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
+		op.resolveModal(getMonitor());
+		Update[] updates = op.getSelectedUpdates();
+		assertEquals("1.0", 2, updates.length);
+		// choose just one
+		op.setSelectedUpdates(new Update[] {updates[0]});
+		op.resolveModal(getMonitor());
+		assertEquals("1.1", 1, op.getSelectedUpdates().length);
+	}
+
+	// bug 290858
+	public void testSearchForUpdatesInJob() throws ProvisionException {
+		createTestMetdataRepository(new IInstallableUnit[] {a1, a130, b1, b12});
+		install(a1, true, false);
+		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
+		iusInvolved.add(a1);
+		iusInvolved.add(b1);
+		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
+		ProvisioningJob job = op.getResolveJob(getMonitor());
+		assertTrue("1.0", job instanceof SearchForUpdatesResolutionJob);
+		// getting the job should not compute the request.
+		assertNull("1.1", ((SearchForUpdatesResolutionJob) job).getProfileChangeRequest());
+		job.runModal(getMonitor());
+		assertNotNull("1.2", ((SearchForUpdatesResolutionJob) job).getProfileChangeRequest());
+
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UpdatePlanning.java b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UpdatePlanning.java
deleted file mode 100644
index 5b39df8..0000000
--- a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/operations/UpdatePlanning.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2009 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.tests.ui.operations;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import org.eclipse.equinox.internal.p2.operations.SearchForUpdatesResolutionJob;
-import org.eclipse.equinox.internal.provisional.p2.director.ProfileChangeRequest;
-import org.eclipse.equinox.p2.core.ProvisionException;
-import org.eclipse.equinox.p2.metadata.*;
-import org.eclipse.equinox.p2.operations.*;
-import org.eclipse.equinox.p2.planner.IProfileChangeRequest;
-import org.eclipse.equinox.p2.tests.ui.AbstractProvisioningUITest;
-
-public class UpdatePlanning extends AbstractProvisioningUITest {
-	IInstallableUnit a1, b1;
-	IInstallableUnit b12;
-	IInstallableUnit a120WithDifferentId;
-	IInstallableUnit a130;
-	IInstallableUnit a140WithDifferentId;
-	IInstallableUnitPatch firstPatchForA1, secondPatchForA1, thirdPatchForA1, patchFora2;
-
-	protected void setUp() throws Exception {
-		super.setUp();
-		a1 = createIU("A", Version.create("1.0.0"));
-		IUpdateDescriptor update = MetadataFactory.createUpdateDescriptor("A", new VersionRange("[1.0.0, 1.0.0]"), 0, "update description");
-		a120WithDifferentId = createIU("UpdateA", Version.createOSGi(1, 2, 0), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, null, NO_TP_DATA, false, update, NO_REQUIRES);
-		a130 = createIU("A", Version.createOSGi(1, 3, 0), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, null, NO_TP_DATA, false, update, NO_REQUIRES);
-		a140WithDifferentId = createIU("UpdateForA", Version.createOSGi(1, 4, 0), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, null, NO_TP_DATA, false, update, NO_REQUIRES);
-		IRequirementChange change = MetadataFactory.createRequirementChange(MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
-		IRequirement lifeCycle = MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[1.0.0, 1.0.0]"), null, false, false);
-		firstPatchForA1 = createIUPatch("P", Version.create("1.0.0"), true, new IRequirementChange[] {change}, new IRequirement[][] {{MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, lifeCycle);
-		secondPatchForA1 = createIUPatch("P", Version.create("2.0.0"), true, new IRequirementChange[] {change}, new IRequirement[][] {{MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, lifeCycle);
-		thirdPatchForA1 = createIUPatch("P2", Version.create("1.0.0"), true, new IRequirementChange[] {change}, new IRequirement[][] {{MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, lifeCycle);
-
-		IRequirementChange change2 = MetadataFactory.createRequirementChange(MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "B", VersionRange.emptyRange, null, false, false, false), MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "B", new VersionRange("[1.1.0, 1.3.0)"), null, false, false, true));
-		IRequirement lifeCycle2 = MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", new VersionRange("[2.0.0, 3.2.0]"), null, false, false);
-		patchFora2 = createIUPatch("P", Version.create("1.0.0"), true, new IRequirementChange[] {change2}, new IRequirement[][] {{MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, "A", VersionRange.emptyRange, null, false, false)}}, lifeCycle2);
-
-		b1 = createIU("B", Version.create("1.0.0"));
-		update = MetadataFactory.createUpdateDescriptor("B", new VersionRange("[1.0.0, 1.0.0]"), 0, "update description");
-		b12 = createIU("B", Version.createOSGi(1, 2, 0), null, NO_REQUIRES, NO_PROVIDES, NO_PROPERTIES, null, NO_TP_DATA, false, update, NO_REQUIRES);
-		// Ensure that all versions, not just the latest, are considered by the UI
-		getPolicy().setShowLatestVersionsOnly(false);
-	}
-
-	public void testChooseUpdateOverPatch() throws ProvisionException {
-		createTestMetdataRepository(new IInstallableUnit[] {a1, a120WithDifferentId, a130, firstPatchForA1, patchFora2});
-		install(a1, true, false);
-		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
-		iusInvolved.add(a1);
-		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
-		op.resolveModal(getMonitor());
-		ProfileChangeRequest request = op.getProfileChangeRequest();
-		assertTrue("1.0", request.getAdditions().size() == 1);
-		assertTrue("1.1", request.getAdditions().iterator().next().equals(a130));
-		assertTrue("1.2", request.getRemovals().size() == 1);
-		assertTrue("1.3", request.getRemovals().iterator().next().equals(a1));
-	}
-
-	public void testForcePatchOverUpdate() throws ProvisionException {
-		createTestMetdataRepository(new IInstallableUnit[] {a1, a120WithDifferentId, a130, firstPatchForA1, patchFora2});
-		install(a1, true, false);
-		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
-		iusInvolved.add(a1);
-		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
-		op.resolveModal(getMonitor());
-		Update[] updates = op.getPossibleUpdates();
-		Update firstPatch = null;
-		for (int i = 0; i < updates.length; i++) {
-			if (updates[i].replacement.equals(firstPatchForA1)) {
-				firstPatch = updates[i];
-				break;
-			}
-		}
-		assertNotNull(".99", firstPatch);
-		op.setSelectedUpdates(new Update[] {firstPatch});
-		op.resolveModal(getMonitor());
-		ProfileChangeRequest request = op.getProfileChangeRequest();
-		assertTrue("1.0", request.getAdditions().size() == 1);
-		assertTrue("1.1", request.getAdditions().iterator().next().equals(firstPatchForA1));
-		assertTrue("1.2", request.getRemovals().size() == 0);
-	}
-
-	public void testRecognizePatchIsInstalled() throws ProvisionException {
-		createTestMetdataRepository(new IInstallableUnit[] {a1, a120WithDifferentId, a130, firstPatchForA1, patchFora2});
-		install(a1, true, false);
-		install(firstPatchForA1, true, false);
-		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
-		iusInvolved.add(a1);
-		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
-		op.resolveModal(getMonitor());
-		IProfileChangeRequest request = op.getProfileChangeRequest();
-		// update was favored, that would happen even if patch was not installed
-		assertTrue("1.0", request.getAdditions().size() == 1);
-		assertTrue("1.1", request.getAdditions().iterator().next().equals(a130));
-		// the patch is not being shown to the user because we figured out it was already installed
-		// The elements showing are a130 and a120WithDifferentId
-		assertEquals("1.2", 2, op.getPossibleUpdates().length);
-	}
-
-	public void testChooseNotTheNewest() throws ProvisionException {
-		createTestMetdataRepository(new IInstallableUnit[] {a1, a120WithDifferentId, a130, firstPatchForA1, patchFora2});
-		install(a1, true, false);
-		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
-		iusInvolved.add(a1);
-		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
-		op.resolveModal(getMonitor());
-		Update[] updates = op.getPossibleUpdates();
-		Update notNewest = null;
-		for (int i = 0; i < updates.length; i++) {
-			if (updates[i].replacement.equals(a120WithDifferentId)) {
-				notNewest = updates[i];
-				break;
-			}
-		}
-		assertNotNull(".99", notNewest);
-		op.setSelectedUpdates(new Update[] {notNewest});
-		op.resolveModal(getMonitor());
-		IProfileChangeRequest request = op.getProfileChangeRequest();
-		// selected was favored
-		assertTrue("1.0", request.getAdditions().size() == 1);
-		assertTrue("1.1", request.getAdditions().iterator().next().equals(a120WithDifferentId));
-		// The two updates and the patch were recognized
-		assertEquals("1.2", 3, op.getPossibleUpdates().length);
-	}
-
-	public void testChooseLatestPatches() throws ProvisionException {
-		createTestMetdataRepository(new IInstallableUnit[] {a1, firstPatchForA1, secondPatchForA1, thirdPatchForA1});
-		install(a1, true, false);
-		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
-		iusInvolved.add(a1);
-		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
-		op.resolveModal(getMonitor());
-		IProfileChangeRequest request = op.getProfileChangeRequest();
-		// the latest two patches were selected
-		HashSet chosen = new HashSet();
-		assertTrue("1.0", request.getAdditions().size() == 2);
-		chosen.addAll(request.getAdditions());
-		assertTrue("1.1", chosen.contains(secondPatchForA1));
-		assertTrue("1.2", chosen.contains(thirdPatchForA1));
-
-		assertEquals("1.2", 3, op.getPossibleUpdates().length);
-	}
-
-	public void testLatestHasDifferentId() throws ProvisionException {
-		createTestMetdataRepository(new IInstallableUnit[] {a1, firstPatchForA1, secondPatchForA1, thirdPatchForA1, a120WithDifferentId, a130, a140WithDifferentId});
-		install(a1, true, false);
-		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
-		iusInvolved.add(a1);
-		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
-		op.resolveModal(getMonitor());
-		IProfileChangeRequest request = op.getProfileChangeRequest();
-		// update 140 was recognized as the latest even though it had a different id
-		assertTrue("1.0", request.getAdditions().size() == 1);
-		assertTrue("1.1", request.getAdditions().iterator().next().equals(a140WithDifferentId));
-		// All three patches and all three updates can be chosen
-		assertEquals("1.2", 6, op.getPossibleUpdates().length);
-	}
-
-	// bug 300445
-	public void testRemoveSelectionAfterResolve() throws ProvisionException {
-		createTestMetdataRepository(new IInstallableUnit[] {a1, a130, b1, b12});
-		install(a1, true, false);
-		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
-		iusInvolved.add(a1);
-		iusInvolved.add(b1);
-		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
-		op.resolveModal(getMonitor());
-		Update[] updates = op.getSelectedUpdates();
-		assertEquals("1.0", 2, updates.length);
-		// choose just one
-		op.setSelectedUpdates(new Update[] {updates[0]});
-		op.resolveModal(getMonitor());
-		assertEquals("1.1", 1, op.getSelectedUpdates().length);
-	}
-
-	// bug 290858
-	public void testSearchForUpdatesInJob() throws ProvisionException {
-		createTestMetdataRepository(new IInstallableUnit[] {a1, a130, b1, b12});
-		install(a1, true, false);
-		ArrayList<IInstallableUnit> iusInvolved = new ArrayList<IInstallableUnit>();
-		iusInvolved.add(a1);
-		iusInvolved.add(b1);
-		UpdateOperation op = getProvisioningUI().getUpdateOperation(iusInvolved, null);
-		ProvisioningJob job = op.getResolveJob(getMonitor());
-		assertTrue("1.0", job instanceof SearchForUpdatesResolutionJob);
-		// getting the job should not compute the request.
-		assertNull("1.1", ((SearchForUpdatesResolutionJob) job).getProfileChangeRequest());
-		job.runModal(getMonitor());
-		assertNotNull("1.2", ((SearchForUpdatesResolutionJob) job).getProfileChangeRequest());
-
-	}
-}
