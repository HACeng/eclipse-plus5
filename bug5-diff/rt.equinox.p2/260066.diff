commit 2f55375cf63b4979f36345fa5b9409bc1311c2ac
Author: Andrew Niefer <aniefer>
Date:   Wed Feb 11 16:25:49 2009 +0000

    bug 260066 - publishing products

0	31	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/CompoundQueryable.java
62	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/VersionedName.java
65	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/eclipse/IProductDescriptor.java
88	10	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/eclipse/ProductFile.java
82	46	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
48	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherApplication.java
18	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/IPublisherInfo.java
14	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/IPublisherResult.java
18	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/PublisherInfo.java
43	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/PublisherResult.java
39	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IFilterAdvice.java
2	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IRootIUAdvice.java
48	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/QueryableFilterAdvice.java
3	4	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootFilesAction.java
3	3	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
4	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAdvice.java
5	2	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ApplicationLauncherAction.java
0	66	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BrandedExecutableAction.java
5	9	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ConfigCUsAction.java
3	3	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/EclipseInstallAction.java
74	19	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/EquinoxExecutableAction.java
1	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
38	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IBrandingAdvice.java
40	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IExecutableAdvice.java
0	21	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ILaunchingAdvice.java
11	2	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/InstallPublisherApplication.java
1	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/LaunchingAdvice.java
69	38	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
136	35	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductFileAdvice.java
10	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductPublisherApplication.java
2	1	bundles/org.eclipse.equinox.p2.publisher/src_ant/org/eclipse/equinox/internal/p2/publisher/ant/PublisherTask.java
2	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/AllTests.java
1	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ConfigCUsActionTest.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/EquinoxExecutableActionTest.java
10	7	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionTest.java
5	4	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionTestMac.java
63	5	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionWithAdviceFileTest.java
153	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductFileAdviceTest.java
190	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductFileTest.java
40	0	bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/contextRepos/content.xml
36	0	bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productFileActionTest.product
3	0	bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productWithConfig/config.ini
50	0	bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productWithConfig/sample.product
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/CompoundQueryable.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/CompoundQueryable.java
deleted file mode 100644
index cc93aa7..0000000
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/CompoundQueryable.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 Code 9 and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: 
- *   Code 9 - initial API and implementation
- ******************************************************************************/
-package org.eclipse.equinox.internal.p2.publisher;
-
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.SubMonitor;
-import org.eclipse.equinox.internal.provisional.p2.query.*;
-
-public class CompoundQueryable implements IQueryable {
-
-	IQueryable[] children;
-
-	public CompoundQueryable(IQueryable[] children) {
-		this.children = children;
-	}
-
-	public Collector query(Query query, Collector collector, IProgressMonitor monitor) {
-		SubMonitor sub = SubMonitor.convert(monitor, children.length * 10);
-		for (int i = 0; i < children.length; i++)
-			children[i].query(query, collector, sub.newChild(1));
-		sub.done();
-		return collector;
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/VersionedName.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/VersionedName.java
new file mode 100644
index 0000000..8218e60
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/VersionedName.java
@@ -0,0 +1,62 @@
+/*******************************************************************************
+ * Copyright (c) 2008, 2009 Code 9 and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Code 9 - initial API and implementation
+ *     EclipseSrouce - ongoing development
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.publisher;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.p2.publisher.AbstractPublisherAction;
+
+public class VersionedName {
+	private String id;
+	private Version version;
+
+	/**
+	 * Creates and returns a new versioned id from the given spec.  The spec should be
+	 * id/version.
+	 * @param spec the spec for the versioned id to create
+	 * @return the parsed versioned id
+	 * @throws IllegalArgumentException If <code>spec</code> is improperly
+	 *         formatted.
+	 */
+	public static VersionedName parse(String spec) {
+		String[] segments = AbstractPublisherAction.getArrayFromString(spec, "/"); //$NON-NLS-1$
+		return new VersionedName(segments[0], segments.length == 1 ? null : segments[1]);
+	}
+
+	/**
+	 * Creates a new versioned name with the given id and version.
+	 * @param id The identifier
+	 * @param version The version
+	 * @throws IllegalArgumentException If <code>version</code> is improperly
+	 *         formatted.
+	 */
+	public VersionedName(String id, String version) {
+		this.id = id;
+		this.version = new Version(version == null ? "0.0.0" : version);
+	}
+
+	public VersionedName(String id, Version version) {
+		this.id = id;
+		this.version = version;
+	}
+
+	public String getId() {
+		return id;
+	}
+
+	public Version getVersion() {
+		return version;
+	}
+
+	public String toString() {
+		return id + "/" + (version == null ? "0.0.0" : version.toString());
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/eclipse/IProductDescriptor.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/eclipse/IProductDescriptor.java
index afb209c..63e551f 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/eclipse/IProductDescriptor.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/eclipse/IProductDescriptor.java
@@ -1,18 +1,31 @@
 /*******************************************************************************
- * Copyright (c) 2008 Code 9 and others. All rights reserved. This
+ * Copyright (c) 2008, 2009 Code 9 and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
  * 
  * Contributors: 
  *   Code 9 - initial API and implementation
+ *   EclipseSource - ongoing development
  ******************************************************************************/
 package org.eclipse.equinox.internal.p2.publisher.eclipse;
 
+import java.io.File;
 import java.util.List;
+import java.util.Properties;
 
+/**
+ * Represents a product file.  
+ * 
+ * If getLocation returns null, then config.ini and p2 advice files cannot
+ * be used (since these are both relative to the product location).
+ *
+ */
 public interface IProductDescriptor {
 
+	/**
+	 * Gets the name of the launcher.
+	 */
 	public String getLauncherName();
 
 	/**
@@ -22,24 +35,75 @@ public interface IProductDescriptor {
 	 */
 	public List getBundles(boolean includeFragments);
 
+	/**
+	 * Returns a list<VersionedName> of fragments that constitute this product.
+	 */
 	public List getFragments();
 
+	/**
+	 * Returns a List<VersionedName> of features that constitute this product.
+	 */
 	public List getFeatures();
 
+	/**
+	 * Returns the path to the config.ini file as specified in the .product file.
+	 */
 	public String getConfigIniPath(String os);
 
+	/**
+	 * Returns the ID for this product.
+	 */
 	public String getId();
 
+	/**
+	 * Returns the ID of the bundle in which the splash screen resides.
+	 */
 	public String getSplashLocation();
 
+	/**
+	 * Returns the name of the product
+	 */
 	public String getProductName();
 
+	/**
+	 * Specifies whether this product was built using features or not.
+	 */
 	public boolean useFeatures();
 
+	/**
+	 * Returns the version of the product.
+	 */
 	public String getVersion();
 
+	/**
+	 * Returns the VM arguments for this product for a given OS.
+	 */
 	public String getVMArguments(String os);
 
+	/**
+	 * Returns the program arguments for this product for a given OS.
+	 */
 	public String getProgramArguments(String os);
 
+	/**
+	 * Returns the properties for a product file.
+	 */
+	public Properties getConfigurationProperties();
+
+	/**
+	 * Returns a list of icons for this product for a given OS.
+	 */
+	public String[] getIcons(String os);
+
+	/**
+	 * Returns a List<BundleInfo> for each bundle that has custom configuration data.
+	 * @return A List<BundleInfo>
+	 */
+	public List getBundleInfos();
+
+	/**
+	 * This is needed for config.ini files and p2 advice
+	 */
+	public File getLocation();
+
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/eclipse/ProductFile.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/eclipse/ProductFile.java
index 86b2b29..76e8c01 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/eclipse/ProductFile.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/internal/p2/publisher/eclipse/ProductFile.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2008 IBM Corporation and others.
+ * Copyright (c) 2005, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,6 +8,7 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Code 9 - Additional function and fixes
+ *     EclipseSource - ongoing development
  *******************************************************************************/
 
 package org.eclipse.equinox.internal.p2.publisher.eclipse;
@@ -16,14 +17,14 @@ import java.io.*;
 import java.util.*;
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
+import org.eclipse.equinox.internal.p2.publisher.VersionedName;
 import org.eclipse.equinox.internal.provisional.frameworkadmin.BundleInfo;
 import org.xml.sax.Attributes;
 import org.xml.sax.InputSource;
 import org.xml.sax.helpers.DefaultHandler;
 
 /**
- * 
- * @since 3.1
+ *  Used to parse a .product file.
  */
 public class ProductFile extends DefaultHandler implements IProductDescriptor {
 	private static final String ATTRIBUTE_PATH = "path"; //$NON-NLS-1$
@@ -31,6 +32,7 @@ public class ProductFile extends DefaultHandler implements IProductDescriptor {
 	private static final String ATTRIBUTE_FRAGMENT = "fragment"; //$NON-NLS-1$
 	private static final String ATTRIBUTE_APPLICATION = "application"; //$NON-NLS-1$
 	private static final String ATTRIBUTE_NAME = "name"; //$NON-NLS-1$
+	private static final String ATTRIBUTE_VALUE = "value"; //$NON-NLS-1$
 	private static final String ATTRIBUTE_LOCATION = "location"; //$NON-NLS-1$
 	private static final String ATTRIBUTE_AUTO_START = "autoStart"; //$NON-NLS-1$
 	private static final String ATTRIBUTE_START_LEVEL = "startLevel"; //$NON-NLS-1$
@@ -73,6 +75,7 @@ public class ProductFile extends DefaultHandler implements IProductDescriptor {
 	private static final String EL_PLUGINS = "plugins"; //$NON-NLS-1$
 	private static final String EL_PLUGIN = "plugin"; //$NON-NLS-1$
 	private static final String EL_PRODUCT = "product"; //$NON-NLS-1$
+	private static final String EL_PROPERTY = "property"; //$NON-NLS-1$
 	private static final String EL_CONFIG_INI = "configIni"; //$NON-NLS-1$
 	private static final String EL_LAUNCHER = "launcher"; //$NON-NLS-1$
 	private static final String EL_LAUNCHER_ARGS = "launcherArgs"; //$NON-NLS-1$
@@ -121,6 +124,7 @@ public class ProductFile extends DefaultHandler implements IProductDescriptor {
 	private Properties launcherArgs = new Properties();
 	private File location;
 	private List bundleInfos;
+	private Properties properties;
 
 	private static String normalize(String text) {
 		if (text == null || text.trim().length() == 0)
@@ -166,14 +170,33 @@ public class ProductFile extends DefaultHandler implements IProductDescriptor {
 		//		}
 	}
 
+	/**
+	 * Gets the name of the launcher specified in the .product file.
+	 */
 	public String getLauncherName() {
 		return launcherName;
 	}
 
+	/**
+	 * Gets the location of the .product file.
+	 */
 	public File getLocation() {
 		return location;
 	}
 
+	/**
+	 * Returns the properties found in .product file.  Properties
+	 * are located in the <configurations> block of the file
+	 */
+	public Properties getConfigurationProperties() {
+		return properties == null ? new Properties() : properties;
+	}
+
+	/**
+	 * Returns a List<VersionedName> for each bundle that makes up this product.
+	 * @param includeFragments Indicates whether or not fragments should
+	 * be included in the list
+	 */
 	public List getBundles(boolean includeFragments) {
 		List p = plugins != null ? plugins : Collections.EMPTY_LIST;
 		if (!includeFragments)
@@ -199,25 +222,28 @@ public class ProductFile extends DefaultHandler implements IProductDescriptor {
 		return bundleInfos != null ? bundleInfos : Collections.EMPTY_LIST;
 	}
 
+	/**
+	 * Returns a list<VersionedName> of fragments that constitute this product.
+	 */
 	public List getFragments() {
 		if (fragments == null)
 			return Collections.EMPTY_LIST;
 		return fragments;
 	}
 
+	/**
+	 * Returns a List<VersionedName> of features that constitute this product.
+	 */
 	public List getFeatures() {
 		if (features == null)
 			return Collections.EMPTY_LIST;
 		return features;
 	}
 
-	/**
-	 * Parses the specified url and constructs a feature
-	 */
 	public String[] getIcons(String os) {
 		Collection result = (Collection) icons.get(os);
 		if (result == null)
-			return new String[0];
+			return null;
 		return (String[]) result.toArray(new String[result.size()]);
 	}
 
@@ -230,31 +256,56 @@ public class ProductFile extends DefaultHandler implements IProductDescriptor {
 		return configPath;
 	}
 
+	/**
+	 * Returns the ID for this product.
+	 */
 	public String getId() {
 		return id;
 	}
 
+	/**
+	 * Returns the location (the bundle) that defines the splash screen
+	 */
 	public String getSplashLocation() {
 		return splashLocation;
 	}
 
+	/**
+	 * Returns the product name.
+	 */
 	public String getProductName() {
 		return productName;
 	}
 
+	/**
+	 * Returns the application identifier for this product.
+	 */
 	public String getApplication() {
 		return application;
 	}
 
+	/**
+	 * Returns true if this product is built using feature, 
+	 * false otherwise.
+	 */
 	public boolean useFeatures() {
 		return useFeatures;
 	}
 
+	/**
+	 * Returns the version of the product
+	 */
 	public String getVersion() {
 		return (version == null || version.length() == 0) ? "0.0.0" : version; //$NON-NLS-1$
 	}
 
+	/**
+	 * Returns the VM arguments for a specific platform.
+	 * If the empty string is used for the OS, this returns
+	 * the default VM arguments
+	 */
 	public String getVMArguments(String os) {
+		os = os == null ? "" : os; //$NON-NLS-1$
 		String key = null;
 		if (os.equals(OS_WIN32)) {
 			key = VM_ARGS_WIN;
@@ -277,7 +328,13 @@ public class ProductFile extends DefaultHandler implements IProductDescriptor {
 		return normalize(args);
 	}
 
+	/**
+	 * Returns the program arguments for a specific platform.
+	 * If the empty string is used for the OS, this returns
+	 * the default program arguments
+	 */
 	public String getProgramArguments(String os) {
+		os = os == null ? "" : os; //$NON-NLS-1$
 		String key = null;
 		if (os.equals(OS_WIN32)) {
 			key = PROGRAM_ARGS_WIN;
@@ -388,11 +445,30 @@ public class ProductFile extends DefaultHandler implements IProductDescriptor {
 			case STATE_CONFIGURATIONS :
 				if (EL_PLUGIN.equals(localName)) {
 					processPluginConfiguration(attributes);
+				} else if (EL_PROPERTY.equals(localName)) {
+					processPropertyConfiguration(attributes);
 				}
 				break;
 		}
 	}
 
+	/**
+	 * Processes the property tag in the .product file.  These tags contain
+	 * a Name and Value pair.  For each tag (with a non-null name), a property 
+	 * is created.
+	 */
+	private void processPropertyConfiguration(Attributes attributes) {
+		String name = attributes.getValue(ATTRIBUTE_NAME);
+		String value = attributes.getValue(ATTRIBUTE_VALUE);
+		if (name == null)
+			return;
+		if (value == null)
+			value = ""; //$NON-NLS-1$
+		if (properties == null)
+			properties = new Properties();
+		properties.put(name, value);
+	}
+
 	private void processPluginConfiguration(Attributes attributes) {
 		BundleInfo info = new BundleInfo();
 		info.setSymbolicName(attributes.getValue(ATTRIBUTE_ID));
@@ -505,21 +581,23 @@ public class ProductFile extends DefaultHandler implements IProductDescriptor {
 
 	private void processPlugin(Attributes attributes) {
 		String fragment = attributes.getValue(ATTRIBUTE_FRAGMENT);
+		VersionedName name = new VersionedName(attributes.getValue(ATTRIBUTE_ID), attributes.getValue(ATTRIBUTE_VERSION));
 		if (fragment != null && new Boolean(fragment).booleanValue()) {
 			if (fragments == null)
 				fragments = new ArrayList();
-			fragments.add(attributes.getValue(ATTRIBUTE_ID));
+			fragments.add(name);
 		} else {
 			if (plugins == null)
 				plugins = new ArrayList();
-			plugins.add(attributes.getValue(ATTRIBUTE_ID));
+			plugins.add(name);
 		}
 	}
 
 	private void processFeature(Attributes attributes) {
+		VersionedName name = new VersionedName(attributes.getValue(ATTRIBUTE_ID), attributes.getValue(ATTRIBUTE_VERSION));
 		if (features == null)
 			features = new ArrayList();
-		features.add(attributes.getValue(ATTRIBUTE_ID));
+		features.add(name);
 	}
 
 	private void processProduct(Attributes attributes) {
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
index 5bb5125..c1c2abc 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
@@ -17,20 +17,49 @@ import org.eclipse.equinox.internal.p2.core.helpers.FileUtils;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
 import org.eclipse.equinox.internal.p2.core.helpers.FileUtils.IPathComputer;
 import org.eclipse.equinox.internal.p2.publisher.Activator;
+import org.eclipse.equinox.internal.p2.publisher.VersionedName;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.*;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.processing.ProcessingStepDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.core.*;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
 import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.publisher.actions.ICapabilityAdvice;
+import org.eclipse.equinox.p2.publisher.actions.IFilterAdvice;
 import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;
 
 public abstract class AbstractPublisherAction implements IPublisherAction {
 	private static final String CONFIG_ANY = "ANY"; //$NON-NLS-1$
 	public static final String CONFIG_SEGMENT_SEPARATOR = "."; //$NON-NLS-1$
 
-	public static void addSelfCapability(InstallableUnitDescription root) {
-		root.setCapabilities(new IProvidedCapability[] {createSelfCapability(root.getId(), root.getVersion())});
+	protected IPublisherInfo info;
+
+	/**
+	 * Convert a list of tokens into an array. The list separator has to be
+	 * specified.
+	 */
+	public static String[] getArrayFromString(String list, String separator) {
+		if (list == null || list.trim().equals("")) //$NON-NLS-1$
+			return new String[0];
+		List result = new ArrayList();
+		for (StringTokenizer tokens = new StringTokenizer(list, separator); tokens.hasMoreTokens();) {
+			String token = tokens.nextToken().trim();
+			if (!token.equals("")) //$NON-NLS-1$
+				result.add(token);
+		}
+		return (String[]) result.toArray(new String[result.size()]);
+	}
+
+	/**
+	 * Returns a string array of { ws, os, arch } as parsed from the given string
+	 * @param configSpec the string to parse
+	 * @return the ws, os, arch form of the given string
+	 */
+	public static String[] parseConfigSpec(String configSpec) {
+		String[] result = getArrayFromString(configSpec, CONFIG_SEGMENT_SEPARATOR);
+		for (int i = 0; i < result.length; i++)
+			if (result[i].equals("*")) //$NON-NLS-1$
+				result[i] = CONFIG_ANY;
+		return result;
 	}
 
 	/**
@@ -46,6 +75,10 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 		return ws + '.' + os + '.' + arch;
 	}
 
+	protected void addSelfCapability(InstallableUnitDescription root) {
+		root.setCapabilities(new IProvidedCapability[] {createSelfCapability(root.getId(), root.getVersion())});
+	}
+
 	/**
 	 * Returns the LDAP filter form that matches the given config spec.  Returns
 	 * an empty String if the spec does not identify an ws, os or arch.
@@ -53,7 +86,7 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 	 * @return the LDAP filter for the given spec.  <code>null</code> if the given spec does not 
 	 * parse into a filter.
 	 */
-	public static String createFilterSpec(String configSpec) {
+	protected String createFilterSpec(String configSpec) {
 		String[] config = parseConfigSpec(configSpec);
 		if (config[0] != null || config[1] != null || config[2] != null) {
 			String filterWs = config[0] != null && config[0] != CONFIG_ANY ? "(osgi.ws=" + config[0] + ")" : ""; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
@@ -73,29 +106,61 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 	 * @param configSpec the config spec to format
 	 * @return the readable format of the given config spec
 	 */
-	public static String createIdString(String configSpec) {
+	protected String createIdString(String configSpec) {
 		String[] config = parseConfigSpec(configSpec);
 		return config[0] + '.' + config[1] + '.' + config[2];
 	}
 
-	public static Collection createIURequirements(Collection children) {
+	protected String createCUIdString(String id, String type, String flavor, String configSpec) {
+		return flavor + id + "." + type + "." + createIdString(configSpec); //$NON-NLS-1$ //$NON-NLS-2$
+	}
+
+	/**
+	 * Creates and returns a collection of RequiredCapabilities for the IUs represented
+	 * by the given collection.  The collection may include a mixture of IInstallableUnits
+	 * or VersionedNames.
+	 * @param children descriptions of the IUs on which requirements are to be made
+	 * @return a collection of RequiredCapabilities representing the given IUs
+	 */
+	protected Collection createIURequirements(Collection children) {
 		ArrayList result = new ArrayList(children.size());
 		for (Iterator i = children.iterator(); i.hasNext();) {
-			IInstallableUnit iu = (IInstallableUnit) i.next();
-			VersionRange range = new VersionRange(iu.getVersion(), true, iu.getVersion(), true);
-			result.add(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, iu.getId(), range, iu.getFilter(), false, false));
+			Object next = i.next();
+			if (next instanceof IInstallableUnit) {
+				IInstallableUnit iu = (IInstallableUnit) next;
+				VersionRange range = new VersionRange(iu.getVersion(), true, iu.getVersion(), true);
+				result.add(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, iu.getId(), range, iu.getFilter(), false, false));
+			} else if (next instanceof VersionedName) {
+				VersionedName name = (VersionedName) next;
+				VersionRange range = new VersionRange(name.getVersion(), true, name.getVersion(), true);
+				String filter = getFilterAdvice(name);
+				result.add(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, name.getId(), range, filter, false, false));
+			}
 		}
 		return result;
 	}
 
-	public static InstallableUnitDescription createIUShell(String id, Version version) {
+	private String getFilterAdvice(VersionedName name) {
+		if (info == null)
+			return null;
+		Collection filterAdvice = info.getAdvice(CONFIG_ANY, true, name.getId(), name.getVersion(), IFilterAdvice.class);
+		for (Iterator i = filterAdvice.iterator(); i.hasNext();) {
+			IFilterAdvice advice = (IFilterAdvice) i.next();
+			String result = advice.getFilter(name.getId(), name.getVersion(), false);
+			if (result != null)
+				return result;
+		}
+		return null;
+	}
+
+	protected InstallableUnitDescription createIUShell(String id, Version version) {
 		InstallableUnitDescription root = new MetadataFactory.InstallableUnitDescription();
 		root.setId(id);
 		root.setVersion(version);
 		return root;
 	}
 
-	public static IArtifactDescriptor createPack200ArtifactDescriptor(IArtifactKey key, File pathOnDisk, String installSize) {
+	protected IArtifactDescriptor createPack200ArtifactDescriptor(IArtifactKey key, File pathOnDisk, String installSize) {
 		final String PACKED_FORMAT = "packed"; //$NON-NLS-1$
 		//TODO this size calculation is bogus
 		ArtifactDescriptor result = new ArtifactDescriptor(key);
@@ -110,7 +175,7 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 		return result;
 	}
 
-	public static InstallableUnitDescription createParentIU(Collection children, String id, Version version) {
+	protected InstallableUnitDescription createParentIU(Collection children, String id, Version version) {
 		InstallableUnitDescription root = createIUShell(id, version);
 		root.addRequiredCapabilities(createIURequirements(children));
 		addSelfCapability(root);
@@ -118,54 +183,25 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 	}
 
 	//This is to hide FileUtils from other actions
-	public static IPathComputer createParentPrefixComputer(int segmentsToKeep) {
+	protected IPathComputer createParentPrefixComputer(int segmentsToKeep) {
 		return FileUtils.createParentPrefixComputer(segmentsToKeep);
 	}
 
 	//This is to hide FileUtils from other actions
-	public static IPathComputer createRootPrefixComputer(final File root) {
+	protected IPathComputer createRootPrefixComputer(final File root) {
 		return FileUtils.createRootPathComputer(root);
 	}
 
-	public static IProvidedCapability createSelfCapability(String installableUnitId, Version installableUnitVersion) {
+	protected IProvidedCapability createSelfCapability(String installableUnitId, Version installableUnitVersion) {
 		return MetadataFactory.createProvidedCapability(PublisherHelper.IU_NAMESPACE, installableUnitId, installableUnitVersion);
 	}
 
 	/**
-	 * Convert a list of tokens into an array. The list separator has to be
-	 * specified.
-	 */
-	public static String[] getArrayFromString(String list, String separator) {
-		if (list == null || list.trim().equals("")) //$NON-NLS-1$
-			return new String[0];
-		List result = new ArrayList();
-		for (StringTokenizer tokens = new StringTokenizer(list, separator); tokens.hasMoreTokens();) {
-			String token = tokens.nextToken().trim();
-			if (!token.equals("")) //$NON-NLS-1$
-				result.add(token);
-		}
-		return (String[]) result.toArray(new String[result.size()]);
-	}
-
-	/**
-	 * Returns a string array of { ws, os, arch } as parsed from the given string
-	 * @param configSpec the string to parse
-	 * @return the ws, os, arch form of the given string
-	 */
-	public static String[] parseConfigSpec(String configSpec) {
-		String[] result = getArrayFromString(configSpec, CONFIG_SEGMENT_SEPARATOR);
-		for (int i = 0; i < result.length; i++)
-			if (result[i].equals("*")) //$NON-NLS-1$
-				result[i] = CONFIG_ANY;
-		return result;
-	}
-
-	/**
 	 * Add all of the advised provided and required capabilities for the given installable unit.
 	 * @param iu the IU to decorate
 	 * @param info the publisher info supplying the advice
 	 */
-	protected static void processCapabilityAdvice(InstallableUnitDescription iu, IPublisherInfo info) {
+	protected void processCapabilityAdvice(InstallableUnitDescription iu, IPublisherInfo info) {
 		Collection advice = info.getAdvice(null, false, iu.getId(), iu.getVersion(), ICapabilityAdvice.class);
 		for (Iterator i = advice.iterator(); i.hasNext();) {
 			ICapabilityAdvice entry = (ICapabilityAdvice) i.next();
@@ -195,7 +231,7 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 	 * @param inclusion the file to be published. files can be <code>null</code> but no action is taken.
 	 * @param info the publisher info.
 	 */
-	protected static void publishArtifact(IArtifactDescriptor descriptor, File inclusion, IPublisherInfo info) {
+	protected void publishArtifact(IArtifactDescriptor descriptor, File inclusion, IPublisherInfo info) {
 		// no files to publish so this is done.
 		if (inclusion == null)
 			return;
@@ -253,7 +289,7 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 	 * @param info the publisher info.
 	 * @param prefixComputer
 	 */
-	protected static void publishArtifact(IArtifactDescriptor descriptor, File[] inclusions, File[] exclusions, IPublisherInfo info, IPathComputer prefixComputer) {
+	protected void publishArtifact(IArtifactDescriptor descriptor, File[] inclusions, File[] exclusions, IPublisherInfo info, IPathComputer prefixComputer) {
 		// no files to publish so this is done.
 		if (inclusions == null || inclusions.length < 1)
 			return;
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherApplication.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherApplication.java
index 7a3bda5..f794d36 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherApplication.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherApplication.java
@@ -17,14 +17,18 @@ import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.app.IApplication;
 import org.eclipse.equinox.app.IApplicationContext;
 import org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRepositoryManager;
+import org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository;
 import org.eclipse.equinox.internal.p2.core.ProvisioningEventBus;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
+import org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository;
 import org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager;
 import org.eclipse.equinox.internal.p2.publisher.Activator;
 import org.eclipse.equinox.internal.p2.publisher.Messages;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepository;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
 import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
+import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
 import org.eclipse.osgi.util.NLS;
 import org.osgi.framework.ServiceRegistration;
@@ -116,6 +120,50 @@ public abstract class AbstractPublisherApplication implements IApplication {
 
 		if (arg.equalsIgnoreCase("-configs")) //$NON-NLS-1$
 			info.setConfigurations(AbstractPublisherAction.getArrayFromString(parameter, ",")); //$NON-NLS-1$
+
+		if (arg.equalsIgnoreCase("-contextMetadata")) //$NON-NLS-1$
+			info.setContextMetadataRepository(processMetadataRepositoryList(parameter));
+
+		if (arg.equalsIgnoreCase("-contextArtifacts")) //$NON-NLS-1$
+			info.setContextArtifactRepository(processArtifactRepositoryList(parameter));
+	}
+
+	private IArtifactRepository processArtifactRepositoryList(String parameter) {
+		String[] list = AbstractPublisherAction.getArrayFromString(parameter, ","); //$NON-NLS-1$
+		if (list == null || list.length == 0)
+			return null;
+
+		CompositeArtifactRepository result = null;
+		try {
+			URI repositoryURI = new URI("memory:"); //$NON-NLS-1$
+			result = (CompositeArtifactRepository) defaultArtifactManager.createRepository(repositoryURI, "artifact name", IArtifactRepositoryManager.TYPE_COMPOSITE_REPOSITORY, null); //$NON-NLS-1$
+			for (int i = 0; i < list.length; i++)
+				result.addChild(new URI(list[i]));
+		} catch (ProvisionException e) {
+			// TODO log something here
+		} catch (URISyntaxException e) {
+			// TODO log something here
+		}
+		return result;
+	}
+
+	private IMetadataRepository processMetadataRepositoryList(String parameter) {
+		String[] list = AbstractPublisherAction.getArrayFromString(parameter, ","); //$NON-NLS-1$
+		if (list == null || list.length == 0)
+			return null;
+
+		CompositeMetadataRepository result = null;
+		try {
+			URI repositoryURI = new URI("memory:"); //$NON-NLS-1$
+			result = (CompositeMetadataRepository) defaultMetadataManager.createRepository(repositoryURI, "artifact name", IMetadataRepositoryManager.TYPE_COMPOSITE_REPOSITORY, null); //$NON-NLS-1$
+			for (int i = 0; i < list.length; i++)
+				result.addChild(new URI(list[i]));
+		} catch (ProvisionException e) {
+			// TODO log something here
+		} catch (URISyntaxException e) {
+			// TODO log something here
+		}
+		return result;
 	}
 
 	protected void processFlag(String arg, PublisherInfo info) {
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/IPublisherInfo.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/IPublisherInfo.java
index b4d26d3..d400d2d 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/IPublisherInfo.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/IPublisherInfo.java
@@ -80,4 +80,22 @@ public interface IPublisherInfo {
 	 * @see AbstractPublisherAction#createConfigSpec(String, String, String)
 	 */
 	public String[] getConfigurations();
+
+	/**
+	 * Returns the artifact repository given to the publisher as context for 
+	 * the publisher actions.  May be <code>null</code>.  Note that multiple 
+	 * repositories may be represented as one composite repository.
+	 * 
+	 * @return the context artifact repository or <code>null</code> if none.
+	 */
+	public IArtifactRepository getContextArtifactRepository();
+
+	/**
+	 * Returns the metadata repository given to the publisher as context for 
+	 * the publisher actions.  May be <code>null</code>.  Note that multiple 
+	 * repositories may be represented as one composite repository.
+	 * 
+	 * @return the context metadata repository or <code>null</code> if none.
+	 */
+	public IMetadataRepository getContextMetadataRepository();
 }
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/IPublisherResult.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/IPublisherResult.java
index 6a303b3..05c0b58 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/IPublisherResult.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/IPublisherResult.java
@@ -10,7 +10,9 @@
 package org.eclipse.equinox.p2.publisher;
 
 import java.util.Collection;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.query.IQueryable;
 
 /**
  * Publisher results represent the result of running a publishing operation.  A result is a 
@@ -19,7 +21,7 @@ import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
  * determined by the actions involved in the operation and it is up to the consumer of the
  * result to interpret the collections.
  */
-public interface IPublisherResult {
+public interface IPublisherResult extends IQueryable {
 	/**
 	 * Merge mode setting that causes all root results to be merged into 
 	 * the root of the merged results and all non-roots to become non-roots.
@@ -91,6 +93,17 @@ public interface IPublisherResult {
 	public IInstallableUnit getIU(String id, String type);
 
 	/**
+	 * Returns the IU of the given type with the given id and version in this result.
+	 * @param id the id of the IU to look for
+	 * @param version the version of the IU to look for
+	 * @param type the type of IU to look for in this result
+	 * @return the requested IU
+	 * @see #ROOT
+	 * @see #NON_ROOT
+	 */
+	public IInstallableUnit getIU(String id, Version version, String type);
+
+	/**
 	 * Merges the given result in this result according to the given mode. 
 	 * @see #MERGE_ALL_NON_ROOT
 	 * @see #MERGE_ALL_ROOT
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/PublisherInfo.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/PublisherInfo.java
index 3196a33..e171bf1 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/PublisherInfo.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/PublisherInfo.java
@@ -19,6 +19,8 @@ public class PublisherInfo implements IPublisherInfo {
 	private int artifactOptions = 0;
 	private IMetadataRepository metadataRepository;
 	private IArtifactRepository artifactRepository;
+	private IMetadataRepository contextMetadataRepository;
+	private IArtifactRepository contextArtifactRepository;
 	private String[] configurations = new String[0];
 	private List adviceList = new ArrayList(11);
 
@@ -44,6 +46,14 @@ public class PublisherInfo implements IPublisherInfo {
 		return metadataRepository;
 	}
 
+	public IArtifactRepository getContextArtifactRepository() {
+		return contextArtifactRepository;
+	}
+
+	public IMetadataRepository getContextMetadataRepository() {
+		return contextMetadataRepository;
+	}
+
 	public int getArtifactOptions() {
 		return artifactOptions;
 	}
@@ -56,6 +66,14 @@ public class PublisherInfo implements IPublisherInfo {
 		metadataRepository = value;
 	}
 
+	public void setContextArtifactRepository(IArtifactRepository value) {
+		contextArtifactRepository = value;
+	}
+
+	public void setContextMetadataRepository(IMetadataRepository value) {
+		contextMetadataRepository = value;
+	}
+
 	public void setArtifactOptions(int value) {
 		artifactOptions = value;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/PublisherResult.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/PublisherResult.java
index 6ba8200..e9cdef9 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/PublisherResult.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/PublisherResult.java
@@ -10,7 +10,10 @@
 package org.eclipse.equinox.p2.publisher;
 
 import java.util.*;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.query.*;
 
 public class PublisherResult implements IPublisherResult {
 
@@ -39,6 +42,26 @@ public class PublisherResult implements IPublisherResult {
 		ius.add(iu);
 	}
 
+	public IInstallableUnit getIU(String id, Version version, String type) {
+		if (type == null || type == ROOT) {
+			Collection ius = (Collection) rootIUs.get(id);
+			for (Iterator i = ius.iterator(); i.hasNext();) {
+				IInstallableUnit iu = (IInstallableUnit) i.next();
+				if (iu.getVersion().equals(version))
+					return iu;
+			}
+		}
+		if (type == null || type == NON_ROOT) {
+			Collection ius = (Collection) nonRootIUs.get(id);
+			for (Iterator i = ius.iterator(); i.hasNext();) {
+				IInstallableUnit iu = (IInstallableUnit) i.next();
+				if (iu.getVersion().equals(version))
+					return iu;
+			}
+		}
+		return null;
+	}
+
 	// TODO this method really should not be needed as it just returns the first
 	// matching IU non-deterministically.
 	public IInstallableUnit getIU(String id, String type) {
@@ -98,4 +121,24 @@ public class PublisherResult implements IPublisherResult {
 		}
 	}
 
+	class QueryableMap implements IQueryable {
+		private Map map;
+
+		public QueryableMap(Map map) {
+			this.map = map;
+		}
+
+		public Collector query(Query query, Collector collector, IProgressMonitor monitor) {
+			return query.perform(flatten(this.map.values()).iterator(), collector);
+		}
+	}
+
+	/**
+	 * Queries both the root and non root IUs
+	 */
+	public Collector query(Query query, Collector collector, IProgressMonitor monitor) {
+		IQueryable nonRootQueryable = new QueryableMap(nonRootIUs);
+		IQueryable rootQueryable = new QueryableMap(rootIUs);
+		return new CompoundQueryable(new IQueryable[] {nonRootQueryable, rootQueryable}).query(query, collector, monitor);
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IFilterAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IFilterAdvice.java
new file mode 100644
index 0000000..c4e0a0f
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IFilterAdvice.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: 
+ *   EclipseSource - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.equinox.p2.publisher.actions;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.p2.publisher.IPublisherAdvice;
+
+/**
+ * Filter advice helps actions figure out where an IU with a given id and version
+ * is applicable.  For example, when some IU being published depends on another, 
+ * it is possible that the prerequisite is not applicable in all scenarios.  In that case
+ * it is useful for new IU to spec its requirement using an applicability filter.  This
+ * advice can supply that filter.
+ */
+public interface IFilterAdvice extends IPublisherAdvice {
+	/**
+	 * Returns the filter to use for depending on the IU with the given id.
+	 * If an exact match is desired, only IUs with the given version are considered
+	 * as sources of filter information.  If in-exact matches are acceptable, the
+	 * advisor will attempt to find the most relevant IU (typically the one with the highest
+	 * version less than that supplied) to supply the version information.
+	 * 
+	 * @param id the id of the target IU 
+	 * @param version the version of the target IU 
+	 * @param exact whether or not to consider information for IUs whose 
+	 * version does not match the supplied version
+	 * @return the filter to use when depending on the given IU or <code>null</code>
+	 * if none.
+	 */
+	public String getFilter(String id, Version version, boolean exact);
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IRootIUAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IRootIUAdvice.java
index 7ad2478..d7afae7 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IRootIUAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IRootIUAdvice.java
@@ -16,7 +16,8 @@ public interface IRootIUAdvice {
 
 	/**
 	 * Returns the list of children of the root for this publishing operation.
-	 * Returned elements are either the String id of the IUs or the IUs themselves.
+	 * Returned elements are either the String id of the IUs, a VersionedName describing 
+	 * the IU or the IUs themselves.
 	 * @param result 
 	 * @return the collection of children
 	 */
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/QueryableFilterAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/QueryableFilterAdvice.java
new file mode 100644
index 0000000..aaba1d7
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/QueryableFilterAdvice.java
@@ -0,0 +1,48 @@
+/*******************************************************************************
+ * Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: 
+ *   EclipseSource - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.equinox.p2.publisher.actions;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
+import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import org.eclipse.equinox.internal.provisional.p2.query.IQueryable;
+
+/**
+ * An IFilterAdvice that looks up the desired IU in the publisher's input metadata
+ * repository and returns whatever filter is found there.
+ */
+public class QueryableFilterAdvice implements IFilterAdvice {
+
+	private IQueryable queryable;
+
+	public QueryableFilterAdvice(IQueryable queryable) {
+		this.queryable = queryable;
+	}
+
+	public String getFilter(String id, Version version, boolean exact) {
+		InstallableUnitQuery query = new InstallableUnitQuery(id, version);
+		Collector result = queryable.query(query, new Collector(), null);
+		if (!result.isEmpty())
+			return (((IInstallableUnit) result.iterator().next()).getFilter());
+		if (exact)
+			return null;
+		query = new InstallableUnitQuery(id);
+		result = queryable.query(query, new Collector(), null);
+		if (!result.isEmpty())
+			return (((IInstallableUnit) result.iterator().next()).getFilter());
+		return null;
+	}
+
+	public boolean isApplicable(String configSpec, boolean includeDefault, String id, Version version) {
+		return true;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootFilesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootFilesAction.java
index dcac00b..8d02761 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootFilesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootFilesAction.java
@@ -89,7 +89,7 @@ public class RootFilesAction extends AbstractPublisherAction {
 		IArtifactKey key = PublisherHelper.createBinaryArtifactKey(iuId, version);
 		iu.setArtifacts(new IArtifactKey[] {key});
 		iu.setTouchpointType(PublisherHelper.TOUCHPOINT_NATIVE);
-		IProvidedCapability launcherCapability = MetadataFactory.createProvidedCapability(flavor + idBase, idPrefix, version); 
+		IProvidedCapability launcherCapability = MetadataFactory.createProvidedCapability(flavor + idBase, idPrefix, version);
 		iu.setCapabilities(new IProvidedCapability[] {PublisherHelper.createSelfCapability(iuId, version), launcherCapability});
 		result.addIU(MetadataFactory.createInstallableUnit(iu), IPublisherResult.ROOT);
 
@@ -123,11 +123,10 @@ public class RootFilesAction extends AbstractPublisherAction {
 		}
 	}
 
-	private static IPathComputer createPrefixComputer(File root) {
+	private IPathComputer createPrefixComputer(File root) {
 		if (root == null)
 			return createParentPrefixComputer(1);
-		else
-			return createRootPrefixComputer(root);
+		return createRootPrefixComputer(root);
 	}
 
 	/**
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
index aa8bde2..2e21ad8 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
@@ -12,8 +12,7 @@ package org.eclipse.equinox.p2.publisher.actions;
 
 import java.util.*;
 import org.eclipse.core.runtime.*;
-import org.eclipse.equinox.internal.p2.publisher.Activator;
-import org.eclipse.equinox.internal.p2.publisher.Messages;
+import org.eclipse.equinox.internal.p2.publisher.*;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
@@ -35,7 +34,6 @@ public class RootIUAction extends AbstractPublisherAction {
 	private String id;
 	private String name;
 	private Collection versionAdvice;
-	private IPublisherInfo info;
 
 	public RootIUAction(String id, Version version, String name) {
 		this.id = id;
@@ -122,6 +120,8 @@ public class RootIUAction extends AbstractPublisherAction {
 							iu = queryFor(childId);
 						if (iu != null)
 							children.add(iu);
+					} else if (object instanceof VersionedName) {
+						children.add(object);
 					} else if (object instanceof IInstallableUnit)
 						children.add(object);
 				}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAdvice.java
index 019b890..1f6765d 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAdvice.java
@@ -13,6 +13,10 @@ import java.util.Collection;
 import org.eclipse.equinox.p2.publisher.AbstractAdvice;
 import org.eclipse.equinox.p2.publisher.IPublisherResult;
 
+/**
+ * Advises publisher actions as to which IUs should be listed as children of an
+ * eventual root IU.  Each child is described as a VersionedName.
+ */
 public class RootIUAdvice extends AbstractAdvice implements IRootIUAdvice {
 
 	private Collection children;
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ApplicationLauncherAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ApplicationLauncherAction.java
index d1648d8..dfce61b 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ApplicationLauncherAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ApplicationLauncherAction.java
@@ -87,6 +87,7 @@ public class ApplicationLauncherAction extends AbstractPublisherAction {
 	private void createLauncherAdvice(IPublisherInfo info, IPublisherResult results) {
 		Collection ius = getIUs(results.getIUs(null, null), EquinoxLauncherCUAction.ORG_ECLIPSE_EQUINOX_LAUNCHER);
 		VersionAdvice advice = new VersionAdvice();
+		boolean found = false;
 		for (Iterator i = ius.iterator(); i.hasNext();) {
 			IInstallableUnit iu = (IInstallableUnit) i.next();
 			// skip over source bundles and fragments
@@ -94,8 +95,10 @@ public class ApplicationLauncherAction extends AbstractPublisherAction {
 			if (iu.getId().endsWith(".source") || iu.isFragment()) //$NON-NLS-1$
 				continue;
 			advice.setVersion(IInstallableUnit.NAMESPACE_IU_ID, iu.getId(), iu.getVersion());
+			found = true;
 		}
-		info.addAdvice(advice);
+		if (found)
+			info.addAdvice(advice);
 	}
 
 	private Collection getIUs(Collection ius, String prefix) {
@@ -141,6 +144,6 @@ public class ApplicationLauncherAction extends AbstractPublisherAction {
 			return result;
 		// otherwise, assume that we are running against an Eclipse install and do the default thing
 		String os = AbstractPublisherAction.parseConfigSpec(configSpec)[1];
-		return ExecutablesDescriptor.createDescriptor(os, executableName, location); 
+		return ExecutablesDescriptor.createDescriptor(os, executableName, location);
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BrandedExecutableAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BrandedExecutableAction.java
deleted file mode 100644
index 1dc0faa..0000000
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BrandedExecutableAction.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 Code 9 and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: 
- *   Code 9 - initial API and implementation
- ******************************************************************************/
-package org.eclipse.equinox.p2.publisher.eclipse;
-
-import org.eclipse.equinox.internal.p2.publisher.eclipse.*;
-import org.eclipse.equinox.internal.provisional.p2.core.Version;
-
-public class BrandedExecutableAction extends EquinoxExecutableAction {
-
-	private ProductFile product;
-
-	public BrandedExecutableAction(ExecutablesDescriptor executables, String productLocation, String flavor, String configSpec) {
-		super();
-		this.executables = executables;
-		this.flavor = flavor;
-		this.configSpec = configSpec;
-		product = loadProduct(productLocation);
-		idBase = product.getProductName();
-		version = new Version(product.getVersion());
-	}
-
-	private ProductFile loadProduct(String productLocation) {
-		ProductFile result = null;
-		try {
-			result = new ProductFile(productLocation);
-		} catch (Exception e) {
-			//TODO
-		}
-		if (result == null)
-			throw new IllegalArgumentException("unable to load product file");
-		return result;
-	}
-
-	/**
-	 * Brands a copy of the given executable descriptor with the information in the 
-	 * current product definition.  The files described in the descriptor are also copied
-	 * to a temporary location to avoid destructive modification
-	 * @param descriptor the executable descriptor to brand.
-	 * @return the new descriptor
-	 */
-	protected ExecutablesDescriptor brandExecutables(ExecutablesDescriptor descriptor) {
-		ExecutablesDescriptor result = new ExecutablesDescriptor(descriptor);
-		result.makeTemporaryCopy();
-		BrandingIron iron = new BrandingIron();
-		String os = parseConfigSpec(configSpec)[1];
-		iron.setIcons(product.getIcons(os));
-		iron.setName(product.getLauncherName());
-		iron.setOS(os);
-		iron.setRoot(result.getLocation().getAbsolutePath());
-		try {
-			iron.brand();
-			result.setExecutableName(product.getLauncherName(), true);
-		} catch (Exception e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-		return result;
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ConfigCUsAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ConfigCUsAction.java
index c2cefdd..9ca6168 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ConfigCUsAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ConfigCUsAction.java
@@ -62,10 +62,6 @@ public class ConfigCUsAction extends AbstractPublisherAction {
 		PROGRAM_ARGS_TO_SKIP.add("-configuration"); //$NON-NLS-1$
 	}
 
-	public static String getCUId(String id, String type, String flavor, String configSpec) {
-		return flavor + id + "." + type + "." + AbstractPublisherAction.createIdString(configSpec); //$NON-NLS-1$ //$NON-NLS-2$
-	}
-
 	public static String getAbstractCUCapabilityNamespace(String id, String type, String flavor, String configSpec) {
 		return flavor + id;
 	}
@@ -103,7 +99,7 @@ public class ConfigCUsAction extends AbstractPublisherAction {
 			BundleInfo[] bundles = fillInBundles(configAdvice, results);
 			publishBundleCUs(info, bundles, configSpec, innerResult);
 			publishConfigIUs(configAdvice, innerResult, configSpec);
-			Collection launchingAdvice = info.getAdvice(configSpec, false, null, null, ILaunchingAdvice.class);
+			Collection launchingAdvice = info.getAdvice(configSpec, false, null, null, IExecutableAdvice.class);
 			publishIniIUs(launchingAdvice, innerResult, configSpec);
 		}
 		// merge the IUs  into the final result as non-roots and create a parent IU that captures them all
@@ -212,10 +208,10 @@ public class ConfigCUsAction extends AbstractPublisherAction {
 	 */
 	private IInstallableUnit createCU(String id, Version version, String type, String flavor, String configSpec, Map touchpointData) {
 		InstallableUnitDescription cu = new InstallableUnitDescription();
-		String resultId = getCUId(id, type, flavor, configSpec);
+		String resultId = createCUIdString(id, type, flavor, configSpec);
 		cu.setId(resultId);
 		cu.setVersion(version);
-		cu.setFilter(AbstractPublisherAction.createFilterSpec(configSpec));
+		cu.setFilter(createFilterSpec(configSpec));
 		cu.setProperty(IInstallableUnit.PROP_TYPE_FRAGMENT, Boolean.TRUE.toString());
 		IProvidedCapability selfCapability = PublisherHelper.createSelfCapability(resultId, version);
 		String namespace = getAbstractCUCapabilityNamespace(id, type, flavor, configSpec);
@@ -261,7 +257,7 @@ public class ConfigCUsAction extends AbstractPublisherAction {
 		String unconfigurationData = ""; //$NON-NLS-1$
 
 		for (Iterator j = launchingAdvice.iterator(); j.hasNext();) {
-			ILaunchingAdvice advice = (ILaunchingAdvice) j.next();
+			IExecutableAdvice advice = (IExecutableAdvice) j.next();
 			String[] jvmArgs = advice.getVMArguments();
 			for (int i = 0; i < jvmArgs.length; i++)
 				if (shouldPublishJvmArg(jvmArgs[i])) {
@@ -326,7 +322,7 @@ public class ConfigCUsAction extends AbstractPublisherAction {
 	}
 
 	protected GeneratorBundleInfo createGeneratorBundleInfo(IPublisherInfo info, BundleInfo bundleInfo, IPublisherResult result) {
-		if (bundleInfo.getLocation() != null)
+		if (bundleInfo.getLocation() != null || bundleInfo.getVersion() != null)
 			return new GeneratorBundleInfo(bundleInfo);
 
 		String name = bundleInfo.getSymbolicName();
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/EclipseInstallAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/EclipseInstallAction.java
index e28b325..a10c4b9 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/EclipseInstallAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/EclipseInstallAction.java
@@ -13,6 +13,7 @@ package org.eclipse.equinox.p2.publisher.eclipse;
 import java.io.File;
 import java.util.*;
 import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.publisher.VersionedName;
 import org.eclipse.equinox.internal.p2.publisher.eclipse.ExecutablesDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.p2.publisher.*;
@@ -25,15 +26,14 @@ public class EclipseInstallAction extends AbstractPublisherAction {
 	protected String name;
 	protected String executableName;
 	protected String flavor;
-	protected String[] topLevel;
-	protected IPublisherInfo info;
+	protected VersionedName[] topLevel;
 	protected String[] nonRootFiles;
 	protected boolean start = false;
 
 	protected EclipseInstallAction() {
 	}
 
-	public EclipseInstallAction(String source, String id, Version version, String name, String executableName, String flavor, String[] topLevel, String[] nonRootFiles, boolean start) {
+	public EclipseInstallAction(String source, String id, Version version, String name, String executableName, String flavor, VersionedName[] topLevel, String[] nonRootFiles, boolean start) {
 		this.source = source;
 		this.id = id;
 		this.version = version;
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/EquinoxExecutableAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/EquinoxExecutableAction.java
index ce9c3a4..154fc33 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/EquinoxExecutableAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/EquinoxExecutableAction.java
@@ -11,10 +11,10 @@
 package org.eclipse.equinox.p2.publisher.eclipse;
 
 import java.io.File;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.FileUtils;
+import org.eclipse.equinox.internal.p2.publisher.eclipse.BrandingIron;
 import org.eclipse.equinox.internal.p2.publisher.eclipse.ExecutablesDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
@@ -26,8 +26,21 @@ import org.eclipse.equinox.p2.publisher.*;
 import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;
 import org.eclipse.osgi.service.environment.Constants;
 
+/**
+ * Given the description of an executable, this action publishes optionally 
+ * non-destructively brands the executable, publishes the resultant artifacts
+ * and publishes the required IUs to identify the branded executable, configure
+ * the executable and set it up as the launcher for a profile.
+ * <p>
+ * This action works on one platform configuration only.
+ * <p>
+ * This action consults the following types of advice:
+ * </ul>
+ * <li>{@link IBrandingAdvice}</li>
+ * </ul>
+ */
 public class EquinoxExecutableAction extends AbstractPublisherAction {
-	private static String TYPE = "executable";
+	private static String TYPE = "executable"; //$NON-NLS-1$
 
 	protected String configSpec;
 	protected String idBase;
@@ -47,11 +60,15 @@ public class EquinoxExecutableAction extends AbstractPublisherAction {
 	}
 
 	public IStatus perform(IPublisherInfo info, IPublisherResult result, IProgressMonitor monitor) {
-		// TODO temporary measure for handling the Eclipse launcher feature files.
-		ExecutablesDescriptor brandedExecutables = brandExecutables(executables);
-		publishExecutableIU(info, brandedExecutables, result);
-		publishExecutableCU(info, brandedExecutables, result);
-		publishExecutableSetter(brandedExecutables, result);
+		ExecutablesDescriptor brandedExecutables = brandExecutables(info, executables);
+		try {
+			publishExecutableIU(info, brandedExecutables, result);
+			publishExecutableCU(info, brandedExecutables, result);
+			publishExecutableSetter(brandedExecutables, result);
+		} finally {
+			if (brandedExecutables.isTemporary())
+				FileUtils.deleteAll(brandedExecutables.getLocation());
+		}
 		return Status.OK_STATUS;
 	}
 
@@ -119,13 +136,13 @@ public class EquinoxExecutableAction extends AbstractPublisherAction {
 	}
 
 	private String getExecutableId() {
-		return ConfigCUsAction.getCUId(idBase, TYPE, "", configSpec);
+		return createCUIdString(idBase, TYPE, "", configSpec);
 	}
 
 	// Create the CU that installs (e.g., unzips) the executable
 	private void publishExecutableCU(IPublisherInfo info, ExecutablesDescriptor execDescriptor, IPublisherResult result) {
 		InstallableUnitFragmentDescription cu = new InstallableUnitFragmentDescription();
-		String id = ConfigCUsAction.getCUId(idBase, TYPE, flavor, configSpec);
+		String id = createCUIdString(idBase, TYPE, flavor, configSpec);
 		cu.setId(id);
 		cu.setVersion(version);
 		cu.setFilter(createFilterSpec(configSpec));
@@ -161,22 +178,60 @@ public class EquinoxExecutableAction extends AbstractPublisherAction {
 		return touchpointData;
 	}
 
-	protected ExecutablesDescriptor brandExecutables(ExecutablesDescriptor descriptor) {
+	/**
+	 * Brands a copy of the given executable descriptor with the information in the 
+	 * current product definition.  The files described in the descriptor are also copied
+	 * to a temporary location to avoid destructive modification
+	 * @param info the publisher info that sets the context for this operation
+	 * @param descriptor the executable descriptor to brand.
+	 * @return the new descriptor
+	 */
+	protected ExecutablesDescriptor brandExecutables(IPublisherInfo info, ExecutablesDescriptor descriptor) {
 		ExecutablesDescriptor result = new ExecutablesDescriptor(descriptor);
 		result.makeTemporaryCopy();
+		IBrandingAdvice advice = getBrandingAdvice(info);
+		if (advice == null || advice.getIcons() == null)
+			partialBrandExecutables(result);
+		else
+			fullBrandExecutables(result, advice);
+		return result;
+	}
+
+	private IBrandingAdvice getBrandingAdvice(IPublisherInfo info) {
+		// there is expected to only be one branding advice for a given configspec so
+		// just return the first one we find.
+		Collection advice = info.getAdvice(configSpec, true, null, null, IBrandingAdvice.class);
+		for (Iterator i = advice.iterator(); i.hasNext();)
+			return (IBrandingAdvice) i.next();
+		return null;
+	}
+
+	protected void fullBrandExecutables(ExecutablesDescriptor descriptor, IBrandingAdvice advice) {
+		BrandingIron iron = new BrandingIron();
+		iron.setIcons(advice.getIcons());
+		iron.setName(advice.getExecutableName());
+		iron.setOS(advice.getOS());
+		iron.setRoot(descriptor.getLocation().getAbsolutePath());
+		try {
+			iron.brand();
+			descriptor.setExecutableName(advice.getExecutableName(), true);
+		} catch (Exception e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+
+	protected void partialBrandExecutables(ExecutablesDescriptor descriptor) {
 		File[] list = descriptor.getFiles();
 		for (int i = 0; i < list.length; i++)
 			mungeExecutableFileName(list[i], descriptor);
-		result.setExecutableName("eclipse", true); //$NON-NLS-1$
-		return result;
+		descriptor.setExecutableName("eclipse", true); //$NON-NLS-1$
 	}
 
-	/**
-	 * @TODO This method is a temporary hack to rename the launcher.exe files
-	 * to eclipse.exe (or "launcher" to "eclipse"). Eventually we will either hand-craft
-	 * metadata/artifacts for launchers, or alter the delta pack to contain eclipse-branded
-	 * launchers.
-	 */
+	// TODO This method is a temporary hack to rename the launcher.exe files
+	// to eclipse.exe (or "launcher" to "eclipse"). Eventually we will either hand-craft
+	// metadata/artifacts for launchers, or alter the delta pack to contain eclipse-branded
+	// launchers.
 	private void mungeExecutableFileName(File file, ExecutablesDescriptor descriptor) {
 		if (file.getName().equals("launcher")) { //$NON-NLS-1$
 			File newFile = new File(file.getParentFile(), "eclipse"); //$NON-NLS-1$
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
index e801aaf..99d1e93 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
@@ -237,7 +237,7 @@ public class FeaturesAction extends AbstractPublisherAction {
 		iu.setTouchpointType(PublisherHelper.TOUCHPOINT_NATIVE);
 		String configSpec = descriptor.getConfigSpec();
 		if (configSpec != null)
-			iu.setFilter(AbstractPublisherAction.createFilterSpec(configSpec));
+			iu.setFilter(createFilterSpec(configSpec));
 		File[] fileResult = attachFiles(iu, descriptor, location);
 		setupLinks(iu, descriptor);
 		setupPermissions(iu, descriptor);
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IBrandingAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IBrandingAdvice.java
new file mode 100644
index 0000000..3e92dc8
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IBrandingAdvice.java
@@ -0,0 +1,38 @@
+/*******************************************************************************
+ * Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: 
+ *   EclipseSource - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.equinox.p2.publisher.eclipse;
+
+/**
+ * Advice for branding executables and other element while publishing.
+ */
+public interface IBrandingAdvice {
+
+	/**
+	 * Returns the OS that this branding advice is relevant for.
+	 */
+	public String getOS();
+
+	/**
+	 * Returns the list of icon files to be used in branding an executable. 
+	 * The nature of the returned values and the images they represent is
+	 * platform-specific.
+	 * 
+	 * @return the list of icons used in branding an executable or <code>null</code> if none.
+	 */
+	public String[] getIcons();
+
+	/**
+	 * Returns the name of the launcher.  This should be the OS-independent
+	 * name. That is, ".exe" etc. should not be included.
+	 * 
+	 * @return the name of the branded launcher or <code>null</code> if none.
+	 */
+	public String getExecutableName();
+}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IExecutableAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IExecutableAdvice.java
new file mode 100644
index 0000000..7d46675
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IExecutableAdvice.java
@@ -0,0 +1,40 @@
+/*******************************************************************************
+ * Copyright (c) 2008, 2009 Code 9 and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: 
+ *   Code 9 - initial API and implementation
+ *   EclipseSource - ongoing development
+ ******************************************************************************/
+package org.eclipse.equinox.p2.publisher.eclipse;
+
+import org.eclipse.equinox.p2.publisher.IPublisherAdvice;
+
+/**
+ * Advice for executables while publishing.
+ */
+public interface IExecutableAdvice extends IPublisherAdvice {
+
+	/**
+	 * Returns the VM arguments for this executable.
+	 * @return The list of VM Arguments for this executable or empty array for none
+	 */
+	public String[] getVMArguments();
+
+	/**
+	 * Returns the program arguments for this executable.
+	 * 
+	 * @return The list of program arguments for tihs executable or empty array for none
+	 */
+	public String[] getProgramArguments();
+
+	/**
+	 * Returns the name of the launcher.  This should be the OS-independent
+	 * name. That is, ".exe" etc. should not be included.
+	 * 
+	 * @return the name of the branded launcher or <code>null</code> if none.
+	 */
+	public String getExecutableName();
+}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ILaunchingAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ILaunchingAdvice.java
deleted file mode 100644
index c2c7514..0000000
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ILaunchingAdvice.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 Code 9 and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: 
- *   Code 9 - initial API and implementation
- ******************************************************************************/
-package org.eclipse.equinox.p2.publisher.eclipse;
-
-import org.eclipse.equinox.p2.publisher.IPublisherAdvice;
-
-public interface ILaunchingAdvice extends IPublisherAdvice {
-
-	public String[] getVMArguments();
-
-	public String[] getProgramArguments();
-
-	public String getExecutableName();
-}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/InstallPublisherApplication.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/InstallPublisherApplication.java
index ce320fd..0910d98 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/InstallPublisherApplication.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/InstallPublisherApplication.java
@@ -11,6 +11,7 @@ package org.eclipse.equinox.p2.publisher.eclipse;
 
 import java.net.URISyntaxException;
 import java.util.ArrayList;
+import org.eclipse.equinox.internal.p2.publisher.VersionedName;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.p2.publisher.*;
 
@@ -21,7 +22,7 @@ public class InstallPublisherApplication extends AbstractPublisherApplication {
 	protected String name;
 	protected String executableName;
 	protected String flavor;
-	protected String[] topLevel;
+	protected VersionedName[] topLevel;
 	protected boolean start;
 	protected String[] rootExclusions;
 
@@ -54,12 +55,20 @@ public class InstallPublisherApplication extends AbstractPublisherApplication {
 			flavor = parameter;
 
 		if (arg.equalsIgnoreCase("-top")) //$NON-NLS-1$
-			topLevel = AbstractPublisherAction.getArrayFromString(parameter, ",");
+			topLevel = createVersionedNameList(parameter);
 
 		if (arg.equalsIgnoreCase("-rootExclusions")) //$NON-NLS-1$
 			rootExclusions = AbstractPublisherAction.getArrayFromString(parameter, ",");
 	}
 
+	private VersionedName[] createVersionedNameList(String parameter) {
+		String[] list = AbstractPublisherAction.getArrayFromString(parameter, ","); //$NON-NLS-1$
+		VersionedName[] result = new VersionedName[list.length];
+		for (int i = 0; i < result.length; i++)
+			result[i] = VersionedName.parse(list[i]);
+		return result;
+	}
+
 	protected IPublisherAction[] createActions() {
 		ArrayList result = new ArrayList();
 		result.add(createEclipseInstallAction());
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/LaunchingAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/LaunchingAdvice.java
index c08172a..54f6232 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/LaunchingAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/LaunchingAdvice.java
@@ -13,7 +13,7 @@ package org.eclipse.equinox.p2.publisher.eclipse;
 import org.eclipse.equinox.internal.provisional.frameworkadmin.LauncherData;
 import org.eclipse.equinox.p2.publisher.AbstractAdvice;
 
-public class LaunchingAdvice extends AbstractAdvice implements ILaunchingAdvice {
+public class LaunchingAdvice extends AbstractAdvice implements IExecutableAdvice {
 
 	private LauncherData data;
 	private String configSpec;
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
index e5c8317..6df72b6 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
@@ -11,25 +11,32 @@ package org.eclipse.equinox.p2.publisher.eclipse;
 
 import java.io.File;
 import java.util.*;
-import org.eclipse.core.runtime.Path;
-import org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.publisher.VersionedName;
+import org.eclipse.equinox.internal.p2.publisher.eclipse.IProductDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
-import org.eclipse.equinox.p2.publisher.IPublisherAction;
-import org.eclipse.equinox.p2.publisher.IPublisherResult;
-import org.eclipse.equinox.p2.publisher.actions.MergeResultsAction;
-import org.eclipse.equinox.p2.publisher.actions.RootIUAdvice;
+import org.eclipse.equinox.p2.publisher.*;
+import org.eclipse.equinox.p2.publisher.actions.*;
 
-public class ProductAction extends EclipseInstallAction {
+public class ProductAction extends AbstractPublisherAction {
+	protected String source;
+	protected String id;
+	protected Version version;
+	protected String name;
+	protected String executableName;
+	protected String flavor;
+	protected boolean start = false;
+	//protected String productLocation;
+	protected File executablesFeatureLocation;
+	protected IProductDescriptor product;
 
-	private String productLocation;
-	private File executablesFeatureLocation;
-
-	public ProductAction(String source, String productLocation, String flavor, File executablesFeatureLocation) {
+	public ProductAction(String source, IProductDescriptor product, String flavor, File executablesFeatureLocation) {
 		super();
 		this.source = source;
 		this.flavor = flavor;
 		this.executablesFeatureLocation = executablesFeatureLocation;
-		this.productLocation = productLocation;
+		this.product = product;
+		//this.productLocation = productLocation;
 	}
 
 	protected IPublisherAction[] createActions() {
@@ -38,60 +45,76 @@ public class ProductAction extends EclipseInstallAction {
 
 		// create all the actions needed to publish a product
 		ArrayList actions = new ArrayList();
-		// if we have a source location then create actions that publishes the bundles 
-		// and features as well as the root files, launchers, etc.
-		if (source != null)
-			actions.add(new MergeResultsAction(new IPublisherAction[] {createFeaturesAction(), createBundlesAction()}, IPublisherResult.MERGE_ALL_NON_ROOT));
 		// products include the executable so add actions to publish them
-		actions.add(createApplicationExecutableAction(info.getConfigurations()));
+		if (getExecutablesLocation() != null)
+			actions.add(createApplicationExecutableAction(info.getConfigurations()));
 		// add the actions that just configure things.
-		actions.add(createJREAction());
 		actions.add(createConfigCUsAction());
 		actions.add(createDefaultCUsAction());
 		actions.add(createRootIUAction());
 		return (IPublisherAction[]) actions.toArray(new IPublisherAction[actions.size()]);
 	}
 
-	private ProductFile loadProduct() {
-		ProductFile product = null;
-		try {
-			product = new ProductFile(productLocation);
-		} catch (Exception e) {
-			//TODO
+	protected IPublisherAction createApplicationExecutableAction(String[] configSpecs) {
+		return new ApplicationLauncherAction(id, version, flavor, executableName, getExecutablesLocation(), configSpecs);
+	}
+
+	protected IPublisherAction createDefaultCUsAction() {
+		return new DefaultCUsAction(info, flavor, 4, false);
+	}
+
+	protected IPublisherAction createRootIUAction() {
+		return new RootIUAction(id, version, name);
+	}
+
+	protected IPublisherAction createConfigCUsAction() {
+		return new ConfigCUsAction(info, flavor, id, version);
+	}
+
+	public IStatus perform(IPublisherInfo info, IPublisherResult results, IProgressMonitor monitor) {
+		monitor = SubMonitor.convert(monitor);
+		this.info = info;
+		IPublisherAction[] actions = createActions();
+		MultiStatus finalStatus = new MultiStatus(EclipseInstallAction.class.getName(), 0, "publishing result", null); //$NON-NLS-1$
+		for (int i = 0; i < actions.length; i++) {
+			if (monitor.isCanceled())
+				return Status.CANCEL_STATUS;
+			finalStatus.merge(actions[i].perform(info, results, monitor));
 		}
-		if (product == null)
-			throw new IllegalArgumentException("unable to load product file"); //$NON-NLS-1$
-		return product;
+		if (!finalStatus.isOK())
+			return finalStatus;
+		return Status.OK_STATUS;
 	}
 
 	private void createAdvice() {
-		ProductFile product = loadProduct();
 		executableName = product.getLauncherName();
-		createProductAdvice(product);
-		createAdviceFileAdvice(product);
-		createRootAdvice(product);
+		createProductAdvice();
+		createAdviceFileAdvice();
+		createRootAdvice();
+		info.addAdvice(new RootIUResultFilterAdvice(null));
 	}
 
 	/**
 	 * Create advice for a p2.inf file co-located with the product file, if any.
 	 */
-	private void createAdviceFileAdvice(ProductFile product) {
+	private void createAdviceFileAdvice() {
 		File productFileLocation = product.getLocation();
 		if (productFileLocation == null)
 			return;
 		info.addAdvice(new AdviceFileAdvice(product.getId(), new Version(product.getVersion()), new Path(productFileLocation.getParent()), new Path("p2.inf"))); //$NON-NLS-1$
+
 	}
 
-	protected void createRootAdvice(ProductFile product) {
+	private void createRootAdvice() {
 		Collection list;
 		if (product.useFeatures())
 			list = listElements(product.getFeatures(), ".feature.group"); //$NON-NLS-1$
 		else
-			list = listElements(product.getBundles(true), ""); //$NON-NLS-1$
+			list = listElements(product.getBundles(true), null);
 		info.addAdvice(new RootIUAdvice(list));
 	}
 
-	private void createProductAdvice(ProductFile product) {
+	private void createProductAdvice() {
 		id = product.getId();
 		version = new Version(product.getVersion());
 		name = product.getId();
@@ -102,13 +125,21 @@ public class ProductAction extends EclipseInstallAction {
 	}
 
 	private Collection listElements(List elements, String suffix) {
+		if (suffix == null || suffix.length() == 0)
+			return elements;
 		ArrayList result = new ArrayList(elements.size());
-		for (Iterator i = elements.iterator(); i.hasNext();)
-			result.add(((String) i.next()) + suffix);
+		for (Iterator i = elements.iterator(); i.hasNext();) {
+			VersionedName name = (VersionedName) i.next();
+			result.add(new VersionedName(name.getId() + suffix, name.getVersion()));
+		}
 		return result;
 	}
 
 	protected File getExecutablesLocation() {
-		return executablesFeatureLocation == null ? super.getExecutablesLocation() : executablesFeatureLocation;
+		if (executablesFeatureLocation != null)
+			return executablesFeatureLocation;
+		if (source != null)
+			return new File(source);
+		return null;
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductFileAdvice.java
index b4db047..c17fee8 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductFileAdvice.java
@@ -1,20 +1,23 @@
 /*******************************************************************************
- * Copyright (c) 2008 Code 9 and others. All rights reserved. This
+ * Copyright (c) 2008, 2009 Code 9 and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
  * 
  * Contributors: 
  *   Code 9 - initial API and implementation
+ *   EclipseSource - ongoing development
  ******************************************************************************/
 package org.eclipse.equinox.p2.publisher.eclipse;
 
 import java.io.File;
 import java.util.*;
+import org.eclipse.equinox.internal.p2.publisher.VersionedName;
 import org.eclipse.equinox.internal.p2.publisher.eclipse.DataLoader;
-import org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile;
+import org.eclipse.equinox.internal.p2.publisher.eclipse.IProductDescriptor;
 import org.eclipse.equinox.internal.provisional.frameworkadmin.BundleInfo;
 import org.eclipse.equinox.internal.provisional.frameworkadmin.ConfigData;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.p2.publisher.AbstractAdvice;
 import org.eclipse.equinox.p2.publisher.AbstractPublisherAction;
 
@@ -22,20 +25,111 @@ import org.eclipse.equinox.p2.publisher.AbstractPublisherAction;
  * Provide advice derived from the .product file.  The product can give some info on 
  * launching as well as the configuration (bundles, properties, ...)
  */
-public class ProductFileAdvice extends AbstractAdvice implements ILaunchingAdvice, IConfigAdvice {
+public class ProductFileAdvice extends AbstractAdvice implements IExecutableAdvice, IConfigAdvice, IBrandingAdvice {
 
-	private ProductFile product;
+	private IProductDescriptor product;
 	private String configSpec;
 	private String os;
 	private ConfigData configData = null;
 
-	public ProductFileAdvice(ProductFile product, String configSpec) {
+	/**
+	 * A way of comparing BundleInfos.  Bundles are first sorted by 
+	 * Name and then sorted by version.
+	 */
+	Comparator bundleInfoComparator = new Comparator() {
+		public int compare(Object arg0, Object arg1) {
+			BundleInfo b1 = (BundleInfo) arg0;
+			BundleInfo b2 = (BundleInfo) arg1;
+			boolean useVersion = b1.getVersion() != null && b2.getVersion() != null;
+			if (b1.getSymbolicName().compareTo(b2.getSymbolicName()) != 0 || !useVersion)
+				return b1.getSymbolicName().compareTo(b2.getSymbolicName());
+			return new Version(b1.getVersion()).compareTo(new Version(b2.getVersion()));
+		}
+	};
+
+	/**
+	 * Constructs a new ProductFileAdvice for a given product file and a
+	 * particular configuration. Configurations are 
+	 * specified as: ws.os.arch where:
+	 *  ws is the windowing system
+	 *  os is the operating system
+	 *  arch is the architecture
+	 */
+	public ProductFileAdvice(IProductDescriptor product, String configSpec) {
 		this.product = product;
 		this.configSpec = configSpec;
 		os = AbstractPublisherAction.parseConfigSpec(configSpec)[1];
 		configData = getConfigData();
 	}
 
+	/**
+	 * Returns the program arguments for this product.  
+	 */
+	public String[] getProgramArguments() {
+		String line = product.getProgramArguments(os);
+		return AbstractPublisherAction.getArrayFromString(line, " "); //$NON-NLS-1$
+	}
+
+	/**
+	 * Returns the VM arguments for this product.
+	 */
+	public String[] getVMArguments() {
+		String line = product.getVMArguments(os);
+		return AbstractPublisherAction.getArrayFromString(line, " "); //$NON-NLS-1$
+	}
+
+	/**
+	 * Returns the Bundles that constitute this product.  These
+	 * bundles may be specified in the .product file, .product file configuration
+	 * area, config.ini file, or a combination of these three places.
+	 */
+	public BundleInfo[] getBundles() {
+		return configData.getBundles();
+	}
+
+	/**
+	 * Returns the properties associated with this product.  These
+	 * properties may be defined in the .product file, the config.ini
+	 * file, or both.
+	 */
+	public Properties getProperties() {
+		Properties result = new Properties();
+		result.putAll(configData.getProperties());
+		result.putAll(product.getConfigurationProperties());
+		return result;
+	}
+
+	/**
+	 * Returns the name of the launcher.  This should be the OS-independent
+	 * name. That is, ".exe" etc. should not be included.
+	 * 
+	 * @return the name of the branded launcher or <code>null</code> if none.
+	 */
+	public String getExecutableName() {
+		return product.getLauncherName();
+	}
+
+	/**
+	 * Returns the product file parser that this advice is working on
+	 */
+	public IProductDescriptor getProductFile() {
+		return product;
+	}
+
+	/**
+	 * Returns the icons defined for this product
+	 */
+	public String[] getIcons() {
+		return product.getIcons(os);
+	}
+
+	/**
+	 * Returns the operating system that this advice is configured to work with.
+	 */
+	public String getOS() {
+		return this.os;
+	}
+
 	private ConfigData getConfigData() {
 		DataLoader loader = createDataLoader();
 		ConfigData result;
@@ -43,6 +137,9 @@ public class ProductFileAdvice extends AbstractAdvice implements ILaunchingAdvic
 			result = loader.getConfigData();
 		else
 			result = generateConfigData();
+
+		addProductFileBundles(result); // these are the bundles specified in the <plugins/> tag
+		addProductFileConfigBundles(result); // these are the bundles specified in the <configurations> tag in the product file
 		result.setProperty("eclipse.product", product.getId()); //$NON-NLS-1$
 		String location = getSplashLocation();
 		if (location != null)
@@ -50,6 +147,33 @@ public class ProductFileAdvice extends AbstractAdvice implements ILaunchingAdvic
 		return result;
 	}
 
+	private void addProductFileConfigBundles(ConfigData configData) {
+		TreeSet set = new TreeSet(bundleInfoComparator);
+		set.addAll(Arrays.asList(configData.getBundles()));
+		List bundleInfos = product.getBundleInfos();
+		for (Iterator i = bundleInfos.iterator(); i.hasNext();) {
+			BundleInfo bundleInfo = (BundleInfo) i.next();
+			if (!set.contains(bundleInfo)) {
+				configData.addBundle(bundleInfo);
+			}
+		}
+	}
+
+	private void addProductFileBundles(ConfigData configData) {
+		List bundles = product.getBundles(true);
+		Set set = new TreeSet(bundleInfoComparator);
+		set.addAll(Arrays.asList(configData.getBundles()));
+
+		for (Iterator i = bundles.iterator(); i.hasNext();) {
+			VersionedName name = (VersionedName) i.next();
+			BundleInfo bundleInfo = new BundleInfo();
+			bundleInfo.setSymbolicName(name.getId());
+			bundleInfo.setVersion(name.getVersion().toString());
+			if (!set.contains(bundleInfo))
+				configData.addBundle(bundleInfo);
+		}
+	}
+
 	private ConfigData generateConfigData() {
 		ConfigData result = new ConfigData(null, null, null, null);
 		if (product.useFeatures())
@@ -59,51 +183,28 @@ public class ProductFileAdvice extends AbstractAdvice implements ILaunchingAdvic
 		// what if the product is p2 based or simpleconfig is in the list?
 		List bundles = product.getBundles(true);
 		for (Iterator i = bundles.iterator(); i.hasNext();) {
-			String id = (String) i.next();
+			VersionedName name = (VersionedName) i.next();
 			BundleInfo bundleInfo = new BundleInfo();
-			bundleInfo.setSymbolicName(id);
+			bundleInfo.setSymbolicName(name.getId());
+			bundleInfo.setVersion(name.getVersion().toString());
 			result.addBundle(bundleInfo);
 		}
 		return result;
 	}
 
 	private String getSplashLocation() {
-		// TODO implement this
-		return null;
+		return product.getSplashLocation();
 	}
 
 	protected String getConfigSpec() {
 		return configSpec;
 	}
 
-	public String[] getProgramArguments() {
-		String line = product.getProgramArguments(os);
-		return AbstractPublisherAction.getArrayFromString(line, " "); //$NON-NLS-1$
-	}
-
-	public String[] getVMArguments() {
-		String line = product.getVMArguments(os);
-		return AbstractPublisherAction.getArrayFromString(line, " "); //$NON-NLS-1$
-	}
-
 	protected boolean matchConfig(String spec, boolean includeDefault) {
 		String targetOS = AbstractPublisherAction.parseConfigSpec(spec)[1];
 		return os.equals(targetOS);
 	}
 
-	public BundleInfo[] getBundles() {
-		ArrayList result = new ArrayList();
-		result.addAll(Arrays.asList(configData.getBundles()));
-		result.addAll(product.getBundleInfos());
-		return (BundleInfo[]) result.toArray(new BundleInfo[result.size()]);
-	}
-
-	public Properties getProperties() {
-		Properties result = new Properties();
-		result.putAll(configData.getProperties());
-		return result;
-	}
-
 	private DataLoader createDataLoader() {
 		String location = product.getConfigIniPath(os);
 		if (location == null)
@@ -111,6 +212,9 @@ public class ProductFileAdvice extends AbstractAdvice implements ILaunchingAdvic
 		if (location == null)
 			return null;
 		File configFile = new File(location);
+
+		// We are assuming we are always relative from the product file
+		// However PDE tooling puts us relative from the workspace
 		if (!configFile.isAbsolute())
 			configFile = new File(product.getLocation().getParentFile(), location);
 		// TODO need to figure out what to do for the launcher location here...
@@ -118,7 +222,4 @@ public class ProductFileAdvice extends AbstractAdvice implements ILaunchingAdvic
 		return new DataLoader(configFile, new File(product.getLauncherName()).getAbsoluteFile());
 	}
 
-	public String getExecutableName() {
-		return product.getLauncherName();
-	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductPublisherApplication.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductPublisherApplication.java
index 2d43614..63aaa16 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductPublisherApplication.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductPublisherApplication.java
@@ -12,6 +12,8 @@ package org.eclipse.equinox.p2.publisher.eclipse;
 import java.io.File;
 import java.net.URISyntaxException;
 import java.util.ArrayList;
+import org.eclipse.equinox.internal.p2.publisher.eclipse.IProductDescriptor;
+import org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile;
 import org.eclipse.equinox.p2.publisher.*;
 
 public class ProductPublisherApplication extends AbstractPublisherApplication {
@@ -30,7 +32,14 @@ public class ProductPublisherApplication extends AbstractPublisherApplication {
 	}
 
 	private IPublisherAction createProductAction() {
-		return new ProductAction(source, product, flavor, new File(executables));
+		IProductDescriptor productDescriptor = null;
+		try {
+			productDescriptor = new ProductFile(product);
+		} catch (Exception e) {
+			if (product == null)
+				throw new IllegalArgumentException("unable to load product file"); //$NON-NLS-1$
+		}
+		return new ProductAction(source, productDescriptor, flavor, new File(executables));
 	}
 
 	protected void processParameter(String arg, String parameter, PublisherInfo info) throws URISyntaxException {
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src_ant/org/eclipse/equinox/internal/p2/publisher/ant/PublisherTask.java b/bundles/org.eclipse.equinox.p2.publisher/src_ant/org/eclipse/equinox/internal/p2/publisher/ant/PublisherTask.java
index e3a07d1..539f66a 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src_ant/org/eclipse/equinox/internal/p2/publisher/ant/PublisherTask.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src_ant/org/eclipse/equinox/internal/p2/publisher/ant/PublisherTask.java
@@ -13,6 +13,7 @@ package org.eclipse.equinox.internal.p2.publisher.ant;
 import java.io.File;
 import org.apache.tools.ant.BuildException;
 import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.equinox.internal.p2.publisher.VersionedName;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.p2.publisher.*;
@@ -37,7 +38,7 @@ public class PublisherTask extends AbstractPublishTask {
 	private String versionAdvice;
 	private String rootName;
 	private String executableName;
-	private String[] topLevel;
+	private VersionedName[] topLevel;
 	private boolean start;
 	private String[] nonRootFiles;
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/AllTests.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/AllTests.java
index 64412b9..75b93c8 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/AllTests.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/AllTests.java
@@ -29,6 +29,8 @@ public class AllTests extends TestCase {
 		suite.addTestSuite(ProductActionTest.class);
 		suite.addTestSuite(ProductActionTestMac.class);
 		suite.addTestSuite(ProductActionWithAdviceFileTest.class);
+		suite.addTestSuite(ProductFileAdviceTest.class);
+		suite.addTestSuite(ProductFileTest.class);
 		suite.addTestSuite(RootFilesActionTest.class);
 		suite.addTestSuite(RootIUActionTest.class);
 		suite.addTestSuite(GeneralPublisherTests.class);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ConfigCUsActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ConfigCUsActionTest.java
index a935816..6518e85 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ConfigCUsActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ConfigCUsActionTest.java
@@ -111,7 +111,7 @@ public class ConfigCUsActionTest extends ActionTest {
 		LaunchingAdvice launchingAdvice = new LaunchingAdvice(launcherData, configSpec);
 		ArrayList launchingList = new ArrayList();
 		launchingList.add(launchingAdvice);
-		expect(publisherInfo.getAdvice(configSpec, false, null, null, ILaunchingAdvice.class)).andReturn(launchingList);
+		expect(publisherInfo.getAdvice(configSpec, false, null, null, IExecutableAdvice.class)).andReturn(launchingList);
 
 		//setup metadata repository
 		IInstallableUnit[] ius = {mockIU("foo", null), mockIU("bar", null)}; //$NON-NLS-1$ //$NON-NLS-2$
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/EquinoxExecutableActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/EquinoxExecutableActionTest.java
index a3019ba..f3ee446 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/EquinoxExecutableActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/EquinoxExecutableActionTest.java
@@ -10,10 +10,11 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.publisher.actions;
 
-import static org.easymock.EasyMock.expect;
+import static org.easymock.EasyMock.*;
 
 import java.io.File;
 import java.util.ArrayList;
+import java.util.Collections;
 import org.eclipse.core.runtime.NullProgressMonitor;
 import org.eclipse.equinox.internal.p2.publisher.eclipse.ExecutablesDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepository;
@@ -156,5 +157,6 @@ public class EquinoxExecutableActionTest extends ActionTest {
 		setupArtifactRepository();
 		expect(publisherInfo.getArtifactRepository()).andReturn(artifactRepository);
 		expect(publisherInfo.getArtifactOptions()).andReturn(IPublisherInfo.A_PUBLISH);
+		expect(publisherInfo.getAdvice((String) anyObject(), anyBoolean(), (String) anyObject(), (Version) anyObject(), (Class) anyObject())).andReturn(Collections.emptyList());
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionTest.java
index e4e0df9..346fcb4 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionTest.java
@@ -13,11 +13,11 @@ package org.eclipse.equinox.p2.tests.publisher.actions;
 import static org.easymock.EasyMock.*;
 
 import java.io.File;
-import java.io.IOException;
 import java.util.Collection;
 import java.util.Collections;
 import org.easymock.Capture;
 import org.easymock.EasyMock;
+import org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile;
 import org.eclipse.equinox.internal.provisional.frameworkadmin.BundleInfo;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.p2.publisher.IPublisherInfo;
@@ -64,8 +64,9 @@ public class ProductActionTest extends ActionTest {
 	 * Tests publishing a product containing a branded application with a custom
 	 * splash screen, icon, etc.
 	 */
-	public void testBrandedApplication() throws IOException {
-		testAction = new ProductAction(source, TestData.getFile("ProductActionTest", "brandedProduct/branded.product").toString(), flavorArg, executablesFeatureLocation);
+	public void testBrandedApplication() throws Exception {
+		ProductFile productFile = new ProductFile(TestData.getFile("ProductActionTest", "brandedProduct/branded.product").toString());
+		testAction = new ProductAction(source, productFile, flavorArg, executablesFeatureLocation);
 		testAction.perform(publisherInfo, publisherResult, null);
 		Collection ius = publisherResult.getIUs("branded.product", IPublisherResult.NON_ROOT);
 		assertEquals("1.0", 1, ius.size());
@@ -78,7 +79,8 @@ public class ProductActionTest extends ActionTest {
 	 * IConfigAdvice (start levels, auto-start).
 	 */
 	public void testSetBundleConfigData() throws Exception {
-		testAction = new ProductAction(source, TestData.getFile("ProductActionTest", "startLevel.product").toString(), flavorArg, executablesFeatureLocation);
+		ProductFile productFile = new ProductFile(TestData.getFile("ProductActionTest", "startLevel.product").toString());
+		testAction = new ProductAction(source, productFile, flavorArg, executablesFeatureLocation);
 
 		testAction.perform(publisherInfo, publisherResult, null);
 		IConfigAdvice configAdvice = productFileAdviceCapture.getValue();
@@ -98,11 +100,12 @@ public class ProductActionTest extends ActionTest {
 	/**
 	 * Tests that correct advice is created for the org.eclipse.platform product.
 	 */
-	public void testPlatformProduct() throws IOException {
-		testAction = new ProductAction(source, TestData.getFile("ProductActionTest", "platform.product").toString(), flavorArg, executablesFeatureLocation);
+	public void testPlatformProduct() throws Exception {
+		ProductFile productFile = new ProductFile(TestData.getFile("ProductActionTest", "platform.product").toString());
+		testAction = new ProductAction(source, productFile, flavorArg, executablesFeatureLocation);
 		testAction.perform(publisherInfo, publisherResult, null);
 
-		ILaunchingAdvice launchAdvice = productFileAdviceCapture.getValue();
+		IExecutableAdvice launchAdvice = productFileAdviceCapture.getValue();
 		assertEquals("1.0", "eclipse", launchAdvice.getExecutableName());
 
 		String[] programArgs = launchAdvice.getProgramArguments();
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionTestMac.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionTestMac.java
index 3ee47dd..0cb73a1 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionTestMac.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionTestMac.java
@@ -12,10 +12,10 @@ package org.eclipse.equinox.p2.tests.publisher.actions;
 import static org.easymock.EasyMock.*;
 
 import java.io.File;
-import java.io.IOException;
 import java.util.Collections;
 import org.easymock.Capture;
 import org.easymock.EasyMock;
+import org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.p2.publisher.AbstractPublisherAction;
 import org.eclipse.equinox.p2.publisher.IPublisherInfo;
@@ -59,11 +59,12 @@ public class ProductActionTestMac extends ActionTest {
 	/**
 	 * Tests that correct advice is created for the org.eclipse.platform product.
 	 */
-	public void testPlatformProduct() throws IOException {
-		testAction = new ProductAction(source, TestData.getFile("ProductActionTest", "platform.product").toString(), flavorArg, executablesFeatureLocation);
+	public void testPlatformProduct() throws Exception {
+		ProductFile productFile = new ProductFile(TestData.getFile("ProductActionTest", "platform.product").toString());
+		testAction = new ProductAction(source, productFile, flavorArg, executablesFeatureLocation);
 		testAction.perform(publisherInfo, publisherResult, null);
 
-		ILaunchingAdvice launchAdvice = productFileAdviceCapture.getValue();
+		IExecutableAdvice launchAdvice = productFileAdviceCapture.getValue();
 		assertEquals("1.0", "eclipse", launchAdvice.getExecutableName());
 
 		String[] programArgs = launchAdvice.getProgramArguments();
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionWithAdviceFileTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionWithAdviceFileTest.java
index cd5fa6f..77e1847 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionWithAdviceFileTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductActionWithAdviceFileTest.java
@@ -11,12 +11,20 @@
 package org.eclipse.equinox.p2.tests.publisher.actions;
 
 import java.io.File;
-import java.io.IOException;
+import java.net.URI;
 import java.util.Collection;
-import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.internal.provisional.p2.metadata.ITouchpointData;
+import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
+import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
+import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
+import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 import org.eclipse.equinox.p2.publisher.IPublisherResult;
 import org.eclipse.equinox.p2.publisher.PublisherInfo;
+import org.eclipse.equinox.p2.publisher.actions.QueryableFilterAdvice;
 import org.eclipse.equinox.p2.publisher.eclipse.ProductAction;
 import org.eclipse.equinox.p2.tests.TestData;
 
@@ -35,11 +43,61 @@ public class ProductActionWithAdviceFileTest extends ActionTest {
 		setupPublisherResult();
 	}
 
+	class IUQuery extends MatchQuery {
+		IInstallableUnit iu;
+
+		public IUQuery(String id, Version version) {
+			InstallableUnitDescription iuDescription = new InstallableUnitDescription();
+			iuDescription.setId(id);
+			iuDescription.setVersion(version);
+			iu = MetadataFactory.createInstallableUnit(iuDescription);
+		}
+
+		public boolean isMatch(Object candidate) {
+			if (iu.equals(candidate))
+				return true;
+			return false;
+		}
+	}
+
+	public void testProductFileWithRepoAdvice() throws Exception {
+		URI location;
+		try {
+			location = TestData.getFile("ProductActionTest", "contextRepos").toURI();
+		} catch (Exception e) {
+			fail("0.99", e);
+			return;
+		}
+		ProductFile productFile = new ProductFile(TestData.getFile("ProductActionTest", "platform.product").toString());
+		IMetadataRepositoryManager metadataRepositoryManager = getMetadataRepositoryManager();
+		IMetadataRepository repository = metadataRepositoryManager.loadRepository(location, new NullProgressMonitor());
+		testAction = new ProductAction(source, productFile, flavorArg, executablesFeatureLocation);
+		PublisherInfo info = new PublisherInfo();
+		info.setContextMetadataRepository(repository);
+		info.addAdvice(new QueryableFilterAdvice(info.getContextMetadataRepository()));
+
+		testAction.perform(info, publisherResult, null);
+		Collector results = publisherResult.query(new IUQuery("org.eclipse.platform.ide", new Version("3.5.0.I20081118")), new Collector(), null);
+		assertEquals("1.0", 1, results.size());
+		IInstallableUnit unit = (IInstallableUnit) results.iterator().next();
+		IRequiredCapability[] requiredCapabilities = unit.getRequiredCapabilities();
+
+		IRequiredCapability capability = null;
+		for (int i = 0; i < requiredCapabilities.length; i++)
+			if (requiredCapabilities[i].getName().equals("org.eclipse.equinox.p2.user.ui.feature.group")) {
+				capability = requiredCapabilities[i];
+				break;
+			}
+		assertTrue("1.1", capability != null);
+		assertEquals("1.2", "(org.eclipse.update.install.features=true)", capability.getFilter());
+	}
+
 	/**
 	 * Tests publishing a product that contains an advice file (p2.inf)
 	 */
-	public void testProductWithAdviceFile() throws IOException {
-		testAction = new ProductAction(source, TestData.getFile("ProductActionTest/productWithAdvice", "productWithAdvice.product").toString(), flavorArg, executablesFeatureLocation);
+	public void testProductWithAdviceFile() throws Exception {
+		ProductFile productFile = new ProductFile(TestData.getFile("ProductActionTest/productWithAdvice", "productWithAdvice.product").toString());
+		testAction = new ProductAction(source, productFile, flavorArg, executablesFeatureLocation);
 		testAction.perform(new PublisherInfo(), publisherResult, null);
 
 		Collection productIUs = publisherResult.getIUs("productWithAdvice.product", IPublisherResult.NON_ROOT);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductFileAdviceTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductFileAdviceTest.java
new file mode 100644
index 0000000..4568004
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductFileAdviceTest.java
@@ -0,0 +1,153 @@
+/******************************************************************************* 
+* Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+* program and the accompanying materials are made available under the terms of
+* the Eclipse Public License v1.0 which accompanies this distribution, and is
+* available at http://www.eclipse.org/legal/epl-v10.html
+*
+* Contributors:
+*   EclipseSource - initial API and implementation
+******************************************************************************/
+package org.eclipse.equinox.p2.tests.publisher.actions;
+
+import java.io.File;
+import java.util.*;
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile;
+import org.eclipse.equinox.internal.provisional.frameworkadmin.BundleInfo;
+import org.eclipse.equinox.p2.publisher.eclipse.ProductFileAdvice;
+import org.eclipse.equinox.p2.tests.TestData;
+
+/**
+ * Tests the product file advice
+ */
+public class ProductFileAdviceTest extends TestCase {
+
+	String productFileLocation = null;
+	ProductFile productFile = null;
+	ProductFileAdvice productFileAdviceWin32 = null;
+
+	String productFileLocation2 = null;
+	ProductFile productFile2 = null;
+	ProductFileAdvice productFileAdvice2 = null;
+
+	String configFile = "/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productWithConfig/config.ini";
+
+	/* (non-Javadoc)
+	 * @see junit.framework.TestCase#setUp()
+	 */
+	protected void setUp() throws Exception {
+		super.setUp();
+		productFileLocation = TestData.getFile("ProductActionTest/productWithConfig", "sample.product").toString();
+		productFile = new ProductFile(productFileLocation);
+		productFileAdviceWin32 = new ProductFileAdvice(productFile, "x86.win32.*");
+
+		productFileLocation2 = TestData.getFile("ProductActionTest", "productFileActionTest.product").toString();
+		productFile2 = new ProductFile(productFileLocation2);
+		productFileAdvice2 = new ProductFileAdvice(productFile2, "x86.win32.*");
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.p2.publisher.eclipse.ProductFileAdvice#getProgramArguments()}.
+	 */
+	public void testGetProgramArguments() {
+		String[] programArgumentsWin32 = productFileAdviceWin32.getProgramArguments();
+		List listOfArguments = Arrays.asList(programArgumentsWin32);
+		assertEquals("1.0", 1, listOfArguments.size());
+		assertTrue("1.0", listOfArguments.contains("programArg"));
+
+		String[] programArguments2 = productFileAdvice2.getProgramArguments();
+		assertEquals("2.0", 0, programArguments2.length);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.p2.publisher.eclipse.ProductFileAdvice#getVMArguments()}.
+	 */
+	public void testGetVMArguments() {
+		String[] vmArgumentsWin32 = productFileAdviceWin32.getVMArguments();
+		assertEquals("1.0", 1, vmArgumentsWin32.length);
+		assertEquals("1.1", "vmArg", vmArgumentsWin32[0]);
+
+		String[] vmArguments2 = productFileAdvice2.getVMArguments();
+		assertEquals("2.0", 0, vmArguments2.length);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.p2.publisher.eclipse.ProductFileAdvice#getBundles()}.
+	 */
+	public void testGetBundles() {
+		BundleInfo[] bundles = productFileAdviceWin32.getBundles();
+		assertEquals("1.0", 4, bundles.length);
+		for (int i = 0; i < 4; i++) {
+			if (bundles[i].getSymbolicName().equals("org.eclipse.equinox.common")) {
+				assertEquals(2, bundles[i].getStartLevel());
+				assertEquals(true, bundles[i].isMarkedAsStarted());
+			} else if (bundles[i].getSymbolicName().equals("org.eclipse.update.configurator")) {
+				assertEquals(3, bundles[i].getStartLevel());
+				assertEquals(true, bundles[i].isMarkedAsStarted());
+			} else if (bundles[i].getSymbolicName().equals("org.eclipse.core.runtime")) {
+				// nothing yet
+			} else if (bundles[i].getSymbolicName().equals("org.eclipse.swt.win32.win32.x86")) {
+				assertEquals(-1, bundles[i].getStartLevel());
+				assertEquals(false, bundles[i].isMarkedAsStarted());
+			} else
+				fail("unknown bundle: " + bundles[i].getSymbolicName());
+		}
+
+		bundles = productFileAdvice2.getBundles();
+		assertEquals("2.0", 1, bundles.length);
+		for (int i = 0; i < 1; i++) {
+			if (bundles[i].getSymbolicName().equals("org.eclipse.core.commands")) {
+				// nothing yet
+			} else
+				fail("unknown bundle: " + bundles[i].getSymbolicName());
+		}
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.p2.publisher.eclipse.ProductFileAdvice#getProperties()}.
+	 */
+	public void testGetProperties() {
+		Properties properties = productFileAdviceWin32.getProperties();
+		assertEquals("1.0", 6, properties.size());
+		assertEquals("1.2", "bar", properties.get("foo"));
+		assertEquals("1.3", "", properties.get("foo1"));
+		assertEquals("1.4", "true", properties.get("osgi.sharedConfiguration.area.readOnly"));
+		assertEquals("1.5", "/d/sw/java64/jdk1.6.0_03/bin/java", properties.get("eclipse.vm"));
+		assertEquals("1.6", "test.product", properties.get("eclipse.product"));
+		assertEquals("1.1", "org.eclipse.equinox.p2.tests", properties.get("osgi.splashPath"));
+
+		properties = productFileAdvice2.getProperties();
+		assertEquals("2.0", 0, properties.size());
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.p2.publisher.eclipse.ProductFileAdvice#getExecutableName()}.
+	 */
+	public void testGetExecutableName() {
+		assertEquals("1.0", "sample", productFileAdviceWin32.getExecutableName());
+		assertEquals("2.0", null, productFileAdvice2.getExecutableName());
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.p2.publisher.eclipse.ProductFileAdvice#getProductFile()}.
+	 */
+	public void testGetProductFile() {
+		assertEquals("1.0", productFile, productFileAdviceWin32.getProductFile());
+		assertEquals("2.0", productFile2, productFileAdvice2.getProductFile());
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.p2.publisher.eclipse.ProductFileAdvice#getIcons(java.lang.String)}.
+	 */
+	public void testGetIcons() {
+		String[] icons = productFileAdviceWin32.getIcons();
+		String absolutePath = new File(productFile.getLocation().getParentFile(), "test/icon.bmp").getAbsolutePath();
+		assertEquals("1.0", 1, icons.length);
+		assertEquals("1.1", absolutePath, icons[0]);
+
+		icons = productFileAdvice2.getIcons();
+		absolutePath = new File(productFile2.getLocation().getParentFile(), "icon.bmp").getAbsolutePath();
+		assertEquals("2.0", 1, icons.length);
+		assertEquals("2.1", absolutePath, icons[0]);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductFileTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductFileTest.java
new file mode 100644
index 0000000..ae8f038
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ProductFileTest.java
@@ -0,0 +1,190 @@
+/******************************************************************************* 
+* Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+* program and the accompanying materials are made available under the terms of
+* the Eclipse Public License v1.0 which accompanies this distribution, and is
+* available at http://www.eclipse.org/legal/epl-v10.html
+*
+* Contributors:
+*   EclipseSource - initial API and implementation
+******************************************************************************/
+package org.eclipse.equinox.p2.tests.publisher.actions;
+
+import java.io.File;
+import java.util.List;
+import java.util.Properties;
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.p2.publisher.VersionedName;
+import org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile;
+import org.eclipse.equinox.internal.provisional.frameworkadmin.BundleInfo;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.p2.tests.TestData;
+
+/**
+ * Tests the product file parser found in the publisher.
+ */
+public class ProductFileTest extends TestCase {
+
+	String productFileLocation = null;
+	ProductFile productFile = null;
+
+	String configFile = "/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productWithConfig/config.ini";
+
+	protected void setUp() throws Exception {
+		productFileLocation = TestData.getFile("ProductActionTest/productWithConfig", "sample.product").toString();
+		productFile = new ProductFile(productFileLocation);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getLauncherName()}.
+	 */
+	public void testGetLauncherName() {
+		assertEquals("1.0", "sample", productFile.getLauncherName());
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getLocation()}.
+	 */
+	public void testGetLocation() {
+		assertEquals("1.0", productFileLocation, productFile.getLocation().toString());
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getProperties()}.
+	 */
+	public void testGetConfigurationProperties() {
+		Properties properties = productFile.getConfigurationProperties();
+		assertEquals("1.0", 2, properties.size());
+		assertEquals("1.1", "bar", properties.get("foo"));
+		assertEquals("1.2", "", properties.get("foo1"));
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getBundles(boolean)}.
+	 */
+	public void testGetBundles() {
+		List bundles = productFile.getBundles(false);
+		assertEquals("1.0", 1, bundles.size());
+		assertEquals("1.1", "org.eclipse.core.runtime", ((VersionedName) bundles.get(0)).getId());
+		assertEquals("1.2", new Version(1, 0, 4), ((VersionedName) bundles.get(0)).getVersion());
+		bundles = productFile.getBundles(true);
+		assertEquals("1.3", 2, bundles.size());
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getBundleInfos()}.
+	 */
+	public void testGetBundleInfos() {
+		List bundleInfos = productFile.getBundleInfos();
+		BundleInfo info = (BundleInfo) bundleInfos.iterator().next();
+		assertEquals("1.0", 1, bundleInfos.size());
+		assertEquals("1.1", "org.eclipse.core.runtime", info.getSymbolicName());
+		assertEquals("1.2", 2, info.getStartLevel());
+		assertEquals("1.3", true, info.isMarkedAsStarted());
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getFragments()}.
+	 */
+	public void testGetFragments() {
+		List fragments = productFile.getFragments();
+		assertEquals("1.0", 1, fragments.size());
+		assertEquals("1.1", "org.eclipse.swt.win32.win32.x86", ((VersionedName) fragments.get(0)).getId());
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getFeatures()}.
+	 */
+	public void testGetFeatures() {
+		List features = productFile.getFeatures();
+		assertEquals("1.0", 1, features.size());
+		assertEquals("1.1", "org.eclipse.rcp", ((VersionedName) features.get(0)).getId());
+		assertEquals("1.2", new Version("3.5.0.v20081110-9C9tEvNEla71LZ2jFz-RFB-t"), ((VersionedName) features.get(0)).getVersion());
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getIcons(java.lang.String)}.
+	 */
+	public void testGetIcons() {
+		String[] icons = productFile.getIcons("win32");
+		String absolutePath = new File(productFile.getLocation().getParentFile(), "test/icon.bmp").getAbsolutePath();
+		assertEquals("1.0", 1, icons.length);
+		assertEquals("1.1", absolutePath, icons[0]);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getConfigIniPath()}.
+	 */
+	public void testGetConfigIniPath() {
+		String configIni = productFile.getConfigIniPath("win32");
+		assertEquals("1.0", "config.ini", configIni);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getId()}.
+	 */
+	public void testGetId() {
+		String id = productFile.getId();
+		assertEquals("1.0", "test.product", id);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getSplashLocation()}.
+	 */
+	public void testGetSplashLocation() {
+		String splashLocation = productFile.getSplashLocation();
+		assertEquals("1.0", "org.eclipse.equinox.p2.tests", splashLocation);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getProductName()}.
+	 */
+	public void testGetProductName() {
+		String productName = productFile.getProductName();
+		assertEquals("1.0", "aaTestProduct", productName);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getApplication()}.
+	 */
+	public void testGetApplication() {
+		String application = productFile.getApplication();
+		assertEquals("1.0", "test.app", application);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#useFeatures()}.
+	 */
+	public void testUseFeatures() {
+		boolean useFeatures = productFile.useFeatures();
+		assertTrue("1.0", !useFeatures);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getVersion()}.
+	 */
+	public void testGetVersion() {
+		String version = productFile.getVersion();
+		assertEquals("1.0", new Version("1"), new Version(version));
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getVMArguments(java.lang.String)}.
+	 */
+	public void testGetVMArguments() {
+		String vmArguments = productFile.getVMArguments("");
+		assertEquals("1.0", "vmArg", vmArguments);
+		vmArguments = productFile.getVMArguments(null);
+		assertEquals("1.1", "vmArg", vmArguments);
+	}
+
+	/**
+	 * Test method for {@link org.eclipse.equinox.internal.p2.publisher.eclipse.ProductFile#getProgramArguments(java.lang.String)}.
+	 */
+	public void testGetProgramArguments() {
+		String programArguments = productFile.getProgramArguments("");
+		assertEquals("1.0", "programArg", programArguments);
+		programArguments = productFile.getProgramArguments(null);
+		assertEquals("1.1", "programArg", programArguments);
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/contextRepos/content.xml b/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/contextRepos/content.xml
new file mode 100644
index 0000000..b9c4415
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/contextRepos/content.xml
@@ -0,0 +1,40 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<?metadataRepository class='org.eclipse.equinox.internal.p2.metadata.repository.LocalMetadataRepository' version='1.0.0'?>
+<repository name='Good Test Repository' type='org.eclipse.equinox.internal.p2.metadata.repository.LocalMetadataRepository' version='1' description='Good test repository description'>
+  <properties size='3'>
+    <property name='p2.system' value='true'/>
+    <property name='p2.timestamp' value='1221680367875'/>
+    <property name='site.checksum' value='2404093275'/>
+  </properties>
+  <units size='1'>
+    <unit id='org.eclipse.equinox.p2.user.ui.feature.group' version='1.0.0.qualifier'>
+      <provides size='3'>
+        <provided namespace='org.eclipse.equinox.p2.iu' name='test.feature.feature.jar' version='1.0.0'/>
+        <provided namespace='org.eclipse.equinox.p2.eclipse.type' name='feature' version='1.0.0'/>
+        <provided namespace='org.eclipse.update.feature' name='test.feature' version='1.0.0'/>
+      </provides>
+      <filter>
+        (org.eclipse.update.install.features=true)
+      </filter>
+      <artifacts size='1'>
+        <artifact classifier='org.eclipse.update.feature' id='test.feature' version='1.0.0'/>
+      </artifacts>
+      <touchpoint id='org.eclipse.equinox.p2.osgi' version='1.0.0'/>
+      <touchpointData size='1'>
+        <instructions size='1'>
+          <instruction key='zipped'>
+            true
+          </instruction>
+        </instructions>
+      </touchpointData>
+      <licenses size='1'>
+        <license url='http://www.example.com/license'>
+          [Enter License Description here.]
+        </license>
+      </licenses>
+      <copyright url='http://www.example.com/copyright'>
+        [Enter Copyright Description here.]
+      </copyright>
+    </unit>
+  </units>
+</repository>
diff --git a/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productFileActionTest.product b/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productFileActionTest.product
new file mode 100644
index 0000000..863e14c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productFileActionTest.product
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<?pde version="3.5"?>
+
+<product name="SampleProduct" version="1.0.0" useFeatures="false">
+
+
+   <configIni>
+   </configIni>
+
+   <launcherArgs>
+   </launcherArgs>
+
+   <windowImages/>
+
+
+   <launcher>
+      <solaris/>
+      <win useIco="false">
+         <bmp
+            winSmallLow="icon.bmp"/>
+      </win>
+   </launcher>
+
+
+   <vm>
+   </vm>
+
+   <plugins>
+      <plugin id="org.eclipse.core.commands" version="5.0.0"/>
+   </plugins>
+
+   <configurations>
+      <plugin id="org.eclipse.core.commands" autoStart="false" startLevel="2" />
+   </configurations>
+
+</product>
diff --git a/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productWithConfig/config.ini b/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productWithConfig/config.ini
new file mode 100644
index 0000000..6bd3c88
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productWithConfig/config.ini
@@ -0,0 +1,3 @@
+osgi.sharedConfiguration.area.readOnly=true
+eclipse.vm=/d/sw/java64/jdk1.6.0_03/bin/java
+osgi.bundles=org.eclipse.equinox.common@2:start, org.eclipse.update.configurator@3:start
diff --git a/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productWithConfig/sample.product b/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productWithConfig/sample.product
new file mode 100644
index 0000000..2e56d24
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/testData/ProductActionTest/productWithConfig/sample.product
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<?pde version="3.5"?>
+
+<product name="aaTestProduct" id="test.product" application="test.app" version="1" useFeatures="false">
+
+   <configIni use="default">
+      <win32>config.ini</win32>
+   </configIni>
+
+   <launcherArgs>
+      <programArgs>programArg</programArgs>
+      <vmArgs>vmArg</vmArgs>
+      <vmArgsMac>-XstartOnFirstThread -Dorg.eclipse.swt.internal.carbon.smallFonts</vmArgsMac>
+   </launcherArgs>
+
+   <windowImages/>
+
+   <splash
+      location="org.eclipse.equinox.p2.tests"
+      startupProgressRect="5,275,445,15"
+      startupMessageRect="7,252,445,20"
+      startupForegroundColor="000000" />
+   <launcher name="sample">
+      <solaris/>
+      <win useIco="false">
+         <bmp
+            winSmallLow="/test/icon.bmp"/>
+      </win>
+   </launcher>
+
+   <vm>
+   </vm>
+
+   <plugins>
+      <plugin id="org.eclipse.core.runtime" version="1.0.4"/>
+      <plugin id="org.eclipse.swt.win32.win32.x86" fragment="true"/>
+   </plugins>
+
+   <features>
+      <feature id="org.eclipse.rcp" version="3.5.0.v20081110-9C9tEvNEla71LZ2jFz-RFB-t"/>
+   </features>
+
+   <configurations>
+      <plugin id="org.eclipse.core.runtime" autoStart="true" startLevel="2" />
+      <property name = "foo" value="bar"/>
+      <property name = "foo1" />
+      <property value="bar1"/>
+   </configurations>
+
+</product>
