commit 6df0aff993d6ccbe4abeb7f577b623f181475456
Author: John Arthorne <johna>
Date:   Mon Nov 19 21:58:31 2007 +0000

    Bug 209992 [prov] IQueryable, take two

1	0	bundles/org.eclipse.equinox.p2.console/META-INF/MANIFEST.MF
18	12	bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvCommandProvider.java
15	37	bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvisioningHelper.java
23	3	bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
95	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/Collector.java
67	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/CompoundQuery.java
36	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/IQueryable.java
53	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/Query.java
1	0	bundles/org.eclipse.equinox.p2.director.app/META-INF/MANIFEST.MF
96	95	bundles/org.eclipse.equinox.p2.director.app/src/org/eclipse/equinox/internal/p2/director/app/Application.java
1	0	bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
30	0	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/HasMatchCollector.java
5	3	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
5	2	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OperationGenerator.java
4	1	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
3	2	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/p2/director/ProvisioningPlan.java
18	22	bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/p2/directorywatcher/RepositoryListener.java
3	10	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Profile.java
7	3	bundles/org.eclipse.equinox.p2.installer/src/org/eclipse/equinox/internal/p2/installer/InstallUpdateProductOperation.java
18	17	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
4	9	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/URLMetadataRepository.java
17	10	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/p2/metadata/repository/IMetadataRepository.java
4	1	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/spi/p2/metadata/repository/AbstractMetadataRepository.java
8	2	bundles/org.eclipse.equinox.p2.metadata/META-INF/MANIFEST.MF
5	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/ProvidedCapability.java
70	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/query/CapabilityQuery.java
79	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/query/InstallableUnitQuery.java
0	98	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/CompoundIterator.java
0	25	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/IQueryable.java
0	73	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/Query.java
0	47	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/QueryableArray.java
1	0	bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
11	17	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/TestMetadataRepository.java
7	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UninstallTest.java
6	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/full/DirectorTest.java
7	5	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/full/End2EndTest.java
diff --git a/bundles/org.eclipse.equinox.p2.console/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.console/META-INF/MANIFEST.MF
index f1bd150..62d793c 100644
--- a/bundles/org.eclipse.equinox.p2.console/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.console/META-INF/MANIFEST.MF
@@ -17,6 +17,7 @@ Import-Package: org.eclipse.core.runtime;common=split,
  org.eclipse.equinox.p2.director,
  org.eclipse.equinox.p2.engine,
  org.eclipse.equinox.p2.metadata,
+ org.eclipse.equinox.p2.metadata.query,
  org.eclipse.equinox.p2.metadata.repository,
  org.eclipse.equinox.p2.query,
  org.eclipse.osgi.framework.console;version="1.0.0";resolution:=optional,
diff --git a/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvCommandProvider.java b/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvCommandProvider.java
index 060c0e4..fedcd6e 100644
--- a/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvCommandProvider.java
+++ b/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvCommandProvider.java
@@ -19,8 +19,10 @@ import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.engine.IProfileRegistry;
 import org.eclipse.equinox.p2.engine.Profile;
 import org.eclipse.equinox.p2.metadata.*;
+import org.eclipse.equinox.p2.metadata.query.CapabilityQuery;
+import org.eclipse.equinox.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
-import org.eclipse.equinox.p2.query.Query;
+import org.eclipse.equinox.p2.query.*;
 import org.eclipse.osgi.framework.console.CommandInterpreter;
 import org.eclipse.osgi.framework.console.CommandProvider;
 import org.eclipse.osgi.service.resolver.VersionRange;
@@ -30,8 +32,8 @@ import org.eclipse.osgi.service.resolver.VersionRange;
  * with the provisioning system.
  */
 public class ProvCommandProvider implements CommandProvider {
+	private static final String WILDCARD_ANY = "*"; //$NON-NLS-1$
 	public static final String NEW_LINE = System.getProperty("line.separator", "\n"); //$NON-NLS-1$ //$NON-NLS-2$
-	private static final String IU_KIND_NAMESPACE = "org.eclipse.equinox.p2.type";
 
 	//	private Profile profile;
 
@@ -130,8 +132,7 @@ public class ProvCommandProvider implements CommandProvider {
 	}
 
 	/**
-	 * Lists the known metadata repositories, or the contents of a given
-	 * metadata repository.
+	 * Lists the installable units that match the given URL, id, and/or version.
 	 * 
 	 * @param interpreter
 	 */
@@ -140,9 +141,9 @@ public class ProvCommandProvider implements CommandProvider {
 		String id = processArgument(interpreter.nextArgument());
 		String version = processArgument(interpreter.nextArgument());
 		URL repoURL = null;
-		if (urlString != null && !urlString.equals("*"))
+		if (urlString != null && !urlString.equals(WILDCARD_ANY))
 			repoURL = toURL(interpreter, urlString);
-		IInstallableUnit[] units = sort(ProvisioningHelper.getInstallableUnits(repoURL, id, new VersionRange(version), null));
+		IInstallableUnit[] units = sort(ProvisioningHelper.getInstallableUnits(repoURL, new InstallableUnitQuery(id, new VersionRange(version)), null));
 		for (int i = 0; i < units.length; i++)
 			println(interpreter, units[i]);
 	}
@@ -168,7 +169,7 @@ public class ProvCommandProvider implements CommandProvider {
 		URL repoURL = toURL(interpreter, urlString);
 		if (repoURL == null)
 			return;
-		IInstallableUnit[] units = sort(ProvisioningHelper.getInstallableUnits(repoURL, id, new VersionRange(version), null));
+		IInstallableUnit[] units = sort(ProvisioningHelper.getInstallableUnits(repoURL, new InstallableUnitQuery(id, new VersionRange(version)), null));
 		for (int i = 0; i < units.length; i++)
 			println(interpreter, units[i]);
 	}
@@ -196,8 +197,12 @@ public class ProvCommandProvider implements CommandProvider {
 				return;
 			repositories = new IMetadataRepository[] {repo};
 		}
-		RequiredCapability requirement = new RequiredCapability(IU_KIND_NAMESPACE, "group", null, null, false, false);
-		IInstallableUnit[] units = sort(Query.query(repositories, null, null, new RequiredCapability[] {requirement}, false, null));
+		RequiredCapability requirement = new RequiredCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", null, null, false, false); //$NON-NLS-1$
+		Query query = new CapabilityQuery(requirement);
+		Collector result = new Collector();
+		for (int i = 0; i < repositories.length; i++)
+			repositories[i].query(query, result, null);
+		IInstallableUnit[] units = sort(result);
 		for (int i = 0; i < units.length; i++)
 			println(interpreter, units[i]);
 	}
@@ -262,7 +267,7 @@ public class ProvCommandProvider implements CommandProvider {
 	}
 
 	private String processArgument(String arg) {
-		if (arg == null || arg.equals("*"))
+		if (arg == null || arg.equals(WILDCARD_ANY))
 			return null;
 		return arg;
 	}
@@ -291,12 +296,13 @@ public class ProvCommandProvider implements CommandProvider {
 			return;
 
 		// list the profile contents
-		IInstallableUnit[] result = sort(Query.query(new Profile[] {target}, id, new VersionRange(range), null, false, null));
+		IInstallableUnit[] result = sort(target.query(new InstallableUnitQuery(id, new VersionRange(range)), new Collector(), null));
 		for (int i = 0; i < result.length; i++)
 			interpreter.println(result[i]);
 	}
 
-	private IInstallableUnit[] sort(IInstallableUnit[] units) {
+	private IInstallableUnit[] sort(Collector collector) {
+		IInstallableUnit[] units = (IInstallableUnit[]) collector.toArray(IInstallableUnit.class);
 		Arrays.sort(units, new Comparator() {
 			public int compare(Object arg0, Object arg1) {
 				return arg0.toString().compareTo(arg1.toString());
diff --git a/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvisioningHelper.java b/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvisioningHelper.java
index 2ea30f7..a92c65f 100644
--- a/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvisioningHelper.java
+++ b/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvisioningHelper.java
@@ -26,10 +26,9 @@ import org.eclipse.equinox.p2.engine.*;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepositoryManager;
-import org.eclipse.equinox.p2.query.CompoundIterator;
+import org.eclipse.equinox.p2.query.Collector;
 import org.eclipse.equinox.p2.query.Query;
 import org.eclipse.osgi.service.environment.EnvironmentInfo;
-import org.eclipse.osgi.service.resolver.VersionRange;
 import org.osgi.framework.Version;
 
 public class ProvisioningHelper {
@@ -145,47 +144,26 @@ public class ProvisioningHelper {
 	}
 
 	/**
-	 * Returns the installable units with the given id and version
-	 * specifications in the given metadata repository.  <code>null</code>
-	 * can be used to indicate wildcards for any of the arguments.
+	 * Returns the installable units that match the given query
+	 * in the given metadata repository.
 	 * 
-	 * @param location The location of the metdata repo to search.  <code>null</code> indicates
+	 * @param location The location of the metadata repo to search.  <code>null</code> indicates
 	 *        search all known repos.
-	 * @param id The id of the IUs to find. <code>null</code> indicates
-	 *        wildcard.
-	 * @param range The version range of the IUs to find. <code>null</code>
-	 *        indicates wildcard.
+	 * @param query The query to perform
+	 * @param monitor A progress monitor, or <code>null</code>
 	 * @return The IUs that match the query
 	 */
-	public static IInstallableUnit[] getInstallableUnits(URL location, String id, VersionRange range, IProgressMonitor progress) {
+	public static Collector getInstallableUnits(URL location, Query query, IProgressMonitor monitor) {
 		IMetadataRepository[] repositories = null;
-		if (location == null)
+		Collector collector = new Collector();
+		if (location == null) {
 			repositories = getMetadataRepositories();
-		else
-			repositories = new IMetadataRepository[] {getMetadataRepository(location)};
-		Iterator i = Query.getIterator(repositories, id, range, null, false);
-		return CompoundIterator.asArray(i, progress);
-	}
-
-	/**
-	 * Returns the installable units with the given id and version
-	 * specifications.
-	 * 
-	 * @param profileId The profile to search
-	 * @param id The id of the IUs to find. <code>null</code> indicates
-	 *        wildcard.
-	 * @param range The version range of the IUs to find. <code>null</code>
-	 *        indicates wildcard.
-	 * @return The IUs that match the query
-	 */
-	public static IInstallableUnit[] getInstallableUnits(String profileId, String id, VersionRange range, IProgressMonitor progress) {
-		Profile[] profiles = null;
-		if (profileId == null)
-			profiles = getProfiles();
-		else
-			profiles = new Profile[] {getProfile(profileId)};
-		Iterator i = Query.getIterator(profiles, id, range, null, false);
-		return CompoundIterator.asArray(i, progress);
+			for (int i = 0; i < repositories.length; i++)
+				repositories[i].query(query, collector, monitor);
+		} else {
+			getMetadataRepository(location).query(query, collector, null);
+		}
+		return collector;
 	}
 
 	public static IMetadataRepository[] getMetadataRepositories() {
diff --git a/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
index 6243db4..7869520 100644
--- a/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
@@ -16,14 +16,34 @@ Import-Package: org.eclipse.core.runtime.adaptor,
  org.osgi.util.tracker;version="1.3.3",
  org.xml.sax
 Export-Package: org.eclipse.equinox.internal.p2.core;x-internal:=true,
- org.eclipse.equinox.internal.p2.core.helpers;x-friends:="org.eclipse.equinox.p2.director,org.eclipse.equinox.p2.artifact.processors,org.eclipse.equinox.p2.artifact.optimizers,org.eclipse.equinox.p2.artifact.repository,
- org.eclipse.equinox.p2.director.app,org.eclipse.equinox.p2.directorywatcher,org.eclipse.equinox.p2.download,org.eclipse.equinox.p2.engine,org.eclipse.equinox.p2.installer,org.eclipse.equinox.p2.metadata,org.eclipse.equinox.p2.metadata.generator,org.eclipse.equinox.frameworkadmin.test,
- org.eclipse.equinox.p2.metadata.repository,org.eclipse.equinox.p2.repositoryoptimizer,org.eclipse.equinox.p2.touchpoint.eclipse,org.eclipse.equinox.p2.touchpoint.natives,org.eclipse.equinox.p2.ui,org.eclipse.equinox.p2.ui.sdk,org.eclipse.equinox.p2.updatechecker,org.eclipse.equinox.p2.updatechecker.app,org.eclipse.equinox.p2.console",
+ org.eclipse.equinox.internal.p2.core.helpers;
+  x-friends:="org.eclipse.equinox.p2.director,
+   org.eclipse.equinox.p2.artifact.processors,
+   org.eclipse.equinox.p2.artifact.optimizers,
+   org.eclipse.equinox.p2.artifact.repository,
+   org.eclipse.equinox.p2.director.app,
+   org.eclipse.equinox.p2.directorywatcher,
+   org.eclipse.equinox.p2.download,
+   org.eclipse.equinox.p2.engine,
+   org.eclipse.equinox.p2.installer,
+   org.eclipse.equinox.p2.metadata,
+   org.eclipse.equinox.p2.metadata.generator,
+   org.eclipse.equinox.frameworkadmin.test,
+   org.eclipse.equinox.p2.metadata.repository,
+   org.eclipse.equinox.p2.repositoryoptimizer,
+   org.eclipse.equinox.p2.touchpoint.eclipse,
+   org.eclipse.equinox.p2.touchpoint.natives,
+   org.eclipse.equinox.p2.ui,
+   org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.updatechecker,
+   org.eclipse.equinox.p2.updatechecker.app,
+   org.eclipse.equinox.p2.console",
  org.eclipse.equinox.internal.p2.persistence;x-friends:="org.eclipse.equinox.p2.artifact.repository,org.eclipse.equinox.p2.engine,org.eclipse.equinox.p2.metadata.repository",
  org.eclipse.equinox.p2.core,
  org.eclipse.equinox.p2.core.eventbus,
  org.eclipse.equinox.p2.core.location,
  org.eclipse.equinox.p2.core.repository,
+ org.eclipse.equinox.p2.query,
  org.eclipse.equinox.spi.p2.core.repository
 Eclipse-LazyStart: true
 Bundle-ClassPath: .
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/Collector.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/Collector.java
new file mode 100644
index 0000000..66ae25b
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/Collector.java
@@ -0,0 +1,95 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.query;
+
+import java.lang.reflect.Array;
+import java.util.*;
+
+/**
+ * A collector is a generic visitor that collects objects passed to it,
+ * and can then express the result of the visit in various forms. The collector
+ * can also short-circuit a traversal by returning <code>false</code> from
+ * its {@link #accept(Object)} method.
+ * <p>
+ * This default collector just accepts all objects passed to it.  Clients may subclass
+ * to perform different processing on the objects passed to it.
+ */
+public class Collector {
+	private ArrayList collected = null;
+
+	/**
+	 * Creates a new collector.
+	 */
+	public Collector() {
+		super();
+	}
+
+	/**
+	 * Accepts an object.
+	 * <p>
+	 * This default implementation adds the objects to a list. Clients may
+	 * override this method to perform additional filtering, add different objects 
+	 * to the list, short-circuit the traversal, or process the objects directly without 
+	 * collecting them.
+	 * 
+	 * @param object the object to collect or visit
+	 * @return <code>true</code> if the traversal should continue,
+	 * or <code>false</code> to indicate the traversal should stop.
+	 */
+	public boolean accept(Object object) {
+		getList().add(object);
+		return true;
+	}
+
+	/**
+	 * Returns the list that is being used to collect results.
+	 * @return the list being used to collect results.
+	 */
+	protected List getList() {
+		if (collected == null)
+			collected = new ArrayList();
+		return collected;
+	}
+
+	/**
+	 * Returns whether this collector is empty.
+	 * @return <code>true</code> if this collector has accepted any results,
+	 * and <code>false</code> otherwise.
+	 */
+	public boolean isEmpty() {
+		return collected == null || collected.isEmpty();
+	}
+
+	/**
+	 * Returns an iterator on the collected objects.
+	 * 
+	 * @return an iterator of the collected objects.
+	 */
+	public Iterator iterator() {
+		return collected == null ? Collections.EMPTY_LIST.iterator() : collected.iterator();
+	}
+
+	/**
+	 * Returns the collected objects as an array
+	 * 
+	 * @param clazz The type of array to return
+	 * @return The array of results
+	 * @throws ArrayStoreException the runtime type of the specified array is
+	 *         not a supertype of the runtime type of every collected object
+	 */
+	public Object[] toArray(Class clazz) {
+		int size = collected == null ? 0 : collected.size();
+		Object[] result = (Object[]) Array.newInstance(clazz, size);
+		if (size != 0)
+			collected.toArray(result);
+		return result;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/CompoundQuery.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/CompoundQuery.java
new file mode 100644
index 0000000..f755b7d
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/CompoundQuery.java
@@ -0,0 +1,67 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.query;
+
+/**
+ * A query that combines a group of other queries.
+ */
+public class CompoundQuery extends Query {
+	private boolean and;
+	private Query[] queries;
+
+	/**
+	 * Creates a compound query that combines the given queries. The queries
+	 * will be performed by the compound query in the given order. This method
+	 * might not perform all queries if it can determine the result of the compound
+	 * expression without doing so.
+	 * 
+	 * @param queries The queries to perform
+	 * @param and <code>true</code> if this query represents a logical 'and', and
+	 * <code>false</code> if this query represents a logical 'or'.
+	 */
+	public CompoundQuery(Query[] queries, boolean and) {
+		this.queries = queries;
+		this.and = and;
+	}
+
+	public Query[] getQueries() {
+		return queries;
+	}
+
+	/**
+	 * Returns whether this compound query combines its queries with a logical
+	 * 'and' or 'or'.
+	 * @return <code>true</code> if this query represents a logical 'and', and
+	 * <code>false</code> if this query represents a logical 'or'.
+	 */
+	public boolean isAnd() {
+		return and;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.equinox.p2.query2.Query#isMatch(java.lang.Object)
+	 */
+	public boolean isMatch(Object candidate) {
+		for (int i = 0; i < queries.length; i++) {
+			boolean valid = queries[i].isMatch(candidate);
+			// if we are OR'ing then the first time we find a requirement that is met, return success
+			if (valid && !and)
+				return true;
+			// if we are AND'ing then the first time we find a requirement that is NOT met, return failure
+			if (!valid && and)
+				return false;
+		}
+		// if we get past the requirements check and we are AND'ing then return true 
+		// since all requirements must have been met.  If we are OR'ing then return false 
+		// since none of the requirements were met.
+		return and;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/IQueryable.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/IQueryable.java
new file mode 100644
index 0000000..b40c3e1
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/IQueryable.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.query;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+
+/**
+ * An IQueryable contains objects, and is able to perform queries on those objects.
+ * <p>
+ * This interface may be implemented by clients.
+ */
+public interface IQueryable {
+	/**
+	 * Performs a query, passing any objects that satisfy the
+	 * query to the provided collector.
+	 * <p>
+	 * This method is long-running; progress and cancellation are provided
+	 * by the given progress monitor. 
+	 * </p>
+	 * 
+	 * @param query The query to perform
+	 * @param collector Collects the results of the query
+	 * @param monitor a progress monitor, or <code>null</code> if progress
+	 *    reporting is not desired
+	 * @return The collector argument
+	 */
+	public Collector query(Query query, Collector collector, IProgressMonitor monitor);
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/Query.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/Query.java
new file mode 100644
index 0000000..3e619a5
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/p2/query/Query.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.query;
+
+import java.util.Iterator;
+
+/**
+ * The superclass of all queries that can be performed on an {@link IQueryable}.
+ * <p>
+ * This class may be subclassed by clients. Subclasses should specify the type
+ * of object they support querying on. Subclasses are also encouraged to clearly
+ * specify their match algorithm, and expose the parameters involved in the match
+ * computation, to allow {@link IQueryable} implementations to optimize their
+ * execution of the query.
+ */
+public abstract class Query {
+	/**
+	 * Creates a new query.
+	 */
+	public Query() {
+		super();
+	}
+
+	/**
+	 * Returns whether the given object satisfies the parameters of this query.
+	 * 
+	 * @param candidate The object to perform the query against
+	 * @return <code>true</code> if the unit satisfies the parameters
+	 * of this query, and <code>false</code> otherwise
+	 */
+	public abstract boolean isMatch(Object candidate);
+
+	/**
+	 * Performs this query on the given iterator, passing all objects in the iterator 
+	 * that match the criteria of this query to the given result.
+	 */
+	public Collector perform(Iterator iterator, Collector result) {
+		while (iterator.hasNext()) {
+			Object candidate = iterator.next();
+			if (isMatch(candidate))
+				result.accept(candidate);
+		}
+		return result;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.director.app/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.director.app/META-INF/MANIFEST.MF
index 14f4df4..89fdc4e 100644
--- a/bundles/org.eclipse.equinox.p2.director.app/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.director.app/META-INF/MANIFEST.MF
@@ -14,6 +14,7 @@ Import-Package: org.eclipse.equinox.app,
  org.eclipse.equinox.p2.engine,
  org.eclipse.equinox.p2.engine.phases,
  org.eclipse.equinox.p2.metadata,
+ org.eclipse.equinox.p2.metadata.query,
  org.eclipse.equinox.p2.metadata.repository,
  org.eclipse.equinox.p2.query,
  org.eclipse.osgi.service.environment,
diff --git a/bundles/org.eclipse.equinox.p2.director.app/src/org/eclipse/equinox/internal/p2/director/app/Application.java b/bundles/org.eclipse.equinox.p2.director.app/src/org/eclipse/equinox/internal/p2/director/app/Application.java
index 5dfc0e2..d8baaba 100644
--- a/bundles/org.eclipse.equinox.p2.director.app/src/org/eclipse/equinox/internal/p2/director/app/Application.java
+++ b/bundles/org.eclipse.equinox.p2.director.app/src/org/eclipse/equinox/internal/p2/director/app/Application.java
@@ -21,9 +21,9 @@ import org.eclipse.equinox.p2.director.*;
 import org.eclipse.equinox.p2.engine.*;
 import org.eclipse.equinox.p2.engine.phases.Sizing;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
-import org.eclipse.equinox.p2.query.IQueryable;
-import org.eclipse.equinox.p2.query.Query;
+import org.eclipse.equinox.p2.query.Collector;
 import org.eclipse.osgi.service.resolver.VersionRange;
 import org.osgi.framework.Version;
 
@@ -47,86 +47,19 @@ public class Application implements IApplication {
 	private boolean roamingProfile = false;
 	private Version version = null;
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.eclipse.equinox.app.IApplication#start(org.eclipse.equinox.app.IApplicationContext)
-	 */
-	public Object start(IApplicationContext context) throws Exception {
-		return run((String[]) context.getArguments().get("application.args"));
-	}
-
-	public Object run(String[] args) throws Exception {
-		long time = -System.currentTimeMillis();
-		initializeFromArguments(args);
-
-		Properties props = new Properties();
-		props.setProperty(Profile.PROP_INSTALL_FOLDER, destination);
-		props.setProperty(Profile.PROP_FLAVOR, flavor);
-		if (bundlePool != null)
-			if (bundlePool.equals("<destination>"))
-				props.setProperty("eclipse.p2.cache", destination);
-			else
-				props.setProperty("eclipse.p2.cache", bundlePool);
-		if (roamingProfile)
-			props.setProperty("eclipse.p2.roaming", "true");
-
-		String env = getEnvironmentProperty();
-		if (env != null)
-			props.setProperty(Profile.PROP_ENVIRONMENTS, env);
-		Profile profile = ProvisioningHelper.addProfile(profileId, props);
-		String currentFlavor = profile.getValue(Profile.PROP_FLAVOR);
-		if (currentFlavor != null && !currentFlavor.endsWith(flavor))
-			throw new RuntimeException("Install flavor not consistent with profile flavor");
-
-		IDirector director = (IDirector) ServiceHelper.getService(Activator.getContext(), IDirector.class.getName());
-		if (director == null)
-			throw new RuntimeException("Director could not be loaded");
-
-		IPlanner planner = (IPlanner) ServiceHelper.getService(Activator.getContext(), IPlanner.class.getName());
-		if (planner == null)
-			throw new RuntimeException("Planner could not be loaded");
-
-		Engine engine = (Engine) ServiceHelper.getService(Activator.getContext(), Engine.class.getName());
-		if (engine == null)
-			throw new RuntimeException("Engine could not be loaded");
-
-		ProvisioningHelper.addArtifactRepository(artifactRepositoryLocation);
-		IMetadataRepository metadataRepository = ProvisioningHelper.addMetadataRepository(metadataRepositoryLocation);
-		IInstallableUnit[] roots = Query.query(new IQueryable[] {metadataRepository}, root, version == null ? null : new VersionRange(version, true, version, true), null, false, null);
-		ProvisioningPlan result = null;
-		IStatus operationStatus = null;
-		if (roots.length > 0) {
-			if (install) {
-				result = planner.getInstallPlan(roots, profile, new NullProgressMonitor());
-			} else {
-				result = planner.getUninstallPlan(roots, profile, new NullProgressMonitor());
-			}
-			if (!result.getStatus().isOK())
-				operationStatus = result.getStatus();
-			else {
-				Sizing sizeComputer = new Sizing(100, "Compute sizes"); //$NON-NLS-1$
-				PhaseSet set = new PhaseSet(new Phase[] {sizeComputer}) {};
-				operationStatus = engine.perform(profile, set, result.getOperands(), new NullProgressMonitor());
-				System.out.println("Estimated size on disk " + sizeComputer.getDiskSize());
-				System.out.println("Estimated download size " + sizeComputer.getDlSize());
-				operationStatus = engine.perform(profile, new DefaultPhaseSet(), result.getOperands(), new NullProgressMonitor());
-			}
-		} else {
-			operationStatus = new Status(IStatus.INFO, "org.eclipse.equinox.p2.director.test", "The installable unit '" + root + "' has not been found");
-		}
-
-		time += System.currentTimeMillis();
-		if (operationStatus.isOK()) {
-			System.out.println((install ? "installation" : "uninstallation") + " complete (" + time + "ms)");
-		} else {
-			System.out.println((install ? "installation" : "uninstallation") + " failed. " + operationStatus);
-			LogHelper.log(operationStatus);
-		}
-		return null;
-	}
-
-	public void stop() {
+	private String getEnvironmentProperty() {
+		Properties values = new Properties();
+		if (os != null)
+			values.put("osgi.os", os);
+		if (nl != null)
+			values.put("osgi.nl", nl);
+		if (ws != null)
+			values.put("osgi.ws", ws);
+		if (arch != null)
+			values.put("osgi.arch", arch);
+		if (values.isEmpty())
+			return null;
+		return toString(values);
 	}
 
 	public void initializeFromArguments(String[] args) throws Exception {
@@ -200,19 +133,87 @@ public class Application implements IApplication {
 		}
 	}
 
-	private String getEnvironmentProperty() {
-		Properties values = new Properties();
-		if (os != null)
-			values.put("osgi.os", os);
-		if (nl != null)
-			values.put("osgi.nl", nl);
-		if (ws != null)
-			values.put("osgi.ws", ws);
-		if (arch != null)
-			values.put("osgi.arch", arch);
-		if (values.isEmpty())
-			return null;
-		return toString(values);
+	public Object run(String[] args) throws Exception {
+		long time = -System.currentTimeMillis();
+		initializeFromArguments(args);
+
+		Properties props = new Properties();
+		props.setProperty(Profile.PROP_INSTALL_FOLDER, destination);
+		props.setProperty(Profile.PROP_FLAVOR, flavor);
+		if (bundlePool != null)
+			if (bundlePool.equals("<destination>"))
+				props.setProperty("eclipse.p2.cache", destination);
+			else
+				props.setProperty("eclipse.p2.cache", bundlePool);
+		if (roamingProfile)
+			props.setProperty("eclipse.p2.roaming", "true");
+
+		String env = getEnvironmentProperty();
+		if (env != null)
+			props.setProperty(Profile.PROP_ENVIRONMENTS, env);
+		Profile profile = ProvisioningHelper.addProfile(profileId, props);
+		String currentFlavor = profile.getValue(Profile.PROP_FLAVOR);
+		if (currentFlavor != null && !currentFlavor.endsWith(flavor))
+			throw new RuntimeException("Install flavor not consistent with profile flavor");
+
+		IDirector director = (IDirector) ServiceHelper.getService(Activator.getContext(), IDirector.class.getName());
+		if (director == null)
+			throw new RuntimeException("Director could not be loaded");
+
+		IPlanner planner = (IPlanner) ServiceHelper.getService(Activator.getContext(), IPlanner.class.getName());
+		if (planner == null)
+			throw new RuntimeException("Planner could not be loaded");
+
+		Engine engine = (Engine) ServiceHelper.getService(Activator.getContext(), Engine.class.getName());
+		if (engine == null)
+			throw new RuntimeException("Engine could not be loaded");
+
+		ProvisioningHelper.addArtifactRepository(artifactRepositoryLocation);
+		IMetadataRepository metadataRepository = ProvisioningHelper.addMetadataRepository(metadataRepositoryLocation);
+		VersionRange range = version == null ? VersionRange.emptyRange : new VersionRange(version, true, version, true);
+		IInstallableUnit[] roots = (IInstallableUnit[]) metadataRepository.query(new InstallableUnitQuery(root, range), new Collector(), null).toArray(IInstallableUnit.class);
+		ProvisioningPlan result = null;
+		IStatus operationStatus = null;
+		if (roots.length > 0) {
+			if (install) {
+				result = planner.getInstallPlan(roots, profile, new NullProgressMonitor());
+			} else {
+				result = planner.getUninstallPlan(roots, profile, new NullProgressMonitor());
+			}
+			if (!result.getStatus().isOK())
+				operationStatus = result.getStatus();
+			else {
+				Sizing sizeComputer = new Sizing(100, "Compute sizes"); //$NON-NLS-1$
+				PhaseSet set = new PhaseSet(new Phase[] {sizeComputer}) {};
+				operationStatus = engine.perform(profile, set, result.getOperands(), new NullProgressMonitor());
+				System.out.println("Estimated size on disk " + sizeComputer.getDiskSize());
+				System.out.println("Estimated download size " + sizeComputer.getDlSize());
+				operationStatus = engine.perform(profile, new DefaultPhaseSet(), result.getOperands(), new NullProgressMonitor());
+			}
+		} else {
+			operationStatus = new Status(IStatus.INFO, "org.eclipse.equinox.p2.director.test", "The installable unit '" + root + "' has not been found");
+		}
+
+		time += System.currentTimeMillis();
+		if (operationStatus.isOK()) {
+			System.out.println((install ? "installation" : "uninstallation") + " complete (" + time + "ms)");
+		} else {
+			System.out.println((install ? "installation" : "uninstallation") + " failed. " + operationStatus);
+			LogHelper.log(operationStatus);
+		}
+		return null;
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.eclipse.equinox.app.IApplication#start(org.eclipse.equinox.app.IApplicationContext)
+	 */
+	public Object start(IApplicationContext context) throws Exception {
+		return run((String[]) context.getArguments().get("application.args"));
+	}
+
+	public void stop() {
 	}
 
 	private String toString(Properties context) {
diff --git a/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
index 3aba458..e48b69a 100644
--- a/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
@@ -11,6 +11,7 @@ Import-Package: org.eclipse.equinox.internal.p2.core.helpers,
  org.eclipse.equinox.p2.core.repository,
  org.eclipse.equinox.p2.engine,
  org.eclipse.equinox.p2.metadata,
+ org.eclipse.equinox.p2.metadata.query,
  org.eclipse.equinox.p2.metadata.repository,
  org.eclipse.equinox.p2.query,
  org.eclipse.osgi.service.resolver;version="1.1.0",
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/HasMatchCollector.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/HasMatchCollector.java
new file mode 100644
index 0000000..e2449f1
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/HasMatchCollector.java
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.director;
+
+import org.eclipse.equinox.p2.query.Collector;
+
+/**
+ * A collector that short-circuits on the first match.
+ */
+public class HasMatchCollector extends Collector {
+	private boolean hasMatch = false;
+
+	public boolean accept(Object object) {
+		hasMatch = true;
+		return false;
+	}
+
+	public boolean isEmpty() {
+		return !hasMatch;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
index 69e7203..2c05392 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
@@ -14,7 +14,8 @@ import org.eclipse.equinox.internal.p2.resolution.ResolutionHelper;
 import org.eclipse.equinox.internal.p2.resolution.UnsatisfiedCapability;
 import org.eclipse.equinox.p2.engine.Profile;
 import org.eclipse.equinox.p2.metadata.*;
-import org.eclipse.equinox.p2.query.CompoundIterator;
+import org.eclipse.equinox.p2.metadata.query.CapabilityQuery;
+import org.eclipse.equinox.p2.query.Collector;
 import org.eclipse.osgi.service.resolver.VersionRange;
 import org.eclipse.osgi.util.NLS;
 import org.osgi.framework.InvalidSyntaxException;
@@ -589,8 +590,9 @@ public class NewDependencyExpander {
 	}
 
 	private IInstallableUnit match(Collection close, IInstallableUnit picked) {
-		CompoundIterator it = new CompoundIterator(new Iterator[] {close.iterator()}, null, null, picked.getRequiredCapabilities(), true);
-		if (it.hasNext())
+		Collector result = new HasMatchCollector();
+		new CapabilityQuery(picked.getRequiredCapabilities()).perform(close.iterator(), result);
+		if (!result.isEmpty())
 			return picked;
 		return null;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OperationGenerator.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OperationGenerator.java
index 7018cfc..232c874 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OperationGenerator.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OperationGenerator.java
@@ -12,7 +12,8 @@ import java.util.*;
 import org.eclipse.equinox.p2.engine.Operand;
 import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.metadata.MetadataFactory.InstallableUnitDescription;
-import org.eclipse.equinox.p2.query.CompoundIterator;
+import org.eclipse.equinox.p2.metadata.query.InstallableUnitQuery;
+import org.eclipse.equinox.p2.query.Collector;
 import org.eclipse.osgi.service.resolver.VersionRange;
 
 public class OperationGenerator {
@@ -75,7 +76,9 @@ public class OperationGenerator {
 			if (iuTo.getProperty(IInstallableUnit.PROP_UPDATE_FROM) == null)
 				continue;
 			//when the ui we update from is in the new state, skip (for example FROM is A, C, B & TO is C (update of 
-			Iterator updates = new CompoundIterator(new Iterator[] {from.iterator()}, iuTo.getProperty(IInstallableUnit.PROP_UPDATE_FROM), new VersionRange(iuTo.getProperty(IInstallableUnit.PROP_UPDATE_RANGE)), null, false);
+			InstallableUnitQuery updateQuery = new InstallableUnitQuery(iuTo.getProperty(IInstallableUnit.PROP_UPDATE_FROM), new VersionRange(iuTo.getProperty(IInstallableUnit.PROP_UPDATE_RANGE)));
+			Iterator updates = updateQuery.perform(from.iterator(), new Collector()).iterator();
+
 			IInstallableUnit iuFrom;
 			if (!updates.hasNext()) { //Nothing to udpate from.
 				continue;
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
index 5c65671..16c1c70 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
@@ -17,8 +17,10 @@ import org.eclipse.equinox.p2.director.ProvisioningPlan;
 import org.eclipse.equinox.p2.engine.Operand;
 import org.eclipse.equinox.p2.engine.Profile;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepositoryManager;
+import org.eclipse.equinox.p2.query.Query;
 import org.eclipse.osgi.service.resolver.VersionRange;
 import org.eclipse.osgi.util.NLS;
 
@@ -146,7 +148,8 @@ public class SimplePlanner implements IPlanner {
 	private IInstallableUnit[] inProfile(IInstallableUnit[] toFind, Profile profile, boolean found, IProgressMonitor monitor) {
 		ArrayList result = new ArrayList(toFind.length);
 		for (int i = 0; i < toFind.length; i++) {
-			if (profile.query(toFind[i].getId(), new VersionRange(toFind[i].getVersion(), true, toFind[i].getVersion(), true), null, false, monitor).length > 0) {
+			Query query = new InstallableUnitQuery(toFind[i].getId(), new VersionRange(toFind[i].getVersion(), true, toFind[i].getVersion(), true));
+			if (!profile.query(query, new HasMatchCollector(), monitor).isEmpty()) {
 				if (found)
 					result.add(toFind[i]);
 			} else {
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/p2/director/ProvisioningPlan.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/p2/director/ProvisioningPlan.java
index ef70bf6..7819b4b 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/p2/director/ProvisioningPlan.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/p2/director/ProvisioningPlan.java
@@ -16,7 +16,7 @@ public class ProvisioningPlan {
 	private Operand[] operands;
 
 	public ProvisioningPlan(IStatus status) {
-		this(status, null);
+		this(status, new Operand[0]);
 	}
 
 	public ProvisioningPlan(IStatus status, Operand[] operands) {
@@ -30,7 +30,8 @@ public class ProvisioningPlan {
 
 	/** 
 	 * The operands to pass to the engine.
-	 * @return the operands or <code>null</code> if the the operation has not been successfull. 
+	 * @return the operands to be executed. This may be an empty array if the
+	 * plan has errors or if there is nothing to do.
 	 */
 	public Operand[] getOperands() {
 		return operands;
diff --git a/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/p2/directorywatcher/RepositoryListener.java b/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/p2/directorywatcher/RepositoryListener.java
index a485383..2b4768a 100644
--- a/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/p2/directorywatcher/RepositoryListener.java
+++ b/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/p2/directorywatcher/RepositoryListener.java
@@ -11,6 +11,7 @@ import org.eclipse.equinox.p2.metadata.generator.BundleDescriptionFactory;
 import org.eclipse.equinox.p2.metadata.generator.MetadataGeneratorHelper;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepositoryManager;
+import org.eclipse.equinox.p2.query.Query;
 import org.eclipse.osgi.service.resolver.*;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.ServiceReference;
@@ -176,34 +177,29 @@ public class RepositoryListener extends DirectoryChangeListener {
 
 	private void synchronizeMetadataRepository() {
 		boolean modified = false;
-		Map snapshot = new HashMap(currentFiles);
-		List toRemove = new ArrayList();
-
-		IInstallableUnit[] ius = metadataRepository.getInstallableUnits(null);
-		for (int i = 0; i < ius.length; i++) {
-			IInstallableUnit iu = ius[i];
-			File iuFile = new File(iu.getProperty("file.name"));
-			Long iuLastModified = new Long(iu.getProperty("file.lastModified"));
-
-			Long snapshotLastModified = (Long) snapshot.get(iuFile);
-			if (snapshotLastModified == null || !snapshotLastModified.equals(iuLastModified))
-				toRemove.add(iu);
-			else
+		final Map snapshot = new HashMap(currentFiles);
+		Query removeQuery = new Query() {
+			public boolean isMatch(Object candidate) {
+				if (!(candidate instanceof IInstallableUnit))
+					return false;
+				IInstallableUnit iu = (IInstallableUnit) candidate;
+				File iuFile = new File(iu.getProperty("file.name")); //$NON-NLS-1$
+				Long iuLastModified = new Long(iu.getProperty("file.lastModified")); //$NON-NLS-1$
+				Long snapshotLastModified = (Long) snapshot.get(iuFile);
+				if (snapshotLastModified == null || !snapshotLastModified.equals(iuLastModified))
+					return true;
 				snapshot.remove(iuFile);
-		}
-
-		if (!toRemove.isEmpty()) {
-			IInstallableUnit[] iusToRemove = (IInstallableUnit[]) toRemove.toArray(new IInstallableUnit[toRemove.size()]);
-			metadataRepository.removeInstallableUnits(iusToRemove);
+				return false;
+			}
+		};
+		if (metadataRepository.removeInstallableUnits(removeQuery, null))
 			modified = true;
-		}
 
 		if (!snapshot.isEmpty()) {
+			modified = true;
 			IInstallableUnit[] iusToAdd = generateIUs(snapshot.keySet());
 			metadataRepository.addInstallableUnits(iusToAdd);
-			modified = true;
 		}
-
 		if (modified)
 			lastModifed = System.currentTimeMillis();
 	}
@@ -225,9 +221,9 @@ public class RepositoryListener extends DirectoryChangeListener {
 				if (descriptor != null) {
 					artifactRepository.addDescriptor(descriptor);
 					modified = true;
-				}
 			}
 		}
+		}
 
 		for (Iterator it = snapshot.iterator(); it.hasNext();) {
 			IArtifactKey key = (IArtifactKey) it.next();
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Profile.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Profile.java
index 2a93244..9d8cbb0 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Profile.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/p2/engine/Profile.java
@@ -18,10 +18,7 @@ import org.eclipse.equinox.internal.p2.installregistry.IInstallRegistry;
 import org.eclipse.equinox.internal.p2.installregistry.IProfileInstallRegistry;
 import org.eclipse.equinox.p2.core.eventbus.ProvisioningEventBus;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
-import org.eclipse.equinox.p2.query.IQueryable;
-import org.eclipse.equinox.p2.query.QueryableArray;
-import org.eclipse.osgi.service.resolver.VersionRange;
+import org.eclipse.equinox.p2.query.*;
 import org.eclipse.osgi.util.NLS;
 
 public class Profile implements IQueryable {
@@ -208,12 +205,8 @@ public class Profile implements IQueryable {
 		return profile.getInstallableUnits();
 	}
 
-	public Iterator getIterator(String id, VersionRange range, RequiredCapability[] requirements, boolean and) {
-		return new QueryableArray(getAllInstallableUnits()).getIterator(id, range, requirements, and);
-	}
-
-	public IInstallableUnit[] query(String id, VersionRange range, RequiredCapability[] requirements, boolean and, IProgressMonitor progress) {
-		return new QueryableArray(getAllInstallableUnits()).query(id, range, requirements, and, progress);
+	public Collector query(Query query, Collector collector, IProgressMonitor monitor) {
+		return query.perform(Arrays.asList(getAllInstallableUnits()).iterator(), collector);
 	}
 
 	public Iterator getInstallableUnits() {
diff --git a/bundles/org.eclipse.equinox.p2.installer/src/org/eclipse/equinox/internal/p2/installer/InstallUpdateProductOperation.java b/bundles/org.eclipse.equinox.p2.installer/src/org/eclipse/equinox/internal/p2/installer/InstallUpdateProductOperation.java
index 8a08902..10cc68c 100644
--- a/bundles/org.eclipse.equinox.p2.installer/src/org/eclipse/equinox/internal/p2/installer/InstallUpdateProductOperation.java
+++ b/bundles/org.eclipse.equinox.p2.installer/src/org/eclipse/equinox/internal/p2/installer/InstallUpdateProductOperation.java
@@ -22,8 +22,10 @@ import org.eclipse.equinox.p2.director.IDirector;
 import org.eclipse.equinox.p2.engine.IProfileRegistry;
 import org.eclipse.equinox.p2.engine.Profile;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepositoryManager;
+import org.eclipse.equinox.p2.query.*;
 import org.eclipse.osgi.service.environment.EnvironmentInfo;
 import org.eclipse.osgi.service.resolver.VersionRange;
 import org.eclipse.osgi.util.NLS;
@@ -140,9 +142,11 @@ public class InstallUpdateProductOperation implements IInstallOperation {
 			range = new VersionRange(version, true, version, true);
 		IMetadataRepository[] repos = metadataRepoMan.getKnownRepositories();
 		for (int i = 0; i < repos.length; i++) {
-			IInstallableUnit[] found = repos[i].query(id, range, null, true, null);
-			if (found.length > 0)
-				return found[0];
+			Query query = new InstallableUnitQuery(id, range);
+			Collector collector = new Collector();
+			Iterator result = repos[i].query(query, collector, null).iterator();
+			if (result.hasNext())
+				return (IInstallableUnit) result.next();
 		}
 		throw fail("Installable unit not found: " + id);
 	}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
index 191430f..0ae9478 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
@@ -18,10 +18,9 @@ import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.NullProgressMonitor;
 import org.eclipse.equinox.p2.core.repository.RepositoryCreationException;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
-import org.eclipse.equinox.p2.query.CompoundIterator;
+import org.eclipse.equinox.p2.query.Collector;
+import org.eclipse.equinox.p2.query.Query;
 import org.eclipse.equinox.spi.p2.metadata.repository.AbstractMetadataRepository;
-import org.eclipse.osgi.service.resolver.VersionRange;
 import org.eclipse.osgi.util.NLS;
 
 /**
@@ -53,7 +52,7 @@ public class LocalMetadataRepository extends AbstractMetadataRepository {
 	}
 
 	public LocalMetadataRepository(URL location, String name) throws RepositoryCreationException {
-		super(name == null ? (location != null ? location.toExternalForm() : "") : name, REPOSITORY_TYPE, REPOSITORY_VERSION.toString(), location, null, null);
+		super(name == null ? (location != null ? location.toExternalForm() : "") : name, REPOSITORY_TYPE, REPOSITORY_VERSION.toString(), location, null, null); //$NON-NLS-1$
 		if (!location.getProtocol().equals("file")) //$NON-NLS-1$
 			throw new IllegalArgumentException("Invalid local repository location: " + location);
 	}
@@ -63,21 +62,16 @@ public class LocalMetadataRepository extends AbstractMetadataRepository {
 	}
 
 	public IInstallableUnit[] getInstallableUnits(IProgressMonitor monitor) {
-		if (monitor == null) {
+		if (monitor == null)
 			monitor = new NullProgressMonitor();
-		}
 		monitor.beginTask(NLS.bind(Messages.REPO_LOADING, location.toExternalForm()), 5);
-		IInstallableUnit[] result = query(null, null, null, false, monitor);
+		IInstallableUnit[] result = (IInstallableUnit[]) units.toArray(new IInstallableUnit[0]);
 		monitor.done();
 		return result;
 	}
 
-	public Iterator getIterator(String id, VersionRange range, RequiredCapability[] requirements, boolean and) {
-		return new CompoundIterator(new Iterator[] {units.iterator()}, id, range, requirements, and);
-	}
-
-	public IInstallableUnit[] query(String id, VersionRange range, RequiredCapability[] requirements, boolean and, IProgressMonitor monitor) {
-		return CompoundIterator.asArray(new CompoundIterator(new Iterator[] {units.iterator()}, id, range, requirements, and), null);
+	public Collector query(Query query, Collector collector, IProgressMonitor monitor) {
+		return query.perform(units.iterator(), collector);
 	}
 
 	public void addInstallableUnits(IInstallableUnit[] installableUnits) {
@@ -103,9 +97,16 @@ public class LocalMetadataRepository extends AbstractMetadataRepository {
 		}
 	}
 
-	public void removeInstallableUnits(IInstallableUnit[] installableUnits) {
-		units.removeAll(Arrays.asList(installableUnits));
+	public boolean removeInstallableUnits(Query query, IProgressMonitor monitor) {
+		int sizeBefore = units.size();
+		query.perform(units.iterator(), new Collector() {
+			public boolean accept(Object object) {
+				units.remove(object);
+				return true;
+			}
+		});
 		save();
+		return units.size() != sizeBefore;
 	}
 
 	public void removeAll() {
@@ -114,8 +115,8 @@ public class LocalMetadataRepository extends AbstractMetadataRepository {
 	}
 
 	// use this method to setup any transient fields etc after the object has been restored from a stream
-	public void initializeAfterLoad(URL location) {
-		this.location = location;
+	public void initializeAfterLoad(URL aLocation) {
+		this.location = aLocation;
 	}
 
 	public void revertToBackup(LocalMetadataRepository backup) {
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/URLMetadataRepository.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/URLMetadataRepository.java
index e62a3b7..109b7a0 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/URLMetadataRepository.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/URLMetadataRepository.java
@@ -18,10 +18,9 @@ import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.NullProgressMonitor;
 import org.eclipse.equinox.p2.core.repository.RepositoryCreationException;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
-import org.eclipse.equinox.p2.query.CompoundIterator;
+import org.eclipse.equinox.p2.query.Collector;
+import org.eclipse.equinox.p2.query.Query;
 import org.eclipse.equinox.spi.p2.metadata.repository.AbstractMetadataRepository;
-import org.eclipse.osgi.service.resolver.VersionRange;
 import org.eclipse.osgi.util.NLS;
 
 /**
@@ -81,12 +80,8 @@ public class URLMetadataRepository extends AbstractMetadataRepository {
 		return content;
 	}
 
-	public Iterator getIterator(String id, VersionRange range, RequiredCapability[] requirements, boolean and) {
-		return new CompoundIterator(new Iterator[] {units.iterator()}, id, range, requirements, and);
-	}
-
-	public IInstallableUnit[] query(String id, VersionRange range, RequiredCapability[] requirements, boolean and, IProgressMonitor progress) {
-		return CompoundIterator.asArray(new CompoundIterator(new Iterator[] {units.iterator()}, id, range, requirements, and), null);
+	public Collector query(Query query, Collector collector, IProgressMonitor monitor) {
+		return query.perform(units.iterator(), collector);
 	}
 
 	// Use this method to setup any transient fields etc after the object has been restored from a stream
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/p2/metadata/repository/IMetadataRepository.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/p2/metadata/repository/IMetadataRepository.java
index 3b3876b..08721a2 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/p2/metadata/repository/IMetadataRepository.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/p2/metadata/repository/IMetadataRepository.java
@@ -14,6 +14,7 @@ import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.equinox.p2.core.repository.IRepository;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.p2.query.IQueryable;
+import org.eclipse.equinox.p2.query.Query;
 import org.eclipse.equinox.spi.p2.metadata.repository.AbstractMetadataRepository;
 
 /**
@@ -26,13 +27,6 @@ import org.eclipse.equinox.spi.p2.metadata.repository.AbstractMetadataRepository
  */
 public interface IMetadataRepository extends IRepository, IQueryable {
 
-	/**
-	 * Returns all installable units known to this repository.
-	 * @param monitor TODO
-	 * @return the installable units known to this repository
-	 */
-	public IInstallableUnit[] getInstallableUnits(IProgressMonitor monitor);
-
 	/** 
 	 * Add the given installable units to this repository
 	 * @param installableUnits the installable unts to add
@@ -40,10 +34,23 @@ public interface IMetadataRepository extends IRepository, IQueryable {
 	public void addInstallableUnits(IInstallableUnit[] installableUnits);
 
 	/**
-	 * Remove the given installable units from this repository
-	 * @param installableUnits the installable units to remove
+	 * Returns all installable units known to this repository.
+	 * @param monitor a progress monitor, or <code>null</code> if progress
+	 *    reporting is not desired
+	 * @return the installable units known to this repository
+	 */
+	public IInstallableUnit[] getInstallableUnits(IProgressMonitor monitor);
+
+	/**
+	 * Removes all installable units that match the given query from this repository.
+	 * 
+	 * @param query the installable units to remove
+	 * @param monitor a progress monitor, or <code>null</code> if progress
+	 *    reporting is not desired
+	 * @return <code>true</code> if any units were actually removed, and
+	 * <code>false</code> otherwise
 	 */
-	public void removeInstallableUnits(IInstallableUnit[] installableUnits);
+	public boolean removeInstallableUnits(Query query, IProgressMonitor monitor);
 
 	/**
 	 * Remove all installable units from this repository.  
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/spi/p2/metadata/repository/AbstractMetadataRepository.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/spi/p2/metadata/repository/AbstractMetadataRepository.java
index 4bf8980..356297a 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/spi/p2/metadata/repository/AbstractMetadataRepository.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/spi/p2/metadata/repository/AbstractMetadataRepository.java
@@ -12,8 +12,10 @@ package org.eclipse.equinox.spi.p2.metadata.repository;
 
 import java.net.URL;
 import java.util.Map;
+import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
+import org.eclipse.equinox.p2.query.Query;
 import org.eclipse.equinox.spi.p2.core.repository.AbstractRepository;
 import org.osgi.framework.Version;
 
@@ -56,9 +58,10 @@ public abstract class AbstractMetadataRepository extends AbstractRepository impl
 			throw new UnsupportedOperationException("Repository not modifiable");
 	}
 
-	public void removeInstallableUnits(IInstallableUnit[] installableUnit) {
+	public boolean removeInstallableUnits(Query query, IProgressMonitor monitor) {
 		if (!isModifiable())
 			throw new UnsupportedOperationException("Repository not modifiable");
+		return false;
 	}
 
 }
diff --git a/bundles/org.eclipse.equinox.p2.metadata/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.metadata/META-INF/MANIFEST.MF
index 533613c..668075d 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.metadata/META-INF/MANIFEST.MF
@@ -5,9 +5,15 @@ Bundle-Name: %pluginName
 Bundle-Vendor: %providerName
 Bundle-Localization: plugin
 Bundle-Version: 0.1.0.qualifier
-Export-Package: org.eclipse.equinox.internal.p2.metadata;x-friends:="org.eclipse.equinox.p2.metadata.generator,org.eclipse.equinox.p2.metadata.repository,org.eclipse.equinox.p2.engine,org.eclipse.equinox.p2.artifact.repository,org.eclipse.equinox.p2.artifact.optimizers,org.eclipse.equinox.p2.artifact.processors",
+Export-Package: org.eclipse.equinox.internal.p2.metadata;
+  x-friends:="org.eclipse.equinox.p2.metadata.generator,
+   org.eclipse.equinox.p2.metadata.repository,
+   org.eclipse.equinox.p2.engine,
+   org.eclipse.equinox.p2.artifact.repository,
+   org.eclipse.equinox.p2.artifact.optimizers,
+   org.eclipse.equinox.p2.artifact.processors",
  org.eclipse.equinox.p2.metadata,
- org.eclipse.equinox.p2.query
+ org.eclipse.equinox.p2.metadata.query
 Import-Package: org.eclipse.osgi.service.resolver;version="1.1.0",
  org.eclipse.osgi.util;version="1.1.0",
  org.osgi.framework;version="1.3.0"
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/ProvidedCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/ProvidedCapability.java
index bbbdf86..bdfa815 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/ProvidedCapability.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/ProvidedCapability.java
@@ -53,6 +53,11 @@ public class ProvidedCapability {
 		return namespace.hashCode() * name.hashCode() * version.hashCode();
 	}
 
+	/**
+	 * TODO The name of this method is backwards. A provided capability does not
+	 * get satisfied - it is the required capability that is satisfied or not. It should be "satisfies"
+	 * or "isSatisfied"
+	 */
 	public boolean isSatisfiedBy(RequiredCapability candidate) {
 		if (getName() == null || !getName().equals(candidate.getName()))
 			return false;
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/query/CapabilityQuery.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/query/CapabilityQuery.java
new file mode 100644
index 0000000..01692bd
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/query/CapabilityQuery.java
@@ -0,0 +1,70 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.metadata.query;
+
+import org.eclipse.equinox.p2.metadata.*;
+import org.eclipse.equinox.p2.query.Query;
+
+/**
+ * A query that searches for {@link IInstallableUnit} instances that provide
+ * capabilities that match one or more required capabilities.
+ */
+public class CapabilityQuery extends Query {
+	private RequiredCapability[] required;
+
+	/**
+	 * Creates a new query on the given required capability.
+	 * @param required The required capability
+	 */
+	public CapabilityQuery(RequiredCapability required) {
+		this.required = new RequiredCapability[] {required};
+	}
+
+	/**
+	 * Creates a new query on the given required capabilities. The installable
+	 * unit must provide capabilities that match all of the given required capabilities
+	 * for this query to be satisfied.
+	 * @param required The required capabilities
+	 */
+	public CapabilityQuery(RequiredCapability[] required) {
+		this.required = required;
+	}
+
+	/**
+	 * Returns the required capability that this query is matching against.
+	 * @return the required capability that this query is matching against.
+	 */
+	public RequiredCapability[] getRequiredCapabilities() {
+		return required;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.equinox.p2.query2.Query#isMatch(java.lang.Object)
+	 */
+	public boolean isMatch(Object object) {
+		if (!(object instanceof IInstallableUnit))
+			return false;
+		IInstallableUnit candidate = (IInstallableUnit) object;
+		ProvidedCapability[] provides = candidate.getProvidedCapabilities();
+		for (int i = 0; i < required.length; i++) {
+			boolean satisfied = false;
+			for (int j = 0; j < provides.length; j++) {
+				if (provides[j].isSatisfiedBy(required[i])) {
+					satisfied = true;
+					break;
+				}
+			}
+			if (!satisfied)
+				return false;
+		}
+		return true;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/query/InstallableUnitQuery.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/query/InstallableUnitQuery.java
new file mode 100644
index 0000000..1373bc6
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/query/InstallableUnitQuery.java
@@ -0,0 +1,79 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.metadata.query;
+
+import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.query.Query;
+import org.eclipse.osgi.service.resolver.VersionRange;
+import org.osgi.framework.Version;
+
+/**
+ * A query that matches on the id and version of an {@link IInstallableUnit}.
+ */
+public class InstallableUnitQuery extends Query {
+	private String id;
+	private final VersionRange range;
+
+	/**
+	 * Creates a query that will match any {@link IInstallableUnit} with the given
+	 * id, and whose version falls in the provided range.
+	 * 
+	 * @param id The installable unit id to match, or <code>null</code> to match any id
+	 * @param range The version range to match
+	 */
+	public InstallableUnitQuery(String id, VersionRange range) {
+		this.id = id;
+		this.range = range;
+	}
+
+	/**
+	 * Creates a query that will match any {@link IInstallableUnit} with the given
+	 * id and version.
+	 * 
+	 * @param id The installable unit id to match, or <code>null</code> to match any id
+	 * @param version The precise version that a matching unit must have
+	 */
+	public InstallableUnitQuery(String id, Version version) {
+		this.id = id;
+		this.range = new VersionRange(version, true, version, true);
+	}
+
+	/**
+	 * Returns the id that this query will match against.
+	 * @return The installable unit it
+	 */
+	public String getId() {
+		return id;
+	}
+
+	/**
+	 * Returns the version range that this query will match against.
+	 * @return The installable unit version range.
+	 */
+	public VersionRange getRange() {
+		return range;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.equinox.p2.query2.Query#isMatch(java.lang.Object)
+	 */
+	public boolean isMatch(Object object) {
+		if (!(object instanceof IInstallableUnit))
+			return false;
+		IInstallableUnit candidate = (IInstallableUnit) object;
+		if (id != null && !id.equals(candidate.getId()))
+			return false;
+		if (range != null && !range.isIncluded(candidate.getVersion()))
+			return false;
+		return true;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/CompoundIterator.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/CompoundIterator.java
deleted file mode 100644
index b8cadf6..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/CompoundIterator.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: IBM Corporation - initial API and implementation
- ******************************************************************************/
-package org.eclipse.equinox.p2.query;
-
-import java.util.*;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.equinox.internal.p2.metadata.Messages;
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
-import org.eclipse.osgi.service.resolver.VersionRange;
-
-public class CompoundIterator implements Iterator {
-	private Iterator[] iterators;
-	private String id;
-	private VersionRange range;
-	private RequiredCapability[] requirements;
-	private boolean and;
-	private int index = 0;
-	private boolean filtered = false;
-	private IInstallableUnit lookahead = null;
-
-	public static IInstallableUnit[] asArray(Iterator i, IProgressMonitor progress) {
-		if (progress == null)
-			progress = new NullProgressMonitor();
-		progress.beginTask(Messages.QUERY_PROGRESS, IProgressMonitor.UNKNOWN);
-		HashSet result = new HashSet();
-		while (i.hasNext()) {
-			result.add(i.next());
-			progress.worked(IProgressMonitor.UNKNOWN);
-		}
-		progress.done();
-		return (IInstallableUnit[]) result.toArray(new IInstallableUnit[result.size()]);
-	}
-
-	public CompoundIterator(Iterator[] iterators) {
-		this.iterators = iterators;
-	}
-
-	public CompoundIterator(Iterator[] iterators, String id, VersionRange range, RequiredCapability[] requirements, boolean and) {
-		this(iterators);
-		this.id = id;
-		this.range = range;
-		this.requirements = requirements;
-		this.and = and;
-		filtered = true;
-	}
-
-	public boolean hasNext() {
-		if (lookahead != null)
-			return true;
-		if (index >= iterators.length)
-			return false;
-		if (filtered) {
-			while (iterators[index].hasNext()) {
-				IInstallableUnit next = (IInstallableUnit) iterators[index].next();
-				if (Query.match(next, id, range, requirements, and)) {
-					lookahead = next;
-					return true;
-				}
-			}
-		} else {
-			if (iterators[index].hasNext())
-				return true;
-		}
-		index++;
-		return hasNext();
-	}
-
-	public Object next() {
-		if (lookahead != null) {
-			IInstallableUnit result = lookahead;
-			lookahead = null;
-			return result;
-		}
-		if (index >= iterators.length)
-			throw new NoSuchElementException();
-		while (iterators[index].hasNext()) {
-			IInstallableUnit next = (IInstallableUnit) iterators[index].next();
-			if (!filtered)
-				return next;
-			if (Query.match(next, id, range, requirements, and))
-				return next;
-		}
-		index++;
-		return next();
-	}
-
-	public void remove() {
-		throw new UnsupportedOperationException();
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/IQueryable.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/IQueryable.java
deleted file mode 100644
index 3256127..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/IQueryable.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.query;
-
-import java.util.Iterator;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
-import org.eclipse.osgi.service.resolver.VersionRange;
-
-public interface IQueryable {
-
-	IInstallableUnit[] query(String id, VersionRange range, RequiredCapability[] requirements, boolean and, IProgressMonitor progress);
-
-	Iterator getIterator(String id, VersionRange range, RequiredCapability[] requirements, boolean and);
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/Query.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/Query.java
deleted file mode 100644
index 848021d..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/Query.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: IBM Corporation - initial API and implementation
- ******************************************************************************/
-package org.eclipse.equinox.p2.query;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.equinox.internal.p2.metadata.Messages;
-import org.eclipse.equinox.p2.metadata.*;
-import org.eclipse.osgi.service.resolver.VersionRange;
-
-public class Query {
-
-	public static boolean match(IInstallableUnit source, String id, VersionRange range, RequiredCapability[] requirements, boolean and) {
-		if (id != null && !source.getId().equals(id))
-			return false;
-		if (range != null && !range.isIncluded(source.getVersion()))
-			return false;
-		if (requirements == null)
-			return true;
-		// if any of the requirements are met by any of the capabilities of the source...
-		for (int k = 0; k < requirements.length; k++) {
-			boolean valid = false;
-			ProvidedCapability[] capabilities = source.getProvidedCapabilities();
-			for (int j = 0; j < capabilities.length; j++)
-				//TODO Need to deal with option and multiplicity flag
-				if ((requirements[k].getName().equals(capabilities[j].getName()) && requirements[k].getNamespace().equals(capabilities[j].getNamespace()) && (requirements[k].getRange() == null ? true : requirements[k].getRange().isIncluded(capabilities[j].getVersion())))) {
-					valid = true;
-				}
-			// if we are OR'ing then the first time we find a requirement that is met, return success
-			if (valid && !and)
-				return true;
-			// if we are AND'ing then the first time we find a requirement that is NOT met, return failure
-			if (!valid && and)
-				return false;
-		}
-		// if we get past the requirements check and we are AND'ing then return true 
-		// since all requirements must have been met.  If we are OR'ing then return false 
-		// since none of the requirements were met.
-		return and;
-	}
-
-	public static IInstallableUnit[] query(IQueryable[] sources, String id, VersionRange range, RequiredCapability[] requirements, boolean and, IProgressMonitor progress) {
-		if (progress == null)
-			progress = new NullProgressMonitor();
-
-		progress.beginTask(Messages.QUERY_PROGRESS, sources.length);
-		ArrayList result = new ArrayList();
-		for (int i = 0; i < sources.length; i++) {
-			IQueryable source = sources[i];
-			IInstallableUnit[] list = source.query(id, range, requirements, and, progress);
-			for (int j = 0; j < list.length; j++)
-				result.add(list[j]);
-			progress.worked(1);
-		}
-		progress.done();
-		return (IInstallableUnit[]) result.toArray(new IInstallableUnit[result.size()]);
-	}
-
-	public static Iterator getIterator(IQueryable[] sources, String id, VersionRange range, RequiredCapability[] requirements, boolean and) {
-		Iterator[] result = new Iterator[sources.length];
-		for (int i = 0; i < sources.length; i++)
-			result[i] = sources[i].getIterator(id, range, requirements, and);
-		return new CompoundIterator(result);
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/QueryableArray.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/QueryableArray.java
deleted file mode 100644
index 6fb74eb..0000000
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/query/QueryableArray.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.query;
-
-import java.util.*;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.equinox.internal.p2.metadata.Messages;
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
-import org.eclipse.osgi.service.resolver.VersionRange;
-
-public class QueryableArray implements IQueryable {
-	private IInstallableUnit[] source;
-
-	public QueryableArray(IInstallableUnit[] source) {
-		this.source = source;
-	}
-
-	public Iterator getIterator(String id, VersionRange range, RequiredCapability[] requirements, boolean and) {
-		Iterator i = Arrays.asList(source).iterator();
-		return new CompoundIterator(new Iterator[] {i}, id, range, requirements, and);
-	}
-
-	public IInstallableUnit[] query(String id, VersionRange range, RequiredCapability[] requirements, boolean and, IProgressMonitor progress) {
-		if (progress == null)
-			progress = new NullProgressMonitor();
-		progress.beginTask(Messages.QUERY_PROGRESS, source.length);
-		Set result = new HashSet();
-		for (int i = 0; i < source.length; i++) {
-			if (Query.match(source[i], id, range, requirements, and))
-				result.add(source[i]);
-			progress.worked(1);
-		}
-		progress.done();
-		return (IInstallableUnit[]) result.toArray(new IInstallableUnit[result.size()]);
-
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
index 5cdc46a..44e5745 100644
--- a/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
@@ -32,6 +32,7 @@ Import-Package: ie.wombat.jbdiff,
  org.eclipse.equinox.p2.directorywatcher,
  org.eclipse.equinox.p2.engine,
  org.eclipse.equinox.p2.metadata,
+ org.eclipse.equinox.p2.metadata.query,
  org.eclipse.equinox.p2.metadata.repository,
  org.eclipse.equinox.p2.query,
  org.eclipse.equinox.p2.sar,
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/TestMetadataRepository.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/TestMetadataRepository.java
index 80b379b..007f82b 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/TestMetadataRepository.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/TestMetadataRepository.java
@@ -15,11 +15,10 @@ import junit.framework.Assert;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.equinox.p2.core.repository.IRepository;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
+import org.eclipse.equinox.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
-import org.eclipse.equinox.p2.query.CompoundIterator;
+import org.eclipse.equinox.p2.query.*;
 import org.eclipse.equinox.spi.p2.metadata.repository.AbstractMetadataRepository;
-import org.eclipse.osgi.service.resolver.VersionRange;
 import org.osgi.framework.Version;
 
 /**
@@ -55,10 +54,8 @@ public class TestMetadataRepository extends AbstractMetadataRepository {
 	}
 
 	public IInstallableUnit find(String id, String versionString) {
-		Version iuVersion = new Version(versionString);
-		VersionRange range = new VersionRange(iuVersion, true, iuVersion, true);
-		IInstallableUnit[] result = query(id, range, null, true, null);
-		return result.length != 1 ? null : result[0];
+		Iterator result = query(new InstallableUnitQuery(id, new Version(versionString)), new Collector(), null).iterator();
+		return (IInstallableUnit) (result.hasNext() ? result.next() : null);
 	}
 
 	public Object getAdapter(Class adapter) {
@@ -69,26 +66,23 @@ public class TestMetadataRepository extends AbstractMetadataRepository {
 	}
 
 	public IInstallableUnit[] getInstallableUnits(IProgressMonitor monitor) {
-		IInstallableUnit[] result = query(null, null, null, false, monitor);
-		return result;
+		return (IInstallableUnit[]) units.toArray(new IInstallableUnit[0]);
 	}
 
-	public Iterator getIterator(String id, VersionRange range, RequiredCapability[] requirements, boolean and) {
-		return new CompoundIterator(new Iterator[] {units.iterator()}, id, range, requirements, and);
-	}
-
-	public IInstallableUnit[] query(String id, VersionRange range, RequiredCapability[] requirements, boolean and, IProgressMonitor monitor) {
-		return CompoundIterator.asArray(new CompoundIterator(new Iterator[] {units.iterator()}, id, range, requirements, and), null);
+	public Collector query(Query query, Collector collector, IProgressMonitor monitor) {
+		return query.perform(units.iterator(), collector);
 	}
 
 	public void removeAll() {
 		units.clear();
 	}
 
-	public void removeInstallableUnits(IInstallableUnit[] toRemove) {
+	public boolean removeInstallableUnits(IInstallableUnit[] toRemove) {
+		boolean modified = false;
 		for (int i = 0; i < toRemove.length; i++) {
-			units.remove(toRemove[i]);
+			modified |= units.remove(toRemove[i]);
 		}
+		return modified;
 	}
 
 	public void initialize(RepositoryState state) {
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UninstallTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UninstallTest.java
index fdd5869..baba96f 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UninstallTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/UninstallTest.java
@@ -26,8 +26,13 @@ public class UninstallTest extends AbstractProvisioningTest {
 	}
 
 	public void testUninstall() {
-		System.out.println(director.install(new IInstallableUnit[] {a1}, profile, null));
-		director.uninstall(new IInstallableUnit[] {a1}, profile, null);
+		IInstallableUnit[] units = new IInstallableUnit[] {a1};
+		System.out.println(director.install(units, profile, null));
+		assertProfileContains("1.0", profile, units);
+		director.uninstall(units, profile, null);
+		assertEmptyProfile(profile);
+		//uninstalling on empty profile should be a no-op
+		director.uninstall(units, profile, null);
 		assertEmptyProfile(profile);
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/full/DirectorTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/full/DirectorTest.java
index f2c4a40..e2de98b 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/full/DirectorTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/full/DirectorTest.java
@@ -20,10 +20,13 @@ import org.eclipse.equinox.p2.director.IDirector;
 import org.eclipse.equinox.p2.engine.IProfileRegistry;
 import org.eclipse.equinox.p2.engine.Profile;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepositoryManager;
+import org.eclipse.equinox.p2.query.Collector;
 import org.eclipse.equinox.p2.tests.TestActivator;
 import org.eclipse.osgi.service.environment.EnvironmentInfo;
+import org.eclipse.osgi.service.resolver.VersionRange;
 import org.osgi.framework.ServiceReference;
 
 /**
@@ -122,9 +125,9 @@ public class DirectorTest extends TestCase {
 		if (!operationStatus.isOK())
 			fail("The installation has failed");
 
-		IInstallableUnit[] result = p.query(allRoots[0].getId(), null, null, false, null);
+		IInstallableUnit[] result = (IInstallableUnit[]) p.query(new InstallableUnitQuery(allRoots[0].getId(), VersionRange.emptyRange), new Collector(), null).toArray(IInstallableUnit.class);
 		assertEquals(result.length, (!doUninstall ? 1 : 0));
-		result = p.query("toolingdefault", null, null, false, null);
+		result = (IInstallableUnit[]) p.query(new InstallableUnitQuery("toolingdefault", VersionRange.emptyRange), new Collector(), null).toArray(IInstallableUnit.class);
 
 		ensureFragmentAssociationIsNotPersisted(mgr);
 	}
@@ -135,7 +138,7 @@ public class DirectorTest extends TestCase {
 		mgr.removeRepository(mgr.getRepository(location.getMetadataRepositoryURL()));
 		IMetadataRepository repo = null;
 		repo = mgr.loadRepository(location.getMetadataRepositoryURL(), null);
-		Iterator it = repo.getIterator("org.eclipse.equinox.simpleconfigurator", null, null, false);
+		Iterator it = repo.query(new InstallableUnitQuery("org.eclipse.equinox.simpleconfigurator", VersionRange.emptyRange), new Collector(), null).iterator();
 		if (!it.hasNext())
 			return;
 		IInstallableUnit sc = (IInstallableUnit) it.next();
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/full/End2EndTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/full/End2EndTest.java
index d1158eb..e3c345c 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/full/End2EndTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/full/End2EndTest.java
@@ -17,8 +17,10 @@ import org.eclipse.equinox.p2.director.IPlanner;
 import org.eclipse.equinox.p2.engine.IProfileRegistry;
 import org.eclipse.equinox.p2.engine.Profile;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.p2.metadata.repository.IMetadataRepositoryManager;
+import org.eclipse.equinox.p2.query.Collector;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
 import org.eclipse.equinox.p2.tests.TestActivator;
 import org.eclipse.osgi.service.environment.EnvironmentInfo;
@@ -101,7 +103,7 @@ public class End2EndTest extends AbstractProvisioningTest {
 		assertEquals(false, profile2.getInstallableUnits().hasNext()); //the profile should be empty since we uninstalled everything
 		IInstallableUnit[] snapshots = getIUs("profile2");
 		assertTrue("snap" + snapshots.length, snapshots.length >= 2);//TODO Normally here it should be 2!!!
-		assertEquals(false, profile2.getIterator("sdk", VersionRange.emptyRange, null, false).hasNext());
+		assertTrue(profile2.query(new InstallableUnitQuery("sdk", VersionRange.emptyRange), new Collector(), null).isEmpty());
 
 		// Now test the rollback to a previous state, in this case we reinstall the SDK
 		s = director.become(snapshots[0].equals(firstSnapshot) ? snapshots[1] : snapshots[0], profile2, new NullProgressMonitor());
@@ -138,7 +140,7 @@ public class End2EndTest extends AbstractProvisioningTest {
 	public IInstallableUnit[] getIUs(String id) {
 		Collection result = new ArrayList();
 		for (int i = 0; i < repos.length; i++) {
-			Iterator it = repos[i].getIterator(id, VersionRange.emptyRange, null, false);
+			Iterator it = repos[i].query(new InstallableUnitQuery(id, VersionRange.emptyRange), new Collector(), null).iterator();
 			while (it.hasNext()) {
 				result.add(it.next());
 			}
@@ -148,8 +150,8 @@ public class End2EndTest extends AbstractProvisioningTest {
 
 	public IInstallableUnit getIU(String id) {
 		for (int i = 0; i < repos.length; i++) {
-			Iterator it = repos[i].getIterator(id, VersionRange.emptyRange, null, false);
-			while (it.hasNext()) {
+			Iterator it = repos[i].query(new InstallableUnitQuery(id, VersionRange.emptyRange), new Collector(), null).iterator();
+			if (it.hasNext()) {
 				return (IInstallableUnit) it.next();
 			}
 		}
@@ -158,7 +160,7 @@ public class End2EndTest extends AbstractProvisioningTest {
 
 	public IInstallableUnit getIU(String id, Version v) {
 		for (int i = 0; i < repos.length; i++) {
-			Iterator it = repos[i].getIterator(id, new VersionRange("[" + v.toString() + "," + v.toString() + "]"), null, false);
+			Iterator it = repos[i].query(new InstallableUnitQuery(id, v), new Collector(), null).iterator();
 			while (it.hasNext()) {
 				return (IInstallableUnit) it.next();
 			}
