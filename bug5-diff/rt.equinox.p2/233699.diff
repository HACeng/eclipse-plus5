commit de378e7f3f78e374beb8183e0b2b68f2c27e1cae
Author: Pascal Rapicault <prapicau>
Date:   Thu Jan 15 03:42:24 2009 +0000

    Bug 233699 - Add support for version types other than OSGi

24	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/FormatException.java
128	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/Messages.java
1	1	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/Version.java
1253	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionFormat.java
528	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionFormatParser.java
364	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionParser.java
1	1	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionRange.java
367	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionVector.java
61	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/messages.properties
24	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/FormatException.java
128	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Messages.java
1	1	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Version.java
1253	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionFormat.java
528	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionFormatParser.java
364	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionParser.java
1	1	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionRange.java
367	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionVector.java
61	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/messages.properties
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AutomatedTests.java
43	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/AllTests.java
187	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/CommonPatternsTest.java
131	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatATest.java
71	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatArrayTest.java
192	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatDTest.java
122	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatNTest.java
30	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatPTest.java
255	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatProcessingTest.java
313	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatQTest.java
85	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatRTest.java
101	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatRangeTest.java
192	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatSTest.java
36	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatTest.java
189	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/IntersectionTest.java
294	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/MultiplicityTest.java
119	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/OSGiRangeTest.java
231	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/OSGiVersionTest.java
261	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/PerformanceTest.java
161	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawRangeTest.java
143	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawRangeWithOriginalTest.java
1002	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawVersionTest.java
144	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawWithOriginalTest.java
193	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/VersionTesting.java
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/FormatException.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/FormatException.java
new file mode 100644
index 0000000..d4a555d
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/FormatException.java
@@ -0,0 +1,24 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core;
+
+/**
+ * Exception thrown by the {@link VersionFormatParser}
+ *
+ */
+public class FormatException extends Exception {
+
+	private static final long serialVersionUID = -867104101610941043L;
+
+	public FormatException(String message) {
+		super(message);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/Messages.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/Messages.java
new file mode 100644
index 0000000..69b0c41
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/Messages.java
@@ -0,0 +1,128 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+ package org.eclipse.equinox.internal.provisional.p2.core;
+
+import org.eclipse.osgi.util.NLS;
+
+public class Messages extends NLS {
+	public static String _0_is_not_a_positive_integer_in_osgi_1;
+
+	public static String _0_is_not_a_string_in_osgi_1;
+
+	public static String _0_is_not_a_valid_qualifier_in_osgi_1;
+
+	public static String array_can_not_be_empty;
+
+	public static String array_can_not_have_character_group;
+
+	public static String auto_can_not_have_pad_value;
+
+	public static String cannot_combine_ignore_with_other_instruction;
+
+	public static String cannot_combine_range_upper_bound_with_pad_value;
+
+	public static String character_group_defined_more_then_once;
+
+	public static String colon_expected_before_original_version_0;
+
+	public static String default_defined_more_then_once;
+
+	public static String delimiter_can_not_be_ignored;
+
+	public static String delimiter_can_not_have_default_value;
+
+	public static String delimiter_can_not_have_pad_value;
+
+	public static String delimiter_can_not_have_range;
+
+	public static String EOS_after_escape;
+
+	public static String expected_orignal_after_colon_0;
+
+	public static String expected_orignal_after_slash_0;
+
+	public static String expected_slash_after_raw_vector_0;
+
+	public static String format_0_unable_to_parse_1;
+
+	public static String format_0_unable_to_parse_empty_version;
+
+	public static String format_is_empty;
+
+	public static String format_must_be_delimited_by_colon_0;
+
+	public static String group_can_not_be_empty;
+
+	public static String ignore_defined_more_then_once;
+
+	public static String illegal_character_encountered_ascii_0;
+
+	public static String illegal_number_of_entries_0_in_osgi_1;
+
+	public static String missing_comma_in_range_0;
+
+	public static String negative_character_range;
+
+	public static String neither_raw_vector_nor_format_specified_0;
+
+	public static String number_can_not_have_pad_value;
+
+	public static String only_format_specified_0;
+
+	public static String original_must_start_with_colon_0;
+
+	public static String original_stated_but_missing_0;
+
+	public static String pad_defined_more_then_once;
+
+	public static String pad_not_allowed_in_osgi_0;
+
+	public static String premature_end_of_format;
+
+	public static String premature_end_of_format_expected_0;
+
+	public static String premature_EOS_0;
+
+	public static String range_boundaries_0_and_1_cannot_have_different_formats;
+
+	public static String range_defined_more_then_once;
+
+	public static String range_max_cannot_be_less_then_range_min;
+
+	public static String range_max_cannot_be_zero;
+
+	public static String range_min_0_is_not_less_then_range_max_1;
+
+	public static String raw_and_original_must_use_same_range_inclusion_0;
+
+	public static String raw_element_can_not_have_pad_value;
+
+	public static String raw_element_expected_0;
+
+	public static String string_can_not_have_pad_value;
+
+	public static String syntax_error_in_version_format_0_1_2;
+
+	public static String syntax_error_in_version_format_0_1_found_2_expected_3;
+
+	public static String unbalanced_format_parenthesis;
+
+	private static final String BUNDLE_NAME = "org.eclipse.equinox.internal.provisional.p2.core.messages"; //$NON-NLS-1$
+
+	static {
+		// initialize resource bundle
+		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
+	}
+
+	private Messages() {
+		// Prevent instance creation
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/Version.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/Version.java
index 4e3c699..32c05bd 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/Version.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/Version.java
@@ -1 +1 @@
-/* * Copyright (c) OSGi Alliance (2004, 2008). All Rights Reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//******************************************************************************* * Copyright (c) 2008 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: *     IBM Corporation - initial API and implementation *******************************************************************************/package org.eclipse.equinox.internal.provisional.p2.core;import java.util.NoSuchElementException;import java.util.StringTokenizer;/** * Version identifier for bundles and packages. *  * <p> * Version identifiers have four components. * <ol> * <li>Major version. A non-negative integer.</li> * <li>Minor version. A non-negative integer.</li> * <li>Micro version. A non-negative integer.</li> * <li>Qualifier. A text string. See <code>Version(String)</code> for the * format of the qualifier string.</li> * </ol> *  * <p> * <code>Version</code> objects are immutable. *  * @since 1.3 * @Immutable * @version $Revision: 5962 $ */public class Version implements Comparable {	private final int major;	private final int minor;	private final int micro;	private final String qualifier;	private static final String SEPARATOR = "."; //$NON-NLS-1$	/**	 * The empty version "0.0.0". Equivalent to calling	 * <code>new Version(0,0,0)</code>.	 */	public static final Version emptyVersion = new Version(0, 0, 0);	/**	 * Creates a version identifier from the specified numerical components.	 * 	 * <p>	 * The qualifier is set to the empty string.	 * 	 * @param major Major component of the version identifier.	 * @param minor Minor component of the version identifier.	 * @param micro Micro component of the version identifier.	 * @throws IllegalArgumentException If the numerical components are	 *         negative.	 */	public Version(int major, int minor, int micro) {		this(major, minor, micro, null);	}	/**	 * Creates a version identifier from the specified components.	 * 	 * @param major Major component of the version identifier.	 * @param minor Minor component of the version identifier.	 * @param micro Micro component of the version identifier.	 * @param qualifier Qualifier component of the version identifier. If	 *        <code>null</code> is specified, then the qualifier will be set to	 *        the empty string.	 * @throws IllegalArgumentException If the numerical components are negative	 *         or the qualifier string is invalid.	 */	public Version(int major, int minor, int micro, String qualifier) {		if (qualifier == null) {			qualifier = ""; //$NON-NLS-1$		}		this.major = major;		this.minor = minor;		this.micro = micro;		this.qualifier = qualifier;		validate();	}	/**	 * Created a version identifier from the specified string.	 * 	 * <p>	 * Here is the grammar for version strings.	 * 	 * <pre>	 * version ::= major('.'minor('.'micro('.'qualifier)?)?)?	 * major ::= digit+	 * minor ::= digit+	 * micro ::= digit+	 * qualifier ::= (alpha|digit|'_'|'-')+	 * digit ::= [0..9]	 * alpha ::= [a..zA..Z]	 * </pre>	 * 	 * There must be no whitespace in version.	 * 	 * @param version String representation of the version identifier.	 * @throws IllegalArgumentException If <code>version</code> is improperly	 *         formatted.	 */	public Version(String version) {		int major = 0;		int minor = 0;		int micro = 0;		String qualifier = ""; //$NON-NLS-1$		try {			StringTokenizer st = new StringTokenizer(version, SEPARATOR, true);			major = Integer.parseInt(st.nextToken());			if (st.hasMoreTokens()) {				st.nextToken(); // consume delimiter				minor = Integer.parseInt(st.nextToken());				if (st.hasMoreTokens()) {					st.nextToken(); // consume delimiter					micro = Integer.parseInt(st.nextToken());					if (st.hasMoreTokens()) {						st.nextToken(); // consume delimiter						qualifier = st.nextToken();						if (st.hasMoreTokens()) {							throw new IllegalArgumentException("invalid format"); //$NON-NLS-1$						}					}				}			}		} catch (NoSuchElementException e) {			throw new IllegalArgumentException("invalid format"); //$NON-NLS-1$		}		this.major = major;		this.minor = minor;		this.micro = micro;		this.qualifier = qualifier;		validate();	}	/**	 * Called by the Version constructors to validate the version components.	 * 	 * @throws IllegalArgumentException If the numerical components are negative	 *         or the qualifier string is invalid.	 */	private void validate() {		if (major < 0) {			throw new IllegalArgumentException("negative major"); //$NON-NLS-1$		}		if (minor < 0) {			throw new IllegalArgumentException("negative minor"); //$NON-NLS-1$		}		if (micro < 0) {			throw new IllegalArgumentException("negative micro"); //$NON-NLS-1$		}		char[] chars = qualifier.toCharArray();		for (int i = 0, length = chars.length; i < length; i++) {			char ch = chars[i];			if (('A' <= ch) && (ch <= 'Z')) {				continue;			}			if (('a' <= ch) && (ch <= 'z')) {				continue;			}			if (('0' <= ch) && (ch <= '9')) {				continue;			}			if ((ch == '_') || (ch == '-')) {				continue;			}			throw new IllegalArgumentException("invalid qualifier: " + qualifier); //$NON-NLS-1$		}	}	/**	 * Parses a version identifier from the specified string.	 * 	 * <p>	 * See <code>Version(String)</code> for the format of the version string.	 * 	 * @param version String representation of the version identifier. Leading	 *        and trailing whitespace will be ignored.	 * @return A <code>Version</code> object representing the version	 *         identifier. If <code>version</code> is <code>null</code> or	 *         the empty string then <code>emptyVersion</code> will be	 *         returned.	 * @throws IllegalArgumentException If <code>version</code> is improperly	 *         formatted.	 */	public static Version parseVersion(String version) {		if (version == null) {			return emptyVersion;		}		version = version.trim();		if (version.length() == 0) {			return emptyVersion;		}		return new Version(version);	}	/**	 * Returns the major component of this version identifier.	 * 	 * @return The major component.	 */	public int getMajor() {		return major;	}	/**	 * Returns the minor component of this version identifier.	 * 	 * @return The minor component.	 */	public int getMinor() {		return minor;	}	/**	 * Returns the micro component of this version identifier.	 * 	 * @return The micro component.	 */	public int getMicro() {		return micro;	}	/**	 * Returns the qualifier component of this version identifier.	 * 	 * @return The qualifier component.	 */	public String getQualifier() {		return qualifier;	}	/**	 * Returns the string representation of this version identifier.	 * 	 * <p>	 * The format of the version string will be <code>major.minor.micro</code>	 * if qualifier is the empty string or	 * <code>major.minor.micro.qualifier</code> otherwise.	 * 	 * @return The string representation of this version identifier.	 */	public String toString() {		int q = qualifier.length();		StringBuffer result = new StringBuffer(20 + q);		result.append(major);		result.append(SEPARATOR);		result.append(minor);		result.append(SEPARATOR);		result.append(micro);		if (q > 0) {			result.append(SEPARATOR);			result.append(qualifier);		}		return result.toString();	}	/**	 * Returns a hash code value for the object.	 * 	 * @return An integer which is a hash code value for this object.	 */	public int hashCode() {		return (major << 24) + (minor << 16) + (micro << 8) + qualifier.hashCode();	}	/**	 * Compares this <code>Version</code> object to another object.	 * 	 * <p>	 * A version is considered to be <b>equal to </b> another version if the	 * major, minor and micro components are equal and the qualifier component	 * is equal (using <code>String.equals</code>).	 * 	 * @param object The <code>Version</code> object to be compared.	 * @return <code>true</code> if <code>object</code> is a	 *         <code>Version</code> and is equal to this object;	 *         <code>false</code> otherwise.	 */	public boolean equals(Object object) {		if (object == this) { // quicktest			return true;		}		if (!(object instanceof Version)) {			return false;		}		Version other = (Version) object;		return (major == other.major) && (minor == other.minor) && (micro == other.micro) && qualifier.equals(other.qualifier);	}	/**	 * Compares this <code>Version</code> object to another object.	 * 	 * <p>	 * A version is considered to be <b>less than </b> another version if its	 * major component is less than the other version's major component, or the	 * major components are equal and its minor component is less than the other	 * version's minor component, or the major and minor components are equal	 * and its micro component is less than the other version's micro component,	 * or the major, minor and micro components are equal and it's qualifier	 * component is less than the other version's qualifier component (using	 * <code>String.compareTo</code>).	 * 	 * <p>	 * A version is considered to be <b>equal to</b> another version if the	 * major, minor and micro components are equal and the qualifier component	 * is equal (using <code>String.compareTo</code>).	 * 	 * @param object The <code>Version</code> object to be compared.	 * @return A negative integer, zero, or a positive integer if this object is	 *         less than, equal to, or greater than the specified	 *         <code>Version</code> object.	 * @throws ClassCastException If the specified object is not a	 *         <code>Version</code>.	 */	public int compareTo(Object object) {		if (object == this) { // quicktest			return 0;		}		Version other = (Version) object;		int result = major - other.major;		if (result != 0) {			return result;		}		result = minor - other.minor;		if (result != 0) {			return result;		}		result = micro - other.micro;		if (result != 0) {			return result;		}		return qualifier.compareTo(other.qualifier);	}	public static Version fromOSGiVersion(org.osgi.framework.Version version) {		if (version.equals(org.osgi.framework.Version.emptyVersion))			return emptyVersion;		return new Version(version.getMajor(), version.getMinor(), version.getMicro(), version.getQualifier());	}	public static org.osgi.framework.Version toOSGiVersion(Version version) {		if (version.equals(emptyVersion))			return org.osgi.framework.Version.emptyVersion;		return new org.osgi.framework.Version(version.getMajor(), version.getMinor(), version.getMicro(), version.getQualifier());	}}
\ No newline at end of file
+/******************************************************************************* * Copyright (c) 2009 Cloudsmith and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *  * Contributors: *     Cloudsmith Inc - initial API and implementation. *******************************************************************************/package org.eclipse.equinox.internal.provisional.p2.core;import org.eclipse.osgi.util.NLS;/** * <p>The Omni Version is composed of a vector of Comparable objects and a pad value. The pad * might be <code>null</code>. The vector can contain integers, strings, {@link VersionVector} * instances, or one of the special objects {@link VersionVector#MAX_VALUE MAX_VALUE}, * {@link VersionVector#MAXS_VALUE MAXS_VALUE}, or {@link VersionVector#MIN_VALUE MIN_VALUE}.</p> * * <p>When two versions are compared, they are always considered padded to infinity by their * pad value or by {@link VersionVector#MIN_VALUE MIN_VALUE} in case the pad value is * <code>null</code>. The comparison is type sensitive so that:</p><pre> * MAX_VALUE &gt; Integer &gt; VersionVector &gt; MAXS_VALUE &gt; String &gt; MIN_VALUE<br/> * </pre> * * The class is signature compatible with {@link org.osgi.framework.Version} but attempts * to use it as such might render a {@link UnsupportedOperationException} in case the * vector holds incompatible values. The method {@link #isOSGiCompatible()} can be used * to test. *  * @Immutable * @noextend This class is not intended to be subclassed by clients. */public class Version extends VersionVector {	private static final Integer cache[] = new Integer[100];	private static final char[] allowedOSGiChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-".toCharArray(); //$NON-NLS-1$	public static final Integer ZERO_INT = new Integer(0);	public static final Integer MAX_INT_OBJ = new Integer(Integer.MAX_VALUE);	static {		cache[0] = ZERO_INT;		for (int i = 1; i < cache.length; i++)			cache[i] = new Integer(i);	}	static Integer valueOf(int i) {		try {			return cache[i];		} catch (ArrayIndexOutOfBoundsException e) {			return (i == Integer.MAX_VALUE) ? MAX_INT_OBJ : new Integer(i);		}	}	/**	 * The empty OSGi version "0.0.0". Equivalent to calling	 * <code>new Version(0,0,0)</code>.	 */	public static final Version emptyVersion = new Version(0, 0, 0);	/**	 * The version that is semantically greater then all other versions.	 */	public static final Version MAX_VERSION = new Version("raw:MpM"); //$NON-NLS-1$	/**	 * The version that is semantically less then all other versions.	 */	public static final Version MIN_VERSION = new Version("raw:-M"); //$NON-NLS-1$	private static final long serialVersionUID = 8202715438560849928L;	/**	 * Create an omni version from an OSGi <code>version</code>.	 * @param version The OSGi version. Can be <code>null</code>.	 * @return The created omni version	 */	public static Version fromOSGiVersion(org.osgi.framework.Version version) {		if (version == null)			return null;		if (version.equals(org.osgi.framework.Version.emptyVersion))			return emptyVersion;		return new Version(version.getMajor(), version.getMinor(), version.getMicro(), version.getQualifier());	}	/**	 * Parses a version identifier from the specified string.	 * 	 * <p>	 * See {@link #Version(String)} for the format of the version string.	 * 	 * @param version String representation of the version identifier. Leading	 *        and trailing whitespace will be ignored.	 * @return A <code>Version</code> object representing the version	 *         identifier. If <code>version</code> is <code>null</code> or	 *         the empty string then <code>emptyVersion</code> will be	 *         returned.	 * @throws IllegalArgumentException If <code>version</code> is improperly	 *         formatted.	 */	public static Version parseVersion(String version) {		if (version != null) {			Version v = new Version();			if (VersionParser.parseInto(version, 0, version.length(), v))				return v;		}		return Version.emptyVersion;	}	/**	 * Convert <code>version</code> into its OSGi equivalent if possible.	 *	 * @param version The version to convert. Can be <code>null</code>	 * @return The converted version or <code>null</code> if the argument was <code>null</code>	 * @throws UnsupportedOperationException if the version could not be converted into an OSGi version	 */	public static org.osgi.framework.Version toOSGiVersion(Version version) {		if (version == null)			return null;		if (version.equals(emptyVersion))			return org.osgi.framework.Version.emptyVersion;		return new org.osgi.framework.Version(version.getMajor(), version.getMinor(), version.getMicro(), version.getQualifier());	}	/**	 * For exception messages only	 * @param i the index of the entry	 * @return the name of the entry	 */	private static String getOSGiEntryName(int i) {		String name = null;		switch (i) {			case 0 :				name = "major"; //$NON-NLS-1$				break;			case 1 :				name = "minor"; //$NON-NLS-1$				break;			case 2 :				name = "micro"; //$NON-NLS-1$				break;			case 4 :				name = "qualifier"; //$NON-NLS-1$		}		return name;	}	/**	 * The optional format	 */	private VersionFormat format;	/**	 * The optional original string	 */	private String original;	/**	 * Creates an OSGi version identifier from the specified numerical components.	 * 	 * <p>	 * The qualifier is set to the empty string.	 * 	 * @param major Major component of the version identifier.	 * @param minor Minor component of the version identifier.	 * @param micro Micro component of the version identifier.	 * @throws IllegalArgumentException If the numerical components are	 *         negative.	 */	public Version(int major, int minor, int micro) {		this(major, minor, micro, null);	}	/**	 * Creates an OSGi version identifier from the specified components.	 * 	 * @param major Major component of the version identifier.	 * @param minor Minor component of the version identifier.	 * @param micro Micro component of the version identifier.	 * @param qualifier Qualifier component of the version identifier. If	 *        <code>null</code> is specified, then the qualifier will be set to	 *        the empty string.	 * @throws IllegalArgumentException If the numerical components are negative	 *         or the qualifier string is invalid.	 */	public Version(int major, int minor, int micro, String qualifier) {		if (qualifier != null && qualifier.length() == 0)			qualifier = null;		Comparable[] vector = new Comparable[qualifier == null ? 3 : 4];		vector[0] = valueOf(major);		vector[1] = valueOf(minor);		vector[2] = valueOf(micro);		if (qualifier != null)			vector[3] = qualifier;		init(vector, null, VersionFormat.OSGI_FORMAT, null);		validateOSGI(true);	}	/**	 * Created a version identifier from the specified string.	 * 	 * @param version String representation of the version identifier.	 * @throws IllegalArgumentException If <code>version</code> is improperly	 *         formatted.	 */	public Version(String version) {		VersionParser.parseInto(version, 0, version.length(), this);	}	Version() {		// Empty constructor	}	Version(Comparable[] array, Comparable padValue, VersionFormat format, String original) {		init(array, padValue, format, original);	}	/**	 * Returns the optional format.	 */	public VersionFormat getFormat() {		return format;	}	/**	 * Returns the OSGi major component of this version identifier.	 * 	 * @return The major component.	 * @throws UnsupportedOperationException if the first element in the	 * vector is not a number.	 * @see #isOSGiCompatible()	 */	public int getMajor() {		return getIntElement(0);	}	/**	 * Returns the OSGi micro component of this version identifier.	 * 	 * @return The micro component.	 * @throws UnsupportedOperationException if the third element in the	 * vector is not a number.	 * @see #isOSGiCompatible()	 */	public int getMicro() {		return getIntElement(2);	}	/**	 * Returns the OSGi minor component of this version identifier.	 * 	 * @return The minor component.	 * @throws UnsupportedOperationException if the second element in the	 * vector is not a number.	 * @see #isOSGiCompatible()	 */	public int getMinor() {		return getIntElement(1);	}	/**	 * Returns the <code>original</code> part of the string for this version	 * or <code>null</code> if no such part was provided when the version was	 * created. An OSGi type version will always return the OSGi string representation.	 *	 * @return The <code>original</code> part of the version string or	 * <code>null</code> if that part was missing.	 */	public String getOriginal() {		return original;	}	/**	 * Returns the OSGi qualifier component of this version identifier.	 * 	 * @return The qualifier component or <code>null</code> if not set.	 * @throws UnsupportedOperationException if the fourth element in the	 * vector is set to something other then a string.	 * @see #isOSGiCompatible()	 */	public String getQualifier() {		Comparable[] vector = getVector();		if (vector.length < 4)			return null;		if (!(vector[3] instanceof String))			throw new UnsupportedOperationException();		return (String) vector[3];	}	/**	 * Checks if this version is in compliance with the OSGi version spec.	 * @return A flag indicating whether the version is OSGi compatible or not.	 */	public boolean isOSGiCompatible() {		return format == VersionFormat.OSGI_FORMAT || validateOSGI(false);	}	/**	 * Appends the original for this version onto the <code>sb</code> StringBuffer	 * if present.	 * @param sb The buffer that will receive the raw string format	 * @param rangeSafe Set to <code>true</code> if range delimiters should be escaped	 */	public void originalToString(StringBuffer sb, boolean rangeSafe) {		if (original != null) {			if (rangeSafe) {				// Escape all range delimiters while appending				String s = original;				int end = s.length();				for (int idx = 0; idx < end; ++idx) {					char c = s.charAt(idx);					if (c == '\\' || c == '[' || c == '(' || c == ']' || c == ')' || c == ',' || c <= ' ')						sb.append('\\');					sb.append(c);				}			} else				sb.append(original);		}	}	/**	 * Appends the raw format for this version onto the <code>sb</code> StringBuffer.	 * @param sb The buffer that will receive the raw string format	 * @param rangeSafe Set to <code>true</code> if range delimiters should be escaped	 */	public void rawToString(StringBuffer sb, boolean rangeSafe) {		super.toString(sb, rangeSafe);	}	/**	 * Appends the string representation of this version onto the	 * <code>sb</code> StringBuffer.	 * @param sb The buffer that will receive the version string	 */	public void toString(StringBuffer sb) {		if (format == VersionFormat.OSGI_FORMAT) {			Comparable[] vector = getVector();			sb.append(vector[0]);			sb.append('.');			sb.append(vector[1]);			sb.append('.');			sb.append(vector[2]);			if (vector.length > 3) {				sb.append('.');				sb.append(vector[3]);			}			return;		}		sb.append(VersionParser.RAW_PREFIX);		super.toString(sb, false);		if (format != null || original != null) {			sb.append('/');			if (format != null)				format.toString(sb);			if (original != null) {				sb.append(':');				originalToString(sb, false);			}		}	}	void init(Comparable[] vec, Comparable pad, VersionFormat fmt, String orig) {		init(vec, pad);		format = fmt;		original = orig;	}	private int getIntElement(int i) {		Comparable[] vector = getVector();		if (!(vector.length > i && vector[i] instanceof Integer))			throw new UnsupportedOperationException();		return ((Integer) vector[i]).intValue();	}	// Preserve singletons during deserialization	private Object readResolve() {		Version v = this;		if (equals(MAX_VERSION))			v = MAX_VERSION;		else if (equals(MIN_VERSION))			v = MIN_VERSION;		else if (equals(emptyVersion))			v = emptyVersion;		else if (equals(VersionRange.OSGi_versionMax))			v = VersionRange.OSGi_versionMax;		else if (equals(VersionRange.OSGi_versionMin))			v = VersionRange.OSGi_versionMin;		return v;	}	boolean validateOSGI(boolean throwDetailed) {		Comparable[] vector = getVector();		if (vector.length < 3 || vector.length > 4) {			if (throwDetailed)				throw new IllegalArgumentException(NLS.bind(Messages.illegal_number_of_entries_0_in_osgi_1, valueOf(vector.length), this));			return false;		}		if (getPad() != null) {			if (throwDetailed)				throw new IllegalArgumentException(NLS.bind(Messages.pad_not_allowed_in_osgi_0, this));			return false;		}		for (int i = 0; i < 3; ++i) {			Object e = vector[i];			if (!(e instanceof Integer && ((Integer) e).intValue() >= 0)) {				if (throwDetailed)					throw new IllegalArgumentException(NLS.bind(Messages._0_is_not_a_positive_integer_in_osgi_1, getOSGiEntryName(i), this));				return false;			}		}		if (vector.length == 4) {			Object e = vector[3];			if (!(e instanceof String)) {				if (throwDetailed)					throw new IllegalArgumentException(NLS.bind(Messages._0_is_not_a_string_in_osgi_1, getOSGiEntryName(3), this));				return false;			}			String s = (String) e;			int idx = s.length();			char[] allowed = allowedOSGiChars;			int ctop = allowed.length;			outer: while (--idx >= 0) {				char c = s.charAt(idx);				int cdx = ctop;				while (--cdx >= 0)					if (c == allowed[cdx])						continue outer;				if (throwDetailed)					throw new IllegalArgumentException(NLS.bind(Messages._0_is_not_a_valid_qualifier_in_osgi_1, getOSGiEntryName(3), this));				return false;			}		}		return true;	}}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionFormat.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionFormat.java
new file mode 100644
index 0000000..19a70a9
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionFormat.java
@@ -0,0 +1,1253 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core;
+
+import java.io.Serializable;
+import java.util.*;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * <p>The VersionFormat represents the Omni Version Format in compiled form. It
+ * is also a parser for versions of that format.</p>
+ * <p>An instance of VersionFormat is immutable and thus thread safe. The parser
+ * does not maintain any state.</p>
+ * 
+ * @Immutable
+ * @noextend This class is not intended to be subclassed by clients.
+ */
+public class VersionFormat implements Serializable {
+	private static final long serialVersionUID = 6888925893926932754L;
+
+	/**
+	 * Represents one fragment of a format (i.e. auto, number, string, delimiter, etc.)
+	 */
+	static abstract class Fragment implements Serializable {
+		private static final long serialVersionUID = 4109185333058622681L;
+
+		private final Qualifier qualifier;
+
+		Fragment(Qualifier qualifier) {
+			this.qualifier = qualifier;
+		}
+
+		public final boolean equals(Object f) {
+			return f == this || getClass().equals(f.getClass()) && qualifier.equals(((Fragment) f).qualifier);
+		}
+
+		public final int hashCode() {
+			return 11 * qualifier.hashCode();
+		}
+
+		public boolean isGroup() {
+			return false;
+		}
+
+		public String toString() {
+			StringBuffer sb = new StringBuffer();
+			toString(sb);
+			return sb.toString();
+		}
+
+		Comparable getDefaultValue() {
+			return null;
+		}
+
+		Fragment getFirstLeaf() {
+			return this;
+		}
+
+		Comparable getPadValue() {
+			return null;
+		}
+
+		Qualifier getQualifier() {
+			return qualifier;
+		}
+
+		boolean parse(List segments, String version, int maxPos, TreeInfo info) {
+			return qualifier.parse(new Fragment[] {this}, 0, segments, version, maxPos, info);
+		}
+
+		abstract boolean parseOne(List segments, String version, int maxPos, TreeInfo info);
+
+		void setDefaults(List segments) {
+			// No-op at this level
+		}
+
+		void toString(StringBuffer sb) {
+			if (!(qualifier == VersionFormatParser.EXACT_ONE_QUALIFIER || (qualifier == VersionFormatParser.ZERO_OR_ONE_QUALIFIER && this.isGroup())))
+				qualifier.toString(sb);
+		}
+	}
+
+	/**
+	 * Specifies the min and max occurrences of a fragment
+	 */
+	static class Qualifier implements Serializable {
+		private static final long serialVersionUID = 7494021832824671685L;
+
+		private final int max;
+		private final int min;
+
+		Qualifier(int min, int max) {
+			this.min = min;
+			this.max = max;
+		}
+
+		public boolean equals(Object o) {
+			if (o == this)
+				return true;
+			if (!(o instanceof Qualifier))
+				return false;
+			Qualifier oq = (Qualifier) o;
+			return min == oq.min && max == oq.max;
+		}
+
+		public int hashCode() {
+			return 31 * min + 67 * max;
+		}
+
+		public String toString() {
+			StringBuffer sb = new StringBuffer();
+			toString(sb);
+			return sb.toString();
+		}
+
+		int getMax() {
+			return max;
+		}
+
+		int getMin() {
+			return min;
+		}
+
+		boolean parse(Fragment[] fragments, int fragIdx, List segments, String version, int maxPos, TreeInfo info) {
+			Fragment fragment = fragments[fragIdx++];
+			int idx = 0;
+
+			// Do the required parsing. I.e. iterate this fragment
+			// min number of times.
+			//
+			for (; idx < min; ++idx)
+				if (!fragment.parseOne(segments, version, maxPos, info))
+					return false;
+
+			for (; idx < max; ++idx) {
+				// We are greedy. Continue parsing until we get an exception
+				// and remember the state before each parse is performed.
+				//
+				info.pushState(segments.size(), fragment);
+				if (!fragment.parseOne(segments, version, maxPos, info)) {
+					info.popState(segments, fragment);
+					break;
+				}
+			}
+			int maxParsed = idx;
+
+			for (;;) {
+				// Pad with default values unless the max is unbounded
+				//
+				if (max != Integer.MAX_VALUE) {
+					for (; idx < max; ++idx)
+						fragment.setDefaults(segments);
+				}
+
+				if (fragIdx == fragments.length)
+					// We are the last segment
+					//
+					return true;
+
+				// Try to parse the next segment. If it fails, pop the state of
+				// this segment (or a child thereof) and try again
+				//
+				if (fragments[fragIdx].getQualifier().parse(fragments, fragIdx, segments, version, maxPos, info))
+					return true;
+
+				// Be less greedy, step back one position and try again.
+				//
+				if (maxParsed <= min)
+					// We have no more states to pop. Tell previous that we failed.
+					//
+					return false;
+
+				info.popState(segments, fragment);
+				idx = --maxParsed; // segments now have room for one more default value
+			}
+		}
+
+		void toString(StringBuffer sb) {
+			if (min == 0) {
+				if (max == 1)
+					sb.append('?');
+				else if (max == Integer.MAX_VALUE)
+					sb.append('*');
+				else {
+					sb.append('{');
+					sb.append(min);
+					sb.append(',');
+					sb.append(max);
+					sb.append('}');
+				}
+			} else if (max == Integer.MAX_VALUE) {
+				if (min == 1)
+					sb.append('+');
+				else {
+					sb.append('{');
+					sb.append(min);
+					sb.append(",}"); //$NON-NLS-1$
+				}
+			} else {
+				sb.append('{');
+				sb.append(min);
+				if (min != max) {
+					sb.append(',');
+					sb.append(max);
+				}
+				sb.append('}');
+			}
+		}
+
+		// Preserve singleton when deserialized
+		private Object readResolve() {
+			Qualifier q = this;
+			if (min == 0) {
+				if (max == 1)
+					q = VersionFormatParser.ZERO_OR_ONE_QUALIFIER;
+				else if (max == Integer.MAX_VALUE)
+					q = VersionFormatParser.ZERO_OR_MANY_QUALIFIER;
+			} else if (min == 1) {
+				if (max == 1)
+					q = VersionFormatParser.EXACT_ONE_QUALIFIER;
+				else if (max == Integer.MAX_VALUE)
+					q = VersionFormatParser.ONE_OR_MANY_QUALIFIER;
+			}
+			return q;
+		}
+	}
+
+	private static class AutoFragment extends RangeFragment {
+		private static final long serialVersionUID = -1016534328164247755L;
+
+		AutoFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+			super(instr, qualifier);
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			maxPos = checkRange(pos, maxPos);
+			if (maxPos < 0)
+				return false;
+
+			char c = version.charAt(pos);
+			if (VersionParser.isDigit(c) && isAllowed(c)) {
+				// Parse to next non-digit
+				//
+				int start = pos;
+				int value = c - '0';
+				while (++pos < maxPos) {
+					c = version.charAt(pos);
+					if (!(VersionParser.isDigit(c) && isAllowed(c)))
+						break;
+					value *= 10;
+					value += (c - '0');
+				}
+				int len = pos - start;
+				if (rangeMin > len || len > rangeMax)
+					return false;
+
+				if (!isIgnored())
+					segments.add(Version.valueOf(value));
+				info.setPosition(pos);
+				return true;
+			}
+
+			if (!(VersionParser.isLetter(c) && isAllowed(c)))
+				return false;
+
+			// Parse to next non-letter or next delimiter
+			//
+			int start = pos++;
+			for (; pos < maxPos; ++pos) {
+				c = version.charAt(pos);
+				if (!(VersionParser.isLetter(c) && isAllowed(c)))
+					break;
+			}
+			int len = pos - start;
+			if (rangeMin > len || len > rangeMax)
+				return false;
+
+			if (!isIgnored())
+				segments.add(version.substring(start, pos));
+			info.setPosition(pos);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append('a');
+			super.toString(sb);
+		}
+	}
+
+	private static class DelimiterFragment extends Fragment {
+		private static final long serialVersionUID = 8173654376143370605L;
+		private final char[] delimChars;
+		private final boolean inverted;
+
+		DelimiterFragment(VersionFormatParser.Instructions ep, Qualifier qualifier) {
+			super(qualifier);
+			if (ep == null) {
+				delimChars = null;
+				inverted = false;
+			} else {
+				inverted = ep.inverted;
+				delimChars = ep.characters;
+			}
+		}
+
+		boolean isMatch(String version, int pos) {
+			char c = version.charAt(pos);
+			if (delimChars != null) {
+				for (int idx = 0; idx < delimChars.length; ++idx)
+					if (c == delimChars[idx])
+						return !inverted;
+				return inverted;
+			} else if (VersionParser.isLetterOrDigit(c))
+				return false;
+
+			return true;
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			if (pos < maxPos && isMatch(version, pos)) {
+				// Just swallow, a delimiter does not contribute to the vector.
+				//
+				info.setPosition(pos + 1);
+				return true;
+			}
+			return false;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append('d');
+			if (delimChars != null)
+				appendCharacterRange(sb, delimChars, inverted);
+			super.toString(sb);
+		}
+	}
+
+	static boolean equalsAllowNull(Object a, Object b) {
+		return (a == null) ? (b == null) : (b != null && a.equals(b));
+	}
+
+	private static abstract class ElementFragment extends Fragment {
+		private static final long serialVersionUID = -6834591415456539713L;
+		private final Comparable defaultValue;
+		private final boolean ignored;
+		private final Comparable padValue;
+
+		ElementFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+			super(qualifier);
+			if (instr != null) {
+				ignored = instr.ignore;
+				defaultValue = instr.defaultValue;
+				padValue = instr.padValue;
+			} else {
+				ignored = false;
+				defaultValue = null;
+				padValue = null;
+			}
+		}
+
+		Comparable getDefaultValue() {
+			return defaultValue;
+		}
+
+		Comparable getPadValue() {
+			return padValue;
+		}
+
+		boolean isIgnored() {
+			return ignored;
+		}
+
+		void setDefaults(List segments) {
+			Object defaultVal = getDefaultValue();
+			if (defaultVal != null)
+				segments.add(defaultVal);
+		}
+
+		void toString(StringBuffer sb) {
+			if (ignored) {
+				sb.append('=');
+				sb.append('!');
+				sb.append(';');
+			}
+			if (defaultValue != null) {
+				sb.append('=');
+				VersionVector.rawToString(sb, false, defaultValue);
+				sb.append(';');
+			}
+			if (padValue != null) {
+				sb.append('=');
+				sb.append('p');
+				VersionVector.rawToString(sb, false, padValue);
+				sb.append(';');
+			}
+			super.toString(sb);
+		}
+	}
+
+	private static class GroupFragment extends ElementFragment {
+		private static final long serialVersionUID = 9219978678087669699L;
+		private final boolean array;
+		private final Fragment[] fragments;
+
+		GroupFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, Fragment[] fragments, boolean array) {
+			super(instr, qualifier);
+			this.fragments = fragments;
+			this.array = array;
+		}
+
+		public boolean isGroup() {
+			return !array;
+		}
+
+		Fragment getFirstLeaf() {
+			return fragments[0].getFirstLeaf();
+		}
+
+		Fragment[] getFragments() {
+			return fragments;
+		}
+
+		boolean isArray() {
+			return array;
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			if (array) {
+				ArrayList subSegs = new ArrayList();
+				boolean success = fragments[0].getQualifier().parse(fragments, 0, subSegs, version, maxPos, info);
+				if (!success || subSegs.isEmpty())
+					return false;
+
+				Comparable padValue = info.getPadValue();
+				if (padValue != null)
+					info.setPadValue(null); // Prevent outer group from getting this.
+				else
+					padValue = getPadValue();
+
+				VersionParser.removeRedundantTrail(segments, padValue);
+				segments.add(new VersionVector((Comparable[]) subSegs.toArray(new Comparable[subSegs.size()]), padValue));
+				return true;
+			}
+
+			if (fragments[0].getQualifier().parse(fragments, 0, segments, version, maxPos, info)) {
+				Comparable padValue = getPadValue();
+				if (padValue != null)
+					info.setPadValue(padValue);
+				return true;
+			}
+			return false;
+		}
+
+		void setDefaults(List segments) {
+			Comparable dflt = getDefaultValue();
+			if (dflt != null) {
+				// A group default overrides any defaults within the
+				// group fragments
+				super.setDefaults(segments);
+			} else {
+				// Assign defaults for all fragments
+				for (int idx = 0; idx < fragments.length; ++idx)
+					fragments[idx].setDefaults(segments);
+			}
+		}
+
+		void toString(StringBuffer sb) {
+			if (array) {
+				sb.append('<');
+				for (int idx = 0; idx < fragments.length; ++idx)
+					fragments[idx].toString(sb);
+				sb.append('>');
+			} else {
+				if (getQualifier() == VersionFormatParser.ZERO_OR_ONE_QUALIFIER) {
+					sb.append('[');
+					for (int idx = 0; idx < fragments.length; ++idx)
+						fragments[idx].toString(sb);
+					sb.append(']');
+				} else {
+					sb.append('(');
+					for (int idx = 0; idx < fragments.length; ++idx)
+						fragments[idx].toString(sb);
+					sb.append(')');
+				}
+			}
+			super.toString(sb);
+		}
+	}
+
+	private static class LiteralFragment extends Fragment {
+		private static final long serialVersionUID = 6210696245839471802L;
+		private final String string;
+
+		LiteralFragment(Qualifier qualifier, String string) {
+			super(qualifier);
+			this.string = string;
+		}
+
+		String getString() {
+			return string;
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			int litLen = string.length();
+			if (pos + litLen > maxPos)
+				return false;
+
+			for (int idx = 0; idx < litLen; ++idx, ++pos) {
+				if (string.charAt(idx) != version.charAt(pos))
+					return false;
+			}
+			info.setPosition(pos);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			String str = string;
+			if (str.length() != 1) {
+				sb.append('\'');
+				toStringEscaped(sb, str, "\'"); //$NON-NLS-1$
+				sb.append('\'');
+			} else {
+				char c = str.charAt(0);
+				switch (c) {
+					case '\'' :
+					case '\\' :
+					case '<' :
+					case '[' :
+					case '(' :
+					case '{' :
+					case '?' :
+					case '*' :
+					case '+' :
+					case '=' :
+						sb.append('\\');
+						sb.append(c);
+						break;
+					default :
+						if (VersionParser.isLetterOrDigit(c)) {
+							sb.append('\\');
+							sb.append(c);
+						} else
+							sb.append(c);
+				}
+			}
+			super.toString(sb);
+		}
+	}
+
+	private static class NumberFragment extends RangeFragment {
+		private static final long serialVersionUID = -8552754381106711507L;
+		private final boolean signed;
+
+		NumberFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, boolean signed) {
+			super(instr, qualifier);
+			this.signed = signed;
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			maxPos = checkRange(pos, maxPos);
+			if (maxPos < 0)
+				return false;
+
+			// Parse to next non-digit
+			//
+			int start = pos;
+			int value;
+
+			char c = version.charAt(pos);
+			if (signed || characters != null) {
+				boolean negate = false;
+				if (signed && c == '-' && pos + 1 < maxPos) {
+					negate = true;
+					c = version.charAt(++pos);
+				}
+
+				if (!(c >= '0' && c <= '9' && isAllowed(c)))
+					return false;
+
+				// Parse to next non-digit
+				//
+				value = c - '0';
+				while (++pos < maxPos) {
+					c = version.charAt(pos);
+					if (!(c >= '0' && c <= '9' && isAllowed(c)))
+						break;
+					value *= 10;
+					value += (c - '0');
+				}
+				if (negate)
+					value = -value;
+			} else {
+				if (c < '0' || c > '9')
+					return false;
+
+				// Parse to next non-digit
+				//
+				value = c - '0';
+				while (++pos < maxPos) {
+					c = version.charAt(pos);
+					if (c < '0' || c > '9')
+						break;
+					value *= 10;
+					value += (c - '0');
+				}
+			}
+
+			int len = pos - start;
+			if (rangeMin > len || len > rangeMax)
+				return false;
+
+			if (!isIgnored())
+				segments.add(Version.valueOf(value));
+			info.setPosition(pos);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append(signed ? 'N' : 'n');
+			super.toString(sb);
+		}
+	}
+
+	private static class PadFragment extends ElementFragment {
+		private static final long serialVersionUID = 5052010199974380170L;
+
+		PadFragment(Qualifier qualifier) {
+			super(null, qualifier);
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			if (pos >= maxPos || version.charAt(pos) != 'p')
+				return false;
+
+			int[] position = new int[] {++pos};
+			Comparable v = VersionParser.parseRawElement(version, position, maxPos);
+			if (v == null)
+				return false;
+
+			if (!isIgnored())
+				info.setPadValue(v);
+			info.setPosition(position[0]);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append('p');
+			super.toString(sb);
+		}
+	}
+
+	private static class QuotedFragment extends RangeFragment {
+		private static final long serialVersionUID = 6057751133533608969L;
+
+		QuotedFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+			super(instr, qualifier);
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			if (pos >= maxPos)
+				return false;
+
+			char endQuote;
+			char quote = version.charAt(pos);
+			switch (quote) {
+				case '<' :
+					endQuote = '>';
+					break;
+				case '{' :
+					endQuote = '}';
+					break;
+				case '(' :
+					endQuote = ')';
+					break;
+				case '[' :
+					endQuote = ']';
+					break;
+				case '>' :
+					endQuote = '<';
+					break;
+				case '}' :
+					endQuote = '{';
+					break;
+				case ')' :
+					endQuote = '(';
+					break;
+				case ']' :
+					endQuote = '[';
+					break;
+				default :
+					if (VersionParser.isLetterOrDigit(quote))
+						return false;
+					endQuote = quote;
+			}
+			int start = ++pos;
+			char c = version.charAt(pos);
+			while (c != endQuote && isAllowed(c) && ++pos < maxPos)
+				c = version.charAt(pos);
+
+			if (c != endQuote || rangeMin > pos - start)
+				// End quote not found
+				return false;
+
+			int len = pos - start;
+			if (rangeMin > len || len > rangeMax)
+				return false;
+
+			if (!isIgnored())
+				segments.add(version.substring(start, pos));
+			info.setPosition(++pos); // Skip quote
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append('q');
+			super.toString(sb);
+		}
+	}
+
+	private static abstract class RangeFragment extends ElementFragment {
+		private static final long serialVersionUID = -6680402803630334708L;
+		final char[] characters;
+		final boolean inverted;
+		final int rangeMax;
+		final int rangeMin;
+
+		RangeFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+			super(instr, qualifier);
+			if (instr == null) {
+				characters = null;
+				inverted = false;
+				rangeMin = 0;
+				rangeMax = Integer.MAX_VALUE;
+			} else {
+				characters = instr.characters;
+				inverted = instr.inverted;
+				rangeMin = instr.rangeMin;
+				rangeMax = instr.rangeMax;
+			}
+		}
+
+		/**
+		 * Checks that pos is at a valid character position, that we
+		 * have at least the required minimum characters left, and
+		 * if a maximum number of characters is set, limits the
+		 * returned value to a maxPos that reflects that maximum.
+		 * @param pos the current position
+		 * @param maxPos the current maxPos
+		 * @return maxPos, possibly limited by rangeMax
+		 */
+		int checkRange(int pos, int maxPos) {
+			int check = pos;
+			if (rangeMin == 0)
+				check++; // Verify one character
+			else
+				check += rangeMin;
+
+			if (check > maxPos)
+				// Less then min characters left
+				maxPos = -1;
+			else {
+				if (rangeMax != Integer.MAX_VALUE) {
+					check = pos + rangeMax;
+					if (check < maxPos)
+						maxPos = check;
+				}
+			}
+			return maxPos;
+		}
+
+		boolean isAllowed(char c) {
+			char[] crs = characters;
+			if (crs != null) {
+				int idx = crs.length;
+				while (--idx >= 0)
+					if (c == crs[idx])
+						return !inverted;
+				return inverted;
+			}
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			if (characters != null)
+				appendCharacterRange(sb, characters, inverted);
+			if (rangeMin != 0 || rangeMax != Integer.MAX_VALUE) {
+				sb.append('=');
+				sb.append('{');
+				sb.append(rangeMin);
+				if (rangeMin != rangeMax) {
+					sb.append(',');
+					if (rangeMax != Integer.MAX_VALUE)
+						sb.append(rangeMax);
+				}
+				sb.append('}');
+				sb.append(';');
+			}
+			super.toString(sb);
+		}
+	}
+
+	private static class RawFragment extends ElementFragment {
+		private static final long serialVersionUID = 4107448125256042602L;
+
+		RawFragment(VersionFormatParser.Instructions processing, Qualifier qualifier) {
+			super(processing, qualifier);
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int[] position = new int[] {info.getPosition()};
+			Comparable v = VersionParser.parseRawElement(version, position, maxPos);
+			if (v == null)
+				return false;
+
+			if (!isIgnored())
+				segments.add(v);
+			info.setPosition(position[0]);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append('r');
+			super.toString(sb);
+		}
+	}
+
+	private static class StringFragment extends RangeFragment {
+		private static final long serialVersionUID = -2265924553606430164L;
+		final boolean anyChar;
+
+		StringFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, boolean noLimit) {
+			super(instr, qualifier);
+			anyChar = noLimit;
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			maxPos = checkRange(pos, maxPos);
+			if (maxPos < 0)
+				return false;
+
+			// Parse to next delimiter or end of string
+			//
+			int start = pos;
+			if (characters != null) {
+				if (anyChar) {
+					// Swallow everything that matches the allowed characters
+					for (; pos < maxPos; ++pos) {
+						if (!isAllowed(version.charAt(pos)))
+							break;
+					}
+				} else {
+					// Swallow letters that matches the allowed characters
+					for (; pos < maxPos; ++pos) {
+						char c = version.charAt(pos);
+						if (!(VersionParser.isLetter(c) && isAllowed(c)))
+							break;
+					}
+				}
+			} else {
+				if (anyChar)
+					// Swallow all characters
+					pos = maxPos;
+				else {
+					// Swallow all letters
+					for (; pos < maxPos; ++pos) {
+						if (!VersionParser.isLetter(version.charAt(pos)))
+							break;
+					}
+				}
+			}
+			int len = pos - start;
+			if (len == 0 || rangeMin > len || len > rangeMax)
+				return false;
+
+			if (!isIgnored())
+				segments.add(version.substring(start, pos));
+			info.setPosition(pos);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append(anyChar ? 'S' : 's');
+			super.toString(sb);
+		}
+	}
+
+	private static class TreeInfo extends ArrayList {
+		private static final long serialVersionUID = 4770093863009659750L;
+
+		private static class StateInfo {
+			Fragment fragment;
+			int segmentCount;
+			int position;
+
+			StateInfo(int position, int segmentCount, Fragment fragment) {
+				this.fragment = fragment;
+				this.position = position;
+				this.segmentCount = segmentCount;
+			}
+		}
+
+		private Comparable padValue;
+		private int top;
+
+		TreeInfo(Fragment frag, int pos) {
+			add(new StateInfo(pos, 0, frag));
+			top = 0;
+		}
+
+		Comparable getPadValue() {
+			return padValue;
+		}
+
+		int getPosition() {
+			return ((StateInfo) get(top)).position;
+		}
+
+		void popState(List segments, Fragment frag) {
+			int idx = top;
+			while (idx > 0) {
+				StateInfo si = (StateInfo) get(idx);
+				if (si.fragment == frag) {
+					int nsegs = segments.size();
+					int segMax = si.segmentCount;
+					while (nsegs > segMax)
+						segments.remove(--nsegs);
+					top = idx - 1;
+					break;
+				}
+			}
+		}
+
+		void pushState(int segCount, Fragment fragment) {
+			int pos = ((StateInfo) get(top)).position;
+			if (++top == size())
+				add(new StateInfo(pos, segCount, fragment));
+			else {
+				StateInfo si = (StateInfo) get(top);
+				si.fragment = fragment;
+				si.position = pos;
+				si.segmentCount = segCount;
+			}
+		}
+
+		void setPadValue(Comparable pad) {
+			padValue = pad;
+		}
+
+		void setPosition(int pos) {
+			((StateInfo) get(top)).position = pos;
+		}
+	}
+
+	/**
+	 * The predefined OSGi format that is used when parsing OSGi
+	 * versions.
+	 */
+	public static final VersionFormat OSGI_FORMAT;
+
+	/**
+	 * The predefined OSGi format that is used when parsing raw
+	 * versions.
+	 */
+	public static final VersionFormat RAW_FORMAT;
+
+	private static final Map formatCache = Collections.synchronizedMap(new HashMap());
+
+	private static final String OSGI_FORMAT_STRING = "n[.n=0;[.n=0;[.S=[A-Za-z0-9_-];]]]"; //$NON-NLS-1$
+
+	private static final String RAW_FORMAT_STRING = "r(.r)*p?"; //$NON-NLS-1$
+
+	static {
+		try {
+			VersionFormatParser parser = new VersionFormatParser();
+			OSGI_FORMAT = new VersionFormat(parser.compile(OSGI_FORMAT_STRING, 0, OSGI_FORMAT_STRING.length()));
+			formatCache.put(OSGI_FORMAT_STRING, OSGI_FORMAT);
+			RAW_FORMAT = new RawFormat(parser.compile(RAW_FORMAT_STRING, 0, RAW_FORMAT_STRING.length()));
+			formatCache.put(RAW_FORMAT_STRING, RAW_FORMAT);
+		} catch (FormatException e) {
+			// If this happens, something is wrong with the actual
+			// implementation of the FormatCompiler.
+			//
+			throw new ExceptionInInitializerError(e);
+		}
+	}
+
+	/**
+	 * Compile a version format string into a compiled format. This method is
+	 * shorthand for:<pre>CompiledFormat.compile(format, 0, format.length())</pre>.
+	 *
+	 * @param format The format to compile.
+	 * @return The compiled format
+	 * @throws FormatException If the format could not be compiled
+	 */
+	public static VersionFormat compile(String format) throws FormatException {
+		return compile(format, 0, format.length());
+	}
+
+	/**
+	 * Compile a version format string into a compiled format. The parsing starts
+	 * at position start and ends at position end. The returned format is cached so
+	 * subsequent calls to this method using the same format string will yield the
+	 * same compiled format instance.
+	 *
+	 * @param format The format string to compile.
+	 * @param start Start position in the format string
+	 * @param end End position in the format string
+	 * @return The compiled format
+	 * @throws FormatException If the format could not be compiled
+	 */
+	public static VersionFormat compile(String format, int start, int end) throws FormatException {
+		String fmtString = format.substring(start, end).intern();
+		synchronized (fmtString) {
+			VersionFormat fmt = (VersionFormat) formatCache.get(fmtString);
+			if (fmt == null) {
+				VersionFormatParser parser = new VersionFormatParser();
+				fmt = new VersionFormat(parser.compile(format, start, end));
+				formatCache.put(fmtString, fmt);
+			}
+			return fmt;
+		}
+	}
+
+	/**
+	 * Parse a version string using the {@link #RAW_FORMAT} parser.
+	 *
+	 * @param version The version to parse.
+	 * @param originalFormat The original format to assign to the created version. Can be <code>null</code>.
+	 * @param original The original version string to assign to the created version. Can be <code>null</code>.
+	 * @return A created version
+	 * @throws IllegalArgumentException If the version string could not be parsed.
+	 */
+	public static Version parseRaw(String version, VersionFormat originalFormat, String original) {
+		Comparable[] padReturn = new Comparable[1];
+		Comparable[] vector = RAW_FORMAT.parse(version, 0, version.length(), padReturn);
+		return new Version(vector, padReturn[0], originalFormat, original);
+	}
+
+	static void appendCharacterRange(StringBuffer sb, char[] range, boolean inverted) {
+		sb.append('=');
+		sb.append('[');
+		if (inverted)
+			sb.append('^');
+		int top = range.length;
+		for (int idx = 0; idx < top; ++idx) {
+			char b = range[idx];
+			if (b == '\\' || b == ']' || (b == '-' && idx + 1 < top))
+				sb.append('\\');
+
+			sb.append(b);
+			int ndx = idx + 1;
+			if (ndx + 2 < top) {
+				char c = b;
+				for (; ndx < top; ++ndx) {
+					char n = range[ndx];
+					if (c + 1 != n)
+						break;
+					c = n;
+				}
+				if (ndx <= idx + 3)
+					continue;
+
+				sb.append('-');
+				if (c == '\\' || c == ']' || (c == '-' && idx + 1 < top))
+					sb.append('\\');
+				sb.append(c);
+				idx = ndx - 1;
+			}
+		}
+		sb.append(']');
+	}
+
+	static Fragment createAutoFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+		return new AutoFragment(instr, qualifier);
+	}
+
+	static Fragment createDelimiterFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+		return new DelimiterFragment(instr, qualifier);
+	}
+
+	static Fragment createGroupFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, Fragment[] fragments, boolean array) {
+		return new GroupFragment(instr, qualifier, fragments, array);
+	}
+
+	static Fragment createLiteralFragment(Qualifier qualifier, String literal) {
+		return new LiteralFragment(qualifier, literal);
+	}
+
+	static Fragment createNumberFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, boolean signed) {
+		return new NumberFragment(instr, qualifier, signed);
+	}
+
+	static Fragment createPadFragment(Qualifier qualifier) {
+		return new PadFragment(qualifier);
+	}
+
+	static Fragment createQuotedFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+		return new QuotedFragment(instr, qualifier);
+	}
+
+	static Fragment createRawFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+		return new RawFragment(instr, qualifier);
+	}
+
+	static Fragment createStringFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, boolean unbound) {
+		return new StringFragment(instr, qualifier, unbound);
+	}
+
+	static void toStringEscaped(StringBuffer sb, String value, String escapes) {
+		for (int idx = 0; idx < value.length(); ++idx) {
+			char c = value.charAt(idx);
+			if (c == '\\' || escapes.indexOf(c) >= 0)
+				sb.append('\\');
+			sb.append(c);
+		}
+	}
+
+	private final Fragment topFragment;
+
+	private String fmtString;
+
+	VersionFormat(Fragment topFragment) {
+		this.topFragment = topFragment;
+	}
+
+	public boolean equals(Object o) {
+		return this == o || o instanceof VersionFormat && toString().equals(o.toString());
+	}
+
+	public int hashCode() {
+		return 11 * toString().hashCode();
+	}
+
+	/**
+	 * Parse the given version string.
+	 * @param version The version string to parse.
+	 * @return A created version.
+	 * @throws IllegalArgumentException If the version string could not be parsed.
+	 */
+	public Version parse(String version) {
+		return parse(version, 0, version.length());
+	}
+
+	/**
+	 * Parse the given version string.
+	 * @param version The version string to parse.
+	 * @param start Start position in the version string
+	 * @param end End position in the version string
+	 * @return A created version.
+	 * @throws IllegalArgumentException If the version string could not be parsed.
+	 */
+	public Version parse(String version, int start, int maxPos) {
+		Comparable[] padReturn = new Comparable[1];
+		Comparable[] vector = parse(version, start, maxPos, padReturn);
+		return new Version(vector, padReturn[0], this, version.substring(start, maxPos));
+	}
+
+	/**
+	 * Returns the string representation of this compiled format
+	 */
+	public synchronized String toString() {
+		if (fmtString == null) {
+			StringBuffer sb = new StringBuffer();
+			toString(sb);
+		}
+		return fmtString;
+	}
+
+	/**
+	 * Appends the string representation of this compiled format to
+	 * the given StringBuffer.
+	 * @param sb The buffer that will receive the string representation
+	 * @param rangeSafe if true, all range sensitive characters will be escaped with backslash.
+	 */
+	public synchronized void toString(StringBuffer sb) {
+		if (fmtString != null)
+			sb.append(fmtString);
+		else {
+			int start = sb.length();
+			sb.append("format"); //$NON-NLS-1$
+			topFragment.toString(sb);
+			fmtString = sb.substring(start);
+		}
+	}
+
+	TreeInfo createInfo(int start) {
+		return new TreeInfo(topFragment, start);
+	}
+
+	Comparable[] parse(String version, int start, int maxPos, Comparable[] padReturn) {
+		ArrayList entries = new ArrayList();
+		if (start == maxPos)
+			throw new IllegalArgumentException(NLS.bind(Messages.format_0_unable_to_parse_empty_version, this, version.substring(start, maxPos)));
+		TreeInfo info = new TreeInfo(topFragment, start);
+		if (!(topFragment.parse(entries, version, maxPos, info) && info.getPosition() == maxPos))
+			throw new IllegalArgumentException(NLS.bind(Messages.format_0_unable_to_parse_1, this, version.substring(start, maxPos)));
+		Comparable pad = info.getPadValue();
+		VersionParser.removeRedundantTrail(entries, pad);
+		padReturn[0] = pad;
+		return (Comparable[]) entries.toArray(new Comparable[entries.size()]);
+	}
+
+	// Preserve cache during deserialization
+	private Object readResolve() {
+		synchronized (formatCache) {
+			String string = toString();
+			VersionFormat fmt = (VersionFormat) formatCache.put(string, this);
+			if (fmt == null)
+				fmt = this;
+			else
+				// Put old format back
+				formatCache.put(string, fmt);
+			return fmt;
+		}
+	}
+}
+
+class RawFormat extends VersionFormat {
+	private static final long serialVersionUID = 8851695938450999819L;
+
+	RawFormat(Fragment topFragment) {
+		super(topFragment);
+	}
+
+	/**
+	 * Parse but do not assign this format as the Version format nor the version
+	 * string as the original.
+	 */
+	public Version parse(String version, int start, int maxPos) {
+		Comparable[] padReturn = new Comparable[1];
+		Comparable[] vector = parse(version, start, maxPos, padReturn);
+		return new Version(vector, padReturn[0], null, null);
+	}
+
+	// Preserve singleton when deserialized
+	private Object readResolve() {
+		return RAW_FORMAT;
+	}
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionFormatParser.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionFormatParser.java
new file mode 100644
index 0000000..4a31345
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionFormatParser.java
@@ -0,0 +1,528 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core;
+
+import java.util.ArrayList;
+import java.util.List;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * This is the Omni Version Format parser. It will parse a version format in string form
+ * into a group of {@link VersionFormat.Fragment} elements. That group, wrapped in a
+ * {@link VersionFormat}, becomes the parser for versions corresponding to the format.
+ *
+ * The class is not intended to included in a public API. Instead VersionFormats should
+ * be created using {@link VersionFormat#parse(String)}
+ *
+ */
+class VersionFormatParser {
+
+	static class Instructions {
+		char[] characters = null;
+		Comparable defaultValue = null;
+		boolean ignore = false;
+		boolean inverted = false;
+		Comparable padValue = null;
+		int rangeMax = Integer.MAX_VALUE;
+		int rangeMin = 0;
+	}
+
+	static final VersionFormat.Qualifier EXACT_ONE_QUALIFIER = new VersionFormat.Qualifier(1, 1);
+
+	static final VersionFormat.Qualifier ONE_OR_MANY_QUALIFIER = new VersionFormat.Qualifier(1, Integer.MAX_VALUE);
+
+	static final VersionFormat.Qualifier ZERO_OR_MANY_QUALIFIER = new VersionFormat.Qualifier(0, Integer.MAX_VALUE);
+
+	static final VersionFormat.Qualifier ZERO_OR_ONE_QUALIFIER = new VersionFormat.Qualifier(0, 1);
+
+	private int current;
+
+	private List currentList;
+
+	private int eos;
+
+	private String format;
+
+	private int start;
+
+	VersionFormat.Fragment compile(String fmt, int pos, int maxPos) throws FormatException {
+		format = fmt;
+		if (start >= maxPos)
+			throw new FormatException(Messages.format_is_empty);
+
+		start = pos;
+		current = pos;
+		eos = maxPos;
+		currentList = new ArrayList();
+		while (current < eos)
+			parseFragment();
+
+		VersionFormat.Fragment topFrag;
+		switch (currentList.size()) {
+			case 0 :
+				throw new FormatException(Messages.format_is_empty);
+			case 1 :
+				VersionFormat.Fragment frag = (VersionFormat.Fragment) currentList.get(0);
+				if (frag.isGroup()) {
+					topFrag = frag;
+					break;
+				}
+				// Fall through to default
+			default :
+				topFrag = VersionFormat.createGroupFragment(null, EXACT_ONE_QUALIFIER, (VersionFormat.Fragment[]) currentList.toArray(new VersionFormat.Fragment[currentList.size()]), false);
+		}
+		currentList = null;
+		return topFrag;
+	}
+
+	private void assertChar(char expected) throws FormatException {
+		if (current >= eos)
+			throw formatException(NLS.bind(Messages.premature_end_of_format_expected_0, new String(new char[] {expected})));
+
+		char c = format.charAt(current);
+		if (c != expected)
+			throw formatException(c, new String(new char[] {expected}));
+		++current;
+	}
+
+	private FormatException formatException(char found, String expected) {
+		return formatException(new String(new char[] {found}), expected);
+	}
+
+	private FormatException formatException(String message) {
+		return new FormatException(NLS.bind(Messages.syntax_error_in_version_format_0_1_2, new Object[] {format.substring(start, eos), new Integer(current), message}));
+	}
+
+	private FormatException formatException(String found, String expected) {
+		return new FormatException(NLS.bind(Messages.syntax_error_in_version_format_0_1_found_2_expected_3, new Object[] {format.substring(start, eos), new Integer(current), found, expected}));
+	}
+
+	private FormatException illegalControlCharacter(char c) {
+		return formatException(NLS.bind(Messages.illegal_character_encountered_ascii_0, Version.valueOf(c)));
+	}
+
+	private String parseAndConsiderEscapeUntil(char endChar) throws FormatException {
+		StringBuffer sb = new StringBuffer();
+		while (current < eos) {
+			char c = format.charAt(current++);
+			if (c == endChar)
+				break;
+
+			if (c < 32)
+				throw illegalControlCharacter(c);
+
+			if (c == '\\') {
+				if (current == eos)
+					throw formatException(Messages.EOS_after_escape);
+				c = format.charAt(current++);
+				if (c < 32)
+					throw illegalControlCharacter(c);
+			}
+			sb.append(c);
+		}
+		return sb.toString();
+	}
+
+	private void parseAuto() throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.padValue != null)
+				throw formatException(Messages.auto_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createAutoFragment(ep, parseQualifier()));
+	}
+
+	private void parseBracketGroup() throws FormatException {
+		List saveList = currentList;
+		currentList = new ArrayList();
+		while (current < eos && format.charAt(current) != ']')
+			parseFragment();
+
+		if (current == eos)
+			throw formatException(NLS.bind(Messages.premature_end_of_format_expected_0, "]")); //$NON-NLS-1$
+
+		++current;
+		VersionFormatParser.Instructions ep = parseProcessing();
+		saveList.add(VersionFormat.createGroupFragment(ep, ZERO_OR_ONE_QUALIFIER, (VersionFormat.Fragment[]) currentList.toArray(new VersionFormat.Fragment[currentList.size()]), false));
+		currentList = saveList;
+	}
+
+	private void parseCharacterGroup(VersionFormatParser.Instructions ep) throws FormatException {
+		assertChar('[');
+
+		StringBuffer sb = new StringBuffer();
+		outer: for (; current < eos; ++current) {
+			char c = format.charAt(current);
+			switch (c) {
+				case '\\' :
+					if (current + 1 < eos) {
+						sb.append(format.charAt(++current));
+						continue;
+					}
+					throw formatException(Messages.premature_end_of_format);
+				case '^' :
+					if (sb.length() == 0)
+						ep.inverted = true;
+					else
+						sb.append(c);
+					continue;
+				case ']' :
+					break outer;
+				case '-' :
+					if (sb.length() > 0 && current + 1 < eos) {
+						char rangeEnd = format.charAt(++current);
+						if (rangeEnd == ']') {
+							// Use dash verbatim when last in range
+							sb.append(c);
+							break outer;
+						}
+
+						char rangeStart = sb.charAt(sb.length() - 1);
+						if (rangeEnd < rangeStart)
+							throw formatException(Messages.negative_character_range);
+						while (++rangeStart <= rangeEnd)
+							sb.append(rangeStart);
+						continue;
+					}
+					// Fall through to default
+				default :
+					if (c < 32)
+						throw illegalControlCharacter(c);
+					sb.append(c);
+			}
+		}
+		assertChar(']');
+		int top = sb.length();
+		char[] chars = new char[top];
+		sb.getChars(0, top, chars, 0);
+		ep.characters = chars;
+	}
+
+	private void parseDelimiter() throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.rangeMin != 0 || ep.rangeMax != Integer.MAX_VALUE)
+				throw formatException(Messages.delimiter_can_not_have_range);
+			if (ep.ignore)
+				throw formatException(Messages.delimiter_can_not_be_ignored);
+			if (ep.defaultValue != null)
+				throw formatException(Messages.delimiter_can_not_have_default_value);
+			if (ep.padValue != null)
+				throw formatException(Messages.delimiter_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createDelimiterFragment(ep, parseQualifier()));
+	}
+
+	private void parseFragment() throws FormatException {
+		if (current == eos)
+			throw formatException(Messages.premature_end_of_format);
+		char c = format.charAt(current++);
+		switch (c) {
+			case '(' :
+				parseGroup(false);
+				break;
+			case '<' :
+				parseGroup(true);
+				break;
+			case '[' :
+				parseBracketGroup();
+				break;
+			case 'a' :
+				parseAuto();
+				break;
+			case 'r' :
+				parseRaw();
+				break;
+			case 'n' :
+				parseNumber(false);
+				break;
+			case 'N' :
+				parseNumber(true);
+				break;
+			case 's' :
+				parseString(false);
+				break;
+			case 'S' :
+				parseString(true);
+				break;
+			case 'd' :
+				parseDelimiter();
+				break;
+			case 'q' :
+				parseQuotedString();
+				break;
+			case 'p' :
+				parsePad();
+				break;
+			default :
+				parseLiteral(c);
+		}
+	}
+
+	private void parseGroup(boolean array) throws FormatException {
+		List saveList = currentList;
+		currentList = new ArrayList();
+		char expectedEnd = array ? '>' : ')';
+		while (current < eos && format.charAt(current) != expectedEnd)
+			parseFragment();
+		assertChar(expectedEnd);
+
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.characters != null)
+				throw formatException(Messages.array_can_not_have_character_group);
+			if (ep.rangeMax != Integer.MAX_VALUE && ep.padValue != null) {
+				throw formatException(Messages.cannot_combine_range_upper_bound_with_pad_value);
+			}
+		}
+
+		if (currentList.isEmpty())
+			throw formatException(array ? Messages.array_can_not_be_empty : Messages.group_can_not_be_empty);
+		saveList.add(VersionFormat.createGroupFragment(ep, parseQualifier(), (VersionFormat.Fragment[]) currentList.toArray(new VersionFormat.Fragment[currentList.size()]), array));
+		currentList = saveList;
+	}
+
+	private int parseIntegerLiteral() throws FormatException {
+		if (current == eos)
+			throw formatException(NLS.bind(Messages.premature_end_of_format_expected_0, "<integer>")); //$NON-NLS-1$
+
+		char c = format.charAt(current);
+		if (!VersionParser.isDigit(c))
+			throw formatException(c, "<integer>"); //$NON-NLS-1$
+
+		int value = c - '0';
+		while (++current < eos) {
+			c = format.charAt(current);
+			if (!VersionParser.isDigit(c))
+				break;
+			value *= 10;
+			value += (c - '0');
+		}
+		return value;
+	}
+
+	private void parseLiteral(char c) throws FormatException {
+		String value;
+		switch (c) {
+			case '\'' :
+				value = parseAndConsiderEscapeUntil(c);
+				break;
+			case ')' :
+			case ']' :
+			case '{' :
+			case '}' :
+			case '?' :
+			case '*' :
+				throw formatException(c, "<literal>"); //$NON-NLS-1$
+			default :
+				if (VersionParser.isLetterOrDigit(c))
+					throw formatException(c, "<literal>"); //$NON-NLS-1$
+
+				if (c < 32)
+					throw illegalControlCharacter(c);
+
+				if (c == '\\') {
+					if (current == eos)
+						throw formatException(Messages.EOS_after_escape);
+					c = format.charAt(current++);
+					if (c < 32)
+						throw illegalControlCharacter(c);
+				}
+				value = new String(new char[] {c});
+		}
+		currentList.add(VersionFormat.createLiteralFragment(parseQualifier(), value));
+	}
+
+	private int[] parseMinMax() throws FormatException {
+
+		int max = Integer.MAX_VALUE;
+		++current;
+		int min = parseIntegerLiteral();
+		char c = format.charAt(current);
+		if (c == '}') {
+			max = min;
+			if (max == 0)
+				throw formatException(Messages.range_max_cannot_be_zero);
+			++current;
+		} else if (c == ',' && current + 1 < eos) {
+			if (format.charAt(++current) != '}') {
+				max = parseIntegerLiteral();
+				if (max == 0)
+					throw formatException(Messages.range_max_cannot_be_zero);
+				if (max < min)
+					throw formatException(Messages.range_max_cannot_be_less_then_range_min);
+			}
+			assertChar('}');
+		} else
+			throw formatException(c, "},"); //$NON-NLS-1$
+		return new int[] {min, max};
+	}
+
+	private void parseNumber(boolean signed) throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.padValue != null)
+				throw formatException(Messages.number_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createNumberFragment(ep, parseQualifier(), signed));
+	}
+
+	private void parsePad() throws FormatException {
+		currentList.add(VersionFormat.createPadFragment(parseQualifier()));
+	}
+
+	private VersionFormatParser.Instructions parseProcessing() throws FormatException {
+		if (current >= eos)
+			return null;
+
+		char c = format.charAt(current);
+		if (c != '=')
+			return null;
+
+		VersionFormatParser.Instructions ep = new VersionFormatParser.Instructions();
+		do {
+			current++;
+			parseProcessingInstruction(ep);
+		} while (current < eos && format.charAt(current) == '=');
+		return ep;
+	}
+
+	private void parseProcessingInstruction(VersionFormatParser.Instructions processing) throws FormatException {
+		if (current == eos)
+			throw formatException(Messages.premature_end_of_format);
+
+		char c = format.charAt(current);
+		if (c == 'p') {
+			// =pad(<raw-element>);
+			//
+			if (processing.padValue != null)
+				throw formatException(Messages.pad_defined_more_then_once);
+			if (processing.ignore)
+				throw formatException(Messages.cannot_combine_ignore_with_other_instruction);
+			++current;
+			processing.padValue = parseRawElement();
+		} else if (c == '!') {
+			// =ignore;
+			//
+			if (processing.ignore)
+				throw formatException(Messages.ignore_defined_more_then_once);
+			if (processing.padValue != null || processing.characters != null || processing.rangeMin != 0 || processing.rangeMax != Integer.MAX_VALUE || processing.defaultValue != null)
+				throw formatException(Messages.cannot_combine_ignore_with_other_instruction);
+			++current;
+			processing.ignore = true;
+		} else if (c == '[') {
+			// =[<character group];
+			//
+			if (processing.characters != null)
+				throw formatException(Messages.character_group_defined_more_then_once);
+			if (processing.ignore)
+				throw formatException(Messages.cannot_combine_ignore_with_other_instruction);
+			parseCharacterGroup(processing);
+		} else if (c == '{') {
+			// ={min,max};
+			//
+			if (processing.rangeMin != 0 || processing.rangeMax != Integer.MAX_VALUE)
+				throw formatException(Messages.range_defined_more_then_once);
+			if (processing.ignore)
+				throw formatException(Messages.cannot_combine_ignore_with_other_instruction);
+			int[] minMax = parseMinMax();
+			processing.rangeMin = minMax[0];
+			processing.rangeMax = minMax[1];
+		} else {
+			// =<raw-element>;
+			if (processing.defaultValue != null)
+				throw formatException(Messages.default_defined_more_then_once);
+			if (processing.ignore)
+				throw formatException(Messages.cannot_combine_ignore_with_other_instruction);
+			processing.defaultValue = parseRawElement();
+		}
+		assertChar(';');
+	}
+
+	private VersionFormat.Qualifier parseQualifier() throws FormatException {
+		if (current >= eos)
+			return EXACT_ONE_QUALIFIER;
+
+		char c = format.charAt(current);
+		if (c == '?') {
+			++current;
+			return ZERO_OR_ONE_QUALIFIER;
+		}
+
+		if (c == '*') {
+			++current;
+			return ZERO_OR_MANY_QUALIFIER;
+		}
+
+		if (c == '+') {
+			++current;
+			return ONE_OR_MANY_QUALIFIER;
+		}
+
+		if (c != '{')
+			return EXACT_ONE_QUALIFIER;
+
+		int[] minMax = parseMinMax();
+		int min = minMax[0];
+		int max = minMax[1];
+
+		// Use singletons for commonly used ranges
+		//
+		if (min == 0) {
+			if (max == 1)
+				return ZERO_OR_ONE_QUALIFIER;
+			if (max == Integer.MAX_VALUE)
+				return ZERO_OR_MANY_QUALIFIER;
+		} else if (min == 1) {
+			if (max == 1)
+				return EXACT_ONE_QUALIFIER;
+			if (max == Integer.MAX_VALUE)
+				return ONE_OR_MANY_QUALIFIER;
+		}
+		return new VersionFormat.Qualifier(min, max);
+	}
+
+	private void parseQuotedString() throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.padValue != null)
+				throw formatException(Messages.string_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createQuotedFragment(ep, parseQualifier()));
+	}
+
+	private void parseRaw() throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.padValue != null)
+				throw formatException(Messages.raw_element_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createRawFragment(ep, parseQualifier()));
+	}
+
+	private Comparable parseRawElement() throws FormatException {
+		int[] position = new int[] {current};
+		Comparable v = VersionParser.parseRawElement(format, position, eos);
+		if (v == null)
+			throw new FormatException(NLS.bind(Messages.raw_element_expected_0, format));
+		current = position[0];
+		return v;
+	}
+
+	private void parseString(boolean unlimited) throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.padValue != null)
+				throw formatException(Messages.string_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createStringFragment(ep, parseQualifier(), unlimited));
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionParser.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionParser.java
new file mode 100644
index 0000000..98560bf
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionParser.java
@@ -0,0 +1,364 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core;
+
+import java.util.ArrayList;
+import java.util.List;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * The Omni Version parser. Not intended for public API. Instead use
+ * {@link Version#Version(String)} or {@link Version#parseVersion(String)}.
+ *
+ * The class also contains some general purpose parser support methods
+ *
+ * @noextend This class is not intended to be subclassed by clients.
+ */
+abstract class VersionParser {
+	static void removeRedundantTrail(List segments, Comparable padValue) {
+		Comparable redundantTrail = padValue == null ? VersionVector.MIN_VALUE : padValue;
+		int idx = segments.size();
+		while (--idx >= 0 && segments.get(idx).equals(redundantTrail))
+			segments.remove(idx);
+	}
+
+	static final String RAW_PREFIX = "raw:"; //$NON-NLS-1$
+
+	private VersionParser() {
+		// Prevent class from being instantiated
+	}
+
+	/**
+	 * Parse the <code>version</code> string and assing the parsed portions to the <code>receiver</code>.
+	 * This method is called from the version string constructor.
+	 *
+	 * @param version The string to be parsed
+	 * @param start Start position in the <code>version</code> string
+	 * @param maxPos End position in the <code>version</code> string
+	 * @param receiver The version to be filled in
+	 * @returns <code>true</code> if a version indeed was parsed or <code>false</code> if the string
+	 * contained only whitespace.
+	 * @throws IllegalArgumentException if the version is malformed
+	 */
+	static boolean parseInto(String version, int start, int maxPos, Version receiver) throws IllegalArgumentException {
+		// trim leading and trailing whitespace
+		int pos = skipWhite(version, start);
+		maxPos = skipTrailingWhite(version, start, maxPos);
+		if (pos == maxPos)
+			return false;
+
+		Comparable[] padReturn = new Comparable[1];
+		Comparable[] vector = null;
+		Comparable pad = null;
+		VersionFormat fmt = null;
+		char c = version.charAt(pos);
+		if (isDigit(c)) {
+			fmt = VersionFormat.OSGI_FORMAT;
+			vector = fmt.parse(version, pos, maxPos, padReturn);
+			receiver.init(vector, padReturn[0], fmt, version);
+			return true;
+		}
+
+		if (!isLetter(c))
+			throw new IllegalArgumentException();
+
+		if (version.startsWith(RAW_PREFIX, pos)) {
+			VersionFormat rawFmt = VersionFormat.RAW_FORMAT;
+			pos += 4;
+
+			// Find ending '/' that is neither quoted or escaped
+			int end = maxPos;
+			for (int idx = pos; idx < maxPos; ++idx) {
+				c = version.charAt(idx);
+				switch (c) {
+					case '/' :
+						end = idx;
+						break;
+					case '\\' :
+						++idx;
+						continue;
+					case '\'' :
+					case '"' :
+						for (++idx; idx < maxPos; ++idx) {
+							char e = version.charAt(idx);
+							if (e == c) {
+								break;
+							}
+							if (e == '\\')
+								++idx;
+						}
+						// fall through to default
+					default :
+						continue;
+				}
+				break;
+			}
+
+			vector = rawFmt.parse(version, pos, end, padReturn);
+			pad = padReturn[0];
+			pos = end;
+			if (pos == maxPos) {
+				// This was a pure raw version
+				//
+				receiver.init(vector, pad, null, null);
+				return true;
+			}
+
+			if (version.charAt(pos) != '/')
+				throw new IllegalArgumentException(NLS.bind(Messages.expected_slash_after_raw_vector_0, version.substring(start, maxPos)));
+			++pos;
+
+			if (pos == maxPos)
+				throw new IllegalArgumentException(NLS.bind(Messages.expected_orignal_after_slash_0, version.substring(start, maxPos)));
+		}
+
+		if (version.startsWith("format(", pos)) { //$NON-NLS-1$
+			// Parse the format
+			//
+			pos += 7;
+			try {
+				// Find matching ')' that is neither quoted or escaped
+				//
+				int end = findEndOfFormat(version, pos, maxPos);
+				fmt = VersionFormat.compile(version, pos, end);
+				pos = end + 1;
+			} catch (FormatException e) {
+				throw new IllegalArgumentException(e.getMessage());
+			}
+			if (pos == maxPos) {
+				// This was a raw version with format but no original
+				//
+				if (vector == null)
+					throw new IllegalArgumentException(NLS.bind(Messages.only_format_specified_0, version.substring(start, maxPos)));
+				receiver.init(vector, pad, fmt, null);
+				return true;
+			}
+		}
+
+		if (fmt == null && vector == null)
+			throw new IllegalArgumentException(NLS.bind(Messages.neither_raw_vector_nor_format_specified_0, version.substring(start, maxPos)));
+
+		if (version.charAt(pos) != ':')
+			throw new IllegalArgumentException(NLS.bind(Messages.colon_expected_before_original_version_0, version.substring(start, maxPos)));
+
+		pos++;
+		if (pos == maxPos)
+			throw new IllegalArgumentException(NLS.bind(Messages.expected_orignal_after_colon_0, version.substring(start, maxPos)));
+
+		if (vector == null) {
+			// Vector and pad must be created by parsing the original
+			//
+			vector = fmt.parse(version, pos, maxPos, padReturn);
+			pad = padReturn[0];
+		}
+		receiver.init(vector, pad, fmt, version.substring(pos));
+		return true;
+	}
+
+	static boolean isDigit(char c) {
+		return c >= '0' && c <= '9';
+	}
+
+	static boolean isLetter(char c) {
+		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
+	}
+
+	static boolean isLetterOrDigit(char c) {
+		return isDigit(c) || isLetter(c);
+	}
+
+	static int findEndOfFormat(String string, int pos, int maxPos) {
+		int end = -1;
+		int depth = 1;
+		for (int idx = pos; idx < maxPos; ++idx) {
+			char c = string.charAt(idx);
+			switch (c) {
+				case ')' :
+					if (--depth == 0) {
+						end = idx;
+						break;
+					}
+					continue;
+				case '(' :
+					++depth;
+					continue;
+				case '\\' :
+					++idx;
+					continue;
+				case '\'' :
+				case '"' :
+					for (++idx; idx < maxPos; ++idx) {
+						char e = string.charAt(idx);
+						if (e == c) {
+							break;
+						}
+						if (e == '\\')
+							++idx;
+					}
+					// fall through to default
+				default :
+					continue;
+			}
+			break;
+		}
+		if (depth != 0)
+			throw new IllegalArgumentException(NLS.bind(Messages.unbalanced_format_parenthesis, string.substring(pos - 1, maxPos)));
+		return end;
+	}
+
+	static Comparable parseRawElement(String value, int[] position, int maxPos) {
+		int current = position[0];
+		if (current >= maxPos)
+			return null;
+
+		boolean negate = false;
+		char c = value.charAt(current);
+		Comparable v;
+		switch (c) {
+			case '\'' :
+			case '"' : {
+				StringBuffer sb = new StringBuffer();
+				for (;;) {
+					char q = c;
+					if (++current == maxPos)
+						return null;
+					c = value.charAt(current);
+					while (c != q) {
+						if (c < 32)
+							return null;
+						sb.append(c);
+						if (++current == maxPos)
+							return null;
+						c = value.charAt(current);
+					}
+					if (++current == maxPos)
+						break;
+					c = value.charAt(current);
+					if (c != '\'' && c != '"')
+						break;
+				}
+				v = sb.toString();
+				break;
+			}
+			case '<' : {
+				if (++current == maxPos)
+					return null;
+
+				position[0] = current;
+				v = parseRawVector(value, position, maxPos);
+				if (v == null)
+					return null;
+				current = position[0];
+				break;
+			}
+			case 'm' :
+				v = VersionVector.MAXS_VALUE;
+				++current;
+				break;
+			case 'M' :
+				v = VersionVector.MAX_VALUE;
+				++current;
+				break;
+			case '-' :
+				if (++current >= maxPos)
+					return null;
+
+				c = value.charAt(current);
+				if (c == 'M') {
+					++current;
+					v = VersionVector.MIN_VALUE;
+					break;
+				}
+				negate = true;
+				// Fall through to default
+			default : {
+				if (isDigit(c)) {
+					int start = current++;
+					while (current < maxPos && isDigit(value.charAt(current)))
+						++current;
+					int val = Integer.parseInt(value.substring(start, current));
+					if (negate)
+						val = -val;
+					v = Version.valueOf(val);
+					break;
+				}
+				return null;
+			}
+		}
+		position[0] = current;
+		return v;
+	}
+
+	private static Comparable parseRawVector(String value, int[] position, int maxPos) {
+		int pos = position[0];
+		if (pos >= maxPos)
+			return null;
+
+		char c = value.charAt(pos);
+		if (c == '>')
+			return null;
+
+		ArrayList rawList = new ArrayList();
+		boolean padMarkerSeen = (c == 'p');
+		if (padMarkerSeen) {
+			if (++pos >= maxPos)
+				return null;
+			position[0] = pos;
+		}
+
+		Comparable pad = null;
+		for (;;) {
+			Comparable elem = parseRawElement(value, position, maxPos);
+			if (elem == null)
+				return null;
+
+			if (padMarkerSeen)
+				pad = elem;
+			else
+				rawList.add(elem);
+
+			pos = position[0];
+			if (pos >= maxPos)
+				return null;
+
+			c = value.charAt(pos);
+			position[0] = ++pos;
+			if (c == '>')
+				break;
+
+			if (padMarkerSeen || pos >= maxPos)
+				return null;
+
+			if (c == 'p') {
+				padMarkerSeen = true;
+				continue;
+			}
+
+			if (c != '.')
+				return null;
+		}
+		removeRedundantTrail(rawList, pad);
+		return new VersionVector((Comparable[]) rawList.toArray(new Comparable[rawList.size()]), pad);
+	}
+
+	static int skipWhite(String string, int pos) {
+		int top = string.length();
+		while (pos < top && string.charAt(pos) <= ' ')
+			++pos;
+		return pos;
+	}
+
+	static int skipTrailingWhite(String string, int start, int end) {
+		while (end > start && string.charAt(end - 1) <= ' ')
+			--end;
+		return end;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionRange.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionRange.java
index 769ec07..a8bb10e 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionRange.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionRange.java
@@ -1 +1 @@
-/******************************************************************************* * Copyright (c) 2003, 2008 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *  * Contributors: *     IBM Corporation - initial API and implementation *******************************************************************************/package org.eclipse.equinox.internal.provisional.p2.core;/** * This class represents a version range. * @since 3.1 * @noextend This class is not intended to be subclassed by clients. */public class VersionRange {	private static final Version versionMax = new Version(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);	/**	 * An empty version	 */	public static final VersionRange emptyRange = new VersionRange(null);	private final Version minVersion;	private final boolean includeMin;	private final Version maxVersion;	private final boolean includeMax;	/**	 * Constructs a VersionRange with the specified minVersion and maxVersion.	 * @param minVersion the minimum version of the range	 * @param maxVersion the maximum version of the range	 */	public VersionRange(Version minVersion, boolean includeMin, Version maxVersion, boolean includeMax) {		this.minVersion = minVersion;		this.includeMin = includeMin;		this.maxVersion = maxVersion;		this.includeMax = includeMax;	}	/**	 * Constructs a VersionRange from the given versionRange String.	 * @param versionRange a version range String that specifies a range of	 * versions.	 */	public VersionRange(String versionRange) {		if (versionRange == null || versionRange.length() == 0) {			minVersion = Version.emptyVersion;			includeMin = true;			maxVersion = VersionRange.versionMax;			includeMax = true;			return;		}		versionRange = versionRange.trim();		if (versionRange.charAt(0) == '[' || versionRange.charAt(0) == '(') {			int comma = versionRange.indexOf(',');			if (comma < 0)				throw new IllegalArgumentException();			char last = versionRange.charAt(versionRange.length() - 1);			if (last != ']' && last != ')')				throw new IllegalArgumentException();			minVersion = Version.parseVersion(versionRange.substring(1, comma).trim());			includeMin = versionRange.charAt(0) == '[';			maxVersion = Version.parseVersion(versionRange.substring(comma + 1, versionRange.length() - 1).trim());			includeMax = last == ']';		} else {			minVersion = Version.parseVersion(versionRange.trim());			includeMin = true;			maxVersion = VersionRange.versionMax;			includeMax = true;		}	}	/**	 * Returns the minimum Version of this VersionRange	 * @return the minimum Version of this VersionRange	 */	public Version getMinimum() {		return minVersion;	}	/**	 * Indicates if the minimum version is included in the version range.	 * @return true if the minimum version is included in the version range;	 * otherwise false is returned	 */	public boolean getIncludeMinimum() {		return includeMin;	}	/**	 * Returns the maximum Version of this VersionRange	 * @return the maximum Version of this VersionRange	 */	public Version getMaximum() {		return maxVersion;	}	/**	 * Indicates if the maximum version is included in the version range.	 * @return true if the maximum version is included in the version range;	 * otherwise false is returned	 */	public boolean getIncludeMaximum() {		return includeMax;	}	/**	 * Returns whether the given version is included in this VersionRange.	 * This will depend on the minimum and maximum versions of this VersionRange	 * and the given version.	 * 	 * @param version a version to be tested for inclusion in this VersionRange. 	 * (may be <code>null</code>)	 * @return <code>true</code> if the version is include, 	 * <code>false</code> otherwise 	 */	public boolean isIncluded(Version version) {		Version minRequired = getMinimum();		if (minRequired == null)			return true;		if (version == null)			return false;		Version maxRequired = getMaximum() == null ? VersionRange.versionMax : getMaximum();		int minCheck = includeMin ? 0 : 1;		int maxCheck = includeMax ? 0 : -1;		return version.compareTo(minRequired) >= minCheck && version.compareTo(maxRequired) <= maxCheck;	}	public boolean equals(Object object) {		if (!(object instanceof VersionRange))			return false;		VersionRange vr = (VersionRange) object;		if (minVersion != null && vr.getMinimum() != null) {			if (minVersion.equals(vr.getMinimum()) && includeMin == vr.includeMin)				if (maxVersion != null && vr.getMaximum() != null) {					if (maxVersion.equals(vr.getMaximum()) && includeMax == vr.includeMax)						return true;				} else					return maxVersion == vr.getMaximum();		} else {			return minVersion == vr.getMinimum();		}		return false;	}	public int hashCode() {		final int prime = 31;		int result = 1;		result = prime * result + (maxVersion != null ? maxVersion.hashCode() : VersionRange.versionMax.hashCode());		result = prime * result + (minVersion != null ? minVersion.hashCode() : Version.emptyVersion.hashCode());		result = prime * result + (includeMax ? 1231 : 1237);		result = prime * result + (includeMin ? 1231 : 1237);		return result;	}	public String toString() {		if (minVersion == null)			return Version.emptyVersion.toString();		if (VersionRange.versionMax.equals(maxVersion))			return minVersion.toString();		StringBuffer result = new StringBuffer();		result.append(includeMin ? '[' : '(');		result.append(minVersion);		result.append(',');		result.append(maxVersion);		result.append(includeMax ? ']' : ')');		return result.toString();	}	public static org.eclipse.osgi.service.resolver.VersionRange toOSGiVersionRange(VersionRange range) {		if (range.equals(emptyRange))			return org.eclipse.osgi.service.resolver.VersionRange.emptyRange;		return new org.eclipse.osgi.service.resolver.VersionRange(Version.toOSGiVersion(range.getMinimum()), range.getIncludeMinimum(), Version.toOSGiVersion(range.getMaximum()), range.getIncludeMinimum());	}	public static VersionRange fromOSGiVersionRange(org.eclipse.osgi.service.resolver.VersionRange range) {		if (range.equals(org.eclipse.osgi.service.resolver.VersionRange.emptyRange))			return emptyRange;		return new VersionRange(Version.fromOSGiVersion(range.getMinimum()), range.getIncludeMinimum(), Version.fromOSGiVersion(range.getMaximum()), range.getIncludeMinimum());	}}
\ No newline at end of file
+/******************************************************************************* * Copyright (c) 2003, 2009 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *  * Contributors: *     IBM Corporation - initial API and implementation *     Cloudsmith Inc - rewrite to handle non-OSGi versions. *******************************************************************************/package org.eclipse.equinox.internal.provisional.p2.core;import java.io.Serializable;import org.eclipse.osgi.util.NLS;/** * This class represents a version range with Omni Version bounds. It is signature * equivalent with the OSGi {@link org.eclipse.osgi.service.resolver.VersionRange VersionRange} * * @Immutable * @noextend This class is not intended to be subclassed by clients. */public class VersionRange implements Serializable {	private static final long serialVersionUID = 4988030307298088028L;	static final Version OSGi_versionMin = new Version(0, 0, 0);	static final Version OSGi_versionMax = new Version(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);	/**	 * TODO: This should not be OSGi but it has to be that for now since the resolver creates	 * a filter where the min and max are converted into strings. When the filter is evaluated an	 * attempt is made to recreate them as OSGi versions.	 *	 * An empty OSGi Version range.	 */	public static final VersionRange emptyRange = new VersionRange(OSGi_versionMin, true, OSGi_versionMax, true);	private final Version minVersion;	private final boolean includeMin;	private final Version maxVersion;	private final boolean includeMax;	private static int copyEscaped(String vr, int pos, String breakChars, StringBuffer sb) {		int top = vr.length();		pos = VersionParser.skipWhite(vr, pos);		if (pos >= top)			throw new IllegalArgumentException();		char c = vr.charAt(pos);		for (;;) {			if (c == '\\' && ++pos < top)				c = vr.charAt(pos);			else {				if (c <= ' ')					return VersionParser.skipWhite(vr, pos);				if (breakChars != null && breakChars.indexOf(c) >= 0)					break;			}			sb.append(c);			if (++pos >= top)				break;			c = vr.charAt(pos);		}		return pos;	}	/**	 * Constructs a VersionRange with the specified minVersion and maxVersion.	 * @param minVersion the minimum version of the range	 * @param maxVersion the maximum version of the range	 */	public VersionRange(Version minVersion, boolean includeMin, Version maxVersion, boolean includeMax) {		if (minVersion == null) {			if (maxVersion == null) {				minVersion = Version.MIN_VERSION;				maxVersion = Version.MAX_VERSION;			} else				minVersion = maxVersion.getFormat() == VersionFormat.OSGI_FORMAT ? OSGi_versionMin : Version.MIN_VERSION;		} else {			if (maxVersion == null)				maxVersion = minVersion.getFormat() == VersionFormat.OSGI_FORMAT ? OSGi_versionMax : Version.MAX_VERSION;			else {				if (minVersion != maxVersion && minVersion.equals(maxVersion))					maxVersion = minVersion;				else if (!minVersion.getFormat().equals(maxVersion.getFormat()))					throw new IllegalArgumentException(NLS.bind(Messages.range_boundaries_0_and_1_cannot_have_different_formats, minVersion, maxVersion));			}		}		this.minVersion = minVersion;		this.includeMin = includeMin;		this.maxVersion = maxVersion;		this.includeMax = includeMax;		validateRange();	}	/**	 * Constructs a VersionRange from the given versionRange String.	 * @param versionRange a version range String that specifies a range of	 * versions.	 */	public VersionRange(String versionRange) {		int top = 0;		int pos = 0;		if (versionRange != null) {			top = versionRange.length();			pos = VersionParser.skipWhite(versionRange, 0);			top = VersionParser.skipTrailingWhite(versionRange, pos, top);		}		if (pos >= top) {			minVersion = Version.MIN_VERSION;			includeMin = true;			maxVersion = Version.MAX_VERSION;			includeMax = true;			return;		}		char c = versionRange.charAt(pos);		int[] position = new int[1];		boolean rawPrefix = false;		VersionFormat fmt = null;		if (VersionParser.isLetter(c)) {			if (versionRange.startsWith("raw:", pos)) { //$NON-NLS-1$				rawPrefix = true;				pos += 4;			} else {				position[0] = pos;				fmt = parseFormat(versionRange, position);				pos = position[0];				if (pos >= versionRange.length())					throw new IllegalArgumentException(NLS.bind(Messages.format_must_be_delimited_by_colon_0, versionRange));				c = versionRange.charAt(pos);				if (c != ':')					throw new IllegalArgumentException(NLS.bind(Messages.format_must_be_delimited_by_colon_0, versionRange));				++pos;			}			pos = VersionParser.skipWhite(versionRange, pos);			if (pos >= top)				throw new IllegalArgumentException(NLS.bind(Messages.premature_EOS_0, versionRange));			c = versionRange.charAt(pos);		} else			fmt = VersionFormat.OSGI_FORMAT;		String minStr;		String maxStr;		StringBuffer sb = new StringBuffer();		if (c == '[' || c == '(') {			includeMin = (c == '[');			pos = copyEscaped(versionRange, ++pos, ",)]", sb); //$NON-NLS-1$			if (pos >= top)				throw new IllegalArgumentException(NLS.bind(Messages.premature_EOS_0, versionRange));			c = versionRange.charAt(pos++);			if (c != ',')				throw new IllegalArgumentException(NLS.bind(Messages.missing_comma_in_range_0, versionRange));			minStr = sb.toString();			sb.setLength(0);			pos = copyEscaped(versionRange, pos, ")]", sb); //$NON-NLS-1$			if (pos >= top)				throw new IllegalArgumentException();			maxStr = sb.toString();			c = versionRange.charAt(pos++);			includeMax = (c == ']');		} else {			StringBuffer sbMin = new StringBuffer();			pos = copyEscaped(versionRange, pos, null, sbMin);			includeMin = includeMax = true;			minStr = sbMin.toString();			maxStr = null;		}		if (rawPrefix) {			String origMin = null;			String origMax = null;			pos = VersionParser.skipWhite(versionRange, pos);			if (pos < top && versionRange.charAt(pos) == '/') {				if (++pos == top)					throw new IllegalArgumentException(NLS.bind(Messages.original_stated_but_missing_0, versionRange));				position[0] = pos;				fmt = parseFormat(versionRange, position);				pos = VersionParser.skipWhite(versionRange, position[0]);				if (pos < top) {					boolean origUseIncDelims = false;					c = versionRange.charAt(pos);					if (c != ':')						throw new IllegalArgumentException(NLS.bind(Messages.original_must_start_with_colon_0, versionRange));					pos = VersionParser.skipWhite(versionRange, ++pos);					if (pos == top)						throw new IllegalArgumentException(NLS.bind(Messages.original_stated_but_missing_0, versionRange));					c = versionRange.charAt(pos);					if (c == '[' || c == '(') {						if (includeMin != (c == '[') || maxStr == null)							throw new IllegalArgumentException(NLS.bind(Messages.raw_and_original_must_use_same_range_inclusion_0, versionRange));						pos = VersionParser.skipWhite(versionRange, ++pos);						origUseIncDelims = true;					}					sb.setLength(0);					if (maxStr == null) {						copyEscaped(versionRange, pos, ",])", sb); //$NON-NLS-1$						origMin = sb.toString();					} else {						pos = copyEscaped(versionRange, pos, ",])", sb); //$NON-NLS-1$						if (pos >= top)							throw new IllegalArgumentException(NLS.bind(Messages.premature_EOS_0, versionRange));						c = versionRange.charAt(pos++);						if (c != ',')							throw new IllegalArgumentException(NLS.bind(Messages.missing_comma_in_range_0, versionRange));						origMin = sb.toString();						sb.setLength(0);						pos = copyEscaped(versionRange, pos, "])", sb); //$NON-NLS-1$						if (origUseIncDelims) {							if (pos >= top)								throw new IllegalArgumentException(NLS.bind(Messages.premature_EOS_0, versionRange));							c = versionRange.charAt(pos++);							if (includeMax != (c == ']'))								throw new IllegalArgumentException(NLS.bind(Messages.raw_and_original_must_use_same_range_inclusion_0, versionRange));						}						origMax = sb.toString();					}				}			}			minVersion = VersionFormat.parseRaw(minStr, fmt, origMin);			if (maxStr != null) {				if (maxStr.equals(minStr))					maxVersion = minVersion;				else					maxVersion = VersionFormat.parseRaw(maxStr, fmt, origMax);			} else				maxVersion = Version.MAX_VERSION;		} else {			if (fmt == null)				fmt = VersionFormat.OSGI_FORMAT;			minVersion = fmt.parse(minStr);			if (maxStr != null) {				if (maxStr.equals(minStr))					maxVersion = minVersion;				else					maxVersion = fmt.parse(maxStr);			} else {				maxVersion = (fmt == VersionFormat.OSGI_FORMAT) ? OSGi_versionMax : Version.MAX_VERSION;			}		}		validateRange();	}	private static VersionFormat parseFormat(String versionRange, int[] position) {		int pos = VersionParser.skipWhite(versionRange, position[0]);		if (!versionRange.startsWith("format(", pos)) //$NON-NLS-1$			return null;		pos += 7;		int end = VersionParser.findEndOfFormat(versionRange, pos, versionRange.length());		try {			position[0] = end + 1;			return VersionFormat.compile(versionRange, pos, end);		} catch (FormatException e) {			throw new IllegalArgumentException(e.getMessage());		}	}	/**	 * Returns the minimum Version of this VersionRange	 * @return the minimum Version of this VersionRange	 */	public Version getMinimum() {		return minVersion;	}	/**	 * Indicates if the minimum version is included in the version range.	 * @return true if the minimum version is included in the version range;	 * otherwise false is returned	 */	public boolean getIncludeMinimum() {		return includeMin;	}	/**	 * Returns the maximum Version of this VersionRange	 * @return the maximum Version of this VersionRange	 */	public Version getMaximum() {		return maxVersion;	}	/**	 * Indicates if the maximum version is included in the version range.	 * @return true if the maximum version is included in the version range;	 * otherwise false is returned	 */	public boolean getIncludeMaximum() {		return includeMax;	}	public VersionRange intersect(VersionRange r2) {		int minCompare = minVersion.compareTo(r2.getMinimum());		int maxCompare = maxVersion.compareTo(r2.getMaximum());		boolean resultMinIncluded;		Version resultMin;		if (minCompare == 0) {			if (maxCompare == 0 && includeMin == r2.getIncludeMinimum() && includeMax == r2.getIncludeMaximum())				return this;			resultMin = minVersion;			resultMinIncluded = includeMin && r2.getIncludeMinimum();		} else if (minCompare < 0) {			resultMin = r2.getMinimum();			resultMinIncluded = r2.getIncludeMinimum();		} else { // minCompare > 0)			resultMin = minVersion;			resultMinIncluded = includeMin;		}		boolean resultMaxIncluded;		Version resultMax;		if (maxCompare > 0) {			resultMax = r2.getMaximum();			resultMaxIncluded = r2.getIncludeMaximum();		} else if (maxCompare < 0) {			resultMax = maxVersion;			resultMaxIncluded = includeMax;		} else {//maxCompare == 0			resultMax = maxVersion;			resultMaxIncluded = includeMax && r2.getIncludeMaximum();		}		int minMaxCmp = resultMin.compareTo(resultMax);		if (minMaxCmp < 0 || (minMaxCmp == 0 && resultMinIncluded && resultMaxIncluded))			return new VersionRange(resultMin, resultMinIncluded, resultMax, resultMaxIncluded);		return null;	}	/**	 * Returns whether the given version is included in this VersionRange.	 * This will depend on the minimum and maximum versions of this VersionRange	 * and the given version.	 * 	 * @param version a version to be tested for inclusion in this VersionRange. 	 * (may be <code>null</code>)	 * @return <code>true</code> if the version is include, 	 * <code>false</code> otherwise 	 */	public boolean isIncluded(Version version) {		if (version == null)			return false;		if (minVersion == maxVersion)			// Can only happen when both includeMin and includeMax are true			return minVersion.equals(version);		int minCheck = includeMin ? 0 : -1;		int maxCheck = includeMax ? 0 : 1;		return minVersion.compareTo(version) <= minCheck && maxVersion.compareTo(version) >= maxCheck;	}	/**	 * Checks if the versions of this range is in compliance with the OSGi version spec.	 * @return A flag indicating whether the range is OSGi compatible or not.	 */	public boolean isOSGiCompatible() {		return minVersion.isOSGiCompatible() && maxVersion.isOSGiCompatible();	}	public boolean equals(Object object) {		if (!(object instanceof VersionRange))			return false;		VersionRange vr = (VersionRange) object;		return includeMin == vr.includeMin && includeMax == vr.includeMax && minVersion.equals(vr.getMinimum()) && maxVersion.equals(vr.getMaximum());	}	public int hashCode() {		final int prime = 31;		int result = 1;		result = prime * result + maxVersion.hashCode();		result = prime * result + minVersion.hashCode();		result = prime * result + (includeMax ? 1231 : 1237);		result = prime * result + (includeMin ? 1231 : 1237);		return result;	}	public String toString() {		StringBuffer result = new StringBuffer();		toString(result);		return result.toString();	}	public void toString(StringBuffer result) {		if (minVersion.getFormat() == VersionFormat.OSGI_FORMAT) {			if (includeMin && includeMax && OSGi_versionMax.equals(maxVersion)) {				minVersion.toString(result);			} else {				result.append(includeMin ? '[' : '(');				minVersion.toString(result);				result.append(',');				maxVersion.toString(result);				result.append(includeMax ? ']' : ')');			}			return;		}		boolean gtEqual = includeMin && includeMax && Version.MAX_VERSION.equals(maxVersion);		result.append("raw:"); //$NON-NLS-1$		if (gtEqual) {			minVersion.rawToString(result, true);		} else {			result.append(includeMin ? '[' : '(');			minVersion.rawToString(result, true);			result.append(',');			maxVersion.rawToString(result, true);			result.append(includeMax ? ']' : ')');		}		if (minVersion.getFormat() != null || minVersion.getOriginal() != null) {			result.append('/');			if (minVersion.getFormat() != null)				minVersion.getFormat().toString(result);			if (minVersion.getOriginal() != null) {				result.append(':');				if (gtEqual) {					minVersion.originalToString(result, true);				} else {					minVersion.originalToString(result, true);					result.append(',');					maxVersion.originalToString(result, true);				}			}		}	}	// Preserve singletons during deserialization	private Object readResolve() {		VersionRange vr = this;		if (equals(emptyRange))			vr = emptyRange;		return vr;	}	private void validateRange() {		int cmp = minVersion.compareTo(maxVersion);		if (!(cmp < 0 || (cmp == 0 && includeMin && includeMax)))			throw new IllegalArgumentException(NLS.bind(Messages.range_min_0_is_not_less_then_range_max_1, minVersion, maxVersion));	}	public static org.eclipse.osgi.service.resolver.VersionRange toOSGiVersionRange(VersionRange range) {		if (range.equals(emptyRange))			return org.eclipse.osgi.service.resolver.VersionRange.emptyRange;		return new org.eclipse.osgi.service.resolver.VersionRange(Version.toOSGiVersion(range.getMinimum()), range.getIncludeMinimum(), Version.toOSGiVersion(range.getMaximum()), range.getIncludeMinimum());	}	public static VersionRange fromOSGiVersionRange(org.eclipse.osgi.service.resolver.VersionRange range) {		if (range.equals(org.eclipse.osgi.service.resolver.VersionRange.emptyRange))			return emptyRange;		return new VersionRange(Version.fromOSGiVersion(range.getMinimum()), range.getIncludeMinimum(), Version.fromOSGiVersion(range.getMaximum()), range.getIncludeMinimum());	}}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionVector.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionVector.java
new file mode 100644
index 0000000..cc95fcd
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/VersionVector.java
@@ -0,0 +1,367 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core;
+
+import java.io.Serializable;
+
+/**
+ * The VersionVector represents an array of Comparable objects. The array can be
+ * nested since a VersionVector is Comparable in itself.
+ *  
+ * @Immutable
+ */
+public class VersionVector implements Comparable, Serializable {
+
+	private static final class MaxStringValue implements Comparable, Serializable {
+		private static final long serialVersionUID = -4936252230441132767L;
+
+		MaxStringValue() {
+			// Empty constructor
+		}
+
+		public int compareTo(Object o) {
+			return o == this ? 0 : (o == MAX_VALUE || o instanceof Integer || o instanceof VersionVector ? -1 : 1);
+		}
+
+		// For singleton deserialization
+		private Object readResolve() {
+			return MAXS_VALUE;
+		}
+
+		public String toString() {
+			return "m"; //$NON-NLS-1$
+		}
+	}
+
+	private static final class MaxValue implements Comparable, Serializable {
+		private static final long serialVersionUID = -5889641741635253589L;
+
+		MaxValue() {
+			// Empty constructor
+		}
+
+		public int compareTo(Object o) {
+			return o == this ? 0 : 1;
+		}
+
+		public String toString() {
+			return "M"; //$NON-NLS-1$
+		}
+
+		// For singleton deserialization
+		private Object readResolve() {
+			return MAX_VALUE;
+		}
+	}
+
+	private static class MinValue implements Comparable, Serializable {
+		private static final long serialVersionUID = -1066323980049812226L;
+
+		MinValue() {
+			// Empty constructor
+		}
+
+		public int compareTo(Object o) {
+			return o == this ? 0 : -1;
+		}
+
+		public String toString() {
+			return "-M"; //$NON-NLS-1$
+		}
+
+		private Object readResolve() {
+			return MIN_VALUE;
+		}
+	}
+
+	/**
+	 * A value that is greater then any other value
+	 */
+	public static final Comparable MAX_VALUE = new MaxValue();
+
+	/**
+	 * A value that is greater then any string but less then {@link #MAX_VALUE} and
+	 * any Integer or VersionVector.
+	 */
+	public static final Comparable MAXS_VALUE = new MaxStringValue();
+
+	/**
+	 * A value that is less then any other value
+	 */
+	public static final Comparable MIN_VALUE = new MinValue();
+
+	private static final long serialVersionUID = -8385373304298723744L;
+
+	static void rawToString(StringBuffer sb, boolean forRange, Comparable e) {
+		if (e instanceof String) {
+			writeQuotedString(sb, forRange, (String) e, '\'', 0, false);
+		} else if (e instanceof VersionVector) {
+			sb.append('<');
+			((VersionVector) e).toString(sb, forRange);
+			sb.append('>');
+		} else
+			sb.append(e);
+	}
+
+	/**
+	 * Write a string within quotes. If the string is found to contain the quote, an attempt is made
+	 * to flip quote character (single quote becomes double quote and vice versa). A string that contains
+	 * both will be written as several adjacent quoted strings so that each string is quoted with a
+	 * quote character that it does not contain.
+	 * @param sb The buffer that will receive the string
+	 * @param rangeSafe Set to <code>true</code> if the resulting string will be used in a range string
+	 *        and hence need to escape the range delimiter characters
+	 * @param s The string to be written
+	 * @param quote The quote character to start with. Must be the single or double quote character.
+	 * @param startPos The start position
+	 * @param didFlip True if the call is recursive and thus, cannot switch quotes in the first string.
+	 */
+	static void writeQuotedString(StringBuffer sb, boolean rangeSafe, String s, char quote, int startPos, boolean didFlip) {
+		int quotePos = sb.length();
+		sb.append(quote);
+		boolean otherSeen = false;
+		int top = s.length();
+		for (int idx = startPos; idx < top; ++idx) {
+			char c = s.charAt(idx);
+			if (c == '\'' || c == '"') {
+				if (c == quote) {
+					char otherQuote = quote == '\'' ? '"' : '\'';
+					if (didFlip || otherSeen) {
+						// We can only flip once
+						sb.append(quote);
+						writeQuotedString(sb, rangeSafe, s, otherQuote, idx, true);
+						return;
+					}
+					quote = otherQuote;
+					sb.setCharAt(quotePos, quote);
+					didFlip = true;
+				} else
+					otherSeen = true;
+			}
+			if (rangeSafe && (c == '\\' || c == '[' || c == '(' || c == ']' || c == ')' || c == ',' || c <= ' '))
+				sb.append('\\');
+			sb.append(c);
+		}
+		sb.append(quote);
+	}
+
+	private static int compareSegments(Comparable a, Comparable b) {
+		if (a == b)
+			return 0;
+
+		if (a instanceof Integer && b instanceof Integer) {
+			int ai = ((Integer) a).intValue();
+			int bi = ((Integer) b).intValue();
+			return ai > bi ? 1 : (ai < bi ? -1 : 0);
+		}
+
+		if (a instanceof String && b instanceof String)
+			return a.compareTo(b);
+
+		if (a == MAX_VALUE || a == MIN_VALUE || a == MAXS_VALUE)
+			return a.compareTo(b);
+
+		if (b == MAX_VALUE || b == MIN_VALUE || b == MAXS_VALUE)
+			return -b.compareTo(a);
+
+		if (a instanceof Integer)
+			return 1;
+		if (b instanceof Integer)
+			return -1;
+		if (a instanceof VersionVector)
+			return (b instanceof VersionVector) ? a.compareTo(b) : 1;
+
+		if (b instanceof VersionVector)
+			return -1;
+
+		throw new IllegalArgumentException();
+	}
+
+	private Comparable padValue;
+
+	private Comparable[] vector;
+
+	VersionVector() {
+		// Constructor used in conjunction with init (when version is parsed from string)
+	}
+
+	VersionVector(Comparable[] vector, Comparable pad) {
+		this.vector = vector;
+		this.padValue = (pad == MIN_VALUE) ? null : pad;
+	}
+
+	public int compareTo(Object o) {
+		if (o == this)
+			return 0;
+
+		VersionVector ov = (VersionVector) o;
+		Comparable[] t_vector = vector;
+		Comparable[] o_vector = ov.vector;
+		int top = t_vector.length;
+		if (top > o_vector.length)
+			top = o_vector.length;
+
+		for (int idx = 0; idx < top; ++idx) {
+			int cmp = compareSegments(t_vector[idx], o_vector[idx]);
+			if (cmp != 0)
+				return cmp;
+		}
+
+		// All elements compared equal up to this point. Check
+		// pad values
+		if (top < t_vector.length)
+			return (ov.padValue == null) ? 1 : compareReminder(top, ov.padValue);
+
+		if (top < o_vector.length)
+			return (padValue == null) ? -1 : -ov.compareReminder(top, padValue);
+
+		// Lengths are equal. Compare pad values
+		return padValue == null ? (ov.padValue == null ? 0 : -1) : (ov.padValue == null ? 1 : compareSegments(padValue, ov.padValue));
+	}
+
+	public boolean equals(Object o) {
+		if (o == this)
+			return true;
+
+		if (!(o instanceof VersionVector))
+			return false;
+
+		VersionVector ov = (VersionVector) o;
+
+		// We compare pad first since it is impossible for versions with
+		// different pad to be equal (versions are padded to infinity) 
+		if (padValue == null) {
+			if (ov.padValue != null)
+				return false;
+		} else {
+			if (ov.padValue == null || !padValue.equals(ov.padValue))
+				return false;
+		}
+
+		Comparable[] t_vector = vector;
+		Comparable[] o_vector = ov.vector;
+		int idx = t_vector.length;
+
+		// If the length of the vector differs, the versions cannot be equal
+		// since segments equal to pad are stripped by the parser
+		if (idx != o_vector.length)
+			return false;
+
+		while (--idx >= 0)
+			if (!t_vector[idx].equals(o_vector[idx]))
+				return false;
+
+		return true;
+	}
+
+	/**
+	 * Returns the pad value used when comparing this versions to
+	 * versions that has a raw vector with a larger number of elements
+	 * @return The pad value or <code>null</code> if not set.
+	 */
+	public Comparable getPad() {
+		return padValue;
+	}
+
+	/**
+	 * An element from the raw vector
+	 * @param index The zero based index of the desired element
+	 * @return An element from the raw vector
+	 */
+	public Comparable getSegment(int index) {
+		return vector[index];
+	}
+
+	/**
+	 * Returns the number of elements in the raw vector
+	 * @return The element count
+	 */
+	public int getSegmentCount() {
+		return vector.length;
+	}
+
+	public int hashCode() {
+		int hashCode = padValue == null ? 31 : padValue.hashCode();
+		int idx = vector.length;
+		while (--idx >= 0) {
+			Object elem = vector[idx];
+			if (elem != null)
+				hashCode += elem.hashCode();
+			hashCode = hashCode * 31;
+		}
+		return hashCode;
+	}
+
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		toString(sb);
+		return sb.toString();
+	}
+
+	/**
+	 * Append the string representation of this instance to the
+	 * <code>sb</code> buffer.
+	 * @param sb The buffer to append to
+	 */
+	public void toString(StringBuffer sb) {
+		toString(sb, false);
+	}
+
+	/**
+	 * Append the string representation of this instance to the
+	 * <code>sb</code> buffer.
+	 * @param sb The buffer to append to
+	 * @param rangeSafe If <code>true</code>, the range delimiters will be escaped
+	 * with backslash.
+	 */
+	public void toString(StringBuffer sb, boolean rangeSafe) {
+		int top = vector.length;
+		if (top == 0)
+			// Write one pad value as explicit. It will be considered
+			// redundant and removed by the parser but the raw format
+			// does not allow zero elements
+			rawToString(sb, rangeSafe, padValue == null ? MIN_VALUE : padValue);
+		else {
+			for (int idx = 0; idx < top; ++idx) {
+				if (idx > 0)
+					sb.append('.');
+				rawToString(sb, rangeSafe, vector[idx]);
+			}
+		}
+		if (padValue != null) {
+			sb.append('p');
+			rawToString(sb, rangeSafe, padValue);
+		}
+	}
+
+	/**
+	 * This method is package protected since it violates the immutable
+	 * contract.
+	 * @return The raw vector. Must be treated as read-only
+	 */
+	Comparable[] getVector() {
+		return vector;
+	}
+
+	void init(Comparable[] vec, Comparable pad) {
+		vector = vec;
+		padValue = (pad == MIN_VALUE) ? null : pad;
+	}
+
+	private int compareReminder(int idx, Comparable othersPad) {
+		int cmp;
+		for (cmp = 0; idx < vector.length && cmp == 0; ++idx)
+			cmp = compareSegments(vector[idx], othersPad);
+		if (cmp == 0)
+			cmp = (padValue == null) ? -1 : padValue.compareTo(othersPad);
+		return cmp;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/messages.properties b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/messages.properties
new file mode 100644
index 0000000..0454093
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/messages.properties
@@ -0,0 +1,61 @@
+###############################################################################
+ # Copyright (c) 2009 Cloudsmith Inc. and others.
+ # All rights reserved. This program and the accompanying materials
+ # are made available under the terms of the Eclipse Public License v1.0
+ # which accompanies this distribution, and is available at
+ # http://www.eclipse.org/legal/epl-v10.html
+ #
+ # Contributors:
+ #     Cloudsmith Inc. - initial API and implementation
+###############################################################################
+_0_is_not_a_positive_integer_in_osgi_1=The {0} value is not a positive in OSGi version: "{1}"
+_0_is_not_a_string_in_osgi_1=The {0} value is not a string in OSGi version: "{1}"
+_0_is_not_a_valid_qualifier_in_osgi_1=The {0} value is invalid in OSGi version: "{1}"array_can_not_be_empty=Array format can not be empty
+array_can_not_be_empty=Array format can not be empty
+array_can_not_have_character_group=Array format can not have a character group
+auto_can_not_have_pad_value=Auto format can not have a pad value
+cannot_combine_ignore_with_other_instruction=Cannot combine ignore with other instruction
+cannot_combine_range_upper_bound_with_pad_value=Cannot combine range upper bound with pad value
+character_group_defined_more_then_once=Character group was defined more then once
+colon_expected_before_original_version_0=A colon was expected before original version: {0}
+default_defined_more_then_once=Default defined more then once
+delimiter_can_not_be_ignored=A delimiter cannot be ignored
+delimiter_can_not_have_default_value=A delimiter cannot have a default value
+delimiter_can_not_have_pad_value=A delimiter cannot have a pad value
+delimiter_can_not_have_range=A delimiter cannot have a range
+EOS_after_escape=End of string was encountere after the escape character
+expected_orignal_after_colon_0=An original version was expected after colon: {0}
+expected_orignal_after_slash_0=A format or colon was expected after slash: {0}
+expected_slash_after_raw_vector_0=A slash was expected after a raw version: {0}
+format_0_unable_to_parse_1=Format "{0}" was unable to parse {1}
+format_0_unable_to_parse_empty_version=Format "{0}" was unable to parse an empty version
+format_is_empty=Format is empty
+format_must_be_delimited_by_colon_0=Format must be delimited by version range: {0}
+group_can_not_be_empty=A group can not be empty
+ignore_defined_more_then_once=More then one definition of ignore
+illegal_character_encountered_ascii_0=An illegal character was encountered. Code = {0}
+illegal_number_of_entries_0_in_osgi_1=Illegal number of entries {0} in OSGi version: "{1}"
+missing_comma_in_range_0=Missing comma in range "{0}"
+negative_character_range=The character range is negative
+neither_raw_vector_nor_format_specified_0=Neither raw version nor format was specified: {0}
+number_can_not_have_pad_value=A number cannot have a pad value
+only_format_specified_0=Only a format was specified: {0}
+original_must_start_with_colon_0=Original version must start with colon: {0}
+original_stated_but_missing_0=Expected original version after colon: {0}
+pad_defined_more_then_once=Pad was defined more then once
+pad_not_allowed_in_osgi_0=Pad is not allowed in an OSGi version: "{0}"
+premature_end_of_format=Premature end of format
+premature_end_of_format_expected_0=Premature end of format, "{0}" expected
+premature_EOS_0=Premature end of string in "{0}"
+range_defined_more_then_once=Range defined more then once
+range_max_cannot_be_less_then_range_min=The range maximum must not be less then its minimum
+range_max_cannot_be_zero=The range maximum cannot be zero
+range_min_0_is_not_less_then_range_max_1=Range minimum "{0}" is not less then range maximum "{1}" (inclusion is required at both ends if the versions are equal)
+range_boundaries_0_and_1_cannot_have_different_formats=Range boundaries "{0}" and "{1}" cannot have different formats
+raw_and_original_must_use_same_range_inclusion_0=Raw and original must use the same range inclusion markers in range "{0}"
+raw_element_can_not_have_pad_value=A raw element cannot have a pad value
+raw_element_expected_0=A raw element was expected: {0}
+string_can_not_have_pad_value=A string cannot have a pad value
+syntax_error_in_version_format_0_1_2=Syntax error in version format "{0}" at position {1}: {2}
+syntax_error_in_version_format_0_1_found_2_expected_3=Syntax error in version format "{0}" at position {1}: Found {2} when {3} was expected
+unbalanced_format_parenthesis=Unbalanced format parenthesis
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/FormatException.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/FormatException.java
new file mode 100644
index 0000000..d4a555d
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/FormatException.java
@@ -0,0 +1,24 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core;
+
+/**
+ * Exception thrown by the {@link VersionFormatParser}
+ *
+ */
+public class FormatException extends Exception {
+
+	private static final long serialVersionUID = -867104101610941043L;
+
+	public FormatException(String message) {
+		super(message);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Messages.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Messages.java
new file mode 100644
index 0000000..69b0c41
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Messages.java
@@ -0,0 +1,128 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+ package org.eclipse.equinox.internal.provisional.p2.core;
+
+import org.eclipse.osgi.util.NLS;
+
+public class Messages extends NLS {
+	public static String _0_is_not_a_positive_integer_in_osgi_1;
+
+	public static String _0_is_not_a_string_in_osgi_1;
+
+	public static String _0_is_not_a_valid_qualifier_in_osgi_1;
+
+	public static String array_can_not_be_empty;
+
+	public static String array_can_not_have_character_group;
+
+	public static String auto_can_not_have_pad_value;
+
+	public static String cannot_combine_ignore_with_other_instruction;
+
+	public static String cannot_combine_range_upper_bound_with_pad_value;
+
+	public static String character_group_defined_more_then_once;
+
+	public static String colon_expected_before_original_version_0;
+
+	public static String default_defined_more_then_once;
+
+	public static String delimiter_can_not_be_ignored;
+
+	public static String delimiter_can_not_have_default_value;
+
+	public static String delimiter_can_not_have_pad_value;
+
+	public static String delimiter_can_not_have_range;
+
+	public static String EOS_after_escape;
+
+	public static String expected_orignal_after_colon_0;
+
+	public static String expected_orignal_after_slash_0;
+
+	public static String expected_slash_after_raw_vector_0;
+
+	public static String format_0_unable_to_parse_1;
+
+	public static String format_0_unable_to_parse_empty_version;
+
+	public static String format_is_empty;
+
+	public static String format_must_be_delimited_by_colon_0;
+
+	public static String group_can_not_be_empty;
+
+	public static String ignore_defined_more_then_once;
+
+	public static String illegal_character_encountered_ascii_0;
+
+	public static String illegal_number_of_entries_0_in_osgi_1;
+
+	public static String missing_comma_in_range_0;
+
+	public static String negative_character_range;
+
+	public static String neither_raw_vector_nor_format_specified_0;
+
+	public static String number_can_not_have_pad_value;
+
+	public static String only_format_specified_0;
+
+	public static String original_must_start_with_colon_0;
+
+	public static String original_stated_but_missing_0;
+
+	public static String pad_defined_more_then_once;
+
+	public static String pad_not_allowed_in_osgi_0;
+
+	public static String premature_end_of_format;
+
+	public static String premature_end_of_format_expected_0;
+
+	public static String premature_EOS_0;
+
+	public static String range_boundaries_0_and_1_cannot_have_different_formats;
+
+	public static String range_defined_more_then_once;
+
+	public static String range_max_cannot_be_less_then_range_min;
+
+	public static String range_max_cannot_be_zero;
+
+	public static String range_min_0_is_not_less_then_range_max_1;
+
+	public static String raw_and_original_must_use_same_range_inclusion_0;
+
+	public static String raw_element_can_not_have_pad_value;
+
+	public static String raw_element_expected_0;
+
+	public static String string_can_not_have_pad_value;
+
+	public static String syntax_error_in_version_format_0_1_2;
+
+	public static String syntax_error_in_version_format_0_1_found_2_expected_3;
+
+	public static String unbalanced_format_parenthesis;
+
+	private static final String BUNDLE_NAME = "org.eclipse.equinox.internal.provisional.p2.core.messages"; //$NON-NLS-1$
+
+	static {
+		// initialize resource bundle
+		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
+	}
+
+	private Messages() {
+		// Prevent instance creation
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Version.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Version.java
index 4e3c699..32c05bd 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Version.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/Version.java
@@ -1 +1 @@
-/* * Copyright (c) OSGi Alliance (2004, 2008). All Rights Reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//******************************************************************************* * Copyright (c) 2008 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: *     IBM Corporation - initial API and implementation *******************************************************************************/package org.eclipse.equinox.internal.provisional.p2.core;import java.util.NoSuchElementException;import java.util.StringTokenizer;/** * Version identifier for bundles and packages. *  * <p> * Version identifiers have four components. * <ol> * <li>Major version. A non-negative integer.</li> * <li>Minor version. A non-negative integer.</li> * <li>Micro version. A non-negative integer.</li> * <li>Qualifier. A text string. See <code>Version(String)</code> for the * format of the qualifier string.</li> * </ol> *  * <p> * <code>Version</code> objects are immutable. *  * @since 1.3 * @Immutable * @version $Revision: 5962 $ */public class Version implements Comparable {	private final int major;	private final int minor;	private final int micro;	private final String qualifier;	private static final String SEPARATOR = "."; //$NON-NLS-1$	/**	 * The empty version "0.0.0". Equivalent to calling	 * <code>new Version(0,0,0)</code>.	 */	public static final Version emptyVersion = new Version(0, 0, 0);	/**	 * Creates a version identifier from the specified numerical components.	 * 	 * <p>	 * The qualifier is set to the empty string.	 * 	 * @param major Major component of the version identifier.	 * @param minor Minor component of the version identifier.	 * @param micro Micro component of the version identifier.	 * @throws IllegalArgumentException If the numerical components are	 *         negative.	 */	public Version(int major, int minor, int micro) {		this(major, minor, micro, null);	}	/**	 * Creates a version identifier from the specified components.	 * 	 * @param major Major component of the version identifier.	 * @param minor Minor component of the version identifier.	 * @param micro Micro component of the version identifier.	 * @param qualifier Qualifier component of the version identifier. If	 *        <code>null</code> is specified, then the qualifier will be set to	 *        the empty string.	 * @throws IllegalArgumentException If the numerical components are negative	 *         or the qualifier string is invalid.	 */	public Version(int major, int minor, int micro, String qualifier) {		if (qualifier == null) {			qualifier = ""; //$NON-NLS-1$		}		this.major = major;		this.minor = minor;		this.micro = micro;		this.qualifier = qualifier;		validate();	}	/**	 * Created a version identifier from the specified string.	 * 	 * <p>	 * Here is the grammar for version strings.	 * 	 * <pre>	 * version ::= major('.'minor('.'micro('.'qualifier)?)?)?	 * major ::= digit+	 * minor ::= digit+	 * micro ::= digit+	 * qualifier ::= (alpha|digit|'_'|'-')+	 * digit ::= [0..9]	 * alpha ::= [a..zA..Z]	 * </pre>	 * 	 * There must be no whitespace in version.	 * 	 * @param version String representation of the version identifier.	 * @throws IllegalArgumentException If <code>version</code> is improperly	 *         formatted.	 */	public Version(String version) {		int major = 0;		int minor = 0;		int micro = 0;		String qualifier = ""; //$NON-NLS-1$		try {			StringTokenizer st = new StringTokenizer(version, SEPARATOR, true);			major = Integer.parseInt(st.nextToken());			if (st.hasMoreTokens()) {				st.nextToken(); // consume delimiter				minor = Integer.parseInt(st.nextToken());				if (st.hasMoreTokens()) {					st.nextToken(); // consume delimiter					micro = Integer.parseInt(st.nextToken());					if (st.hasMoreTokens()) {						st.nextToken(); // consume delimiter						qualifier = st.nextToken();						if (st.hasMoreTokens()) {							throw new IllegalArgumentException("invalid format"); //$NON-NLS-1$						}					}				}			}		} catch (NoSuchElementException e) {			throw new IllegalArgumentException("invalid format"); //$NON-NLS-1$		}		this.major = major;		this.minor = minor;		this.micro = micro;		this.qualifier = qualifier;		validate();	}	/**	 * Called by the Version constructors to validate the version components.	 * 	 * @throws IllegalArgumentException If the numerical components are negative	 *         or the qualifier string is invalid.	 */	private void validate() {		if (major < 0) {			throw new IllegalArgumentException("negative major"); //$NON-NLS-1$		}		if (minor < 0) {			throw new IllegalArgumentException("negative minor"); //$NON-NLS-1$		}		if (micro < 0) {			throw new IllegalArgumentException("negative micro"); //$NON-NLS-1$		}		char[] chars = qualifier.toCharArray();		for (int i = 0, length = chars.length; i < length; i++) {			char ch = chars[i];			if (('A' <= ch) && (ch <= 'Z')) {				continue;			}			if (('a' <= ch) && (ch <= 'z')) {				continue;			}			if (('0' <= ch) && (ch <= '9')) {				continue;			}			if ((ch == '_') || (ch == '-')) {				continue;			}			throw new IllegalArgumentException("invalid qualifier: " + qualifier); //$NON-NLS-1$		}	}	/**	 * Parses a version identifier from the specified string.	 * 	 * <p>	 * See <code>Version(String)</code> for the format of the version string.	 * 	 * @param version String representation of the version identifier. Leading	 *        and trailing whitespace will be ignored.	 * @return A <code>Version</code> object representing the version	 *         identifier. If <code>version</code> is <code>null</code> or	 *         the empty string then <code>emptyVersion</code> will be	 *         returned.	 * @throws IllegalArgumentException If <code>version</code> is improperly	 *         formatted.	 */	public static Version parseVersion(String version) {		if (version == null) {			return emptyVersion;		}		version = version.trim();		if (version.length() == 0) {			return emptyVersion;		}		return new Version(version);	}	/**	 * Returns the major component of this version identifier.	 * 	 * @return The major component.	 */	public int getMajor() {		return major;	}	/**	 * Returns the minor component of this version identifier.	 * 	 * @return The minor component.	 */	public int getMinor() {		return minor;	}	/**	 * Returns the micro component of this version identifier.	 * 	 * @return The micro component.	 */	public int getMicro() {		return micro;	}	/**	 * Returns the qualifier component of this version identifier.	 * 	 * @return The qualifier component.	 */	public String getQualifier() {		return qualifier;	}	/**	 * Returns the string representation of this version identifier.	 * 	 * <p>	 * The format of the version string will be <code>major.minor.micro</code>	 * if qualifier is the empty string or	 * <code>major.minor.micro.qualifier</code> otherwise.	 * 	 * @return The string representation of this version identifier.	 */	public String toString() {		int q = qualifier.length();		StringBuffer result = new StringBuffer(20 + q);		result.append(major);		result.append(SEPARATOR);		result.append(minor);		result.append(SEPARATOR);		result.append(micro);		if (q > 0) {			result.append(SEPARATOR);			result.append(qualifier);		}		return result.toString();	}	/**	 * Returns a hash code value for the object.	 * 	 * @return An integer which is a hash code value for this object.	 */	public int hashCode() {		return (major << 24) + (minor << 16) + (micro << 8) + qualifier.hashCode();	}	/**	 * Compares this <code>Version</code> object to another object.	 * 	 * <p>	 * A version is considered to be <b>equal to </b> another version if the	 * major, minor and micro components are equal and the qualifier component	 * is equal (using <code>String.equals</code>).	 * 	 * @param object The <code>Version</code> object to be compared.	 * @return <code>true</code> if <code>object</code> is a	 *         <code>Version</code> and is equal to this object;	 *         <code>false</code> otherwise.	 */	public boolean equals(Object object) {		if (object == this) { // quicktest			return true;		}		if (!(object instanceof Version)) {			return false;		}		Version other = (Version) object;		return (major == other.major) && (minor == other.minor) && (micro == other.micro) && qualifier.equals(other.qualifier);	}	/**	 * Compares this <code>Version</code> object to another object.	 * 	 * <p>	 * A version is considered to be <b>less than </b> another version if its	 * major component is less than the other version's major component, or the	 * major components are equal and its minor component is less than the other	 * version's minor component, or the major and minor components are equal	 * and its micro component is less than the other version's micro component,	 * or the major, minor and micro components are equal and it's qualifier	 * component is less than the other version's qualifier component (using	 * <code>String.compareTo</code>).	 * 	 * <p>	 * A version is considered to be <b>equal to</b> another version if the	 * major, minor and micro components are equal and the qualifier component	 * is equal (using <code>String.compareTo</code>).	 * 	 * @param object The <code>Version</code> object to be compared.	 * @return A negative integer, zero, or a positive integer if this object is	 *         less than, equal to, or greater than the specified	 *         <code>Version</code> object.	 * @throws ClassCastException If the specified object is not a	 *         <code>Version</code>.	 */	public int compareTo(Object object) {		if (object == this) { // quicktest			return 0;		}		Version other = (Version) object;		int result = major - other.major;		if (result != 0) {			return result;		}		result = minor - other.minor;		if (result != 0) {			return result;		}		result = micro - other.micro;		if (result != 0) {			return result;		}		return qualifier.compareTo(other.qualifier);	}	public static Version fromOSGiVersion(org.osgi.framework.Version version) {		if (version.equals(org.osgi.framework.Version.emptyVersion))			return emptyVersion;		return new Version(version.getMajor(), version.getMinor(), version.getMicro(), version.getQualifier());	}	public static org.osgi.framework.Version toOSGiVersion(Version version) {		if (version.equals(emptyVersion))			return org.osgi.framework.Version.emptyVersion;		return new org.osgi.framework.Version(version.getMajor(), version.getMinor(), version.getMicro(), version.getQualifier());	}}
\ No newline at end of file
+/******************************************************************************* * Copyright (c) 2009 Cloudsmith and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *  * Contributors: *     Cloudsmith Inc - initial API and implementation. *******************************************************************************/package org.eclipse.equinox.internal.provisional.p2.core;import org.eclipse.osgi.util.NLS;/** * <p>The Omni Version is composed of a vector of Comparable objects and a pad value. The pad * might be <code>null</code>. The vector can contain integers, strings, {@link VersionVector} * instances, or one of the special objects {@link VersionVector#MAX_VALUE MAX_VALUE}, * {@link VersionVector#MAXS_VALUE MAXS_VALUE}, or {@link VersionVector#MIN_VALUE MIN_VALUE}.</p> * * <p>When two versions are compared, they are always considered padded to infinity by their * pad value or by {@link VersionVector#MIN_VALUE MIN_VALUE} in case the pad value is * <code>null</code>. The comparison is type sensitive so that:</p><pre> * MAX_VALUE &gt; Integer &gt; VersionVector &gt; MAXS_VALUE &gt; String &gt; MIN_VALUE<br/> * </pre> * * The class is signature compatible with {@link org.osgi.framework.Version} but attempts * to use it as such might render a {@link UnsupportedOperationException} in case the * vector holds incompatible values. The method {@link #isOSGiCompatible()} can be used * to test. *  * @Immutable * @noextend This class is not intended to be subclassed by clients. */public class Version extends VersionVector {	private static final Integer cache[] = new Integer[100];	private static final char[] allowedOSGiChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-".toCharArray(); //$NON-NLS-1$	public static final Integer ZERO_INT = new Integer(0);	public static final Integer MAX_INT_OBJ = new Integer(Integer.MAX_VALUE);	static {		cache[0] = ZERO_INT;		for (int i = 1; i < cache.length; i++)			cache[i] = new Integer(i);	}	static Integer valueOf(int i) {		try {			return cache[i];		} catch (ArrayIndexOutOfBoundsException e) {			return (i == Integer.MAX_VALUE) ? MAX_INT_OBJ : new Integer(i);		}	}	/**	 * The empty OSGi version "0.0.0". Equivalent to calling	 * <code>new Version(0,0,0)</code>.	 */	public static final Version emptyVersion = new Version(0, 0, 0);	/**	 * The version that is semantically greater then all other versions.	 */	public static final Version MAX_VERSION = new Version("raw:MpM"); //$NON-NLS-1$	/**	 * The version that is semantically less then all other versions.	 */	public static final Version MIN_VERSION = new Version("raw:-M"); //$NON-NLS-1$	private static final long serialVersionUID = 8202715438560849928L;	/**	 * Create an omni version from an OSGi <code>version</code>.	 * @param version The OSGi version. Can be <code>null</code>.	 * @return The created omni version	 */	public static Version fromOSGiVersion(org.osgi.framework.Version version) {		if (version == null)			return null;		if (version.equals(org.osgi.framework.Version.emptyVersion))			return emptyVersion;		return new Version(version.getMajor(), version.getMinor(), version.getMicro(), version.getQualifier());	}	/**	 * Parses a version identifier from the specified string.	 * 	 * <p>	 * See {@link #Version(String)} for the format of the version string.	 * 	 * @param version String representation of the version identifier. Leading	 *        and trailing whitespace will be ignored.	 * @return A <code>Version</code> object representing the version	 *         identifier. If <code>version</code> is <code>null</code> or	 *         the empty string then <code>emptyVersion</code> will be	 *         returned.	 * @throws IllegalArgumentException If <code>version</code> is improperly	 *         formatted.	 */	public static Version parseVersion(String version) {		if (version != null) {			Version v = new Version();			if (VersionParser.parseInto(version, 0, version.length(), v))				return v;		}		return Version.emptyVersion;	}	/**	 * Convert <code>version</code> into its OSGi equivalent if possible.	 *	 * @param version The version to convert. Can be <code>null</code>	 * @return The converted version or <code>null</code> if the argument was <code>null</code>	 * @throws UnsupportedOperationException if the version could not be converted into an OSGi version	 */	public static org.osgi.framework.Version toOSGiVersion(Version version) {		if (version == null)			return null;		if (version.equals(emptyVersion))			return org.osgi.framework.Version.emptyVersion;		return new org.osgi.framework.Version(version.getMajor(), version.getMinor(), version.getMicro(), version.getQualifier());	}	/**	 * For exception messages only	 * @param i the index of the entry	 * @return the name of the entry	 */	private static String getOSGiEntryName(int i) {		String name = null;		switch (i) {			case 0 :				name = "major"; //$NON-NLS-1$				break;			case 1 :				name = "minor"; //$NON-NLS-1$				break;			case 2 :				name = "micro"; //$NON-NLS-1$				break;			case 4 :				name = "qualifier"; //$NON-NLS-1$		}		return name;	}	/**	 * The optional format	 */	private VersionFormat format;	/**	 * The optional original string	 */	private String original;	/**	 * Creates an OSGi version identifier from the specified numerical components.	 * 	 * <p>	 * The qualifier is set to the empty string.	 * 	 * @param major Major component of the version identifier.	 * @param minor Minor component of the version identifier.	 * @param micro Micro component of the version identifier.	 * @throws IllegalArgumentException If the numerical components are	 *         negative.	 */	public Version(int major, int minor, int micro) {		this(major, minor, micro, null);	}	/**	 * Creates an OSGi version identifier from the specified components.	 * 	 * @param major Major component of the version identifier.	 * @param minor Minor component of the version identifier.	 * @param micro Micro component of the version identifier.	 * @param qualifier Qualifier component of the version identifier. If	 *        <code>null</code> is specified, then the qualifier will be set to	 *        the empty string.	 * @throws IllegalArgumentException If the numerical components are negative	 *         or the qualifier string is invalid.	 */	public Version(int major, int minor, int micro, String qualifier) {		if (qualifier != null && qualifier.length() == 0)			qualifier = null;		Comparable[] vector = new Comparable[qualifier == null ? 3 : 4];		vector[0] = valueOf(major);		vector[1] = valueOf(minor);		vector[2] = valueOf(micro);		if (qualifier != null)			vector[3] = qualifier;		init(vector, null, VersionFormat.OSGI_FORMAT, null);		validateOSGI(true);	}	/**	 * Created a version identifier from the specified string.	 * 	 * @param version String representation of the version identifier.	 * @throws IllegalArgumentException If <code>version</code> is improperly	 *         formatted.	 */	public Version(String version) {		VersionParser.parseInto(version, 0, version.length(), this);	}	Version() {		// Empty constructor	}	Version(Comparable[] array, Comparable padValue, VersionFormat format, String original) {		init(array, padValue, format, original);	}	/**	 * Returns the optional format.	 */	public VersionFormat getFormat() {		return format;	}	/**	 * Returns the OSGi major component of this version identifier.	 * 	 * @return The major component.	 * @throws UnsupportedOperationException if the first element in the	 * vector is not a number.	 * @see #isOSGiCompatible()	 */	public int getMajor() {		return getIntElement(0);	}	/**	 * Returns the OSGi micro component of this version identifier.	 * 	 * @return The micro component.	 * @throws UnsupportedOperationException if the third element in the	 * vector is not a number.	 * @see #isOSGiCompatible()	 */	public int getMicro() {		return getIntElement(2);	}	/**	 * Returns the OSGi minor component of this version identifier.	 * 	 * @return The minor component.	 * @throws UnsupportedOperationException if the second element in the	 * vector is not a number.	 * @see #isOSGiCompatible()	 */	public int getMinor() {		return getIntElement(1);	}	/**	 * Returns the <code>original</code> part of the string for this version	 * or <code>null</code> if no such part was provided when the version was	 * created. An OSGi type version will always return the OSGi string representation.	 *	 * @return The <code>original</code> part of the version string or	 * <code>null</code> if that part was missing.	 */	public String getOriginal() {		return original;	}	/**	 * Returns the OSGi qualifier component of this version identifier.	 * 	 * @return The qualifier component or <code>null</code> if not set.	 * @throws UnsupportedOperationException if the fourth element in the	 * vector is set to something other then a string.	 * @see #isOSGiCompatible()	 */	public String getQualifier() {		Comparable[] vector = getVector();		if (vector.length < 4)			return null;		if (!(vector[3] instanceof String))			throw new UnsupportedOperationException();		return (String) vector[3];	}	/**	 * Checks if this version is in compliance with the OSGi version spec.	 * @return A flag indicating whether the version is OSGi compatible or not.	 */	public boolean isOSGiCompatible() {		return format == VersionFormat.OSGI_FORMAT || validateOSGI(false);	}	/**	 * Appends the original for this version onto the <code>sb</code> StringBuffer	 * if present.	 * @param sb The buffer that will receive the raw string format	 * @param rangeSafe Set to <code>true</code> if range delimiters should be escaped	 */	public void originalToString(StringBuffer sb, boolean rangeSafe) {		if (original != null) {			if (rangeSafe) {				// Escape all range delimiters while appending				String s = original;				int end = s.length();				for (int idx = 0; idx < end; ++idx) {					char c = s.charAt(idx);					if (c == '\\' || c == '[' || c == '(' || c == ']' || c == ')' || c == ',' || c <= ' ')						sb.append('\\');					sb.append(c);				}			} else				sb.append(original);		}	}	/**	 * Appends the raw format for this version onto the <code>sb</code> StringBuffer.	 * @param sb The buffer that will receive the raw string format	 * @param rangeSafe Set to <code>true</code> if range delimiters should be escaped	 */	public void rawToString(StringBuffer sb, boolean rangeSafe) {		super.toString(sb, rangeSafe);	}	/**	 * Appends the string representation of this version onto the	 * <code>sb</code> StringBuffer.	 * @param sb The buffer that will receive the version string	 */	public void toString(StringBuffer sb) {		if (format == VersionFormat.OSGI_FORMAT) {			Comparable[] vector = getVector();			sb.append(vector[0]);			sb.append('.');			sb.append(vector[1]);			sb.append('.');			sb.append(vector[2]);			if (vector.length > 3) {				sb.append('.');				sb.append(vector[3]);			}			return;		}		sb.append(VersionParser.RAW_PREFIX);		super.toString(sb, false);		if (format != null || original != null) {			sb.append('/');			if (format != null)				format.toString(sb);			if (original != null) {				sb.append(':');				originalToString(sb, false);			}		}	}	void init(Comparable[] vec, Comparable pad, VersionFormat fmt, String orig) {		init(vec, pad);		format = fmt;		original = orig;	}	private int getIntElement(int i) {		Comparable[] vector = getVector();		if (!(vector.length > i && vector[i] instanceof Integer))			throw new UnsupportedOperationException();		return ((Integer) vector[i]).intValue();	}	// Preserve singletons during deserialization	private Object readResolve() {		Version v = this;		if (equals(MAX_VERSION))			v = MAX_VERSION;		else if (equals(MIN_VERSION))			v = MIN_VERSION;		else if (equals(emptyVersion))			v = emptyVersion;		else if (equals(VersionRange.OSGi_versionMax))			v = VersionRange.OSGi_versionMax;		else if (equals(VersionRange.OSGi_versionMin))			v = VersionRange.OSGi_versionMin;		return v;	}	boolean validateOSGI(boolean throwDetailed) {		Comparable[] vector = getVector();		if (vector.length < 3 || vector.length > 4) {			if (throwDetailed)				throw new IllegalArgumentException(NLS.bind(Messages.illegal_number_of_entries_0_in_osgi_1, valueOf(vector.length), this));			return false;		}		if (getPad() != null) {			if (throwDetailed)				throw new IllegalArgumentException(NLS.bind(Messages.pad_not_allowed_in_osgi_0, this));			return false;		}		for (int i = 0; i < 3; ++i) {			Object e = vector[i];			if (!(e instanceof Integer && ((Integer) e).intValue() >= 0)) {				if (throwDetailed)					throw new IllegalArgumentException(NLS.bind(Messages._0_is_not_a_positive_integer_in_osgi_1, getOSGiEntryName(i), this));				return false;			}		}		if (vector.length == 4) {			Object e = vector[3];			if (!(e instanceof String)) {				if (throwDetailed)					throw new IllegalArgumentException(NLS.bind(Messages._0_is_not_a_string_in_osgi_1, getOSGiEntryName(3), this));				return false;			}			String s = (String) e;			int idx = s.length();			char[] allowed = allowedOSGiChars;			int ctop = allowed.length;			outer: while (--idx >= 0) {				char c = s.charAt(idx);				int cdx = ctop;				while (--cdx >= 0)					if (c == allowed[cdx])						continue outer;				if (throwDetailed)					throw new IllegalArgumentException(NLS.bind(Messages._0_is_not_a_valid_qualifier_in_osgi_1, getOSGiEntryName(3), this));				return false;			}		}		return true;	}}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionFormat.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionFormat.java
new file mode 100644
index 0000000..19a70a9
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionFormat.java
@@ -0,0 +1,1253 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core;
+
+import java.io.Serializable;
+import java.util.*;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * <p>The VersionFormat represents the Omni Version Format in compiled form. It
+ * is also a parser for versions of that format.</p>
+ * <p>An instance of VersionFormat is immutable and thus thread safe. The parser
+ * does not maintain any state.</p>
+ * 
+ * @Immutable
+ * @noextend This class is not intended to be subclassed by clients.
+ */
+public class VersionFormat implements Serializable {
+	private static final long serialVersionUID = 6888925893926932754L;
+
+	/**
+	 * Represents one fragment of a format (i.e. auto, number, string, delimiter, etc.)
+	 */
+	static abstract class Fragment implements Serializable {
+		private static final long serialVersionUID = 4109185333058622681L;
+
+		private final Qualifier qualifier;
+
+		Fragment(Qualifier qualifier) {
+			this.qualifier = qualifier;
+		}
+
+		public final boolean equals(Object f) {
+			return f == this || getClass().equals(f.getClass()) && qualifier.equals(((Fragment) f).qualifier);
+		}
+
+		public final int hashCode() {
+			return 11 * qualifier.hashCode();
+		}
+
+		public boolean isGroup() {
+			return false;
+		}
+
+		public String toString() {
+			StringBuffer sb = new StringBuffer();
+			toString(sb);
+			return sb.toString();
+		}
+
+		Comparable getDefaultValue() {
+			return null;
+		}
+
+		Fragment getFirstLeaf() {
+			return this;
+		}
+
+		Comparable getPadValue() {
+			return null;
+		}
+
+		Qualifier getQualifier() {
+			return qualifier;
+		}
+
+		boolean parse(List segments, String version, int maxPos, TreeInfo info) {
+			return qualifier.parse(new Fragment[] {this}, 0, segments, version, maxPos, info);
+		}
+
+		abstract boolean parseOne(List segments, String version, int maxPos, TreeInfo info);
+
+		void setDefaults(List segments) {
+			// No-op at this level
+		}
+
+		void toString(StringBuffer sb) {
+			if (!(qualifier == VersionFormatParser.EXACT_ONE_QUALIFIER || (qualifier == VersionFormatParser.ZERO_OR_ONE_QUALIFIER && this.isGroup())))
+				qualifier.toString(sb);
+		}
+	}
+
+	/**
+	 * Specifies the min and max occurrences of a fragment
+	 */
+	static class Qualifier implements Serializable {
+		private static final long serialVersionUID = 7494021832824671685L;
+
+		private final int max;
+		private final int min;
+
+		Qualifier(int min, int max) {
+			this.min = min;
+			this.max = max;
+		}
+
+		public boolean equals(Object o) {
+			if (o == this)
+				return true;
+			if (!(o instanceof Qualifier))
+				return false;
+			Qualifier oq = (Qualifier) o;
+			return min == oq.min && max == oq.max;
+		}
+
+		public int hashCode() {
+			return 31 * min + 67 * max;
+		}
+
+		public String toString() {
+			StringBuffer sb = new StringBuffer();
+			toString(sb);
+			return sb.toString();
+		}
+
+		int getMax() {
+			return max;
+		}
+
+		int getMin() {
+			return min;
+		}
+
+		boolean parse(Fragment[] fragments, int fragIdx, List segments, String version, int maxPos, TreeInfo info) {
+			Fragment fragment = fragments[fragIdx++];
+			int idx = 0;
+
+			// Do the required parsing. I.e. iterate this fragment
+			// min number of times.
+			//
+			for (; idx < min; ++idx)
+				if (!fragment.parseOne(segments, version, maxPos, info))
+					return false;
+
+			for (; idx < max; ++idx) {
+				// We are greedy. Continue parsing until we get an exception
+				// and remember the state before each parse is performed.
+				//
+				info.pushState(segments.size(), fragment);
+				if (!fragment.parseOne(segments, version, maxPos, info)) {
+					info.popState(segments, fragment);
+					break;
+				}
+			}
+			int maxParsed = idx;
+
+			for (;;) {
+				// Pad with default values unless the max is unbounded
+				//
+				if (max != Integer.MAX_VALUE) {
+					for (; idx < max; ++idx)
+						fragment.setDefaults(segments);
+				}
+
+				if (fragIdx == fragments.length)
+					// We are the last segment
+					//
+					return true;
+
+				// Try to parse the next segment. If it fails, pop the state of
+				// this segment (or a child thereof) and try again
+				//
+				if (fragments[fragIdx].getQualifier().parse(fragments, fragIdx, segments, version, maxPos, info))
+					return true;
+
+				// Be less greedy, step back one position and try again.
+				//
+				if (maxParsed <= min)
+					// We have no more states to pop. Tell previous that we failed.
+					//
+					return false;
+
+				info.popState(segments, fragment);
+				idx = --maxParsed; // segments now have room for one more default value
+			}
+		}
+
+		void toString(StringBuffer sb) {
+			if (min == 0) {
+				if (max == 1)
+					sb.append('?');
+				else if (max == Integer.MAX_VALUE)
+					sb.append('*');
+				else {
+					sb.append('{');
+					sb.append(min);
+					sb.append(',');
+					sb.append(max);
+					sb.append('}');
+				}
+			} else if (max == Integer.MAX_VALUE) {
+				if (min == 1)
+					sb.append('+');
+				else {
+					sb.append('{');
+					sb.append(min);
+					sb.append(",}"); //$NON-NLS-1$
+				}
+			} else {
+				sb.append('{');
+				sb.append(min);
+				if (min != max) {
+					sb.append(',');
+					sb.append(max);
+				}
+				sb.append('}');
+			}
+		}
+
+		// Preserve singleton when deserialized
+		private Object readResolve() {
+			Qualifier q = this;
+			if (min == 0) {
+				if (max == 1)
+					q = VersionFormatParser.ZERO_OR_ONE_QUALIFIER;
+				else if (max == Integer.MAX_VALUE)
+					q = VersionFormatParser.ZERO_OR_MANY_QUALIFIER;
+			} else if (min == 1) {
+				if (max == 1)
+					q = VersionFormatParser.EXACT_ONE_QUALIFIER;
+				else if (max == Integer.MAX_VALUE)
+					q = VersionFormatParser.ONE_OR_MANY_QUALIFIER;
+			}
+			return q;
+		}
+	}
+
+	private static class AutoFragment extends RangeFragment {
+		private static final long serialVersionUID = -1016534328164247755L;
+
+		AutoFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+			super(instr, qualifier);
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			maxPos = checkRange(pos, maxPos);
+			if (maxPos < 0)
+				return false;
+
+			char c = version.charAt(pos);
+			if (VersionParser.isDigit(c) && isAllowed(c)) {
+				// Parse to next non-digit
+				//
+				int start = pos;
+				int value = c - '0';
+				while (++pos < maxPos) {
+					c = version.charAt(pos);
+					if (!(VersionParser.isDigit(c) && isAllowed(c)))
+						break;
+					value *= 10;
+					value += (c - '0');
+				}
+				int len = pos - start;
+				if (rangeMin > len || len > rangeMax)
+					return false;
+
+				if (!isIgnored())
+					segments.add(Version.valueOf(value));
+				info.setPosition(pos);
+				return true;
+			}
+
+			if (!(VersionParser.isLetter(c) && isAllowed(c)))
+				return false;
+
+			// Parse to next non-letter or next delimiter
+			//
+			int start = pos++;
+			for (; pos < maxPos; ++pos) {
+				c = version.charAt(pos);
+				if (!(VersionParser.isLetter(c) && isAllowed(c)))
+					break;
+			}
+			int len = pos - start;
+			if (rangeMin > len || len > rangeMax)
+				return false;
+
+			if (!isIgnored())
+				segments.add(version.substring(start, pos));
+			info.setPosition(pos);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append('a');
+			super.toString(sb);
+		}
+	}
+
+	private static class DelimiterFragment extends Fragment {
+		private static final long serialVersionUID = 8173654376143370605L;
+		private final char[] delimChars;
+		private final boolean inverted;
+
+		DelimiterFragment(VersionFormatParser.Instructions ep, Qualifier qualifier) {
+			super(qualifier);
+			if (ep == null) {
+				delimChars = null;
+				inverted = false;
+			} else {
+				inverted = ep.inverted;
+				delimChars = ep.characters;
+			}
+		}
+
+		boolean isMatch(String version, int pos) {
+			char c = version.charAt(pos);
+			if (delimChars != null) {
+				for (int idx = 0; idx < delimChars.length; ++idx)
+					if (c == delimChars[idx])
+						return !inverted;
+				return inverted;
+			} else if (VersionParser.isLetterOrDigit(c))
+				return false;
+
+			return true;
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			if (pos < maxPos && isMatch(version, pos)) {
+				// Just swallow, a delimiter does not contribute to the vector.
+				//
+				info.setPosition(pos + 1);
+				return true;
+			}
+			return false;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append('d');
+			if (delimChars != null)
+				appendCharacterRange(sb, delimChars, inverted);
+			super.toString(sb);
+		}
+	}
+
+	static boolean equalsAllowNull(Object a, Object b) {
+		return (a == null) ? (b == null) : (b != null && a.equals(b));
+	}
+
+	private static abstract class ElementFragment extends Fragment {
+		private static final long serialVersionUID = -6834591415456539713L;
+		private final Comparable defaultValue;
+		private final boolean ignored;
+		private final Comparable padValue;
+
+		ElementFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+			super(qualifier);
+			if (instr != null) {
+				ignored = instr.ignore;
+				defaultValue = instr.defaultValue;
+				padValue = instr.padValue;
+			} else {
+				ignored = false;
+				defaultValue = null;
+				padValue = null;
+			}
+		}
+
+		Comparable getDefaultValue() {
+			return defaultValue;
+		}
+
+		Comparable getPadValue() {
+			return padValue;
+		}
+
+		boolean isIgnored() {
+			return ignored;
+		}
+
+		void setDefaults(List segments) {
+			Object defaultVal = getDefaultValue();
+			if (defaultVal != null)
+				segments.add(defaultVal);
+		}
+
+		void toString(StringBuffer sb) {
+			if (ignored) {
+				sb.append('=');
+				sb.append('!');
+				sb.append(';');
+			}
+			if (defaultValue != null) {
+				sb.append('=');
+				VersionVector.rawToString(sb, false, defaultValue);
+				sb.append(';');
+			}
+			if (padValue != null) {
+				sb.append('=');
+				sb.append('p');
+				VersionVector.rawToString(sb, false, padValue);
+				sb.append(';');
+			}
+			super.toString(sb);
+		}
+	}
+
+	private static class GroupFragment extends ElementFragment {
+		private static final long serialVersionUID = 9219978678087669699L;
+		private final boolean array;
+		private final Fragment[] fragments;
+
+		GroupFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, Fragment[] fragments, boolean array) {
+			super(instr, qualifier);
+			this.fragments = fragments;
+			this.array = array;
+		}
+
+		public boolean isGroup() {
+			return !array;
+		}
+
+		Fragment getFirstLeaf() {
+			return fragments[0].getFirstLeaf();
+		}
+
+		Fragment[] getFragments() {
+			return fragments;
+		}
+
+		boolean isArray() {
+			return array;
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			if (array) {
+				ArrayList subSegs = new ArrayList();
+				boolean success = fragments[0].getQualifier().parse(fragments, 0, subSegs, version, maxPos, info);
+				if (!success || subSegs.isEmpty())
+					return false;
+
+				Comparable padValue = info.getPadValue();
+				if (padValue != null)
+					info.setPadValue(null); // Prevent outer group from getting this.
+				else
+					padValue = getPadValue();
+
+				VersionParser.removeRedundantTrail(segments, padValue);
+				segments.add(new VersionVector((Comparable[]) subSegs.toArray(new Comparable[subSegs.size()]), padValue));
+				return true;
+			}
+
+			if (fragments[0].getQualifier().parse(fragments, 0, segments, version, maxPos, info)) {
+				Comparable padValue = getPadValue();
+				if (padValue != null)
+					info.setPadValue(padValue);
+				return true;
+			}
+			return false;
+		}
+
+		void setDefaults(List segments) {
+			Comparable dflt = getDefaultValue();
+			if (dflt != null) {
+				// A group default overrides any defaults within the
+				// group fragments
+				super.setDefaults(segments);
+			} else {
+				// Assign defaults for all fragments
+				for (int idx = 0; idx < fragments.length; ++idx)
+					fragments[idx].setDefaults(segments);
+			}
+		}
+
+		void toString(StringBuffer sb) {
+			if (array) {
+				sb.append('<');
+				for (int idx = 0; idx < fragments.length; ++idx)
+					fragments[idx].toString(sb);
+				sb.append('>');
+			} else {
+				if (getQualifier() == VersionFormatParser.ZERO_OR_ONE_QUALIFIER) {
+					sb.append('[');
+					for (int idx = 0; idx < fragments.length; ++idx)
+						fragments[idx].toString(sb);
+					sb.append(']');
+				} else {
+					sb.append('(');
+					for (int idx = 0; idx < fragments.length; ++idx)
+						fragments[idx].toString(sb);
+					sb.append(')');
+				}
+			}
+			super.toString(sb);
+		}
+	}
+
+	private static class LiteralFragment extends Fragment {
+		private static final long serialVersionUID = 6210696245839471802L;
+		private final String string;
+
+		LiteralFragment(Qualifier qualifier, String string) {
+			super(qualifier);
+			this.string = string;
+		}
+
+		String getString() {
+			return string;
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			int litLen = string.length();
+			if (pos + litLen > maxPos)
+				return false;
+
+			for (int idx = 0; idx < litLen; ++idx, ++pos) {
+				if (string.charAt(idx) != version.charAt(pos))
+					return false;
+			}
+			info.setPosition(pos);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			String str = string;
+			if (str.length() != 1) {
+				sb.append('\'');
+				toStringEscaped(sb, str, "\'"); //$NON-NLS-1$
+				sb.append('\'');
+			} else {
+				char c = str.charAt(0);
+				switch (c) {
+					case '\'' :
+					case '\\' :
+					case '<' :
+					case '[' :
+					case '(' :
+					case '{' :
+					case '?' :
+					case '*' :
+					case '+' :
+					case '=' :
+						sb.append('\\');
+						sb.append(c);
+						break;
+					default :
+						if (VersionParser.isLetterOrDigit(c)) {
+							sb.append('\\');
+							sb.append(c);
+						} else
+							sb.append(c);
+				}
+			}
+			super.toString(sb);
+		}
+	}
+
+	private static class NumberFragment extends RangeFragment {
+		private static final long serialVersionUID = -8552754381106711507L;
+		private final boolean signed;
+
+		NumberFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, boolean signed) {
+			super(instr, qualifier);
+			this.signed = signed;
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			maxPos = checkRange(pos, maxPos);
+			if (maxPos < 0)
+				return false;
+
+			// Parse to next non-digit
+			//
+			int start = pos;
+			int value;
+
+			char c = version.charAt(pos);
+			if (signed || characters != null) {
+				boolean negate = false;
+				if (signed && c == '-' && pos + 1 < maxPos) {
+					negate = true;
+					c = version.charAt(++pos);
+				}
+
+				if (!(c >= '0' && c <= '9' && isAllowed(c)))
+					return false;
+
+				// Parse to next non-digit
+				//
+				value = c - '0';
+				while (++pos < maxPos) {
+					c = version.charAt(pos);
+					if (!(c >= '0' && c <= '9' && isAllowed(c)))
+						break;
+					value *= 10;
+					value += (c - '0');
+				}
+				if (negate)
+					value = -value;
+			} else {
+				if (c < '0' || c > '9')
+					return false;
+
+				// Parse to next non-digit
+				//
+				value = c - '0';
+				while (++pos < maxPos) {
+					c = version.charAt(pos);
+					if (c < '0' || c > '9')
+						break;
+					value *= 10;
+					value += (c - '0');
+				}
+			}
+
+			int len = pos - start;
+			if (rangeMin > len || len > rangeMax)
+				return false;
+
+			if (!isIgnored())
+				segments.add(Version.valueOf(value));
+			info.setPosition(pos);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append(signed ? 'N' : 'n');
+			super.toString(sb);
+		}
+	}
+
+	private static class PadFragment extends ElementFragment {
+		private static final long serialVersionUID = 5052010199974380170L;
+
+		PadFragment(Qualifier qualifier) {
+			super(null, qualifier);
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			if (pos >= maxPos || version.charAt(pos) != 'p')
+				return false;
+
+			int[] position = new int[] {++pos};
+			Comparable v = VersionParser.parseRawElement(version, position, maxPos);
+			if (v == null)
+				return false;
+
+			if (!isIgnored())
+				info.setPadValue(v);
+			info.setPosition(position[0]);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append('p');
+			super.toString(sb);
+		}
+	}
+
+	private static class QuotedFragment extends RangeFragment {
+		private static final long serialVersionUID = 6057751133533608969L;
+
+		QuotedFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+			super(instr, qualifier);
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			if (pos >= maxPos)
+				return false;
+
+			char endQuote;
+			char quote = version.charAt(pos);
+			switch (quote) {
+				case '<' :
+					endQuote = '>';
+					break;
+				case '{' :
+					endQuote = '}';
+					break;
+				case '(' :
+					endQuote = ')';
+					break;
+				case '[' :
+					endQuote = ']';
+					break;
+				case '>' :
+					endQuote = '<';
+					break;
+				case '}' :
+					endQuote = '{';
+					break;
+				case ')' :
+					endQuote = '(';
+					break;
+				case ']' :
+					endQuote = '[';
+					break;
+				default :
+					if (VersionParser.isLetterOrDigit(quote))
+						return false;
+					endQuote = quote;
+			}
+			int start = ++pos;
+			char c = version.charAt(pos);
+			while (c != endQuote && isAllowed(c) && ++pos < maxPos)
+				c = version.charAt(pos);
+
+			if (c != endQuote || rangeMin > pos - start)
+				// End quote not found
+				return false;
+
+			int len = pos - start;
+			if (rangeMin > len || len > rangeMax)
+				return false;
+
+			if (!isIgnored())
+				segments.add(version.substring(start, pos));
+			info.setPosition(++pos); // Skip quote
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append('q');
+			super.toString(sb);
+		}
+	}
+
+	private static abstract class RangeFragment extends ElementFragment {
+		private static final long serialVersionUID = -6680402803630334708L;
+		final char[] characters;
+		final boolean inverted;
+		final int rangeMax;
+		final int rangeMin;
+
+		RangeFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+			super(instr, qualifier);
+			if (instr == null) {
+				characters = null;
+				inverted = false;
+				rangeMin = 0;
+				rangeMax = Integer.MAX_VALUE;
+			} else {
+				characters = instr.characters;
+				inverted = instr.inverted;
+				rangeMin = instr.rangeMin;
+				rangeMax = instr.rangeMax;
+			}
+		}
+
+		/**
+		 * Checks that pos is at a valid character position, that we
+		 * have at least the required minimum characters left, and
+		 * if a maximum number of characters is set, limits the
+		 * returned value to a maxPos that reflects that maximum.
+		 * @param pos the current position
+		 * @param maxPos the current maxPos
+		 * @return maxPos, possibly limited by rangeMax
+		 */
+		int checkRange(int pos, int maxPos) {
+			int check = pos;
+			if (rangeMin == 0)
+				check++; // Verify one character
+			else
+				check += rangeMin;
+
+			if (check > maxPos)
+				// Less then min characters left
+				maxPos = -1;
+			else {
+				if (rangeMax != Integer.MAX_VALUE) {
+					check = pos + rangeMax;
+					if (check < maxPos)
+						maxPos = check;
+				}
+			}
+			return maxPos;
+		}
+
+		boolean isAllowed(char c) {
+			char[] crs = characters;
+			if (crs != null) {
+				int idx = crs.length;
+				while (--idx >= 0)
+					if (c == crs[idx])
+						return !inverted;
+				return inverted;
+			}
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			if (characters != null)
+				appendCharacterRange(sb, characters, inverted);
+			if (rangeMin != 0 || rangeMax != Integer.MAX_VALUE) {
+				sb.append('=');
+				sb.append('{');
+				sb.append(rangeMin);
+				if (rangeMin != rangeMax) {
+					sb.append(',');
+					if (rangeMax != Integer.MAX_VALUE)
+						sb.append(rangeMax);
+				}
+				sb.append('}');
+				sb.append(';');
+			}
+			super.toString(sb);
+		}
+	}
+
+	private static class RawFragment extends ElementFragment {
+		private static final long serialVersionUID = 4107448125256042602L;
+
+		RawFragment(VersionFormatParser.Instructions processing, Qualifier qualifier) {
+			super(processing, qualifier);
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int[] position = new int[] {info.getPosition()};
+			Comparable v = VersionParser.parseRawElement(version, position, maxPos);
+			if (v == null)
+				return false;
+
+			if (!isIgnored())
+				segments.add(v);
+			info.setPosition(position[0]);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append('r');
+			super.toString(sb);
+		}
+	}
+
+	private static class StringFragment extends RangeFragment {
+		private static final long serialVersionUID = -2265924553606430164L;
+		final boolean anyChar;
+
+		StringFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, boolean noLimit) {
+			super(instr, qualifier);
+			anyChar = noLimit;
+		}
+
+		boolean parseOne(List segments, String version, int maxPos, TreeInfo info) {
+			int pos = info.getPosition();
+			maxPos = checkRange(pos, maxPos);
+			if (maxPos < 0)
+				return false;
+
+			// Parse to next delimiter or end of string
+			//
+			int start = pos;
+			if (characters != null) {
+				if (anyChar) {
+					// Swallow everything that matches the allowed characters
+					for (; pos < maxPos; ++pos) {
+						if (!isAllowed(version.charAt(pos)))
+							break;
+					}
+				} else {
+					// Swallow letters that matches the allowed characters
+					for (; pos < maxPos; ++pos) {
+						char c = version.charAt(pos);
+						if (!(VersionParser.isLetter(c) && isAllowed(c)))
+							break;
+					}
+				}
+			} else {
+				if (anyChar)
+					// Swallow all characters
+					pos = maxPos;
+				else {
+					// Swallow all letters
+					for (; pos < maxPos; ++pos) {
+						if (!VersionParser.isLetter(version.charAt(pos)))
+							break;
+					}
+				}
+			}
+			int len = pos - start;
+			if (len == 0 || rangeMin > len || len > rangeMax)
+				return false;
+
+			if (!isIgnored())
+				segments.add(version.substring(start, pos));
+			info.setPosition(pos);
+			return true;
+		}
+
+		void toString(StringBuffer sb) {
+			sb.append(anyChar ? 'S' : 's');
+			super.toString(sb);
+		}
+	}
+
+	private static class TreeInfo extends ArrayList {
+		private static final long serialVersionUID = 4770093863009659750L;
+
+		private static class StateInfo {
+			Fragment fragment;
+			int segmentCount;
+			int position;
+
+			StateInfo(int position, int segmentCount, Fragment fragment) {
+				this.fragment = fragment;
+				this.position = position;
+				this.segmentCount = segmentCount;
+			}
+		}
+
+		private Comparable padValue;
+		private int top;
+
+		TreeInfo(Fragment frag, int pos) {
+			add(new StateInfo(pos, 0, frag));
+			top = 0;
+		}
+
+		Comparable getPadValue() {
+			return padValue;
+		}
+
+		int getPosition() {
+			return ((StateInfo) get(top)).position;
+		}
+
+		void popState(List segments, Fragment frag) {
+			int idx = top;
+			while (idx > 0) {
+				StateInfo si = (StateInfo) get(idx);
+				if (si.fragment == frag) {
+					int nsegs = segments.size();
+					int segMax = si.segmentCount;
+					while (nsegs > segMax)
+						segments.remove(--nsegs);
+					top = idx - 1;
+					break;
+				}
+			}
+		}
+
+		void pushState(int segCount, Fragment fragment) {
+			int pos = ((StateInfo) get(top)).position;
+			if (++top == size())
+				add(new StateInfo(pos, segCount, fragment));
+			else {
+				StateInfo si = (StateInfo) get(top);
+				si.fragment = fragment;
+				si.position = pos;
+				si.segmentCount = segCount;
+			}
+		}
+
+		void setPadValue(Comparable pad) {
+			padValue = pad;
+		}
+
+		void setPosition(int pos) {
+			((StateInfo) get(top)).position = pos;
+		}
+	}
+
+	/**
+	 * The predefined OSGi format that is used when parsing OSGi
+	 * versions.
+	 */
+	public static final VersionFormat OSGI_FORMAT;
+
+	/**
+	 * The predefined OSGi format that is used when parsing raw
+	 * versions.
+	 */
+	public static final VersionFormat RAW_FORMAT;
+
+	private static final Map formatCache = Collections.synchronizedMap(new HashMap());
+
+	private static final String OSGI_FORMAT_STRING = "n[.n=0;[.n=0;[.S=[A-Za-z0-9_-];]]]"; //$NON-NLS-1$
+
+	private static final String RAW_FORMAT_STRING = "r(.r)*p?"; //$NON-NLS-1$
+
+	static {
+		try {
+			VersionFormatParser parser = new VersionFormatParser();
+			OSGI_FORMAT = new VersionFormat(parser.compile(OSGI_FORMAT_STRING, 0, OSGI_FORMAT_STRING.length()));
+			formatCache.put(OSGI_FORMAT_STRING, OSGI_FORMAT);
+			RAW_FORMAT = new RawFormat(parser.compile(RAW_FORMAT_STRING, 0, RAW_FORMAT_STRING.length()));
+			formatCache.put(RAW_FORMAT_STRING, RAW_FORMAT);
+		} catch (FormatException e) {
+			// If this happens, something is wrong with the actual
+			// implementation of the FormatCompiler.
+			//
+			throw new ExceptionInInitializerError(e);
+		}
+	}
+
+	/**
+	 * Compile a version format string into a compiled format. This method is
+	 * shorthand for:<pre>CompiledFormat.compile(format, 0, format.length())</pre>.
+	 *
+	 * @param format The format to compile.
+	 * @return The compiled format
+	 * @throws FormatException If the format could not be compiled
+	 */
+	public static VersionFormat compile(String format) throws FormatException {
+		return compile(format, 0, format.length());
+	}
+
+	/**
+	 * Compile a version format string into a compiled format. The parsing starts
+	 * at position start and ends at position end. The returned format is cached so
+	 * subsequent calls to this method using the same format string will yield the
+	 * same compiled format instance.
+	 *
+	 * @param format The format string to compile.
+	 * @param start Start position in the format string
+	 * @param end End position in the format string
+	 * @return The compiled format
+	 * @throws FormatException If the format could not be compiled
+	 */
+	public static VersionFormat compile(String format, int start, int end) throws FormatException {
+		String fmtString = format.substring(start, end).intern();
+		synchronized (fmtString) {
+			VersionFormat fmt = (VersionFormat) formatCache.get(fmtString);
+			if (fmt == null) {
+				VersionFormatParser parser = new VersionFormatParser();
+				fmt = new VersionFormat(parser.compile(format, start, end));
+				formatCache.put(fmtString, fmt);
+			}
+			return fmt;
+		}
+	}
+
+	/**
+	 * Parse a version string using the {@link #RAW_FORMAT} parser.
+	 *
+	 * @param version The version to parse.
+	 * @param originalFormat The original format to assign to the created version. Can be <code>null</code>.
+	 * @param original The original version string to assign to the created version. Can be <code>null</code>.
+	 * @return A created version
+	 * @throws IllegalArgumentException If the version string could not be parsed.
+	 */
+	public static Version parseRaw(String version, VersionFormat originalFormat, String original) {
+		Comparable[] padReturn = new Comparable[1];
+		Comparable[] vector = RAW_FORMAT.parse(version, 0, version.length(), padReturn);
+		return new Version(vector, padReturn[0], originalFormat, original);
+	}
+
+	static void appendCharacterRange(StringBuffer sb, char[] range, boolean inverted) {
+		sb.append('=');
+		sb.append('[');
+		if (inverted)
+			sb.append('^');
+		int top = range.length;
+		for (int idx = 0; idx < top; ++idx) {
+			char b = range[idx];
+			if (b == '\\' || b == ']' || (b == '-' && idx + 1 < top))
+				sb.append('\\');
+
+			sb.append(b);
+			int ndx = idx + 1;
+			if (ndx + 2 < top) {
+				char c = b;
+				for (; ndx < top; ++ndx) {
+					char n = range[ndx];
+					if (c + 1 != n)
+						break;
+					c = n;
+				}
+				if (ndx <= idx + 3)
+					continue;
+
+				sb.append('-');
+				if (c == '\\' || c == ']' || (c == '-' && idx + 1 < top))
+					sb.append('\\');
+				sb.append(c);
+				idx = ndx - 1;
+			}
+		}
+		sb.append(']');
+	}
+
+	static Fragment createAutoFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+		return new AutoFragment(instr, qualifier);
+	}
+
+	static Fragment createDelimiterFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+		return new DelimiterFragment(instr, qualifier);
+	}
+
+	static Fragment createGroupFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, Fragment[] fragments, boolean array) {
+		return new GroupFragment(instr, qualifier, fragments, array);
+	}
+
+	static Fragment createLiteralFragment(Qualifier qualifier, String literal) {
+		return new LiteralFragment(qualifier, literal);
+	}
+
+	static Fragment createNumberFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, boolean signed) {
+		return new NumberFragment(instr, qualifier, signed);
+	}
+
+	static Fragment createPadFragment(Qualifier qualifier) {
+		return new PadFragment(qualifier);
+	}
+
+	static Fragment createQuotedFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+		return new QuotedFragment(instr, qualifier);
+	}
+
+	static Fragment createRawFragment(VersionFormatParser.Instructions instr, Qualifier qualifier) {
+		return new RawFragment(instr, qualifier);
+	}
+
+	static Fragment createStringFragment(VersionFormatParser.Instructions instr, Qualifier qualifier, boolean unbound) {
+		return new StringFragment(instr, qualifier, unbound);
+	}
+
+	static void toStringEscaped(StringBuffer sb, String value, String escapes) {
+		for (int idx = 0; idx < value.length(); ++idx) {
+			char c = value.charAt(idx);
+			if (c == '\\' || escapes.indexOf(c) >= 0)
+				sb.append('\\');
+			sb.append(c);
+		}
+	}
+
+	private final Fragment topFragment;
+
+	private String fmtString;
+
+	VersionFormat(Fragment topFragment) {
+		this.topFragment = topFragment;
+	}
+
+	public boolean equals(Object o) {
+		return this == o || o instanceof VersionFormat && toString().equals(o.toString());
+	}
+
+	public int hashCode() {
+		return 11 * toString().hashCode();
+	}
+
+	/**
+	 * Parse the given version string.
+	 * @param version The version string to parse.
+	 * @return A created version.
+	 * @throws IllegalArgumentException If the version string could not be parsed.
+	 */
+	public Version parse(String version) {
+		return parse(version, 0, version.length());
+	}
+
+	/**
+	 * Parse the given version string.
+	 * @param version The version string to parse.
+	 * @param start Start position in the version string
+	 * @param end End position in the version string
+	 * @return A created version.
+	 * @throws IllegalArgumentException If the version string could not be parsed.
+	 */
+	public Version parse(String version, int start, int maxPos) {
+		Comparable[] padReturn = new Comparable[1];
+		Comparable[] vector = parse(version, start, maxPos, padReturn);
+		return new Version(vector, padReturn[0], this, version.substring(start, maxPos));
+	}
+
+	/**
+	 * Returns the string representation of this compiled format
+	 */
+	public synchronized String toString() {
+		if (fmtString == null) {
+			StringBuffer sb = new StringBuffer();
+			toString(sb);
+		}
+		return fmtString;
+	}
+
+	/**
+	 * Appends the string representation of this compiled format to
+	 * the given StringBuffer.
+	 * @param sb The buffer that will receive the string representation
+	 * @param rangeSafe if true, all range sensitive characters will be escaped with backslash.
+	 */
+	public synchronized void toString(StringBuffer sb) {
+		if (fmtString != null)
+			sb.append(fmtString);
+		else {
+			int start = sb.length();
+			sb.append("format"); //$NON-NLS-1$
+			topFragment.toString(sb);
+			fmtString = sb.substring(start);
+		}
+	}
+
+	TreeInfo createInfo(int start) {
+		return new TreeInfo(topFragment, start);
+	}
+
+	Comparable[] parse(String version, int start, int maxPos, Comparable[] padReturn) {
+		ArrayList entries = new ArrayList();
+		if (start == maxPos)
+			throw new IllegalArgumentException(NLS.bind(Messages.format_0_unable_to_parse_empty_version, this, version.substring(start, maxPos)));
+		TreeInfo info = new TreeInfo(topFragment, start);
+		if (!(topFragment.parse(entries, version, maxPos, info) && info.getPosition() == maxPos))
+			throw new IllegalArgumentException(NLS.bind(Messages.format_0_unable_to_parse_1, this, version.substring(start, maxPos)));
+		Comparable pad = info.getPadValue();
+		VersionParser.removeRedundantTrail(entries, pad);
+		padReturn[0] = pad;
+		return (Comparable[]) entries.toArray(new Comparable[entries.size()]);
+	}
+
+	// Preserve cache during deserialization
+	private Object readResolve() {
+		synchronized (formatCache) {
+			String string = toString();
+			VersionFormat fmt = (VersionFormat) formatCache.put(string, this);
+			if (fmt == null)
+				fmt = this;
+			else
+				// Put old format back
+				formatCache.put(string, fmt);
+			return fmt;
+		}
+	}
+}
+
+class RawFormat extends VersionFormat {
+	private static final long serialVersionUID = 8851695938450999819L;
+
+	RawFormat(Fragment topFragment) {
+		super(topFragment);
+	}
+
+	/**
+	 * Parse but do not assign this format as the Version format nor the version
+	 * string as the original.
+	 */
+	public Version parse(String version, int start, int maxPos) {
+		Comparable[] padReturn = new Comparable[1];
+		Comparable[] vector = parse(version, start, maxPos, padReturn);
+		return new Version(vector, padReturn[0], null, null);
+	}
+
+	// Preserve singleton when deserialized
+	private Object readResolve() {
+		return RAW_FORMAT;
+	}
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionFormatParser.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionFormatParser.java
new file mode 100644
index 0000000..4a31345
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionFormatParser.java
@@ -0,0 +1,528 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core;
+
+import java.util.ArrayList;
+import java.util.List;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * This is the Omni Version Format parser. It will parse a version format in string form
+ * into a group of {@link VersionFormat.Fragment} elements. That group, wrapped in a
+ * {@link VersionFormat}, becomes the parser for versions corresponding to the format.
+ *
+ * The class is not intended to included in a public API. Instead VersionFormats should
+ * be created using {@link VersionFormat#parse(String)}
+ *
+ */
+class VersionFormatParser {
+
+	static class Instructions {
+		char[] characters = null;
+		Comparable defaultValue = null;
+		boolean ignore = false;
+		boolean inverted = false;
+		Comparable padValue = null;
+		int rangeMax = Integer.MAX_VALUE;
+		int rangeMin = 0;
+	}
+
+	static final VersionFormat.Qualifier EXACT_ONE_QUALIFIER = new VersionFormat.Qualifier(1, 1);
+
+	static final VersionFormat.Qualifier ONE_OR_MANY_QUALIFIER = new VersionFormat.Qualifier(1, Integer.MAX_VALUE);
+
+	static final VersionFormat.Qualifier ZERO_OR_MANY_QUALIFIER = new VersionFormat.Qualifier(0, Integer.MAX_VALUE);
+
+	static final VersionFormat.Qualifier ZERO_OR_ONE_QUALIFIER = new VersionFormat.Qualifier(0, 1);
+
+	private int current;
+
+	private List currentList;
+
+	private int eos;
+
+	private String format;
+
+	private int start;
+
+	VersionFormat.Fragment compile(String fmt, int pos, int maxPos) throws FormatException {
+		format = fmt;
+		if (start >= maxPos)
+			throw new FormatException(Messages.format_is_empty);
+
+		start = pos;
+		current = pos;
+		eos = maxPos;
+		currentList = new ArrayList();
+		while (current < eos)
+			parseFragment();
+
+		VersionFormat.Fragment topFrag;
+		switch (currentList.size()) {
+			case 0 :
+				throw new FormatException(Messages.format_is_empty);
+			case 1 :
+				VersionFormat.Fragment frag = (VersionFormat.Fragment) currentList.get(0);
+				if (frag.isGroup()) {
+					topFrag = frag;
+					break;
+				}
+				// Fall through to default
+			default :
+				topFrag = VersionFormat.createGroupFragment(null, EXACT_ONE_QUALIFIER, (VersionFormat.Fragment[]) currentList.toArray(new VersionFormat.Fragment[currentList.size()]), false);
+		}
+		currentList = null;
+		return topFrag;
+	}
+
+	private void assertChar(char expected) throws FormatException {
+		if (current >= eos)
+			throw formatException(NLS.bind(Messages.premature_end_of_format_expected_0, new String(new char[] {expected})));
+
+		char c = format.charAt(current);
+		if (c != expected)
+			throw formatException(c, new String(new char[] {expected}));
+		++current;
+	}
+
+	private FormatException formatException(char found, String expected) {
+		return formatException(new String(new char[] {found}), expected);
+	}
+
+	private FormatException formatException(String message) {
+		return new FormatException(NLS.bind(Messages.syntax_error_in_version_format_0_1_2, new Object[] {format.substring(start, eos), new Integer(current), message}));
+	}
+
+	private FormatException formatException(String found, String expected) {
+		return new FormatException(NLS.bind(Messages.syntax_error_in_version_format_0_1_found_2_expected_3, new Object[] {format.substring(start, eos), new Integer(current), found, expected}));
+	}
+
+	private FormatException illegalControlCharacter(char c) {
+		return formatException(NLS.bind(Messages.illegal_character_encountered_ascii_0, Version.valueOf(c)));
+	}
+
+	private String parseAndConsiderEscapeUntil(char endChar) throws FormatException {
+		StringBuffer sb = new StringBuffer();
+		while (current < eos) {
+			char c = format.charAt(current++);
+			if (c == endChar)
+				break;
+
+			if (c < 32)
+				throw illegalControlCharacter(c);
+
+			if (c == '\\') {
+				if (current == eos)
+					throw formatException(Messages.EOS_after_escape);
+				c = format.charAt(current++);
+				if (c < 32)
+					throw illegalControlCharacter(c);
+			}
+			sb.append(c);
+		}
+		return sb.toString();
+	}
+
+	private void parseAuto() throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.padValue != null)
+				throw formatException(Messages.auto_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createAutoFragment(ep, parseQualifier()));
+	}
+
+	private void parseBracketGroup() throws FormatException {
+		List saveList = currentList;
+		currentList = new ArrayList();
+		while (current < eos && format.charAt(current) != ']')
+			parseFragment();
+
+		if (current == eos)
+			throw formatException(NLS.bind(Messages.premature_end_of_format_expected_0, "]")); //$NON-NLS-1$
+
+		++current;
+		VersionFormatParser.Instructions ep = parseProcessing();
+		saveList.add(VersionFormat.createGroupFragment(ep, ZERO_OR_ONE_QUALIFIER, (VersionFormat.Fragment[]) currentList.toArray(new VersionFormat.Fragment[currentList.size()]), false));
+		currentList = saveList;
+	}
+
+	private void parseCharacterGroup(VersionFormatParser.Instructions ep) throws FormatException {
+		assertChar('[');
+
+		StringBuffer sb = new StringBuffer();
+		outer: for (; current < eos; ++current) {
+			char c = format.charAt(current);
+			switch (c) {
+				case '\\' :
+					if (current + 1 < eos) {
+						sb.append(format.charAt(++current));
+						continue;
+					}
+					throw formatException(Messages.premature_end_of_format);
+				case '^' :
+					if (sb.length() == 0)
+						ep.inverted = true;
+					else
+						sb.append(c);
+					continue;
+				case ']' :
+					break outer;
+				case '-' :
+					if (sb.length() > 0 && current + 1 < eos) {
+						char rangeEnd = format.charAt(++current);
+						if (rangeEnd == ']') {
+							// Use dash verbatim when last in range
+							sb.append(c);
+							break outer;
+						}
+
+						char rangeStart = sb.charAt(sb.length() - 1);
+						if (rangeEnd < rangeStart)
+							throw formatException(Messages.negative_character_range);
+						while (++rangeStart <= rangeEnd)
+							sb.append(rangeStart);
+						continue;
+					}
+					// Fall through to default
+				default :
+					if (c < 32)
+						throw illegalControlCharacter(c);
+					sb.append(c);
+			}
+		}
+		assertChar(']');
+		int top = sb.length();
+		char[] chars = new char[top];
+		sb.getChars(0, top, chars, 0);
+		ep.characters = chars;
+	}
+
+	private void parseDelimiter() throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.rangeMin != 0 || ep.rangeMax != Integer.MAX_VALUE)
+				throw formatException(Messages.delimiter_can_not_have_range);
+			if (ep.ignore)
+				throw formatException(Messages.delimiter_can_not_be_ignored);
+			if (ep.defaultValue != null)
+				throw formatException(Messages.delimiter_can_not_have_default_value);
+			if (ep.padValue != null)
+				throw formatException(Messages.delimiter_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createDelimiterFragment(ep, parseQualifier()));
+	}
+
+	private void parseFragment() throws FormatException {
+		if (current == eos)
+			throw formatException(Messages.premature_end_of_format);
+		char c = format.charAt(current++);
+		switch (c) {
+			case '(' :
+				parseGroup(false);
+				break;
+			case '<' :
+				parseGroup(true);
+				break;
+			case '[' :
+				parseBracketGroup();
+				break;
+			case 'a' :
+				parseAuto();
+				break;
+			case 'r' :
+				parseRaw();
+				break;
+			case 'n' :
+				parseNumber(false);
+				break;
+			case 'N' :
+				parseNumber(true);
+				break;
+			case 's' :
+				parseString(false);
+				break;
+			case 'S' :
+				parseString(true);
+				break;
+			case 'd' :
+				parseDelimiter();
+				break;
+			case 'q' :
+				parseQuotedString();
+				break;
+			case 'p' :
+				parsePad();
+				break;
+			default :
+				parseLiteral(c);
+		}
+	}
+
+	private void parseGroup(boolean array) throws FormatException {
+		List saveList = currentList;
+		currentList = new ArrayList();
+		char expectedEnd = array ? '>' : ')';
+		while (current < eos && format.charAt(current) != expectedEnd)
+			parseFragment();
+		assertChar(expectedEnd);
+
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.characters != null)
+				throw formatException(Messages.array_can_not_have_character_group);
+			if (ep.rangeMax != Integer.MAX_VALUE && ep.padValue != null) {
+				throw formatException(Messages.cannot_combine_range_upper_bound_with_pad_value);
+			}
+		}
+
+		if (currentList.isEmpty())
+			throw formatException(array ? Messages.array_can_not_be_empty : Messages.group_can_not_be_empty);
+		saveList.add(VersionFormat.createGroupFragment(ep, parseQualifier(), (VersionFormat.Fragment[]) currentList.toArray(new VersionFormat.Fragment[currentList.size()]), array));
+		currentList = saveList;
+	}
+
+	private int parseIntegerLiteral() throws FormatException {
+		if (current == eos)
+			throw formatException(NLS.bind(Messages.premature_end_of_format_expected_0, "<integer>")); //$NON-NLS-1$
+
+		char c = format.charAt(current);
+		if (!VersionParser.isDigit(c))
+			throw formatException(c, "<integer>"); //$NON-NLS-1$
+
+		int value = c - '0';
+		while (++current < eos) {
+			c = format.charAt(current);
+			if (!VersionParser.isDigit(c))
+				break;
+			value *= 10;
+			value += (c - '0');
+		}
+		return value;
+	}
+
+	private void parseLiteral(char c) throws FormatException {
+		String value;
+		switch (c) {
+			case '\'' :
+				value = parseAndConsiderEscapeUntil(c);
+				break;
+			case ')' :
+			case ']' :
+			case '{' :
+			case '}' :
+			case '?' :
+			case '*' :
+				throw formatException(c, "<literal>"); //$NON-NLS-1$
+			default :
+				if (VersionParser.isLetterOrDigit(c))
+					throw formatException(c, "<literal>"); //$NON-NLS-1$
+
+				if (c < 32)
+					throw illegalControlCharacter(c);
+
+				if (c == '\\') {
+					if (current == eos)
+						throw formatException(Messages.EOS_after_escape);
+					c = format.charAt(current++);
+					if (c < 32)
+						throw illegalControlCharacter(c);
+				}
+				value = new String(new char[] {c});
+		}
+		currentList.add(VersionFormat.createLiteralFragment(parseQualifier(), value));
+	}
+
+	private int[] parseMinMax() throws FormatException {
+
+		int max = Integer.MAX_VALUE;
+		++current;
+		int min = parseIntegerLiteral();
+		char c = format.charAt(current);
+		if (c == '}') {
+			max = min;
+			if (max == 0)
+				throw formatException(Messages.range_max_cannot_be_zero);
+			++current;
+		} else if (c == ',' && current + 1 < eos) {
+			if (format.charAt(++current) != '}') {
+				max = parseIntegerLiteral();
+				if (max == 0)
+					throw formatException(Messages.range_max_cannot_be_zero);
+				if (max < min)
+					throw formatException(Messages.range_max_cannot_be_less_then_range_min);
+			}
+			assertChar('}');
+		} else
+			throw formatException(c, "},"); //$NON-NLS-1$
+		return new int[] {min, max};
+	}
+
+	private void parseNumber(boolean signed) throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.padValue != null)
+				throw formatException(Messages.number_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createNumberFragment(ep, parseQualifier(), signed));
+	}
+
+	private void parsePad() throws FormatException {
+		currentList.add(VersionFormat.createPadFragment(parseQualifier()));
+	}
+
+	private VersionFormatParser.Instructions parseProcessing() throws FormatException {
+		if (current >= eos)
+			return null;
+
+		char c = format.charAt(current);
+		if (c != '=')
+			return null;
+
+		VersionFormatParser.Instructions ep = new VersionFormatParser.Instructions();
+		do {
+			current++;
+			parseProcessingInstruction(ep);
+		} while (current < eos && format.charAt(current) == '=');
+		return ep;
+	}
+
+	private void parseProcessingInstruction(VersionFormatParser.Instructions processing) throws FormatException {
+		if (current == eos)
+			throw formatException(Messages.premature_end_of_format);
+
+		char c = format.charAt(current);
+		if (c == 'p') {
+			// =pad(<raw-element>);
+			//
+			if (processing.padValue != null)
+				throw formatException(Messages.pad_defined_more_then_once);
+			if (processing.ignore)
+				throw formatException(Messages.cannot_combine_ignore_with_other_instruction);
+			++current;
+			processing.padValue = parseRawElement();
+		} else if (c == '!') {
+			// =ignore;
+			//
+			if (processing.ignore)
+				throw formatException(Messages.ignore_defined_more_then_once);
+			if (processing.padValue != null || processing.characters != null || processing.rangeMin != 0 || processing.rangeMax != Integer.MAX_VALUE || processing.defaultValue != null)
+				throw formatException(Messages.cannot_combine_ignore_with_other_instruction);
+			++current;
+			processing.ignore = true;
+		} else if (c == '[') {
+			// =[<character group];
+			//
+			if (processing.characters != null)
+				throw formatException(Messages.character_group_defined_more_then_once);
+			if (processing.ignore)
+				throw formatException(Messages.cannot_combine_ignore_with_other_instruction);
+			parseCharacterGroup(processing);
+		} else if (c == '{') {
+			// ={min,max};
+			//
+			if (processing.rangeMin != 0 || processing.rangeMax != Integer.MAX_VALUE)
+				throw formatException(Messages.range_defined_more_then_once);
+			if (processing.ignore)
+				throw formatException(Messages.cannot_combine_ignore_with_other_instruction);
+			int[] minMax = parseMinMax();
+			processing.rangeMin = minMax[0];
+			processing.rangeMax = minMax[1];
+		} else {
+			// =<raw-element>;
+			if (processing.defaultValue != null)
+				throw formatException(Messages.default_defined_more_then_once);
+			if (processing.ignore)
+				throw formatException(Messages.cannot_combine_ignore_with_other_instruction);
+			processing.defaultValue = parseRawElement();
+		}
+		assertChar(';');
+	}
+
+	private VersionFormat.Qualifier parseQualifier() throws FormatException {
+		if (current >= eos)
+			return EXACT_ONE_QUALIFIER;
+
+		char c = format.charAt(current);
+		if (c == '?') {
+			++current;
+			return ZERO_OR_ONE_QUALIFIER;
+		}
+
+		if (c == '*') {
+			++current;
+			return ZERO_OR_MANY_QUALIFIER;
+		}
+
+		if (c == '+') {
+			++current;
+			return ONE_OR_MANY_QUALIFIER;
+		}
+
+		if (c != '{')
+			return EXACT_ONE_QUALIFIER;
+
+		int[] minMax = parseMinMax();
+		int min = minMax[0];
+		int max = minMax[1];
+
+		// Use singletons for commonly used ranges
+		//
+		if (min == 0) {
+			if (max == 1)
+				return ZERO_OR_ONE_QUALIFIER;
+			if (max == Integer.MAX_VALUE)
+				return ZERO_OR_MANY_QUALIFIER;
+		} else if (min == 1) {
+			if (max == 1)
+				return EXACT_ONE_QUALIFIER;
+			if (max == Integer.MAX_VALUE)
+				return ONE_OR_MANY_QUALIFIER;
+		}
+		return new VersionFormat.Qualifier(min, max);
+	}
+
+	private void parseQuotedString() throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.padValue != null)
+				throw formatException(Messages.string_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createQuotedFragment(ep, parseQualifier()));
+	}
+
+	private void parseRaw() throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.padValue != null)
+				throw formatException(Messages.raw_element_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createRawFragment(ep, parseQualifier()));
+	}
+
+	private Comparable parseRawElement() throws FormatException {
+		int[] position = new int[] {current};
+		Comparable v = VersionParser.parseRawElement(format, position, eos);
+		if (v == null)
+			throw new FormatException(NLS.bind(Messages.raw_element_expected_0, format));
+		current = position[0];
+		return v;
+	}
+
+	private void parseString(boolean unlimited) throws FormatException {
+		VersionFormatParser.Instructions ep = parseProcessing();
+		if (ep != null) {
+			if (ep.padValue != null)
+				throw formatException(Messages.string_can_not_have_pad_value);
+		}
+		currentList.add(VersionFormat.createStringFragment(ep, parseQualifier(), unlimited));
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionParser.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionParser.java
new file mode 100644
index 0000000..98560bf
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionParser.java
@@ -0,0 +1,364 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core;
+
+import java.util.ArrayList;
+import java.util.List;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * The Omni Version parser. Not intended for public API. Instead use
+ * {@link Version#Version(String)} or {@link Version#parseVersion(String)}.
+ *
+ * The class also contains some general purpose parser support methods
+ *
+ * @noextend This class is not intended to be subclassed by clients.
+ */
+abstract class VersionParser {
+	static void removeRedundantTrail(List segments, Comparable padValue) {
+		Comparable redundantTrail = padValue == null ? VersionVector.MIN_VALUE : padValue;
+		int idx = segments.size();
+		while (--idx >= 0 && segments.get(idx).equals(redundantTrail))
+			segments.remove(idx);
+	}
+
+	static final String RAW_PREFIX = "raw:"; //$NON-NLS-1$
+
+	private VersionParser() {
+		// Prevent class from being instantiated
+	}
+
+	/**
+	 * Parse the <code>version</code> string and assing the parsed portions to the <code>receiver</code>.
+	 * This method is called from the version string constructor.
+	 *
+	 * @param version The string to be parsed
+	 * @param start Start position in the <code>version</code> string
+	 * @param maxPos End position in the <code>version</code> string
+	 * @param receiver The version to be filled in
+	 * @returns <code>true</code> if a version indeed was parsed or <code>false</code> if the string
+	 * contained only whitespace.
+	 * @throws IllegalArgumentException if the version is malformed
+	 */
+	static boolean parseInto(String version, int start, int maxPos, Version receiver) throws IllegalArgumentException {
+		// trim leading and trailing whitespace
+		int pos = skipWhite(version, start);
+		maxPos = skipTrailingWhite(version, start, maxPos);
+		if (pos == maxPos)
+			return false;
+
+		Comparable[] padReturn = new Comparable[1];
+		Comparable[] vector = null;
+		Comparable pad = null;
+		VersionFormat fmt = null;
+		char c = version.charAt(pos);
+		if (isDigit(c)) {
+			fmt = VersionFormat.OSGI_FORMAT;
+			vector = fmt.parse(version, pos, maxPos, padReturn);
+			receiver.init(vector, padReturn[0], fmt, version);
+			return true;
+		}
+
+		if (!isLetter(c))
+			throw new IllegalArgumentException();
+
+		if (version.startsWith(RAW_PREFIX, pos)) {
+			VersionFormat rawFmt = VersionFormat.RAW_FORMAT;
+			pos += 4;
+
+			// Find ending '/' that is neither quoted or escaped
+			int end = maxPos;
+			for (int idx = pos; idx < maxPos; ++idx) {
+				c = version.charAt(idx);
+				switch (c) {
+					case '/' :
+						end = idx;
+						break;
+					case '\\' :
+						++idx;
+						continue;
+					case '\'' :
+					case '"' :
+						for (++idx; idx < maxPos; ++idx) {
+							char e = version.charAt(idx);
+							if (e == c) {
+								break;
+							}
+							if (e == '\\')
+								++idx;
+						}
+						// fall through to default
+					default :
+						continue;
+				}
+				break;
+			}
+
+			vector = rawFmt.parse(version, pos, end, padReturn);
+			pad = padReturn[0];
+			pos = end;
+			if (pos == maxPos) {
+				// This was a pure raw version
+				//
+				receiver.init(vector, pad, null, null);
+				return true;
+			}
+
+			if (version.charAt(pos) != '/')
+				throw new IllegalArgumentException(NLS.bind(Messages.expected_slash_after_raw_vector_0, version.substring(start, maxPos)));
+			++pos;
+
+			if (pos == maxPos)
+				throw new IllegalArgumentException(NLS.bind(Messages.expected_orignal_after_slash_0, version.substring(start, maxPos)));
+		}
+
+		if (version.startsWith("format(", pos)) { //$NON-NLS-1$
+			// Parse the format
+			//
+			pos += 7;
+			try {
+				// Find matching ')' that is neither quoted or escaped
+				//
+				int end = findEndOfFormat(version, pos, maxPos);
+				fmt = VersionFormat.compile(version, pos, end);
+				pos = end + 1;
+			} catch (FormatException e) {
+				throw new IllegalArgumentException(e.getMessage());
+			}
+			if (pos == maxPos) {
+				// This was a raw version with format but no original
+				//
+				if (vector == null)
+					throw new IllegalArgumentException(NLS.bind(Messages.only_format_specified_0, version.substring(start, maxPos)));
+				receiver.init(vector, pad, fmt, null);
+				return true;
+			}
+		}
+
+		if (fmt == null && vector == null)
+			throw new IllegalArgumentException(NLS.bind(Messages.neither_raw_vector_nor_format_specified_0, version.substring(start, maxPos)));
+
+		if (version.charAt(pos) != ':')
+			throw new IllegalArgumentException(NLS.bind(Messages.colon_expected_before_original_version_0, version.substring(start, maxPos)));
+
+		pos++;
+		if (pos == maxPos)
+			throw new IllegalArgumentException(NLS.bind(Messages.expected_orignal_after_colon_0, version.substring(start, maxPos)));
+
+		if (vector == null) {
+			// Vector and pad must be created by parsing the original
+			//
+			vector = fmt.parse(version, pos, maxPos, padReturn);
+			pad = padReturn[0];
+		}
+		receiver.init(vector, pad, fmt, version.substring(pos));
+		return true;
+	}
+
+	static boolean isDigit(char c) {
+		return c >= '0' && c <= '9';
+	}
+
+	static boolean isLetter(char c) {
+		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
+	}
+
+	static boolean isLetterOrDigit(char c) {
+		return isDigit(c) || isLetter(c);
+	}
+
+	static int findEndOfFormat(String string, int pos, int maxPos) {
+		int end = -1;
+		int depth = 1;
+		for (int idx = pos; idx < maxPos; ++idx) {
+			char c = string.charAt(idx);
+			switch (c) {
+				case ')' :
+					if (--depth == 0) {
+						end = idx;
+						break;
+					}
+					continue;
+				case '(' :
+					++depth;
+					continue;
+				case '\\' :
+					++idx;
+					continue;
+				case '\'' :
+				case '"' :
+					for (++idx; idx < maxPos; ++idx) {
+						char e = string.charAt(idx);
+						if (e == c) {
+							break;
+						}
+						if (e == '\\')
+							++idx;
+					}
+					// fall through to default
+				default :
+					continue;
+			}
+			break;
+		}
+		if (depth != 0)
+			throw new IllegalArgumentException(NLS.bind(Messages.unbalanced_format_parenthesis, string.substring(pos - 1, maxPos)));
+		return end;
+	}
+
+	static Comparable parseRawElement(String value, int[] position, int maxPos) {
+		int current = position[0];
+		if (current >= maxPos)
+			return null;
+
+		boolean negate = false;
+		char c = value.charAt(current);
+		Comparable v;
+		switch (c) {
+			case '\'' :
+			case '"' : {
+				StringBuffer sb = new StringBuffer();
+				for (;;) {
+					char q = c;
+					if (++current == maxPos)
+						return null;
+					c = value.charAt(current);
+					while (c != q) {
+						if (c < 32)
+							return null;
+						sb.append(c);
+						if (++current == maxPos)
+							return null;
+						c = value.charAt(current);
+					}
+					if (++current == maxPos)
+						break;
+					c = value.charAt(current);
+					if (c != '\'' && c != '"')
+						break;
+				}
+				v = sb.toString();
+				break;
+			}
+			case '<' : {
+				if (++current == maxPos)
+					return null;
+
+				position[0] = current;
+				v = parseRawVector(value, position, maxPos);
+				if (v == null)
+					return null;
+				current = position[0];
+				break;
+			}
+			case 'm' :
+				v = VersionVector.MAXS_VALUE;
+				++current;
+				break;
+			case 'M' :
+				v = VersionVector.MAX_VALUE;
+				++current;
+				break;
+			case '-' :
+				if (++current >= maxPos)
+					return null;
+
+				c = value.charAt(current);
+				if (c == 'M') {
+					++current;
+					v = VersionVector.MIN_VALUE;
+					break;
+				}
+				negate = true;
+				// Fall through to default
+			default : {
+				if (isDigit(c)) {
+					int start = current++;
+					while (current < maxPos && isDigit(value.charAt(current)))
+						++current;
+					int val = Integer.parseInt(value.substring(start, current));
+					if (negate)
+						val = -val;
+					v = Version.valueOf(val);
+					break;
+				}
+				return null;
+			}
+		}
+		position[0] = current;
+		return v;
+	}
+
+	private static Comparable parseRawVector(String value, int[] position, int maxPos) {
+		int pos = position[0];
+		if (pos >= maxPos)
+			return null;
+
+		char c = value.charAt(pos);
+		if (c == '>')
+			return null;
+
+		ArrayList rawList = new ArrayList();
+		boolean padMarkerSeen = (c == 'p');
+		if (padMarkerSeen) {
+			if (++pos >= maxPos)
+				return null;
+			position[0] = pos;
+		}
+
+		Comparable pad = null;
+		for (;;) {
+			Comparable elem = parseRawElement(value, position, maxPos);
+			if (elem == null)
+				return null;
+
+			if (padMarkerSeen)
+				pad = elem;
+			else
+				rawList.add(elem);
+
+			pos = position[0];
+			if (pos >= maxPos)
+				return null;
+
+			c = value.charAt(pos);
+			position[0] = ++pos;
+			if (c == '>')
+				break;
+
+			if (padMarkerSeen || pos >= maxPos)
+				return null;
+
+			if (c == 'p') {
+				padMarkerSeen = true;
+				continue;
+			}
+
+			if (c != '.')
+				return null;
+		}
+		removeRedundantTrail(rawList, pad);
+		return new VersionVector((Comparable[]) rawList.toArray(new Comparable[rawList.size()]), pad);
+	}
+
+	static int skipWhite(String string, int pos) {
+		int top = string.length();
+		while (pos < top && string.charAt(pos) <= ' ')
+			++pos;
+		return pos;
+	}
+
+	static int skipTrailingWhite(String string, int start, int end) {
+		while (end > start && string.charAt(end - 1) <= ' ')
+			--end;
+		return end;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionRange.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionRange.java
index 769ec07..a8bb10e 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionRange.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionRange.java
@@ -1 +1 @@
-/******************************************************************************* * Copyright (c) 2003, 2008 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *  * Contributors: *     IBM Corporation - initial API and implementation *******************************************************************************/package org.eclipse.equinox.internal.provisional.p2.core;/** * This class represents a version range. * @since 3.1 * @noextend This class is not intended to be subclassed by clients. */public class VersionRange {	private static final Version versionMax = new Version(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);	/**	 * An empty version	 */	public static final VersionRange emptyRange = new VersionRange(null);	private final Version minVersion;	private final boolean includeMin;	private final Version maxVersion;	private final boolean includeMax;	/**	 * Constructs a VersionRange with the specified minVersion and maxVersion.	 * @param minVersion the minimum version of the range	 * @param maxVersion the maximum version of the range	 */	public VersionRange(Version minVersion, boolean includeMin, Version maxVersion, boolean includeMax) {		this.minVersion = minVersion;		this.includeMin = includeMin;		this.maxVersion = maxVersion;		this.includeMax = includeMax;	}	/**	 * Constructs a VersionRange from the given versionRange String.	 * @param versionRange a version range String that specifies a range of	 * versions.	 */	public VersionRange(String versionRange) {		if (versionRange == null || versionRange.length() == 0) {			minVersion = Version.emptyVersion;			includeMin = true;			maxVersion = VersionRange.versionMax;			includeMax = true;			return;		}		versionRange = versionRange.trim();		if (versionRange.charAt(0) == '[' || versionRange.charAt(0) == '(') {			int comma = versionRange.indexOf(',');			if (comma < 0)				throw new IllegalArgumentException();			char last = versionRange.charAt(versionRange.length() - 1);			if (last != ']' && last != ')')				throw new IllegalArgumentException();			minVersion = Version.parseVersion(versionRange.substring(1, comma).trim());			includeMin = versionRange.charAt(0) == '[';			maxVersion = Version.parseVersion(versionRange.substring(comma + 1, versionRange.length() - 1).trim());			includeMax = last == ']';		} else {			minVersion = Version.parseVersion(versionRange.trim());			includeMin = true;			maxVersion = VersionRange.versionMax;			includeMax = true;		}	}	/**	 * Returns the minimum Version of this VersionRange	 * @return the minimum Version of this VersionRange	 */	public Version getMinimum() {		return minVersion;	}	/**	 * Indicates if the minimum version is included in the version range.	 * @return true if the minimum version is included in the version range;	 * otherwise false is returned	 */	public boolean getIncludeMinimum() {		return includeMin;	}	/**	 * Returns the maximum Version of this VersionRange	 * @return the maximum Version of this VersionRange	 */	public Version getMaximum() {		return maxVersion;	}	/**	 * Indicates if the maximum version is included in the version range.	 * @return true if the maximum version is included in the version range;	 * otherwise false is returned	 */	public boolean getIncludeMaximum() {		return includeMax;	}	/**	 * Returns whether the given version is included in this VersionRange.	 * This will depend on the minimum and maximum versions of this VersionRange	 * and the given version.	 * 	 * @param version a version to be tested for inclusion in this VersionRange. 	 * (may be <code>null</code>)	 * @return <code>true</code> if the version is include, 	 * <code>false</code> otherwise 	 */	public boolean isIncluded(Version version) {		Version minRequired = getMinimum();		if (minRequired == null)			return true;		if (version == null)			return false;		Version maxRequired = getMaximum() == null ? VersionRange.versionMax : getMaximum();		int minCheck = includeMin ? 0 : 1;		int maxCheck = includeMax ? 0 : -1;		return version.compareTo(minRequired) >= minCheck && version.compareTo(maxRequired) <= maxCheck;	}	public boolean equals(Object object) {		if (!(object instanceof VersionRange))			return false;		VersionRange vr = (VersionRange) object;		if (minVersion != null && vr.getMinimum() != null) {			if (minVersion.equals(vr.getMinimum()) && includeMin == vr.includeMin)				if (maxVersion != null && vr.getMaximum() != null) {					if (maxVersion.equals(vr.getMaximum()) && includeMax == vr.includeMax)						return true;				} else					return maxVersion == vr.getMaximum();		} else {			return minVersion == vr.getMinimum();		}		return false;	}	public int hashCode() {		final int prime = 31;		int result = 1;		result = prime * result + (maxVersion != null ? maxVersion.hashCode() : VersionRange.versionMax.hashCode());		result = prime * result + (minVersion != null ? minVersion.hashCode() : Version.emptyVersion.hashCode());		result = prime * result + (includeMax ? 1231 : 1237);		result = prime * result + (includeMin ? 1231 : 1237);		return result;	}	public String toString() {		if (minVersion == null)			return Version.emptyVersion.toString();		if (VersionRange.versionMax.equals(maxVersion))			return minVersion.toString();		StringBuffer result = new StringBuffer();		result.append(includeMin ? '[' : '(');		result.append(minVersion);		result.append(',');		result.append(maxVersion);		result.append(includeMax ? ']' : ')');		return result.toString();	}	public static org.eclipse.osgi.service.resolver.VersionRange toOSGiVersionRange(VersionRange range) {		if (range.equals(emptyRange))			return org.eclipse.osgi.service.resolver.VersionRange.emptyRange;		return new org.eclipse.osgi.service.resolver.VersionRange(Version.toOSGiVersion(range.getMinimum()), range.getIncludeMinimum(), Version.toOSGiVersion(range.getMaximum()), range.getIncludeMinimum());	}	public static VersionRange fromOSGiVersionRange(org.eclipse.osgi.service.resolver.VersionRange range) {		if (range.equals(org.eclipse.osgi.service.resolver.VersionRange.emptyRange))			return emptyRange;		return new VersionRange(Version.fromOSGiVersion(range.getMinimum()), range.getIncludeMinimum(), Version.fromOSGiVersion(range.getMaximum()), range.getIncludeMinimum());	}}
\ No newline at end of file
+/******************************************************************************* * Copyright (c) 2003, 2009 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *  * Contributors: *     IBM Corporation - initial API and implementation *     Cloudsmith Inc - rewrite to handle non-OSGi versions. *******************************************************************************/package org.eclipse.equinox.internal.provisional.p2.core;import java.io.Serializable;import org.eclipse.osgi.util.NLS;/** * This class represents a version range with Omni Version bounds. It is signature * equivalent with the OSGi {@link org.eclipse.osgi.service.resolver.VersionRange VersionRange} * * @Immutable * @noextend This class is not intended to be subclassed by clients. */public class VersionRange implements Serializable {	private static final long serialVersionUID = 4988030307298088028L;	static final Version OSGi_versionMin = new Version(0, 0, 0);	static final Version OSGi_versionMax = new Version(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);	/**	 * TODO: This should not be OSGi but it has to be that for now since the resolver creates	 * a filter where the min and max are converted into strings. When the filter is evaluated an	 * attempt is made to recreate them as OSGi versions.	 *	 * An empty OSGi Version range.	 */	public static final VersionRange emptyRange = new VersionRange(OSGi_versionMin, true, OSGi_versionMax, true);	private final Version minVersion;	private final boolean includeMin;	private final Version maxVersion;	private final boolean includeMax;	private static int copyEscaped(String vr, int pos, String breakChars, StringBuffer sb) {		int top = vr.length();		pos = VersionParser.skipWhite(vr, pos);		if (pos >= top)			throw new IllegalArgumentException();		char c = vr.charAt(pos);		for (;;) {			if (c == '\\' && ++pos < top)				c = vr.charAt(pos);			else {				if (c <= ' ')					return VersionParser.skipWhite(vr, pos);				if (breakChars != null && breakChars.indexOf(c) >= 0)					break;			}			sb.append(c);			if (++pos >= top)				break;			c = vr.charAt(pos);		}		return pos;	}	/**	 * Constructs a VersionRange with the specified minVersion and maxVersion.	 * @param minVersion the minimum version of the range	 * @param maxVersion the maximum version of the range	 */	public VersionRange(Version minVersion, boolean includeMin, Version maxVersion, boolean includeMax) {		if (minVersion == null) {			if (maxVersion == null) {				minVersion = Version.MIN_VERSION;				maxVersion = Version.MAX_VERSION;			} else				minVersion = maxVersion.getFormat() == VersionFormat.OSGI_FORMAT ? OSGi_versionMin : Version.MIN_VERSION;		} else {			if (maxVersion == null)				maxVersion = minVersion.getFormat() == VersionFormat.OSGI_FORMAT ? OSGi_versionMax : Version.MAX_VERSION;			else {				if (minVersion != maxVersion && minVersion.equals(maxVersion))					maxVersion = minVersion;				else if (!minVersion.getFormat().equals(maxVersion.getFormat()))					throw new IllegalArgumentException(NLS.bind(Messages.range_boundaries_0_and_1_cannot_have_different_formats, minVersion, maxVersion));			}		}		this.minVersion = minVersion;		this.includeMin = includeMin;		this.maxVersion = maxVersion;		this.includeMax = includeMax;		validateRange();	}	/**	 * Constructs a VersionRange from the given versionRange String.	 * @param versionRange a version range String that specifies a range of	 * versions.	 */	public VersionRange(String versionRange) {		int top = 0;		int pos = 0;		if (versionRange != null) {			top = versionRange.length();			pos = VersionParser.skipWhite(versionRange, 0);			top = VersionParser.skipTrailingWhite(versionRange, pos, top);		}		if (pos >= top) {			minVersion = Version.MIN_VERSION;			includeMin = true;			maxVersion = Version.MAX_VERSION;			includeMax = true;			return;		}		char c = versionRange.charAt(pos);		int[] position = new int[1];		boolean rawPrefix = false;		VersionFormat fmt = null;		if (VersionParser.isLetter(c)) {			if (versionRange.startsWith("raw:", pos)) { //$NON-NLS-1$				rawPrefix = true;				pos += 4;			} else {				position[0] = pos;				fmt = parseFormat(versionRange, position);				pos = position[0];				if (pos >= versionRange.length())					throw new IllegalArgumentException(NLS.bind(Messages.format_must_be_delimited_by_colon_0, versionRange));				c = versionRange.charAt(pos);				if (c != ':')					throw new IllegalArgumentException(NLS.bind(Messages.format_must_be_delimited_by_colon_0, versionRange));				++pos;			}			pos = VersionParser.skipWhite(versionRange, pos);			if (pos >= top)				throw new IllegalArgumentException(NLS.bind(Messages.premature_EOS_0, versionRange));			c = versionRange.charAt(pos);		} else			fmt = VersionFormat.OSGI_FORMAT;		String minStr;		String maxStr;		StringBuffer sb = new StringBuffer();		if (c == '[' || c == '(') {			includeMin = (c == '[');			pos = copyEscaped(versionRange, ++pos, ",)]", sb); //$NON-NLS-1$			if (pos >= top)				throw new IllegalArgumentException(NLS.bind(Messages.premature_EOS_0, versionRange));			c = versionRange.charAt(pos++);			if (c != ',')				throw new IllegalArgumentException(NLS.bind(Messages.missing_comma_in_range_0, versionRange));			minStr = sb.toString();			sb.setLength(0);			pos = copyEscaped(versionRange, pos, ")]", sb); //$NON-NLS-1$			if (pos >= top)				throw new IllegalArgumentException();			maxStr = sb.toString();			c = versionRange.charAt(pos++);			includeMax = (c == ']');		} else {			StringBuffer sbMin = new StringBuffer();			pos = copyEscaped(versionRange, pos, null, sbMin);			includeMin = includeMax = true;			minStr = sbMin.toString();			maxStr = null;		}		if (rawPrefix) {			String origMin = null;			String origMax = null;			pos = VersionParser.skipWhite(versionRange, pos);			if (pos < top && versionRange.charAt(pos) == '/') {				if (++pos == top)					throw new IllegalArgumentException(NLS.bind(Messages.original_stated_but_missing_0, versionRange));				position[0] = pos;				fmt = parseFormat(versionRange, position);				pos = VersionParser.skipWhite(versionRange, position[0]);				if (pos < top) {					boolean origUseIncDelims = false;					c = versionRange.charAt(pos);					if (c != ':')						throw new IllegalArgumentException(NLS.bind(Messages.original_must_start_with_colon_0, versionRange));					pos = VersionParser.skipWhite(versionRange, ++pos);					if (pos == top)						throw new IllegalArgumentException(NLS.bind(Messages.original_stated_but_missing_0, versionRange));					c = versionRange.charAt(pos);					if (c == '[' || c == '(') {						if (includeMin != (c == '[') || maxStr == null)							throw new IllegalArgumentException(NLS.bind(Messages.raw_and_original_must_use_same_range_inclusion_0, versionRange));						pos = VersionParser.skipWhite(versionRange, ++pos);						origUseIncDelims = true;					}					sb.setLength(0);					if (maxStr == null) {						copyEscaped(versionRange, pos, ",])", sb); //$NON-NLS-1$						origMin = sb.toString();					} else {						pos = copyEscaped(versionRange, pos, ",])", sb); //$NON-NLS-1$						if (pos >= top)							throw new IllegalArgumentException(NLS.bind(Messages.premature_EOS_0, versionRange));						c = versionRange.charAt(pos++);						if (c != ',')							throw new IllegalArgumentException(NLS.bind(Messages.missing_comma_in_range_0, versionRange));						origMin = sb.toString();						sb.setLength(0);						pos = copyEscaped(versionRange, pos, "])", sb); //$NON-NLS-1$						if (origUseIncDelims) {							if (pos >= top)								throw new IllegalArgumentException(NLS.bind(Messages.premature_EOS_0, versionRange));							c = versionRange.charAt(pos++);							if (includeMax != (c == ']'))								throw new IllegalArgumentException(NLS.bind(Messages.raw_and_original_must_use_same_range_inclusion_0, versionRange));						}						origMax = sb.toString();					}				}			}			minVersion = VersionFormat.parseRaw(minStr, fmt, origMin);			if (maxStr != null) {				if (maxStr.equals(minStr))					maxVersion = minVersion;				else					maxVersion = VersionFormat.parseRaw(maxStr, fmt, origMax);			} else				maxVersion = Version.MAX_VERSION;		} else {			if (fmt == null)				fmt = VersionFormat.OSGI_FORMAT;			minVersion = fmt.parse(minStr);			if (maxStr != null) {				if (maxStr.equals(minStr))					maxVersion = minVersion;				else					maxVersion = fmt.parse(maxStr);			} else {				maxVersion = (fmt == VersionFormat.OSGI_FORMAT) ? OSGi_versionMax : Version.MAX_VERSION;			}		}		validateRange();	}	private static VersionFormat parseFormat(String versionRange, int[] position) {		int pos = VersionParser.skipWhite(versionRange, position[0]);		if (!versionRange.startsWith("format(", pos)) //$NON-NLS-1$			return null;		pos += 7;		int end = VersionParser.findEndOfFormat(versionRange, pos, versionRange.length());		try {			position[0] = end + 1;			return VersionFormat.compile(versionRange, pos, end);		} catch (FormatException e) {			throw new IllegalArgumentException(e.getMessage());		}	}	/**	 * Returns the minimum Version of this VersionRange	 * @return the minimum Version of this VersionRange	 */	public Version getMinimum() {		return minVersion;	}	/**	 * Indicates if the minimum version is included in the version range.	 * @return true if the minimum version is included in the version range;	 * otherwise false is returned	 */	public boolean getIncludeMinimum() {		return includeMin;	}	/**	 * Returns the maximum Version of this VersionRange	 * @return the maximum Version of this VersionRange	 */	public Version getMaximum() {		return maxVersion;	}	/**	 * Indicates if the maximum version is included in the version range.	 * @return true if the maximum version is included in the version range;	 * otherwise false is returned	 */	public boolean getIncludeMaximum() {		return includeMax;	}	public VersionRange intersect(VersionRange r2) {		int minCompare = minVersion.compareTo(r2.getMinimum());		int maxCompare = maxVersion.compareTo(r2.getMaximum());		boolean resultMinIncluded;		Version resultMin;		if (minCompare == 0) {			if (maxCompare == 0 && includeMin == r2.getIncludeMinimum() && includeMax == r2.getIncludeMaximum())				return this;			resultMin = minVersion;			resultMinIncluded = includeMin && r2.getIncludeMinimum();		} else if (minCompare < 0) {			resultMin = r2.getMinimum();			resultMinIncluded = r2.getIncludeMinimum();		} else { // minCompare > 0)			resultMin = minVersion;			resultMinIncluded = includeMin;		}		boolean resultMaxIncluded;		Version resultMax;		if (maxCompare > 0) {			resultMax = r2.getMaximum();			resultMaxIncluded = r2.getIncludeMaximum();		} else if (maxCompare < 0) {			resultMax = maxVersion;			resultMaxIncluded = includeMax;		} else {//maxCompare == 0			resultMax = maxVersion;			resultMaxIncluded = includeMax && r2.getIncludeMaximum();		}		int minMaxCmp = resultMin.compareTo(resultMax);		if (minMaxCmp < 0 || (minMaxCmp == 0 && resultMinIncluded && resultMaxIncluded))			return new VersionRange(resultMin, resultMinIncluded, resultMax, resultMaxIncluded);		return null;	}	/**	 * Returns whether the given version is included in this VersionRange.	 * This will depend on the minimum and maximum versions of this VersionRange	 * and the given version.	 * 	 * @param version a version to be tested for inclusion in this VersionRange. 	 * (may be <code>null</code>)	 * @return <code>true</code> if the version is include, 	 * <code>false</code> otherwise 	 */	public boolean isIncluded(Version version) {		if (version == null)			return false;		if (minVersion == maxVersion)			// Can only happen when both includeMin and includeMax are true			return minVersion.equals(version);		int minCheck = includeMin ? 0 : -1;		int maxCheck = includeMax ? 0 : 1;		return minVersion.compareTo(version) <= minCheck && maxVersion.compareTo(version) >= maxCheck;	}	/**	 * Checks if the versions of this range is in compliance with the OSGi version spec.	 * @return A flag indicating whether the range is OSGi compatible or not.	 */	public boolean isOSGiCompatible() {		return minVersion.isOSGiCompatible() && maxVersion.isOSGiCompatible();	}	public boolean equals(Object object) {		if (!(object instanceof VersionRange))			return false;		VersionRange vr = (VersionRange) object;		return includeMin == vr.includeMin && includeMax == vr.includeMax && minVersion.equals(vr.getMinimum()) && maxVersion.equals(vr.getMaximum());	}	public int hashCode() {		final int prime = 31;		int result = 1;		result = prime * result + maxVersion.hashCode();		result = prime * result + minVersion.hashCode();		result = prime * result + (includeMax ? 1231 : 1237);		result = prime * result + (includeMin ? 1231 : 1237);		return result;	}	public String toString() {		StringBuffer result = new StringBuffer();		toString(result);		return result.toString();	}	public void toString(StringBuffer result) {		if (minVersion.getFormat() == VersionFormat.OSGI_FORMAT) {			if (includeMin && includeMax && OSGi_versionMax.equals(maxVersion)) {				minVersion.toString(result);			} else {				result.append(includeMin ? '[' : '(');				minVersion.toString(result);				result.append(',');				maxVersion.toString(result);				result.append(includeMax ? ']' : ')');			}			return;		}		boolean gtEqual = includeMin && includeMax && Version.MAX_VERSION.equals(maxVersion);		result.append("raw:"); //$NON-NLS-1$		if (gtEqual) {			minVersion.rawToString(result, true);		} else {			result.append(includeMin ? '[' : '(');			minVersion.rawToString(result, true);			result.append(',');			maxVersion.rawToString(result, true);			result.append(includeMax ? ']' : ')');		}		if (minVersion.getFormat() != null || minVersion.getOriginal() != null) {			result.append('/');			if (minVersion.getFormat() != null)				minVersion.getFormat().toString(result);			if (minVersion.getOriginal() != null) {				result.append(':');				if (gtEqual) {					minVersion.originalToString(result, true);				} else {					minVersion.originalToString(result, true);					result.append(',');					maxVersion.originalToString(result, true);				}			}		}	}	// Preserve singletons during deserialization	private Object readResolve() {		VersionRange vr = this;		if (equals(emptyRange))			vr = emptyRange;		return vr;	}	private void validateRange() {		int cmp = minVersion.compareTo(maxVersion);		if (!(cmp < 0 || (cmp == 0 && includeMin && includeMax)))			throw new IllegalArgumentException(NLS.bind(Messages.range_min_0_is_not_less_then_range_max_1, minVersion, maxVersion));	}	public static org.eclipse.osgi.service.resolver.VersionRange toOSGiVersionRange(VersionRange range) {		if (range.equals(emptyRange))			return org.eclipse.osgi.service.resolver.VersionRange.emptyRange;		return new org.eclipse.osgi.service.resolver.VersionRange(Version.toOSGiVersion(range.getMinimum()), range.getIncludeMinimum(), Version.toOSGiVersion(range.getMaximum()), range.getIncludeMinimum());	}	public static VersionRange fromOSGiVersionRange(org.eclipse.osgi.service.resolver.VersionRange range) {		if (range.equals(org.eclipse.osgi.service.resolver.VersionRange.emptyRange))			return emptyRange;		return new VersionRange(Version.fromOSGiVersion(range.getMinimum()), range.getIncludeMinimum(), Version.fromOSGiVersion(range.getMaximum()), range.getIncludeMinimum());	}}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionVector.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionVector.java
new file mode 100644
index 0000000..cc95fcd
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/VersionVector.java
@@ -0,0 +1,367 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core;
+
+import java.io.Serializable;
+
+/**
+ * The VersionVector represents an array of Comparable objects. The array can be
+ * nested since a VersionVector is Comparable in itself.
+ *  
+ * @Immutable
+ */
+public class VersionVector implements Comparable, Serializable {
+
+	private static final class MaxStringValue implements Comparable, Serializable {
+		private static final long serialVersionUID = -4936252230441132767L;
+
+		MaxStringValue() {
+			// Empty constructor
+		}
+
+		public int compareTo(Object o) {
+			return o == this ? 0 : (o == MAX_VALUE || o instanceof Integer || o instanceof VersionVector ? -1 : 1);
+		}
+
+		// For singleton deserialization
+		private Object readResolve() {
+			return MAXS_VALUE;
+		}
+
+		public String toString() {
+			return "m"; //$NON-NLS-1$
+		}
+	}
+
+	private static final class MaxValue implements Comparable, Serializable {
+		private static final long serialVersionUID = -5889641741635253589L;
+
+		MaxValue() {
+			// Empty constructor
+		}
+
+		public int compareTo(Object o) {
+			return o == this ? 0 : 1;
+		}
+
+		public String toString() {
+			return "M"; //$NON-NLS-1$
+		}
+
+		// For singleton deserialization
+		private Object readResolve() {
+			return MAX_VALUE;
+		}
+	}
+
+	private static class MinValue implements Comparable, Serializable {
+		private static final long serialVersionUID = -1066323980049812226L;
+
+		MinValue() {
+			// Empty constructor
+		}
+
+		public int compareTo(Object o) {
+			return o == this ? 0 : -1;
+		}
+
+		public String toString() {
+			return "-M"; //$NON-NLS-1$
+		}
+
+		private Object readResolve() {
+			return MIN_VALUE;
+		}
+	}
+
+	/**
+	 * A value that is greater then any other value
+	 */
+	public static final Comparable MAX_VALUE = new MaxValue();
+
+	/**
+	 * A value that is greater then any string but less then {@link #MAX_VALUE} and
+	 * any Integer or VersionVector.
+	 */
+	public static final Comparable MAXS_VALUE = new MaxStringValue();
+
+	/**
+	 * A value that is less then any other value
+	 */
+	public static final Comparable MIN_VALUE = new MinValue();
+
+	private static final long serialVersionUID = -8385373304298723744L;
+
+	static void rawToString(StringBuffer sb, boolean forRange, Comparable e) {
+		if (e instanceof String) {
+			writeQuotedString(sb, forRange, (String) e, '\'', 0, false);
+		} else if (e instanceof VersionVector) {
+			sb.append('<');
+			((VersionVector) e).toString(sb, forRange);
+			sb.append('>');
+		} else
+			sb.append(e);
+	}
+
+	/**
+	 * Write a string within quotes. If the string is found to contain the quote, an attempt is made
+	 * to flip quote character (single quote becomes double quote and vice versa). A string that contains
+	 * both will be written as several adjacent quoted strings so that each string is quoted with a
+	 * quote character that it does not contain.
+	 * @param sb The buffer that will receive the string
+	 * @param rangeSafe Set to <code>true</code> if the resulting string will be used in a range string
+	 *        and hence need to escape the range delimiter characters
+	 * @param s The string to be written
+	 * @param quote The quote character to start with. Must be the single or double quote character.
+	 * @param startPos The start position
+	 * @param didFlip True if the call is recursive and thus, cannot switch quotes in the first string.
+	 */
+	static void writeQuotedString(StringBuffer sb, boolean rangeSafe, String s, char quote, int startPos, boolean didFlip) {
+		int quotePos = sb.length();
+		sb.append(quote);
+		boolean otherSeen = false;
+		int top = s.length();
+		for (int idx = startPos; idx < top; ++idx) {
+			char c = s.charAt(idx);
+			if (c == '\'' || c == '"') {
+				if (c == quote) {
+					char otherQuote = quote == '\'' ? '"' : '\'';
+					if (didFlip || otherSeen) {
+						// We can only flip once
+						sb.append(quote);
+						writeQuotedString(sb, rangeSafe, s, otherQuote, idx, true);
+						return;
+					}
+					quote = otherQuote;
+					sb.setCharAt(quotePos, quote);
+					didFlip = true;
+				} else
+					otherSeen = true;
+			}
+			if (rangeSafe && (c == '\\' || c == '[' || c == '(' || c == ']' || c == ')' || c == ',' || c <= ' '))
+				sb.append('\\');
+			sb.append(c);
+		}
+		sb.append(quote);
+	}
+
+	private static int compareSegments(Comparable a, Comparable b) {
+		if (a == b)
+			return 0;
+
+		if (a instanceof Integer && b instanceof Integer) {
+			int ai = ((Integer) a).intValue();
+			int bi = ((Integer) b).intValue();
+			return ai > bi ? 1 : (ai < bi ? -1 : 0);
+		}
+
+		if (a instanceof String && b instanceof String)
+			return a.compareTo(b);
+
+		if (a == MAX_VALUE || a == MIN_VALUE || a == MAXS_VALUE)
+			return a.compareTo(b);
+
+		if (b == MAX_VALUE || b == MIN_VALUE || b == MAXS_VALUE)
+			return -b.compareTo(a);
+
+		if (a instanceof Integer)
+			return 1;
+		if (b instanceof Integer)
+			return -1;
+		if (a instanceof VersionVector)
+			return (b instanceof VersionVector) ? a.compareTo(b) : 1;
+
+		if (b instanceof VersionVector)
+			return -1;
+
+		throw new IllegalArgumentException();
+	}
+
+	private Comparable padValue;
+
+	private Comparable[] vector;
+
+	VersionVector() {
+		// Constructor used in conjunction with init (when version is parsed from string)
+	}
+
+	VersionVector(Comparable[] vector, Comparable pad) {
+		this.vector = vector;
+		this.padValue = (pad == MIN_VALUE) ? null : pad;
+	}
+
+	public int compareTo(Object o) {
+		if (o == this)
+			return 0;
+
+		VersionVector ov = (VersionVector) o;
+		Comparable[] t_vector = vector;
+		Comparable[] o_vector = ov.vector;
+		int top = t_vector.length;
+		if (top > o_vector.length)
+			top = o_vector.length;
+
+		for (int idx = 0; idx < top; ++idx) {
+			int cmp = compareSegments(t_vector[idx], o_vector[idx]);
+			if (cmp != 0)
+				return cmp;
+		}
+
+		// All elements compared equal up to this point. Check
+		// pad values
+		if (top < t_vector.length)
+			return (ov.padValue == null) ? 1 : compareReminder(top, ov.padValue);
+
+		if (top < o_vector.length)
+			return (padValue == null) ? -1 : -ov.compareReminder(top, padValue);
+
+		// Lengths are equal. Compare pad values
+		return padValue == null ? (ov.padValue == null ? 0 : -1) : (ov.padValue == null ? 1 : compareSegments(padValue, ov.padValue));
+	}
+
+	public boolean equals(Object o) {
+		if (o == this)
+			return true;
+
+		if (!(o instanceof VersionVector))
+			return false;
+
+		VersionVector ov = (VersionVector) o;
+
+		// We compare pad first since it is impossible for versions with
+		// different pad to be equal (versions are padded to infinity) 
+		if (padValue == null) {
+			if (ov.padValue != null)
+				return false;
+		} else {
+			if (ov.padValue == null || !padValue.equals(ov.padValue))
+				return false;
+		}
+
+		Comparable[] t_vector = vector;
+		Comparable[] o_vector = ov.vector;
+		int idx = t_vector.length;
+
+		// If the length of the vector differs, the versions cannot be equal
+		// since segments equal to pad are stripped by the parser
+		if (idx != o_vector.length)
+			return false;
+
+		while (--idx >= 0)
+			if (!t_vector[idx].equals(o_vector[idx]))
+				return false;
+
+		return true;
+	}
+
+	/**
+	 * Returns the pad value used when comparing this versions to
+	 * versions that has a raw vector with a larger number of elements
+	 * @return The pad value or <code>null</code> if not set.
+	 */
+	public Comparable getPad() {
+		return padValue;
+	}
+
+	/**
+	 * An element from the raw vector
+	 * @param index The zero based index of the desired element
+	 * @return An element from the raw vector
+	 */
+	public Comparable getSegment(int index) {
+		return vector[index];
+	}
+
+	/**
+	 * Returns the number of elements in the raw vector
+	 * @return The element count
+	 */
+	public int getSegmentCount() {
+		return vector.length;
+	}
+
+	public int hashCode() {
+		int hashCode = padValue == null ? 31 : padValue.hashCode();
+		int idx = vector.length;
+		while (--idx >= 0) {
+			Object elem = vector[idx];
+			if (elem != null)
+				hashCode += elem.hashCode();
+			hashCode = hashCode * 31;
+		}
+		return hashCode;
+	}
+
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		toString(sb);
+		return sb.toString();
+	}
+
+	/**
+	 * Append the string representation of this instance to the
+	 * <code>sb</code> buffer.
+	 * @param sb The buffer to append to
+	 */
+	public void toString(StringBuffer sb) {
+		toString(sb, false);
+	}
+
+	/**
+	 * Append the string representation of this instance to the
+	 * <code>sb</code> buffer.
+	 * @param sb The buffer to append to
+	 * @param rangeSafe If <code>true</code>, the range delimiters will be escaped
+	 * with backslash.
+	 */
+	public void toString(StringBuffer sb, boolean rangeSafe) {
+		int top = vector.length;
+		if (top == 0)
+			// Write one pad value as explicit. It will be considered
+			// redundant and removed by the parser but the raw format
+			// does not allow zero elements
+			rawToString(sb, rangeSafe, padValue == null ? MIN_VALUE : padValue);
+		else {
+			for (int idx = 0; idx < top; ++idx) {
+				if (idx > 0)
+					sb.append('.');
+				rawToString(sb, rangeSafe, vector[idx]);
+			}
+		}
+		if (padValue != null) {
+			sb.append('p');
+			rawToString(sb, rangeSafe, padValue);
+		}
+	}
+
+	/**
+	 * This method is package protected since it violates the immutable
+	 * contract.
+	 * @return The raw vector. Must be treated as read-only
+	 */
+	Comparable[] getVector() {
+		return vector;
+	}
+
+	void init(Comparable[] vec, Comparable pad) {
+		vector = vec;
+		padValue = (pad == MIN_VALUE) ? null : pad;
+	}
+
+	private int compareReminder(int idx, Comparable othersPad) {
+		int cmp;
+		for (cmp = 0; idx < vector.length && cmp == 0; ++idx)
+			cmp = compareSegments(vector[idx], othersPad);
+		if (cmp == 0)
+			cmp = (padValue == null) ? -1 : padValue.compareTo(othersPad);
+		return cmp;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/messages.properties b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/messages.properties
new file mode 100644
index 0000000..0454093
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/messages.properties
@@ -0,0 +1,61 @@
+###############################################################################
+ # Copyright (c) 2009 Cloudsmith Inc. and others.
+ # All rights reserved. This program and the accompanying materials
+ # are made available under the terms of the Eclipse Public License v1.0
+ # which accompanies this distribution, and is available at
+ # http://www.eclipse.org/legal/epl-v10.html
+ #
+ # Contributors:
+ #     Cloudsmith Inc. - initial API and implementation
+###############################################################################
+_0_is_not_a_positive_integer_in_osgi_1=The {0} value is not a positive in OSGi version: "{1}"
+_0_is_not_a_string_in_osgi_1=The {0} value is not a string in OSGi version: "{1}"
+_0_is_not_a_valid_qualifier_in_osgi_1=The {0} value is invalid in OSGi version: "{1}"array_can_not_be_empty=Array format can not be empty
+array_can_not_be_empty=Array format can not be empty
+array_can_not_have_character_group=Array format can not have a character group
+auto_can_not_have_pad_value=Auto format can not have a pad value
+cannot_combine_ignore_with_other_instruction=Cannot combine ignore with other instruction
+cannot_combine_range_upper_bound_with_pad_value=Cannot combine range upper bound with pad value
+character_group_defined_more_then_once=Character group was defined more then once
+colon_expected_before_original_version_0=A colon was expected before original version: {0}
+default_defined_more_then_once=Default defined more then once
+delimiter_can_not_be_ignored=A delimiter cannot be ignored
+delimiter_can_not_have_default_value=A delimiter cannot have a default value
+delimiter_can_not_have_pad_value=A delimiter cannot have a pad value
+delimiter_can_not_have_range=A delimiter cannot have a range
+EOS_after_escape=End of string was encountere after the escape character
+expected_orignal_after_colon_0=An original version was expected after colon: {0}
+expected_orignal_after_slash_0=A format or colon was expected after slash: {0}
+expected_slash_after_raw_vector_0=A slash was expected after a raw version: {0}
+format_0_unable_to_parse_1=Format "{0}" was unable to parse {1}
+format_0_unable_to_parse_empty_version=Format "{0}" was unable to parse an empty version
+format_is_empty=Format is empty
+format_must_be_delimited_by_colon_0=Format must be delimited by version range: {0}
+group_can_not_be_empty=A group can not be empty
+ignore_defined_more_then_once=More then one definition of ignore
+illegal_character_encountered_ascii_0=An illegal character was encountered. Code = {0}
+illegal_number_of_entries_0_in_osgi_1=Illegal number of entries {0} in OSGi version: "{1}"
+missing_comma_in_range_0=Missing comma in range "{0}"
+negative_character_range=The character range is negative
+neither_raw_vector_nor_format_specified_0=Neither raw version nor format was specified: {0}
+number_can_not_have_pad_value=A number cannot have a pad value
+only_format_specified_0=Only a format was specified: {0}
+original_must_start_with_colon_0=Original version must start with colon: {0}
+original_stated_but_missing_0=Expected original version after colon: {0}
+pad_defined_more_then_once=Pad was defined more then once
+pad_not_allowed_in_osgi_0=Pad is not allowed in an OSGi version: "{0}"
+premature_end_of_format=Premature end of format
+premature_end_of_format_expected_0=Premature end of format, "{0}" expected
+premature_EOS_0=Premature end of string in "{0}"
+range_defined_more_then_once=Range defined more then once
+range_max_cannot_be_less_then_range_min=The range maximum must not be less then its minimum
+range_max_cannot_be_zero=The range maximum cannot be zero
+range_min_0_is_not_less_then_range_max_1=Range minimum "{0}" is not less then range maximum "{1}" (inclusion is required at both ends if the versions are equal)
+range_boundaries_0_and_1_cannot_have_different_formats=Range boundaries "{0}" and "{1}" cannot have different formats
+raw_and_original_must_use_same_range_inclusion_0=Raw and original must use the same range inclusion markers in range "{0}"
+raw_element_can_not_have_pad_value=A raw element cannot have a pad value
+raw_element_expected_0=A raw element was expected: {0}
+string_can_not_have_pad_value=A string cannot have a pad value
+syntax_error_in_version_format_0_1_2=Syntax error in version format "{0}" at position {1}: {2}
+syntax_error_in_version_format_0_1_found_2_expected_3=Syntax error in version format "{0}" at position {1}: Found {2} when {3} was expected
+unbalanced_format_parenthesis=Unbalanced format parenthesis
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AutomatedTests.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AutomatedTests.java
index 562ff48..98b2ea4 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AutomatedTests.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AutomatedTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Cloudsmith - bug fixing and new functionality
  *******************************************************************************/
 package org.eclipse.equinox.p2.tests;
 
@@ -35,6 +36,7 @@ public class AutomatedTests extends TestCase {
 		suite.addTest(org.eclipse.equinox.p2.tests.metadata.AllTests.suite());
 		suite.addTest(org.eclipse.equinox.p2.tests.metadata.repository.AllTests.suite());
 		suite.addTest(org.eclipse.equinox.p2.tests.mirror.AllTests.suite());
+		suite.addTest(org.eclipse.equinox.p2.tests.omniVersion.AllTests.suite());
 		suite.addTest(org.eclipse.equinox.p2.tests.planner.AllTests.suite());
 		suite.addTest(org.eclipse.equinox.p2.tests.publisher.AllTests.suite());
 		suite.addTest(org.eclipse.equinox.p2.tests.simpleconfigurator.SimpleConfiguratorTests.suite());
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/AllTests.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/AllTests.java
new file mode 100644
index 0000000..660ab23
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/AllTests.java
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.*;
+
+/**
+ * Tests the OmniVersion implementation of Version and VersionRange.
+ * 
+ */
+public class AllTests extends TestCase {
+	public static Test suite() {
+		TestSuite suite = new TestSuite(AllTests.class.getName());
+		suite.addTestSuite(CommonPatternsTest.class);
+		suite.addTestSuite(FormatArrayTest.class);
+		suite.addTestSuite(FormatATest.class);
+		suite.addTestSuite(FormatDTest.class);
+		suite.addTestSuite(FormatNTest.class);
+		suite.addTestSuite(FormatProcessingTest.class);
+		suite.addTestSuite(FormatPTest.class);
+		suite.addTestSuite(FormatQTest.class);
+		suite.addTestSuite(FormatRTest.class);
+		suite.addTestSuite(FormatSTest.class);
+		suite.addTestSuite(FormatTest.class);
+		suite.addTestSuite(MultiplicityTest.class);
+		suite.addTestSuite(OSGiRangeTest.class);
+		suite.addTestSuite(RawRangeTest.class);
+		suite.addTestSuite(RawRangeWithOriginalTest.class);
+		suite.addTestSuite(RawVersionTest.class);
+		suite.addTestSuite(RawWithOriginalTest.class);
+
+		return suite;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/CommonPatternsTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/CommonPatternsTest.java
new file mode 100644
index 0000000..7a428d6
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/CommonPatternsTest.java
@@ -0,0 +1,187 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Test common patterns:
+ * - Triplet
+ * - Mozilla
+ * - RPM
+ * - JSR277 (proposed version handling as documented Dec 30, 2008).
+ * 
+ */
+public class CommonPatternsTest extends VersionTesting {
+	public static String MOZ_PREFIX = "format((<N=0;?s=m;?N=0;?s=m;?>(.<N=0;?s=m;?N=0;?s=m;?>)*)=p<0.m.0.m>;):";
+	public static String TRIPLE_PREFIX = "format([n=0;[.n=0;[.n=0;[.S=m;]]]]):";
+	public static String RPM_PREFIX = "format(<[n=0;:]a(d=[^a-zA-Z0-9@_-];?a)*>[-n[dS=!;]]):";
+	public static String JSR277_PREFIX = "format(n(.n=0;){0,3}[-S=m;]):";
+
+	public void testMozillaPattern() {
+
+		// 1.-1
+		Version v1 = Version.parseVersion(MOZ_PREFIX + "1.-1");
+
+		// < 1 == 1. == 1.0 == 1.0.0
+		Version v2 = Version.parseVersion(MOZ_PREFIX + "1");
+		Version v2a = Version.parseVersion(MOZ_PREFIX + "1.");
+		Version v2b = Version.parseVersion(MOZ_PREFIX + "1.0");
+		Version v2c = Version.parseVersion(MOZ_PREFIX + "1.0.0");
+
+		assertOrder(v1, v2);
+		assertEquals(v2, v2a);
+		assertEquals(v2a, v2b);
+		assertEquals(v2b, v2c);
+
+		// < 1.1a < 1.1aa < 1.1ab < 1.1b < 1.1c
+		Version v3 = Version.parseVersion(MOZ_PREFIX + "1.1a");
+		Version v4 = Version.parseVersion(MOZ_PREFIX + "1.1aa");
+		Version v5 = Version.parseVersion(MOZ_PREFIX + "1.1ab");
+		Version v6 = Version.parseVersion(MOZ_PREFIX + "1.1b");
+		Version v7 = Version.parseVersion(MOZ_PREFIX + "1.1c");
+
+		assertOrder(v2c, v3);
+		assertOrder(v3, v4);
+		assertOrder(v4, v5);
+		assertOrder(v5, v6);
+		assertOrder(v6, v7);
+
+		// < 1.1pre == 1.1pre0 == 1.0+
+		Version v8 = Version.parseVersion(MOZ_PREFIX + "1.1pre");
+		Version v8a = Version.parseVersion(MOZ_PREFIX + "1.1pre0");
+
+		assertOrder(v7, v8);
+		assertEquals(v8, v8a);
+
+		/* NOT SUPPORTED BY OMNI VERSION: Version v8b = Version.parseVersion(MOZ_PREFIX +"1.0+"); */
+
+		// < 1.1pre1a < 1.1pre1aa < 1.1pre1b < 1.1pre1
+		Version v9 = Version.parseVersion(MOZ_PREFIX + "1.1pre1a");
+		Version v10 = Version.parseVersion(MOZ_PREFIX + "1.1pre1aa");
+		Version v11 = Version.parseVersion(MOZ_PREFIX + "1.1pre1b");
+		Version v12 = Version.parseVersion(MOZ_PREFIX + "1.1pre1");
+
+		assertOrder(v8a, v9);
+		assertOrder(v9, v10);
+		assertOrder(v10, v11);
+		assertOrder(v11, v12);
+
+		// < 1.1pre2
+		Version v13 = Version.parseVersion(MOZ_PREFIX + "1.1pre2");
+		assertOrder(v12, v13);
+
+		// < 1.1pre10
+		Version v14 = Version.parseVersion(MOZ_PREFIX + "1.1pre10");
+		assertOrder(v13, v14);
+
+		//< 1.1.-1
+		Version v15 = Version.parseVersion(MOZ_PREFIX + "1.1.-1");
+		assertOrder(v14, v15);
+
+		// < 1.1 == 1.1.0 == 1.1.00
+		Version v16 = Version.parseVersion(MOZ_PREFIX + "1.1");
+		Version v16a = Version.parseVersion(MOZ_PREFIX + "1.1.0");
+		Version v16b = Version.parseVersion(MOZ_PREFIX + "1.1.00");
+
+		assertOrder(v15, v16);
+		assertEquals(v16, v16a);
+		assertEquals(v16a, v16b);
+
+		// < 1.10
+		Version v17 = Version.parseVersion(MOZ_PREFIX + "1.10");
+		assertOrder(v16a, v17);
+
+		// < 1.* < 1.*.1
+		/* NOT SUPPORTED BY OMNIVERSION: Version v18 = Version.parseVersion(MOZ_PREFIX +"1.1a"); */
+
+		// < 2.0
+		Version v18 = Version.parseVersion(MOZ_PREFIX + "2.0");
+		assertOrder(v17, v18);
+	}
+
+	public void testTripletPattern() {
+		Version v1 = Version.parseVersion(TRIPLE_PREFIX + "1");
+		Version v1a = Version.parseVersion(TRIPLE_PREFIX + "1.0");
+		Version v1b = Version.parseVersion(TRIPLE_PREFIX + "1.0.0");
+		assertEquals(v1, v1a);
+		assertEquals(v1a, v1b);
+
+		Version v2 = Version.parseVersion(TRIPLE_PREFIX + "1.0.0.a");
+		assertOrder(v2, v1); // yes 1.0.0.a is OLDER
+
+		Version v3 = Version.parseVersion(TRIPLE_PREFIX + "1.1");
+		assertOrder(v1b, v3);
+
+		Version v4 = Version.parseVersion(TRIPLE_PREFIX + "1.1.0.a");
+		assertOrder(v4, v3); // yes 1.1.0.a is OLDER
+
+		Version v5 = Version.parseVersion(TRIPLE_PREFIX + "2");
+		assertOrder(v3, v5);
+	}
+
+	// TODO: Not clear what a missing RPM EPOCH (i.e. first '.n:' should be interpreted as
+	public void testRPMPattern() {
+		Version v1 = Version.parseVersion(RPM_PREFIX + "33:1.2.3a-23/i386");
+		assertEquals(Version.parseVersion("raw:<33.1.2.3.'a'>.23"), v1);
+		Version v2 = Version.parseVersion(RPM_PREFIX + "34:1");
+		assertOrder(v1, v2);
+
+		Version v3 = Version.parseVersion(RPM_PREFIX + "33:1.2.3b");
+		assertOrder(v1, v3);
+		Version v11 = Version.parseVersion(RPM_PREFIX + "1-1");
+		Version v12 = Version.parseVersion(RPM_PREFIX + "1-2");
+		Version v13 = Version.parseVersion(RPM_PREFIX + "1.0");
+		Version v14 = Version.parseVersion(RPM_PREFIX + "1.1");
+		assertOrder(v11, v12);
+		assertOrder(v12, v13);
+
+		assertOrder(v11, v13);
+		assertOrder(v12, v13);
+
+		assertOrder(v11, v14);
+		assertOrder(v12, v14);
+		assertOrder(v13, v14);
+	}
+
+	/**
+	 * JSR277 works like triplet, but has 4 elements. The last qualifier can be used without specifying the preceding
+	 * three segments.
+	 */
+	public void testJsr277Pattern() {
+		Version v1 = Version.parseVersion(JSR277_PREFIX + "1");
+		Version v1a = Version.parseVersion(JSR277_PREFIX + "1.0");
+		Version v1b = Version.parseVersion(JSR277_PREFIX + "1.0.0");
+		Version v1c = Version.parseVersion(JSR277_PREFIX + "1.0.0.0");
+		assertEquals(v1, v1a);
+		assertEquals(v1a, v1b);
+		assertEquals(v1b, v1c);
+
+		Version v2 = Version.parseVersion(JSR277_PREFIX + "1-a");
+		Version v2a = Version.parseVersion(JSR277_PREFIX + "1.0-a");
+		Version v2b = Version.parseVersion(JSR277_PREFIX + "1.0.0-a");
+		Version v2c = Version.parseVersion(JSR277_PREFIX + "1.0.0.0-a");
+		assertOrder(v2, v1); // yes 1.0.0.a is OLDER
+		assertEquals(v2, v2a);
+		assertEquals(v2a, v2b);
+		assertEquals(v2b, v2c);
+
+		Version v3 = Version.parseVersion(JSR277_PREFIX + "1.1");
+		assertOrder(v1b, v3);
+
+		Version v4 = Version.parseVersion(JSR277_PREFIX + "1.1.0-a");
+		assertOrder(v4, v3); // yes 1.1.0.a is OLDER
+
+		Version v5 = Version.parseVersion(JSR277_PREFIX + "2");
+		assertOrder(v3, v5);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatATest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatATest.java
new file mode 100644
index 0000000..1941593
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatATest.java
@@ -0,0 +1,131 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests the format(a) rule.
+ *
+ */
+public class FormatATest extends TestCase {
+	public void testNumeric() {
+		Version v = Version.parseVersion("format(a):1");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:1"), v);
+	}
+
+	public void testString() {
+		Version v = Version.parseVersion("format(a):a");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'a'"), v);
+	}
+
+	public void testSequenceOfAuto() {
+		Version v = Version.parseVersion("format(aaaa):123abc456def");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:123.'abc'.456.'def'"), v);
+	}
+
+	/**
+	 * Test that exact delimits a on count and type.
+	 */
+	public void testExact() {
+		Version v = Version.parseVersion("format(a={3};aaa={3};):123abc456def");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:123.'abc'.456.'def'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(a={2};a):abc"));
+		assertEquals(Version.parseVersion("raw:'ab'.'c'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(a={2};a):123"));
+		assertEquals(Version.parseVersion("raw:12.3"), v);
+
+		try {
+			// should fail because first segment is delimited after 2 chars
+			Version.parseVersion("format(a={4};aaa={3};):12.3abc456def");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			// should fail because first segment is delimited by type change after 3 chars
+			Version.parseVersion("format(a={4};aaa={3};):123abc456def");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			// should fail because first segment is delimited by type change after 3 chars
+			Version.parseVersion("format(a={4};aaa={3};):xyz123abc456");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	/**
+	 * Test that unbound upper range delimits a on change of type.
+	 */
+	public void testAtLeast() {
+		Version v = Version.parseVersion("format(a={2,};aaa={2,};):123abc456def");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:123.'abc'.456.'def'"), v);
+
+		try {
+			Version.parseVersion("format(a={2,};aaa={2,};):1abc456def");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(a={2,};aaa={2,};):12abc456d");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	/**
+	 * test that at-most follows same rules as exact for the min range 
+	 */
+	public void testAtMost() {
+		Version v = Version.parseVersion("format(a={1,3};aaa={1,3};):123abc456def");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:123.'abc'.456.'def'"), v);
+
+		// change of type is delimiter 
+		assertNotNull(v = Version.parseVersion("format(a={1,2};aaaa={1,2};a):123abc456def"));
+		assertEquals(Version.parseVersion("raw:12.3.'abc'.456.'de'.'f'"), v);
+
+		try {
+			Version.parseVersion("format(a={2,3};aaa={1,2};):1abc456def");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(a={2,3};aaa={2,3};):12abc456d");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(a={4,5};aaa={1,4};):123abc456def");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatArrayTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatArrayTest.java
new file mode 100644
index 0000000..5ea2cd8
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatArrayTest.java
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests format(<>) - arrays.
+ * 
+ */
+public class FormatArrayTest extends TestCase {
+	public void testEmptyArray() {
+		try {
+			Version.parseVersion("format(<>q):''");
+			fail("Uncaught error: empty array group is not allowed:");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testEmptyArrayBecauseContentIsOptional() {
+		try {
+			Version.parseVersion("format(<n?>q):''");
+			fail("Uncaught error: produces an empty vector");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOptionalArray() {
+		Version v = Version.parseVersion("format(<n>?S):abc");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'abc'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(<n>?S):1abc"));
+		assertEquals(Version.parseVersion("raw:<1>.'abc'"), v);
+
+	}
+
+	public void testNumericArray() {
+		Version v = Version.parseVersion("format(<(n.?)+>):1.2.3.4.5.6.7.8.9");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:<1.2.3.4.5.6.7.8.9>"), v);
+	}
+
+	public void testStringArray() {
+		Version v = Version.parseVersion("format(<(S=[^.];d?)+>):a.b.c.d.e.f.g.h.i");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:<'a'.'b'.'c'.'d'.'e'.'f'.'g'.'h'.'i'>"), v);
+	}
+
+	public void testNestedArray() {
+		Version v = Version.parseVersion("format(<n.<n.n>.n>):1.2.3.4");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:<1.<2.3>.4>"), v);
+
+		assertNotNull(v = Version.parseVersion("format(<n.<n.<n>>.n>):1.2.3.4"));
+		assertEquals(Version.parseVersion("raw:<1.<2.<3>>.4>"), v);
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatDTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatDTest.java
new file mode 100644
index 0000000..5c81916
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatDTest.java
@@ -0,0 +1,192 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests format(d) and explicit delimiter chars and strings.
+ */
+public class FormatDTest extends TestCase {
+	/**
+	 * Definition of default set of delimiters
+	 */
+	private static char[] s_delim = { //
+	0x20, // ' '
+			0x21, // ! 
+			0x22, // #
+			0x23, // "
+			0x24, // '$'
+			0x25, // '%'
+			0x26, // '&'
+			0x27, // '
+			0x28, // '('
+			0x29, // ')'
+			0x2a, // '*'
+			0x2b, // '+'
+			0x2c, // 'ï¿½'
+			0x2d, // '-'
+			0x2e, //'.'
+			0x2f, // '/'
+			0x3a, // ':'
+			0x3b, // ';'
+			0x3c, // '<'
+			0x3d, // '='
+			0x3e, // '>' 
+			0x3f, // '?'
+			0x40, // @   <--- TODO: Debatable - is @ a delimiter of part of a string?
+			0x5b, // [
+			0x5c, // \
+			0x5d, // }
+			0x5e, // ^
+			0x5f, // _
+			0x7b, // {
+			0x7c, // |
+			0x7d, // }
+			0x7e, // ~
+	};
+
+	public void testNumericWithDefaultSet() {
+		Version v = null;
+		String formatString = "format(ndn):";
+		Integer one = Integer.valueOf(1);
+		Integer two = Integer.valueOf(2);
+		for (int i = 0; i < s_delim.length; i++) {
+			StringBuffer buf = new StringBuffer();
+			buf.append(formatString);
+			buf.append("1");
+			buf.append(s_delim[i]);
+			buf.append("2");
+			v = Version.parseVersion(buf.toString());
+			assertNotNull(v);
+			assertEquals(one, v.getSegment(0));
+			assertEquals(two, v.getSegment(1));
+		}
+	}
+
+	public void testStringWithDefaultSet() {
+		Version v = null;
+		String formatString = "format(sds):";
+		String one = "abc";
+		String two = "def";
+		for (int i = 0; i < s_delim.length; i++) {
+			StringBuffer buf = new StringBuffer();
+			buf.append(formatString);
+			buf.append(one);
+			buf.append(s_delim[i]);
+			buf.append(two);
+			v = Version.parseVersion(buf.toString());
+			assertNotNull(v);
+			assertEquals(one, v.getSegment(0));
+			assertEquals(two, v.getSegment(1));
+		}
+	}
+
+	public void testAccepted() {
+		Version v = Version.parseVersion("format((d=[A-Z];n){3}):A1B22C333");
+		assertNotNull(v);
+		assertEquals(Integer.valueOf(1), v.getSegment(0));
+		assertEquals(Integer.valueOf(22), v.getSegment(1));
+		assertEquals(Integer.valueOf(333), v.getSegment(2));
+
+		assertNotNull(v = Version.parseVersion("format((d=[ABZ];S=[^ABZ];){3}):Aa1Bb22Zc333"));
+		assertEquals("a1", v.getSegment(0));
+		assertEquals("b22", v.getSegment(1));
+		assertEquals("c333", v.getSegment(2));
+
+		assertNotNull(v = Version.parseVersion("format((d=[A-Za-z];+n)+):Aa1Bb22Zc333"));
+		assertEquals(Integer.valueOf(1), v.getSegment(0));
+		assertEquals(Integer.valueOf(22), v.getSegment(1));
+		assertEquals(Integer.valueOf(333), v.getSegment(2));
+
+		// note that \\ below results in one \ because of java String parsing
+		assertNotNull(v = Version.parseVersion("format((d=[\\\\[\\]];n)+):[1\\22]333"));
+		assertEquals(Integer.valueOf(1), v.getSegment(0));
+		assertEquals(Integer.valueOf(22), v.getSegment(1));
+		assertEquals(Integer.valueOf(333), v.getSegment(2));
+	}
+
+	public void testRejected() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("format((d=[^.:];S=[a-z0-9];){3}):/a1;b22=c333"));
+		assertEquals("a1", v.getSegment(0));
+		assertEquals("b22", v.getSegment(1));
+		assertEquals("c333", v.getSegment(2));
+	}
+
+	public void testExplicit() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("format('epoch='n';''major='n';''minor='n';'):epoch=1;major=22;minor=333;"));
+		assertEquals(Integer.valueOf(1), v.getSegment(0));
+		assertEquals(Integer.valueOf(22), v.getSegment(1));
+		assertEquals(Integer.valueOf(333), v.getSegment(2));
+
+		assertNotNull(v = Version.parseVersion("format('epoch='S=[^.];d'major='S=[^.];d'minor='S):epoch=a1ma.major=b22mi.minor=c333"));
+		assertEquals("a1ma", v.getSegment(0));
+		assertEquals("b22mi", v.getSegment(1));
+		assertEquals("c333", v.getSegment(2));
+
+	}
+
+	public void testCounted() {
+		// repeated d, char count d, and counted d are equal
+		Version v1 = Version.parseVersion("format(dddn):///1");
+		Version v2 = Version.parseVersion("format(d{3}n):///1");
+		assertNotNull(v1);
+		assertNotNull(v2);
+		Integer one = Integer.valueOf(1);
+		assertEquals(one, v1.getSegment(0));
+		assertEquals(one, v2.getSegment(0));
+
+	}
+
+	public void testIllegalCharCount() {
+		try {
+			Version.parseVersion("format(d={3};n):///1");
+			fail("Uncaught error: char count can not be used with 'd'");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	public void testIllegalAsPad() {
+		try {
+			Version.parseVersion("format(nd=pm;n):1.0");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testIllegalWithDefault() {
+		try {
+			Version.parseVersion("format(nd='a';n):1.0");
+			fail("Uncaught error: 'd' can not have a default value");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	/**
+	 * Ignore of d is illegal as d is already ignored.
+	 */
+	public void testIllegalIgnore() {
+		try {
+			Version.parseVersion("format(nd=!;n):1.0");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatNTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatNTest.java
new file mode 100644
index 0000000..a4b94d0
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatNTest.java
@@ -0,0 +1,122 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests format(n) and format(N)
+ *
+ */
+public class FormatNTest extends TestCase {
+	public void testNonNegative() {
+		Version v = Version.parseVersion("format(n):1");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n):0"));
+		assertEquals(Version.parseVersion("raw:0"), v);
+
+		try {
+			Version.parseVersion("format(n):-1");
+			fail("Uncaught exception: negative number in 'n' format");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testNegativeValues() {
+		Version v = Version.parseVersion("format(N):-1");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:-1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(N):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(N):0"));
+		assertEquals(Version.parseVersion("raw:0"), v);
+	}
+
+	public void testLeadingZeros() {
+		Version v = Version.parseVersion("format(n):000001");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(N):-000001"));
+		assertEquals(Version.parseVersion("raw:-1"), v);
+	}
+
+	public void testExact() {
+		Version v = Version.parseVersion("format(n={2};n={2};):1122");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:11.22"), v);
+
+		assertNotNull(v = Version.parseVersion("format(N={4};N={1};):-1234"));
+		assertEquals(Version.parseVersion("raw:-123.4"), v);
+
+		assertNotNull(v = Version.parseVersion("format(N={4};N={3};):-001234"));
+		assertEquals(Version.parseVersion("raw:-1.234"), v);
+
+		try {
+			v = Version.parseVersion("format(n={2};.;n={2};):1.2");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			v = Version.parseVersion("format(n={2};.;n={2};):111.2222");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testAtLeast() {
+		Version v = Version.parseVersion("format(n={2,};.n={2,};):111.22222");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:111.22222"), v);
+		try {
+			v = Version.parseVersion("format(n={2,};.;n={2};):111.2");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testAtMost() {
+		Version v = Version.parseVersion("format(n={2,3};.n={2,3};):111.22");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:111.22"), v);
+		try {
+			v = Version.parseVersion("format(n={2,3};.n={2,3};):111.2222");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			v = Version.parseVersion("format(n={2,3};.n={2,3};):1.222");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testNIsGreedy() {
+		try {
+			Version.parseVersion("format(nn):1010");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatPTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatPTest.java
new file mode 100644
index 0000000..71426c1
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatPTest.java
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+public class FormatPTest extends TestCase {
+	public void testPad() {
+		Version v = Version.parseVersion("format(qp):''pm");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:''pm"), v);
+	}
+
+	public void testArrayPad() {
+		Version v = Version.parseVersion("format(r):<''pm>");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:<''pm>"), v);
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatProcessingTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatProcessingTest.java
new file mode 100644
index 0000000..e9e759a
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatProcessingTest.java
@@ -0,0 +1,255 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests processing rules not tested elsewhere, and combinations of processing rules.
+ *
+ */
+public class FormatProcessingTest extends TestCase {
+
+	public void testIgnore() {
+		Version v = Version.parseVersion("format(n=!;.n.n):100.1.2");
+		assertNotNull(v);
+		assertEquals(Integer.valueOf(1), v.getSegment(0));
+		assertEquals(Integer.valueOf(2), v.getSegment(1));
+	}
+
+	public void testDefaultArrayWithPad() {
+		Version v = Version.parseVersion("format(s.?<n.n>=<1.0pm>;=p10;?):alpha");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'alpha'.<1.0pm>"), v);
+
+		assertNotNull(v = Version.parseVersion("format(s.?<n.n>=<1.0pm>;=p10;?):alpha.1.2"));
+		assertEquals(Version.parseVersion("raw:'alpha'.<1.2p10>"), v);
+	}
+
+	public void testDefaultValues() {
+		Version v = Version.parseVersion("format(n.[n=1;].?[s='foo';].?[a='bar';].?[a=2;]):9.");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:9.1.'foo'.'bar'.2"), v);
+	}
+
+	public void testArrayDefaultValues() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("format(n.<n.n>=<1.0>;?):9."));
+		assertEquals(Version.parseVersion("raw:9.<1.0>"), v);
+
+		// array parses, so individual defaults are used
+		assertNotNull(v = Version.parseVersion("format(n.<n=3;?.?n=4;?>=<1.0>;?):9."));
+		assertEquals("individual defaults should be used", Version.parseVersion("raw:9.<3.4>"), v);
+
+		// array does not parse, individual values are not used
+		assertNotNull(v = Version.parseVersion("format(n.<n=3;?.n=4;?>=<1.0>;?):9."));
+		assertEquals("individual defaults should not be used", Version.parseVersion("raw:9.<1.0>"), v);
+	}
+
+	public void testOtherTypeAsDefault() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("format(s=123;?n):1"));
+		assertEquals("#1.1", Version.parseVersion("raw:123.1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(s=M;?n):1"));
+		assertEquals("#1.2", Version.parseVersion("raw:M.1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(s=-M;?n):1"));
+		assertEquals("#1.3", Version.parseVersion("raw:-M.1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(s=<1.2>;?n):1"));
+		assertEquals("#1.4", Version.parseVersion("raw:<1.2>.1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n='abc';?s):a"));
+		assertEquals("#2.1", Version.parseVersion("raw:'abc'.'a'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n=M;?s):a"));
+		assertEquals("#2.2", Version.parseVersion("raw:M.'a'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n=-M;?s):a"));
+		assertEquals("#2.3", Version.parseVersion("raw:-M.'a'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n=<'a'.'b'>;?n):1"));
+		assertEquals("#2.4", Version.parseVersion("raw:<'a'.'b'>.1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(<n>='abc';?s):a"));
+		assertEquals("#3.1", Version.parseVersion("raw:'abc'.'a'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(<n>=M;?s):a"));
+		assertEquals("#3.2", Version.parseVersion("raw:M.'a'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(<n>=-M;?s):a"));
+		assertEquals("#3.3", Version.parseVersion("raw:-M.'a'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(<n>=123;?s):a"));
+		assertEquals("#3.4", Version.parseVersion("raw:123.'a'"), v);
+
+	}
+
+	/**
+	 * A processing rule can only be applied once to the preceding element.
+	 * (These tests check if the same processing can be applied twice).
+	 */
+	public void testSameMoreThanOnce() {
+		try {
+			Version.parseVersion("format(n=!;=!;.n):1.2");
+			fail("error not detected:2 x =!;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(s=[abc];=[123];.n):abc123.2");
+			fail("error not detected:2 x =[];");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(nd=[^:];=[^:];n):1.2");
+			fail("error not detected:2x [^];");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(n={1,3};={1,3};.n):1.2");
+			fail("error not detected:2x ={ };");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(n=0;=1;.n):1.2");
+			fail("error not detected:2x =default value");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format((n.n)=pm;=pm;):1.2");
+			fail("error not detected:2x =pm;");
+
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	/**
+	 * Tests that it is not allowed to have both =[]; and =[^] at the same time.
+	 */
+	public void testSetNotSet() {
+		try {
+			Version.parseVersion("format(nd=[a-z];=[^.:];n):1.2");
+			fail("error not detected: =[];=[^];");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	/**
+	 * Pad can only be combined with default value.
+	 */
+	public void testBadPadCombinations() {
+		try {
+			Version.parseVersion("format((n.n)=pm;=[abc];):1.2");
+			fail("error not detected: =p; =[];");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format((n.n)=pm;=[^.:];):1.2");
+			fail("error not detected: =p; =[];");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format((n.n)=pm;={1,3};):1.2");
+			fail("error not detected: =p; ={};");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format((n.n)=pm;=!;):1.2");
+			fail("error not detected: =p; =!;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testNonPaddable() {
+		try {
+			Version.parseVersion("format(n=pm;):1");
+			fail("error not detected: n=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(N=pm;):1");
+			fail("error not detected: n=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(s=pm;):a");
+			fail("error not detected: s=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(S=pm;):a");
+			fail("error not detected: S=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(a=pm;):a");
+			fail("error not detected: a=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(d=pm;):a");
+			fail("error not detected: d=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q=pm;):a");
+			fail("error not detected: q=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(r=pm;):a");
+			fail("error not detected: q=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format('x'=pm;n):x1");
+			fail("error not detected: 'x'=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(.=pm;n):x1");
+			fail("error not detected: .=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(p=pm;n):x1");
+			fail("error not detected: p=p;");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatQTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatQTest.java
new file mode 100644
index 0000000..04dce17
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatQTest.java
@@ -0,0 +1,313 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests format(q)
+ * smart quoted string - matches a quoted alphanumeric string where the quote is determined by the first 
+ * character of the string segment. The quote must be a non alphanumeric character, and the string
+ * must be delimited by the same character except brackets and parenthesises (i.e. (), {}, [], <>) which are
+ * handled as pairs, thus 'q' matches "<andrea-doria>" and produces a single string segment with the text 'andrea-doria'. 
+ * A non-quoted sequence of characters are not matched by 'q'.
+ * 
+ */
+public class FormatQTest extends TestCase {
+	public void testQuoteFormatParsing() {
+		Version aVer = Version.parseVersion("raw:'a'");
+		assertNotNull(aVer);
+
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("format(q):'a'"));
+		assertEquals(aVer, v);
+		assertNotNull(v = Version.parseVersion("format(q):\"a\""));
+		assertEquals(aVer, v);
+		assertNotNull(v = Version.parseVersion("format(q):=a="));
+		assertEquals(aVer, v);
+		assertNotNull(v = Version.parseVersion("format(q):#a#"));
+		assertEquals(aVer, v);
+		assertNotNull(v = Version.parseVersion("format(q):!a!"));
+		assertEquals(aVer, v);
+		assertNotNull(v = Version.parseVersion("format(q):|a|"));
+		assertEquals(aVer, v);
+
+	}
+
+	public void testQUnbalancedQuoteR() {
+		try {
+			Version.parseVersion("format(q):'a");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testQUnbalancedQuoteL() {
+		try {
+			Version.parseVersion("format(q):a'");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testQuotedFormatPairsParsing() {
+		Version aVer = Version.parseVersion("raw:'a'");
+		assertNotNull(aVer);
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("format(q):(a)"));
+		assertEquals(aVer, v);
+		assertNotNull(v = Version.parseVersion("format(q):<a>"));
+		assertEquals(aVer, v);
+		assertNotNull(v = Version.parseVersion("format(q):[a]"));
+		assertEquals(aVer, v);
+		assertNotNull(v = Version.parseVersion("format(q):{a}"));
+		assertEquals(aVer, v);
+	}
+
+	public void testQUnbalancedPair1() {
+		try {
+			Version.parseVersion("format(q):(a");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):a)");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):(a(");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):)a)");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testQUnbalancedPair2() {
+		try {
+			Version.parseVersion("format(q):[a");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):a]");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):[a[");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):]a]");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testQUnbalancedPair3() {
+		try {
+			Version.parseVersion("format(q):<a");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):a>");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):<a<");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):>a>");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testQUnbalancedPair4() {
+		try {
+			Version.parseVersion("format(q):{a");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):a}");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):{a{");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):}a}");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testQUnbalancedPair5() {
+		// not all erroneous permutations tested - only principle that open and close must be from "matching pair"
+		// it should be enough to cover a faulty implementation
+		try {
+			Version.parseVersion("format(q):(a}");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):[a}");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):{a]");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q):<a)");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testExact() {
+		Version v = Version.parseVersion("format(q={4};q):<123a>\"bc456'def'\"");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'123a'.\"bc456'def'\""), v);
+
+		assertNotNull(v = Version.parseVersion("format(q={2};q):<ab><c>"));
+		assertEquals(Version.parseVersion("raw:'ab'.'c'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(q={2};S):'12'3"));
+		assertEquals(Version.parseVersion("raw:'12'.'3'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(q={4};q={1};q={3};):<123a>'b'(c45)"));
+		assertEquals(Version.parseVersion("raw:'123a'.'b'.'c45'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(q={2};.q={1};qq={3};):<12>.<3>'456'<abc>"));
+		assertEquals(Version.parseVersion("raw:'12'.'3'.'456'.'abc'"), v);
+
+		try {
+			Version.parseVersion("format(q={4};.q):123.(abc456)'def'");
+			fail("Uncaught error: quoted string is longer than 4");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q={4};q):<123>(abc456'def')");
+			fail("Uncaught error: quoted string is shorter than 4");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testAtLeast() {
+		Version v = Version.parseVersion("format(q={2,};):(123abc456'def')");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:\"123abc456'def'\""), v);
+
+		assertNotNull(v = Version.parseVersion("format(q={2,};):<123abc456'def'>"));
+		assertEquals(Version.parseVersion("raw:\"123abc456'def'\""), v);
+
+		assertNotNull(v = Version.parseVersion("format(q={2,};.q):(123a).(bc456'def')"));
+		assertEquals(Version.parseVersion("raw:'123a'.\"bc456'def'\""), v);
+
+		assertNotNull(v = Version.parseVersion("format(q={2,};q):<123a>(bc456'def')"));
+		assertEquals(Version.parseVersion("raw:'123a'.\"bc456'def'\""), v);
+
+		try {
+			Version.parseVersion("format(q={2,};.q):1.abc456'def'");
+			fail("Uncaught error: first segment is shorter than 2");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q={2,};q):<1>(abc456'def')");
+			fail("Uncaught error: firt segment is shorter than 2");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q={2,};.q={10,};):(12).(abc456'd')");
+			fail("Uncaught error: last segment is shorter than 10");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(q={2,};.q={10,};):<12>.abc456'd'");
+			fail("Uncaught error: second segment is not quoted");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testAtMost() {
+		// exact request
+		Version v = Version.parseVersion("format(q={1,3};q={1,2};q):<123><ab><c456'def'>");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'123'.'ab'.\"c456'def'\""), v);
+
+		// request for more than available
+		assertNotNull(v = Version.parseVersion("format(q={1,4};q={1,4};q):<123><abc4><56'def'>"));
+		assertEquals(Version.parseVersion("raw:'123'.'abc4'.\"56'def'\""), v);
+
+		try {
+			// fails because first segment is shorter
+			Version.parseVersion("format(q={2,3};q):<1><abc456'def'>");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			// fails because there are trailing characters after 'c'
+			Version.parseVersion("format(q={2,3};q={2,3};):<12><abc456'd'>");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatRTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatRTest.java
new file mode 100644
index 0000000..6d1fd8e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatRTest.java
@@ -0,0 +1,85 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests format(r)
+ *
+ */
+public class FormatRTest extends TestCase {
+
+	public void testNumeric() {
+		Version v = Version.parseVersion("format(r):1");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:1"), v);
+	}
+
+	public void testNegativeNumeric() {
+		Version v = Version.parseVersion("format(r):-1");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:-1"), v);
+	}
+
+	public void testString() {
+		Version v = Version.parseVersion("format(r):'a'");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'a'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(r):\"a\""));
+		assertEquals(Version.parseVersion("raw:'a'"), v);
+	}
+
+	public void testConcatentatedStrings() {
+		Version v = Version.parseVersion("format(r):'a''b'");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'ab'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(r):'a has a \"hat\" it is '\"a's\""));
+		assertEquals(Version.parseVersion("raw:'a has a \"hat\" it is '\"a's\""), v);
+	}
+
+	public void testMaxString() {
+		Version v = Version.parseVersion("format(r):m");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:m"), v);
+	}
+
+	public void testMaxNumeric() {
+		Version v = Version.parseVersion("format(r):M");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:M"), v);
+	}
+
+	public void testArray() {
+		Version v = Version.parseVersion("format(r):<1>");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:<1>"), v);
+	}
+
+	public void testNonRElements() {
+		try {
+			Version.parseVersion("format(r):aaa");
+			fail("a is not a valid raw element");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(r):1,2");
+			fail("comma is not a delimiter in raw format");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatRangeTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatRangeTest.java
new file mode 100644
index 0000000..803a61a
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatRangeTest.java
@@ -0,0 +1,101 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+
+/**
+ * Tests ranges using format(xxx) version strings.
+ *
+ */
+public class FormatRangeTest extends VersionTesting {
+	public static String OSGI_PREFIX = "format([n=0;[.n=0;[.n=0;[.s]]]]):";
+
+	public void testRangeWithDefaultValues() {
+		VersionRange range = new VersionRange(OSGI_PREFIX + "0");
+		assertIncludedInRange("#1", range, OSGI_PREFIX + "0");
+		assertIncludedInRange("#1", range, OSGI_PREFIX + "M");
+		assertIncludedInRange("#2", range, OSGI_PREFIX + "(M)=pM;");
+	}
+
+	public void testEmptyRange() {
+		try {
+			new VersionRange(OSGI_PREFIX);
+			fail("Uncught error: range can not be empty");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testRangeDelimitersInVersionString() {
+		VersionRange range = new VersionRange("format(S):[one\\, two,three\\, \\[and\\] four]");
+		assertIncludedInRange("#1", range, "format(S):one, two");
+		assertIncludedInRange("#1", range, "format(S):three, [and] four");
+	}
+
+	public void testSingleVersionRange() {
+		VersionRange range = new VersionRange(OSGI_PREFIX + "[1.0.0, 1.0.0.'-')");
+		assertEquals("0.1", Version.parseVersion(OSGI_PREFIX + "1.0.0"), range.getMinimum());
+		assertEquals("0.2", Version.parseVersion(OSGI_PREFIX + "1.0.0.'-'"), range.getMaximum());
+
+		assertNotIncludedInRange("0.9", range, OSGI_PREFIX + "0.9");
+		assertNotIncludedInRange("1.0", range, OSGI_PREFIX + "1"); // this is not osgi versions 1 is before than 1.0
+		assertNotIncludedInRange("1.1", range, OSGI_PREFIX + "1.0"); // this is not osgi, version 1.0 is before 1.0.0
+		assertIncludedInRange("1.2", range, OSGI_PREFIX + "1.0.0");
+		assertNotIncludedInRange("2.1", range, OSGI_PREFIX + "1.0.0.'0'");
+		assertNotIncludedInRange("2.2", range, OSGI_PREFIX + "1.0.1");
+		assertNotIncludedInRange("2.3", range, OSGI_PREFIX + "1.1");
+		assertNotIncludedInRange("2.4", range, OSGI_PREFIX + "2");
+	}
+
+	public void testInvertedRange() {
+		VersionRange range = new VersionRange(OSGI_PREFIX + "[2.0.0, 1.0.0]");
+		assertNotIncludedInRange("1.0", range, OSGI_PREFIX + "1.0");
+		assertNotIncludedInRange("1.1", range, OSGI_PREFIX + "1.5.0");
+		assertNotIncludedInRange("1.2", range, OSGI_PREFIX + "2.0.0");
+		assertNotIncludedInRange("1.3", range, OSGI_PREFIX + "2.5.0");
+		assertNotIncludedInRange("1.4", range, OSGI_PREFIX + "0.5.0");
+	}
+
+	public void testGreaterThan() {
+		// any version equal or greater than 1.0.0 is ok 
+		VersionRange lowerBound = new VersionRange(OSGI_PREFIX + "1.0.0");
+		assertNotIncludedInRange("1.0", lowerBound, OSGI_PREFIX + "0.9.0");
+		assertIncludedInRange("1.1", lowerBound, OSGI_PREFIX + "1.0.0");
+		assertIncludedInRange("1.2", lowerBound, OSGI_PREFIX + "1.9.9.'x'");
+		assertIncludedInRange("1.3", lowerBound, OSGI_PREFIX + "999.999.999.'foo'");
+		assertIncludedInRange("1.3", lowerBound, OSGI_PREFIX + "M.M.M.m");
+	}
+
+	public void testGreaterThanEmptyString() {
+		// any version equal or greater than '' (empty string) is ok 
+		VersionRange lowerBound = new VersionRange(OSGI_PREFIX + "''");
+		assertIncludedInRange("0.1", lowerBound, OSGI_PREFIX + "''");
+		assertIncludedInRange("1.0", lowerBound, OSGI_PREFIX + "0.9.0");
+		assertIncludedInRange("1.1", lowerBound, OSGI_PREFIX + "1.0.0");
+		assertIncludedInRange("1.2", lowerBound, OSGI_PREFIX + "1.9.9.'x'");
+		assertIncludedInRange("1.3", lowerBound, OSGI_PREFIX + "999.999.999.'foo'");
+		assertIncludedInRange("1.3", lowerBound, OSGI_PREFIX + "M.M.M.m");
+	}
+
+	public void testLowerThan() {
+		// any version lower than 2.0 is ok 		
+		VersionRange upperBound = new VersionRange(OSGI_PREFIX + "[0, 2.0.0)");
+		assertIncludedInRange("1.0", upperBound, OSGI_PREFIX + "0.0");
+		assertIncludedInRange("1.1", upperBound, OSGI_PREFIX + "0.9");
+		assertIncludedInRange("1.2", upperBound, OSGI_PREFIX + "1.0");
+		assertIncludedInRange("1.3", upperBound, OSGI_PREFIX + "1.9.9.'x'");
+		assertNotIncludedInRange("1.4", upperBound, OSGI_PREFIX + "2.0");
+		assertNotIncludedInRange("1.5", upperBound, OSGI_PREFIX + "2.1");
+	}
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatSTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatSTest.java
new file mode 100644
index 0000000..64e3e5e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatSTest.java
@@ -0,0 +1,192 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests format(s), and format(S)
+ * 
+ * a string group matching any character except any following 
+ * explicit/optional delimiter. Use processing rules =[]; or =[^] to define the set of allowed characters.
+ * 
+ */
+public class FormatSTest extends TestCase {
+	public void testStringAcceptDigit() {
+		Version v = Version.parseVersion("format(S):1");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'1'"), v);
+		try {
+			Version.parseVersion("format(s):1");
+			fail("Uncaught error: s should not accept digits");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testStringAcceptAlpha() {
+		Version v = Version.parseVersion("format(s):a");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'a'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(S):a"));
+		assertEquals(Version.parseVersion("raw:'a'"), v);
+	}
+
+	public void testStringDelimitedByNumeric() {
+		Version v = Version.parseVersion("format(sn):foobar123");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'foobar'.123"), v);
+		try {
+			Version.parseVersion("format(Sn):foobar123");
+			fail("Uncaught error: S should eat entire string, no n found at the end");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testStringWithSpace() {
+		Version v;
+
+		assertNotNull(v = Version.parseVersion("format(S=[^0-9];n):foo bar123"));
+		assertEquals(Version.parseVersion("raw:'foo bar'.123"), v);
+
+		// Test 's' with attempt to include 'space' and delimiters
+		//
+		try {
+			Version.parseVersion("format(s=[^];n):foo bar123");
+			fail("Uncaught error: format(s) can not match non letters (space).");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testStringDelimitedByDelimiter() {
+		Version v = Version.parseVersion("format(s.n):foobar.123");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'foobar'.123"), v);
+
+		assertNotNull(v = Version.parseVersion("format(S=[^.];.n):foobar.123"));
+		assertEquals(Version.parseVersion("raw:'foobar'.123"), v);
+	}
+
+	public void testStringDelimitedByExplicitDelimiter() {
+		Version v = Version.parseVersion("format(s=[^r];d=[r];n):foobar123");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'fooba'.123"), v);
+	}
+
+	public void testStringWithAllowedSet() {
+		Version v = Version.parseVersion("format(s=[a-z];sn):fooBAR123");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'foo'.'BAR'.123"), v);
+	}
+
+	public void testStringWithDisallowedSet() {
+		Version v = Version.parseVersion("format(s=[^a-z];sn):FOObar123");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'FOO'.'bar'.123"), v);
+	}
+
+	public void testExact() {
+		Version v = Version.parseVersion("format(S={4};S):123abc456'def'");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'123a'.\"bc456'def'\""), v);
+
+		assertNotNull(v = Version.parseVersion("format(s={2};s):abc"));
+		assertEquals(Version.parseVersion("raw:'ab'.'c'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(S={2};S):abc"));
+		assertEquals(Version.parseVersion("raw:'ab'.'c'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(S={2};S):123"));
+		assertEquals(Version.parseVersion("raw:'12'.'3'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(S={4};S={1};S={3};):123abc45"));
+		assertEquals(Version.parseVersion("raw:'123a'.'b'.'c45'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(S={2};.S={1};s={3};):12.3abc"));
+		assertEquals(Version.parseVersion("raw:'12'.'3'.'abc'"), v);
+
+		try {
+			Version.parseVersion("format(s={4};.s):aaa.abc456'def'");
+			fail("Uncaught error: first segment is less than 4 chars long");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(s={4};.s):123.abc456'def'");
+			fail("Uncaught error: first segment has digits");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(S={4}=[^.];.S):123.abc456'def'");
+			fail("Uncaught error: first segment has only 3 characters");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	/**
+	 * Test that unbound upper range is just a limit on lower range. Upper delimiter must be a delimiter.
+	 */
+	public void testAtLeast() {
+		Version v = Version.parseVersion("format(S={2,};):123abc456'def'");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:\"123abc456'def'\""), v);
+
+		assertNotNull(v = Version.parseVersion("format(S={2,};=[^.];.S):123a.bc456'def'"));
+		assertEquals(Version.parseVersion("raw:'123a'.\"bc456'def'\""), v);
+
+		try {
+			Version.parseVersion("format(s={2,};.S):a.abc456'def'");
+			fail("uncaught error: first segment is shorter than 2");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(s={2,};.s={10,};):aa.abcd");
+			fail("Uncaught error: secont segment too short");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testAtMost() {
+		Version v = Version.parseVersion("format(S={1,3};S={1,2};S):123abc456'def'");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:'123'.'ab'.\"c456'def'\""), v);
+
+		// delimited by delimiter
+		assertNotNull(v = Version.parseVersion("format(S={1,4};=[^.];.S={1,4};.S):123.abc4.56'def'"));
+		assertEquals(Version.parseVersion("raw:'123'.'abc4'.\"56'def'\""), v);
+
+		try {
+			// fails because of delimiter after one char
+			Version.parseVersion("format(s={2,3};s):a.abc456'def'");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			// fails because there are trailing characters after 'c'
+			Version.parseVersion("format(s={2,3};.S={2,3};):aa.abc456'd'");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatTest.java
new file mode 100644
index 0000000..ee4b455
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/FormatTest.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Test of format() performing tests not covered by tests per rule.
+ * 
+ */
+public class FormatTest extends TestCase {
+
+	public void testEmptySegmentsRemoved() {
+		Version v = Version.parseVersion("format(ndddn):1...2");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), Integer.valueOf(1));
+		assertEquals(v.getSegment(1), Integer.valueOf(2));
+	}
+
+	public void testGreedyParsing() {
+		Version v = Version.parseVersion("format(n(.n)*(.s)*):1.2.3.hello");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:1.2.3.'hello'"), v);
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/IntersectionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/IntersectionTest.java
new file mode 100644
index 0000000..7141c78
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/IntersectionTest.java
@@ -0,0 +1,189 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+
+/**
+ * Tests intersection of VersionRanges.
+ * - non overlapping ranges
+ * - straddle lower or upper bound
+ * - equal range
+ * - same lower bound - upper inside
+ * - same upper bound - lower inside
+ * - inside 
+ * 
+ * Tests made with both inclusive and non inclusive values.
+ * 
+ */
+public class IntersectionTest extends TestCase {
+	public void testIntersectsEmpty() {
+		VersionRange a = new VersionRange("raw:[1.0.0,3.0.0]");
+		VersionRange b = new VersionRange("raw:[4.0.0,6.0.0]");
+		assertTrue("Non overlapping ranges a/b should be empty #1", a.intersect(b) == null);
+		assertTrue("Non overlapping ranges b/a should be empty #2", b.intersect(a) == null);
+
+		a = new VersionRange("raw:[1.0.0,3.0.0]");
+		b = new VersionRange("raw:(3.0.0,6.0.0]");
+		assertTrue("Non overlapping ranges a/b should be empty #3", a.intersect(b) == null);
+		assertTrue("Non overlapping ranges b/a should be empty #4", b.intersect(a) == null);
+
+		a = new VersionRange("raw:[1.0.0,3.0.0)");
+		b = new VersionRange("raw:[3.0.0,6.0.0]");
+		assertTrue("Non overlapping ranges a/b should be empty #5", a.intersect(b) == null);
+		assertTrue("Non overlapping ranges b/a should be empty #6", b.intersect(a) == null);
+	}
+
+	public void testStraddleBoundary() {
+		VersionRange a = new VersionRange("raw:[1.0.0,3.0.0]");
+		VersionRange b = new VersionRange("raw:[2.0.0,6.0.0]");
+		VersionRange r = a.intersect(b);
+		assertEquals("#1.1", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#1.2", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#1.3", r.getIncludeMaximum());
+		assertTrue("#1.4", r.getIncludeMinimum());
+
+		r = b.intersect(a);
+		assertEquals("#2.1", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#2.2", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#2.3", r.getIncludeMaximum());
+		assertTrue("#2.4", r.getIncludeMinimum());
+
+		a = new VersionRange("raw:[1.0.0,3.0.0)");
+		b = new VersionRange("raw:(2.0.0,6.0.0]");
+		r = a.intersect(b);
+		assertEquals("#3.1", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#3.2", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#3.3", !r.getIncludeMaximum());
+		assertTrue("#3.4", !r.getIncludeMinimum());
+
+		r = b.intersect(a);
+		assertEquals("#4.1", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#4.2", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#4.3", !r.getIncludeMaximum());
+		assertTrue("#4.4", !r.getIncludeMinimum());
+
+	}
+
+	public void testEqualRanges() {
+		VersionRange a = new VersionRange("raw:[1.0.0,3.0.0]");
+		VersionRange b = new VersionRange("raw:[1.0.0,3.0.0]");
+		VersionRange r = a.intersect(b);
+		assertEquals("#1.1", Version.parseVersion("raw:1.0.0"), r.getMinimum());
+		assertEquals("#1.2", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#1.3", r.getIncludeMaximum());
+		assertTrue("#1.4", r.getIncludeMinimum());
+		r = b.intersect(a);
+		assertEquals("#1.5", Version.parseVersion("raw:1.0.0"), r.getMinimum());
+		assertEquals("#1.6", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#1.7", r.getIncludeMaximum());
+		assertTrue("#1.8", r.getIncludeMinimum());
+
+		a = new VersionRange("raw:(1.0.0,3.0.0)");
+		b = new VersionRange("raw:(1.0.0,3.0.0)");
+		r = a.intersect(b);
+		assertEquals("#2.1", Version.parseVersion("raw:1.0.0"), r.getMinimum());
+		assertEquals("#2.2", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#2.3", !r.getIncludeMaximum());
+		assertTrue("#2.4", !r.getIncludeMinimum());
+		r = b.intersect(a);
+		assertEquals("#2.5", Version.parseVersion("raw:1.0.0"), r.getMinimum());
+		assertEquals("#2.6", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#2.7", !r.getIncludeMaximum());
+		assertTrue("#2.8", !r.getIncludeMinimum());
+	}
+
+	public void testPartialEqualLower() {
+		VersionRange a = new VersionRange("raw:[1.0.0,3.0.0]");
+		VersionRange b = new VersionRange("raw:[1.0.0,2.0.0]");
+		VersionRange r = a.intersect(b);
+		assertEquals("#1.1", Version.parseVersion("raw:1.0.0"), r.getMinimum());
+		assertEquals("#1.2", Version.parseVersion("raw:2.0.0"), r.getMaximum());
+		assertTrue("#1.3", r.getIncludeMaximum());
+		assertTrue("#1.4", r.getIncludeMinimum());
+		r = b.intersect(a);
+		assertEquals("#1.4", Version.parseVersion("raw:1.0.0"), r.getMinimum());
+		assertEquals("#1.6", Version.parseVersion("raw:2.0.0"), r.getMaximum());
+		assertTrue("#1.7", r.getIncludeMaximum());
+		assertTrue("#1.8", r.getIncludeMinimum());
+
+		b = new VersionRange("raw:[1.0.0,2.0.0)");
+		r = a.intersect(b);
+		assertEquals("#2.1", Version.parseVersion("raw:1.0.0"), r.getMinimum());
+		assertEquals("#2.2", Version.parseVersion("raw:2.0.0"), r.getMaximum());
+		assertTrue("#2.3", !r.getIncludeMaximum());
+		assertTrue("#2.4", r.getIncludeMinimum());
+		r = b.intersect(a);
+		assertEquals("#2.4", Version.parseVersion("raw:1.0.0"), r.getMinimum());
+		assertEquals("#2.6", Version.parseVersion("raw:2.0.0"), r.getMaximum());
+		assertTrue("#2.7", !r.getIncludeMaximum());
+		assertTrue("#2.8", r.getIncludeMinimum());
+
+	}
+
+	public void testPartialEqualUpper() {
+		VersionRange a = new VersionRange("raw:[1.0.0,3.0.0]");
+		VersionRange b = new VersionRange("raw:[2.0.0,3.0.0]");
+		VersionRange r = a.intersect(b);
+		assertEquals("#1.1", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#1.2", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#1.3", r.getIncludeMaximum());
+		assertTrue("#1.4", r.getIncludeMinimum());
+		r = b.intersect(a);
+		assertEquals("#1.4", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#1.6", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#1.7", r.getIncludeMaximum());
+		assertTrue("#1.8", r.getIncludeMinimum());
+
+		b = new VersionRange("raw:(2.0.0,3.0.0]");
+		r = a.intersect(b);
+		assertEquals("#2.1", Version.parseVersion("raw:1.0.0"), r.getMinimum());
+		assertEquals("#2.2", Version.parseVersion("raw:2.0.0"), r.getMaximum());
+		assertTrue("#2.3", r.getIncludeMaximum());
+		assertTrue("#2.4", !r.getIncludeMinimum());
+		r = b.intersect(a);
+		assertEquals("#2.4", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#2.6", Version.parseVersion("raw:3.0.0"), r.getMaximum());
+		assertTrue("#2.7", r.getIncludeMaximum());
+		assertTrue("#2.8", !r.getIncludeMinimum());
+	}
+
+	public void testFullyInside() {
+		VersionRange a = new VersionRange("raw:[1.0.0,3.0.0]");
+		VersionRange b = new VersionRange("raw:[2.0.0,2.5.0]");
+		VersionRange r = a.intersect(b);
+		assertEquals("#1.1", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#1.2", Version.parseVersion("raw:2.5.0"), r.getMaximum());
+		assertTrue("#1.3", r.getIncludeMaximum());
+		assertTrue("#1.4", r.getIncludeMinimum());
+		r = b.intersect(a);
+		assertEquals("#1.5", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#1.6", Version.parseVersion("raw:2.5.0"), r.getMaximum());
+		assertTrue("#1.7", r.getIncludeMaximum());
+		assertTrue("#1.8", r.getIncludeMinimum());
+
+		b = new VersionRange("raw:(2.0.0,2.5.0)");
+		r = a.intersect(b);
+		assertEquals("#2.1", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#2.2", Version.parseVersion("raw:2.5.0"), r.getMaximum());
+		assertTrue("#2.3", !r.getIncludeMaximum());
+		assertTrue("#2.4", !r.getIncludeMinimum());
+
+		r = b.intersect(a);
+		assertEquals("#2.5", Version.parseVersion("raw:2.0.0"), r.getMinimum());
+		assertEquals("#2.6", Version.parseVersion("raw:2.5.0"), r.getMaximum());
+		assertTrue("#2.7", !r.getIncludeMaximum());
+		assertTrue("#2.8", !r.getIncludeMinimum());
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/MultiplicityTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/MultiplicityTest.java
new file mode 100644
index 0000000..b5934a4
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/MultiplicityTest.java
@@ -0,0 +1,294 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests {n.m} in different combinations and the special +?*
+ *
+ */
+public class MultiplicityTest extends TestCase {
+	public void test01() {
+		// n? == [n] == n{0,1} 
+		Version v = Version.parseVersion("format(n?):1");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n[.n]):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+		assertNotNull(v = Version.parseVersion("format(n.?n?):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		try {
+			Version.parseVersion("format(n?):a");
+			fail("Uncaught error: format(n?):a");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		// with []
+		assertNotNull(v = Version.parseVersion("format([n]):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(s[n]):a"));
+		assertEquals(Version.parseVersion("raw:'a'"), v);
+		assertNotNull(v = Version.parseVersion("format(n[.][n]):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		try {
+			Version.parseVersion("format([n]):a");
+			fail("Uncaught error: format([n]):a");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+		// with {0,1}
+		assertNotNull(v = Version.parseVersion("format(n{0,1}):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(sn{0,1}):a"));
+		assertEquals(Version.parseVersion("raw:'a'"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n.?n{0,}):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		try {
+			Version.parseVersion("format(n{0,1}):a");
+			fail("Uncaught error: format(n{0,1}):a");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void test1M() {
+		// n+ == n{1,}
+		Version v = Version.parseVersion("format((nd?)+):1.2.3");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:1.2.3"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n+):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		try {
+			Version.parseVersion("format(n+):");
+			fail("Uncaught error: format(n+):");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(n+):a");
+			fail("Uncaught error: format(n+):a");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		// with {1,}
+		assertNotNull(v = Version.parseVersion("format((nd?){1,}):1.2.3"));
+		assertEquals(Version.parseVersion("raw:1.2.3"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n{1,}):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		try {
+			Version.parseVersion("format(n{1,}):");
+			fail("Uncaught error: format(n{1,}):");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(n{1,}):a");
+			fail("Uncaught error: format(n{1,}):a");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	public void test0M() {
+		// n* == n{0,}
+		Version v = Version.parseVersion("format((nd?)*):1.2.3");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:1.2.3"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n*):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(sn*):a"));
+		assertEquals(Version.parseVersion("raw:'a'"), v);
+
+		try {
+			Version.parseVersion("format(n*):a");
+			fail("Uncaught error: format(n*):a");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		// with {0,}
+		assertNotNull(v = Version.parseVersion("format((nd?){0,}):1.2.3"));
+		assertEquals(Version.parseVersion("raw:1.2.3"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n{0,}):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		assertNotNull(v = Version.parseVersion("format(sn{0,}):a"));
+		assertEquals(Version.parseVersion("raw:'a'"), v);
+
+		try {
+			Version.parseVersion("format(n{0,}):a");
+			fail("Uncaught error: format(n{0,}):a");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	public void testExact() {
+		// n{1}
+		Version v = Version.parseVersion("format((nd?){3}):1.2.3");
+		assertNotNull(v);
+		assertEquals(Version.parseVersion("raw:1.2.3"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n{1}):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		try {
+			Version.parseVersion("format(n{1}):");
+			fail("Uncaught error: format(n{1}):");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format((nd?){3}):1.2");
+			fail("Uncaught error: format((nd?){3}):1.2");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(n{1}):a");
+			fail("Uncaught error: format(n{1}):a");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testAtLeast() {
+		// n{>1,}
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("format((nd?){2,}):1.2.3"));
+		assertEquals(Version.parseVersion("raw:1.2.3"), v);
+		assertNotNull(v = Version.parseVersion("format((nd?){3,}):1.2.3"));
+		assertEquals(Version.parseVersion("raw:1.2.3"), v);
+
+		assertNotNull(v = Version.parseVersion("format(n{1,}):1"));
+		assertEquals(Version.parseVersion("raw:1"), v);
+
+		try {
+			Version.parseVersion("format(n{2,}):1");
+			fail("Uncaught error: format(n{1,}):1");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format((nd?){3,}):1.2");
+			fail("Uncaught error: format(n{3,1}):1.2");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	public void testAtMost() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("format((nd?){2,3}):1.2.3"));
+		assertEquals(Version.parseVersion("raw:1.2.3"), v);
+
+		assertNotNull(v = Version.parseVersion("format((nd?){2,3}):1.2"));
+		assertEquals(Version.parseVersion("raw:1.2"), v);
+
+		try {
+			Version.parseVersion("format(n{2,3}):1");
+			fail("Uncaught error: format(n{2,3}):1");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(n{2,3}):1.2.3.4");
+			fail("Uncaught error: format(n{2,3}):1.2.3.4");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testZeroExact() {
+		// Should not have entered a n{0} as it is meaningless.
+		try {
+			Version.parseVersion("format(n{0}):");
+			fail("Uncaught error: format(n{0}):");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format(n{0,0}):");
+			fail("Uncaught error: format(n{0,0}):");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	public void testMinGreaterThanMax() {
+		try {
+			Version.parseVersion("format((nd?){3,2}):1.2.3");
+			fail("Uncaught error: format((nd?){3,2}):1.2.3");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnbalancedBraceR() {
+		try {
+			Version.parseVersion("format((nd?){3,2):1.2.3");
+			fail("Uncaught error: format((nd?){3,2):1.2.3");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testNegativeRange() {
+		try {
+			Version.parseVersion("format((nd?){-1,2}):1.2.3");
+			fail("Uncaught error: format((nd?){-1,2}):1.2.3");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format((nd?){1,-2}):1.2.3");
+			fail("Uncaught error: format((nd?){1,-2}):1.2.3");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testStringRange() {
+		try {
+			Version.parseVersion("format((nd?){a,2}):1.2.3");
+			fail("Uncaught error: format((nd?){a,2}):1.2.3");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("format((nd?){1,a}):1.2.3");
+			fail("Uncaught error: format((nd?){1,a}):1.2.3");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/OSGiRangeTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/OSGiRangeTest.java
new file mode 100644
index 0000000..ef33057
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/OSGiRangeTest.java
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+
+/**
+ * Tests ranges of versions specified with osgi (default) version format.
+ *
+ */
+public class OSGiRangeTest extends VersionTesting {
+	public void testSingleVersionRange() {
+		VersionRange range;
+		range = new VersionRange("[1.0.0, 1.0.0.-)");
+		assertEquals("0.1", Version.parseVersion("1.0"), range.getMinimum());
+		assertTrue("0.9", !range.isIncluded(Version.parseVersion("0.9")));
+		assertTrue("1.0", range.isIncluded(Version.parseVersion("1")));
+		assertTrue("1.1", range.isIncluded(Version.parseVersion("1.0")));
+		assertTrue("1.2", range.isIncluded(Version.parseVersion("1.0.0")));
+		assertTrue("2.1", !range.isIncluded(Version.parseVersion("1.0.0.0")));
+		assertTrue("2.2", !range.isIncluded(Version.parseVersion("1.0.1")));
+		assertTrue("2.3", !range.isIncluded(Version.parseVersion("1.1")));
+		assertTrue("2.4", !range.isIncluded(Version.parseVersion("2")));
+	}
+
+	public void testInvertedRange() {
+		try {
+			new VersionRange("[2.0.0, 1.0.0]");
+			fail("Inverted range is not allowed");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testGreaterThan() {
+		// any version equal or greater than 1.0 is ok 
+		VersionRange lowerBound = new VersionRange("1.0.0");
+		assertTrue("1.0", !lowerBound.isIncluded(Version.parseVersion("0.9")));
+		assertTrue("1.1", lowerBound.isIncluded(Version.parseVersion("1.0")));
+		assertTrue("1.2", lowerBound.isIncluded(Version.parseVersion("1.9.9.x")));
+		assertTrue("1.3", lowerBound.isIncluded(Version.parseVersion("999.999.999.foo")));
+		assertTrue("2.0", !lowerBound.isIncluded(Version.parseVersion("raw:M")));
+		assertTrue("2.1", !lowerBound.isIncluded(Version.parseVersion("raw:2147483647.2147483647.2147483647.0")));
+
+	}
+
+	public void testLowerThan() {
+		// any version lower than 2.0 is ok 		
+		VersionRange upperBound = new VersionRange("[0,2.0)");
+		assertTrue("1.0", upperBound.isIncluded(Version.parseVersion("0.0")));
+		assertTrue("1.1", upperBound.isIncluded(Version.parseVersion("0.9")));
+		assertTrue("1.2", upperBound.isIncluded(Version.parseVersion("1.0")));
+		assertTrue("1.3", upperBound.isIncluded(Version.parseVersion("1.9.9.x")));
+		assertTrue("1.4", !upperBound.isIncluded(Version.parseVersion("2.0")));
+		assertTrue("1.5", !upperBound.isIncluded(Version.parseVersion("2.1")));
+	}
+
+	public void testRangeStrings() {
+		VersionRange v = null;
+
+		v = new VersionRange("1.0.0");
+		assertEquals("1.0.0", v.toString());
+		v = new VersionRange("[1.0.0,2.0.0]");
+		assertEquals("[1.0.0,2.0.0]", v.toString());
+		v = new VersionRange("(1.0.0,2.0.0]");
+		assertEquals("(1.0.0,2.0.0]", v.toString());
+		v = new VersionRange("[1.0.0,2.0.0)");
+		assertEquals("[1.0.0,2.0.0)", v.toString());
+		v = new VersionRange("(1.0.0,2.0.0)");
+		assertEquals("(1.0.0,2.0.0)", v.toString());
+
+		v = new VersionRange("1.0.0.abcdef");
+		assertEquals("1.0.0.abcdef", v.toString());
+		v = new VersionRange("[1.0.0.abcdef,2.0.0.abcdef]");
+		assertEquals("[1.0.0.abcdef,2.0.0.abcdef]", v.toString());
+		v = new VersionRange("(1.0.0.abcdef,2.0.0.abcdef]");
+		assertEquals("(1.0.0.abcdef,2.0.0.abcdef]", v.toString());
+		v = new VersionRange("[1.0.0.abcdef,2.0.0.abcdef)");
+		assertEquals("[1.0.0.abcdef,2.0.0.abcdef)", v.toString());
+		v = new VersionRange("(1.0.0.abcdef,2.0.0.abcdef)");
+		assertEquals("(1.0.0.abcdef,2.0.0.abcdef)", v.toString());
+	}
+
+	public void testSerialize() {
+		VersionRange v = null;
+
+		v = new VersionRange("1.0.0");
+		assertSerialized(v);
+		v = new VersionRange("[1.0.0,2.0.0]");
+		assertSerialized(v);
+		v = new VersionRange("(1.0.0,2.0.0]");
+		assertSerialized(v);
+		v = new VersionRange("[1.0.0,2.0.0)");
+		assertSerialized(v);
+		v = new VersionRange("(1.0.0,2.0.0)");
+		assertSerialized(v);
+
+		v = new VersionRange("1.0.0.abcdef");
+		assertSerialized(v);
+		v = new VersionRange("[1.0.0.abcdef,2.0.0.abcdef]");
+		assertSerialized(v);
+		v = new VersionRange("(1.0.0.abcdef,2.0.0.abcdef]");
+		assertSerialized(v);
+		v = new VersionRange("[1.0.0.abcdef,2.0.0.abcdef)");
+		assertSerialized(v);
+		v = new VersionRange("(1.0.0.abcdef,2.0.0.abcdef)");
+		assertSerialized(v);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/OSGiVersionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/OSGiVersionTest.java
new file mode 100644
index 0000000..5d05783
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/OSGiVersionTest.java
@@ -0,0 +1,231 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests versions specified with default OSGi version strings and tests OSGi compatibility
+ * for versions specified using raw.
+ *
+ */
+public class OSGiVersionTest extends VersionTesting {
+
+	public void testBasicParsing() {
+
+		// should parse without exception
+		assertNotNull(Version.parseVersion("1"));
+		assertNotNull(Version.parseVersion("1.0"));
+		assertNotNull(Version.parseVersion("1.0.0"));
+		assertNotNull(Version.parseVersion("1.0.0.9"));
+		assertNotNull(Version.parseVersion("1.0.0.r12345"));
+		assertNotNull(Version.parseVersion("1.0.0.r12345_hello"));
+	}
+
+	public void testOSGiStrings() {
+
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("1"));
+		assertEquals("1.0.0", v.toString());
+		assertNotNull(v = Version.parseVersion("1.0"));
+		assertEquals("1.0.0", v.toString());
+		assertNotNull(v = Version.parseVersion("1.0.0"));
+		assertEquals("1.0.0", v.toString());
+		assertNotNull(v = Version.parseVersion("1.0.0.9"));
+		assertEquals("1.0.0.9", v.toString());
+		assertNotNull(v = Version.parseVersion("1.0.0.r12345"));
+		assertEquals("1.0.0.r12345", v.toString());
+		assertNotNull(v = Version.parseVersion("1.0.0.r12345_hello"));
+		assertEquals("1.0.0.r12345_hello", v.toString());
+	}
+
+	public void testSerialize() {
+
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("1"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("1.0"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("1.0.0"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("1.0.0.9"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("1.0.0.r12345"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("1.0.0.r12345_hello"));
+		assertSerialized(v);
+	}
+
+	public void testNegativeFirstValue() {
+		try {
+			Version.parseVersion("-1");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testPeriodInQualifier() {
+		try {
+			Version.parseVersion("1.0.0.sailor.moon");
+			fail("Uncaught exception: period is not allowed in osgi qualifier");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	public void testNegativeSecondValue() {
+		try {
+			Version.parseVersion("1.-1");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testNegativeThirdValue() {
+		try {
+			Version.parseVersion("1.0.-1");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testEmptyFourthValue() {
+		try {
+			Version.parseVersion("1.0.0.");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testStringFirstValue() {
+		try {
+			Version.parseVersion("a");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testStringSecondValue() {
+		try {
+			Version.parseVersion("1.a");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testStringThirdValue() {
+		try {
+			Version.parseVersion("1.0.a");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testSinglePeriod() {
+		try {
+			Version.parseVersion(".");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testTwoPeriods() {
+		try {
+			Version.parseVersion("..");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testThreePeriods() {
+		try {
+			Version.parseVersion("...");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	public void testEquality() {
+		// should parse without exception
+		Version v1 = Version.parseVersion("1");
+		Version v2 = Version.parseVersion("1.0");
+		Version v3 = Version.parseVersion("1.0.0");
+		Version v4 = Version.parseVersion("1.0.0.9");
+		Version v5 = Version.parseVersion("1.0.0.r12345");
+
+		assertEquals(v1, v2);
+		assertEquals(v1, v3);
+		assertEquals(v2, v3);
+		assertOrder(v3, v4); // i.e. not equal
+		assertOrder(v4, v5); // i.e. not equal
+
+	}
+
+	public void testVersionCompare() {
+		// should parse without exception
+		Version v1 = Version.parseVersion("1");
+		Version v2 = Version.parseVersion("1.0.1");
+		Version v3 = Version.parseVersion("1.1");
+		Version v4 = Version.parseVersion("1.1.1");
+		Version v5 = Version.parseVersion("1.1.1.-");
+		Version v6 = Version.parseVersion("1.2");
+		Version v7 = Version.parseVersion("2");
+		Version v8 = Version.parseVersion("10.0");
+
+		assertOrder(v1, v2);
+		assertOrder(v2, v3);
+		assertOrder(v3, v4);
+		assertOrder(v4, v5);
+		assertOrder(v5, v6);
+		assertOrder(v6, v7);
+		assertOrder(v7, v8);
+
+	}
+
+	public void testCompatability() {
+		Version v = Version.parseVersion("raw:1.2.3.'foo'");
+		assertNotNull(v);
+		assertTrue("a raw:1.2.3.'foo' compatible with OSGi", v.isOSGiCompatible());
+
+		assertNotNull(v = Version.parseVersion("raw:1.2.3"));
+		assertTrue("a raw:1.2.3 compatible with OSGi", v.isOSGiCompatible());
+
+		assertNotNull(v = Version.parseVersion("raw:1.2.3p''"));
+		assertFalse("a raw:1.2.3p'' not compatible with OSGi", v.isOSGiCompatible());
+
+		assertNotNull(v = Version.parseVersion("raw:1.2.3.4"));
+		assertFalse("a raw (4th is int) not compatible with OSGi", v.isOSGiCompatible());
+
+		assertNotNull(v = Version.parseVersion("raw:1.2.3.'foo'.'bar'"));
+		assertFalse("a raw (5 elements) not compatible with OSGi", v.isOSGiCompatible());
+
+		assertNotNull(v = Version.parseVersion("raw:1.2"));
+		assertFalse("a raw (only 2 elements) not compatible with OSGi", v.isOSGiCompatible());
+
+		assertNotNull(v = Version.parseVersion("raw:1.2.3.' %@'"));
+		assertFalse("a raw (illegal chars in qualifier) not compatible with OSGi", v.isOSGiCompatible());
+
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/PerformanceTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/PerformanceTest.java
new file mode 100644
index 0000000..f6c2ad0
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/PerformanceTest.java
@@ -0,0 +1,261 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Simple performance comparison between OSGi version implementation and Omni Version.
+ * Tests performance of creating version instances using 4 values, as well as string parsing.
+ * Tests comparison of versions.
+ * 
+ * Aprox 10000 instances are created.
+ * Comparison compares all instances against all other (i.e. about 10 milj).
+ * 
+ */
+public class PerformanceTest extends TestCase {
+	static final int MUL = 24;
+
+	static final String qualifierTemplate = "r20090112-12345-abcdefghijklmnopqrstuvwxyz"; // longer than MUL chars
+
+	public void testStringCreationPerformance() {
+		// Ensure that classes are loaded etc.
+		Version.MAX_VERSION.compareTo(Version.MIN_VERSION);
+		org.osgi.framework.Version.emptyVersion.compareTo(org.osgi.framework.Version.emptyVersion);
+
+		// Create all versions in string format
+		String[] strings = createStrings();
+
+		long start = System.currentTimeMillis();
+		for (int idx = 0; idx < 100; ++idx)
+			osgiVersionCreateFromString(strings);
+		long osgiTime = System.currentTimeMillis() - start;
+
+		start = System.currentTimeMillis();
+		for (int idx = 0; idx < 100; ++idx)
+			omniVersionCreateFromString(strings);
+		long omniTime = System.currentTimeMillis() - start;
+		outputResult("String creation", 100 * MUL * MUL * MUL, osgiTime, omniTime);
+		// System.out.printf("String creation: osgi=%d, omni=%d, factor=%.2f\n", osgiTime, omniTime, factor(omniTime, osgiTime));
+	}
+
+	public void testCreationPerformance() {
+		// Ensure that classes are loaded etc.
+		Version.MAX_VERSION.compareTo(Version.MIN_VERSION);
+		org.osgi.framework.Version.emptyVersion.compareTo(org.osgi.framework.Version.emptyVersion);
+
+		long start = System.currentTimeMillis();
+		for (int idx = 0; idx < 100; ++idx)
+			osgiVersionCreate();
+		long osgiTime = System.currentTimeMillis() - start;
+
+		start = System.currentTimeMillis();
+		for (int idx = 0; idx < 100; ++idx)
+			omniVersionCreate();
+		long omniTime = System.currentTimeMillis() - start;
+		outputResult("Creation", 100 * MUL * MUL * MUL, osgiTime, omniTime);
+
+		// System.out.printf("Creation: osgi=%d, omni=%d, factor=%f2\n", osgiTime, omniTime, factor(omniTime, osgiTime));
+	}
+
+	public void testComparePerformance() {
+		Version[] omniVersions = createOmniVersions();
+		org.osgi.framework.Version osgiVersions[] = createOsgiVersions();
+
+		long start = System.currentTimeMillis();
+		osgiVersionCompare(osgiVersions);
+		long osgiTime = System.currentTimeMillis() - start;
+
+		start = System.currentTimeMillis();
+		omniVersionCompare(omniVersions);
+		long omniTime = System.currentTimeMillis() - start;
+		long units = MUL * MUL * MUL * MUL * MUL * MUL;
+		outputResult("Compare", units, osgiTime, omniTime);
+
+		//System.out.printf("Compare (%d comparisons): osgi=%d, omni=%d\n, factor=%d", units, osgiTime, omniTime, omniTime / osgiTime);
+	}
+
+	public void testEqualsPerformance() {
+		Version[] omniVersions = createOmniVersions();
+		org.osgi.framework.Version osgiVersions[] = createOsgiVersions();
+
+		long start = System.currentTimeMillis();
+		osgiVersionEquals(osgiVersions);
+		long osgiTime = System.currentTimeMillis() - start;
+
+		start = System.currentTimeMillis();
+		omniVersionEquals(omniVersions);
+		long omniTime = System.currentTimeMillis() - start;
+		long units = MUL * MUL * MUL * MUL * MUL * MUL;
+		outputResult("Equals", units, osgiTime, omniTime);
+
+		//System.out.printf("Equals (%d comparisons): osgi=%d, omni=%d, factor=%d\n", units, osgiTime, omniTime, omniTime / osgiTime);
+	}
+
+	public void testToStringPerformance() {
+		Version[] omniVersions = createOmniVersions();
+		org.osgi.framework.Version osgiVersions[] = createOsgiVersions();
+
+		long start = System.currentTimeMillis();
+		for (int idx = 0; idx < 100; ++idx)
+			osgiVersionToString(osgiVersions);
+		long osgiTime = System.currentTimeMillis() - start;
+
+		start = System.currentTimeMillis();
+		for (int idx = 0; idx < 100; ++idx)
+			omniVersionToString(omniVersions);
+		long omniTime = System.currentTimeMillis() - start;
+		long units = 100 * MUL * MUL * MUL;
+		outputResult("To String", units, osgiTime, omniTime);
+
+		//System.out.printf("toString (%d versions): osgi=%d, omni=%d\n", units, osgiTime, omniTime);
+	}
+
+	public static void osgiVersionToString(org.osgi.framework.Version versions[]) {
+		// compare every version against all other versions
+		for (int i = 0; i < MUL * MUL * MUL; i++)
+			versions[i].toString();
+	}
+
+	public static void omniVersionToString(Version versions[]) {
+		// compare every version against all other versions
+		for (int i = 0; i < MUL * MUL * MUL; i++)
+			versions[i].toString();
+	}
+
+	public static void omniVersionCreate() {
+		for (int i = 0; i < MUL; i++)
+			for (int j = 0; j < MUL; j++)
+				for (int k = 0; k < MUL; k++)
+					new Version(i, j, k, qualifierTemplate);
+	}
+
+	public static void omniVersionCompare(Version versions[]) {
+		//compare every version against all other versions
+		for (int i = 0; i < MUL * MUL * MUL; i++)
+			for (int j = 0; j < MUL * MUL * MUL; j++)
+				versions[i].compareTo(versions[j]);
+	}
+
+	public static void omniVersionEquals(Version versions[]) {
+		//compare every version against all other versions
+		for (int i = 0; i < MUL * MUL * MUL; i++)
+			for (int j = 0; j < MUL * MUL * MUL; j++)
+				versions[i].equals(versions[j]);
+	}
+
+	public static void omniVersionCreateFromString(String[] strings) {
+		int x = 0;
+		for (int i = 0; i < MUL; i++)
+			for (int j = 0; j < MUL; j++)
+				for (int k = 0; k < MUL; k++)
+					Version.parseVersion(strings[x++]);
+	}
+
+	public static void osgiVersionCompare(org.osgi.framework.Version versions[]) {
+		// compare every version against all other versions
+		for (int i = 0; i < MUL * MUL * MUL; i++)
+			for (int j = 0; j < MUL * MUL * MUL; j++)
+				versions[i].compareTo(versions[j]);
+	}
+
+	public static void osgiVersionEquals(org.osgi.framework.Version versions[]) {
+		// compare every version against all other versions
+		for (int i = 0; i < MUL * MUL * MUL; i++)
+			for (int j = 0; j < MUL * MUL * MUL; j++)
+				versions[i].equals(versions[j]);
+	}
+
+	public static void osgiVersionCreate() {
+		for (int i = 0; i < MUL; i++)
+			for (int j = 0; j < MUL; j++)
+				for (int k = 0; k < MUL; k++)
+					new org.osgi.framework.Version(i, j, k, qualifierTemplate);
+	}
+
+	public static void osgiVersionCreateFromString(String[] strings) {
+		int x = 0;
+		for (int i = 0; i < MUL; i++)
+			for (int j = 0; j < MUL; j++)
+				for (int k = 0; k < MUL; k++)
+					org.osgi.framework.Version.parseVersion(strings[x++]);
+	}
+
+	/**
+	 * Create a set of different versions. The execution of this method does not take part
+	 * in the time measurement
+	 */
+	private static Version[] createOmniVersions() {
+		Version versions[] = new Version[MUL * MUL * MUL];
+		int x = 0;
+		for (int i = 0; i < MUL; i++)
+			for (int j = 0; j < MUL; j++)
+				for (int k = 0; k < MUL; k++)
+					versions[x++] = new Version(i, j, k, qualifierTemplate.substring(0, k + 1));
+		return versions;
+	}
+
+	/**
+	 * Create a set of different versions. The execution of this method does not take part
+	 * in the time measurement
+	 */
+	private static org.osgi.framework.Version[] createOsgiVersions() {
+		org.osgi.framework.Version versions[] = new org.osgi.framework.Version[MUL * MUL * MUL];
+		int x = 0;
+		for (int i = 0; i < MUL; i++)
+			for (int j = 0; j < MUL; j++)
+				for (int k = 0; k < MUL; k++)
+					versions[x++] = new org.osgi.framework.Version(i, j, k, qualifierTemplate.substring(0, k + 1));
+		return versions;
+	}
+
+	/**
+	 * Create a set of different version strings. The execution of this method does not take part
+	 * in the time measurement
+	 */
+	private static String[] createStrings() {
+		String[] strings = new String[MUL * MUL * MUL];
+		StringBuffer buf = new StringBuffer(100);
+		int x = 0;
+		for (int i = 0; i < MUL; i++)
+			for (int j = 0; j < MUL; j++)
+				for (int k = 0; k < MUL; k++) {
+					buf.setLength(0);
+					buf.append(i);
+					buf.append(".");
+					buf.append(j);
+					buf.append(".");
+					buf.append(k);
+					buf.append(".");
+					buf.append(qualifierTemplate.substring(0, k + 1));
+					strings[x++] = buf.toString();
+				}
+		return strings;
+	}
+
+	private static double factor(long osgiTime, long omniTime) {
+		double osgi = osgiTime;
+		double omni = omniTime;
+		return osgi / omni;
+	}
+
+	private static void outputResult(String message, long units, long osgiTime, long omniTime) {
+		System.out.printf("%s (units %d): osgi=%d [%.2fus/unit], omni=%d [%.2fus/unit], factor=%.2f\n", message, units, osgiTime, perUnit(osgiTime, units), omniTime, perUnit(omniTime, units), factor(omniTime, osgiTime));
+	}
+
+	private static double perUnit(long timeMillisec, long units) {
+		double time = (timeMillisec * 1000);
+		double u = units;
+		return time / u;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawRangeTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawRangeTest.java
new file mode 100644
index 0000000..832d9f9
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawRangeTest.java
@@ -0,0 +1,161 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+
+/**
+ * Tests version ranges specified using raw.
+ *
+ */
+public class RawRangeTest extends VersionTesting {
+	public void testEmptyRange() {
+		VersionRange range = new VersionRange("raw:''");
+		assertIncludedInRange("#1", range, "raw:'a'");
+
+		try {
+			new VersionRange("raw:");
+			fail("Uncaught error: a raw range can not be empty.");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testRangeDelimitersInStrings() {
+		VersionRange range = null;
+		range = new VersionRange("raw:['one\\,\\ two','three\\,\\ \\[and\\]\\ four']");
+		assertIncludedInRange("#1", range, "raw:'one, two'");
+		assertIncludedInRange("#2", range, "raw:'three, [and] four'");
+	}
+
+	public void testRangeDelimitersInStringstoString() {
+		VersionRange range = null;
+		String s = null;
+		range = new VersionRange(s = "raw:['one\\,\\ two','three\\,\\ \\[and\\]\\ four']");
+		assertEquals(s, range.toString());
+	}
+
+	public void testSingleVersionRange() {
+		VersionRange range;
+		range = new VersionRange("raw:[1.0.0, 1.0.0.'-')");
+		assertEquals("0.1", Version.parseVersion("raw:1.0.0"), range.getMinimum());
+		assertEquals("0.2", Version.parseVersion("raw:1.0.0.'-'"), range.getMaximum());
+
+		assertNotIncludedInRange("0.9", range, "raw:0.9");
+		assertNotIncludedInRange("1.0", range, "raw:1"); // this is not osgi versions 1 is before than 1.0
+		assertNotIncludedInRange("1.1", range, "raw:1.0"); // this is not osgi, version 1.0 is before 1.0.0
+		assertIncludedInRange("1.2", range, "raw:1.0.0");
+		assertNotIncludedInRange("2.1", range, "raw:1.0.0.'0'");
+		assertNotIncludedInRange("2.2", range, "raw:1.0.1");
+		assertNotIncludedInRange("2.3", range, "raw:1.1");
+		assertNotIncludedInRange("2.4", range, "raw:2");
+	}
+
+	public void testInvertedRange() {
+		try {
+			new VersionRange("raw:[2.0.0, 1.0.0]");
+			fail("Inverted range is not allowed");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testGreaterThan() {
+		// any version equal or greater than 1.0.0 is ok 
+		VersionRange lowerBound = new VersionRange("raw:1.0.0");
+		assertNotIncludedInRange("1.0", lowerBound, "raw:0.9.0");
+		assertIncludedInRange("1.1", lowerBound, "raw:1.0.0");
+		assertIncludedInRange("1.2", lowerBound, "raw:1.9.9.'x'");
+		assertIncludedInRange("1.3", lowerBound, "raw:999.999.999.'foo'");
+		assertIncludedInRange("1.3", lowerBound, "raw:M.M.M.m");
+	}
+
+	public void testGreaterThanSmallest() {
+		// any version equal or greater than -M' (empty string) is ok 
+		VersionRange lowerBound = new VersionRange("raw:-M");
+		assertIncludedInRange("#1", lowerBound, "raw:-M");
+		assertIncludedInRange("#1.1", lowerBound, "raw:''");
+		assertIncludedInRange("#1.1", lowerBound, "raw:m");
+		assertIncludedInRange("#2", lowerBound, "raw:0.9.0");
+		assertIncludedInRange("#3", lowerBound, "raw:1.0.0");
+		assertIncludedInRange("#4", lowerBound, "raw:1.9.9.'x'");
+		assertIncludedInRange("#5", lowerBound, "raw:999.999.999.'foo'");
+		assertIncludedInRange("#6", lowerBound, "raw:M.M.M.m");
+		assertIncludedInRange("#7", lowerBound, "raw:M");
+		assertIncludedInRange("#8", lowerBound, "raw:MpM");
+	}
+
+	public void testLowerThan() {
+		// any version lower than 2.0 is ok 		
+		VersionRange upperBound = new VersionRange("raw:[0, 2.0)");
+		assertIncludedInRange("1.0", upperBound, "raw:0.0");
+		assertIncludedInRange("1.1", upperBound, "raw:0.9");
+		assertIncludedInRange("1.2", upperBound, "raw:1.0");
+		assertIncludedInRange("1.3", upperBound, "raw:1.9.9.'x'");
+		assertNotIncludedInRange("1.4", upperBound, "raw:2.0");
+		assertNotIncludedInRange("1.5", upperBound, "raw:2.1");
+	}
+
+	public void testSerialize() {
+		VersionRange v = null;
+
+		v = new VersionRange("raw:1.0.0");
+		assertSerialized(v);
+		v = new VersionRange("raw:[1.0.0,2.0.0]");
+		assertSerialized(v);
+		v = new VersionRange("raw:(1.0.0,2.0.0]");
+		assertSerialized(v);
+		v = new VersionRange("raw:[1.0.0,2.0.0)");
+		assertSerialized(v);
+		v = new VersionRange("raw:(1.0.0,2.0.0)");
+		assertSerialized(v);
+
+		v = new VersionRange("raw:1.0.0.'abcdef'");
+		assertSerialized(v);
+		v = new VersionRange("raw:[1.0.0.'abcdef',2.0.0.'abcdef']");
+		assertSerialized(v);
+		v = new VersionRange("raw:(1.0.0.'abcdef',2.0.0.'abcdef']");
+		assertSerialized(v);
+		v = new VersionRange("raw:[1.0.0.'abcdef',2.0.0.'abcdef')");
+		assertSerialized(v);
+		v = new VersionRange("raw:(1.0.0.'abcdef',2.0.0.'abcdef')");
+		assertSerialized(v);
+	}
+
+	public void testToString() {
+		VersionRange v = null;
+		String s = null;
+		v = new VersionRange(s = "raw:1.0.0");
+		assertEquals(s, v.toString());
+		v = new VersionRange(s = "raw:[1.0.0,2.0.0]");
+		assertEquals(s, v.toString());
+		v = new VersionRange(s = "raw:(1.0.0,2.0.0]");
+		assertEquals(s, v.toString());
+		v = new VersionRange(s = "raw:[1.0.0,2.0.0)");
+		assertEquals(s, v.toString());
+		v = new VersionRange(s = "raw:(1.0.0,2.0.0)");
+		assertEquals(s, v.toString());
+
+		v = new VersionRange(s = "raw:1.0.0.'abcdef'");
+		assertEquals(s, v.toString());
+		v = new VersionRange(s = "raw:[1.0.0.'abcdef',2.0.0.'abcdef']");
+		assertEquals(s, v.toString());
+		v = new VersionRange(s = "raw:(1.0.0.'abcdef',2.0.0.'abcdef']");
+		assertEquals(s, v.toString());
+		v = new VersionRange(s = "raw:[1.0.0.'abcdef',2.0.0.'abcdef')");
+		assertEquals(s, v.toString());
+		v = new VersionRange(s = "raw:(1.0.0.'abcdef',2.0.0.'abcdef')");
+		assertEquals(s, v.toString());
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawRangeWithOriginalTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawRangeWithOriginalTest.java
new file mode 100644
index 0000000..52c444c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawRangeWithOriginalTest.java
@@ -0,0 +1,143 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+
+/**
+ * Tests inclusion of original version range string in raw format.
+ * The tests in this class does not fully test the various "format(rules)" only that the sequence
+ * "raw RANGE/format():ORIGINAL RANGE" works, and that errors at the top level are caught.
+ * 
+ */
+public class RawRangeWithOriginalTest extends VersionTesting {
+
+	public void testRawWithUnknownFormat() {
+		VersionRange v = new VersionRange("raw:[1.0,2.0]/:sailor.moon.R,sailor.moon.S");
+		assertEquals(v, new VersionRange("raw:[1.0,2.0]"));
+	}
+
+	public void testRawWithUnknownFormatToString() {
+		assertEquals("raw:[1.0,2.0]/:sailor.moon.R,sailor.moon.S", new VersionRange("raw:[1.0,2.0]/:sailor.moon.R,sailor.moon.S").toString());
+	}
+
+	public void testRawWithUnknownFormatSerialized() {
+		assertSerialized(new VersionRange("raw:[1.0,2.0]/:sailor.moon.R,sailor.moon.S"));
+		assertEquals("raw:[1.0,2.0]/:sailor.moon.R,sailor.moon.S", getSerialized(new VersionRange("raw:[1.0,2.0]/:sailor.moon.R,sailor.moon.S")).toString());
+	}
+
+	public void testRawWithSimpleFormat() {
+		VersionRange v = new VersionRange("raw:[1.0,2.0]/format(n.n):[1.0,2.0]");
+		assertEquals(v, new VersionRange("raw:[1.0,2.0]"));
+	}
+
+	public void testRawWithSimpleFormatToString() {
+		// range brackets are normalized in toString - not needed in original
+		assertEquals("raw:[1.0,2.0]/format(n.n):1.0,2.0", new VersionRange("raw:[1.0,2.0]/format(n.n):[1.0,2.0]").toString());
+	}
+
+	public void testRawWithSimpleFormatSerialized() {
+		assertSerialized(new VersionRange("raw:[1.0,2.0]/format(n.n):[1.0,2.0]"));
+		// range brackets are normalized in toString - not needed in original
+		assertEquals("raw:[1.0,2.0]/format(n.n):1.0,2.0", getSerialized(new VersionRange("raw:[1.0,2.0]/format(n.n):[1.0,2.0]")).toString());
+	}
+
+	public void testOriginalStatedButMissing() {
+		try {
+			new VersionRange("raw:[1.0,2.0]/");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalAndUnknownStatedButMissing() {
+		try {
+			new VersionRange("raw:[1.0,2.0]/:");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalIllegalFormat() {
+		try {
+			new VersionRange("raw:[1.0,2.0]/foo:");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalIllegalFormat2() {
+		try {
+			new VersionRange("raw:[1.0,2.0]/100:");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalIllegalFormat3() {
+		try {
+			new VersionRange("raw:[1.0,2.0]/'format':");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalIllegalFormat4() {
+		try {
+			new VersionRange("raw:[1.0,2.0]//1.0");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalIllegalFormat5() {
+		try {
+			new VersionRange("raw:[1.0,2.0]/format:");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalFormatUnbalancedLeft() {
+		try {
+			new VersionRange("raw:[1.0,2.0]/formatn.n):");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalFormatUnbalancedRight() {
+		try {
+			new VersionRange("raw:[1.0,2.0]/format(n.n:1.0");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalFormatOriginalMissing() {
+		try {
+			new VersionRange("raw:[1.0,2.0]/format(n.n):");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawVersionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawVersionTest.java
new file mode 100644
index 0000000..0567327
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawVersionTest.java
@@ -0,0 +1,1002 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionVector;
+
+/**
+ * Tests the OmniVersion raw version format.
+ *
+ */
+public class RawVersionTest extends VersionTesting {
+
+	public void testBasicParsing() {
+
+		// should parse without exception
+		assertNotNull(Version.parseVersion("raw:1"));
+		assertNotNull(Version.parseVersion("raw:1.0"));
+		assertNotNull(Version.parseVersion("raw:1.0.0"));
+		assertNotNull(Version.parseVersion("raw:1.0.0.9"));
+		assertNotNull(Version.parseVersion("raw:1.0.0.'r12345'"));
+		assertNotNull(Version.parseVersion("raw:1.0.0.'r12345.hello'"));
+
+		assertNotNull(Version.parseVersion("raw:1.0.m"));
+		assertNotNull(Version.parseVersion("raw:1.0.M"));
+
+		assertNotNull(Version.parseVersion("raw:1.0.M"));
+		assertNotNull(Version.parseVersion("raw:1.0.-M"));
+
+	}
+
+	public void testSerialize() {
+		Version v = null;
+		// should parse without exception
+		assertNotNull(v = Version.parseVersion("raw:1"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0.0"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0.0.9"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0.0.'r12345'"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0.0.'r12345.hello'"));
+		assertSerialized(v);
+
+		assertNotNull(v = Version.parseVersion("raw:1.0.m"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0.M"));
+		assertSerialized(v);
+
+		assertNotNull(v = Version.parseVersion("raw:1.0.M"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0.-M"));
+		assertSerialized(v);
+
+		assertNotNull(v = Version.parseVersion("raw:0"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:0.1.2.3.4.5.6.7.8.9"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:0.-1.-2.-3.-4.-5.-6.-7.-8.-9"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:123456789.-1234567890"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:123456789.-1234567890"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:m"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:M"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:-M"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.m"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.M"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.-M"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:'a'"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:\"a\""));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:'ab'"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:'abcdefghijklmnopqrstuvwxyz0123456789'"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:'-_!\"#$%&/()=?+*;,:.'"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:\"'\""));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:'\"'"));
+		assertSerialized(v);
+
+	}
+
+	public void testVersionString() {
+		Version v = null;
+		String s = null;
+		// should parse without exception
+		assertNotNull(v = Version.parseVersion(s = "raw:1"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0.0"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0.0.9"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0.0.'r12345'"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0.0.'r12345.hello'"));
+		assertEquals(s, v.toString());
+
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0.m"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0.M"));
+		assertEquals(s, v.toString());
+
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0.M"));
+		assertEquals(s, v.toString());
+
+		// -M is normalized
+		assertNotNull(v = Version.parseVersion("raw:1.0.-M"));
+		s = "raw:1.0";
+		assertEquals(s, v.toString());
+
+		assertNotNull(v = Version.parseVersion(s = "raw:0"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:0.1.2.3.4.5.6.7.8.9"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:0.-1.-2.-3.-4.-5.-6.-7.-8.-9"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:123456789.-1234567890"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:123456789.-1234567890"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:m"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:M"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:-M"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.m"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.M"));
+		assertEquals(s, v.toString());
+		// -M is normalized
+		assertNotNull(v = Version.parseVersion("raw:1.-M"));
+		s = "raw:1";
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:'a'"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:\"a\""));
+		// " is normalized to '
+		s = "raw:'a'";
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:'ab'"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:'abcdefghijklmnopqrstuvwxyz0123456789'"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:'-_!\"#$%&/()=?+*;,:.'"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:\"'\""));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:'\"'"));
+		assertEquals(s, v.toString());
+
+	}
+
+	public void testIntegerParsing() {
+
+		// should parse without exception
+		Version v = Version.parseVersion("raw:0");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), Integer.valueOf(0));
+
+		// single digits
+		v = Version.parseVersion("raw:0.1.2.3.4.5.6.7.8.9");
+		assertNotNull(v);
+		for (int i = 0; i < 10; i++)
+			assertEquals(v.getSegment(i), Integer.valueOf(i));
+
+		// negative single digits
+		v = Version.parseVersion("raw:0.-1.-2.-3.-4.-5.-6.-7.-8.-9");
+		assertNotNull(v);
+		for (int i = 0; i < 10; i++)
+			assertEquals(v.getSegment(i), Integer.valueOf(-i));
+
+		// some larger numbers
+		v = Version.parseVersion("raw:123456789.-1234567890");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), Integer.valueOf(123456789));
+		assertEquals(v.getSegment(1), Integer.valueOf(-1234567890));
+	}
+
+	public void testWhiteSpaceExceptions() {
+
+		try {
+			Version.parseVersion("raw: 0 ");
+			fail("space not allowed 1");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+		try {
+			Version.parseVersion("raw:0 .1  . 'a'.   'b c d'. 4. 5. 6.   7. 8 .  9");
+			fail("space not allowed 2");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+		try {
+			Version.parseVersion("raw:< 1.2.3>");
+			fail("space not allowed in array 1");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("raw:<1.2.3 >");
+			fail("space not allowed in array 2");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+		try {
+			Version.parseVersion("raw:1.- 1");
+			fail("Uncaught error: space between minus and number in negative");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testMaxParsing() {
+
+		assertNotNull(Version.parseVersion("raw:m"));
+		assertNotNull(Version.parseVersion("raw:M"));
+		assertNotNull(Version.parseVersion("raw:-M"));
+
+		assertNotNull(Version.parseVersion("raw:1.m"));
+		assertNotNull(Version.parseVersion("raw:1.M"));
+		assertNotNull(Version.parseVersion("raw:1.-M"));
+	}
+
+	public void testStringParsing() {
+		Version v = Version.parseVersion("raw:'a'");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), "a");
+
+		assertNotNull(v = Version.parseVersion("raw:\"a\""));
+		assertEquals(v.getSegment(0), "a");
+
+		assertNotNull(v = Version.parseVersion("raw:'ab'"));
+		assertEquals(v.getSegment(0), "ab");
+
+		assertNotNull(v = Version.parseVersion("raw:'abcdefghijklmnopqrstuvwxyz0123456789'"));
+		assertEquals(v.getSegment(0), "abcdefghijklmnopqrstuvwxyz0123456789");
+
+		assertNotNull(v = Version.parseVersion("raw:'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'"));
+		assertEquals(v.getSegment(0), "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
+
+		assertNotNull(v = Version.parseVersion("raw:'-_!\"#$%&/()=?+*;,:.'"));
+		assertEquals(v.getSegment(0), "-_!\"#$%&/()=?+*;,:.");
+
+		assertNotNull(v = Version.parseVersion("raw:\"'\""));
+		assertEquals(v.getSegment(0), "'");
+
+		assertNotNull(v = Version.parseVersion("raw:'\"'"));
+		assertEquals(v.getSegment(0), "\"");
+	}
+
+	public void testEmptyStringParsing() {
+		Version v = Version.parseVersion("raw:''");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), "");
+
+		v = Version.parseVersion("raw:\"\"");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), "");
+	}
+
+	public void testStringConcatenation() {
+		Version v = Version.parseVersion("raw:'ab''cd'");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), "abcd");
+
+		v = Version.parseVersion("raw:'ab'\"cd\"");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), "abcd");
+
+		v = Version.parseVersion("raw:\"ab\"\"cd\"");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), "abcd");
+	}
+
+	public void testStringToString() {
+		// string is normalized
+		assertEquals("raw:'abcd'", Version.parseVersion("raw:'ab''cd'").toString());
+
+		// string is normalized
+		assertEquals("raw:'abcd'", Version.parseVersion("raw:'ab'\"cd\"").toString());
+
+		// string is normalized
+		assertEquals("raw:'abcd'", Version.parseVersion("raw:\"ab\"\"cd\"").toString());
+
+		assertEquals("raw:\"'\"", Version.parseVersion("raw:\"'\"").toString());
+
+		assertEquals("raw:'\"'", Version.parseVersion("raw:'\"'").toString());
+
+		// quotes are normalized - default ' should be used until " is needed and vice versa.
+		assertEquals("raw:'abc\"xxx\"and '\"'yyy'\"", Version.parseVersion("raw:'abc\"xxx\"'\"and 'yyy'\"").toString());
+
+	}
+
+	public void testArrayParsing() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("raw:<1>"));
+		assertEquals(v.getSegment(0), Version.parseVersion("raw:1"));
+
+		assertNotNull(v = Version.parseVersion("raw:<1.0>"));
+		assertEquals(v.getSegment(0), Version.parseVersion("raw:1.0"));
+
+		assertNotNull(v = Version.parseVersion("raw:<'a'>"));
+		assertEquals(v.getSegment(0), Version.parseVersion("raw:'a'"));
+
+		assertNotNull(v = Version.parseVersion("raw:<'a'.'b'>"));
+		assertEquals(v.getSegment(0), Version.parseVersion("raw:'a'.'b'"));
+
+		assertNotNull(v = Version.parseVersion("raw:<'a'.'b''c'>"));
+		assertEquals(v.getSegment(0), Version.parseVersion("raw:'a'.'bc'")); // with concatenation
+
+		assertNotNull(v = Version.parseVersion("raw:<1.2.-M>"));
+		assertEquals(v.getSegment(0), Version.parseVersion("raw:1.2.-M"));
+
+		assertNotNull(v = Version.parseVersion("raw:<1.2.m>"));
+		assertEquals(v.getSegment(0), Version.parseVersion("raw:1.2.m"));
+
+		assertNotNull(v = Version.parseVersion("raw:<1.2.M>"));
+		assertEquals(v.getSegment(0), Version.parseVersion("raw:1.2.M"));
+
+		assertNotNull(v = Version.parseVersion("raw:<<1>>"));
+		assertEquals(v.getSegment(0), Version.parseVersion("raw:<1>"));
+
+		assertNotNull(v = Version.parseVersion("raw:<<1.<2>>>"));
+		assertEquals(v.getSegment(0), Version.parseVersion("raw:<1.<2>>"));
+
+	}
+
+	public void testArraySerialize() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("raw:<1>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:<1.0>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:<'a'>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:<'a'.'b'>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:<'a'.'b''c'>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:<1.2.-M>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:<1.2.m>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:<1.2.M>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:<<1>>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:<<1.<2>>>"));
+		assertSerialized(v);
+
+	}
+
+	public void testArraytoString() {
+		Version v = null;
+		String s = null;
+		assertNotNull(v = Version.parseVersion(s = "raw:<1>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:<1.0>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:<'a'>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:<'a'.'b'>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:<'a'.'bc'>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion("raw:<1.2.-M>"));
+		s = "raw:<1.2>"; // is normalized
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:<1.2.m>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:<1.2.M>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:<<1>>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:<<1.<2>>>"));
+		assertEquals(s, v.toString());
+	}
+
+	public void testArrayOrder() {
+		Version v1 = Version.parseVersion("raw:<1.0.0>");
+		Version v2 = Version.parseVersion("raw:<1.1.0>");
+
+		Version v3 = Version.parseVersion("raw:<1.0.0>.<1.0.0>");
+		Version v4 = Version.parseVersion("raw:<1.0.0>.<1.0.0>.'a'");
+		Version v5 = Version.parseVersion("raw:<1.0.0>.<1.0.1>");
+		Version v6 = Version.parseVersion("raw:<2.0.0>");
+
+		assertOrder(v1, v2);
+		assertOrder(v3, v4);
+		assertOrder(v4, v5);
+		assertOrder(v5, v6);
+	}
+
+	public void testPadParsing1() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("raw:1.0p0"));
+		assertPad(v, "raw:0");
+		assertNotNull(v = Version.parseVersion("raw:1.0p'foo'"));
+		assertPad(v, "raw:'foo'");
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0>"));
+		assertPad(v, "raw:<0>");
+		assertNotNull(v = Version.parseVersion("raw:1.0p<'foo'>"));
+		assertPad(v, "raw:<'foo'>");
+		assertNotNull(v = Version.parseVersion("raw:1.0pm"));
+		assertPad(v, "raw:m");
+		assertNotNull(v = Version.parseVersion("raw:1.0pM"));
+		assertPad(v, "raw:M");
+		assertNotNull(v = Version.parseVersion("raw:1.0p-M"));
+		assertEquals(v.getPad(), null);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<m>"));
+		assertPad(v, "raw:<m>");
+		assertNotNull(v = Version.parseVersion("raw:1.0p<M>"));
+		assertPad(v, "raw:<M>");
+		assertNotNull(v = Version.parseVersion("raw:1.0p<-M>"));
+		assertPad(v, "raw:<-M>");
+		assertNotNull(v = Version.parseVersion("raw:1.0p<1.0.0.'r12345'.m>"));
+		assertPad(v, "raw:<1.0.0.'r12345'.m>");
+	}
+
+	public void testPadSerialize() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("raw:1.0p0"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p'foo'"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<'foo'>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0pm"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0pM"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p-M"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<m>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<M>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<-M>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<1.0.0.'r12345'.m>"));
+		assertSerialized(v);
+	}
+
+	public void testPadtoString() {
+		Version v = null;
+		String s = null;
+		assertNotNull(v = Version.parseVersion("raw:1.0p0"));
+		s = "raw:1p0"; // normalized
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p'foo'"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<0>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<'foo'>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0pm"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0pM"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion("raw:1.0p-M"));
+		s = "raw:1.0"; // normalized
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<m>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<M>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<-M>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<1.0.0.'r12345'.m>"));
+		assertEquals(s, v.toString());
+	}
+
+	/**
+	 * Test parsing of a pad with an array that in turn has padding.
+	 */
+	public void testNestedPadParsing() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p0>"));
+		assertPad(v, "raw:<0p0>");
+		assertPad(v.getPad(), "raw:0");
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p'foo'>"));
+		assertPad(v, "raw:<0p'foo'>");
+		assertPad(v.getPad(), "raw:'foo'");
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p<0>>"));
+		assertPad(v, "raw:<0p<0>>");
+		assertPad(v.getPad(), "raw:<0>");
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p<'foo'>>"));
+		assertPad(v, "raw:<0p<'foo'>>");
+		assertPad(v.getPad(), "raw:<'foo'>");
+
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0pm>"));
+		assertPad(v, "raw:<0pm>");
+		assertPad(v.getPad(), "raw:m");
+
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0pM>"));
+		assertPad(v, "raw:<0pM>");
+		assertPad(v.getPad(), "raw:M");
+
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p-M>"));
+		assertPad(v, "raw:<0p-M>");
+		assertEquals(((VersionVector) v.getPad()).getPad(), null);
+
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p<m>>"));
+		assertPad(v, "raw:<0p<m>>");
+		assertPad(v.getPad(), "raw:<m>");
+
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0pM>"));
+		assertPad(v, "raw:<0pM>");
+		assertPad(v.getPad(), "raw:M");
+
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p-M>"));
+		assertPad(v, "raw:<0p-M>");
+		assertEquals(((VersionVector) v.getPad()).getPad(), null);
+	}
+
+	public void testNestedPadSerialize() {
+		Version v = null;
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p0>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p'foo'>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p<0>>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p<'foo'>>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0pm>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0pM>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p-M>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p<m>>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0pM>"));
+		assertSerialized(v);
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p-M>"));
+		assertSerialized(v);
+	}
+
+	public void testNestedPadtoString() {
+		Version v = null;
+		String s = null;
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<0p0>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<0p'foo'>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<0p<0>>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<0p<'foo'>>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<0pm>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<0pM>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p-M>"));
+		s = "raw:1.0p<0>"; // normalized
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<0p<m>>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion(s = "raw:1.0p<0pM>"));
+		assertEquals(s, v.toString());
+		assertNotNull(v = Version.parseVersion("raw:1.0p<0p-M>"));
+		s = "raw:1.0p<0>"; // normalized
+		assertEquals(s, v.toString());
+	}
+
+	/**
+	 * Tests that:
+	 * 		1p-M < 1.0.0 < 1.0.0p0 == 1p0 < 1.1 < 1.1.1 < 1p1 == 1.1p1 < 1pM
+	 */
+	public void testPadOrder() {
+		Version v1 = Version.parseVersion("raw:1p-M");
+		Version v2 = Version.parseVersion("raw:1.0.0");
+		Version v3 = Version.parseVersion("raw:1.0.0p0");
+		Version v4 = Version.parseVersion("raw:1p0");
+		Version v5 = Version.parseVersion("raw:1.1");
+		Version v6 = Version.parseVersion("raw:1.1.1");
+		Version v7 = Version.parseVersion("raw:1p1");
+		Version v8 = Version.parseVersion("raw:1.1p1");
+		Version v9 = Version.parseVersion("raw:1pM");
+
+		assertOrder(v1, v2);
+		assertOrder(v2, v3);
+		assertEquals(v3, v4);
+		assertOrder(v4, v5);
+		assertOrder(v5, v6);
+		assertOrder(v6, v7);
+		assertEquals(v7, v8);
+		assertOrder(v8, v9);
+	}
+
+	public void testPadTypeOrder() {
+		Version v0 = Version.parseVersion("raw:1p-M");
+		Version v1 = Version.parseVersion("raw:1p'a'");
+		Version v2 = Version.parseVersion("raw:1p<0>");
+		Version v3 = Version.parseVersion("raw:1.0.0");
+		Version v4 = Version.parseVersion("raw:1p0");
+		Version v5 = Version.parseVersion("raw:1p1");
+		Version v6 = Version.parseVersion("raw:1pM");
+		assertOrder(v0, v1);
+		assertOrder(v1, v2);
+		assertOrder(v2, v3);
+		assertOrder(v3, v4);
+		assertOrder(v4, v5);
+		assertOrder(v5, v6);
+	}
+
+	/**
+	 * Test that a / is not prematurely taken as the separator between raw and original when in a string
+	 */
+	public void testOriginalTerminator() {
+		Version v = Version.parseVersion("raw:'/'");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), "/");
+
+		v = Version.parseVersion("raw:\"/\"");
+		assertNotNull(v);
+		assertEquals(v.getSegment(0), "/");
+	}
+
+	public void testEmptyInput() {
+		// should parse with exception 
+		try {
+			Version.parseVersion("raw:");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testNewLine() {
+		// should parse with exception 
+		try {
+			Version.parseVersion("raw:1.'\n'.2");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testSpaceInInt() {
+		// should parse with exception 
+		try {
+			Version.parseVersion("raw:1 2.2");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testFloatingPointl() {
+		// should parse with exception 
+		try {
+			Version.parseVersion("raw:1,2.2");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testScientific() {
+		// should parse with exception 
+		try {
+			Version.parseVersion("raw:1E3");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testHex() {
+		// should parse with exception 
+		try {
+			Version.parseVersion("raw:0xABCD");
+			fail("Uncaught error: hexadecimal not allowed");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnbalancedSingleQuoteRight() {
+		try {
+			Version.parseVersion("raw:'unbalanced");
+			fail("Uncaught error: unbalanced sngle quote");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testMixedQuotes1() {
+		try {
+			Version.parseVersion("raw:1.\"unbalanced'.10");
+			fail("Uncaught error: mixed quotes");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testMixedQuotes2() {
+		try {
+			Version.parseVersion("raw:1.'unbalanced\".10");
+			fail("Uncaught error: mixed quotes");
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnbalancedDoubleQuoteRight() {
+		try {
+			Version.parseVersion("raw:\"unbalanced");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnbalancedArrayRight() {
+		try {
+			Version.parseVersion("raw:<1.2.3");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnbalancedArrayLeft() {
+		try {
+			Version.parseVersion("raw:1.2.3>");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testBadDecimalInteger() {
+		try {
+			Version.parseVersion("raw:12af");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnquotedStringFirstValue() {
+		try {
+			Version.parseVersion("raw:a");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnquotedStringSecondValue() {
+		try {
+			Version.parseVersion("raw:1.a");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testSinglePeriod() {
+		try {
+			Version.parseVersion("raw:.");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testTwoPeriods() {
+		try {
+			Version.parseVersion("raw:..");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testThreePeriods() {
+		try {
+			Version.parseVersion("raw:...");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	public void testPadNotLast() {
+		try {
+			Version.parseVersion("raw:p10.10");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+
+	}
+
+	public void testEmptyPad() {
+		try {
+			Version.parseVersion("raw:10p");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testPadWithNull() {
+		try {
+			Version.parseVersion("raw:10p.");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testWrongPadSeparator() {
+		try {
+			Version.parseVersion("raw:10.p0");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testMultiplePadElements() {
+		try {
+			Version.parseVersion("raw:10p1.2");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnbalancedPadElementsSQ() {
+		try {
+			Version.parseVersion("raw:10p'abc");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnbalancedPadElementsDQ() {
+		try {
+			Version.parseVersion("raw:10p\"abc");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnbalancedPadArrayElementsRight() {
+		try {
+			Version.parseVersion("raw:10p<10");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testUnbalancedPadArrayElementsLeft() {
+		try {
+			Version.parseVersion("raw:10p10>");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOrder() {
+		Version v1 = Version.parseVersion("raw:1");
+		Version v2 = Version.parseVersion("raw:1.0");
+		Version v3 = Version.parseVersion("raw:1.0.0");
+		Version v4 = Version.parseVersion("raw:1.0.0.'9'");
+		Version v5 = Version.parseVersion("raw:1.0.0.'r12345'");
+
+		assertOrder(v1, v2);
+		assertOrder(v2, v3);
+		assertOrder(v3, v4);
+		assertOrder(v4, v5);
+	}
+
+	public void testTypeOrder() {
+		// '' < 'z' < m < [0} < [M] < 0 < M
+		Version v0 = Version.parseVersion("raw:-M");
+		Version v1 = Version.parseVersion("raw:''");
+		Version v2 = Version.parseVersion("raw:'z'");
+		Version v3 = Version.parseVersion("raw:m");
+		Version v4 = Version.parseVersion("raw:<0>");
+		Version v5 = Version.parseVersion("raw:<M>");
+		Version v6 = Version.parseVersion("raw:0");
+		Version v7 = Version.parseVersion("raw:M");
+
+		assertOrder(v0, v1);
+		assertOrder(v1, v2);
+		assertOrder(v2, v3);
+		assertOrder(v3, v4);
+		assertOrder(v4, v5);
+		assertOrder(v5, v6);
+		assertOrder(v6, v7);
+	}
+
+	public void testTypeOrder2() {
+		// '' < 'z' < m < [0] < [M] < 0 < M
+		Version v0 = Version.parseVersion("raw:0.-M");
+		Version v1 = Version.parseVersion("raw:0.''");
+		Version v2 = Version.parseVersion("raw:0.'z'");
+		Version v3 = Version.parseVersion("raw:0.m");
+		Version v4 = Version.parseVersion("raw:0.<0>");
+		Version v5 = Version.parseVersion("raw:0.<M>");
+		Version v6 = Version.parseVersion("raw:0.0");
+		Version v7 = Version.parseVersion("raw:0.M");
+
+		assertOrder(v0, v1);
+		assertOrder(v1, v2);
+		assertOrder(v2, v3);
+		assertOrder(v3, v4);
+		assertOrder(v4, v5);
+		assertOrder(v5, v6);
+		assertOrder(v6, v7);
+	}
+
+	public void testShorterIsOlder() {
+		Version v1 = Version.parseVersion("raw:1.0");
+		Version v2 = Version.parseVersion("raw:1.0.0");
+		Version v3 = Version.parseVersion("raw:1.0.0.0");
+
+		Version v4 = Version.parseVersion("raw:'a'");
+		Version v5 = Version.parseVersion("raw:'a'.'b'.'b'");
+		Version v6 = Version.parseVersion("raw:'a'.'b'.'b'.'b'");
+
+		Version v7 = Version.parseVersion("raw:<1>");
+		Version v8 = Version.parseVersion("raw:<1>.<0>.<0>");
+		Version v9 = Version.parseVersion("raw:<1>.<0>.<0>.<0>");
+
+		assertOrder(v1, v2);
+		assertOrder(v2, v3);
+
+		assertOrder(v4, v5);
+		assertOrder(v5, v6);
+
+		assertOrder(v7, v8);
+		assertOrder(v8, v9);
+	}
+
+	public void testNumericVersionOrder() {
+		Version v1 = Version.parseVersion("1");
+		Version v2 = Version.parseVersion("1.0.1");
+		Version v3 = Version.parseVersion("1.1");
+		Version v4 = Version.parseVersion("1.1.1");
+		Version v5 = Version.parseVersion("1.1.1.-");
+		Version v6 = Version.parseVersion("1.2");
+		Version v7 = Version.parseVersion("2");
+		Version v8 = Version.parseVersion("10.0");
+
+		assertOrder(v1, v2);
+		assertOrder(v2, v3);
+		assertOrder(v3, v4);
+		assertOrder(v4, v5);
+		assertOrder(v5, v6);
+		assertOrder(v6, v7);
+		assertOrder(v7, v8);
+
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawWithOriginalTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawWithOriginalTest.java
new file mode 100644
index 0000000..1b201a1
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/RawWithOriginalTest.java
@@ -0,0 +1,144 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+
+/**
+ * Tests inclusion of original version string in the raw format.
+ * The tests in this class does not fully test the various "format(rules)" only that the sequence "raw/format():original"
+ * works, and that errors at the top level are caught.
+ * 
+ */
+public class RawWithOriginalTest extends VersionTesting {
+
+	public void testRawWithUnknownFormat() {
+		Version v = Version.parseVersion("raw:1.0/:silver.moon");
+		assertNotNull(v);
+		assertEquals(v, Version.parseVersion("raw:1.0"));
+	}
+
+	public void testRawWithUnknownFormatToString() {
+		assertEquals("raw:1.0/:silver.moon", Version.parseVersion("raw:1.0/:silver.moon").toString());
+	}
+
+	public void testRawWithUnknownFormatSerialized() {
+		assertSerialized(Version.parseVersion("raw:1.0/:silver.moon"));
+		assertEquals("raw:1.0/:silver.moon", getSerialized(new Version("raw:1.0/:silver.moon")).toString());
+
+	}
+
+	public void testRawWithSimpleFormat() {
+		Version v = Version.parseVersion("raw:1.0/format(n.n):1.0");
+		assertNotNull(v);
+		assertEquals(v, Version.parseVersion("raw:1.0"));
+	}
+
+	public void testRawWithSimpleFormatToString() {
+		assertEquals("raw:1.0/format(n.n):1.0", Version.parseVersion("raw:1.0/format(n.n):1.0").toString());
+	}
+
+	public void testRawWithSimpleFormatSerialized() {
+		assertSerialized(Version.parseVersion("raw:1.0/format(n.n):1.0"));
+		assertEquals("raw:1.0/format(n.n):1.0", getSerialized(new Version("raw:1.0/format(n.n):1.0")).toString());
+	}
+
+	public void testOriginalStatedButMissing() {
+		try {
+			Version.parseVersion("raw:1.0/");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalAndUnknownStatedButMissing() {
+		try {
+			Version.parseVersion("raw:1.0/:");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalIllegalFormat() {
+		try {
+			Version.parseVersion("raw:1.0/foo:");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalIllegalFormat2() {
+		try {
+			Version.parseVersion("raw:1.0/100:");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalIllegalFormat3() {
+		try {
+			Version.parseVersion("raw:1.0/'format':");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalIllegalFormat4() {
+		try {
+			Version.parseVersion("raw:1.0//1.0");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalIllegalFormat5() {
+		try {
+			Version.parseVersion("raw:1.0/format:");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalFormatUnbalancedLeft() {
+		try {
+			Version.parseVersion("raw:1.0/formatn.n):");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalFormatUnbalancedRight() {
+		try {
+			Version.parseVersion("raw:1.0/format(n.n:1.0");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+
+	public void testOriginalFormatOriginalMissing() {
+		try {
+			Version.parseVersion("raw:1.0/format(n.n):");
+			fail();
+		} catch (IllegalArgumentException e) {
+			assertTrue(true);
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/VersionTesting.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/VersionTesting.java
new file mode 100644
index 0000000..16b30ff
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/omniVersion/VersionTesting.java
@@ -0,0 +1,193 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.p2.tests.omniVersion;
+
+import java.io.*;
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.*;
+
+/**
+ * Base class for version testing. Adds useful assert methods.
+ * 
+ */
+public class VersionTesting extends TestCase {
+	/**
+	 * Asserts that the versionString version is included in the range.
+	 * @param message
+	 * @param range
+	 * @param versionString
+	 */
+	public void assertIncludedInRange(String message, VersionRange range, String versionString) {
+		assertTrue(message, range.isIncluded(Version.parseVersion(versionString)));
+	}
+
+	/**
+	 * Asserts that the versionString version is not included in the range.
+	 * @param message
+	 * @param range
+	 * @param versionString
+	 */
+	public void assertNotIncludedInRange(String message, VersionRange range, String versionString) {
+		assertFalse(message, range.isIncluded(Version.parseVersion(versionString)));
+	}
+
+	/** 
+	 * A strict assertion of order.
+	 * asserts that b > a, a < b, a !=b, b != a
+	 * @param a
+	 * @param b
+	 */
+	public static void assertOrder(Object a, Object b) {
+		if (!(a instanceof Comparable && b instanceof Comparable))
+			fail("can not assert order on non Comparable instances");
+		// fully test comparison
+		if (((Comparable) a).compareTo(b) > 0)
+			fail("a > b");
+		else if (((Comparable) b).compareTo(a) < 0)
+			fail("b < a");
+		else if (((Comparable) b).compareTo(a) == 0)
+			fail("b == a");
+		else if (((Comparable) a).compareTo(b) == 0)
+			fail("a == b");
+
+		assertTrue(true);
+	}
+
+	//	/**
+	//	 * Assert that pad of v is the same as the single element raw version string
+	//	 * @param v
+	//	 * @param rawVersionString
+	//	 */
+	//	public static void assertPad(VersionVector v, String rawVersionString) {
+	//		assertNotNull(v);
+	//		assertNotNull(rawVersionString);
+	//		Version v2 = Version.parseVersion(rawVersionString);
+	//		assertNotNull(v2);
+	//
+	//		assertEquals(v.getPad(), v2);
+	//	}
+
+	/**
+	 * Assert that pad of v is the same as the single element raw version string
+	 * @param v
+	 * @param rawVersionString
+	 */
+	public static void assertPad(Comparable v, String rawVersionString) {
+		assertTrue(v instanceof VersionVector);
+		assertNotNull(rawVersionString);
+		Version v2 = Version.parseVersion(rawVersionString);
+		assertNotNull(v2);
+
+		assertEquals(((VersionVector) v).getPad(), v2.getSegment(0));
+	}
+
+	/**
+	 * Asserts serialization of a VersionRange instance.
+	 * @param v
+	 */
+	public static void assertSerialized(VersionRange range) {
+		assertEquals(range, getSerialized(range));
+	}
+
+	public static VersionRange getSerialized(VersionRange range) {
+		ByteArrayOutputStream out = new ByteArrayOutputStream();
+		ObjectOutputStream os = null;
+		try {
+			os = new ObjectOutputStream(out);
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("IOException creating ObjectOutputStream");
+		}
+		try {
+			os.writeObject(range);
+
+		} catch (NotSerializableException e) {
+			fail("Impl of VersionRange is wrong - it is not serializeable");
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("write of objectfailed");
+		}
+		try {
+			os.close();
+		} catch (IOException e1) {
+			// TODO Auto-generated catch block
+			fail("close of output stream failed");
+		}
+
+		ObjectInputStream is = null;
+		ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
+		try {
+			is = new ObjectInputStream(in);
+		} catch (IOException e) {
+			fail("Can not create object input stream");
+		}
+		VersionRange range2 = null;
+		try {
+			range2 = (VersionRange) is.readObject();
+		} catch (IOException e) {
+			fail("IO failure reading version range");
+		} catch (ClassNotFoundException e) {
+			fail("ClassNotFountException");
+		}
+		return range2;
+	}
+
+	/**
+	 * Asserts serialization of a Version instance.
+	 * @param v
+	 */
+	public static void assertSerialized(Version v) {
+		assertEquals(v, getSerialized(v));
+	}
+
+	public static Version getSerialized(Version v) {
+		ByteArrayOutputStream out = new ByteArrayOutputStream();
+		ObjectOutputStream os = null;
+		try {
+			os = new ObjectOutputStream(out);
+		} catch (IOException e) {
+			fail("IOException creating ObjectOutputStream");
+		}
+		try {
+			os.writeObject(v);
+		} catch (NotSerializableException e) {
+			e.printStackTrace();
+			fail("Impl of Version is wrong - it is not serializeable");
+		} catch (IOException e) {
+			fail("write of objectfailed");
+		}
+		try {
+			os.close();
+		} catch (IOException e1) {
+			// TODO Auto-generated catch block
+			fail("close of output stream failed");
+		}
+
+		ObjectInputStream is = null;
+		ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
+		try {
+			is = new ObjectInputStream(in);
+		} catch (IOException e) {
+			fail("Can not create object input stream");
+		}
+		Version v2 = null;
+		try {
+			v2 = (Version) is.readObject();
+		} catch (IOException e) {
+			fail("IO failure reading version range");
+		} catch (ClassNotFoundException e) {
+			fail("ClassNotFountException");
+		}
+		return v2;
+
+	}
+}
