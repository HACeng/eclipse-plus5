commit e7b5ddb37f84a3dd4f8be2371cebc164fa9b723e
Author: Simon Kaegi <skaegi>
Date:   Tue Feb 24 17:55:17 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf

82	50	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
382	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
7	7	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
1	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/AllTests.java
128	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
4	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index 87f2fd9..a7bbd98 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -15,26 +15,31 @@ import java.util.zip.ZipFile;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.publisher.AbstractAdvice;
+import org.eclipse.equinox.p2.publisher.actions.ICapabilityAdvice;
 
 /**
  * Publishing advice from a p2 advice file. An advice file (p2.inf) can be embedded
  * in the source of a bundle, feature, or product to specify additional advice to be
  * added to the {@link IInstallableUnit} corresponding to the bundle, feature, or product.
  */
-public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvice {
+public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvice, ICapabilityAdvice, IBundleAdvice {
+
 	/**
 	 * The location of the bundle advice file, relative to the bundle root location.
 	 */
 	public static final IPath BUNDLE_ADVICE_FILE = new Path("META-INF/p2.inf"); //$NON-NLS-1$
 
-	private static final String ADVICE_INSTRUCTIONS_PREFIX = "instructions."; //$NON-NLS-1$
-	private final IPath basePath;
-	private final IPath adviceFilePath;
-
 	private final String id;
 	private final Version version;
 
+	private Map touchpointInstructions;
+	private IProvidedCapability[] providedCapabilities;
+	private IRequiredCapability[] requiredCapabilities;
+	private Properties iuProperties;
+	private InstallableUnitDescription[] otherIUs;
+
 	/**
 	 * Creates advice for an advice file at the given location. If <tt>basePath</tt>
 	 * is a directory, then <tt>adviceFilePath</tt> is appended to this location to
@@ -55,14 +60,24 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 		Assert.isNotNull(adviceFilePath);
 		this.id = id;
 		this.version = version;
-		this.basePath = basePath;
-		this.adviceFilePath = adviceFilePath;
+
+		Map advice = loadAdviceMap(basePath, adviceFilePath);
+		if (advice.isEmpty())
+			return;
+
+		AdviceFileParser parser = new AdviceFileParser(advice);
+		parser.parse();
+		touchpointInstructions = parser.getTouchpointInstructions();
+		providedCapabilities = parser.getProvidedCapabilities();
+		requiredCapabilities = parser.getRequiredCapabilities();
+		iuProperties = parser.getProperties();
+		otherIUs = parser.getOtherInstallableUnitDescriptions();
 	}
 
 	/**
 	 * Loads the advice file and returns it in map form.
 	 */
-	private Map getInstructions() {
+	private static Map loadAdviceMap(IPath basePath, IPath adviceFilePath) {
 		File location = basePath.toFile();
 		if (location == null || !location.exists())
 			return Collections.EMPTY_MAP;
@@ -72,31 +87,21 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 		try {
 			if (location.isDirectory()) {
 				File adviceFile = new File(location, adviceFilePath.toString());
-				try {
-					stream = new BufferedInputStream(new FileInputStream(adviceFile));
-				} catch (IOException e) {
-					return Collections.EMPTY_MAP;
-				}
+				stream = new BufferedInputStream(new FileInputStream(adviceFile));
 			} else if (location.isFile()) {
-				try {
-					jar = new ZipFile(location);
-					ZipEntry entry = jar.getEntry(adviceFilePath.toString());
-					if (entry == null)
-						return Collections.EMPTY_MAP;
-					stream = new BufferedInputStream(jar.getInputStream(entry));
-				} catch (IOException e) {
+				jar = new ZipFile(location);
+				ZipEntry entry = jar.getEntry(adviceFilePath.toString());
+				if (entry == null)
 					return Collections.EMPTY_MAP;
-				}
-			}
 
-			Properties advice = null;
-			try {
-				advice = new Properties();
-				advice.load(stream);
-			} catch (IOException e) {
-				return Collections.EMPTY_MAP;
+				stream = new BufferedInputStream(jar.getInputStream(entry));
 			}
-			return advice != null ? advice : Collections.EMPTY_MAP;
+
+			Properties advice = new Properties();
+			advice.load(stream);
+			return (advice != null ? advice : Collections.EMPTY_MAP);
+		} catch (IOException e) {
+			return Collections.EMPTY_MAP;
 		} finally {
 			if (stream != null)
 				try {
@@ -114,37 +119,64 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 	}
 
 	public boolean isApplicable(String configSpec, boolean includeDefault, String candidateId, Version candidateVersion) {
-		if (!id.equals(candidateId) || !version.equals(candidateVersion))
-			return false;
-		// only process this advice if there is an advice file present
-		File location = basePath.toFile();
-		if (!location.isDirectory())
-			return location.exists();
-		return new File(location, adviceFilePath.toString()).exists();
+		return id.equals(candidateId) && version.equals(candidateVersion);
 	}
 
 	/*(non-Javadoc)
 	 * @see org.eclipse.equinox.p2.publisher.eclipse.ITouchpointAdvice#getTouchpointData()
 	 */
 	public ITouchpointData getTouchpointData(ITouchpointData existing) {
-		Map touchpointData = new HashMap(existing.getInstructions());
-		Map bundleAdvice = getInstructions();
-		for (Iterator iterator = bundleAdvice.keySet().iterator(); iterator.hasNext();) {
+		if (touchpointInstructions == null)
+			return existing;
+
+		Map resultInstructions = new HashMap(existing.getInstructions());
+		for (Iterator iterator = touchpointInstructions.keySet().iterator(); iterator.hasNext();) {
 			String key = (String) iterator.next();
-			if (key.startsWith(ADVICE_INSTRUCTIONS_PREFIX)) {
-				String phase = key.substring(ADVICE_INSTRUCTIONS_PREFIX.length());
-				String instruction = ""; //$NON-NLS-1$
-				if (touchpointData.containsKey(phase)) {
-					Object previous = touchpointData.get(phase);
-					instruction = previous instanceof ITouchpointInstruction ? ((ITouchpointInstruction) previous).getBody() : (String) previous;
-					if (instruction.length() > 0 && !instruction.endsWith(";")) //$NON-NLS-1$
-						instruction += ';';
+			ITouchpointInstruction instruction = (ITouchpointInstruction) touchpointInstructions.get(key);
+			ITouchpointInstruction existingInstruction = (ITouchpointInstruction) resultInstructions.get(key);
+
+			if (existingInstruction != null) {
+				String body = existingInstruction.getBody();
+				if (body == null || body.length() == 0)
+					body = instruction.getBody();
+				else if (instruction.getBody() != null) {
+					if (!body.endsWith(";")) //$NON-NLS-1$
+						body += ';';
+					body += instruction.getBody();
 				}
-				instruction += ((String) bundleAdvice.get(key)).trim();
-				touchpointData.put(phase, instruction);
+
+				String importAttribute = existingInstruction.getImportAttribute();
+				if (importAttribute == null || importAttribute.length() == 0)
+					importAttribute = instruction.getImportAttribute();
+				else if (instruction.getImportAttribute() != null) {
+					if (!importAttribute.endsWith(",")) //$NON-NLS-1$
+						importAttribute += ',';
+					importAttribute += instruction.getBody();
+				}
+				instruction = MetadataFactory.createTouchpointInstruction(body, importAttribute);
 			}
+			resultInstructions.put(key, instruction);
 		}
-		return MetadataFactory.createTouchpointData(touchpointData);
+		return MetadataFactory.createTouchpointData(resultInstructions);
+	}
+
+	public IProvidedCapability[] getProvidedCapabilities(InstallableUnitDescription iu) {
+		return providedCapabilities;
 	}
 
+	public IRequiredCapability[] getRequiredCapabilities(InstallableUnitDescription iu) {
+		return requiredCapabilities;
+	}
+
+	public Properties getArtifactProperties(File location) {
+		return null;
+	}
+
+	public Properties getIUProperties(File location) {
+		return iuProperties;
+	}
+
+	public InstallableUnitDescription[] getOtherInstallableUnitDescriptions(IInstallableUnit iu) {
+		return otherIUs;
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
new file mode 100644
index 0000000..b09228e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
@@ -0,0 +1,382 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others. All rights reserved. This
+ * program and the accompanying materials are made available under the terms of
+ * the Eclipse Public License v1.0 which accompanies this distribution, and is
+ * available at http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ ******************************************************************************/
+package org.eclipse.equinox.p2.publisher.eclipse;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.*;
+import java.util.Map.Entry;
+import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitFragmentDescription;
+
+public class AdviceFileParser {
+
+	private Properties adviceProperties = new Properties();
+	private List adviceProvides = new ArrayList();
+	private List adviceRequires = new ArrayList();
+	private Map adviceInstructions = new HashMap();
+	private List adviceOtherIUs = new ArrayList();
+
+	private final Map advice;
+	private Iterator keysIterator;
+	private String current;
+
+	public AdviceFileParser(Map advice) {
+		this.advice = advice;
+	}
+
+	public void parse() {
+		List keys = new ArrayList(advice.keySet());
+		Collections.sort(keys);
+
+		keysIterator = keys.iterator();
+		next();
+
+		while (current != null) {
+			if (current.startsWith("properties."))
+				parseProperties("properties.", adviceProperties);
+			else if (current.startsWith("provides."))
+				parseProvides("provides.", adviceProvides);
+			else if (current.startsWith("requires."))
+				parseRequires("requires.", adviceRequires);
+			else if (current.startsWith("instructions."))
+				parseInstructions("instructions.", adviceInstructions);
+			else if (current.startsWith("unit."))
+				parseUnit("unit.", adviceOtherIUs);
+			else
+				throw new IllegalStateException("bad token: " + current);
+		}
+	}
+
+	private void next() {
+		current = (String) (keysIterator.hasNext() ? keysIterator.next() : null);
+	}
+
+	private String currentValue() {
+		return (String) advice.get(current);
+	}
+
+	private void parseProperties(String prefix, Map properties) {
+		while (current != null && current.startsWith(prefix)) {
+			String propertyName = current.substring(prefix.length());
+			if (propertyName.indexOf('.') != -1)
+				throw new IllegalStateException();
+			properties.put(propertyName, currentValue());
+			next();
+		}
+	}
+
+	private void parseProvides(String prefix, List provides) {
+		while (current != null && current.startsWith(prefix)) {
+			int dotIndex = current.indexOf('.', prefix.length());
+			if (dotIndex == -1)
+				throw new IllegalStateException("bad token: " + current);
+
+			parseProvided(current.substring(0, dotIndex + 1), provides);
+		}
+	}
+
+	private void parseProvided(String prefix, List provides) {
+		String namespace = null;
+		String name = null;
+		Version capabilityVersion = null;
+		while (current != null && current.startsWith(prefix)) {
+			String token = current.substring(prefix.length());
+			if (token.equals("name")) {
+				name = (String) advice.get(current);
+			} else if (token.equals("namespace")) {
+				namespace = (String) advice.get(current);
+			} else if (token.equals("version")) {
+				capabilityVersion = new Version((String) advice.get(current));
+			} else
+				throw new IllegalStateException("bad token: " + current);
+			next();
+		}
+
+		IProvidedCapability capability = MetadataFactory.createProvidedCapability(namespace, name, capabilityVersion);
+		provides.add(capability);
+	}
+
+	private void parseRequires(String prefix, List requires) {
+		while (current != null && current.startsWith(prefix)) {
+			int dotIndex = current.indexOf('.', prefix.length());
+			if (dotIndex == -1)
+				throw new IllegalStateException("bad token: " + current);
+
+			parseRequired(current.substring(0, dotIndex + 1), requires);
+		}
+	}
+
+	private void parseRequired(String prefix, List requires) {
+
+		String namespace = null;
+		String name = null;
+		VersionRange range = null;
+		String filter = null;
+		boolean optional = false;
+		boolean multiple = false;
+		boolean greedy = false;
+
+		while (current != null && current.startsWith(prefix)) {
+			String token = current.substring(prefix.length());
+			if (token.equals("greedy")) {
+				greedy = Boolean.valueOf(currentValue()).booleanValue();
+			} else if (token.equals("optional")) {
+				optional = Boolean.valueOf(currentValue()).booleanValue();
+			} else if (token.equals("multiple")) {
+				multiple = Boolean.valueOf(currentValue()).booleanValue();
+			} else if (token.equals("filter")) {
+				filter = currentValue();
+			} else if (token.equals("name")) {
+				name = currentValue();
+			} else if (token.equals("namespace")) {
+				namespace = currentValue();
+			} else if (token.equals("range")) {
+				range = new VersionRange(currentValue());
+			} else
+				throw new IllegalStateException("bad token: " + current);
+			next();
+		}
+		IRequiredCapability capability = MetadataFactory.createRequiredCapability(namespace, name, range, filter, optional, multiple, greedy);
+		requires.add(capability);
+	}
+
+	private void parseInstructions(String prefix, Map instructions) {
+		while (current != null && current.startsWith(prefix)) {
+			int dotIndex = current.indexOf('.', prefix.length());
+			if (dotIndex != -1)
+				throw new IllegalStateException("bad token: " + current);
+
+			parseInstruction(current, instructions);
+		}
+	}
+
+	private void parseInstruction(String prefix, Map instructions) {
+		String phase = current.substring(current.lastIndexOf('.') + 1);
+		String body = currentValue();
+		next();
+
+		prefix += ".";
+		String importAttribute = null;
+		if (current != null && current.startsWith(prefix)) {
+			if (current.substring(prefix.length()).equals("import")) {
+				importAttribute = currentValue();
+			} else
+				throw new IllegalStateException("bad token: " + current);
+			next();
+		}
+		ITouchpointInstruction instruction = MetadataFactory.createTouchpointInstruction(body, importAttribute);
+		instructions.put(phase, instruction);
+	}
+
+	private void parseUnit(String prefix, List units) {
+		String unitId = null;
+		Version unitVersion = null;
+		boolean unitSingleton = false;
+		String unitFilter = null;
+		String unitCopyright = null;
+		String unitCopyrightLocation = null;
+		String unitTouchpointId = null;
+		Version unitTouchpointVersion = null;
+
+		List unitArtifacts = new ArrayList();
+		Properties unitProperties = new Properties();
+		List unitHostRequirements = new ArrayList();
+		List unitProvides = new ArrayList();
+		List unitRequires = new ArrayList();
+		List unitLicenses = new ArrayList();
+		Map unitInstructions = new HashMap();
+		//		updatedescriptor ??
+
+		while (current != null && current.startsWith(prefix)) {
+			String token = current.substring(prefix.length());
+			if (token.equals("id"))
+				unitId = currentValue();
+			else if (token.equals("version"))
+				unitVersion = new Version(currentValue());
+			else if (token.equals("filter"))
+				unitFilter = currentValue();
+			else if (token.equals("copyright"))
+				unitCopyright = currentValue();
+			else if (token.equals("copyright.location"))
+				unitCopyrightLocation = currentValue();
+			else if (token.equals("touchpoint.id"))
+				unitTouchpointId = currentValue();
+			else if (token.equals("touchpoinit.version"))
+				unitTouchpointVersion = new Version(currentValue());
+			else if (token.startsWith("hostRequirements."))
+				parseHostRequirements(prefix + "hostRequirements.", unitHostRequirements);
+			else if (token.startsWith("arifacts."))
+				parseArtifacts(prefix + "arifacts.", unitArtifacts);
+			else if (token.startsWith("licenses."))
+				parseLicenses(prefix + "licenses.", unitLicenses);
+			else if (token.startsWith("properties."))
+				parseProperties(prefix + "properties.", unitProperties);
+			else if (token.startsWith("provides."))
+				parseProvides(prefix + "provides.", unitProvides);
+			else if (token.startsWith("requires."))
+				parseRequires(prefix + "requires.", unitRequires);
+			else if (token.startsWith("instructions."))
+				parseInstructions(prefix + "instructions.", unitInstructions);
+			else
+				throw new IllegalStateException("bad token: " + current);
+		}
+
+		InstallableUnitDescription description = unitHostRequirements.isEmpty() ? new InstallableUnitDescription() : new InstallableUnitFragmentDescription();
+		description.setId(unitId);
+		description.setVersion(unitVersion);
+		description.setSingleton(unitSingleton);
+		description.setFilter(unitFilter);
+		if (unitCopyright != null || unitCopyrightLocation != null) {
+			try {
+				description.setCopyright(MetadataFactory.createCopyright(new URI(unitCopyrightLocation), unitCopyright));
+			} catch (URISyntaxException e) {
+				throw new IllegalStateException();
+			}
+		}
+		if (unitTouchpointId != null)
+			description.setTouchpointType(MetadataFactory.createTouchpointType(unitTouchpointId, unitTouchpointVersion));
+		if (!unitLicenses.isEmpty())
+			description.setLicense((ILicense) unitLicenses.get(0));
+
+		if (!unitArtifacts.isEmpty())
+			description.setArtifacts((IArtifactKey[]) unitArtifacts.toArray(new IArtifactKey[unitArtifacts.size()]));
+
+		if (!unitHostRequirements.isEmpty())
+			((InstallableUnitFragmentDescription) description).setHost((IRequiredCapability[]) unitHostRequirements.toArray(new IRequiredCapability[unitHostRequirements.size()]));
+
+		if (!unitProperties.isEmpty()) {
+			for (Iterator iterator = unitProperties.entrySet().iterator(); iterator.hasNext();) {
+				Entry entry = (Entry) iterator.next();
+				description.setProperty((String) entry.getKey(), (String) entry.getValue());
+			}
+		}
+
+		if (!unitProvides.isEmpty())
+			description.setCapabilities((IProvidedCapability[]) unitProvides.toArray(new IProvidedCapability[unitProvides.size()]));
+
+		if (!unitRequires.isEmpty())
+			description.setRequiredCapabilities((IRequiredCapability[]) unitRequires.toArray(new IRequiredCapability[unitRequires.size()]));
+
+		if (!unitInstructions.isEmpty())
+			description.addTouchpointData(MetadataFactory.createTouchpointData(unitInstructions));
+
+		adviceOtherIUs.add(description);
+	}
+
+	private void parseLicenses(String prefix, List licenses) {
+		while (current != null && current.startsWith(prefix)) {
+			int dotIndex = current.indexOf('.', prefix.length());
+			if (dotIndex == -1)
+				throw new IllegalStateException("bad token: " + current);
+
+			parseLicense(current.substring(0, dotIndex + 1), licenses);
+		}
+	}
+
+	private void parseLicense(String prefix, List licenses) {
+		String body = currentValue();
+		next();
+
+		prefix += ".";
+		String location = null;
+		if (current != null && current.startsWith(prefix)) {
+			if (current.substring(prefix.length()).equals("import")) {
+				location = currentValue();
+			} else
+				throw new IllegalStateException("bad token: " + current);
+			next();
+		}
+
+		try {
+			ILicense license = MetadataFactory.createLicense(new URI(location), body);
+			licenses.add(license);
+		} catch (URISyntaxException e) {
+			throw new IllegalStateException();
+		}
+	}
+
+	private void parseArtifacts(String prefix, List artifacts) {
+		while (current != null && current.startsWith(prefix)) {
+			int dotIndex = current.indexOf('.', prefix.length());
+			if (dotIndex == -1)
+				throw new IllegalStateException("bad token: " + current);
+
+			parseArtifact(current.substring(0, dotIndex + 1), artifacts);
+		}
+	}
+
+	private void parseArtifact(String prefix, List artifacts) {
+		String artifactClassifier = "osgi.bundle";
+		String artifactId = null;
+		Version artifactVersion = null;
+		while (current != null && current.startsWith(prefix)) {
+			String token = current.substring(prefix.length());
+			if (token.equals("classifier")) {
+				artifactClassifier = currentValue();
+			} else if (token.equals("id")) {
+				artifactId = currentValue();
+			} else if (token.equals("version")) {
+				artifactVersion = new Version(currentValue());
+			} else
+				throw new IllegalStateException("bad token: " + current);
+			next();
+		}
+		IArtifactKey artifactKey = new ArtifactKey(artifactClassifier, artifactId, artifactVersion);
+		artifacts.add(artifactKey);
+	}
+
+	private void parseHostRequirements(String prefix, List hostRequirements) {
+		while (current != null && current.startsWith(prefix)) {
+			int dotIndex = current.indexOf('.', prefix.length());
+			if (dotIndex == -1)
+				throw new IllegalStateException("bad token: " + current);
+
+			parseRequired(current.substring(0, dotIndex + 1), hostRequirements);
+		}
+	}
+
+	public Properties getProperties() {
+		if (adviceProperties.isEmpty())
+			return null;
+		return adviceProperties;
+	}
+
+	public IRequiredCapability[] getRequiredCapabilities() {
+		if (adviceRequires.isEmpty())
+			return null;
+
+		return (IRequiredCapability[]) adviceRequires.toArray(new IRequiredCapability[adviceRequires.size()]);
+	}
+
+	public IProvidedCapability[] getProvidedCapabilities() {
+		if (adviceProvides.isEmpty())
+			return null;
+
+		return (IProvidedCapability[]) adviceProvides.toArray(new IProvidedCapability[adviceProvides.size()]);
+	}
+
+	public Map getTouchpointInstructions() {
+		if (adviceInstructions.isEmpty())
+			return null;
+
+		return adviceInstructions;
+	}
+
+	public InstallableUnitDescription[] getOtherInstallableUnitDescriptions() {
+		if (adviceOtherIUs.isEmpty())
+			return null;
+
+		return (InstallableUnitDescription[]) adviceOtherIUs.toArray(new IProvidedCapability[adviceOtherIUs.size()]);
+	}
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
index 6960266..9228f0e 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
@@ -243,14 +243,14 @@ public class BundlesAction extends AbstractPublisherAction {
 
 	/**
 	 * Add all of the advised properties for the bundle at the given location to the given IU.
-	 * @param bundle the bundle IU to decorate
+	 * @param iu the bundle IU to decorate
 	 * @param location the location of the bundle
 	 * @param info the publisher info supplying the advice
 	 */
-	private static void processPropertiesAdvice(InstallableUnitDescription bundle, String location, IPublisherInfo info) {
+	private static void processPropertiesAdvice(InstallableUnitDescription iu, String location, IPublisherInfo info) {
 		if (location == null)
 			return;
-		Collection advice = info.getAdvice(null, false, null, null, IBundleAdvice.class);
+		Collection advice = info.getAdvice(null, false, iu.getId(), iu.getVersion(), IBundleAdvice.class);
 		File bundleFile = new File(location);
 		for (Iterator i = advice.iterator(); i.hasNext();) {
 			IBundleAdvice entry = (IBundleAdvice) i.next();
@@ -259,7 +259,7 @@ public class BundlesAction extends AbstractPublisherAction {
 				continue;
 			for (Iterator j = props.keySet().iterator(); j.hasNext();) {
 				String key = (String) j.next();
-				bundle.setProperty(key, props.getProperty(key));
+				iu.setProperty(key, props.getProperty(key));
 			}
 		}
 	}
@@ -270,18 +270,18 @@ public class BundlesAction extends AbstractPublisherAction {
 	 * @param info the publisher info supplying the advice
 	 */
 	private static void processCapabilityAdvice(InstallableUnitDescription iu, BundleDescription bundle, IPublisherInfo info) {
-		Collection advice = info.getAdvice(null, false, null, null, ICapabilityAdvice.class);
+		Collection advice = info.getAdvice(null, false, iu.getId(), iu.getVersion(), ICapabilityAdvice.class);
 		for (Iterator i = advice.iterator(); i.hasNext();) {
 			ICapabilityAdvice entry = (ICapabilityAdvice) i.next();
 			IRequiredCapability[] requiredAdvice = entry.getRequiredCapabilities(iu);
-			IProvidedCapability[] providedAdvice = entry.getProvidedCapabilities(iu);
-			if (providedAdvice != null) {
+			if (requiredAdvice != null) {
 				IRequiredCapability[] current = iu.getRequiredCapabilities();
 				IRequiredCapability[] result = new IRequiredCapability[requiredAdvice.length + current.length];
 				System.arraycopy(requiredAdvice, 0, result, 0, requiredAdvice.length);
 				System.arraycopy(current, 0, result, requiredAdvice.length, current.length);
 				iu.setRequiredCapabilities(result);
 			}
+			IProvidedCapability[] providedAdvice = entry.getProvidedCapabilities(iu);
 			if (providedAdvice != null) {
 				IProvidedCapability[] current = iu.getProvidedCapabilities();
 				IProvidedCapability[] result = new IProvidedCapability[providedAdvice.length + current.length];
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/AllTests.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/AllTests.java
index 75b93c8..4e6283d 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/AllTests.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/AllTests.java
@@ -18,6 +18,7 @@ public class AllTests extends TestCase {
 	public static Test suite() {
 		TestSuite suite = new TestSuite(AllTests.class.getName());
 		suite.addTestSuite(AccumulateConfigDataActionTest.class);
+		suite.addTestSuite(AdviceFileParserTest.class);
 		suite.addTestSuite(BundlesActionTest.class);
 		suite.addTestSuite(ConfigCUsActionTest.class);
 		suite.addTestSuite(DefaultCUsActionTest.class);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
new file mode 100644
index 0000000..4d2860e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
@@ -0,0 +1,128 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.tests.publisher.actions;
+
+import java.util.*;
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.p2.publisher.eclipse.AdviceFileParser;
+
+public class AdviceFileParserTest extends TestCase {
+	public void testNoAdvice() {
+		AdviceFileParser parser = new AdviceFileParser(Collections.EMPTY_MAP);
+		parser.parse();
+	}
+
+	public void testPropertyAdvice() {
+		Map map = new HashMap();
+		map.put("properties.testName1", "testValue1");
+		map.put("properties.testName2", "testValue2");
+
+		AdviceFileParser parser = new AdviceFileParser(map);
+		parser.parse();
+		assertEquals("testValue1", parser.getProperties().getProperty("testName1"));
+		assertEquals("testValue2", parser.getProperties().getProperty("testName2"));
+	}
+
+	public void testProvidesAdvice() {
+		Map map = new HashMap();
+		map.put("provides.0.namespace", "testNamespace1");
+		map.put("provides.0.name", "testName1");
+		map.put("provides.0.version", "1.2.3");
+
+		AdviceFileParser parser = new AdviceFileParser(map);
+		parser.parse();
+		IProvidedCapability[] capabilities = parser.getProvidedCapabilities();
+		assertEquals(1, capabilities.length);
+		assertEquals("testNamespace1", capabilities[0].getNamespace());
+		assertEquals("testName1", capabilities[0].getName());
+		assertEquals(new Version("1.2.3"), capabilities[0].getVersion());
+
+		map.put("provides.1.namespace", "testNamespace2");
+		map.put("provides.1.name", "testName2");
+		map.put("provides.1.version", "1.2.4");
+
+		parser = new AdviceFileParser(map);
+		parser.parse();
+		capabilities = parser.getProvidedCapabilities();
+		assertEquals(2, capabilities.length);
+		assertEquals("testNamespace1", capabilities[0].getNamespace());
+		assertEquals("testName1", capabilities[0].getName());
+		assertEquals(new Version("1.2.3"), capabilities[0].getVersion());
+		assertEquals("testNamespace2", capabilities[1].getNamespace());
+		assertEquals("testName2", capabilities[1].getName());
+		assertEquals(new Version("1.2.4"), capabilities[1].getVersion());
+	}
+
+	public void testRequiresAdvice() {
+		Map map = new HashMap();
+		map.put("requires.0.namespace", "testNamespace1");
+		map.put("requires.0.name", "testName1");
+		map.put("requires.0.range", "1.2.3");
+		map.put("requires.0.greedy", Boolean.TRUE.toString());
+		map.put("requires.0.optional", Boolean.TRUE.toString());
+		map.put("requires.0.multiple", Boolean.TRUE.toString());
+
+		AdviceFileParser parser = new AdviceFileParser(map);
+		parser.parse();
+		IRequiredCapability[] capabilities = parser.getRequiredCapabilities();
+		assertEquals(1, capabilities.length);
+		assertEquals("testNamespace1", capabilities[0].getNamespace());
+		assertEquals("testName1", capabilities[0].getName());
+		assertEquals(new VersionRange("1.2.3"), capabilities[0].getRange());
+
+		map.put("requires.1.namespace", "testNamespace2");
+		map.put("requires.1.name", "testName2");
+		map.put("requires.1.range", "1.2.4");
+		map.put("requires.1.greedy", Boolean.FALSE.toString());
+		map.put("requires.1.optional", Boolean.FALSE.toString());
+		//default 
+		//		map.put("requires.1.multiple", Boolean.FALSE.toString());
+
+		parser = new AdviceFileParser(map);
+		parser.parse();
+		capabilities = parser.getRequiredCapabilities();
+		assertEquals(2, capabilities.length);
+		assertEquals("testNamespace1", capabilities[0].getNamespace());
+		assertEquals("testName1", capabilities[0].getName());
+		assertEquals(new VersionRange("1.2.3"), capabilities[0].getRange());
+		assertEquals(true, capabilities[0].isGreedy());
+		assertEquals(true, capabilities[0].isOptional());
+		assertEquals(true, capabilities[0].isMultiple());
+		assertEquals("testNamespace2", capabilities[1].getNamespace());
+		assertEquals("testName2", capabilities[1].getName());
+		assertEquals(new VersionRange("1.2.4"), capabilities[1].getRange());
+		assertEquals(false, capabilities[1].isGreedy());
+		assertEquals(false, capabilities[1].isOptional());
+		assertEquals(false, capabilities[1].isMultiple());
+	}
+
+	public void testInstructionsAdvice() {
+		Map map = new HashMap();
+		map.put("instructions.configure", "addProgramArg(programArg:-startup); addProgramArg(programArg:@artifact);");
+
+		map.put("instructions.unconfigure", "removeProgramArg(programArg:-startup); removeProgramArg(programArg:@artifact);)");
+		map.put("instructions.unconfigure.import", "some.removeProgramArg");
+
+		AdviceFileParser parser = new AdviceFileParser(map);
+		parser.parse();
+		ITouchpointInstruction configure = (ITouchpointInstruction) parser.getTouchpointInstructions().get("configure");
+		assertEquals(null, configure.getImportAttribute());
+		assertEquals("addProgramArg(programArg:-startup); addProgramArg(programArg:@artifact);", configure.getBody());
+
+		ITouchpointInstruction unconfigure = (ITouchpointInstruction) parser.getTouchpointInstructions().get("unconfigure");
+		assertEquals("some.removeProgramArg", unconfigure.getImportAttribute());
+		assertEquals("removeProgramArg(programArg:-startup); removeProgramArg(programArg:@artifact);)", unconfigure.getBody());
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
index a99f58a..fc4ffa9 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
@@ -222,6 +222,10 @@ public class BundlesActionTest extends ActionTest {
 		adviceCollection.add(bundleAdvice);
 		expect(publisherInfo.getAdvice(null, false, null, null, IBundleAdvice.class)).andReturn(adviceCollection).anyTimes();
 		expect(publisherInfo.getArtifactRepository()).andReturn(artifactRepository).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, ICapabilityAdvice.class)).andReturn(Collections.EMPTY_LIST); //$NON-NLS-1$
+		expect(publisherInfo.getAdvice(null, false, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, IBundleAdvice.class)).andReturn(Collections.EMPTY_LIST); //$NON-NLS-1$
+		expect(publisherInfo.getAdvice(null, false, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, ICapabilityAdvice.class)).andReturn(Collections.EMPTY_LIST);//$NON-NLS-1$
+		expect(publisherInfo.getAdvice(null, false, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, IBundleAdvice.class)).andReturn(Collections.EMPTY_LIST);//$NON-NLS-1$
 		expect(publisherInfo.getAdvice(null, true, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, IBundleShapeAdvice.class)).andReturn(null); //$NON-NLS-1$
 		expect(publisherInfo.getAdvice(null, true, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, IBundleShapeAdvice.class)).andReturn(null);//$NON-NLS-1$
 		expect(publisherInfo.getArtifactOptions()).andReturn(IPublisherInfo.A_INDEX | IPublisherInfo.A_OVERWRITE | IPublisherInfo.A_PUBLISH).anyTimes();
commit d67f2f18ec92d4ec30918a493de8b6dceec485e8
Author: Andrew Niefer <aniefer>
Date:   Tue Feb 24 19:21:11 2009 +0000

    bug 265217 - [publisher] Improved IU advice support

17	3	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
18	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
index b09228e..037b3da 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
@@ -52,7 +52,7 @@ public class AdviceFileParser {
 			else if (current.startsWith("instructions."))
 				parseInstructions("instructions.", adviceInstructions);
 			else if (current.startsWith("unit."))
-				parseUnit("unit.", adviceOtherIUs);
+				parseUnits("unit.", adviceOtherIUs);
 			else
 				throw new IllegalStateException("bad token: " + current);
 		}
@@ -63,7 +63,7 @@ public class AdviceFileParser {
 	}
 
 	private String currentValue() {
-		return (String) advice.get(current);
+		return ((String) advice.get(current)).trim();
 	}
 
 	private void parseProperties(String prefix, Map properties) {
@@ -179,6 +179,16 @@ public class AdviceFileParser {
 		instructions.put(phase, instruction);
 	}
 
+	private void parseUnits(String prefix, List ius) {
+		while (current != null && current.startsWith(prefix)) {
+			int dotIndex = current.indexOf('.', prefix.length());
+			if (dotIndex == -1)
+				throw new IllegalStateException("bad token: " + current);
+
+			parseUnit(current.substring(0, dotIndex + 1), ius);
+		}
+	}
+
 	private void parseUnit(String prefix, List units) {
 		String unitId = null;
 		Version unitVersion = null;
@@ -199,6 +209,7 @@ public class AdviceFileParser {
 		//		updatedescriptor ??
 
 		while (current != null && current.startsWith(prefix)) {
+			String c = current;
 			String token = current.substring(prefix.length());
 			if (token.equals("id"))
 				unitId = currentValue();
@@ -230,6 +241,9 @@ public class AdviceFileParser {
 				parseInstructions(prefix + "instructions.", unitInstructions);
 			else
 				throw new IllegalStateException("bad token: " + current);
+
+			if (c.equals(current))
+				next();
 		}
 
 		InstallableUnitDescription description = unitHostRequirements.isEmpty() ? new InstallableUnitDescription() : new InstallableUnitFragmentDescription();
@@ -377,6 +391,6 @@ public class AdviceFileParser {
 		if (adviceOtherIUs.isEmpty())
 			return null;
 
-		return (InstallableUnitDescription[]) adviceOtherIUs.toArray(new IProvidedCapability[adviceOtherIUs.size()]);
+		return (InstallableUnitDescription[]) adviceOtherIUs.toArray(new InstallableUnitDescription[adviceOtherIUs.size()]);
 	}
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
index 9228f0e..cd1c824 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
@@ -292,6 +292,21 @@ public class BundlesAction extends AbstractPublisherAction {
 		}
 	}
 
+	private Collection processOtherIUsAdvice(IInstallableUnit iu, IPublisherInfo publisherInfo) {
+		List result = new ArrayList();
+		Collection advice = publisherInfo.getAdvice(null, false, iu.getId(), iu.getVersion(), AdviceFileAdvice.class);
+		for (Iterator iterator = advice.iterator(); iterator.hasNext();) {
+			AdviceFileAdvice entry = (AdviceFileAdvice) iterator.next();
+			InstallableUnitDescription[] others = entry.getOtherInstallableUnitDescriptions(iu);
+			for (int i = 0; others != null && i < others.length; i++) {
+				result.add(MetadataFactory.createInstallableUnit(others[i]));
+			}
+
+		}
+
+		return result;
+	}
+
 	/**
 	 * Adds all applicable touchpoint advice to the given installable unit.
 	 * @param iu The installable unit to add touchpoint advice to
@@ -740,6 +755,9 @@ public class BundlesAction extends AbstractPublisherAction {
 							}
 						}
 
+						Collection others = processOtherIUsAdvice(bundleIU, info);
+						result.addIUs(others, IPublisherResult.ROOT);
+
 						result.addIU(bundleIU, IPublisherResult.ROOT);
 						result.addIUs(localizationIUs, IPublisherResult.NON_ROOT);
 						localizationIUs.clear();
commit 419fefa675fe66c21d3166677edf3b56c92558a2
Author: Simon Kaegi <skaegi>
Date:   Wed Feb 25 04:20:00 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf

25	3	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
30	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/ITouchpointAdvice.java
0	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
12	2	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
19	16	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
3	21	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
47	41	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
0	30	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ITouchpointAdvice.java
4	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
14	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/FeaturesActionTest.java
0	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
index c1c2abc..a64c2b6 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
@@ -23,8 +23,7 @@ import org.eclipse.equinox.internal.provisional.p2.artifact.repository.processin
 import org.eclipse.equinox.internal.provisional.p2.core.*;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
 import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
-import org.eclipse.equinox.p2.publisher.actions.ICapabilityAdvice;
-import org.eclipse.equinox.p2.publisher.actions.IFilterAdvice;
+import org.eclipse.equinox.p2.publisher.actions.*;
 import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;
 
 public abstract class AbstractPublisherAction implements IPublisherAction {
@@ -201,7 +200,7 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 	 * @param iu the IU to decorate
 	 * @param info the publisher info supplying the advice
 	 */
-	protected void processCapabilityAdvice(InstallableUnitDescription iu, IPublisherInfo info) {
+	protected static void processCapabilityAdvice(InstallableUnitDescription iu, IPublisherInfo info) {
 		Collection advice = info.getAdvice(null, false, iu.getId(), iu.getVersion(), ICapabilityAdvice.class);
 		for (Iterator i = advice.iterator(); i.hasNext();) {
 			ICapabilityAdvice entry = (ICapabilityAdvice) i.next();
@@ -225,6 +224,29 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 	}
 
 	/**
+	 * Adds all applicable touchpoint advice to the given installable unit.
+	 * @param iu The installable unit to add touchpoint advice to
+	 * @param currentInstructions The set of touchpoint instructions assembled for this IU so far
+	 * @param info The publisher info
+	 */
+	protected static void processTouchpointAdvice(InstallableUnitDescription iu, Map currentInstructions, IPublisherInfo info) {
+		Collection advice = info.getAdvice(null, false, iu.getId(), iu.getVersion(), ITouchpointAdvice.class);
+		if (currentInstructions == null) {
+			if (advice.isEmpty())
+				return;
+
+			currentInstructions = new HashMap();
+		}
+
+		ITouchpointData result = MetadataFactory.createTouchpointData(currentInstructions);
+		for (Iterator i = advice.iterator(); i.hasNext();) {
+			ITouchpointAdvice entry = (ITouchpointAdvice) i.next();
+			result = entry.getTouchpointData(result);
+		}
+		iu.addTouchpointData(result);
+	}
+
+	/**
 	 * Publishes the artifact by zipping the <code>files</code> using <code>root</code>
 	 * as a base for relative paths. Then copying the zip into the repository.
 	 * @param descriptor used to identify the zip.
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/ITouchpointAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/ITouchpointAdvice.java
new file mode 100644
index 0000000..c7141f7
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/ITouchpointAdvice.java
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.publisher.actions;
+
+import org.eclipse.equinox.internal.provisional.p2.metadata.ITouchpointData;
+import org.eclipse.equinox.p2.publisher.IPublisherAdvice;
+
+/**
+ * Touchpoint advice provides information related to the touch points associated
+ * with an installable unit being published.
+ */
+public interface ITouchpointAdvice extends IPublisherAdvice {
+	/**
+	 * Returns a touchpoint data that merges the given touchpoint data
+	 * with any new touchpoint data contributed by this advice.
+	 * 
+	 * @param existingData The current set of touchpoint data.
+	 * @return the merged touchpoint data
+	 */
+	public ITouchpointData getTouchpointData(ITouchpointData existingData);
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
index 2e21ad8..843d199 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
@@ -20,7 +20,6 @@ import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.Inst
 import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.internal.provisional.p2.query.Collector;
 import org.eclipse.equinox.p2.publisher.*;
-import org.eclipse.equinox.p2.publisher.eclipse.ITouchpointAdvice;
 import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;
 import org.eclipse.osgi.util.NLS;
 
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index a7bbd98..f4ce017 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -8,6 +8,8 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.publisher.eclipse;
 
+import org.eclipse.equinox.p2.publisher.actions.ITouchpointAdvice;
+
 import java.io.*;
 import java.util.*;
 import java.util.zip.ZipEntry;
@@ -24,7 +26,7 @@ import org.eclipse.equinox.p2.publisher.actions.ICapabilityAdvice;
  * in the source of a bundle, feature, or product to specify additional advice to be
  * added to the {@link IInstallableUnit} corresponding to the bundle, feature, or product.
  */
-public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvice, ICapabilityAdvice, IBundleAdvice {
+public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvice, ICapabilityAdvice, IBundleAdvice, IFeatureAdvice {
 
 	/**
 	 * The location of the bundle advice file, relative to the bundle root location.
@@ -176,7 +178,15 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 		return iuProperties;
 	}
 
-	public InstallableUnitDescription[] getOtherInstallableUnitDescriptions(IInstallableUnit iu) {
+	public InstallableUnitDescription[] getAdditionalInstallableUnitDescriptions(IInstallableUnit iu) {
 		return otherIUs;
 	}
+
+	public Properties getArtifactProperties(Feature feature) {
+		return null;
+	}
+
+	public Properties getIUProperties(Feature feature) {
+		return iuProperties;
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
index 037b3da..a4a10ec 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
@@ -52,7 +52,7 @@ public class AdviceFileParser {
 			else if (current.startsWith("instructions."))
 				parseInstructions("instructions.", adviceInstructions);
 			else if (current.startsWith("unit."))
-				parseUnits("unit.", adviceOtherIUs);
+				parseUnits("units.", adviceOtherIUs);
 			else
 				throw new IllegalStateException("bad token: " + current);
 		}
@@ -209,26 +209,32 @@ public class AdviceFileParser {
 		//		updatedescriptor ??
 
 		while (current != null && current.startsWith(prefix)) {
-			String c = current;
 			String token = current.substring(prefix.length());
-			if (token.equals("id"))
+			if (token.equals("id")) {
 				unitId = currentValue();
-			else if (token.equals("version"))
+				next();
+			} else if (token.equals("version")) {
 				unitVersion = new Version(currentValue());
-			else if (token.equals("filter"))
+				next();
+			} else if (token.equals("filter")) {
 				unitFilter = currentValue();
-			else if (token.equals("copyright"))
+				next();
+			} else if (token.equals("copyright")) {
 				unitCopyright = currentValue();
-			else if (token.equals("copyright.location"))
+				next();
+			} else if (token.equals("copyright.location")) {
 				unitCopyrightLocation = currentValue();
-			else if (token.equals("touchpoint.id"))
+				next();
+			} else if (token.equals("touchpoint.id")) {
 				unitTouchpointId = currentValue();
-			else if (token.equals("touchpoinit.version"))
+				next();
+			} else if (token.equals("touchpoinit.version")) {
 				unitTouchpointVersion = new Version(currentValue());
-			else if (token.startsWith("hostRequirements."))
+				next();
+			} else if (token.startsWith("hostRequirements."))
 				parseHostRequirements(prefix + "hostRequirements.", unitHostRequirements);
-			else if (token.startsWith("arifacts."))
-				parseArtifacts(prefix + "arifacts.", unitArtifacts);
+			else if (token.startsWith("artifacts."))
+				parseArtifacts(prefix + "artifacts.", unitArtifacts);
 			else if (token.startsWith("licenses."))
 				parseLicenses(prefix + "licenses.", unitLicenses);
 			else if (token.startsWith("properties."))
@@ -241,9 +247,6 @@ public class AdviceFileParser {
 				parseInstructions(prefix + "instructions.", unitInstructions);
 			else
 				throw new IllegalStateException("bad token: " + current);
-
-			if (c.equals(current))
-				next();
 		}
 
 		InstallableUnitDescription description = unitHostRequirements.isEmpty() ? new InstallableUnitDescription() : new InstallableUnitFragmentDescription();
@@ -331,7 +334,7 @@ public class AdviceFileParser {
 	}
 
 	private void parseArtifact(String prefix, List artifacts) {
-		String artifactClassifier = "osgi.bundle";
+		String artifactClassifier = null;
 		String artifactId = null;
 		Version artifactVersion = null;
 		while (current != null && current.startsWith(prefix)) {
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
index cd1c824..6a47d4b 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
@@ -292,37 +292,19 @@ public class BundlesAction extends AbstractPublisherAction {
 		}
 	}
 
-	private Collection processOtherIUsAdvice(IInstallableUnit iu, IPublisherInfo publisherInfo) {
+	private Collection processAdditionalIUsAdvice(IInstallableUnit iu, IPublisherInfo publisherInfo) {
 		List result = new ArrayList();
 		Collection advice = publisherInfo.getAdvice(null, false, iu.getId(), iu.getVersion(), AdviceFileAdvice.class);
 		for (Iterator iterator = advice.iterator(); iterator.hasNext();) {
 			AdviceFileAdvice entry = (AdviceFileAdvice) iterator.next();
-			InstallableUnitDescription[] others = entry.getOtherInstallableUnitDescriptions(iu);
+			InstallableUnitDescription[] others = entry.getAdditionalInstallableUnitDescriptions(iu);
 			for (int i = 0; others != null && i < others.length; i++) {
 				result.add(MetadataFactory.createInstallableUnit(others[i]));
 			}
-
 		}
-
 		return result;
 	}
 
-	/**
-	 * Adds all applicable touchpoint advice to the given installable unit.
-	 * @param iu The installable unit to add touchpoint advice to
-	 * @param currentInstructions The set of touchpoint instructions assembled for this IU so far
-	 * @param info The publisher info
-	 */
-	private static void processTouchpointAdvice(InstallableUnitDescription iu, Map currentInstructions, IPublisherInfo info) {
-		Collection advice = info.getAdvice(null, false, iu.getId(), iu.getVersion(), ITouchpointAdvice.class);
-		ITouchpointData result = MetadataFactory.createTouchpointData(currentInstructions);
-		for (Iterator i = advice.iterator(); i.hasNext();) {
-			ITouchpointAdvice entry = (ITouchpointAdvice) i.next();
-			result = entry.getTouchpointData(result);
-		}
-		iu.addTouchpointData(result);
-	}
-
 	public static void createHostLocalizationFragment(IInstallableUnit bundleIU, BundleDescription bd, String hostId, String[] hostBundleManifestValues, Set localizationIUs) {
 		Map hostLocalizations = getHostLocalizations(new File(bd.getLocation()), hostBundleManifestValues);
 		if (hostLocalizations != null) {
@@ -755,7 +737,7 @@ public class BundlesAction extends AbstractPublisherAction {
 							}
 						}
 
-						Collection others = processOtherIUsAdvice(bundleIU, info);
+						Collection others = processAdditionalIUsAdvice(bundleIU, info);
 						result.addIUs(others, IPublisherResult.ROOT);
 
 						result.addIU(bundleIU, IPublisherResult.ROOT);
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
index 103950d..9cd0a20 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
@@ -87,37 +87,14 @@ public class FeaturesAction extends AbstractPublisherAction {
 			touchpointData.put("zipped", "true"); //$NON-NLS-1$ //$NON-NLS-2$
 			iu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		}
-		processFeatureAdvice(feature, iu, info);
+		processFeatureAdvice(iu, feature, info);
 		return MetadataFactory.createInstallableUnit(iu);
 	}
 
-	private static Properties getFeatureAdvice(Feature feature, IPublisherInfo info) {
-		Properties result = new Properties();
-		Collection advice = info.getAdvice(null, false, null, null, IFeatureAdvice.class);
-		for (Iterator i = advice.iterator(); i.hasNext();) {
-			IFeatureAdvice entry = (IFeatureAdvice) i.next();
-			Properties props = entry.getIUProperties(feature);
-			if (props != null)
-				result.putAll(props);
-		}
-		return result;
-	}
-
 	private static String getTransformedId(String original, boolean isPlugin, boolean isGroup) {
 		return (isPlugin ? original : original + (isGroup ? ".feature.group" : ".feature.jar")); //$NON-NLS-1$//$NON-NLS-2$
 	}
 
-	private static void processFeatureAdvice(Feature feature, InstallableUnitDescription iu, IPublisherInfo info) {
-		Properties extraProperties = getFeatureAdvice(feature, info);
-		if (extraProperties != null) {
-			Enumeration e = extraProperties.propertyNames();
-			while (e.hasMoreElements()) {
-				String name = (String) e.nextElement();
-				iu.setProperty(name, extraProperties.getProperty(name));
-			}
-		}
-	}
-
 	/**
 	 * Returns a URI corresponding to the given URL in string form, or null
 	 * if a well formed URI could not be created.
@@ -147,7 +124,7 @@ public class FeaturesAction extends AbstractPublisherAction {
 	 * @param info the publisher info supplying the advice
 	 */
 	protected void addProperties(ArtifactDescriptor descriptor, Feature feature, IPublisherInfo info) {
-		Collection advice = info.getAdvice(null, false, null, null, IFeatureAdvice.class);
+		Collection advice = info.getAdvice(null, false, feature.getId(), new Version(feature.getVersion()), IFeatureAdvice.class);
 		for (Iterator i = advice.iterator(); i.hasNext();) {
 			IFeatureAdvice entry = (IFeatureAdvice) i.next();
 			Properties props = entry.getArtifactProperties(feature);
@@ -195,8 +172,10 @@ public class FeaturesAction extends AbstractPublisherAction {
 	private void createAdviceFileAdvice(Feature feature, IPublisherInfo info) {
 		//assume p2.inf is co-located with feature.xml
 		String location = feature.getLocation();
-		if (location != null)
-			info.addAdvice(new AdviceFileAdvice(feature.getId(), new Version(feature.getVersion()), new Path(location), new Path("p2.inf"))); //$NON-NLS-1$
+		if (location != null) {
+			String groupId = getTransformedId(feature.getId(), /*isPlugin*/false, /*isGroup*/true);
+			info.addAdvice(new AdviceFileAdvice(groupId, new Version(feature.getVersion()), new Path(location), new Path("p2.inf"))); //$NON-NLS-1$
+		}
 	}
 
 	/**
@@ -244,6 +223,7 @@ public class FeaturesAction extends AbstractPublisherAction {
 		iu.setId(id);
 		Version version = Version.fromOSGiVersion(new org.osgi.framework.Version(feature.getVersion()));
 		iu.setVersion(version);
+
 		iu.setProperty(IInstallableUnit.PROP_NAME, feature.getLabel());
 		if (feature.getDescription() != null)
 			iu.setProperty(IInstallableUnit.PROP_DESCRIPTION, feature.getDescription());
@@ -275,8 +255,8 @@ public class FeaturesAction extends AbstractPublisherAction {
 		}
 		iu.setRequiredCapabilities((IRequiredCapability[]) required.toArray(new IRequiredCapability[required.size()]));
 		iu.setTouchpointType(ITouchpointType.NONE);
-		processTouchpointAdvice(iu, info);
-		processFeatureAdvice(feature, iu, info);
+		processTouchpointAdvice(iu, null, info);
+		processFeatureAdvice(iu, feature, info);
 		iu.setProperty(IInstallableUnit.PROP_TYPE_GROUP, Boolean.TRUE.toString());
 		// TODO: shouldn't the filter for the group be constructed from os, ws, arch, nl
 		// 		 of the feature?
@@ -301,6 +281,7 @@ public class FeaturesAction extends AbstractPublisherAction {
 		}
 
 		iu.setCapabilities((IProvidedCapability[]) providedCapabilities.toArray(new IProvidedCapability[providedCapabilities.size()]));
+		processCapabilityAdvice(iu, info);
 		return MetadataFactory.createInstallableUnit(iu);
 	}
 
@@ -362,8 +343,8 @@ public class FeaturesAction extends AbstractPublisherAction {
 		}
 
 		iu.setTouchpointType(ITouchpointType.NONE);
-		processTouchpointAdvice(iu, info);
-		processFeatureAdvice(feature, iu, info);
+		processTouchpointAdvice(iu, null, info);
+		processFeatureAdvice(iu, feature, info);
 		iu.setProperty(IInstallableUnit.PROP_TYPE_GROUP, Boolean.TRUE.toString());
 		iu.setProperty(IInstallableUnit.PROP_TYPE_PATCH, Boolean.TRUE.toString());
 		// TODO: shouldn't the filter for the group be constructed from os, ws, arch, nl
@@ -389,6 +370,7 @@ public class FeaturesAction extends AbstractPublisherAction {
 		}
 
 		iu.setCapabilities((IProvidedCapability[]) providedCapabilities.toArray(new IProvidedCapability[providedCapabilities.size()]));
+		processCapabilityAdvice(iu, info);
 		return MetadataFactory.createInstallableUnitPatch(iu);
 	}
 
@@ -434,6 +416,8 @@ public class FeaturesAction extends AbstractPublisherAction {
 			IInstallableUnit groupIU = createGroupIU(feature, childIUs, info);
 			if (groupIU != null) {
 				result.addIU(groupIU, IPublisherResult.ROOT);
+				Collection others = processAdditionalIUsAdvice(groupIU, info);
+				result.addIUs(others, IPublisherResult.ROOT);
 			}
 			generateSiteReferences(feature, result, info);
 		}
@@ -649,17 +633,39 @@ public class FeaturesAction extends AbstractPublisherAction {
 		return Status.OK_STATUS;
 	}
 
-	private void processTouchpointAdvice(InstallableUnitDescription iu, IPublisherInfo info) {
-		Collection advice = info.getAdvice(null, false, null, null, ITouchpointAdvice.class);
-		ITouchpointData result = MetadataFactory.createTouchpointData(new HashMap());
+	/**
+	 * Add all of the advised properties for the bundle at the given location to the given IU.
+	 * @param iu the feature IU to decorate
+	 * @param publisherInfo the publisher info supplying the advice
+	 */
+	private static void processFeatureAdvice(InstallableUnitDescription iu, Feature feature, IPublisherInfo publisherInfo) {
+		Collection advice = publisherInfo.getAdvice(null, false, iu.getId(), iu.getVersion(), IFeatureAdvice.class);
 		for (Iterator i = advice.iterator(); i.hasNext();) {
-			ITouchpointAdvice entry = (ITouchpointAdvice) i.next();
-			result = entry.getTouchpointData(result);
+			IFeatureAdvice entry = (IFeatureAdvice) i.next();
+			Properties props = entry.getIUProperties(feature);
+			if (props == null)
+				continue;
+			for (Iterator j = props.keySet().iterator(); j.hasNext();) {
+				String key = (String) j.next();
+				iu.setProperty(key, props.getProperty(key));
+			}
+		}
+	}
+
+	private static Collection processAdditionalIUsAdvice(IInstallableUnit iu, IPublisherInfo publisherInfo) {
+		List result = new ArrayList();
+		Collection advice = publisherInfo.getAdvice(null, false, iu.getId(), iu.getVersion(), AdviceFileAdvice.class);
+		for (Iterator iterator = advice.iterator(); iterator.hasNext();) {
+			AdviceFileAdvice entry = (AdviceFileAdvice) iterator.next();
+			InstallableUnitDescription[] others = entry.getAdditionalInstallableUnitDescriptions(iu);
+			for (int i = 0; others != null && i < others.length; i++) {
+				result.add(MetadataFactory.createInstallableUnit(others[i]));
+			}
 		}
-		iu.addTouchpointData(result);
+		return result;
 	}
 
-	protected void publishFeatureArtifacts(Feature feature, IInstallableUnit featureIU, IPublisherInfo info) {
+	protected void publishFeatureArtifacts(Feature feature, IInstallableUnit featureIU, IPublisherInfo publisherInfo) {
 		// add all the artifacts associated with the feature
 		// TODO this is a little strange.  If there are several artifacts, how do we know which files go with
 		// which artifacts when we publish them?  For now it would be surprising to have more than one
@@ -668,13 +674,13 @@ public class FeaturesAction extends AbstractPublisherAction {
 		for (int j = 0; j < artifacts.length; j++) {
 			File file = new File(feature.getLocation());
 			IArtifactDescriptor ad = PublisherHelper.createArtifactDescriptor(artifacts[j], file);
-			addProperties((ArtifactDescriptor) ad, feature, info);
+			addProperties((ArtifactDescriptor) ad, feature, publisherInfo);
 			((ArtifactDescriptor) ad).setProperty(IArtifactDescriptor.DOWNLOAD_CONTENTTYPE, IArtifactDescriptor.TYPE_ZIP);
 			// if the artifact is a dir then zip it up.
 			if (file.isDirectory())
-				publishArtifact(ad, new File[] {file}, null, info, createRootPrefixComputer(file));
+				publishArtifact(ad, new File[] {file}, null, publisherInfo, createRootPrefixComputer(file));
 			else
-				publishArtifact(ad, file, info);
+				publishArtifact(ad, file, publisherInfo);
 		}
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ITouchpointAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ITouchpointAdvice.java
deleted file mode 100644
index 5a824b9..0000000
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ITouchpointAdvice.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.p2.publisher.eclipse;
-
-import org.eclipse.equinox.internal.provisional.p2.metadata.ITouchpointData;
-import org.eclipse.equinox.p2.publisher.IPublisherAdvice;
-
-/**
- * Touchpoint advice provides information related to the touch points associated
- * with an installable unit being published.
- */
-public interface ITouchpointAdvice extends IPublisherAdvice {
-	/**
-	 * Returns a touchpoint data that merges the given touchpoint data
-	 * with any new touchpoint data contributed by this advice.
-	 * 
-	 * @param existingData The current set of touchpoint data.
-	 * @return the merged touchpoint data
-	 */
-	public ITouchpointData getTouchpointData(ITouchpointData existingData);
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
index fc4ffa9..15e2d51 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
@@ -12,6 +12,8 @@ package org.eclipse.equinox.p2.tests.publisher.actions;
 
 import static org.easymock.EasyMock.*;
 
+import org.eclipse.equinox.p2.publisher.actions.ITouchpointAdvice;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.util.*;
@@ -224,8 +226,10 @@ public class BundlesActionTest extends ActionTest {
 		expect(publisherInfo.getArtifactRepository()).andReturn(artifactRepository).anyTimes();
 		expect(publisherInfo.getAdvice(null, false, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, ICapabilityAdvice.class)).andReturn(Collections.EMPTY_LIST); //$NON-NLS-1$
 		expect(publisherInfo.getAdvice(null, false, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, IBundleAdvice.class)).andReturn(Collections.EMPTY_LIST); //$NON-NLS-1$
+		expect(publisherInfo.getAdvice(null, false, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, AdviceFileAdvice.class)).andReturn(Collections.EMPTY_LIST); //$NON-NLS-1$
 		expect(publisherInfo.getAdvice(null, false, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, ICapabilityAdvice.class)).andReturn(Collections.EMPTY_LIST);//$NON-NLS-1$
 		expect(publisherInfo.getAdvice(null, false, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, IBundleAdvice.class)).andReturn(Collections.EMPTY_LIST);//$NON-NLS-1$
+		expect(publisherInfo.getAdvice(null, false, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, AdviceFileAdvice.class)).andReturn(Collections.EMPTY_LIST);//$NON-NLS-1$		
 		expect(publisherInfo.getAdvice(null, true, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, IBundleShapeAdvice.class)).andReturn(null); //$NON-NLS-1$
 		expect(publisherInfo.getAdvice(null, true, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, IBundleShapeAdvice.class)).andReturn(null);//$NON-NLS-1$
 		expect(publisherInfo.getArtifactOptions()).andReturn(IPublisherInfo.A_INDEX | IPublisherInfo.A_OVERWRITE | IPublisherInfo.A_PUBLISH).anyTimes();
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/FeaturesActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/FeaturesActionTest.java
index e2e01a8..4f09afe 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/FeaturesActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/FeaturesActionTest.java
@@ -26,6 +26,8 @@ import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
 import org.eclipse.equinox.p2.publisher.IPublisherInfo;
 import org.eclipse.equinox.p2.publisher.IPublisherResult;
+import org.eclipse.equinox.p2.publisher.actions.ICapabilityAdvice;
+import org.eclipse.equinox.p2.publisher.actions.ITouchpointAdvice;
 import org.eclipse.equinox.p2.publisher.eclipse.*;
 import org.eclipse.equinox.p2.tests.*;
 import org.eclipse.equinox.p2.tests.publisher.TestArtifactRepository;
@@ -166,7 +168,17 @@ public class FeaturesActionTest extends ActionTest {
 		metadataRepository = new TestMetadataRepository(new IInstallableUnit[] {mockIU(BAR, null)});
 
 		ArrayList adviceCollection = fillAdvice(new ArrayList());
-		expect(publisherInfo.getAdvice(null, false, null, null, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "bar.feature.jar", barVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "bar", barVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "bar.feature.group", barVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "bar.feature.group", barVersion, ITouchpointAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "bar.feature.group", barVersion, ICapabilityAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "bar.feature.group", barVersion, AdviceFileAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "foo.feature.jar", fooVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "foo", fooVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "foo.feature.group", fooVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "foo.feature.group", fooVersion, ICapabilityAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "foo.feature.group", fooVersion, AdviceFileAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
 		expect(publisherInfo.getArtifactOptions()).andReturn(IPublisherInfo.A_INDEX | IPublisherInfo.A_OVERWRITE | IPublisherInfo.A_PUBLISH).anyTimes();
 		expect(publisherInfo.getArtifactRepository()).andReturn(artifactRepository).anyTimes();
 		expect(publisherInfo.getMetadataRepository()).andReturn(metadataRepository).anyTimes();
@@ -174,7 +186,7 @@ public class FeaturesActionTest extends ActionTest {
 		//capture any touchpoint advice, and return the captured advice when the action asks for it
 		publisherInfo.addAdvice(and(isA(ITouchpointAdvice.class), capture(tpAdvice)));
 		EasyMock.expectLastCall().anyTimes();
-		expect(publisherInfo.getAdvice(null, false, null, null, ITouchpointAdvice.class)).andReturn(new CaptureList(tpAdvice)).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "foo.feature.group", fooVersion, ITouchpointAdvice.class)).andReturn(new CaptureList(tpAdvice)).anyTimes();
 	}
 
 	private ArrayList fillAdvice(ArrayList adviceCollection) {
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
index d2d3c14..2ef25d6 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
@@ -24,7 +24,6 @@ import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 import org.eclipse.equinox.internal.provisional.p2.query.Query;
 import org.eclipse.equinox.p2.publisher.IPublisherResult;
 import org.eclipse.equinox.p2.publisher.actions.*;
-import org.eclipse.equinox.p2.publisher.eclipse.ITouchpointAdvice;
 import org.eclipse.equinox.p2.tests.TestMetadataRepository;
 
 @SuppressWarnings( {"restriction", "unchecked"})
commit cf77d633628e253225a9ab8afdbbba3a30d34484
Author: Andrew Niefer <aniefer>
Date:   Wed Feb 25 15:45:04 2009 +0000

    Bug 265217 - update pde.build test

1	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
index a4a10ec..4fde90e 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
@@ -51,7 +51,7 @@ public class AdviceFileParser {
 				parseRequires("requires.", adviceRequires);
 			else if (current.startsWith("instructions."))
 				parseInstructions("instructions.", adviceInstructions);
-			else if (current.startsWith("unit."))
+			else if (current.startsWith("units."))
 				parseUnits("units.", adviceOtherIUs);
 			else
 				throw new IllegalStateException("bad token: " + current);
commit 76f096c1edeeba98625c9ae11cc592a85798befb
Author: Simon Kaegi <skaegi>
Date:   Wed Feb 25 16:27:17 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf

13	18	bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/internal/provisional/p2/directorywatcher/EntryAdvice.java
54	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
20	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IAdditionalInstallableUnitAdvice.java
31	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IPropertyAdvice.java
1	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/ITouchpointAdvice.java
8	11	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
5	14	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
11	93	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
10	60	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
0	33	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IBundleAdvice.java
0	31	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IFeatureAdvice.java
1	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
22	16	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
17	16	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/FeaturesActionTest.java
3	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
diff --git a/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/internal/provisional/p2/directorywatcher/EntryAdvice.java b/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/internal/provisional/p2/directorywatcher/EntryAdvice.java
index d6689bd..9115dd2 100644
--- a/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/internal/provisional/p2/directorywatcher/EntryAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/internal/provisional/p2/directorywatcher/EntryAdvice.java
@@ -15,38 +15,25 @@ import java.net.URI;
 import java.util.Map;
 import java.util.Properties;
 import org.eclipse.equinox.internal.p2.update.Site;
-import org.eclipse.equinox.p2.publisher.eclipse.*;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
+import org.eclipse.equinox.p2.publisher.actions.IPropertyAdvice;
 
 /**
  * Entry advice captures the name, location, modified time, shape etc of something
  * discovered by the repository listener.  It is a simplified structure intended to represent
  * only one entry at a time and that entry is the the only entry being published.  
  */
-public class EntryAdvice implements IFeatureAdvice, IBundleAdvice {
+public class EntryAdvice implements IPropertyAdvice {
 	private Properties metadataProps = new Properties();
 	private Properties artifactProps = new Properties();
 
-	public Properties getIUProperties(Feature feature) {
-		return metadataProps;
-	}
-
-	public Properties getArtifactProperties(Feature feature) {
-		return artifactProps;
-	}
-
 	public boolean isApplicable(String configSpec, boolean includeDefault, String id, Version version) {
 		return true;
 	}
 
-	public Properties getIUProperties(File location) {
-		return metadataProps;
-	}
-
-	public Properties getArtifactProperties(File location) {
-		return artifactProps;
-	}
-
 	void setProperties(File location, long timestamp, URI reference) {
 		setProperties(location, timestamp, reference, null);
 	}
@@ -70,4 +57,12 @@ public class EntryAdvice implements IFeatureAdvice, IBundleAdvice {
 	public Map getInstructions(File location) {
 		return null;
 	}
+
+	public Properties getArtifactProperties(IInstallableUnit iu, IArtifactDescriptor descriptor) {
+		return artifactProps;
+	}
+
+	public Properties getInstallableUnitProperties(InstallableUnitDescription iu) {
+		return metadataProps;
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
index a64c2b6..0cdfc7f 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
@@ -195,6 +195,59 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 		return MetadataFactory.createProvidedCapability(PublisherHelper.IU_NAMESPACE, installableUnitId, installableUnitVersion);
 	}
 
+	protected static InstallableUnitDescription[] processAdditionalInstallableUnitsAdvice(IInstallableUnit iu, IPublisherInfo publisherInfo) {
+		Collection advice = publisherInfo.getAdvice(null, false, iu.getId(), iu.getVersion(), IAdditionalInstallableUnitAdvice.class);
+		if (advice.isEmpty())
+			return null;
+
+		List ius = new ArrayList();
+		for (Iterator iterator = advice.iterator(); iterator.hasNext();) {
+			IAdditionalInstallableUnitAdvice entry = (IAdditionalInstallableUnitAdvice) iterator.next();
+			InstallableUnitDescription[] others = entry.getAdditionalInstallableUnitDescriptions(iu);
+			ius.addAll(Arrays.asList(others));
+		}
+		return (InstallableUnitDescription[]) ius.toArray(new InstallableUnitDescription[ius.size()]);
+	}
+
+	/**
+	 * Add all of the advised artifact properties for the given IU and artifact descriptor.
+	 * @param iu the IU
+	 * @param descriptor the descriptor to decorate
+	 * @param info the publisher info supplying the advice
+	 */
+	protected static void processArtifactPropertiesAdvice(IInstallableUnit iu, ArtifactDescriptor descriptor, IPublisherInfo info) {
+		Collection advice = info.getAdvice(null, false, iu.getId(), iu.getVersion(), IPropertyAdvice.class);
+		for (Iterator i = advice.iterator(); i.hasNext();) {
+			IPropertyAdvice entry = (IPropertyAdvice) i.next();
+			Properties props = entry.getArtifactProperties(iu, descriptor);
+			if (props == null)
+				continue;
+			for (Iterator j = props.keySet().iterator(); j.hasNext();) {
+				String key = (String) j.next();
+				descriptor.setRepositoryProperty(key, props.getProperty(key));
+			}
+		}
+	}
+
+	/**
+	 * Add all of the advised IU properties for the given IU.
+	 * @param iu the IU to decorate
+	 * @param info the publisher info supplying the advice
+	 */
+	protected static void processInstallableUnitPropertiesAdvice(InstallableUnitDescription iu, IPublisherInfo info) {
+		Collection advice = info.getAdvice(null, false, iu.getId(), iu.getVersion(), IPropertyAdvice.class);
+		for (Iterator i = advice.iterator(); i.hasNext();) {
+			IPropertyAdvice entry = (IPropertyAdvice) i.next();
+			Properties props = entry.getInstallableUnitProperties(iu);
+			if (props == null)
+				continue;
+			for (Iterator j = props.keySet().iterator(); j.hasNext();) {
+				String key = (String) j.next();
+				iu.setProperty(key, props.getProperty(key));
+			}
+		}
+	}
+
 	/**
 	 * Add all of the advised provided and required capabilities for the given installable unit.
 	 * @param iu the IU to decorate
@@ -235,7 +288,7 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 			if (advice.isEmpty())
 				return;
 
-			currentInstructions = new HashMap();
+			currentInstructions = Collections.EMPTY_MAP;
 		}
 
 		ITouchpointData result = MetadataFactory.createTouchpointData(currentInstructions);
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IAdditionalInstallableUnitAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IAdditionalInstallableUnitAdvice.java
new file mode 100644
index 0000000..a853d13
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IAdditionalInstallableUnitAdvice.java
@@ -0,0 +1,20 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.publisher.actions;
+
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
+import org.eclipse.equinox.p2.publisher.IPublisherAdvice;
+
+public interface IAdditionalInstallableUnitAdvice extends IPublisherAdvice {
+
+	public InstallableUnitDescription[] getAdditionalInstallableUnitDescriptions(IInstallableUnit iu);
+}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IPropertyAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IPropertyAdvice.java
new file mode 100644
index 0000000..86a0367
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/IPropertyAdvice.java
@@ -0,0 +1,31 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.publisher.actions;
+
+import java.util.Properties;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactDescriptor;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
+import org.eclipse.equinox.p2.publisher.IPublisherAdvice;
+
+public interface IPropertyAdvice extends IPublisherAdvice {
+
+	/**
+	 * Returns the set of extra properties to be associated with the IU
+	 */
+	public Properties getInstallableUnitProperties(InstallableUnitDescription iu);
+
+	/**
+	 * Returns the set of extra properties to be associated with the artifact descriptor
+	 * being published
+	 */
+	public Properties getArtifactProperties(IInstallableUnit iu, IArtifactDescriptor descriptor);
+}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/ITouchpointAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/ITouchpointAdvice.java
index c7141f7..0a800d9 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/ITouchpointAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/ITouchpointAdvice.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
+ * Copyright (c) 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
index 843d199..1b0b77b 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/RootIUAction.java
@@ -49,26 +49,23 @@ public class RootIUAction extends AbstractPublisherAction {
 		Collection children = getChildren(result);
 		InstallableUnitDescription descriptor = createTopLevelIUDescription(children, id, version, name, null, false);
 		processCapabilityAdvice(descriptor, info);
-		processTouchpointAdvice(descriptor);
+		processTouchpointAdvice(descriptor, null, info);
+		processInstallableUnitPropertiesAdvice(descriptor, info);
 		IInstallableUnit rootIU = MetadataFactory.createInstallableUnit(descriptor);
 		if (rootIU == null)
 			return new Status(IStatus.ERROR, Activator.ID, NLS.bind(Messages.error_rootIU_generation, new Object[] {name, id, version}));
 		result.addIU(rootIU, IPublisherResult.NON_ROOT);
+
+		InstallableUnitDescription[] others = processAdditionalInstallableUnitsAdvice(rootIU, info);
+		for (int iuIndex = 0; others != null && iuIndex < others.length; iuIndex++) {
+			result.addIU(MetadataFactory.createInstallableUnit(others[iuIndex]), IPublisherResult.ROOT);
+		}
+
 		return Status.OK_STATUS;
 		// TODO why do we create a category here?
 		//		result.addIU(generateDefaultCategory(rootIU, rootCategory), IPublisherResult.NON_ROOT);
 	}
 
-	private void processTouchpointAdvice(InstallableUnitDescription descriptor) {
-		Collection allAdvice = info.getAdvice(null, true, id, version, ITouchpointAdvice.class);
-		if (allAdvice == null || allAdvice.isEmpty())
-			return;
-		ITouchpointData touchpointData = MetadataFactory.createTouchpointData(Collections.EMPTY_MAP);
-		for (Iterator it = allAdvice.iterator(); it.hasNext();)
-			touchpointData = ((ITouchpointAdvice) it.next()).getTouchpointData(touchpointData);
-		descriptor.addTouchpointData(touchpointData);
-	}
-
 	/**
 	 * This was copied over from Generator to match up with the call from generateRootIU (above).
 	 * It is entirely unclear why it was needed.  Should review.
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index f4ce017..500505b 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -8,25 +8,24 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.publisher.eclipse;
 
-import org.eclipse.equinox.p2.publisher.actions.ITouchpointAdvice;
-
 import java.io.*;
 import java.util.*;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
 import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.publisher.AbstractAdvice;
-import org.eclipse.equinox.p2.publisher.actions.ICapabilityAdvice;
+import org.eclipse.equinox.p2.publisher.actions.*;
 
 /**
  * Publishing advice from a p2 advice file. An advice file (p2.inf) can be embedded
  * in the source of a bundle, feature, or product to specify additional advice to be
  * added to the {@link IInstallableUnit} corresponding to the bundle, feature, or product.
  */
-public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvice, ICapabilityAdvice, IBundleAdvice, IFeatureAdvice {
+public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvice, ICapabilityAdvice, IPropertyAdvice {
 
 	/**
 	 * The location of the bundle advice file, relative to the bundle root location.
@@ -170,23 +169,15 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 		return requiredCapabilities;
 	}
 
-	public Properties getArtifactProperties(File location) {
-		return null;
-	}
-
-	public Properties getIUProperties(File location) {
-		return iuProperties;
-	}
-
 	public InstallableUnitDescription[] getAdditionalInstallableUnitDescriptions(IInstallableUnit iu) {
 		return otherIUs;
 	}
 
-	public Properties getArtifactProperties(Feature feature) {
+	public Properties getArtifactProperties(IInstallableUnit iu, IArtifactDescriptor descriptor) {
 		return null;
 	}
 
-	public Properties getIUProperties(Feature feature) {
+	public Properties getInstallableUnitProperties(InstallableUnitDescription iu) {
 		return iuProperties;
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
index 6a47d4b..d92f4690 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
@@ -200,7 +200,7 @@ public class BundlesAction extends AbstractPublisherAction {
 			}
 		}
 		iu.setCapabilities((IProvidedCapability[]) providedCapabilities.toArray(new IProvidedCapability[providedCapabilities.size()]));
-		processCapabilityAdvice(iu, bd, info);
+		processCapabilityAdvice(iu, info);
 
 		// Set certain properties from the manifest header attributes as IU properties.
 		// The values of these attributes may be localized (strings starting with '%')
@@ -227,7 +227,7 @@ public class BundlesAction extends AbstractPublisherAction {
 			touchpointData.put("zipped", "true"); //$NON-NLS-1$ //$NON-NLS-2$
 		processTouchpointAdvice(iu, touchpointData, info);
 
-		processPropertiesAdvice(iu, bd.getLocation(), info);
+		processInstallableUnitPropertiesAdvice(iu, info);
 		return MetadataFactory.createInstallableUnit(iu);
 	}
 
@@ -241,70 +241,6 @@ public class BundlesAction extends AbstractPublisherAction {
 		return updateRange;
 	}
 
-	/**
-	 * Add all of the advised properties for the bundle at the given location to the given IU.
-	 * @param iu the bundle IU to decorate
-	 * @param location the location of the bundle
-	 * @param info the publisher info supplying the advice
-	 */
-	private static void processPropertiesAdvice(InstallableUnitDescription iu, String location, IPublisherInfo info) {
-		if (location == null)
-			return;
-		Collection advice = info.getAdvice(null, false, iu.getId(), iu.getVersion(), IBundleAdvice.class);
-		File bundleFile = new File(location);
-		for (Iterator i = advice.iterator(); i.hasNext();) {
-			IBundleAdvice entry = (IBundleAdvice) i.next();
-			Properties props = entry.getIUProperties(bundleFile);
-			if (props == null)
-				continue;
-			for (Iterator j = props.keySet().iterator(); j.hasNext();) {
-				String key = (String) j.next();
-				iu.setProperty(key, props.getProperty(key));
-			}
-		}
-	}
-
-	/**
-	 * Add all of the advised provided and required capabilities for the given installable unit.
-	 * @param iu the IU to decorate
-	 * @param info the publisher info supplying the advice
-	 */
-	private static void processCapabilityAdvice(InstallableUnitDescription iu, BundleDescription bundle, IPublisherInfo info) {
-		Collection advice = info.getAdvice(null, false, iu.getId(), iu.getVersion(), ICapabilityAdvice.class);
-		for (Iterator i = advice.iterator(); i.hasNext();) {
-			ICapabilityAdvice entry = (ICapabilityAdvice) i.next();
-			IRequiredCapability[] requiredAdvice = entry.getRequiredCapabilities(iu);
-			if (requiredAdvice != null) {
-				IRequiredCapability[] current = iu.getRequiredCapabilities();
-				IRequiredCapability[] result = new IRequiredCapability[requiredAdvice.length + current.length];
-				System.arraycopy(requiredAdvice, 0, result, 0, requiredAdvice.length);
-				System.arraycopy(current, 0, result, requiredAdvice.length, current.length);
-				iu.setRequiredCapabilities(result);
-			}
-			IProvidedCapability[] providedAdvice = entry.getProvidedCapabilities(iu);
-			if (providedAdvice != null) {
-				IProvidedCapability[] current = iu.getProvidedCapabilities();
-				IProvidedCapability[] result = new IProvidedCapability[providedAdvice.length + current.length];
-				System.arraycopy(providedAdvice, 0, result, 0, providedAdvice.length);
-				System.arraycopy(current, 0, result, providedAdvice.length, current.length);
-				iu.setCapabilities(result);
-			}
-		}
-	}
-
-	private Collection processAdditionalIUsAdvice(IInstallableUnit iu, IPublisherInfo publisherInfo) {
-		List result = new ArrayList();
-		Collection advice = publisherInfo.getAdvice(null, false, iu.getId(), iu.getVersion(), AdviceFileAdvice.class);
-		for (Iterator iterator = advice.iterator(); iterator.hasNext();) {
-			AdviceFileAdvice entry = (AdviceFileAdvice) iterator.next();
-			InstallableUnitDescription[] others = entry.getAdditionalInstallableUnitDescriptions(iu);
-			for (int i = 0; others != null && i < others.length; i++) {
-				result.add(MetadataFactory.createInstallableUnit(others[i]));
-			}
-		}
-		return result;
-	}
-
 	public static void createHostLocalizationFragment(IInstallableUnit bundleIU, BundleDescription bd, String hostId, String[] hostBundleManifestValues, Set localizationIUs) {
 		Map hostLocalizations = getHostLocalizations(new File(bd.getLocation()), hostBundleManifestValues);
 		if (hostLocalizations != null) {
@@ -711,9 +647,13 @@ public class BundlesAction extends AbstractPublisherAction {
 					} else {
 						createAdviceFileAdvice(bundles[i], info);
 						IArtifactKey key = createBundleArtifactKey(bd.getSymbolicName(), bd.getVersion().toString());
+
+						// Create the bundle IU according to any shape advice we have
+						IInstallableUnit bundleIU = createBundleIU(bd, key, info);
+
 						File location = new File(bd.getLocation());
 						IArtifactDescriptor ad = PublisherHelper.createArtifactDescriptor(key, location);
-						addProperties((ArtifactDescriptor) ad, location, info);
+						processArtifactPropertiesAdvice(bundleIU, (ArtifactDescriptor) ad, info);
 
 						// Publish according to the shape on disk
 						File bundleLocation = new File(bd.getLocation());
@@ -722,9 +662,6 @@ public class BundlesAction extends AbstractPublisherAction {
 						else
 							publishArtifact(ad, new File(bd.getLocation()), info);
 
-						// Create the bundle IU according to any shape advice we have
-						IInstallableUnit bundleIU = createBundleIU(bd, key, info);
-
 						if (isFragment(bd)) {
 							// TODO: Can NL fragments be multi-host?  What special handling
 							//		 is required for multi-host fragments in general?
@@ -737,12 +674,13 @@ public class BundlesAction extends AbstractPublisherAction {
 							}
 						}
 
-						Collection others = processAdditionalIUsAdvice(bundleIU, info);
-						result.addIUs(others, IPublisherResult.ROOT);
-
 						result.addIU(bundleIU, IPublisherResult.ROOT);
 						result.addIUs(localizationIUs, IPublisherResult.NON_ROOT);
 						localizationIUs.clear();
+						InstallableUnitDescription[] others = processAdditionalInstallableUnitsAdvice(bundleIU, info);
+						for (int iuIndex = 0; others != null && iuIndex < others.length; iuIndex++) {
+							result.addIU(MetadataFactory.createInstallableUnit(others[iuIndex]), IPublisherResult.ROOT);
+						}
 					}
 				}
 			}
@@ -758,26 +696,6 @@ public class BundlesAction extends AbstractPublisherAction {
 			info.addAdvice(new AdviceFileAdvice(bundleDescription.getSymbolicName(), Version.fromOSGiVersion(bundleDescription.getVersion()), new Path(location), AdviceFileAdvice.BUNDLE_ADVICE_FILE));
 	}
 
-	/**
-	 * Add all of the advice for the bundle at the given location to the given descriptor.
-	 * @param descriptor the descriptor to decorate
-	 * @param location the location of the bundle
-	 * @param info the publisher info supplying the advice
-	 */
-	private void addProperties(ArtifactDescriptor descriptor, File location, IPublisherInfo info) {
-		Collection advice = info.getAdvice(null, false, null, null, IBundleAdvice.class);
-		for (Iterator i = advice.iterator(); i.hasNext();) {
-			IBundleAdvice entry = (IBundleAdvice) i.next();
-			Properties props = entry.getArtifactProperties(location);
-			if (props == null)
-				continue;
-			for (Iterator j = props.keySet().iterator(); j.hasNext();) {
-				String key = (String) j.next();
-				descriptor.setRepositoryProperty(key, props.getProperty(key));
-			}
-		}
-	}
-
 	private static boolean isDir(BundleDescription bundle, IPublisherInfo info) {
 		Collection advice = info.getAdvice(null, true, bundle.getSymbolicName(), Version.fromOSGiVersion(bundle.getVersion()), IBundleShapeAdvice.class);
 		// if the advice has a shape, use it
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
index 9cd0a20..6bbd6f2 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
@@ -87,7 +87,7 @@ public class FeaturesAction extends AbstractPublisherAction {
 			touchpointData.put("zipped", "true"); //$NON-NLS-1$ //$NON-NLS-2$
 			iu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		}
-		processFeatureAdvice(iu, feature, info);
+		processInstallableUnitPropertiesAdvice(iu, info);
 		return MetadataFactory.createInstallableUnit(iu);
 	}
 
@@ -117,26 +117,6 @@ public class FeaturesAction extends AbstractPublisherAction {
 		this.locations = locations;
 	}
 
-	/**
-	 * Add all of the advice for the feature at the given location to the given descriptor.
-	 * @param descriptor the descriptor to decorate
-	 * @param feature the feature we are getting advice for
-	 * @param info the publisher info supplying the advice
-	 */
-	protected void addProperties(ArtifactDescriptor descriptor, Feature feature, IPublisherInfo info) {
-		Collection advice = info.getAdvice(null, false, feature.getId(), new Version(feature.getVersion()), IFeatureAdvice.class);
-		for (Iterator i = advice.iterator(); i.hasNext();) {
-			IFeatureAdvice entry = (IFeatureAdvice) i.next();
-			Properties props = entry.getArtifactProperties(feature);
-			if (props == null)
-				continue;
-			for (Iterator j = props.keySet().iterator(); j.hasNext();) {
-				String key = (String) j.next();
-				descriptor.setRepositoryProperty(key, props.getProperty(key));
-			}
-		}
-	}
-
 	// attach the described files from the given location to the given iu description.  Return
 	// the list of files identified.
 	private File[] attachFiles(InstallableUnitDescription iu, FileSetDescriptor descriptor, File location) {
@@ -256,7 +236,7 @@ public class FeaturesAction extends AbstractPublisherAction {
 		iu.setRequiredCapabilities((IRequiredCapability[]) required.toArray(new IRequiredCapability[required.size()]));
 		iu.setTouchpointType(ITouchpointType.NONE);
 		processTouchpointAdvice(iu, null, info);
-		processFeatureAdvice(iu, feature, info);
+		processInstallableUnitPropertiesAdvice(iu, info);
 		iu.setProperty(IInstallableUnit.PROP_TYPE_GROUP, Boolean.TRUE.toString());
 		// TODO: shouldn't the filter for the group be constructed from os, ws, arch, nl
 		// 		 of the feature?
@@ -344,7 +324,7 @@ public class FeaturesAction extends AbstractPublisherAction {
 
 		iu.setTouchpointType(ITouchpointType.NONE);
 		processTouchpointAdvice(iu, null, info);
-		processFeatureAdvice(iu, feature, info);
+		processInstallableUnitPropertiesAdvice(iu, info);
 		iu.setProperty(IInstallableUnit.PROP_TYPE_GROUP, Boolean.TRUE.toString());
 		iu.setProperty(IInstallableUnit.PROP_TYPE_PATCH, Boolean.TRUE.toString());
 		// TODO: shouldn't the filter for the group be constructed from os, ws, arch, nl
@@ -416,8 +396,10 @@ public class FeaturesAction extends AbstractPublisherAction {
 			IInstallableUnit groupIU = createGroupIU(feature, childIUs, info);
 			if (groupIU != null) {
 				result.addIU(groupIU, IPublisherResult.ROOT);
-				Collection others = processAdditionalIUsAdvice(groupIU, info);
-				result.addIUs(others, IPublisherResult.ROOT);
+				InstallableUnitDescription[] others = processAdditionalInstallableUnitsAdvice(groupIU, info);
+				for (int iuIndex = 0; others != null && iuIndex < others.length; iuIndex++) {
+					result.addIU(MetadataFactory.createInstallableUnit(others[iuIndex]), IPublisherResult.ROOT);
+				}
 			}
 			generateSiteReferences(feature, result, info);
 		}
@@ -633,38 +615,6 @@ public class FeaturesAction extends AbstractPublisherAction {
 		return Status.OK_STATUS;
 	}
 
-	/**
-	 * Add all of the advised properties for the bundle at the given location to the given IU.
-	 * @param iu the feature IU to decorate
-	 * @param publisherInfo the publisher info supplying the advice
-	 */
-	private static void processFeatureAdvice(InstallableUnitDescription iu, Feature feature, IPublisherInfo publisherInfo) {
-		Collection advice = publisherInfo.getAdvice(null, false, iu.getId(), iu.getVersion(), IFeatureAdvice.class);
-		for (Iterator i = advice.iterator(); i.hasNext();) {
-			IFeatureAdvice entry = (IFeatureAdvice) i.next();
-			Properties props = entry.getIUProperties(feature);
-			if (props == null)
-				continue;
-			for (Iterator j = props.keySet().iterator(); j.hasNext();) {
-				String key = (String) j.next();
-				iu.setProperty(key, props.getProperty(key));
-			}
-		}
-	}
-
-	private static Collection processAdditionalIUsAdvice(IInstallableUnit iu, IPublisherInfo publisherInfo) {
-		List result = new ArrayList();
-		Collection advice = publisherInfo.getAdvice(null, false, iu.getId(), iu.getVersion(), AdviceFileAdvice.class);
-		for (Iterator iterator = advice.iterator(); iterator.hasNext();) {
-			AdviceFileAdvice entry = (AdviceFileAdvice) iterator.next();
-			InstallableUnitDescription[] others = entry.getAdditionalInstallableUnitDescriptions(iu);
-			for (int i = 0; others != null && i < others.length; i++) {
-				result.add(MetadataFactory.createInstallableUnit(others[i]));
-			}
-		}
-		return result;
-	}
-
 	protected void publishFeatureArtifacts(Feature feature, IInstallableUnit featureIU, IPublisherInfo publisherInfo) {
 		// add all the artifacts associated with the feature
 		// TODO this is a little strange.  If there are several artifacts, how do we know which files go with
@@ -673,9 +623,9 @@ public class FeaturesAction extends AbstractPublisherAction {
 		IArtifactKey[] artifacts = featureIU.getArtifacts();
 		for (int j = 0; j < artifacts.length; j++) {
 			File file = new File(feature.getLocation());
-			IArtifactDescriptor ad = PublisherHelper.createArtifactDescriptor(artifacts[j], file);
-			addProperties((ArtifactDescriptor) ad, feature, publisherInfo);
-			((ArtifactDescriptor) ad).setProperty(IArtifactDescriptor.DOWNLOAD_CONTENTTYPE, IArtifactDescriptor.TYPE_ZIP);
+			ArtifactDescriptor ad = (ArtifactDescriptor) PublisherHelper.createArtifactDescriptor(artifacts[j], file);
+			processArtifactPropertiesAdvice(featureIU, ad, publisherInfo);
+			ad.setProperty(IArtifactDescriptor.DOWNLOAD_CONTENTTYPE, IArtifactDescriptor.TYPE_ZIP);
 			// if the artifact is a dir then zip it up.
 			if (file.isDirectory())
 				publishArtifact(ad, new File[] {file}, null, publisherInfo, createRootPrefixComputer(file));
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IBundleAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IBundleAdvice.java
deleted file mode 100644
index 525e03c..0000000
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IBundleAdvice.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 Code 9 and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: 
- *   Code 9 - initial API and implementation
- ******************************************************************************/
-package org.eclipse.equinox.p2.publisher.eclipse;
-
-import java.io.File;
-import java.util.Properties;
-import org.eclipse.equinox.p2.publisher.IPublisherAdvice;
-
-public interface IBundleAdvice extends IPublisherAdvice {
-
-	/**
-	 * Returns the set of extra properties to be associated with the IU for the bundle
-	 * at the given location
-	 * @param location the location of the feature to advise
-	 * @return extra properties for the given feature
-	 */
-	public Properties getIUProperties(File location);
-
-	/**
-	 * Returns the set of extra properties to be associated with the artifact descriptor
-	 * being published for the bundle at the given location
-	 * @param location the location of the feature to advise
-	 * @return extra properties for the given feature
-	 */
-	public Properties getArtifactProperties(File location);
-}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IFeatureAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IFeatureAdvice.java
deleted file mode 100644
index a5c4313..0000000
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/IFeatureAdvice.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 Code 9 and others. All rights reserved. This
- * program and the accompanying materials are made available under the terms of
- * the Eclipse Public License v1.0 which accompanies this distribution, and is
- * available at http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors: 
- *   Code 9 - initial API and implementation
- *   IBM - ongoing development
- ******************************************************************************/
-package org.eclipse.equinox.p2.publisher.eclipse;
-
-import java.util.Properties;
-import org.eclipse.equinox.p2.publisher.IPublisherAdvice;
-
-public interface IFeatureAdvice extends IPublisherAdvice {
-
-	/**
-	 * Returns the set of extra properties to be associated with the IU for the feature
-	 * at the given location
-	 * @return extra properties for the given feature
-	 */
-	public Properties getIUProperties(Feature feature);
-
-	/**
-	 * Returns the set of extra properties to be associated with the artifact descriptor
-	 * being published for the feature at the given location
-	 * @return extra properties for the given feature
-	 */
-	public Properties getArtifactProperties(Feature feature);
-}
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
index 6df72b6..007c882 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
@@ -83,6 +83,7 @@ public class ProductAction extends AbstractPublisherAction {
 		}
 		if (!finalStatus.isOK())
 			return finalStatus;
+
 		return Status.OK_STATUS;
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
index 15e2d51..6a34e02 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
@@ -12,8 +12,6 @@ package org.eclipse.equinox.p2.tests.publisher.actions;
 
 import static org.easymock.EasyMock.*;
 
-import org.eclipse.equinox.p2.publisher.actions.ITouchpointAdvice;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.util.*;
@@ -21,13 +19,16 @@ import java.util.zip.ZipInputStream;
 import org.easymock.EasyMock;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.publisher.IPublisherInfo;
 import org.eclipse.equinox.p2.publisher.IPublisherResult;
-import org.eclipse.equinox.p2.publisher.actions.ICapabilityAdvice;
-import org.eclipse.equinox.p2.publisher.eclipse.*;
+import org.eclipse.equinox.p2.publisher.actions.*;
+import org.eclipse.equinox.p2.publisher.eclipse.BundlesAction;
+import org.eclipse.equinox.p2.publisher.eclipse.IBundleShapeAdvice;
 import org.eclipse.equinox.p2.tests.TestActivator;
 import org.eclipse.equinox.p2.tests.TestData;
 import org.eclipse.equinox.p2.tests.publisher.TestArtifactRepository;
@@ -214,22 +215,27 @@ public class BundlesActionTest extends ActionTest {
 		sdkProperties.put("key1", "value1");//$NON-NLS-1$//$NON-NLS-2$
 		sdkProperties.put("key2", "value2");//$NON-NLS-1$//$NON-NLS-2$
 
-		IBundleAdvice bundleAdvice = EasyMock.createMock(IBundleAdvice.class);
-		expect(bundleAdvice.getArtifactProperties(TEST_FILE1)).andReturn(sarProperties).anyTimes();
-		expect(bundleAdvice.getArtifactProperties(TEST_FILE2)).andReturn(sdkProperties).anyTimes();
-		expect(bundleAdvice.getIUProperties((File) anyObject())).andReturn(new Properties()).anyTimes();
+		IPropertyAdvice propertyAdvice1 = EasyMock.createMock(IPropertyAdvice.class);
+		expect(propertyAdvice1.getInstallableUnitProperties((InstallableUnitDescription) EasyMock.anyObject())).andReturn(null).anyTimes();
+		expect(propertyAdvice1.getArtifactProperties((IInstallableUnit) EasyMock.anyObject(), (IArtifactDescriptor) EasyMock.anyObject())).andReturn(sarProperties).anyTimes();
+		EasyMock.replay(propertyAdvice1);
+		ArrayList adviceCollection1 = new ArrayList();
+		adviceCollection1.add(propertyAdvice1);
+
+		IPropertyAdvice propertyAdvice2 = EasyMock.createMock(IPropertyAdvice.class);
+		expect(propertyAdvice2.getInstallableUnitProperties((InstallableUnitDescription) EasyMock.anyObject())).andReturn(null).anyTimes();
+		expect(propertyAdvice2.getArtifactProperties((IInstallableUnit) EasyMock.anyObject(), (IArtifactDescriptor) EasyMock.anyObject())).andReturn(sdkProperties).anyTimes();
+		EasyMock.replay(propertyAdvice2);
+		ArrayList adviceCollection2 = new ArrayList();
+		adviceCollection2.add(propertyAdvice2);
 
-		EasyMock.replay(bundleAdvice);
-		ArrayList adviceCollection = new ArrayList();
-		adviceCollection.add(bundleAdvice);
-		expect(publisherInfo.getAdvice(null, false, null, null, IBundleAdvice.class)).andReturn(adviceCollection).anyTimes();
 		expect(publisherInfo.getArtifactRepository()).andReturn(artifactRepository).anyTimes();
 		expect(publisherInfo.getAdvice(null, false, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, ICapabilityAdvice.class)).andReturn(Collections.EMPTY_LIST); //$NON-NLS-1$
-		expect(publisherInfo.getAdvice(null, false, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, IBundleAdvice.class)).andReturn(Collections.EMPTY_LIST); //$NON-NLS-1$
-		expect(publisherInfo.getAdvice(null, false, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, AdviceFileAdvice.class)).andReturn(Collections.EMPTY_LIST); //$NON-NLS-1$
+		expect(publisherInfo.getAdvice(null, false, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, IPropertyAdvice.class)).andReturn(adviceCollection1).times(2); //$NON-NLS-1$
+		expect(publisherInfo.getAdvice(null, false, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, IAdditionalInstallableUnitAdvice.class)).andReturn(Collections.EMPTY_LIST); //$NON-NLS-1$
 		expect(publisherInfo.getAdvice(null, false, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, ICapabilityAdvice.class)).andReturn(Collections.EMPTY_LIST);//$NON-NLS-1$
-		expect(publisherInfo.getAdvice(null, false, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, IBundleAdvice.class)).andReturn(Collections.EMPTY_LIST);//$NON-NLS-1$
-		expect(publisherInfo.getAdvice(null, false, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, AdviceFileAdvice.class)).andReturn(Collections.EMPTY_LIST);//$NON-NLS-1$		
+		expect(publisherInfo.getAdvice(null, false, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, IPropertyAdvice.class)).andReturn(adviceCollection2).times(2);//$NON-NLS-1$
+		expect(publisherInfo.getAdvice(null, false, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, IAdditionalInstallableUnitAdvice.class)).andReturn(Collections.EMPTY_LIST);//$NON-NLS-1$		
 		expect(publisherInfo.getAdvice(null, true, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, IBundleShapeAdvice.class)).andReturn(null); //$NON-NLS-1$
 		expect(publisherInfo.getAdvice(null, true, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, IBundleShapeAdvice.class)).andReturn(null);//$NON-NLS-1$
 		expect(publisherInfo.getArtifactOptions()).andReturn(IPublisherInfo.A_INDEX | IPublisherInfo.A_OVERWRITE | IPublisherInfo.A_PUBLISH).anyTimes();
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/FeaturesActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/FeaturesActionTest.java
index 4f09afe..5a4b5a3 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/FeaturesActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/FeaturesActionTest.java
@@ -21,14 +21,15 @@ import org.easymock.EasyMock;
 import org.eclipse.core.runtime.NullProgressMonitor;
 import org.eclipse.core.runtime.Path;
 import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.publisher.IPublisherInfo;
 import org.eclipse.equinox.p2.publisher.IPublisherResult;
-import org.eclipse.equinox.p2.publisher.actions.ICapabilityAdvice;
-import org.eclipse.equinox.p2.publisher.actions.ITouchpointAdvice;
-import org.eclipse.equinox.p2.publisher.eclipse.*;
+import org.eclipse.equinox.p2.publisher.actions.*;
+import org.eclipse.equinox.p2.publisher.eclipse.FeaturesAction;
 import org.eclipse.equinox.p2.tests.*;
 import org.eclipse.equinox.p2.tests.publisher.TestArtifactRepository;
 import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;
@@ -168,17 +169,17 @@ public class FeaturesActionTest extends ActionTest {
 		metadataRepository = new TestMetadataRepository(new IInstallableUnit[] {mockIU(BAR, null)});
 
 		ArrayList adviceCollection = fillAdvice(new ArrayList());
-		expect(publisherInfo.getAdvice(null, false, "bar.feature.jar", barVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
-		expect(publisherInfo.getAdvice(null, false, "bar", barVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
-		expect(publisherInfo.getAdvice(null, false, "bar.feature.group", barVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "bar.feature.jar", barVersion, IPropertyAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "bar", barVersion, IPropertyAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "bar.feature.group", barVersion, IPropertyAdvice.class)).andReturn(adviceCollection).anyTimes();
 		expect(publisherInfo.getAdvice(null, false, "bar.feature.group", barVersion, ITouchpointAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
 		expect(publisherInfo.getAdvice(null, false, "bar.feature.group", barVersion, ICapabilityAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
-		expect(publisherInfo.getAdvice(null, false, "bar.feature.group", barVersion, AdviceFileAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
-		expect(publisherInfo.getAdvice(null, false, "foo.feature.jar", fooVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
-		expect(publisherInfo.getAdvice(null, false, "foo", fooVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
-		expect(publisherInfo.getAdvice(null, false, "foo.feature.group", fooVersion, IFeatureAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "bar.feature.group", barVersion, IAdditionalInstallableUnitAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "foo.feature.jar", fooVersion, IPropertyAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "foo", fooVersion, IPropertyAdvice.class)).andReturn(adviceCollection).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "foo.feature.group", fooVersion, IPropertyAdvice.class)).andReturn(adviceCollection).anyTimes();
 		expect(publisherInfo.getAdvice(null, false, "foo.feature.group", fooVersion, ICapabilityAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
-		expect(publisherInfo.getAdvice(null, false, "foo.feature.group", fooVersion, AdviceFileAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, "foo.feature.group", fooVersion, IAdditionalInstallableUnitAdvice.class)).andReturn(Collections.EMPTY_LIST).anyTimes();
 		expect(publisherInfo.getArtifactOptions()).andReturn(IPublisherInfo.A_INDEX | IPublisherInfo.A_OVERWRITE | IPublisherInfo.A_PUBLISH).anyTimes();
 		expect(publisherInfo.getArtifactRepository()).andReturn(artifactRepository).anyTimes();
 		expect(publisherInfo.getMetadataRepository()).andReturn(metadataRepository).anyTimes();
@@ -193,11 +194,11 @@ public class FeaturesActionTest extends ActionTest {
 		Properties prop = new Properties();
 		prop.setProperty("key1", "value1"); //$NON-NLS-1$//$NON-NLS-2$
 		prop.setProperty("key2", "value2"); //$NON-NLS-1$//$NON-NLS-2$
-		IFeatureAdvice featureAdvice = EasyMock.createMock(IFeatureAdvice.class);
-		expect(featureAdvice.getIUProperties((Feature) EasyMock.anyObject())).andReturn(prop).anyTimes();
-		expect(featureAdvice.getArtifactProperties((Feature) EasyMock.anyObject())).andReturn(null).anyTimes();
-		EasyMock.replay(featureAdvice);
-		adviceCollection.add(featureAdvice);
+		IPropertyAdvice propertyAdvice = EasyMock.createMock(IPropertyAdvice.class);
+		expect(propertyAdvice.getInstallableUnitProperties((InstallableUnitDescription) EasyMock.anyObject())).andReturn(prop).anyTimes();
+		expect(propertyAdvice.getArtifactProperties((IInstallableUnit) EasyMock.anyObject(), (IArtifactDescriptor) EasyMock.anyObject())).andReturn(null).anyTimes();
+		EasyMock.replay(propertyAdvice);
+		adviceCollection.add(propertyAdvice);
 		return adviceCollection;
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
index 2ef25d6..65f30f1 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
@@ -342,7 +342,9 @@ public class RootIUActionTest extends ActionTest {
 		expect(publisherInfo.getAdvice(null, false, rootIU, versionArg, ICapabilityAdvice.class)).andReturn(new ArrayList()).anyTimes();
 		expect(publisherInfo.getAdvice(null, true, null, null, IRootIUAdvice.class)).andReturn(rootIUAdviceCollection).anyTimes();
 		expect(publisherInfo.getAdvice(null, true, null, null, IVersionAdvice.class)).andReturn(null).anyTimes();
-		expect(publisherInfo.getAdvice(null, true, rootIU, versionArg, ITouchpointAdvice.class)).andReturn(new ArrayList()).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, rootIU, versionArg, ITouchpointAdvice.class)).andReturn(new ArrayList()).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, rootIU, versionArg, IPropertyAdvice.class)).andReturn(new ArrayList()).anyTimes();
+		expect(publisherInfo.getAdvice(null, false, rootIU, versionArg, IAdditionalInstallableUnitAdvice.class)).andReturn(new ArrayList()).anyTimes();
 		expect(publisherInfo.getMetadataRepository()).andReturn(metadataRepository).anyTimes();
 	}
 
commit ff51a849a0b989f675a75e73b5c5749110023334
Author: Andrew Niefer <aniefer>
Date:   Wed Feb 25 16:57:13 2009 +0000

    Bug 265217 - update pde.build test

4	3	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
1	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
index 0cdfc7f..dfd9f37 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
@@ -204,7 +204,8 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 		for (Iterator iterator = advice.iterator(); iterator.hasNext();) {
 			IAdditionalInstallableUnitAdvice entry = (IAdditionalInstallableUnitAdvice) iterator.next();
 			InstallableUnitDescription[] others = entry.getAdditionalInstallableUnitDescriptions(iu);
-			ius.addAll(Arrays.asList(others));
+			if (others != null)
+				ius.addAll(Arrays.asList(others));
 		}
 		return (InstallableUnitDescription[]) ius.toArray(new InstallableUnitDescription[ius.size()]);
 	}
@@ -258,14 +259,14 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 		for (Iterator i = advice.iterator(); i.hasNext();) {
 			ICapabilityAdvice entry = (ICapabilityAdvice) i.next();
 			IRequiredCapability[] requiredAdvice = entry.getRequiredCapabilities(iu);
-			IProvidedCapability[] providedAdvice = entry.getProvidedCapabilities(iu);
-			if (providedAdvice != null) {
+			if (requiredAdvice != null) {
 				IRequiredCapability[] current = iu.getRequiredCapabilities();
 				IRequiredCapability[] result = new IRequiredCapability[requiredAdvice.length + current.length];
 				System.arraycopy(requiredAdvice, 0, result, 0, requiredAdvice.length);
 				System.arraycopy(current, 0, result, requiredAdvice.length, current.length);
 				iu.setRequiredCapabilities(result);
 			}
+			IProvidedCapability[] providedAdvice = entry.getProvidedCapabilities(iu);
 			if (providedAdvice != null) {
 				IProvidedCapability[] current = iu.getProvidedCapabilities();
 				IProvidedCapability[] result = new IProvidedCapability[providedAdvice.length + current.length];
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index 500505b..35b3668 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -25,7 +25,7 @@ import org.eclipse.equinox.p2.publisher.actions.*;
  * in the source of a bundle, feature, or product to specify additional advice to be
  * added to the {@link IInstallableUnit} corresponding to the bundle, feature, or product.
  */
-public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvice, ICapabilityAdvice, IPropertyAdvice {
+public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvice, ICapabilityAdvice, IPropertyAdvice, IAdditionalInstallableUnitAdvice {
 
 	/**
 	 * The location of the bundle advice file, relative to the bundle root location.
commit 850adde4531b23629e38f442b7857094e4804738
Author: Simon Kaegi <skaegi>
Date:   Wed Feb 25 19:32:07 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf
    -eliminating unnecessary advicefileadvice

6	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
7	2	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
3	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
3	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
3	1	bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index 35b3668..bd0ba80 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -40,6 +40,7 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 	private IRequiredCapability[] requiredCapabilities;
 	private Properties iuProperties;
 	private InstallableUnitDescription[] otherIUs;
+	private boolean containsAdvice = false;
 
 	/**
 	 * Creates advice for an advice file at the given location. If <tt>basePath</tt>
@@ -73,6 +74,11 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 		requiredCapabilities = parser.getRequiredCapabilities();
 		iuProperties = parser.getProperties();
 		otherIUs = parser.getOtherInstallableUnitDescriptions();
+		containsAdvice = true;
+	}
+
+	public boolean containsAdvice() {
+		return containsAdvice;
 	}
 
 	/**
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
index d92f4690..c04f2e7 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
@@ -692,8 +692,13 @@ public class BundlesAction extends AbstractPublisherAction {
 	 */
 	private void createAdviceFileAdvice(BundleDescription bundleDescription, IPublisherInfo info) {
 		String location = bundleDescription.getLocation();
-		if (location != null)
-			info.addAdvice(new AdviceFileAdvice(bundleDescription.getSymbolicName(), Version.fromOSGiVersion(bundleDescription.getVersion()), new Path(location), AdviceFileAdvice.BUNDLE_ADVICE_FILE));
+		if (location == null)
+			return;
+
+		AdviceFileAdvice advice = new AdviceFileAdvice(bundleDescription.getSymbolicName(), Version.fromOSGiVersion(bundleDescription.getVersion()), new Path(location), AdviceFileAdvice.BUNDLE_ADVICE_FILE);
+		if (advice.containsAdvice())
+			info.addAdvice(advice);
+
 	}
 
 	private static boolean isDir(BundleDescription bundle, IPublisherInfo info) {
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
index 6bbd6f2..3c274ff 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/FeaturesAction.java
@@ -154,7 +154,9 @@ public class FeaturesAction extends AbstractPublisherAction {
 		String location = feature.getLocation();
 		if (location != null) {
 			String groupId = getTransformedId(feature.getId(), /*isPlugin*/false, /*isGroup*/true);
-			info.addAdvice(new AdviceFileAdvice(groupId, new Version(feature.getVersion()), new Path(location), new Path("p2.inf"))); //$NON-NLS-1$
+			AdviceFileAdvice advice = new AdviceFileAdvice(groupId, new Version(feature.getVersion()), new Path(location), new Path("p2.inf")); //$NON-NLS-1$
+			if (advice.containsAdvice())
+				info.addAdvice(advice);
 		}
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
index 007c882..ecc62dc 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/ProductAction.java
@@ -102,8 +102,10 @@ public class ProductAction extends AbstractPublisherAction {
 		File productFileLocation = product.getLocation();
 		if (productFileLocation == null)
 			return;
-		info.addAdvice(new AdviceFileAdvice(product.getId(), new Version(product.getVersion()), new Path(productFileLocation.getParent()), new Path("p2.inf"))); //$NON-NLS-1$
 
+		AdviceFileAdvice advice = new AdviceFileAdvice(product.getId(), new Version(product.getVersion()), new Path(productFileLocation.getParent()), new Path("p2.inf")); //$NON-NLS-1$
+		if (advice.containsAdvice())
+			info.addAdvice(advice);
 	}
 
 	private void createRootAdvice() {
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java b/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
index 68324f0..f55c407 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
@@ -195,7 +195,9 @@ public class EclipseTouchpoint extends Touchpoint {
 		BundleDescription bundleDescription = BundlesAction.createBundleDescription(bundleFile);
 		PublisherInfo info = new PublisherInfo();
 		Version version = new Version(bundleDescription.getVersion().toString());
-		info.addAdvice(new AdviceFileAdvice(bundleDescription.getSymbolicName(), version, new Path(bundleFile.getAbsolutePath()), AdviceFileAdvice.BUNDLE_ADVICE_FILE));
+		AdviceFileAdvice advice = new AdviceFileAdvice(bundleDescription.getSymbolicName(), version, new Path(bundleFile.getAbsolutePath()), AdviceFileAdvice.BUNDLE_ADVICE_FILE);
+		if (advice.containsAdvice())
+			info.addAdvice(advice);
 		String shape = bundleFile.isDirectory() ? IBundleShapeAdvice.DIR : IBundleShapeAdvice.JAR;
 		info.addAdvice(new BundleShapeAdvice(bundleDescription.getSymbolicName(), version, shape));
 		return BundlesAction.createBundleIU(bundleDescription, artifactKey, info);
commit f9f312304ab10f05d63708988eaccb024d302d65
Author: Simon Kaegi <skaegi>
Date:   Wed Feb 25 21:04:40 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf
    added $qualifier$ and $version$ support when parsing version and version ranges

1	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
32	8	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
16	16	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index bd0ba80..9fd0dca 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -67,7 +67,7 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 		if (advice.isEmpty())
 			return;
 
-		AdviceFileParser parser = new AdviceFileParser(advice);
+		AdviceFileParser parser = new AdviceFileParser(id, version, advice);
 		parser.parse();
 		touchpointInstructions = parser.getTouchpointInstructions();
 		providedCapabilities = parser.getProvidedCapabilities();
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
index 4fde90e..4728a84 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
@@ -30,8 +30,12 @@ public class AdviceFileParser {
 	private final Map advice;
 	private Iterator keysIterator;
 	private String current;
+	//	private String hostId; not currently used
+	private Version hostVersion;
 
-	public AdviceFileParser(Map advice) {
+	public AdviceFileParser(String id, Version version, Map advice) {
+		// this.hostId = id; not currently used
+		this.hostVersion = version;
 		this.advice = advice;
 	}
 
@@ -93,11 +97,11 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			String token = current.substring(prefix.length());
 			if (token.equals("name")) {
-				name = (String) advice.get(current);
+				name = currentValue();
 			} else if (token.equals("namespace")) {
-				namespace = (String) advice.get(current);
+				namespace = currentValue();
 			} else if (token.equals("version")) {
-				capabilityVersion = new Version((String) advice.get(current));
+				capabilityVersion = new Version(substituteVersionAndQualifier(currentValue()));
 			} else
 				throw new IllegalStateException("bad token: " + current);
 			next();
@@ -142,7 +146,7 @@ public class AdviceFileParser {
 			} else if (token.equals("namespace")) {
 				namespace = currentValue();
 			} else if (token.equals("range")) {
-				range = new VersionRange(currentValue());
+				range = new VersionRange(substituteVersionAndQualifier(currentValue()));
 			} else
 				throw new IllegalStateException("bad token: " + current);
 			next();
@@ -214,7 +218,7 @@ public class AdviceFileParser {
 				unitId = currentValue();
 				next();
 			} else if (token.equals("version")) {
-				unitVersion = new Version(currentValue());
+				unitVersion = new Version(substituteVersionAndQualifier(currentValue()));
 				next();
 			} else if (token.equals("filter")) {
 				unitFilter = currentValue();
@@ -229,7 +233,7 @@ public class AdviceFileParser {
 				unitTouchpointId = currentValue();
 				next();
 			} else if (token.equals("touchpoinit.version")) {
-				unitTouchpointVersion = new Version(currentValue());
+				unitTouchpointVersion = new Version(substituteVersionAndQualifier(currentValue()));
 				next();
 			} else if (token.startsWith("hostRequirements."))
 				parseHostRequirements(prefix + "hostRequirements.", unitHostRequirements);
@@ -344,7 +348,7 @@ public class AdviceFileParser {
 			} else if (token.equals("id")) {
 				artifactId = currentValue();
 			} else if (token.equals("version")) {
-				artifactVersion = new Version(currentValue());
+				artifactVersion = new Version(substituteVersionAndQualifier(currentValue()));
 			} else
 				throw new IllegalStateException("bad token: " + current);
 			next();
@@ -363,6 +367,26 @@ public class AdviceFileParser {
 		}
 	}
 
+	private String substituteVersionAndQualifier(String version) {
+		if (version.indexOf("$version$") != -1) {
+			version = version.replaceAll("\\$version\\$", hostVersion.toString());
+		}
+
+		if (version.indexOf("$qualifier$") != -1) {
+			String qualifier = hostVersion.getQualifier();
+			if (qualifier == null)
+				qualifier = "";
+			if (qualifier.length() == 0) {
+				// Note: this works only for OSGi versions and version ranges
+				// where the qualifier if present must be at the end of a version string
+				version = version.replaceAll(".\\$qualifier\\$", "");
+			}
+
+			version = version.replaceAll("\\$qualifier\\$", qualifier);
+		}
+		return version;
+	}
+
 	public Properties getProperties() {
 		if (adviceProperties.isEmpty())
 			return null;
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
index 4d2860e..6cb2ab8 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
@@ -19,7 +19,7 @@ import org.eclipse.equinox.p2.publisher.eclipse.AdviceFileParser;
 
 public class AdviceFileParserTest extends TestCase {
 	public void testNoAdvice() {
-		AdviceFileParser parser = new AdviceFileParser(Collections.EMPTY_MAP);
+		AdviceFileParser parser = new AdviceFileParser("id", Version.MIN_VERSION, Collections.EMPTY_MAP);
 		parser.parse();
 	}
 
@@ -28,7 +28,7 @@ public class AdviceFileParserTest extends TestCase {
 		map.put("properties.testName1", "testValue1");
 		map.put("properties.testName2", "testValue2");
 
-		AdviceFileParser parser = new AdviceFileParser(map);
+		AdviceFileParser parser = new AdviceFileParser("id", Version.MIN_VERSION, map);
 		parser.parse();
 		assertEquals("testValue1", parser.getProperties().getProperty("testName1"));
 		assertEquals("testValue2", parser.getProperties().getProperty("testName2"));
@@ -38,21 +38,21 @@ public class AdviceFileParserTest extends TestCase {
 		Map map = new HashMap();
 		map.put("provides.0.namespace", "testNamespace1");
 		map.put("provides.0.name", "testName1");
-		map.put("provides.0.version", "1.2.3");
+		map.put("provides.0.version", "1.2.3.$qualifier$");
 
-		AdviceFileParser parser = new AdviceFileParser(map);
+		AdviceFileParser parser = new AdviceFileParser("id", new Version("1.0.0.v20090909"), map);
 		parser.parse();
 		IProvidedCapability[] capabilities = parser.getProvidedCapabilities();
 		assertEquals(1, capabilities.length);
 		assertEquals("testNamespace1", capabilities[0].getNamespace());
 		assertEquals("testName1", capabilities[0].getName());
-		assertEquals(new Version("1.2.3"), capabilities[0].getVersion());
+		assertEquals(new Version("1.2.3.v20090909"), capabilities[0].getVersion());
 
 		map.put("provides.1.namespace", "testNamespace2");
 		map.put("provides.1.name", "testName2");
-		map.put("provides.1.version", "1.2.4");
+		map.put("provides.1.version", "$version$");
 
-		parser = new AdviceFileParser(map);
+		parser = new AdviceFileParser("id", Version.MIN_VERSION, map);
 		parser.parse();
 		capabilities = parser.getProvidedCapabilities();
 		assertEquals(2, capabilities.length);
@@ -61,47 +61,47 @@ public class AdviceFileParserTest extends TestCase {
 		assertEquals(new Version("1.2.3"), capabilities[0].getVersion());
 		assertEquals("testNamespace2", capabilities[1].getNamespace());
 		assertEquals("testName2", capabilities[1].getName());
-		assertEquals(new Version("1.2.4"), capabilities[1].getVersion());
+		assertEquals(Version.MIN_VERSION, capabilities[1].getVersion());
 	}
 
 	public void testRequiresAdvice() {
 		Map map = new HashMap();
 		map.put("requires.0.namespace", "testNamespace1");
 		map.put("requires.0.name", "testName1");
-		map.put("requires.0.range", "1.2.3");
+		map.put("requires.0.range", "[1.2.3.$qualifier$, 2)");
 		map.put("requires.0.greedy", Boolean.TRUE.toString());
 		map.put("requires.0.optional", Boolean.TRUE.toString());
 		map.put("requires.0.multiple", Boolean.TRUE.toString());
 
-		AdviceFileParser parser = new AdviceFileParser(map);
+		AdviceFileParser parser = new AdviceFileParser("id", new Version("1.0.0.v20090909"), map);
 		parser.parse();
 		IRequiredCapability[] capabilities = parser.getRequiredCapabilities();
 		assertEquals(1, capabilities.length);
 		assertEquals("testNamespace1", capabilities[0].getNamespace());
 		assertEquals("testName1", capabilities[0].getName());
-		assertEquals(new VersionRange("1.2.3"), capabilities[0].getRange());
+		assertEquals(new VersionRange("[1.2.3.v20090909, 2)"), capabilities[0].getRange());
 
 		map.put("requires.1.namespace", "testNamespace2");
 		map.put("requires.1.name", "testName2");
-		map.put("requires.1.range", "1.2.4");
+		map.put("requires.1.range", "$version$");
 		map.put("requires.1.greedy", Boolean.FALSE.toString());
 		map.put("requires.1.optional", Boolean.FALSE.toString());
 		//default 
 		//		map.put("requires.1.multiple", Boolean.FALSE.toString());
 
-		parser = new AdviceFileParser(map);
+		parser = new AdviceFileParser("id", Version.MIN_VERSION, map);
 		parser.parse();
 		capabilities = parser.getRequiredCapabilities();
 		assertEquals(2, capabilities.length);
 		assertEquals("testNamespace1", capabilities[0].getNamespace());
 		assertEquals("testName1", capabilities[0].getName());
-		assertEquals(new VersionRange("1.2.3"), capabilities[0].getRange());
+		assertEquals(new VersionRange("[1.2.3, 2)"), capabilities[0].getRange());
 		assertEquals(true, capabilities[0].isGreedy());
 		assertEquals(true, capabilities[0].isOptional());
 		assertEquals(true, capabilities[0].isMultiple());
 		assertEquals("testNamespace2", capabilities[1].getNamespace());
 		assertEquals("testName2", capabilities[1].getName());
-		assertEquals(new VersionRange("1.2.4"), capabilities[1].getRange());
+		assertEquals(new VersionRange(Version.MIN_VERSION.toString()), capabilities[1].getRange());
 		assertEquals(false, capabilities[1].isGreedy());
 		assertEquals(false, capabilities[1].isOptional());
 		assertEquals(false, capabilities[1].isMultiple());
@@ -114,7 +114,7 @@ public class AdviceFileParserTest extends TestCase {
 		map.put("instructions.unconfigure", "removeProgramArg(programArg:-startup); removeProgramArg(programArg:@artifact);)");
 		map.put("instructions.unconfigure.import", "some.removeProgramArg");
 
-		AdviceFileParser parser = new AdviceFileParser(map);
+		AdviceFileParser parser = new AdviceFileParser("id", Version.MIN_VERSION, map);
 		parser.parse();
 		ITouchpointInstruction configure = (ITouchpointInstruction) parser.getTouchpointInstructions().get("configure");
 		assertEquals(null, configure.getImportAttribute());
commit 02d3e7abb7951eb0f57bc4a5ab85e8a5cc9b6fef
Author: Simon Kaegi <skaegi>
Date:   Wed Feb 25 22:40:08 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf
    Improving error handling and fixing use of regexp String.replace which isn't in profile 1.1

12	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
54	24	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index 9fd0dca..fd277bc 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -13,6 +13,8 @@ import java.util.*;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
+import org.eclipse.equinox.internal.p2.publisher.Activator;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactDescriptor;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
@@ -68,7 +70,13 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 			return;
 
 		AdviceFileParser parser = new AdviceFileParser(id, version, advice);
-		parser.parse();
+		try {
+			parser.parse();
+		} catch (Exception e) {
+			String message = "An error occured while parsing advice file: basePath=" + basePath + ", adviceFilePath=" + adviceFilePath + ".";
+			IStatus status = new Status(IStatus.ERROR, Activator.ID, message, e);
+			LogHelper.log(status);
+		}
 		touchpointInstructions = parser.getTouchpointInstructions();
 		providedCapabilities = parser.getProvidedCapabilities();
 		requiredCapabilities = parser.getRequiredCapabilities();
@@ -108,6 +116,9 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 			advice.load(stream);
 			return (advice != null ? advice : Collections.EMPTY_MAP);
 		} catch (IOException e) {
+			String message = "An error occured while reading advice file: basePath=" + basePath + ", adviceFilePath=" + adviceFilePath + ".";
+			IStatus status = new Status(IStatus.ERROR, Activator.ID, message, e);
+			LogHelper.log(status);
 			return Collections.EMPTY_MAP;
 		} finally {
 			if (stream != null)
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
index 4728a84..88cdc79 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
@@ -57,8 +57,11 @@ public class AdviceFileParser {
 				parseInstructions("instructions.", adviceInstructions);
 			else if (current.startsWith("units."))
 				parseUnits("units.", adviceOtherIUs);
-			else
-				throw new IllegalStateException("bad token: " + current);
+			else {
+				// we ignore elements we do not understand
+				next();
+			}
+
 		}
 	}
 
@@ -102,8 +105,9 @@ public class AdviceFileParser {
 				namespace = currentValue();
 			} else if (token.equals("version")) {
 				capabilityVersion = new Version(substituteVersionAndQualifier(currentValue()));
-			} else
-				throw new IllegalStateException("bad token: " + current);
+			} else {
+				// we ignore elements we do not understand
+			}
 			next();
 		}
 
@@ -147,8 +151,9 @@ public class AdviceFileParser {
 				namespace = currentValue();
 			} else if (token.equals("range")) {
 				range = new VersionRange(substituteVersionAndQualifier(currentValue()));
-			} else
-				throw new IllegalStateException("bad token: " + current);
+			} else {
+				// we ignore elements we do not understand
+			}
 			next();
 		}
 		IRequiredCapability capability = MetadataFactory.createRequiredCapability(namespace, name, range, filter, optional, multiple, greedy);
@@ -175,8 +180,9 @@ public class AdviceFileParser {
 		if (current != null && current.startsWith(prefix)) {
 			if (current.substring(prefix.length()).equals("import")) {
 				importAttribute = currentValue();
-			} else
-				throw new IllegalStateException("bad token: " + current);
+			} else {
+				// we ignore elements we do not understand
+			}
 			next();
 		}
 		ITouchpointInstruction instruction = MetadataFactory.createTouchpointInstruction(body, importAttribute);
@@ -187,7 +193,7 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex == -1)
-				throw new IllegalStateException("bad token: " + current);
+				throw new IllegalStateException("bad token: " + current + " = " + currentValue());
 
 			parseUnit(current.substring(0, dotIndex + 1), ius);
 		}
@@ -249,8 +255,10 @@ public class AdviceFileParser {
 				parseRequires(prefix + "requires.", unitRequires);
 			else if (token.startsWith("instructions."))
 				parseInstructions(prefix + "instructions.", unitInstructions);
-			else
-				throw new IllegalStateException("bad token: " + current);
+			else {
+				// we ignore elements we do not understand
+				next();
+			}
 		}
 
 		InstallableUnitDescription description = unitHostRequirements.isEmpty() ? new InstallableUnitDescription() : new InstallableUnitFragmentDescription();
@@ -262,7 +270,7 @@ public class AdviceFileParser {
 			try {
 				description.setCopyright(MetadataFactory.createCopyright(new URI(unitCopyrightLocation), unitCopyright));
 			} catch (URISyntaxException e) {
-				throw new IllegalStateException();
+				throw new IllegalStateException("bad copyright URI at token: " + current + ", " + currentValue());
 			}
 		}
 		if (unitTouchpointId != null)
@@ -299,7 +307,7 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex == -1)
-				throw new IllegalStateException("bad token: " + current);
+				throw new IllegalStateException("bad token: " + current + " = " + currentValue());
 
 			parseLicense(current.substring(0, dotIndex + 1), licenses);
 		}
@@ -314,8 +322,9 @@ public class AdviceFileParser {
 		if (current != null && current.startsWith(prefix)) {
 			if (current.substring(prefix.length()).equals("import")) {
 				location = currentValue();
-			} else
-				throw new IllegalStateException("bad token: " + current);
+			} else {
+				// we ignore elements we do not understand
+			}
 			next();
 		}
 
@@ -323,7 +332,7 @@ public class AdviceFileParser {
 			ILicense license = MetadataFactory.createLicense(new URI(location), body);
 			licenses.add(license);
 		} catch (URISyntaxException e) {
-			throw new IllegalStateException();
+			throw new IllegalStateException("bad license URI at token: " + current + ", " + currentValue());
 		}
 	}
 
@@ -331,7 +340,7 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex == -1)
-				throw new IllegalStateException("bad token: " + current);
+				throw new IllegalStateException("bad token: " + current + " = " + currentValue());
 
 			parseArtifact(current.substring(0, dotIndex + 1), artifacts);
 		}
@@ -349,8 +358,10 @@ public class AdviceFileParser {
 				artifactId = currentValue();
 			} else if (token.equals("version")) {
 				artifactVersion = new Version(substituteVersionAndQualifier(currentValue()));
-			} else
-				throw new IllegalStateException("bad token: " + current);
+			} else {
+				// we ignore elements we do not understand
+			}
+
 			next();
 		}
 		IArtifactKey artifactKey = new ArtifactKey(artifactClassifier, artifactId, artifactVersion);
@@ -361,7 +372,7 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex == -1)
-				throw new IllegalStateException("bad token: " + current);
+				throw new IllegalStateException("bad token: " + current + " = " + currentValue());
 
 			parseRequired(current.substring(0, dotIndex + 1), hostRequirements);
 		}
@@ -369,7 +380,7 @@ public class AdviceFileParser {
 
 	private String substituteVersionAndQualifier(String version) {
 		if (version.indexOf("$version$") != -1) {
-			version = version.replaceAll("\\$version\\$", hostVersion.toString());
+			version = replace(version, "$version$", hostVersion.toString());
 		}
 
 		if (version.indexOf("$qualifier$") != -1) {
@@ -379,14 +390,33 @@ public class AdviceFileParser {
 			if (qualifier.length() == 0) {
 				// Note: this works only for OSGi versions and version ranges
 				// where the qualifier if present must be at the end of a version string
-				version = version.replaceAll(".\\$qualifier\\$", "");
+				version = replace(version, ".$qualifier$", "");
 			}
-
-			version = version.replaceAll("\\$qualifier\\$", qualifier);
+			version = replace(version, "$qualifier$", qualifier);
 		}
 		return version;
 	}
 
+	// originally from org.eclipse.core.internal.net.StringUtil
+	public static String replace(String source, String from, String to) {
+		if (from.length() == 0)
+			return source;
+		StringBuffer buffer = new StringBuffer();
+		int current = 0;
+		int pos = 0;
+		while (pos != -1) {
+			pos = source.indexOf(from, current);
+			if (pos == -1) {
+				buffer.append(source.substring(current));
+			} else {
+				buffer.append(source.substring(current, pos));
+				buffer.append(to);
+				current = pos + from.length();
+			}
+		}
+		return buffer.toString();
+	}
+
 	public Properties getProperties() {
 		if (adviceProperties.isEmpty())
 			return null;
commit 1ce300e5d49c8ba9d1d327a687432945126405af
Author: Simon Kaegi <skaegi>
Date:   Wed Feb 25 23:06:14 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf
    Tidying up warnings and adding parse constants

2	2	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
88	64	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index fd277bc..0c137e5 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -73,7 +73,7 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 		try {
 			parser.parse();
 		} catch (Exception e) {
-			String message = "An error occured while parsing advice file: basePath=" + basePath + ", adviceFilePath=" + adviceFilePath + ".";
+			String message = "An error occured while parsing advice file: basePath=" + basePath + ", adviceFilePath=" + adviceFilePath + "."; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
 			IStatus status = new Status(IStatus.ERROR, Activator.ID, message, e);
 			LogHelper.log(status);
 		}
@@ -116,7 +116,7 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 			advice.load(stream);
 			return (advice != null ? advice : Collections.EMPTY_MAP);
 		} catch (IOException e) {
-			String message = "An error occured while reading advice file: basePath=" + basePath + ", adviceFilePath=" + adviceFilePath + ".";
+			String message = "An error occured while reading advice file: basePath=" + basePath + ", adviceFilePath=" + adviceFilePath + "."; //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
 			IStatus status = new Status(IStatus.ERROR, Activator.ID, message, e);
 			LogHelper.log(status);
 			return Collections.EMPTY_MAP;
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
index 88cdc79..aed3eb9 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
@@ -21,6 +21,31 @@ import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.Inst
 
 public class AdviceFileParser {
 
+	private static final String QUALIFIER_SUBSTITUTION = "$qualifier$"; //$NON-NLS-1$
+	private static final String VERSION_SUBSTITUTION = "$version$"; //$NON-NLS-1$
+	private static final String CLASSIFIER = "classifier"; //$NON-NLS-1$
+	private static final String LICENSES_PREFIX = "licenses."; //$NON-NLS-1$
+	private static final String ARTIFACTS_PREFIX = "artifacts."; //$NON-NLS-1$
+	private static final String HOST_REQUIREMENTS_PREFIX = "hostRequirements."; //$NON-NLS-1$
+	private static final String TOUCHPOINIT_VERSION = "touchpoinit.version"; //$NON-NLS-1$
+	private static final String TOUCHPOINT_ID = "touchpoint.id"; //$NON-NLS-1$
+	private static final String COPYRIGHT_LOCATION = "copyright.location"; //$NON-NLS-1$
+	private static final String COPYRIGHT = "copyright"; //$NON-NLS-1$
+	private static final String ID = "id"; //$NON-NLS-1$
+	private static final String IMPORT = "import"; //$NON-NLS-1$
+	private static final String RANGE = "range"; //$NON-NLS-1$
+	private static final String FILTER = "filter"; //$NON-NLS-1$
+	private static final String MULTIPLE = "multiple"; //$NON-NLS-1$
+	private static final String OPTIONAL = "optional"; //$NON-NLS-1$
+	private static final String GREEDY = "greedy"; //$NON-NLS-1$
+	private static final String VERSION = "version"; //$NON-NLS-1$
+	private static final String NAMESPACE = "namespace"; //$NON-NLS-1$
+	private static final String NAME = "name"; //$NON-NLS-1$
+	private static final String UNITS_PREFIX = "units."; //$NON-NLS-1$
+	private static final String INSTRUCTIONS_PREFIX = "instructions."; //$NON-NLS-1$
+	private static final String REQUIRES_PREFIX = "requires."; //$NON-NLS-1$
+	private static final String PROVIDES_PREFIX = "provides."; //$NON-NLS-1$
+	private static final String PROPERTIES_PREFIX = "properties."; //$NON-NLS-1$
 	private Properties adviceProperties = new Properties();
 	private List adviceProvides = new ArrayList();
 	private List adviceRequires = new ArrayList();
@@ -47,21 +72,20 @@ public class AdviceFileParser {
 		next();
 
 		while (current != null) {
-			if (current.startsWith("properties."))
-				parseProperties("properties.", adviceProperties);
-			else if (current.startsWith("provides."))
-				parseProvides("provides.", adviceProvides);
-			else if (current.startsWith("requires."))
-				parseRequires("requires.", adviceRequires);
-			else if (current.startsWith("instructions."))
-				parseInstructions("instructions.", adviceInstructions);
-			else if (current.startsWith("units."))
-				parseUnits("units.", adviceOtherIUs);
+			if (current.startsWith(PROPERTIES_PREFIX))
+				parseProperties(PROPERTIES_PREFIX, adviceProperties);
+			else if (current.startsWith(PROVIDES_PREFIX))
+				parseProvides(PROVIDES_PREFIX, adviceProvides);
+			else if (current.startsWith(REQUIRES_PREFIX))
+				parseRequires(REQUIRES_PREFIX, adviceRequires);
+			else if (current.startsWith(INSTRUCTIONS_PREFIX))
+				parseInstructions(INSTRUCTIONS_PREFIX, adviceInstructions);
+			else if (current.startsWith(UNITS_PREFIX))
+				parseUnits(UNITS_PREFIX, adviceOtherIUs);
 			else {
 				// we ignore elements we do not understand
 				next();
 			}
-
 		}
 	}
 
@@ -87,7 +111,7 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex == -1)
-				throw new IllegalStateException("bad token: " + current);
+				throw new IllegalStateException("bad token: " + current); //$NON-NLS-1$
 
 			parseProvided(current.substring(0, dotIndex + 1), provides);
 		}
@@ -99,11 +123,11 @@ public class AdviceFileParser {
 		Version capabilityVersion = null;
 		while (current != null && current.startsWith(prefix)) {
 			String token = current.substring(prefix.length());
-			if (token.equals("name")) {
+			if (token.equals(NAME)) {
 				name = currentValue();
-			} else if (token.equals("namespace")) {
+			} else if (token.equals(NAMESPACE)) {
 				namespace = currentValue();
-			} else if (token.equals("version")) {
+			} else if (token.equals(VERSION)) {
 				capabilityVersion = new Version(substituteVersionAndQualifier(currentValue()));
 			} else {
 				// we ignore elements we do not understand
@@ -119,7 +143,7 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex == -1)
-				throw new IllegalStateException("bad token: " + current);
+				throw new IllegalStateException("bad token: " + current); //$NON-NLS-1$
 
 			parseRequired(current.substring(0, dotIndex + 1), requires);
 		}
@@ -137,19 +161,19 @@ public class AdviceFileParser {
 
 		while (current != null && current.startsWith(prefix)) {
 			String token = current.substring(prefix.length());
-			if (token.equals("greedy")) {
+			if (token.equals(GREEDY)) {
 				greedy = Boolean.valueOf(currentValue()).booleanValue();
-			} else if (token.equals("optional")) {
+			} else if (token.equals(OPTIONAL)) {
 				optional = Boolean.valueOf(currentValue()).booleanValue();
-			} else if (token.equals("multiple")) {
+			} else if (token.equals(MULTIPLE)) {
 				multiple = Boolean.valueOf(currentValue()).booleanValue();
-			} else if (token.equals("filter")) {
+			} else if (token.equals(FILTER)) {
 				filter = currentValue();
-			} else if (token.equals("name")) {
+			} else if (token.equals(NAME)) {
 				name = currentValue();
-			} else if (token.equals("namespace")) {
+			} else if (token.equals(NAMESPACE)) {
 				namespace = currentValue();
-			} else if (token.equals("range")) {
+			} else if (token.equals(RANGE)) {
 				range = new VersionRange(substituteVersionAndQualifier(currentValue()));
 			} else {
 				// we ignore elements we do not understand
@@ -164,7 +188,7 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex != -1)
-				throw new IllegalStateException("bad token: " + current);
+				throw new IllegalStateException("bad token: " + current); //$NON-NLS-1$
 
 			parseInstruction(current, instructions);
 		}
@@ -175,10 +199,10 @@ public class AdviceFileParser {
 		String body = currentValue();
 		next();
 
-		prefix += ".";
+		prefix += '.';
 		String importAttribute = null;
 		if (current != null && current.startsWith(prefix)) {
-			if (current.substring(prefix.length()).equals("import")) {
+			if (current.substring(prefix.length()).equals(IMPORT)) {
 				importAttribute = currentValue();
 			} else {
 				// we ignore elements we do not understand
@@ -193,7 +217,7 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex == -1)
-				throw new IllegalStateException("bad token: " + current + " = " + currentValue());
+				throw new IllegalStateException("bad token: " + current + " = " + currentValue()); //$NON-NLS-1$ //$NON-NLS-2$
 
 			parseUnit(current.substring(0, dotIndex + 1), ius);
 		}
@@ -220,41 +244,41 @@ public class AdviceFileParser {
 
 		while (current != null && current.startsWith(prefix)) {
 			String token = current.substring(prefix.length());
-			if (token.equals("id")) {
+			if (token.equals(ID)) {
 				unitId = currentValue();
 				next();
-			} else if (token.equals("version")) {
+			} else if (token.equals(VERSION)) {
 				unitVersion = new Version(substituteVersionAndQualifier(currentValue()));
 				next();
-			} else if (token.equals("filter")) {
+			} else if (token.equals(FILTER)) {
 				unitFilter = currentValue();
 				next();
-			} else if (token.equals("copyright")) {
+			} else if (token.equals(COPYRIGHT)) {
 				unitCopyright = currentValue();
 				next();
-			} else if (token.equals("copyright.location")) {
+			} else if (token.equals(COPYRIGHT_LOCATION)) {
 				unitCopyrightLocation = currentValue();
 				next();
-			} else if (token.equals("touchpoint.id")) {
+			} else if (token.equals(TOUCHPOINT_ID)) {
 				unitTouchpointId = currentValue();
 				next();
-			} else if (token.equals("touchpoinit.version")) {
+			} else if (token.equals(TOUCHPOINIT_VERSION)) {
 				unitTouchpointVersion = new Version(substituteVersionAndQualifier(currentValue()));
 				next();
-			} else if (token.startsWith("hostRequirements."))
-				parseHostRequirements(prefix + "hostRequirements.", unitHostRequirements);
-			else if (token.startsWith("artifacts."))
-				parseArtifacts(prefix + "artifacts.", unitArtifacts);
-			else if (token.startsWith("licenses."))
-				parseLicenses(prefix + "licenses.", unitLicenses);
-			else if (token.startsWith("properties."))
-				parseProperties(prefix + "properties.", unitProperties);
-			else if (token.startsWith("provides."))
-				parseProvides(prefix + "provides.", unitProvides);
-			else if (token.startsWith("requires."))
-				parseRequires(prefix + "requires.", unitRequires);
-			else if (token.startsWith("instructions."))
-				parseInstructions(prefix + "instructions.", unitInstructions);
+			} else if (token.startsWith(HOST_REQUIREMENTS_PREFIX))
+				parseHostRequirements(prefix + HOST_REQUIREMENTS_PREFIX, unitHostRequirements);
+			else if (token.startsWith(ARTIFACTS_PREFIX))
+				parseArtifacts(prefix + ARTIFACTS_PREFIX, unitArtifacts);
+			else if (token.startsWith(LICENSES_PREFIX))
+				parseLicenses(prefix + LICENSES_PREFIX, unitLicenses);
+			else if (token.startsWith(PROPERTIES_PREFIX))
+				parseProperties(prefix + PROPERTIES_PREFIX, unitProperties);
+			else if (token.startsWith(PROVIDES_PREFIX))
+				parseProvides(prefix + PROVIDES_PREFIX, unitProvides);
+			else if (token.startsWith(REQUIRES_PREFIX))
+				parseRequires(prefix + REQUIRES_PREFIX, unitRequires);
+			else if (token.startsWith(INSTRUCTIONS_PREFIX))
+				parseInstructions(prefix + INSTRUCTIONS_PREFIX, unitInstructions);
 			else {
 				// we ignore elements we do not understand
 				next();
@@ -270,7 +294,7 @@ public class AdviceFileParser {
 			try {
 				description.setCopyright(MetadataFactory.createCopyright(new URI(unitCopyrightLocation), unitCopyright));
 			} catch (URISyntaxException e) {
-				throw new IllegalStateException("bad copyright URI at token: " + current + ", " + currentValue());
+				throw new IllegalStateException("bad copyright URI at token: " + current + ", " + currentValue()); //$NON-NLS-1$ //$NON-NLS-2$
 			}
 		}
 		if (unitTouchpointId != null)
@@ -307,7 +331,7 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex == -1)
-				throw new IllegalStateException("bad token: " + current + " = " + currentValue());
+				throw new IllegalStateException("bad token: " + current + " = " + currentValue()); //$NON-NLS-1$ //$NON-NLS-2$
 
 			parseLicense(current.substring(0, dotIndex + 1), licenses);
 		}
@@ -317,10 +341,10 @@ public class AdviceFileParser {
 		String body = currentValue();
 		next();
 
-		prefix += ".";
+		prefix += '.';
 		String location = null;
 		if (current != null && current.startsWith(prefix)) {
-			if (current.substring(prefix.length()).equals("import")) {
+			if (current.substring(prefix.length()).equals(IMPORT)) {
 				location = currentValue();
 			} else {
 				// we ignore elements we do not understand
@@ -332,7 +356,7 @@ public class AdviceFileParser {
 			ILicense license = MetadataFactory.createLicense(new URI(location), body);
 			licenses.add(license);
 		} catch (URISyntaxException e) {
-			throw new IllegalStateException("bad license URI at token: " + current + ", " + currentValue());
+			throw new IllegalStateException("bad license URI at token: " + current + ", " + currentValue()); //$NON-NLS-1$ //$NON-NLS-2$
 		}
 	}
 
@@ -340,7 +364,7 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex == -1)
-				throw new IllegalStateException("bad token: " + current + " = " + currentValue());
+				throw new IllegalStateException("bad token: " + current + " = " + currentValue()); //$NON-NLS-1$ //$NON-NLS-2$
 
 			parseArtifact(current.substring(0, dotIndex + 1), artifacts);
 		}
@@ -352,11 +376,11 @@ public class AdviceFileParser {
 		Version artifactVersion = null;
 		while (current != null && current.startsWith(prefix)) {
 			String token = current.substring(prefix.length());
-			if (token.equals("classifier")) {
+			if (token.equals(CLASSIFIER)) {
 				artifactClassifier = currentValue();
-			} else if (token.equals("id")) {
+			} else if (token.equals(ID)) {
 				artifactId = currentValue();
-			} else if (token.equals("version")) {
+			} else if (token.equals(VERSION)) {
 				artifactVersion = new Version(substituteVersionAndQualifier(currentValue()));
 			} else {
 				// we ignore elements we do not understand
@@ -372,27 +396,27 @@ public class AdviceFileParser {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
 			if (dotIndex == -1)
-				throw new IllegalStateException("bad token: " + current + " = " + currentValue());
+				throw new IllegalStateException("bad token: " + current + " = " + currentValue()); //$NON-NLS-1$ //$NON-NLS-2$
 
 			parseRequired(current.substring(0, dotIndex + 1), hostRequirements);
 		}
 	}
 
 	private String substituteVersionAndQualifier(String version) {
-		if (version.indexOf("$version$") != -1) {
-			version = replace(version, "$version$", hostVersion.toString());
+		if (version.indexOf(VERSION_SUBSTITUTION) != -1) {
+			version = replace(version, VERSION_SUBSTITUTION, hostVersion.toString());
 		}
 
-		if (version.indexOf("$qualifier$") != -1) {
+		if (version.indexOf(QUALIFIER_SUBSTITUTION) != -1) {
 			String qualifier = hostVersion.getQualifier();
 			if (qualifier == null)
-				qualifier = "";
+				qualifier = ""; //$NON-NLS-1$
 			if (qualifier.length() == 0) {
 				// Note: this works only for OSGi versions and version ranges
 				// where the qualifier if present must be at the end of a version string
-				version = replace(version, ".$qualifier$", "");
+				version = replace(version, "." + QUALIFIER_SUBSTITUTION, ""); //$NON-NLS-1$ //$NON-NLS-2$
 			}
-			version = replace(version, "$qualifier$", qualifier);
+			version = replace(version, QUALIFIER_SUBSTITUTION, qualifier);
 		}
 		return version;
 	}
commit 91d98246d9bf43dd5c7eeb1590b2090d73782da0
Author: Simon Kaegi <skaegi>
Date:   Thu Feb 26 02:25:37 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf
    adding update descriptor support

31	3	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
index aed3eb9..aa38d1e 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
@@ -23,10 +23,12 @@ public class AdviceFileParser {
 
 	private static final String QUALIFIER_SUBSTITUTION = "$qualifier$"; //$NON-NLS-1$
 	private static final String VERSION_SUBSTITUTION = "$version$"; //$NON-NLS-1$
+
+	private static final String UPDATE_DESCRIPTION = "update.description"; //$NON-NLS-1$
+	private static final String UPDATE_SEVERITY = "update.severity"; //$NON-NLS-1$
+	private static final String UPDATE_RANGE = "update.range"; //$NON-NLS-1$
+	private static final String UPDATE_ID = "update.id"; //$NON-NLS-1$
 	private static final String CLASSIFIER = "classifier"; //$NON-NLS-1$
-	private static final String LICENSES_PREFIX = "licenses."; //$NON-NLS-1$
-	private static final String ARTIFACTS_PREFIX = "artifacts."; //$NON-NLS-1$
-	private static final String HOST_REQUIREMENTS_PREFIX = "hostRequirements."; //$NON-NLS-1$
 	private static final String TOUCHPOINIT_VERSION = "touchpoinit.version"; //$NON-NLS-1$
 	private static final String TOUCHPOINT_ID = "touchpoint.id"; //$NON-NLS-1$
 	private static final String COPYRIGHT_LOCATION = "copyright.location"; //$NON-NLS-1$
@@ -41,11 +43,16 @@ public class AdviceFileParser {
 	private static final String VERSION = "version"; //$NON-NLS-1$
 	private static final String NAMESPACE = "namespace"; //$NON-NLS-1$
 	private static final String NAME = "name"; //$NON-NLS-1$
+
 	private static final String UNITS_PREFIX = "units."; //$NON-NLS-1$
 	private static final String INSTRUCTIONS_PREFIX = "instructions."; //$NON-NLS-1$
 	private static final String REQUIRES_PREFIX = "requires."; //$NON-NLS-1$
 	private static final String PROVIDES_PREFIX = "provides."; //$NON-NLS-1$
 	private static final String PROPERTIES_PREFIX = "properties."; //$NON-NLS-1$
+	private static final String LICENSES_PREFIX = "licenses."; //$NON-NLS-1$
+	private static final String ARTIFACTS_PREFIX = "artifacts."; //$NON-NLS-1$
+	private static final String HOST_REQUIREMENTS_PREFIX = "hostRequirements."; //$NON-NLS-1$
+
 	private Properties adviceProperties = new Properties();
 	private List adviceProvides = new ArrayList();
 	private List adviceRequires = new ArrayList();
@@ -233,6 +240,11 @@ public class AdviceFileParser {
 		String unitTouchpointId = null;
 		Version unitTouchpointVersion = null;
 
+		String updateId = null;
+		VersionRange updateRange = null;
+		int updateSeverity = 0;
+		String updateDescription = null;
+
 		List unitArtifacts = new ArrayList();
 		Properties unitProperties = new Properties();
 		List unitHostRequirements = new ArrayList();
@@ -265,6 +277,18 @@ public class AdviceFileParser {
 			} else if (token.equals(TOUCHPOINIT_VERSION)) {
 				unitTouchpointVersion = new Version(substituteVersionAndQualifier(currentValue()));
 				next();
+			} else if (token.equals(UPDATE_ID)) {
+				updateId = currentValue();
+				next();
+			} else if (token.equals(UPDATE_RANGE)) {
+				updateRange = new VersionRange(substituteVersionAndQualifier(currentValue()));
+				next();
+			} else if (token.equals(UPDATE_SEVERITY)) {
+				updateSeverity = Integer.parseInt(currentValue());
+				next();
+			} else if (token.equals(UPDATE_DESCRIPTION)) {
+				updateDescription = currentValue();
+				next();
 			} else if (token.startsWith(HOST_REQUIREMENTS_PREFIX))
 				parseHostRequirements(prefix + HOST_REQUIREMENTS_PREFIX, unitHostRequirements);
 			else if (token.startsWith(ARTIFACTS_PREFIX))
@@ -299,6 +323,10 @@ public class AdviceFileParser {
 		}
 		if (unitTouchpointId != null)
 			description.setTouchpointType(MetadataFactory.createTouchpointType(unitTouchpointId, unitTouchpointVersion));
+
+		if (updateId != null)
+			description.setUpdateDescriptor(MetadataFactory.createUpdateDescriptor(updateId, updateRange, updateSeverity, updateDescription));
+
 		if (!unitLicenses.isEmpty())
 			description.setLicense((ILicense) unitLicenses.get(0));
 
commit b7ea7245aecdc282482f40942624eeac0c5b9556
Author: Simon Kaegi <skaegi>
Date:   Thu Feb 26 04:31:40 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf
    final tests and fixes

3	3	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
25	18	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
160	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index 0c137e5..00785a2 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -41,7 +41,7 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 	private IProvidedCapability[] providedCapabilities;
 	private IRequiredCapability[] requiredCapabilities;
 	private Properties iuProperties;
-	private InstallableUnitDescription[] otherIUs;
+	private InstallableUnitDescription[] additionalIUs;
 	private boolean containsAdvice = false;
 
 	/**
@@ -81,7 +81,7 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 		providedCapabilities = parser.getProvidedCapabilities();
 		requiredCapabilities = parser.getRequiredCapabilities();
 		iuProperties = parser.getProperties();
-		otherIUs = parser.getOtherInstallableUnitDescriptions();
+		additionalIUs = parser.getAdditionalInstallableUnitDescriptions();
 		containsAdvice = true;
 	}
 
@@ -187,7 +187,7 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 	}
 
 	public InstallableUnitDescription[] getAdditionalInstallableUnitDescriptions(IInstallableUnit iu) {
-		return otherIUs;
+		return additionalIUs;
 	}
 
 	public Properties getArtifactProperties(IInstallableUnit iu, IArtifactDescriptor descriptor) {
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
index aa38d1e..e7a3a61 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
@@ -29,11 +29,12 @@ public class AdviceFileParser {
 	private static final String UPDATE_RANGE = "update.range"; //$NON-NLS-1$
 	private static final String UPDATE_ID = "update.id"; //$NON-NLS-1$
 	private static final String CLASSIFIER = "classifier"; //$NON-NLS-1$
-	private static final String TOUCHPOINIT_VERSION = "touchpoinit.version"; //$NON-NLS-1$
+	private static final String TOUCHPOINT_VERSION = "touchpoint.version"; //$NON-NLS-1$
 	private static final String TOUCHPOINT_ID = "touchpoint.id"; //$NON-NLS-1$
 	private static final String COPYRIGHT_LOCATION = "copyright.location"; //$NON-NLS-1$
 	private static final String COPYRIGHT = "copyright"; //$NON-NLS-1$
 	private static final String ID = "id"; //$NON-NLS-1$
+	private static final String SINGLETON = "singleton"; //$NON-NLS-1$
 	private static final String IMPORT = "import"; //$NON-NLS-1$
 	private static final String RANGE = "range"; //$NON-NLS-1$
 	private static final String FILTER = "filter"; //$NON-NLS-1$
@@ -43,6 +44,7 @@ public class AdviceFileParser {
 	private static final String VERSION = "version"; //$NON-NLS-1$
 	private static final String NAMESPACE = "namespace"; //$NON-NLS-1$
 	private static final String NAME = "name"; //$NON-NLS-1$
+	private static final String LOCATION = "location"; //$NON-NLS-1$
 
 	private static final String UNITS_PREFIX = "units."; //$NON-NLS-1$
 	private static final String INSTRUCTIONS_PREFIX = "instructions."; //$NON-NLS-1$
@@ -240,10 +242,10 @@ public class AdviceFileParser {
 		String unitTouchpointId = null;
 		Version unitTouchpointVersion = null;
 
-		String updateId = null;
-		VersionRange updateRange = null;
-		int updateSeverity = 0;
-		String updateDescription = null;
+		String unitUpdateId = null;
+		VersionRange unitUpdateRange = null;
+		int unitUpdateSeverity = 0;
+		String unitUpdateDescription = null;
 
 		List unitArtifacts = new ArrayList();
 		Properties unitProperties = new Properties();
@@ -262,6 +264,9 @@ public class AdviceFileParser {
 			} else if (token.equals(VERSION)) {
 				unitVersion = new Version(substituteVersionAndQualifier(currentValue()));
 				next();
+			} else if (token.equals(SINGLETON)) {
+				unitSingleton = Boolean.valueOf(currentValue()).booleanValue();
+				next();
 			} else if (token.equals(FILTER)) {
 				unitFilter = currentValue();
 				next();
@@ -274,20 +279,20 @@ public class AdviceFileParser {
 			} else if (token.equals(TOUCHPOINT_ID)) {
 				unitTouchpointId = currentValue();
 				next();
-			} else if (token.equals(TOUCHPOINIT_VERSION)) {
+			} else if (token.equals(TOUCHPOINT_VERSION)) {
 				unitTouchpointVersion = new Version(substituteVersionAndQualifier(currentValue()));
 				next();
 			} else if (token.equals(UPDATE_ID)) {
-				updateId = currentValue();
+				unitUpdateId = currentValue();
 				next();
 			} else if (token.equals(UPDATE_RANGE)) {
-				updateRange = new VersionRange(substituteVersionAndQualifier(currentValue()));
+				unitUpdateRange = new VersionRange(substituteVersionAndQualifier(currentValue()));
 				next();
 			} else if (token.equals(UPDATE_SEVERITY)) {
-				updateSeverity = Integer.parseInt(currentValue());
+				unitUpdateSeverity = Integer.parseInt(currentValue());
 				next();
 			} else if (token.equals(UPDATE_DESCRIPTION)) {
-				updateDescription = currentValue();
+				unitUpdateDescription = currentValue();
 				next();
 			} else if (token.startsWith(HOST_REQUIREMENTS_PREFIX))
 				parseHostRequirements(prefix + HOST_REQUIREMENTS_PREFIX, unitHostRequirements);
@@ -316,7 +321,8 @@ public class AdviceFileParser {
 		description.setFilter(unitFilter);
 		if (unitCopyright != null || unitCopyrightLocation != null) {
 			try {
-				description.setCopyright(MetadataFactory.createCopyright(new URI(unitCopyrightLocation), unitCopyright));
+				URI uri = unitCopyrightLocation != null ? new URI(unitCopyrightLocation) : null;
+				description.setCopyright(MetadataFactory.createCopyright(uri, unitCopyright));
 			} catch (URISyntaxException e) {
 				throw new IllegalStateException("bad copyright URI at token: " + current + ", " + currentValue()); //$NON-NLS-1$ //$NON-NLS-2$
 			}
@@ -324,8 +330,8 @@ public class AdviceFileParser {
 		if (unitTouchpointId != null)
 			description.setTouchpointType(MetadataFactory.createTouchpointType(unitTouchpointId, unitTouchpointVersion));
 
-		if (updateId != null)
-			description.setUpdateDescriptor(MetadataFactory.createUpdateDescriptor(updateId, updateRange, updateSeverity, updateDescription));
+		if (unitUpdateId != null)
+			description.setUpdateDescriptor(MetadataFactory.createUpdateDescriptor(unitUpdateId, unitUpdateRange, unitUpdateSeverity, unitUpdateDescription));
 
 		if (!unitLicenses.isEmpty())
 			description.setLicense((ILicense) unitLicenses.get(0));
@@ -358,10 +364,10 @@ public class AdviceFileParser {
 	private void parseLicenses(String prefix, List licenses) {
 		while (current != null && current.startsWith(prefix)) {
 			int dotIndex = current.indexOf('.', prefix.length());
-			if (dotIndex == -1)
+			if (dotIndex != -1)
 				throw new IllegalStateException("bad token: " + current + " = " + currentValue()); //$NON-NLS-1$ //$NON-NLS-2$
 
-			parseLicense(current.substring(0, dotIndex + 1), licenses);
+			parseLicense(current, licenses);
 		}
 	}
 
@@ -372,7 +378,7 @@ public class AdviceFileParser {
 		prefix += '.';
 		String location = null;
 		if (current != null && current.startsWith(prefix)) {
-			if (current.substring(prefix.length()).equals(IMPORT)) {
+			if (current.substring(prefix.length()).equals(LOCATION)) {
 				location = currentValue();
 			} else {
 				// we ignore elements we do not understand
@@ -381,7 +387,8 @@ public class AdviceFileParser {
 		}
 
 		try {
-			ILicense license = MetadataFactory.createLicense(new URI(location), body);
+			URI uri = location != null ? new URI(location) : null;
+			ILicense license = MetadataFactory.createLicense(uri, body);
 			licenses.add(license);
 		} catch (URISyntaxException e) {
 			throw new IllegalStateException("bad license URI at token: " + current + ", " + currentValue()); //$NON-NLS-1$ //$NON-NLS-2$
@@ -496,7 +503,7 @@ public class AdviceFileParser {
 		return adviceInstructions;
 	}
 
-	public InstallableUnitDescription[] getOtherInstallableUnitDescriptions() {
+	public InstallableUnitDescription[] getAdditionalInstallableUnitDescriptions() {
 		if (adviceOtherIUs.isEmpty())
 			return null;
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
index 6cb2ab8..1f5b984 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
@@ -15,12 +15,18 @@ import junit.framework.TestCase;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.publisher.eclipse.AdviceFileParser;
 
 public class AdviceFileParserTest extends TestCase {
 	public void testNoAdvice() {
 		AdviceFileParser parser = new AdviceFileParser("id", Version.MIN_VERSION, Collections.EMPTY_MAP);
 		parser.parse();
+		assertNull(parser.getAdditionalInstallableUnitDescriptions());
+		assertNull(parser.getProperties());
+		assertNull(parser.getProvidedCapabilities());
+		assertNull(parser.getRequiredCapabilities());
+		assertNull(parser.getTouchpointInstructions());
 	}
 
 	public void testPropertyAdvice() {
@@ -125,4 +131,158 @@ public class AdviceFileParserTest extends TestCase {
 		assertEquals("removeProgramArg(programArg:-startup); removeProgramArg(programArg:@artifact);)", unconfigure.getBody());
 	}
 
+	public void testAdditionalInstallableUnitDescriptionsAdvice() {
+		Map map = new HashMap();
+		map.put("units.0.id", "testid0");
+		map.put("units.0.version", "1.2.3");
+
+		map.put("units.1.id", "testid1");
+		map.put("units.1.version", "1.2.4");
+		map.put("units.1.singleton", "true");
+		map.put("units.1.copyright", "testCopyright");
+		map.put("units.1.copyright.location", "http://localhost/test");
+		map.put("units.1.filter", "test=testFilter");
+		map.put("units.1.touchpoint.id", "testTouchpointId");
+		map.put("units.1.touchpoint.version", "1.2.5");
+		map.put("units.1.update.id", "testid1");
+		map.put("units.1.update.range", "(1,2)");
+		map.put("units.1.update.severity", "2");
+		map.put("units.1.update.description", "some description");
+		map.put("units.1.artifacts.0.id", "testArtifact1");
+		map.put("units.1.artifacts.0.version", "1.2.6");
+		map.put("units.1.artifacts.0.classifier", "testClassifier1");
+		map.put("units.1.artifacts.1.id", "testArtifact2");
+		map.put("units.1.artifacts.1.version", "1.2.7");
+		map.put("units.1.artifacts.1.classifier", "testClassifier2");
+		map.put("units.1.licenses.0", "testLicense");
+		map.put("units.1.licenses.0.location", "http://localhost/license");
+		map.put("units.1.properties.testName1", "testValue1");
+		map.put("units.1.properties.testName2", "testValue2");
+		map.put("units.1.requires.0.namespace", "testNamespace1");
+		map.put("units.1.requires.0.name", "testName1");
+		map.put("units.1.requires.0.range", "[1.2.3.$qualifier$, 2)");
+		map.put("units.1.requires.0.greedy", Boolean.TRUE.toString());
+		map.put("units.1.requires.0.optional", Boolean.TRUE.toString());
+		map.put("units.1.requires.0.multiple", Boolean.TRUE.toString());
+		map.put("units.1.requires.1.namespace", "testNamespace2");
+		map.put("units.1.requires.1.name", "testName2");
+		map.put("units.1.requires.1.range", "$version$");
+		map.put("units.1.requires.1.greedy", Boolean.FALSE.toString());
+		map.put("units.1.requires.1.optional", Boolean.FALSE.toString());
+		map.put("units.1.provides.0.namespace", "testNamespace1");
+		map.put("units.1.provides.0.name", "testName1");
+		map.put("units.1.provides.0.version", "1.2.3.$qualifier$");
+		map.put("units.1.provides.1.namespace", "testNamespace2");
+		map.put("units.1.provides.1.name", "testName2");
+		map.put("units.1.provides.1.version", "$version$");
+		map.put("units.1.instructions.configure", "addProgramArg(programArg:-startup); addProgramArg(programArg:@artifact);");
+		map.put("units.1.instructions.unconfigure", "removeProgramArg(programArg:-startup); removeProgramArg(programArg:@artifact);)");
+		map.put("units.1.instructions.unconfigure.import", "some.removeProgramArg");
+
+		map.put("units.1.hostRequirements.0.namespace", "testNamespace1");
+		map.put("units.1.hostRequirements.0.name", "testName1");
+		map.put("units.1.hostRequirements.0.range", "[1.2.3.$qualifier$, 2)");
+		map.put("units.1.hostRequirements.0.greedy", Boolean.TRUE.toString());
+		map.put("units.1.hostRequirements.0.optional", Boolean.TRUE.toString());
+		map.put("units.1.hostRequirements.0.multiple", Boolean.TRUE.toString());
+		map.put("units.1.hostRequirements.1.namespace", "testNamespace2");
+		map.put("units.1.hostRequirements.1.name", "testName2");
+		map.put("units.1.hostRequirements.1.range", "$version$");
+		map.put("units.1.hostRequirements.1.greedy", Boolean.FALSE.toString());
+		map.put("units.1.hostRequirements.1.optional", Boolean.FALSE.toString());
+
+		AdviceFileParser parser = new AdviceFileParser("id", Version.MIN_VERSION, map);
+		parser.parse();
+		InstallableUnitDescription[] descriptions = parser.getAdditionalInstallableUnitDescriptions();
+		IInstallableUnit iu0 = MetadataFactory.createInstallableUnit(descriptions[0]);
+		assertEquals("testid0", iu0.getId());
+		assertEquals(new Version("1.2.3"), iu0.getVersion());
+		assertFalse(iu0.isSingleton());
+		assertFalse(iu0.isFragment());
+		assertEquals(0, iu0.getArtifacts().length);
+		assertEquals(null, iu0.getCopyright());
+		assertEquals(null, iu0.getFilter());
+		assertEquals(null, iu0.getLicense());
+		assertEquals(0, iu0.getProperties().size());
+		assertEquals(0, iu0.getRequiredCapabilities().length);
+		assertEquals(0, iu0.getProvidedCapabilities().length);
+		assertEquals(0, iu0.getTouchpointData().length);
+		assertEquals(ITouchpointType.NONE, iu0.getTouchpointType());
+		assertEquals(null, iu0.getUpdateDescriptor());
+
+		IInstallableUnit iu1 = MetadataFactory.createInstallableUnit(descriptions[1]);
+		assertEquals("testid1", iu1.getId());
+		assertEquals(new Version("1.2.4"), iu1.getVersion());
+		assertTrue(iu1.isSingleton());
+		assertEquals(2, iu1.getArtifacts().length);
+		assertEquals("testArtifact1", iu1.getArtifacts()[0].getId());
+		assertEquals(new Version("1.2.6"), iu1.getArtifacts()[0].getVersion());
+		assertEquals("testClassifier1", iu1.getArtifacts()[0].getClassifier());
+		assertEquals("testArtifact2", iu1.getArtifacts()[1].getId());
+		assertEquals(new Version("1.2.7"), iu1.getArtifacts()[1].getVersion());
+		assertEquals("testClassifier2", iu1.getArtifacts()[1].getClassifier());
+		assertEquals("testCopyright", iu1.getCopyright().getBody());
+		assertEquals("http://localhost/test", iu1.getCopyright().getLocation().toString());
+		assertEquals("test=testFilter", iu1.getFilter());
+		assertEquals("testLicense", iu1.getLicense().getBody());
+		assertEquals("http://localhost/license", iu1.getLicense().getLocation().toString());
+		assertEquals("testValue1", iu1.getProperty("testName1"));
+		assertEquals("testValue2", iu1.getProperty("testName2"));
+
+		IRequiredCapability[] required = iu1.getRequiredCapabilities();
+		assertEquals(2, required.length);
+		assertEquals("testNamespace1", required[0].getNamespace());
+		assertEquals("testName1", required[0].getName());
+		assertEquals(new VersionRange("[1.2.3, 2)"), required[0].getRange());
+		assertEquals(true, required[0].isGreedy());
+		assertEquals(true, required[0].isOptional());
+		assertEquals(true, required[0].isMultiple());
+		assertEquals("testNamespace2", required[1].getNamespace());
+		assertEquals("testName2", required[1].getName());
+		assertEquals(new VersionRange(Version.MIN_VERSION.toString()), required[1].getRange());
+		assertEquals(false, required[1].isGreedy());
+		assertEquals(false, required[1].isOptional());
+		assertEquals(false, required[1].isMultiple());
+
+		IProvidedCapability[] provided = iu1.getProvidedCapabilities();
+		assertEquals(2, provided.length);
+		assertEquals("testNamespace1", provided[0].getNamespace());
+		assertEquals("testName1", provided[0].getName());
+		assertEquals(new Version("1.2.3"), provided[0].getVersion());
+		assertEquals("testNamespace2", provided[1].getNamespace());
+		assertEquals("testName2", provided[1].getName());
+		assertEquals(Version.MIN_VERSION, provided[1].getVersion());
+
+		assertEquals(1, iu1.getTouchpointData().length);
+		ITouchpointInstruction configure = iu1.getTouchpointData()[0].getInstruction("configure");
+		assertEquals(null, configure.getImportAttribute());
+		assertEquals("addProgramArg(programArg:-startup); addProgramArg(programArg:@artifact);", configure.getBody());
+
+		ITouchpointInstruction unconfigure = iu1.getTouchpointData()[0].getInstruction("unconfigure");
+		assertEquals("some.removeProgramArg", unconfigure.getImportAttribute());
+		assertEquals("removeProgramArg(programArg:-startup); removeProgramArg(programArg:@artifact);)", unconfigure.getBody());
+
+		assertEquals(MetadataFactory.createTouchpointType("testTouchpointId", new Version("1.2.5")), iu1.getTouchpointType());
+		assertEquals("testid1", iu1.getUpdateDescriptor().getId());
+		assertEquals(new VersionRange("(1,2)"), iu1.getUpdateDescriptor().getRange());
+		assertEquals(2, iu1.getUpdateDescriptor().getSeverity());
+		assertEquals("some description", iu1.getUpdateDescriptor().getDescription());
+
+		assertTrue(iu1.isFragment());
+		IRequiredCapability[] hostRequired = ((IInstallableUnitFragment) iu1).getHost();
+		assertEquals(2, hostRequired.length);
+		assertEquals("testNamespace1", hostRequired[0].getNamespace());
+		assertEquals("testName1", hostRequired[0].getName());
+		assertEquals(new VersionRange("[1.2.3, 2)"), hostRequired[0].getRange());
+		assertEquals(true, hostRequired[0].isGreedy());
+		assertEquals(true, hostRequired[0].isOptional());
+		assertEquals(true, hostRequired[0].isMultiple());
+		assertEquals("testNamespace2", hostRequired[1].getNamespace());
+		assertEquals("testName2", hostRequired[1].getName());
+		assertEquals(new VersionRange(Version.MIN_VERSION.toString()), hostRequired[1].getRange());
+		assertEquals(false, hostRequired[1].isGreedy());
+		assertEquals(false, hostRequired[1].isOptional());
+		assertEquals(false, hostRequired[1].isMultiple());
+	}
+
 }
commit cae46cb7ff05a531b637739fa303e5248fa633c4
Author: Simon Kaegi <skaegi>
Date:   Thu Feb 26 18:46:32 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf
     have to check for existence of p2.inf file

2	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index 00785a2..0980e60 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -102,6 +102,8 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 		try {
 			if (location.isDirectory()) {
 				File adviceFile = new File(location, adviceFilePath.toString());
+				if (!adviceFile.isFile())
+					return Collections.EMPTY_MAP;
 				stream = new BufferedInputStream(new FileInputStream(adviceFile));
 			} else if (location.isFile()) {
 				jar = new ZipFile(location);
commit 85c73aa2a4cb4460ce30f40dfc8a198c57b7936c
Author: Simon Kaegi <skaegi>
Date:   Fri Feb 27 21:45:20 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf
    properties now uses properties.0.name and properties.0.value

23	4	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
8	4	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
index e7a3a61..5915ab2 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileParser.java
@@ -45,6 +45,7 @@ public class AdviceFileParser {
 	private static final String NAMESPACE = "namespace"; //$NON-NLS-1$
 	private static final String NAME = "name"; //$NON-NLS-1$
 	private static final String LOCATION = "location"; //$NON-NLS-1$
+	private static final String VALUE = "value"; //$NON-NLS-1$
 
 	private static final String UNITS_PREFIX = "units."; //$NON-NLS-1$
 	private static final String INSTRUCTIONS_PREFIX = "instructions."; //$NON-NLS-1$
@@ -108,12 +109,30 @@ public class AdviceFileParser {
 
 	private void parseProperties(String prefix, Map properties) {
 		while (current != null && current.startsWith(prefix)) {
-			String propertyName = current.substring(prefix.length());
-			if (propertyName.indexOf('.') != -1)
-				throw new IllegalStateException();
-			properties.put(propertyName, currentValue());
+			int dotIndex = current.indexOf('.', prefix.length());
+			if (dotIndex == -1)
+				throw new IllegalStateException("bad token: " + current); //$NON-NLS-1$
+
+			parseProperty(current.substring(0, dotIndex + 1), properties);
+		}
+	}
+
+	private void parseProperty(String prefix, Map properties) {
+		String propertyName = null;
+		String propertyValue = null;
+		while (current != null && current.startsWith(prefix)) {
+			String token = current.substring(prefix.length());
+			if (token.equals(NAME)) {
+				propertyName = currentValue();
+			} else if (token.equals(VALUE)) {
+				propertyValue = currentValue();
+			} else {
+				// we ignore elements we do not understand
+			}
 			next();
 		}
+
+		properties.put(propertyName, propertyValue);
 	}
 
 	private void parseProvides(String prefix, List provides) {
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
index 1f5b984..21a25b4 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/AdviceFileParserTest.java
@@ -31,8 +31,10 @@ public class AdviceFileParserTest extends TestCase {
 
 	public void testPropertyAdvice() {
 		Map map = new HashMap();
-		map.put("properties.testName1", "testValue1");
-		map.put("properties.testName2", "testValue2");
+		map.put("properties.0.name", "testName1");
+		map.put("properties.0.value", "testValue1");
+		map.put("properties.1.name", "testName2");
+		map.put("properties.1.value", "testValue2");
 
 		AdviceFileParser parser = new AdviceFileParser("id", Version.MIN_VERSION, map);
 		parser.parse();
@@ -156,8 +158,10 @@ public class AdviceFileParserTest extends TestCase {
 		map.put("units.1.artifacts.1.classifier", "testClassifier2");
 		map.put("units.1.licenses.0", "testLicense");
 		map.put("units.1.licenses.0.location", "http://localhost/license");
-		map.put("units.1.properties.testName1", "testValue1");
-		map.put("units.1.properties.testName2", "testValue2");
+		map.put("units.1.properties.0.name", "testName1");
+		map.put("units.1.properties.0.value", "testValue1");
+		map.put("units.1.properties.1.name", "testName2");
+		map.put("units.1.properties.1.value", "testValue2");
 		map.put("units.1.requires.0.namespace", "testNamespace1");
 		map.put("units.1.requires.0.name", "testName1");
 		map.put("units.1.requires.0.range", "[1.2.3.$qualifier$, 2)");
commit 04ad6939ca6c62f10c5c8796183ee7f2bc98e9e4
Author: Simon Kaegi <skaegi>
Date:   Mon Mar 2 19:48:21 2009 +0000

    Bug 265217 [publisher] Improved IU advice support with p2.inf
    on a parse error we want to provide no advice

1	0	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
index 0980e60..31a51ad 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/eclipse/AdviceFileAdvice.java
@@ -76,6 +76,7 @@ public class AdviceFileAdvice extends AbstractAdvice implements ITouchpointAdvic
 			String message = "An error occured while parsing advice file: basePath=" + basePath + ", adviceFilePath=" + adviceFilePath + "."; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
 			IStatus status = new Status(IStatus.ERROR, Activator.ID, message, e);
 			LogHelper.log(status);
+			return;
 		}
 		touchpointInstructions = parser.getTouchpointInstructions();
 		providedCapabilities = parser.getProvidedCapabilities();
