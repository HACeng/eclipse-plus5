commit 70c366fd4d0475ed1fd826cbf2283f8ed3b3ebec
Author: Todor Boev <rinsvind@gmail.com>
Date:   Tue Jun 6 13:43:16 2017 +0300

    Bug 313553 - [publisher] publish metadata for Provide-Capability and Require-Capability
    
    Generalize to include attributes.
    
    Change-Id: I1135b89842185ed0e3197bfbcf4625a0f4f73510
    Signed-off-by: Todor Boev <rinsvind@gmail.com>

75	25	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
12	3	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
11	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
12	8	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
index 8a324a2..be7aea6 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2011 IBM Corporation and others.
+ * Copyright (c) 2007, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,9 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.metadata;
 
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
 import org.eclipse.core.runtime.Assert;
 import org.eclipse.equinox.p2.metadata.IProvidedCapability;
 import org.eclipse.equinox.p2.metadata.Version;
@@ -26,33 +29,71 @@ public class ProvidedCapability implements IProvidedCapability, IMemberProvider
 	public static final String MEMBER_VERSION = "version"; //$NON-NLS-1$
 	public static final String MEMBER_NAMESPACE = "namespace"; //$NON-NLS-1$
 
-	private final String name;
 	private final String namespace;
-	private final Version version;
+	private final Map<String, Object> attributes;
+
+	public ProvidedCapability(String namespace, Map<String, Object> attrs) {
+		Assert.isNotNull(namespace, NLS.bind(Messages.provided_capability_namespace_not_defined, null));
+		this.namespace = namespace;
+
+		Assert.isNotNull(attrs);
+		Assert.isTrue(!attrs.isEmpty());
+		Assert.isTrue(!attrs.containsKey(MEMBER_NAMESPACE));
+		this.attributes = new HashMap<>(attrs);
+
+		if (!attributes.containsKey(MEMBER_NAME)) {
+			// It is common for a capability to have a main attribute under a key
+			// with value the same as the capability namespace. Use as "name" if present.
+			Assert.isTrue(attributes.containsKey(namespace));
+			attributes.put(MEMBER_NAME, attributes.get(namespace));
+		}
+
+		Object version = attributes.get(MEMBER_VERSION);
+		if (version == null) {
+			attributes.put(MEMBER_VERSION, Version.emptyVersion);
+		} else if (version instanceof org.osgi.framework.Version) {
+			org.osgi.framework.Version osgiVer = (org.osgi.framework.Version) version;
+			attributes.put(
+					MEMBER_VERSION,
+					Version.createOSGi(osgiVer.getMajor(), osgiVer.getMinor(), osgiVer.getMicro(), osgiVer.getQualifier()));
+		} else {
+			Assert.isTrue(version instanceof Version);
+		}
+	}
 
 	public ProvidedCapability(String namespace, String name, Version version) {
 		Assert.isNotNull(namespace, NLS.bind(Messages.provided_capability_namespace_not_defined, null));
 		Assert.isNotNull(name, NLS.bind(Messages.provided_capability_name_not_defined, namespace));
 		this.namespace = namespace;
-		this.name = name;
-		this.version = version == null ? Version.emptyVersion : version;
+		this.attributes = new HashMap<>();
+		attributes.put(MEMBER_NAME, name);
+		attributes.put(MEMBER_VERSION, version == null ? Version.emptyVersion : version);
 	}
 
 	public boolean equals(Object other) {
-		if (other == null)
+		if (other == null) {
 			return false;
-		if (!(other instanceof IProvidedCapability))
+		}
+
+		if (!(other instanceof IProvidedCapability)) {
 			return false;
+		}
+
 		IProvidedCapability otherCapability = (IProvidedCapability) other;
-		if (!(namespace.equals(otherCapability.getNamespace())))
+
+		if (!(namespace.equals(otherCapability.getNamespace()))) {
 			return false;
-		if (!(name.equals(otherCapability.getName())))
+		}
+
+		if (!(attributes.equals(otherCapability.getAttributes()))) {
 			return false;
-		return version.equals(otherCapability.getVersion());
+		}
+
+		return true;
 	}
 
 	public String getName() {
-		return name;
+		return (String) attributes.get(MEMBER_NAME);
 	}
 
 	public String getNamespace() {
@@ -60,28 +101,37 @@ public class ProvidedCapability implements IProvidedCapability, IMemberProvider
 	}
 
 	public Version getVersion() {
-		return version;
+		return (Version) attributes.get(MEMBER_VERSION);
+	}
+
+	public Map<String, Object> getAttributes() {
+		return attributes;
 	}
 
 	public int hashCode() {
-		return namespace.hashCode() * name.hashCode() * version.hashCode();
+		return namespace.hashCode() * attributes.hashCode();
 	}
 
 	public String toString() {
-		return namespace + '/' + name + '/' + version;
+		StringBuilder str = new StringBuilder();
+		str.append(namespace);
+
+		for (Entry<String, Object> attr : attributes.entrySet()) {
+			String key = attr.getKey();
+			Object val = attr.getValue();
+			String type = val.getClass().getSimpleName();
+
+			str.append("; ").append(key).append(":").append(type).append("=").append(val); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+		}
+
+		return str.toString();
 	}
 
 	public Object getMember(String memberName) {
-		// It is OK to use identity comparisons here since
-		// a) All constant valued strings are always interned
-		// b) The Member constructor always interns the name
-		//
-		if (MEMBER_NAME == memberName)
-			return name;
-		if (MEMBER_VERSION == memberName)
-			return version;
-		if (MEMBER_NAMESPACE == memberName)
-			return namespace;
-		throw new IllegalArgumentException("No such member: " + memberName); //$NON-NLS-1$
+		Object res = memberName.equals(MEMBER_NAMESPACE) ? namespace : attributes.get(memberName);
+		if (res == null) {
+			throw new IllegalArgumentException("No such member: " + memberName); //$NON-NLS-1$
+		}
+		return res;
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
index 7848c2d..e895d5b 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
@@ -10,6 +10,8 @@
 ******************************************************************************/
 package org.eclipse.equinox.p2.metadata;
 
+import java.util.Map;
+
 /**
  * Describes a capability that is exposed by an installable unit. These capabilities
  * can satisfy the dependencies of other installable units, causing the unit
@@ -29,26 +31,33 @@ public interface IProvidedCapability {
 
 	/**
 	 * 
-	 * @return String
+	 * @return String the special "name" attribute of this capability.
 	 * @noreference This method is not intended to be referenced by clients.
 	 */
 	public String getName();
 
 	/**
 	 * 
-	 * @return String
+	 * @return String the namespace of this capability.
 	 * @noreference This method is not intended to be referenced by clients.
 	 */
 	public String getNamespace();
 
 	/**
 	 * 
-	 * @return String
+	 * @return String the special "version" attribute of this capability.
 	 * @noreference This method is not intended to be referenced by clients.
 	 */
 	public Version getVersion();
 
 	/**
+	 * 
+	 * @return A full description of this capability
+	 * @noreference This method is not intended to be referenced by clients.
+	 */
+	public Map<String, Object> getAttributes();
+
+	/**
 	 * Returns whether this provided capability is equal to the given object.
 	 * 
 	 * This method returns <i>true</i> if:
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
index 4cbaffb..061fd11 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
@@ -430,6 +430,17 @@ public final class MetadataFactory {
 	}
 
 	/**
+	 * Returns a {@link IProvidedCapability} with the given values.
+	 * 
+	 * @param namespace The capability namespace
+	 * @param attributes The description of the capability
+	 * @since 2.4
+	 */
+	public static IProvidedCapability createProvidedCapability(String namespace, Map<String, Object> attributes) {
+		return new ProvidedCapability(namespace, attributes);
+	}
+
+	/**
 	 * Returns a {@link IRequirement} with the given values.
 	 * 
 	 * @param namespace The capability namespace
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
index f715a45..e743c47 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
@@ -177,14 +177,15 @@ public class SPIMetadataRepositoryTest extends AbstractProvisioningTest {
 
 	class SPIProvidedCapability implements IProvidedCapability {
 
-		String namespace = null;
-		String name = null;
-		Version version = null;
+		String namespace;
+		Map<String, Object> attributes;
 
 		public SPIProvidedCapability(String namespace, String name, Version version) {
 			this.namespace = namespace;
-			this.name = name;
-			this.version = version;
+
+			this.attributes = new HashMap<String, Object>();
+			attributes.put(ProvidedCapability.MEMBER_NAME, name);
+			attributes.put(ProvidedCapability.MEMBER_VERSION, version);
 		}
 
 		@Override
@@ -196,14 +197,14 @@ public class SPIMetadataRepositoryTest extends AbstractProvisioningTest {
 			IProvidedCapability otherCapability = (IProvidedCapability) other;
 			if (!(namespace.equals(otherCapability.getNamespace())))
 				return false;
-			if (!(name.equals(otherCapability.getName())))
+			if (!(attributes.equals(otherCapability.getAttributes())))
 				return false;
 			return true;
 		}
 
 		@Override
 		public String getName() {
-			return this.name;
+			return (String) attributes.get(ProvidedCapability.MEMBER_NAME);
 		}
 
 		@Override
@@ -213,13 +214,16 @@ public class SPIMetadataRepositoryTest extends AbstractProvisioningTest {
 
 		@Override
 		public Version getVersion() {
-			return this.version;
+			return (Version) attributes.get(ProvidedCapability.MEMBER_VERSION);
 		}
 
 		public boolean satisfies(IRequirement candidate) {
 			return false;
 		}
 
+		public Map<String, Object> getAttributes() {
+			return attributes;
+		}
 	}
 
 	class SPIInstallableUnit implements IInstallableUnit {
commit 02e018c88f5307fc754ae8bc0c0467eb209dd982
Author: Todor Boev <rinsvind@gmail.com>
Date:   Tue Jun 6 13:35:51 2017 +0300

    Bug 313553 - Prepare BundlesAction
    
    Change-Id: I783ce240d5e79d0bc90e3982bef206ef11c80be1
    Signed-off-by: Todor Boev <rinsvind@gmail.com>

112	81	bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java b/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
index 3c3db9e..9e73a8d 100644
--- a/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
@@ -151,9 +151,12 @@ public class BundlesAction extends AbstractPublisherAction {
 	protected IInstallableUnit doCreateBundleIU(BundleDescription bd, IArtifactKey key, IPublisherInfo info) {
 		@SuppressWarnings("unchecked")
 		Map<String, String> manifest = (Map<String, String>) bd.getUserObject();
+
 		Map<Locale, Map<String, String>> manifestLocalizations = null;
-		if (manifest != null && bd.getLocation() != null)
+		if (manifest != null && bd.getLocation() != null) {
 			manifestLocalizations = getManifestLocalizations(manifest, new File(bd.getLocation()));
+		}
+
 		InstallableUnitDescription iu = new MetadataFactory.InstallableUnitDescription();
 		iu.setSingleton(bd.isSingleton());
 		iu.setId(bd.getSymbolicName());
@@ -163,52 +166,56 @@ public class BundlesAction extends AbstractPublisherAction {
 		iu.setArtifacts(new IArtifactKey[] {key});
 		iu.setTouchpointType(PublisherHelper.TOUCHPOINT_OSGI);
 
-		boolean isFragment = bd.getHost() != null;
-		//		boolean requiresAFragment = isFragment ? false : requireAFragment(bd, manifest);
+		boolean isFragment = (bd.getHost() != null);
 
-		// Process the required bundles
-		BundleSpecification requiredBundles[] = bd.getRequiredBundles();
-		ArrayList<IRequirement> reqsDeps = new ArrayList<>();
-		//		if (requiresAFragment)
-		//			reqsDeps.add(MetadataFactory.createRequiredCapability(CAPABILITY_TYPE_OSGI_FRAGMENTS, bd.getSymbolicName(), VersionRange.emptyRange, null, false, false));
-		if (isFragment)
-			reqsDeps.add(MetadataFactory.createRequirement(CAPABILITY_NS_OSGI_BUNDLE, bd.getHost().getName(), PublisherHelper.fromOSGiVersionRange(bd.getHost().getVersionRange()), null, false, false));
+		// Gather requirements here
+		List<IRequirement> requirements = new ArrayList<>();
 
+		// Process required fragment host
+		if (isFragment) {
+			requirements.add(MetadataFactory.createRequirement(CAPABILITY_NS_OSGI_BUNDLE, bd.getHost().getName(), PublisherHelper.fromOSGiVersionRange(bd.getHost().getVersionRange()), null, false, false));
+		}
+
+		// Process required bundles
 		ManifestElement[] rawRequireBundleHeader = parseManifestHeader(Constants.REQUIRE_BUNDLE, manifest, bd.getLocation());
-		for (BundleSpecification requiredBundle : requiredBundles) {
-			addRequireBundleRequirement(reqsDeps, requiredBundle, rawRequireBundleHeader);
+		for (BundleSpecification requiredBundle : bd.getRequiredBundles()) {
+			addRequireBundleRequirement(requirements, requiredBundle, rawRequireBundleHeader);
 		}
 
 		// Process the import packages
 		ManifestElement[] rawImportPackageHeader = parseManifestHeader(Constants.IMPORT_PACKAGE, manifest, bd.getLocation());
-		ImportPackageSpecification osgiImports[] = bd.getImportPackages();
-		for (int i = 0; i < osgiImports.length; i++) {
-			// TODO we need to sort out how we want to handle wild-carded dynamic imports - for now we ignore them
-			ImportPackageSpecification importSpec = osgiImports[i];
-			if (isDynamicImport(importSpec))
-				continue;
-			addImportPackageRequirement(reqsDeps, importSpec, rawImportPackageHeader);
+		for (ImportPackageSpecification importedPackage : bd.getImportPackages()) {
+			if (!isDynamicImport(importedPackage)) {
+				addImportPackageRequirement(requirements, importedPackage, rawImportPackageHeader);
+			}
 		}
-		iu.setRequirements(reqsDeps.toArray(new IRequirement[reqsDeps.size()]));
+
+		iu.setRequirements(requirements.toArray(new IRequirement[requirements.size()]));
 
 		// Create set of provided capabilities
-		ArrayList<IProvidedCapability> providedCapabilities = new ArrayList<>();
+		List<IProvidedCapability> providedCapabilities = new ArrayList<>();
+
+		// Add identification capabilities
 		providedCapabilities.add(PublisherHelper.createSelfCapability(bd.getSymbolicName(), PublisherHelper.fromOSGiVersion(bd.getVersion())));
 		providedCapabilities.add(MetadataFactory.createProvidedCapability(CAPABILITY_NS_OSGI_BUNDLE, bd.getSymbolicName(), PublisherHelper.fromOSGiVersion(bd.getVersion())));
 
-		// Process the export package
-		ExportPackageDescription exports[] = bd.getExportPackages();
-		for (int i = 0; i < exports.length; i++) {
-			//TODO make sure that we support all the refinement on the exports
-			providedCapabilities.add(MetadataFactory.createProvidedCapability(PublisherHelper.CAPABILITY_NS_JAVA_PACKAGE, exports[i].getName(), PublisherHelper.fromOSGiVersion(exports[i].getVersion())));
+		// Process exported packages
+		ExportPackageDescription[] exportedPackages = bd.getExportPackages();
+		for (ExportPackageDescription packageExport : exportedPackages) {
+			providedCapabilities.add(MetadataFactory.createProvidedCapability(PublisherHelper.CAPABILITY_NS_JAVA_PACKAGE, packageExport.getName(), PublisherHelper.fromOSGiVersion(packageExport.getVersion())));
 		}
-		// Here we add a bundle capability to identify bundles
-		if (manifest != null && manifest.containsKey("Eclipse-SourceBundle")) //$NON-NLS-1$
+
+		// Add capability to describe the type of bundle
+		if (manifest != null && manifest.containsKey("Eclipse-SourceBundle")) { //$NON-NLS-1$
 			providedCapabilities.add(SOURCE_BUNDLE_CAPABILITY);
-		else
+		} else {
 			providedCapabilities.add(BUNDLE_CAPABILITY);
-		if (isFragment)
+		}
+
+		// If needed add an additional capability to identify this as an OSGi fragment
+		if (isFragment) {
 			providedCapabilities.add(MetadataFactory.createProvidedCapability(CAPABILITY_NS_OSGI_FRAGMENT, bd.getHost().getName(), PublisherHelper.fromOSGiVersion(bd.getVersion())));
+		}
 
 		if (manifestLocalizations != null) {
 			for (Entry<Locale, Map<String, String>> locEntry : manifestLocalizations.entrySet()) {
@@ -220,7 +227,10 @@ public class BundlesAction extends AbstractPublisherAction {
 				providedCapabilities.add(PublisherHelper.makeTranslationCapability(bd.getSymbolicName(), locale));
 			}
 		}
+
 		iu.setCapabilities(providedCapabilities.toArray(new IProvidedCapability[providedCapabilities.size()]));
+
+		// Process advice
 		processUpdateDescriptorAdvice(iu, info);
 		processCapabilityAdvice(iu, info);
 
@@ -245,15 +255,18 @@ public class BundlesAction extends AbstractPublisherAction {
 		// that this is something that will not impact the configuration.
 		Map<String, String> touchpointData = new HashMap<>();
 		touchpointData.put("manifest", toManifestString(manifest)); //$NON-NLS-1$
-		if (isDir(bd, info))
+		if (isDir(bd, info)) {
 			touchpointData.put("zipped", "true"); //$NON-NLS-1$ //$NON-NLS-2$
-		processTouchpointAdvice(iu, touchpointData, info);
+		}
 
+		// Process more advice
+		processTouchpointAdvice(iu, touchpointData, info);
 		processInstallableUnitPropertiesAdvice(iu, info);
+
 		return MetadataFactory.createInstallableUnit(iu);
 	}
 
-	protected void addImportPackageRequirement(ArrayList<IRequirement> reqsDeps, ImportPackageSpecification importSpec, ManifestElement[] rawImportPackageHeader) {
+	protected void addImportPackageRequirement(List<IRequirement> reqsDeps, ImportPackageSpecification importSpec, ManifestElement[] rawImportPackageHeader) {
 		VersionRange versionRange = PublisherHelper.fromOSGiVersionRange(importSpec.getVersionRange());
 		final boolean optional = isOptional(importSpec);
 		final boolean greedy;
@@ -265,7 +278,7 @@ public class BundlesAction extends AbstractPublisherAction {
 		reqsDeps.add(MetadataFactory.createRequirement(PublisherHelper.CAPABILITY_NS_JAVA_PACKAGE, importSpec.getName(), versionRange, null, optional ? 0 : 1, 1, greedy));
 	}
 
-	protected void addRequireBundleRequirement(ArrayList<IRequirement> reqsDeps, BundleSpecification requiredBundle, ManifestElement[] rawRequireBundleHeader) {
+	protected void addRequireBundleRequirement(List<IRequirement> reqsDeps, BundleSpecification requiredBundle, ManifestElement[] rawRequireBundleHeader) {
 		final boolean optional = requiredBundle.isOptional();
 		final boolean greedy;
 		if (optional)
@@ -739,69 +752,87 @@ public class BundlesAction extends AbstractPublisherAction {
 		}
 	}
 
-	//TODO remove this method
+	/**
+	 * Publishes bundle IUs to the p2 metadata and artifact repositories. 
+	 * 
+	 * @param bundleDescriptions Equinox framework descriptions of the bundles to publish. 
+	 * @param result Used to attach status for the publication operation.
+	 * @param monitor Used to fire progress events.
+	 * 
+	 * @deprecated Use {@link #generateBundleIUs(BundleDescription[] bundleDescriptions, IPublisherInfo info, IPublisherResult result, IProgressMonitor monitor)} with
+	 * {@link IPublisherInfo} set to <code>null</code>
+	 */
+	@Deprecated
 	protected void generateBundleIUs(BundleDescription[] bundleDescriptions, IPublisherResult result, IProgressMonitor monitor) {
 		generateBundleIUs(bundleDescriptions, null, result, monitor);
 	}
 
+	/**
+	 * Publishes bundle IUs to the p2 metadata and artifact repositories. 
+	 * 
+	 * @param bundleDescriptions Equinox framework descriptions of the bundles to publish. 
+	 * @param info Configuration and publication advice information.
+	 * @param result Used to attach status for the publication operation.
+	 * @param monitor Used to fire progress events.
+	 */
 	protected void generateBundleIUs(BundleDescription[] bundleDescriptions, IPublisherInfo info, IPublisherResult result, IProgressMonitor monitor) {
-
 		// This assumes that hosts are processed before fragments because for each fragment the host
 		// is queried for the strings that should be translated.
-		for (int i = 0; i < bundleDescriptions.length; i++) {
-			if (monitor.isCanceled())
+		for (BundleDescription bd : bundleDescriptions) {
+			if (monitor.isCanceled()) {
 				throw new OperationCanceledException();
+			}
 
-			BundleDescription bd = bundleDescriptions[i];
-			if (bd != null && bd.getSymbolicName() != null && bd.getVersion() != null) {
-				//First check to see if there is already an IU around for this
-				IInstallableUnit bundleIU = queryForIU(result, bundleDescriptions[i].getSymbolicName(), PublisherHelper.fromOSGiVersion(bd.getVersion()));
-				IArtifactKey key = createBundleArtifactKey(bd.getSymbolicName(), bd.getVersion().toString());
-				if (bundleIU == null) {
-					createAdviceFileAdvice(bundleDescriptions[i], info);
-					// Create the bundle IU according to any shape advice we have
-					bundleIU = doCreateBundleIU(bd, key, info);
-				}
+			if (bd == null || bd.getSymbolicName() == null || bd.getVersion() == null) {
+				continue;
+			}
 
-				File location = new File(bd.getLocation());
-				IArtifactDescriptor ad = PublisherHelper.createArtifactDescriptor(info, key, location);
-				processArtifactPropertiesAdvice(bundleIU, ad, info);
+			//First check to see if there is already an IU around for this
+			IInstallableUnit bundleIU = queryForIU(result, bd.getSymbolicName(), PublisherHelper.fromOSGiVersion(bd.getVersion()));
+			IArtifactKey bundleArtKey = createBundleArtifactKey(bd.getSymbolicName(), bd.getVersion().toString());
+			if (bundleIU == null) {
+				createAdviceFileAdvice(bd, info);
+				// Create the bundle IU according to any shape advice we have
+				bundleIU = doCreateBundleIU(bd, bundleArtKey, info);
+			}
 
-				// Publish according to the shape on disk
-				File bundleLocation = new File(bd.getLocation());
-				if (bundleLocation.isDirectory())
-					publishArtifact(ad, bundleLocation, bundleLocation.listFiles(), info);
-				else
-					publishArtifact(ad, bundleLocation, info);
-
-				IInstallableUnit fragment = null;
-				if (isFragment(bd)) {
-					// TODO: Need a test case for multiple hosts
-					String hostId = bd.getHost().getName();
-					VersionRange hostVersionRange = PublisherHelper.fromOSGiVersionRange(bd.getHost().getVersionRange());
-					IQueryResult<IInstallableUnit> hosts = queryForIUs(result, hostId, hostVersionRange);
-
-					for (Iterator<IInstallableUnit> itor = hosts.iterator(); itor.hasNext();) {
-						IInstallableUnit host = itor.next();
-						String fragmentId = makeHostLocalizationFragmentId(bd.getSymbolicName());
-						fragment = queryForIU(result, fragmentId, PublisherHelper.fromOSGiVersion(bd.getVersion()));
-						if (fragment == null) {
-							String[] externalizedStrings = getExternalizedStrings(host);
-							fragment = createHostLocalizationFragment(bundleIU, bd, hostId, externalizedStrings);
-						}
-					}
+			File bundleLocation = new File(bd.getLocation());
+			IArtifactDescriptor ad = PublisherHelper.createArtifactDescriptor(info, bundleArtKey, bundleLocation);
+			processArtifactPropertiesAdvice(bundleIU, ad, info);
 
-				}
+			// Publish according to the shape on disk
+			if (bundleLocation.isDirectory()) {
+				publishArtifact(ad, bundleLocation, bundleLocation.listFiles(), info);
+			} else {
+				publishArtifact(ad, bundleLocation, info);
+			}
+
+			IInstallableUnit fragment = null;
+			if (isFragment(bd)) {
+				String hostId = bd.getHost().getName();
+				VersionRange hostVersionRange = PublisherHelper.fromOSGiVersionRange(bd.getHost().getVersionRange());
 
-				result.addIU(bundleIU, IPublisherResult.ROOT);
-				if (fragment != null)
-					result.addIU(fragment, IPublisherResult.NON_ROOT);
+				IQueryResult<IInstallableUnit> hosts = queryForIUs(result, hostId, hostVersionRange);
 
-				InstallableUnitDescription[] others = processAdditionalInstallableUnitsAdvice(bundleIU, info);
-				for (int iuIndex = 0; others != null && iuIndex < others.length; iuIndex++) {
-					result.addIU(MetadataFactory.createInstallableUnit(others[iuIndex]), IPublisherResult.ROOT);
+				for (IInstallableUnit host : hosts) {
+					String fragmentId = makeHostLocalizationFragmentId(bd.getSymbolicName());
+					fragment = queryForIU(result, fragmentId, PublisherHelper.fromOSGiVersion(bd.getVersion()));
+					if (fragment == null) {
+						String[] externalizedStrings = getExternalizedStrings(host);
+						fragment = createHostLocalizationFragment(bundleIU, bd, hostId, externalizedStrings);
+					}
 				}
 			}
+
+			result.addIU(bundleIU, IPublisherResult.ROOT);
+			if (fragment != null) {
+				result.addIU(fragment, IPublisherResult.NON_ROOT);
+			}
+
+			InstallableUnitDescription[] others = processAdditionalInstallableUnitsAdvice(bundleIU, info);
+			for (int iuIndex = 0; others != null && iuIndex < others.length; iuIndex++) {
+				result.addIU(MetadataFactory.createInstallableUnit(others[iuIndex]), IPublisherResult.ROOT);
+			}
 		}
 	}
 
commit d2c97e4e8f866fd8233c5ed67a99907b34e00ab4
Author: Todor Boev <rinsvind@gmail.com>
Date:   Tue Sep 5 17:05:19 2017 +0300

    Bug 313553 - Retrofit the JRE IU with generic osgi.ee capabilities
    
    The osgi.ee capabilities can now match both old-style and generic
    requirements.
    
    Change-Id: Id39103123ff2f1ce9d33a353b92e918f706dfa34
    Signed-off-by: Todor Boev <rinsvind@gmail.com>

7	3	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
14	8	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/JREActionTest.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
index 2a9ef43..868d31c 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
@@ -192,7 +192,7 @@ public class JREAction extends AbstractPublisherAction {
 			for (int namespaceIx = 0; namespaceIx < namespaces.length; namespaceIx++) {
 				String namespace = namespaces[namespaceIx];
 
-				if ("osgi.ee".equals(namespace)) { // this is the OSGi capability namespace "osgi.ee"  //$NON-NLS-1$
+				if (NAMESPACE_OSGI_EE.equals(namespace)) { // this is the OSGi capability namespace "osgi.ee"
 					parseEECapability(systemCapability, parsingStatus, parsingResult);
 
 				} else {
@@ -204,7 +204,7 @@ public class JREAction extends AbstractPublisherAction {
 	}
 
 	private static void parseEECapability(ManifestElement eeCapability, MultiStatus parsingStatus, List<IProvidedCapability> parsingResult) {
-		String eeName = eeCapability.getAttribute("osgi.ee"); // this is an attribute required for capabilities in the "osgi.ee" namespace //$NON-NLS-1$
+		String eeName = eeCapability.getAttribute(NAMESPACE_OSGI_EE); // this is an attribute required for capabilities in the "osgi.ee" namespace
 		if (eeName == null) {
 			parsingStatus.add(newErrorStatus(NLS.bind(Messages.message_eeMissingNameAttribute, eeCapability), null));
 			return;
@@ -222,7 +222,11 @@ public class JREAction extends AbstractPublisherAction {
 				Version parsedVersion = Version.parseVersion(rawVersion);
 
 				// complete record -> store
-				parsingResult.add(MetadataFactory.createProvidedCapability(NAMESPACE_OSGI_EE, eeName, parsedVersion));
+				Map<String, Object> capAttrs = new HashMap<String, Object>();
+				capAttrs.put(NAMESPACE_OSGI_EE, eeName);
+				capAttrs.put("version", parsedVersion);
+
+				parsingResult.add(MetadataFactory.createProvidedCapability(NAMESPACE_OSGI_EE, capAttrs));
 
 			} catch (IllegalArgumentException e) {
 				parsingStatus.add(newErrorStatus(NLS.bind(Messages.message_eeInvalidVersionAttribute, rawVersion), e));
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/JREActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/JREActionTest.java
index 32d05e2..6310a02 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/JREActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/JREActionTest.java
@@ -23,7 +23,6 @@ import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.NullProgressMonitor;
 import org.eclipse.equinox.internal.p2.core.helpers.FileUtils;
 import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
-import org.eclipse.equinox.internal.p2.metadata.ProvidedCapability;
 import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.publisher.IPublisherInfo;
 import org.eclipse.equinox.p2.publisher.IPublisherResult;
@@ -130,11 +129,11 @@ public class JREActionTest extends ActionTest {
 		performAction(new JREAction("J2SE-1.5"));
 
 		Collection<IProvidedCapability> capabilities = getPublishedCapabilitiesOf("a.jre.j2se");
-		assertThat(capabilities, not(hasItem((IProvidedCapability) new ProvidedCapability("osgi.ee", "JavaSE", Version.parseVersion("1.6")))));
-		assertThat(capabilities, hasItem((IProvidedCapability) new ProvidedCapability("osgi.ee", "JavaSE", Version.parseVersion("1.5"))));
-		assertThat(capabilities, hasItem((IProvidedCapability) new ProvidedCapability("osgi.ee", "OSGi/Minimum", Version.parseVersion("1.0"))));
+		assertThat(capabilities, not(hasItem(createEECapability("JavaSE", "1.6"))));
+		assertThat(capabilities, hasItem(createEECapability("JavaSE", "1.5")));
+		assertThat(capabilities, hasItem(createEECapability("OSGi/Minimum", "1.0")));
 
-		assertThat(capabilities, not(hasItem((IProvidedCapability) new ProvidedCapability("osgi.ee", "J2SE", Version.parseVersion("1.5")))));
+		assertThat(capabilities, not(hasItem(createEECapability("J2SE", "1.5"))));
 	}
 
 	public void testSingleOsgiEECapability() {
@@ -142,8 +141,8 @@ public class JREActionTest extends ActionTest {
 		performAction(new JREAction("OSGi/Minimum-1.0"));
 
 		Collection<IProvidedCapability> capabilities = getPublishedCapabilitiesOf("a.jre.osgi.minimum");
-		assertThat(capabilities, not(hasItem((IProvidedCapability) new ProvidedCapability("osgi.ee", "JavaSE", Version.parseVersion("1.5")))));
-		assertThat(capabilities, hasItem((IProvidedCapability) new ProvidedCapability("osgi.ee", "OSGi/Minimum", Version.parseVersion("1.0"))));
+		assertThat(capabilities, not(hasItem(createEECapability("JavaSE", "1.5"))));
+		assertThat(capabilities, hasItem(createEECapability("OSGi/Minimum", "1.0")));
 	}
 
 	public void testInvalidOsgiEECapabilitySpec() {
@@ -226,10 +225,17 @@ public class JREActionTest extends ActionTest {
 		return iu.getProvidedCapabilities();
 	}
 
+	private static IProvidedCapability createEECapability(String ee, String version) {
+		Map<String, Object> attrs = new HashMap<>();
+		attrs.put("osgi.ee", ee);
+		attrs.put("version", Version.parseVersion(version));
+
+		return MetadataFactory.createProvidedCapability("osgi.ee", attrs);
+	}
+
 	@Override
 	protected void insertPublisherInfoBehavior() {
 		expect(publisherInfo.getArtifactRepository()).andReturn(artifactRepository).anyTimes();
 		expect(publisherInfo.getArtifactOptions()).andReturn(IPublisherInfo.A_PUBLISH).anyTimes();
 	}
-
 }
commit 780d9bedcc73cf2daf808b1a16d68565daba871a
Author: Todor Boev <rinsvind@gmail.com>
Date:   Mon Jun 5 19:23:31 2017 +0300

    Bug 313553 - Requirement: fix comparisons to match OSGi LDAP spec.
    
    The non-constant argument can be a collection in which case the
    comparison operation must iterate through it testing each element.
    
    Change-Id: I4105bc9b746c4e5767ecc77f80c93a1cbc82d65e
    Signed-off-by: Todor Boev <rinsvind@gmail.com>

25	1	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/Compare.java
18	4	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/Equals.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/Compare.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/Compare.java
index 7e958e4..5ee16f7 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/Compare.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/Compare.java
@@ -10,6 +10,7 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.metadata.expression;
 
+import java.util.Collection;
 import org.eclipse.equinox.p2.metadata.expression.IEvaluationContext;
 
 /**
@@ -31,7 +32,30 @@ final class Compare extends Binary {
 	}
 
 	public Object evaluate(IEvaluationContext context) {
-		int cmpResult = CoercingComparator.coerceAndCompare(lhs.evaluate(context), rhs.evaluate(context));
+		Object lhsVal = lhs.evaluate(context);
+		Object rhsVal = rhs.evaluate(context);
+
+		// Handle collections as per the OSGi LDAP spec
+		if (lhsVal instanceof Collection<?>) {
+			for (Object lhsItem : (Collection<?>) lhsVal) {
+				int cmpResult = CoercingComparator.coerceAndCompare(lhsItem, rhsVal);
+
+				if (cmpResult == 0) {
+					return equalOK;
+				}
+
+				if (cmpResult < 0 && compareLess) {
+					return true;
+				}
+
+				if (!compareLess) {
+					return true;
+				}
+			}
+			return false;
+		}
+
+		int cmpResult = CoercingComparator.coerceAndCompare(lhsVal, rhsVal);
 		return Boolean.valueOf(cmpResult == 0 ? equalOK : (cmpResult < 0 ? compareLess : !compareLess));
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/Equals.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/Equals.java
index c318776..4992d79 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/Equals.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/Equals.java
@@ -10,6 +10,7 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.metadata.expression;
 
+import java.util.Collection;
 import org.eclipse.equinox.p2.metadata.expression.IEvaluationContext;
 
 /**
@@ -24,10 +25,23 @@ final class Equals extends Binary {
 	}
 
 	public Object evaluate(IEvaluationContext context) {
-		boolean result = CoercingComparator.coerceAndEquals(lhs.evaluate(context), rhs.evaluate(context));
-		if (negate)
-			result = !result;
-		return Boolean.valueOf(result);
+		Object lhsVal = lhs.evaluate(context);
+		Object rhsVal = rhs.evaluate(context);
+
+		// Handle collections as per the OSGi LDAP spec
+		if (lhsVal instanceof Collection<?>) {
+			for (Object lhsItem : (Collection<?>) lhsVal) {
+				boolean eq = CoercingComparator.coerceAndEquals(lhsItem, rhsVal);
+
+				if (eq && !negate) {
+					return true;
+				}
+			}
+			return negate;
+		}
+
+		boolean eq = CoercingComparator.coerceAndEquals(lhsVal, rhsVal);
+		return negate ? !eq : eq;
 	}
 
 	public int getExpressionType() {
commit 6c0135edf1bd792bf107d96a5fa53681dd1ce6f1
Author: Alexander Kurtakov <akurtako@redhat.com>
Date:   Wed Sep 6 14:50:38 2017 +0300

    Bug 313553 - [publisher] publish metadata for Provide-Capability and
    Require-Capability
    
    Remove redundant type declarations introduced with previous patches.
    
    Change-Id: Ia3a8826ee3dc93a66eb0ed445c374091b68c354a
    Signed-off-by: Alexander Kurtakov <akurtako@redhat.com>

3	3	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
2	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
index 868d31c..baacf2e 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
@@ -222,9 +222,9 @@ public class JREAction extends AbstractPublisherAction {
 				Version parsedVersion = Version.parseVersion(rawVersion);
 
 				// complete record -> store
-				Map<String, Object> capAttrs = new HashMap<String, Object>();
+				Map<String, Object> capAttrs = new HashMap<>();
 				capAttrs.put(NAMESPACE_OSGI_EE, eeName);
-				capAttrs.put("version", parsedVersion);
+				capAttrs.put("version", parsedVersion); //$NON-NLS-1$
 
 				parsingResult.add(MetadataFactory.createProvidedCapability(NAMESPACE_OSGI_EE, capAttrs));
 
@@ -305,7 +305,7 @@ public class JREAction extends AbstractPublisherAction {
 
 			if (jreLocation.isDirectory()) {
 				//Look for a JRE profile file to set version and capabilities
-				File[] profiles = jreLocation.listFiles((FileFilter) pathname -> pathname.getAbsolutePath().endsWith(".profile"));
+				File[] profiles = jreLocation.listFiles((FileFilter) pathname -> pathname.getAbsolutePath().endsWith(".profile")); //$NON-NLS-1$
 				if (profiles != null && profiles.length > 0) {
 					javaProfile = profiles[0];
 				}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
index e743c47..37f8355 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
@@ -183,7 +183,7 @@ public class SPIMetadataRepositoryTest extends AbstractProvisioningTest {
 		public SPIProvidedCapability(String namespace, String name, Version version) {
 			this.namespace = namespace;
 
-			this.attributes = new HashMap<String, Object>();
+			this.attributes = new HashMap<>();
 			attributes.put(ProvidedCapability.MEMBER_NAME, name);
 			attributes.put(ProvidedCapability.MEMBER_VERSION, version);
 		}
@@ -221,6 +221,7 @@ public class SPIMetadataRepositoryTest extends AbstractProvisioningTest {
 			return false;
 		}
 
+		@Override
 		public Map<String, Object> getAttributes() {
 			return attributes;
 		}
commit 8e6983eab7b45fbe90282303641fe76d2d3b4971
Author: Todor Boev <rinsvind@gmail.com>
Date:   Tue Jun 6 13:31:59 2017 +0300

    Bug 313553 - Capability: provide attributes to LDAP matches
    
    Change-Id: Ie062404257d9781664ca3d45517645516ce43067
    Signed-off-by: Todor Boev <rinsvind@gmail.com>

10	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/MemberProvider.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/MemberProvider.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/MemberProvider.java
index dccb003..4eaa481 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/MemberProvider.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/MemberProvider.java
@@ -12,6 +12,8 @@ package org.eclipse.equinox.internal.p2.metadata.expression;
 
 import java.util.*;
 import java.util.Map.Entry;
+import org.eclipse.equinox.internal.p2.metadata.ProvidedCapability;
+import org.eclipse.equinox.p2.metadata.IProvidedCapability;
 import org.eclipse.equinox.p2.metadata.expression.IMemberProvider;
 import org.osgi.framework.ServiceReference;
 
@@ -135,6 +137,14 @@ public abstract class MemberProvider implements IMemberProvider {
 			return caseInsensitive ? new CIDictionaryMemberProvider((Dictionary<String, ?>) value) : new DictionaryMemberProvider((Dictionary<String, ?>) value);
 		if (value instanceof ServiceReference)
 			return new ServiceRefMemberProvider((ServiceReference<?>) value);
+		// TODO Should there be a clause in Matches.match() instead?
+		if (value instanceof IProvidedCapability) {
+			IProvidedCapability cap = (IProvidedCapability) value;
+			Map<String, Object> attrs = new HashMap<String, Object>();
+			attrs.put(ProvidedCapability.MEMBER_NAMESPACE, cap.getNamespace());
+			attrs.putAll(cap.getAttributes());
+			return caseInsensitive ? new CIMapMemberProvider(attrs) : new MapMemberProvider(attrs);
+		}
 		throw new IllegalArgumentException();
 	}
 
commit aa4390e03ef4b5f6676c9e2991779df068b38f2b
Author: Todor Boev <rinsvind@gmail.com>
Date:   Tue Jun 6 13:36:30 2017 +0300

    Bug 313553 - Requirement: add handling to BundlesAction
    
    Added publication of generic requirements.
    Fixed the requirement advice processing to ignore
    generic requirements.
    Fixed the BundlesActionTest to verify the newly
    published generic requirements
    
    Change-Id: I5351e12dbc92090717348e0c495c4993906d07fc
    Signed-off-by: Todor Boev <rinsvind@gmail.com>

19	1	bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
34	23	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
18	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ActionTest.java
79	67	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
diff --git a/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java b/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
index 9e73a8d..eaaa780 100644
--- a/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
@@ -28,7 +28,7 @@ import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.metadata.MetadataFactory.InstallableUnitFragmentDescription;
 import org.eclipse.equinox.p2.metadata.VersionRange;
-import org.eclipse.equinox.p2.metadata.expression.IMatchExpression;
+import org.eclipse.equinox.p2.metadata.expression.*;
 import org.eclipse.equinox.p2.publisher.*;
 import org.eclipse.equinox.p2.publisher.actions.*;
 import org.eclipse.equinox.p2.query.IQueryResult;
@@ -190,6 +190,12 @@ public class BundlesAction extends AbstractPublisherAction {
 			}
 		}
 
+		// Process generic requirements
+		ManifestElement[] rawRequireCapHeader = parseManifestHeader(Constants.REQUIRE_CAPABILITY, manifest, bd.getLocation());
+		for (GenericSpecification requiredCap : bd.getGenericRequires()) {
+			addGenericRequirement(requirements, requiredCap, rawRequireCapHeader);
+		}
+
 		iu.setRequirements(requirements.toArray(new IRequirement[requirements.size()]));
 
 		// Create set of provided capabilities
@@ -278,6 +284,18 @@ public class BundlesAction extends AbstractPublisherAction {
 		reqsDeps.add(MetadataFactory.createRequirement(PublisherHelper.CAPABILITY_NS_JAVA_PACKAGE, importSpec.getName(), versionRange, null, optional ? 0 : 1, 1, greedy));
 	}
 
+	protected void addGenericRequirement(List<IRequirement> reqsDeps, GenericSpecification requireCapSpec, ManifestElement[] rawRequiresPackageHeader) {
+		String ldap = requireCapSpec.getMatchingFilter();
+		ldap = "(&(namespace=" + requireCapSpec.getType() + ")" + ldap + ")"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+		IExpression expr = ExpressionUtil.parse("providedCapabilities.exists(pc | pc ~= filter('" + ldap + "'))"); //$NON-NLS-1$ //$NON-NLS-2$
+		IMatchExpression<IInstallableUnit> matchExpr = ExpressionUtil.getFactory().matchExpression(expr);
+
+		// Optional and greedy in order to be backward compatible.
+		IRequirement requireCap = MetadataFactory.createRequirement(matchExpr, null, 0, 1, true);
+
+		reqsDeps.add(requireCap);
+	}
+
 	protected void addRequireBundleRequirement(List<IRequirement> reqsDeps, BundleSpecification requiredBundle, ManifestElement[] rawRequireBundleHeader) {
 		final boolean optional = requiredBundle.isOptional();
 		final boolean greedy;
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
index 53752ed..5fc2480 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/AbstractPublisherAction.java
@@ -20,8 +20,7 @@ import org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifact
 import org.eclipse.equinox.internal.p2.core.helpers.FileUtils;
 import org.eclipse.equinox.internal.p2.core.helpers.FileUtils.IPathComputer;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
-import org.eclipse.equinox.internal.p2.metadata.IRequiredCapability;
-import org.eclipse.equinox.internal.p2.metadata.InstallableUnit;
+import org.eclipse.equinox.internal.p2.metadata.*;
 import org.eclipse.equinox.internal.p2.publisher.Activator;
 import org.eclipse.equinox.internal.p2.publisher.QuotedTokenizer;
 import org.eclipse.equinox.p2.core.ProvisionException;
@@ -315,19 +314,18 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 				Set<IRequirement> resultRequiredCapabilities = new HashSet<>(current);
 
 				// remove current required capabilities that match (same name and namespace) advice.
-				for (int j = 0; j < current.size(); j++) {
-					IRequirement curr = current.get(j);
-					IRequiredCapability currentRequiredCapability = null;
-					if (curr instanceof IRequiredCapability)
-						currentRequiredCapability = (IRequiredCapability) curr;
-					else
+				for (IRequirement currReq : current) {
+					IRequiredCapability currentRequiredCapability = toRequiredCapability(currReq);
+					if (currentRequiredCapability == null) {
 						continue;
-					for (int k = 0; k < requiredAdvice.length; k++) {
-						IRequiredCapability requiredCapability = null;
-						if (requiredAdvice[k] instanceof IRequiredCapability)
-							requiredCapability = (IRequiredCapability) requiredAdvice[k];
-						else
+					}
+
+					for (IRequirement currReqAdvice : requiredAdvice) {
+						IRequiredCapability requiredCapability = toRequiredCapability(currReqAdvice);
+						if (requiredCapability == null) {
 							continue;
+						}
+
 						if (requiredCapability.getNamespace().equals(currentRequiredCapability.getNamespace()) && requiredCapability.getName().equals(currentRequiredCapability.getName())) {
 							resultRequiredCapabilities.remove(currentRequiredCapability);
 							break;
@@ -346,18 +344,18 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 				Set<IRequirement> resultMetaRequiredCapabilities = new HashSet<>(current);
 
 				// remove current meta-required capabilities that match (same name and namespace) advice.
-				for (IRequirement curr : current) {
-					IRequiredCapability currentMetaRequiredCapability = null;
-					if (curr instanceof IRequiredCapability)
-						currentMetaRequiredCapability = (IRequiredCapability) curr;
-					else
+				for (IRequirement currMetaReq : current) {
+					IRequiredCapability currentMetaRequiredCapability = toRequiredCapability(currMetaReq);
+					if (currentMetaRequiredCapability == null) {
 						continue;
-					for (int k = 0; k < metaRequiredAdvice.length; k++) {
-						IRequiredCapability metaRequiredCapability = null;
-						if (metaRequiredAdvice[k] instanceof IRequiredCapability)
-							metaRequiredCapability = (IRequiredCapability) metaRequiredAdvice[k];
-						else
+					}
+
+					for (IRequirement currMetaReqAdvice : metaRequiredAdvice) {
+						IRequiredCapability metaRequiredCapability = toRequiredCapability(currMetaReqAdvice);
+						if (metaRequiredCapability == null) {
 							continue;
+						}
+
 						if (metaRequiredCapability.getNamespace().equals(currentMetaRequiredCapability.getNamespace()) && metaRequiredCapability.getName().equals(currentMetaRequiredCapability.getName())) {
 							resultMetaRequiredCapabilities.remove(currentMetaRequiredCapability);
 							break;
@@ -390,6 +388,19 @@ public abstract class AbstractPublisherAction implements IPublisherAction {
 		}
 	}
 
+	protected static IRequiredCapability toRequiredCapability(IRequirement requirement) {
+		if (!(requirement instanceof IRequiredCapability)) {
+			return null;
+		}
+
+		IRequiredCapability requiredCapability = (IRequiredCapability) requirement;
+		if (!RequiredCapability.isSimpleRequirement(requiredCapability.getMatches())) {
+			return null;
+		}
+
+		return requiredCapability;
+	}
+
 	/**
 	 * Adds all applicable touchpoint advice to the given installable unit.
 	 * @param iu The installable unit to add touchpoint advice to
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ActionTest.java
index 4b57f75..06302d9 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/ActionTest.java
@@ -19,7 +19,7 @@ import org.eclipse.equinox.internal.p2.core.helpers.FileUtils;
 import org.eclipse.equinox.internal.p2.metadata.IRequiredCapability;
 import org.eclipse.equinox.internal.p2.metadata.InstallableUnit;
 import org.eclipse.equinox.p2.metadata.*;
-import org.eclipse.equinox.p2.metadata.expression.IMatchExpression;
+import org.eclipse.equinox.p2.metadata.expression.*;
 import org.eclipse.equinox.p2.publisher.*;
 import org.eclipse.equinox.p2.query.*;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
@@ -83,6 +83,23 @@ public abstract class ActionTest extends AbstractProvisioningTest {
 		Assert.fail("Missing RequiredCapability: " + name + " " + range.toString()); //$NON-NLS-1$
 	}
 
+	protected void verifyRequirement(Collection<IRequirement> requirement, String filter, int min, int max, boolean greedy) {
+		IExpression expr = ExpressionUtil.parse(filter);
+		IMatchExpression<IInstallableUnit> matchExpr = ExpressionUtil.getFactory().matchExpression(expr);
+
+		for (Iterator iterator = requirement.iterator(); iterator.hasNext();) {
+			IRequirement required = (IRequirement) iterator.next();
+			if (required.getMatches().equals(matchExpr)) {
+				String requirementDescr = "IRequirement " + filter;
+				Assert.assertEquals("Min of " + requirementDescr, min, required.getMin());
+				Assert.assertEquals("Max of " + requirementDescr, max, required.getMax());
+				Assert.assertEquals("Greedy of " + requirementDescr, greedy, required.isGreedy());
+				return;
+			}
+		}
+		Assert.fail("Missing IRequirement: " + filter); //$NON-NLS-1$
+	}
+
 	protected IInstallableUnit mockIU(String id, Version version) {
 		IInstallableUnit result = createMock(IInstallableUnit.class);
 		expect(result.getId()).andReturn(id).anyTimes();
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
index 35542a5..dd53c2a 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
@@ -41,39 +41,45 @@ import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;
 public class BundlesActionTest extends ActionTest {
 	private static final String OSGI = PublisherHelper.OSGI_BUNDLE_CLASSIFIER;
 	private static final String JAVA_PACKAGE = "java.package";//$NON-NLS-1$
+	private static final String JAVA_EE_1_4_REQ = "providedCapabilities.exists(pc | pc ~= filter('(&(namespace=osgi.ee)(|(&(osgi.ee=JavaSE)(version=1.4))(&(osgi.ee=CDC/Foundation)(version=1.1))))'))";
+	private static final String JAVA_EE_1_6_REQ = "providedCapabilities.exists(pc | pc ~= filter('(&(namespace=osgi.ee)(&(osgi.ee=JavaSE)(version=1.6)))'))";
 
 	private static final String TEST1_IUD_NAME = "iud";//$NON-NLS-1$
 	private static final String TEST1_PROVZ_NAME = "iuz";//$NON-NLS-1$
 	private static final String TEST1_PROVBUNDLE_NAME = "test1";//$NON-NLS-1$
-	private static final String TEST2_REQA_NAME = "iua";//$NON-NLS-1$
-	private static final String TEST2_REQB_NAME = "iub";//$NON-NLS-1$
-	private static final String TEST2_REQC_NAME = "iuc";//$NON-NLS-1$
-	private static final String TEST2_PROVZ_NAME = "iuz";//$NON-NLS-1$
-	private static final String TEST2_PROVY_NAME = "iuy";//$NON-NLS-1$
-	private static final String TEST2_PROVX_NAME = "iux";//$NON-NLS-1$
-	private static final String TEST2_PROVBUNDLE_NAME = "test2";//$NON-NLS-1$
-	private static final String TEST3_PROVBUNDLE_NAME = "test3";//$NON-NLS-1$
-	private static final String TEST4_PROVBUNDLE_NAME = "test4";//$NON-NLS-1$
+	private static final String TEST1_REQ_EE_FILTER = JAVA_EE_1_4_REQ;
+	private static final String TEST2_REQ_A_NAME = "iua";//$NON-NLS-1$
+	private static final String TEST2_REQ_B_NAME = "iub";//$NON-NLS-1$
+	private static final String TEST2_REQ_C_NAME = "iuc";//$NON-NLS-1$
+	private static final String TEST2_REQ_EE_FILTER = JAVA_EE_1_4_REQ;
+	private static final String TEST2_PROV_Z_NAME = "iuz";//$NON-NLS-1$
+	private static final String TEST2_PROV_Y_NAME = "iuy";//$NON-NLS-1$
+	private static final String TEST2_PROV_X_NAME = "iux";//$NON-NLS-1$
+	private static final String TEST2_PROV_BUNDLE_NAME = "test2";//$NON-NLS-1$
+	private static final String TEST3_PROV_BUNDLE_NAME = "test3";//$NON-NLS-1$
+	private static final String TEST4_PROV_BUNDLE_NAME = "test4";//$NON-NLS-1$
 	private static final String TEST4_REQ_PACKAGE_OPTIONAL_NAME = "iue";//$NON-NLS-1$
 	private static final String TEST4_REQ_PACKAGE_OPTGREEDY_NAME = "iuf";//$NON-NLS-1$
 	private static final String TEST4_REQ_BUNDLE_OPTIONAL_NAME = "iug";//$NON-NLS-1$
 	private static final String TEST4_REQ_BUNDLE_OPTGREEDY_NAME = "iuh";//$NON-NLS-1$
-	private static final String TEST5_PROVBUNDLE_NAME = "test5";//$NON-NLS-1$
+	private static final String TEST5_REQ_EE_FILTER = JAVA_EE_1_4_REQ;
+	private static final String TEST5_PROV_BUNDLE_NAME = "test5";//$NON-NLS-1$
+	private static final String TESTDYN_REQ_EE_FILTER = JAVA_EE_1_6_REQ;
 
 	private static final File TEST_BASE = new File(TestActivator.getTestDataFolder(), "BundlesActionTest");//$NON-NLS-1$
 	private static final File TEST_FILE1 = new File(TEST_BASE, TEST1_PROVBUNDLE_NAME);
-	private static final File TEST_FILE2 = new File(TEST_BASE, TEST2_PROVBUNDLE_NAME + ".jar");//$NON-NLS-1$
-	private static final File TEST_FILE2_PACKED = new File(TEST_BASE, TEST2_PROVBUNDLE_NAME + ".jar.pack.gz");//$NON-NLS-1$
+	private static final File TEST_FILE2 = new File(TEST_BASE, TEST2_PROV_BUNDLE_NAME + ".jar");//$NON-NLS-1$
+	private static final File TEST_FILE2_PACKED = new File(TEST_BASE, TEST2_PROV_BUNDLE_NAME + ".jar.pack.gz");//$NON-NLS-1$
 
 	private static final String PROVBUNDLE_NAMESPACE = "org.eclipse.equinox.p2.iu";//$NON-NLS-1$
-	private static final String TEST2_IUA_NAMESPACE = OSGI;
-	private static final String TEST2_IUB_NAMESPACE = JAVA_PACKAGE;
-	private static final String TEST2_IUC_NAMESPACE = JAVA_PACKAGE;
-	private static final String TEST1_IUD_NAMESPACE = JAVA_PACKAGE;
-	private static final String TEST2_PROVZ_NAMESPACE = JAVA_PACKAGE;
-	private static final String TEST2_PROVY_NAMESPACE = JAVA_PACKAGE;
-	private static final String TEST2_PROVX_NAMESPACE = JAVA_PACKAGE;
-	private static final String TEST1_PROVZ_NAMESPACE = JAVA_PACKAGE;
+	private static final String TEST2_IU_A_NAMESPACE = OSGI;
+	private static final String TEST2_IU_B_NAMESPACE = JAVA_PACKAGE;
+	private static final String TEST2_IU_C_NAMESPACE = JAVA_PACKAGE;
+	private static final String TEST1_IU_D_NAMESPACE = JAVA_PACKAGE;
+	private static final String TEST2_PROV_Z_NAMESPACE = JAVA_PACKAGE;
+	private static final String TEST2_PROV_Y_NAMESPACE = JAVA_PACKAGE;
+	private static final String TEST2_PROV_X_NAMESPACE = JAVA_PACKAGE;
+	private static final String TEST1_PROV_Z_NAMESPACE = JAVA_PACKAGE;
 
 	private final Version BUNDLE1_VERSION = Version.create("0.1.0");//$NON-NLS-1$
 	private final Version BUNDLE2_VERSION = Version.create("1.0.0.qualifier");//$NON-NLS-1$
@@ -210,14 +216,15 @@ public class BundlesActionTest extends ActionTest {
 
 		// check required capabilities
 		Collection<IRequirement> requiredCapability = bundle1IU.getRequirements();
-		verifyRequiredCapability(requiredCapability, TEST1_IUD_NAMESPACE, TEST1_IUD_NAME, TEST1_IUD_VERSION_RANGE);
-		assertEquals("2.0", 1, requiredCapability.size());
+		verifyRequiredCapability(requiredCapability, TEST1_IU_D_NAMESPACE, TEST1_IUD_NAME, TEST1_IUD_VERSION_RANGE);
+		verifyRequirement(requiredCapability, TEST1_REQ_EE_FILTER, 0, 1, true);
+		assertEquals("2.0", 2, requiredCapability.size());
 
 		// check provided capabilities
 		Collection<IProvidedCapability> providedCapabilities = bundle1IU.getProvidedCapabilities();
 		verifyProvidedCapability(providedCapabilities, PROVBUNDLE_NAMESPACE, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION);
 		verifyProvidedCapability(providedCapabilities, OSGI, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION);
-		verifyProvidedCapability(providedCapabilities, TEST1_PROVZ_NAMESPACE, TEST1_PROVZ_NAME, TEST2_PROVZ_VERSION);
+		verifyProvidedCapability(providedCapabilities, TEST1_PROV_Z_NAMESPACE, TEST1_PROVZ_NAME, TEST2_PROVZ_VERSION);
 		verifyProvidedCapability(providedCapabilities, PublisherHelper.NAMESPACE_ECLIPSE_TYPE, "source", Version.create("1.0.0"));//$NON-NLS-1$//$NON-NLS-2$
 		assertEquals("2.1", 4, providedCapabilities.size());
 
@@ -236,7 +243,7 @@ public class BundlesActionTest extends ActionTest {
 	}
 
 	private void verifyBundle2() {
-		ArrayList<IInstallableUnit> ius = new ArrayList<>(publisherResult.getIUs(TEST2_PROVBUNDLE_NAME, IPublisherResult.ROOT));
+		ArrayList<IInstallableUnit> ius = new ArrayList<>(publisherResult.getIUs(TEST2_PROV_BUNDLE_NAME, IPublisherResult.ROOT));
 		assertTrue(ius.size() == 1);
 		IInstallableUnit bundle2IU = ius.get(0);
 
@@ -244,21 +251,22 @@ public class BundlesActionTest extends ActionTest {
 		assertEquals(bundle2IU.getVersion(), BUNDLE2_VERSION);
 
 		// check required capabilities
-		Collection<IRequirement> requiredCapabilities = bundle2IU.getRequirements();
-		verifyRequiredCapability(requiredCapabilities, TEST2_IUA_NAMESPACE, TEST2_REQA_NAME, TEST2_IUA_VERSION_RANGE);
-		verifyRequiredCapability(requiredCapabilities, TEST2_IUB_NAMESPACE, TEST2_REQB_NAME, TEST2_IUB_VERSION_RANGE);
-		verifyRequiredCapability(requiredCapabilities, TEST2_IUC_NAMESPACE, TEST2_REQC_NAME, TEST2_IUC_VERSION_RANGE);
-		assertTrue(requiredCapabilities.size() == 3 /*number of tested elements*/);
+		Collection<IRequirement> requirements = bundle2IU.getRequirements();
+		verifyRequiredCapability(requirements, TEST2_IU_A_NAMESPACE, TEST2_REQ_A_NAME, TEST2_IUA_VERSION_RANGE);
+		verifyRequiredCapability(requirements, TEST2_IU_B_NAMESPACE, TEST2_REQ_B_NAME, TEST2_IUB_VERSION_RANGE);
+		verifyRequiredCapability(requirements, TEST2_IU_C_NAMESPACE, TEST2_REQ_C_NAME, TEST2_IUC_VERSION_RANGE);
+		verifyRequirement(requirements, TEST2_REQ_EE_FILTER, 0, 1, true);
+		assertTrue(requirements.size() == 4 /*number of tested elements*/);
 
 		// check provided capabilities
 		Collection<IProvidedCapability> providedCapabilities = bundle2IU.getProvidedCapabilities();
-		verifyProvidedCapability(providedCapabilities, PROVBUNDLE_NAMESPACE, TEST2_PROVBUNDLE_NAME, PROVBUNDLE2_VERSION);
-		verifyProvidedCapability(providedCapabilities, OSGI, TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION);
-		verifyProvidedCapability(providedCapabilities, TEST2_PROVZ_NAMESPACE, TEST2_PROVZ_NAME, TEST2_PROVZ_VERSION);
-		verifyProvidedCapability(providedCapabilities, TEST2_PROVY_NAMESPACE, TEST2_PROVY_NAME, TEST2_PROVY_VERSION);
-		verifyProvidedCapability(providedCapabilities, TEST2_PROVX_NAMESPACE, TEST2_PROVX_NAME, TEST2_PROVX_VERSION);
+		verifyProvidedCapability(providedCapabilities, PROVBUNDLE_NAMESPACE, TEST2_PROV_BUNDLE_NAME, PROVBUNDLE2_VERSION);
+		verifyProvidedCapability(providedCapabilities, OSGI, TEST2_PROV_BUNDLE_NAME, BUNDLE2_VERSION);
+		verifyProvidedCapability(providedCapabilities, TEST2_PROV_Z_NAMESPACE, TEST2_PROV_Z_NAME, TEST2_PROVZ_VERSION);
+		verifyProvidedCapability(providedCapabilities, TEST2_PROV_Y_NAMESPACE, TEST2_PROV_Y_NAME, TEST2_PROVY_VERSION);
+		verifyProvidedCapability(providedCapabilities, TEST2_PROV_X_NAMESPACE, TEST2_PROV_X_NAME, TEST2_PROVX_VERSION);
 		verifyProvidedCapability(providedCapabilities, PublisherHelper.NAMESPACE_ECLIPSE_TYPE, "bundle", Version.create("1.0.0"));//$NON-NLS-1$//$NON-NLS-2$
-		assertTrue(providedCapabilities.size() == 6 /*number of tested elements*/);
+		assertEquals(6, providedCapabilities.size()); /*number of tested elements*/
 
 		// check %bundle name is correct
 		Map<String, String> prop = bundle2IU.getProperties();
@@ -282,7 +290,7 @@ public class BundlesActionTest extends ActionTest {
 
 	private void verifyBundle3() {
 		// also a regression test for bug 393051: manifest headers use uncommon (but valid) capitalization
-		ArrayList<IInstallableUnit> ius = new ArrayList<>(publisherResult.getIUs(TEST3_PROVBUNDLE_NAME, IPublisherResult.ROOT));
+		ArrayList<IInstallableUnit> ius = new ArrayList<>(publisherResult.getIUs(TEST3_PROV_BUNDLE_NAME, IPublisherResult.ROOT));
 
 		assertTrue(ius.size() == 1);
 		IInstallableUnit bundle3IU = ius.get(0);
@@ -294,14 +302,14 @@ public class BundlesActionTest extends ActionTest {
 		int severity = updateDescriptor.getSeverity();
 
 		VersionRange expectedRange = new VersionRange("(0.0.1," + BUNDLE3_VERSION + "]");
-		assertEquals(TEST3_PROVBUNDLE_NAME, name);
+		assertEquals(TEST3_PROV_BUNDLE_NAME, name);
 		assertEquals(expectedRange, range);
 		assertEquals("Some description about this update", description.trim());
 		assertEquals(8, severity);
 	}
 
 	private void verifyBundle4() {
-		ArrayList<IInstallableUnit> ius = new ArrayList<>(publisherResult.getIUs(TEST4_PROVBUNDLE_NAME, IPublisherResult.ROOT));
+		ArrayList<IInstallableUnit> ius = new ArrayList<>(publisherResult.getIUs(TEST4_PROV_BUNDLE_NAME, IPublisherResult.ROOT));
 		assertTrue(ius.size() == 1);
 		IInstallableUnit bundle4IU = ius.get(0);
 
@@ -309,21 +317,22 @@ public class BundlesActionTest extends ActionTest {
 		assertEquals("1.1", bundle4IU.getVersion(), BUNDLE4_VERSION);
 
 		// check required capabilities
-		Collection<IRequirement> requiredCapability = bundle4IU.getRequirements();
-		verifyRequiredCapability(requiredCapability, JAVA_PACKAGE, TEST4_REQ_PACKAGE_OPTIONAL_NAME, DEFAULT_VERSION_RANGE, 0, 1, false);
-		verifyRequiredCapability(requiredCapability, JAVA_PACKAGE, TEST4_REQ_PACKAGE_OPTGREEDY_NAME, DEFAULT_VERSION_RANGE, 0, 1, true);
-		verifyRequiredCapability(requiredCapability, OSGI, TEST4_REQ_BUNDLE_OPTIONAL_NAME, DEFAULT_VERSION_RANGE, 0, 1, false);
-		verifyRequiredCapability(requiredCapability, OSGI, TEST4_REQ_BUNDLE_OPTGREEDY_NAME, DEFAULT_VERSION_RANGE, 0, 1, true);
-		assertEquals("2.0", 4, requiredCapability.size());
+		Collection<IRequirement> requirements = bundle4IU.getRequirements();
+		verifyRequiredCapability(requirements, JAVA_PACKAGE, TEST4_REQ_PACKAGE_OPTIONAL_NAME, DEFAULT_VERSION_RANGE, 0, 1, false);
+		verifyRequiredCapability(requirements, JAVA_PACKAGE, TEST4_REQ_PACKAGE_OPTGREEDY_NAME, DEFAULT_VERSION_RANGE, 0, 1, true);
+		verifyRequiredCapability(requirements, OSGI, TEST4_REQ_BUNDLE_OPTIONAL_NAME, DEFAULT_VERSION_RANGE, 0, 1, false);
+		verifyRequiredCapability(requirements, OSGI, TEST4_REQ_BUNDLE_OPTGREEDY_NAME, DEFAULT_VERSION_RANGE, 0, 1, true);
+		assertEquals("2.0", 4, requirements.size());
 	}
 
 	private void verifyBundle5() {
-		ArrayList<IInstallableUnit> ius = new ArrayList<>(publisherResult.getIUs(TEST5_PROVBUNDLE_NAME, IPublisherResult.ROOT));
+		ArrayList<IInstallableUnit> ius = new ArrayList<>(publisherResult.getIUs(TEST5_PROV_BUNDLE_NAME, IPublisherResult.ROOT));
 		assertTrue(ius.size() == 1);
 		IInstallableUnit bundle5IU = ius.get(0);
 
 		Collection<IRequirement> requirements = bundle5IU.getRequirements();
-		assertTrue(requirements.size() == 1);
+		verifyRequirement(requirements, TEST5_REQ_EE_FILTER, 0, 1, true);
+		assertTrue(requirements.size() == 2);
 		IRequirement requirement = requirements.iterator().next();
 
 		int min = requirement.getMin();
@@ -363,37 +372,37 @@ public class BundlesActionTest extends ActionTest {
 		expectUpdateDescriptorAdviceQuery(TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, null);
 		expectTouchpointAdviceQuery(TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, tpAdvice1);
 
-		expectOtherAdviceQueries(TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION);
-		expectPropertyAdviceQuery(TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, sdkProperties);
-		expectUpdateDescriptorAdviceQuery(TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, null);
-		expectTouchpointAdviceQuery(TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, tpAdvice2);
+		expectOtherAdviceQueries(TEST2_PROV_BUNDLE_NAME, BUNDLE2_VERSION);
+		expectPropertyAdviceQuery(TEST2_PROV_BUNDLE_NAME, BUNDLE2_VERSION, sdkProperties);
+		expectUpdateDescriptorAdviceQuery(TEST2_PROV_BUNDLE_NAME, BUNDLE2_VERSION, null);
+		expectTouchpointAdviceQuery(TEST2_PROV_BUNDLE_NAME, BUNDLE2_VERSION, tpAdvice2);
 
-		expectOtherAdviceQueries(TEST3_PROVBUNDLE_NAME, BUNDLE3_VERSION);
-		expectPropertyAdviceQuery(TEST3_PROVBUNDLE_NAME, BUNDLE3_VERSION, sarProperties);
-		expectUpdateDescriptorAdviceQuery(TEST3_PROVBUNDLE_NAME, BUNDLE3_VERSION, udAdvice3);
-		expectTouchpointAdviceQuery(TEST3_PROVBUNDLE_NAME, BUNDLE3_VERSION, null);
+		expectOtherAdviceQueries(TEST3_PROV_BUNDLE_NAME, BUNDLE3_VERSION);
+		expectPropertyAdviceQuery(TEST3_PROV_BUNDLE_NAME, BUNDLE3_VERSION, sarProperties);
+		expectUpdateDescriptorAdviceQuery(TEST3_PROV_BUNDLE_NAME, BUNDLE3_VERSION, udAdvice3);
+		expectTouchpointAdviceQuery(TEST3_PROV_BUNDLE_NAME, BUNDLE3_VERSION, null);
 
-		expectOtherAdviceQueries(TEST4_PROVBUNDLE_NAME, BUNDLE4_VERSION);
-		expectPropertyAdviceQuery(TEST4_PROVBUNDLE_NAME, BUNDLE4_VERSION, null);
-		expectUpdateDescriptorAdviceQuery(TEST4_PROVBUNDLE_NAME, BUNDLE4_VERSION, null);
-		expectTouchpointAdviceQuery(TEST4_PROVBUNDLE_NAME, BUNDLE4_VERSION, null);
+		expectOtherAdviceQueries(TEST4_PROV_BUNDLE_NAME, BUNDLE4_VERSION);
+		expectPropertyAdviceQuery(TEST4_PROV_BUNDLE_NAME, BUNDLE4_VERSION, null);
+		expectUpdateDescriptorAdviceQuery(TEST4_PROV_BUNDLE_NAME, BUNDLE4_VERSION, null);
+		expectTouchpointAdviceQuery(TEST4_PROV_BUNDLE_NAME, BUNDLE4_VERSION, null);
 
-		expectCapabilityAdviceQuery(TEST5_PROVBUNDLE_NAME, BUNDLE5_VERSION, capAdvice5);
-		expectOtherAdviceQueries(TEST5_PROVBUNDLE_NAME, BUNDLE5_VERSION);
-		expectPropertyAdviceQuery(TEST5_PROVBUNDLE_NAME, BUNDLE5_VERSION, sarProperties);
-		expectUpdateDescriptorAdviceQuery(TEST5_PROVBUNDLE_NAME, BUNDLE5_VERSION, null);
-		expectTouchpointAdviceQuery(TEST5_PROVBUNDLE_NAME, BUNDLE5_VERSION, null);
+		expectCapabilityAdviceQuery(TEST5_PROV_BUNDLE_NAME, BUNDLE5_VERSION, capAdvice5);
+		expectOtherAdviceQueries(TEST5_PROV_BUNDLE_NAME, BUNDLE5_VERSION);
+		expectPropertyAdviceQuery(TEST5_PROV_BUNDLE_NAME, BUNDLE5_VERSION, sarProperties);
+		expectUpdateDescriptorAdviceQuery(TEST5_PROV_BUNDLE_NAME, BUNDLE5_VERSION, null);
+		expectTouchpointAdviceQuery(TEST5_PROV_BUNDLE_NAME, BUNDLE5_VERSION, null);
 
 		//capture any touchpoint advice, and return the captured advice when the action asks for it
 		publisherInfo.addAdvice(and(AdviceMatcher.adviceMatches(TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION, ITouchpointAdvice.class), capture(tpAdvice1)));
 		EasyMock.expectLastCall().anyTimes();
 
-		publisherInfo.addAdvice(and(AdviceMatcher.adviceMatches(TEST2_PROVBUNDLE_NAME, BUNDLE2_VERSION, ITouchpointAdvice.class), capture(tpAdvice2)));
+		publisherInfo.addAdvice(and(AdviceMatcher.adviceMatches(TEST2_PROV_BUNDLE_NAME, BUNDLE2_VERSION, ITouchpointAdvice.class), capture(tpAdvice2)));
 		EasyMock.expectLastCall().anyTimes();
 
-		publisherInfo.addAdvice(and(AdviceMatcher.adviceMatches(TEST3_PROVBUNDLE_NAME, BUNDLE3_VERSION, AdviceFileAdvice.class), capture(udAdvice3)));
+		publisherInfo.addAdvice(and(AdviceMatcher.adviceMatches(TEST3_PROV_BUNDLE_NAME, BUNDLE3_VERSION, AdviceFileAdvice.class), capture(udAdvice3)));
 
-		publisherInfo.addAdvice(and(AdviceMatcher.adviceMatches(TEST5_PROVBUNDLE_NAME, BUNDLE5_VERSION, AdviceFileAdvice.class), capture(capAdvice5)));
+		publisherInfo.addAdvice(and(AdviceMatcher.adviceMatches(TEST5_PROV_BUNDLE_NAME, BUNDLE5_VERSION, AdviceFileAdvice.class), capture(capAdvice5)));
 		EasyMock.expectLastCall().anyTimes();
 	}
 
@@ -441,7 +450,10 @@ public class BundlesActionTest extends ActionTest {
 	public void testDynamicImport() throws Exception {
 		File testData = getTestData("dymamicImport", "testData/dynamicImport");
 		IInstallableUnit iu = BundlesAction.createBundleIU(BundlesAction.createBundleDescription(testData), null, new PublisherInfo());
-		assertEquals(0, iu.getRequirements().size());
+
+		Collection<IRequirement> requirements = iu.getRequirements();
+		verifyRequirement(requirements, TESTDYN_REQ_EE_FILTER, 0, 1, true);
+		assertEquals(1, requirements.size());
 	}
 
 	public void testPublishBundlesWhereOneBundleIsInvalid() throws Exception {
commit 872431089780603782ca6de7c774059ed8620e3c
Author: Todor Boev <rinsvind@gmail.com>
Date:   Tue May 30 19:12:40 2017 +0300

    Bug 313553 - Capability: add handling to BundlesAction
    
    Update BundlesAction to publish the bundle generic
    capabilities.
    Fix BundlesActionTest to handle the newly published
    capabilities.
    
    Change-Id: I4b3d11b64706b4fc77b9084f27f8e1583f15580e
    Signed-off-by: Todor Boev <rinsvind@gmail.com>

3	1	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
1	1	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
35	2	bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
5	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
index be7aea6..2c68d5e 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
@@ -93,7 +93,9 @@ public class ProvidedCapability implements IProvidedCapability, IMemberProvider
 	}
 
 	public String getName() {
-		return (String) attributes.get(MEMBER_NAME);
+		// There is always a "name" member, but it may not always be a string.
+		// Convert it here so that it is still possible to get the real type via getAttributes().
+		return attributes.get(MEMBER_NAME).toString();
 	}
 
 	public String getNamespace() {
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
index e895d5b..47aa3ee 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
@@ -31,7 +31,7 @@ public interface IProvidedCapability {
 
 	/**
 	 * 
-	 * @return String the special "name" attribute of this capability.
+	 * @return String the String representation of the special "name" attribute of this capability.
 	 * @noreference This method is not intended to be referenced by clients.
 	 */
 	public String getName();
diff --git a/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java b/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
index eaaa780..4cf0fc3 100644
--- a/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
@@ -22,6 +22,7 @@ import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.frameworkadmin.BundleInfo;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
 import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
+import org.eclipse.equinox.internal.p2.metadata.ProvidedCapability;
 import org.eclipse.equinox.internal.p2.publisher.Messages;
 import org.eclipse.equinox.internal.p2.publisher.eclipse.GeneratorBundleInfo;
 import org.eclipse.equinox.p2.metadata.*;
@@ -206,11 +207,43 @@ public class BundlesAction extends AbstractPublisherAction {
 		providedCapabilities.add(MetadataFactory.createProvidedCapability(CAPABILITY_NS_OSGI_BUNDLE, bd.getSymbolicName(), PublisherHelper.fromOSGiVersion(bd.getVersion())));
 
 		// Process exported packages
-		ExportPackageDescription[] exportedPackages = bd.getExportPackages();
-		for (ExportPackageDescription packageExport : exportedPackages) {
+		for (ExportPackageDescription packageExport : bd.getExportPackages()) {
 			providedCapabilities.add(MetadataFactory.createProvidedCapability(PublisherHelper.CAPABILITY_NS_JAVA_PACKAGE, packageExport.getName(), PublisherHelper.fromOSGiVersion(packageExport.getVersion())));
 		}
 
+		// Process generic capabilities
+
+		// TODO 
+		// IProvidedCapability may have to be extended to contain the OSGi directives as well which may be needed for 
+		// Bug 360659, Bug 525368. E.g. with IProvidedCapability.getDirectives()
+
+		// TODO
+		// The "osgi.wiring.bundle" capability seems equal to p2 "osgi.bundle" capability.
+		// It may be better to derive it at runtime.
+
+		// TODO
+		// It may be possible map the "osgi.identity" capability to elements of the IU like the id, the license, etc.
+		// It may be better to derive it at runtime.
+
+		int numCapName = 0;
+		for (GenericDescription genericCap : bd.getGenericCapabilities()) {
+			String capNs = genericCap.getType();
+
+			Map<String, Object> capAttrs = genericCap.getDeclaredAttributes();
+
+			// Some capabilities do not follow the OSGi convention to have an attribute with a key equal to their namespace (e.g. "osgi.service")
+			// In such cases synthesize a unique name
+			if (!capAttrs.containsKey(capNs)) {
+				capAttrs = new HashMap<>(capAttrs);
+				capAttrs.put(
+						ProvidedCapability.MEMBER_NAME,
+						String.format("%s_%s-%s", iu.getId(), iu.getVersion(), numCapName++)); //$NON-NLS-1$
+				numCapName++;
+			}
+
+			providedCapabilities.add(MetadataFactory.createProvidedCapability(capNs, capAttrs));
+		}
+
 		// Add capability to describe the type of bundle
 		if (manifest != null && manifest.containsKey("Eclipse-SourceBundle")) { //$NON-NLS-1$
 			providedCapabilities.add(SOURCE_BUNDLE_CAPABILITY);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
index dd53c2a..75eef92 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
@@ -40,6 +40,7 @@ import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;
 
 public class BundlesActionTest extends ActionTest {
 	private static final String OSGI = PublisherHelper.OSGI_BUNDLE_CLASSIFIER;
+	private static final String OSGI_IDENTITY = "osgi.identity";
 	private static final String JAVA_PACKAGE = "java.package";//$NON-NLS-1$
 	private static final String JAVA_EE_1_4_REQ = "providedCapabilities.exists(pc | pc ~= filter('(&(namespace=osgi.ee)(|(&(osgi.ee=JavaSE)(version=1.4))(&(osgi.ee=CDC/Foundation)(version=1.1))))'))";
 	private static final String JAVA_EE_1_6_REQ = "providedCapabilities.exists(pc | pc ~= filter('(&(namespace=osgi.ee)(&(osgi.ee=JavaSE)(version=1.6)))'))";
@@ -223,10 +224,11 @@ public class BundlesActionTest extends ActionTest {
 		// check provided capabilities
 		Collection<IProvidedCapability> providedCapabilities = bundle1IU.getProvidedCapabilities();
 		verifyProvidedCapability(providedCapabilities, PROVBUNDLE_NAMESPACE, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION);
+		verifyProvidedCapability(providedCapabilities, OSGI_IDENTITY, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION);
 		verifyProvidedCapability(providedCapabilities, OSGI, TEST1_PROVBUNDLE_NAME, BUNDLE1_VERSION);
 		verifyProvidedCapability(providedCapabilities, TEST1_PROV_Z_NAMESPACE, TEST1_PROVZ_NAME, TEST2_PROVZ_VERSION);
 		verifyProvidedCapability(providedCapabilities, PublisherHelper.NAMESPACE_ECLIPSE_TYPE, "source", Version.create("1.0.0"));//$NON-NLS-1$//$NON-NLS-2$
-		assertEquals("2.1", 4, providedCapabilities.size());
+		assertEquals("2.1", 5, providedCapabilities.size());
 
 		Collection<ITouchpointData> data = bundle1IU.getTouchpointData();
 		boolean found = false;
@@ -262,11 +264,12 @@ public class BundlesActionTest extends ActionTest {
 		Collection<IProvidedCapability> providedCapabilities = bundle2IU.getProvidedCapabilities();
 		verifyProvidedCapability(providedCapabilities, PROVBUNDLE_NAMESPACE, TEST2_PROV_BUNDLE_NAME, PROVBUNDLE2_VERSION);
 		verifyProvidedCapability(providedCapabilities, OSGI, TEST2_PROV_BUNDLE_NAME, BUNDLE2_VERSION);
+		verifyProvidedCapability(providedCapabilities, OSGI_IDENTITY, TEST2_PROV_BUNDLE_NAME, BUNDLE2_VERSION);
 		verifyProvidedCapability(providedCapabilities, TEST2_PROV_Z_NAMESPACE, TEST2_PROV_Z_NAME, TEST2_PROVZ_VERSION);
 		verifyProvidedCapability(providedCapabilities, TEST2_PROV_Y_NAMESPACE, TEST2_PROV_Y_NAME, TEST2_PROVY_VERSION);
 		verifyProvidedCapability(providedCapabilities, TEST2_PROV_X_NAMESPACE, TEST2_PROV_X_NAME, TEST2_PROVX_VERSION);
 		verifyProvidedCapability(providedCapabilities, PublisherHelper.NAMESPACE_ECLIPSE_TYPE, "bundle", Version.create("1.0.0"));//$NON-NLS-1$//$NON-NLS-2$
-		assertEquals(6, providedCapabilities.size()); /*number of tested elements*/
+		assertEquals(7, providedCapabilities.size()); /*number of tested elements*/
 
 		// check %bundle name is correct
 		Map<String, String> prop = bundle2IU.getProperties();
commit 508127d71a2a2cbc3aad554f2931219ae190a410
Author: Todor Boev <rinsvind@gmail.com>
Date:   Tue Jun 6 17:39:11 2017 +0300

    Bug 313553 - Capability: add writing to a metadata repo
    
    Change-Id: I4323f084b7b6b1107d0ccd95d375570dc9c35fb0
    Signed-off-by: Todor Boev <rinsvind@gmail.com>

58	5	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
8	0	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/XMLConstants.java
2	0	bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
index 89785d3..37559a7 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
@@ -14,6 +14,7 @@ package org.eclipse.equinox.internal.p2.metadata.repository.io;
 import java.io.OutputStream;
 import java.net.MalformedURLException;
 import java.util.*;
+import java.util.Map.Entry;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
 import org.eclipse.equinox.internal.p2.metadata.RequiredCapability;
@@ -152,16 +153,68 @@ public class MetadataWriter extends XMLWriter implements XMLConstants {
 			start(PROVIDED_CAPABILITIES_ELEMENT);
 			attribute(COLLECTION_SIZE_ATTRIBUTE, capabilities.size());
 			for (IProvidedCapability capability : capabilities) {
-				start(PROVIDED_CAPABILITY_ELEMENT);
-				attribute(NAMESPACE_ATTRIBUTE, capability.getNamespace());
-				attribute(NAME_ATTRIBUTE, capability.getName());
-				attribute(VERSION_ATTRIBUTE, capability.getVersion());
-				end(PROVIDED_CAPABILITY_ELEMENT);
+				writeProvidedCapability(capability);
 			}
 			end(PROVIDED_CAPABILITIES_ELEMENT);
 		}
 	}
 
+	protected void writeProvidedCapability(IProvidedCapability capability) {
+		start(PROVIDED_CAPABILITY_ELEMENT);
+
+		attribute(NAMESPACE_ATTRIBUTE, capability.getNamespace());
+		attribute(NAME_ATTRIBUTE, capability.getName());
+		attribute(VERSION_ATTRIBUTE, capability.getVersion());
+
+		Map<String, Object> attrs = new HashMap<>(capability.getAttributes());
+		attrs.remove(NAME_ATTRIBUTE);
+		attrs.remove(VERSION_ATTRIBUTE);
+
+		if (!attrs.isEmpty()) {
+			start(CAPABILITY_ATTRIBUTES_ELEMENT);
+			attribute(COLLECTION_SIZE_ATTRIBUTE, attrs.size());
+
+			for (Entry<String, Object> attr : attrs.entrySet()) {
+				start(CAPABILITY_ATTRIBUTE_ELEMENT);
+
+				String name = attr.getKey();
+				Object val = attr.getValue();
+				String type;
+
+				if (Collection.class.isAssignableFrom(val.getClass())) {
+					Collection<?> coll = (Collection<?>) val;
+
+					String elType = coll.iterator().next().getClass().getSimpleName();
+					type = "List<" + elType + ">"; //$NON-NLS-1$ //$NON-NLS-2$
+
+					StringBuilder valBuff = new StringBuilder();
+					for (Iterator<?> iter = coll.iterator(); iter.hasNext();) {
+						String el = iter.next().toString();
+
+						valBuff.append(el);
+						if (iter.hasNext()) {
+							valBuff.append(","); //$NON-NLS-1$
+						}
+					}
+
+					val = valBuff.toString();
+				} else {
+					type = val.getClass().getSimpleName();
+					val = val.toString();
+				}
+
+				attribute(CAPABILITY_ATTRIBUTE_NAME_ATTRIBUTE, name);
+				attribute(CAPABILITY_ATTRIBUTE_TYPE_ATTRIBUTE, type);
+				attribute(CAPABILITY_ATTRIBUTE_VALUE_ATTRIBUTE, val);
+
+				end(CAPABILITY_ATTRIBUTE_ELEMENT);
+			}
+			end(CAPABILITY_ATTRIBUTES_ELEMENT);
+		}
+
+		end(PROVIDED_CAPABILITY_ELEMENT);
+	}
+
 	protected void writeMetaRequirements(Collection<IRequirement> metaRequirements) {
 		if (metaRequirements != null && metaRequirements.size() > 0) {
 			start(META_REQUIREMENTS_ELEMENT);
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/XMLConstants.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/XMLConstants.java
index fd7e3ac..44db999 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/XMLConstants.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/XMLConstants.java
@@ -71,6 +71,14 @@ public interface XMLConstants extends org.eclipse.equinox.internal.p2.persistenc
 	public static final String CAPABILITY_OPTIONAL_ATTRIBUTE = "optional"; //$NON-NLS-1$
 	public static final String CAPABILITY_MULTIPLE_ATTRIBUTE = "multiple"; //$NON-NLS-1$
 	public static final String CAPABILITY_GREED_ATTRIBUTE = "greedy"; //$NON-NLS-1$
+
+	public static final String CAPABILITY_ATTRIBUTES_ELEMENT = "attributes"; //$NON-NLS-1$
+	public static final String CAPABILITY_ATTRIBUTE_ELEMENT = "attribute"; //$NON-NLS-1$
+	public static final String CAPABILITY_ATTRIBUTE_NAME_ATTRIBUTE = "name"; //$NON-NLS-1$
+	public static final String CAPABILITY_ATTRIBUTE_TYPE_ATTRIBUTE = "type"; //$NON-NLS-1$
+	public static final String CAPABILITY_ATTRIBUTE_VALUE_ATTRIBUTE = "value"; //$NON-NLS-1$
+	public static final String[] CAPABILITY_ATTRIBUTE_REQUIRED_ATTRIBUTES = new String[] {CAPABILITY_ATTRIBUTE_NAME_ATTRIBUTE, CAPABILITY_ATTRIBUTE_VALUE_ATTRIBUTE, CAPABILITY_ATTRIBUTE_TYPE_ATTRIBUTE};
+
 	public static final String[] REQIURED_CAPABILITY_ATTRIBUTES = new String[] {NAMESPACE_ATTRIBUTE, NAME_ATTRIBUTE, VERSION_RANGE_ATTRIBUTE};
 	public static final String[] REQIUREMENT_ATTRIBUTES = new String[] {MATCH_ATTRIBUTE};
 	public static final String[] OPTIONAL_CAPABILITY_ATTRIBUTES = new String[] {CAPABILITY_OPTIONAL_ATTRIBUTE, CAPABILITY_MULTIPLE_ATTRIBUTE, CAPABILITY_GREED_ATTRIBUTE};
diff --git a/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java b/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
index 4cf0fc3..925f082 100644
--- a/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
@@ -317,6 +317,8 @@ public class BundlesAction extends AbstractPublisherAction {
 		reqsDeps.add(MetadataFactory.createRequirement(PublisherHelper.CAPABILITY_NS_JAVA_PACKAGE, importSpec.getName(), versionRange, null, optional ? 0 : 1, 1, greedy));
 	}
 
+	// TODO Handle all attributes and directives somehow? Especially the "effective" directive.
+	// TODO Make these optional and greedy for backward compatibility?
 	protected void addGenericRequirement(List<IRequirement> reqsDeps, GenericSpecification requireCapSpec, ManifestElement[] rawRequiresPackageHeader) {
 		String ldap = requireCapSpec.getMatchingFilter();
 		ldap = "(&(namespace=" + requireCapSpec.getType() + ")" + ldap + ")"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
commit 719079bb53131a19435e345b0e58228dedb75dbc
Author: Todor Boev <rinsvind@gmail.com>
Date:   Mon Jun 5 19:24:39 2017 +0300

    Bug 313553 - Capability: add reading from a metadata repo.
    
    Change-Id: If2cdce9d316c3d9cbc4b16c81dc1a74b97f6e7e5
    Signed-off-by: Todor Boev <rinsvind@gmail.com>

133	6	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
index 05b7f9b..a1ff605 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
@@ -31,6 +31,18 @@ import org.xml.sax.ContentHandler;
 public abstract class MetadataParser extends XMLParser implements XMLConstants {
 	static final ILicense[] NO_LICENSES = new ILicense[0];
 
+	static final String ATTR_TYPE_LIST_HEAD = "List<"; //$NON-NLS-1$
+	static final String ATTR_TYPE_STRING = String.class.getSimpleName();
+	static final String ATTR_TYPE_INTEGER = Integer.class.getSimpleName();
+	static final String ATTR_TYPE_LONG = Long.class.getSimpleName();
+	static final String ATTR_TYPE_FLOAT = Float.class.getSimpleName();
+	static final String ATTR_TYPE_DOUBLE = Double.class.getSimpleName();
+	static final String ATTR_TYPE_BYTE = Byte.class.getSimpleName();
+	static final String ATTR_TYPE_SHORT = Short.class.getSimpleName();
+	static final String ATTR_TYPE_CHARACTER = Character.class.getSimpleName();
+	static final String ATTR_TYPE_BOOLEAN = Boolean.class.getSimpleName();
+	static final String ATTR_TYPE_VERSION = Version.class.getSimpleName();
+
 	public MetadataParser(BundleContext context, String bundleId) {
 		super(context, bundleId);
 	}
@@ -503,18 +515,133 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 	}
 
 	protected class ProvidedCapabilityHandler extends AbstractHandler {
+		private String namespace;
+		private String name;
+		private Version version;
+		private ProvidedCapabilityAttributesHandler attributesHandler;
+
+		private List<IProvidedCapability> capabilities;
 
 		public ProvidedCapabilityHandler(AbstractHandler parentHandler, Attributes attributes, List<IProvidedCapability> capabilities) {
 			super(parentHandler, PROVIDED_CAPABILITY_ELEMENT);
+
+			this.capabilities = capabilities;
+
 			String[] values = parseRequiredAttributes(attributes, REQUIRED_PROVIDED_CAPABILITY_ATTRIBUTES);
-			Version version = checkVersion(PROVIDED_CAPABILITY_ELEMENT, VERSION_ATTRIBUTE, values[2]);
-			capabilities.add(MetadataFactory.createProvidedCapability(values[0], values[1], version));
+			this.namespace = values[0];
+			this.name = values[1];
+			this.version = checkVersion(PROVIDED_CAPABILITY_ELEMENT, VERSION_ATTRIBUTE, values[2]);
+		}
+
+		public void startElement(String elem, Attributes attributes) {
+			if (elem.equals(CAPABILITY_ATTRIBUTES_ELEMENT)) {
+				this.attributesHandler = new ProvidedCapabilityAttributesHandler(this, attributes);
+			} else {
+				invalidElement(elem, attributes);
+			}
+		}
+
+		protected void finished() {
+			Map<String, Object> capAttrs = (attributesHandler != null)
+					? attributesHandler.getAttributes()
+					: new HashMap<String, Object>();
+
+			capAttrs.put(NAME_ATTRIBUTE, name);
+			capAttrs.put(VERSION_ATTRIBUTE, version);
+			IProvidedCapability cap = MetadataFactory.createProvidedCapability(namespace, capAttrs);
+			capabilities.add(cap);
+		}
+	}
+
+	protected class ProvidedCapabilityAttributesHandler extends AbstractMetadataHandler {
+		private Map<String, Object> capAttributes;
+
+		public ProvidedCapabilityAttributesHandler(AbstractHandler parentHandler, Attributes attributes) {
+			super(parentHandler, CAPABILITY_ATTRIBUTES_ELEMENT);
+			// TODO add getOptionalSize(attributes, 4)
+			this.capAttributes = new HashMap<String, Object>();
+		}
+
+		public Map<String, Object> getAttributes() {
+			return capAttributes;
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (name.equals(CAPABILITY_ATTRIBUTE_ELEMENT)) {
+				new ProvidedCapabilityAttributeHandler(this, attributes, capAttributes);
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+	}
+
+	protected class ProvidedCapabilityAttributeHandler extends AbstractMetadataHandler {
+		public ProvidedCapabilityAttributeHandler(AbstractHandler parentHandler, Attributes attributes, Map<String, Object> capAttributes) {
+			super(parentHandler, CAPABILITY_ATTRIBUTE_ELEMENT);
+
+			String[] values = parseRequiredAttributes(attributes, CAPABILITY_ATTRIBUTE_REQUIRED_ATTRIBUTES);
+
+			String name = values[0];
+			String value = values[1];
+			String type = values[2];
+
+			if (type.startsWith(ATTR_TYPE_LIST_HEAD)) {
+				capAttributes.put(name, parseList(type, value));
+			} else {
+				capAttributes.put(name, parseScalar(type, value));
+			}
 		}
 
 		@Override
 		public void startElement(String name, Attributes attributes) {
 			invalidElement(name, attributes);
 		}
+
+		private List<Object> parseList(String type, String value) {
+			String elType = type.substring(ATTR_TYPE_LIST_HEAD.length(), type.length() - 1);
+
+			List<Object> res = new ArrayList<Object>();
+			for (String el : value.split("\\s*,\\s*")) { //$NON-NLS-1$
+				res.add(parseScalar(elType, el));
+			}
+
+			return res;
+		}
+
+		private Object parseScalar(String type, String value) {
+			if (ATTR_TYPE_STRING.equals(type)) {
+				return value;
+			}
+			if (ATTR_TYPE_INTEGER.equals(type)) {
+				return Integer.parseInt(value);
+			}
+			if (ATTR_TYPE_LONG.equals(type)) {
+				return Long.parseLong(value);
+			}
+			if (ATTR_TYPE_FLOAT.equals(type)) {
+				return Float.parseFloat(value);
+			}
+			if (ATTR_TYPE_DOUBLE.equals(type)) {
+				return Double.parseDouble(value);
+			}
+			if (ATTR_TYPE_BYTE.equals(type)) {
+				return Byte.parseByte(value);
+			}
+			if (ATTR_TYPE_SHORT.equals(type)) {
+				return Short.parseShort(value);
+			}
+			if (ATTR_TYPE_CHARACTER.equals(type)) {
+				return value.charAt(0);
+			}
+			if (ATTR_TYPE_BOOLEAN.equals(type)) {
+				return Boolean.parseBoolean(value);
+			}
+			if (ATTR_TYPE_VERSION.equals(type)) {
+				return Version.create(value);
+			}
+			// TODO Throw what?
+			return value.toString();
+		}
 	}
 
 	protected class HostRequiredCapabilitiesHandler extends AbstractMetadataHandler {
@@ -623,13 +750,13 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 		}
 
 		@Override
-		public void startElement(String name, Attributes attributes) {
-			if (name.equals(CAPABILITY_FILTER_ELEMENT)) {
+		public void startElement(String elem, Attributes attributes) {
+			if (elem.equals(CAPABILITY_FILTER_ELEMENT)) {
 				filterHandler = new TextHandler(this, CAPABILITY_FILTER_ELEMENT, attributes);
-			} else if (name.equals(REQUIREMENT_DESCRIPTION_ELEMENT)) {
+			} else if (elem.equals(REQUIREMENT_DESCRIPTION_ELEMENT)) {
 				descriptionHandler = new TextHandler(this, REQUIREMENT_DESCRIPTION_ELEMENT, attributes);
 			} else {
-				invalidElement(name, attributes);
+				invalidElement(elem, attributes);
 			}
 		}
 
commit 1c02b17b8348fc8a3e04a05db1240a28ecc352cf
Author: Todor Boev <rinsvind@gmail.com>
Date:   Mon Oct 2 19:06:00 2017 +0300

    Bug 313553 - Unentangle ProvidedCapability members and attributes
    
    The members are the generic way for p2 queries to describe getters
    on objects. The capability attributes then participate in queries
    as the "attributes" member of a ProvidedCapability object.
    
    Fixed the IProvidedCapability to follow the OSGi convention that the
    attributes contain the name of the capability under a key equal to the
    capability namespace. This is cleaner than to introduce a new "name"
    attribute for the p2 name that can conflict with an incoming OSGi "name"
    attribute.
    
    Fixed the version of IProvidedCapability to follow the OSGi convention
    that capabilities with a version have a "version" attribute with a value
    of type an OSGi version object.
    
    Change-Id: Ic9b77c2d103216141035dc3fb5861ca99a3ddccd
    Signed-off-by: Todor Boev <rinsvind@gmail.com>

9	7	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
4	3	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
38	30	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
0	10	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/MemberProvider.java
7	8	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
42	24	bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
2	1	bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
10	12	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
2	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
index a1ff605..90e27da 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
@@ -16,8 +16,7 @@ import java.net.URI;
 import java.util.*;
 import java.util.Map.Entry;
 import org.eclipse.equinox.internal.p2.core.helpers.OrderedProperties;
-import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
-import org.eclipse.equinox.internal.p2.metadata.InstallableUnit;
+import org.eclipse.equinox.internal.p2.metadata.*;
 import org.eclipse.equinox.internal.p2.persistence.XMLParser;
 import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.metadata.MetadataFactory.*;
@@ -533,6 +532,7 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 			this.version = checkVersion(PROVIDED_CAPABILITY_ELEMENT, VERSION_ATTRIBUTE, values[2]);
 		}
 
+		@Override
 		public void startElement(String elem, Attributes attributes) {
 			if (elem.equals(CAPABILITY_ATTRIBUTES_ELEMENT)) {
 				this.attributesHandler = new ProvidedCapabilityAttributesHandler(this, attributes);
@@ -541,13 +541,14 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 			}
 		}
 
+		@Override
 		protected void finished() {
 			Map<String, Object> capAttrs = (attributesHandler != null)
 					? attributesHandler.getAttributes()
-					: new HashMap<String, Object>();
+					: new HashMap<>();
 
-			capAttrs.put(NAME_ATTRIBUTE, name);
-			capAttrs.put(VERSION_ATTRIBUTE, version);
+			capAttrs.put(namespace, name);
+			capAttrs.put(ProvidedCapability.ATTRIBUTE_VERSION, version);
 			IProvidedCapability cap = MetadataFactory.createProvidedCapability(namespace, capAttrs);
 			capabilities.add(cap);
 		}
@@ -559,13 +560,14 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 		public ProvidedCapabilityAttributesHandler(AbstractHandler parentHandler, Attributes attributes) {
 			super(parentHandler, CAPABILITY_ATTRIBUTES_ELEMENT);
 			// TODO add getOptionalSize(attributes, 4)
-			this.capAttributes = new HashMap<String, Object>();
+			this.capAttributes = new HashMap<>();
 		}
 
 		public Map<String, Object> getAttributes() {
 			return capAttributes;
 		}
 
+		@Override
 		public void startElement(String name, Attributes attributes) {
 			if (name.equals(CAPABILITY_ATTRIBUTE_ELEMENT)) {
 				new ProvidedCapabilityAttributeHandler(this, attributes, capAttributes);
@@ -600,7 +602,7 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 		private List<Object> parseList(String type, String value) {
 			String elType = type.substring(ATTR_TYPE_LIST_HEAD.length(), type.length() - 1);
 
-			List<Object> res = new ArrayList<Object>();
+			List<Object> res = new ArrayList<>();
 			for (String el : value.split("\\s*,\\s*")) { //$NON-NLS-1$
 				res.add(parseScalar(elType, el));
 			}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
index 37559a7..2b7686e 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataWriter.java
@@ -17,6 +17,7 @@ import java.util.*;
 import java.util.Map.Entry;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
+import org.eclipse.equinox.internal.p2.metadata.ProvidedCapability;
 import org.eclipse.equinox.internal.p2.metadata.RequiredCapability;
 import org.eclipse.equinox.internal.p2.metadata.repository.Activator;
 import org.eclipse.equinox.internal.p2.persistence.XMLWriter;
@@ -167,8 +168,8 @@ public class MetadataWriter extends XMLWriter implements XMLConstants {
 		attribute(VERSION_ATTRIBUTE, capability.getVersion());
 
 		Map<String, Object> attrs = new HashMap<>(capability.getAttributes());
-		attrs.remove(NAME_ATTRIBUTE);
-		attrs.remove(VERSION_ATTRIBUTE);
+		attrs.remove(capability.getNamespace());
+		attrs.remove(ProvidedCapability.ATTRIBUTE_VERSION);
 
 		if (!attrs.isEmpty()) {
 			start(CAPABILITY_ATTRIBUTES_ELEMENT);
@@ -185,7 +186,7 @@ public class MetadataWriter extends XMLWriter implements XMLConstants {
 					Collection<?> coll = (Collection<?>) val;
 
 					String elType = coll.iterator().next().getClass().getSimpleName();
-					type = "List<" + elType + ">"; //$NON-NLS-1$ //$NON-NLS-2$
+					type = String.format("List<%s>", elType); //$NON-NLS-1$
 
 					StringBuilder valBuff = new StringBuilder();
 					for (Iterator<?> iter = coll.iterator(); iter.hasNext();) {
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
index 2c68d5e..5d36a19 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/ProvidedCapability.java
@@ -25,9 +25,18 @@ import org.eclipse.osgi.util.NLS;
  * Describes a capability as exposed or required by an installable unit
  */
 public class ProvidedCapability implements IProvidedCapability, IMemberProvider {
+	/** Used for fast access from P2 queries to the {@link #getNamespace} method */
+	public static final String MEMBER_NAMESPACE = "namespace"; //$NON-NLS-1$
+	/** Used for fast access from P2 queries to the {@link #getName} method */
 	public static final String MEMBER_NAME = "name"; //$NON-NLS-1$
+	/** Used for fast access from P2 queries to the {@link #getVersion} method */
 	public static final String MEMBER_VERSION = "version"; //$NON-NLS-1$
-	public static final String MEMBER_NAMESPACE = "namespace"; //$NON-NLS-1$
+	/** Used for fast access from P2 queries to the {@link #getAttributes} method */
+	public static final String MEMBER_ATTRIBUTES = "attributes"; //$NON-NLS-1$
+
+	// TODO Move this to IProvidedCapability?
+	// The "version" attribute is part of the public contract of getVersion() and getAttributes()
+	public static final String ATTRIBUTE_VERSION = "version"; //$NON-NLS-1$
 
 	private final String namespace;
 	private final Map<String, Object> attributes;
@@ -38,26 +47,19 @@ public class ProvidedCapability implements IProvidedCapability, IMemberProvider
 
 		Assert.isNotNull(attrs);
 		Assert.isTrue(!attrs.isEmpty());
-		Assert.isTrue(!attrs.containsKey(MEMBER_NAMESPACE));
+
 		this.attributes = new HashMap<>(attrs);
 
-		if (!attributes.containsKey(MEMBER_NAME)) {
-			// It is common for a capability to have a main attribute under a key
-			// with value the same as the capability namespace. Use as "name" if present.
-			Assert.isTrue(attributes.containsKey(namespace));
-			attributes.put(MEMBER_NAME, attributes.get(namespace));
-		}
+		// Verify the name
+		Assert.isTrue(attributes.containsKey(namespace) && (attributes.get(namespace) instanceof String),
+				NLS.bind(Messages.provided_capability_name_not_defined, namespace));
 
-		Object version = attributes.get(MEMBER_VERSION);
-		if (version == null) {
-			attributes.put(MEMBER_VERSION, Version.emptyVersion);
-		} else if (version instanceof org.osgi.framework.Version) {
-			org.osgi.framework.Version osgiVer = (org.osgi.framework.Version) version;
-			attributes.put(
-					MEMBER_VERSION,
-					Version.createOSGi(osgiVer.getMajor(), osgiVer.getMinor(), osgiVer.getMicro(), osgiVer.getQualifier()));
+		// Verify the version
+		Object version = attributes.get(ATTRIBUTE_VERSION);
+		if (version != null) {
+			Assert.isTrue(attributes.get(ATTRIBUTE_VERSION) instanceof Version);
 		} else {
-			Assert.isTrue(version instanceof Version);
+			attributes.put(ATTRIBUTE_VERSION, Version.emptyVersion);
 		}
 	}
 
@@ -66,8 +68,8 @@ public class ProvidedCapability implements IProvidedCapability, IMemberProvider
 		Assert.isNotNull(name, NLS.bind(Messages.provided_capability_name_not_defined, namespace));
 		this.namespace = namespace;
 		this.attributes = new HashMap<>();
-		attributes.put(MEMBER_NAME, name);
-		attributes.put(MEMBER_VERSION, version == null ? Version.emptyVersion : version);
+		attributes.put(namespace, name);
+		attributes.put(ATTRIBUTE_VERSION, version == null ? Version.emptyVersion : version);
 	}
 
 	public boolean equals(Object other) {
@@ -92,18 +94,16 @@ public class ProvidedCapability implements IProvidedCapability, IMemberProvider
 		return true;
 	}
 
-	public String getName() {
-		// There is always a "name" member, but it may not always be a string.
-		// Convert it here so that it is still possible to get the real type via getAttributes().
-		return attributes.get(MEMBER_NAME).toString();
-	}
-
 	public String getNamespace() {
 		return namespace;
 	}
 
+	public String getName() {
+		return (String) attributes.get(namespace);
+	}
+
 	public Version getVersion() {
-		return (Version) attributes.get(MEMBER_VERSION);
+		return (Version) attributes.get(ATTRIBUTE_VERSION);
 	}
 
 	public Map<String, Object> getAttributes() {
@@ -129,11 +129,19 @@ public class ProvidedCapability implements IProvidedCapability, IMemberProvider
 		return str.toString();
 	}
 
+	@Override
 	public Object getMember(String memberName) {
-		Object res = memberName.equals(MEMBER_NAMESPACE) ? namespace : attributes.get(memberName);
-		if (res == null) {
-			throw new IllegalArgumentException("No such member: " + memberName); //$NON-NLS-1$
+		switch (memberName) {
+			case MEMBER_NAMESPACE :
+				return namespace;
+			case MEMBER_NAME :
+				return attributes.get(namespace);
+			case MEMBER_VERSION :
+				return attributes.get(ATTRIBUTE_VERSION);
+			case MEMBER_ATTRIBUTES :
+				return attributes;
+			default :
+				throw new IllegalArgumentException("No such member: " + memberName); //$NON-NLS-1$
 		}
-		return res;
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/MemberProvider.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/MemberProvider.java
index 4eaa481..dccb003 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/MemberProvider.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/expression/MemberProvider.java
@@ -12,8 +12,6 @@ package org.eclipse.equinox.internal.p2.metadata.expression;
 
 import java.util.*;
 import java.util.Map.Entry;
-import org.eclipse.equinox.internal.p2.metadata.ProvidedCapability;
-import org.eclipse.equinox.p2.metadata.IProvidedCapability;
 import org.eclipse.equinox.p2.metadata.expression.IMemberProvider;
 import org.osgi.framework.ServiceReference;
 
@@ -137,14 +135,6 @@ public abstract class MemberProvider implements IMemberProvider {
 			return caseInsensitive ? new CIDictionaryMemberProvider((Dictionary<String, ?>) value) : new DictionaryMemberProvider((Dictionary<String, ?>) value);
 		if (value instanceof ServiceReference)
 			return new ServiceRefMemberProvider((ServiceReference<?>) value);
-		// TODO Should there be a clause in Matches.match() instead?
-		if (value instanceof IProvidedCapability) {
-			IProvidedCapability cap = (IProvidedCapability) value;
-			Map<String, Object> attrs = new HashMap<String, Object>();
-			attrs.put(ProvidedCapability.MEMBER_NAMESPACE, cap.getNamespace());
-			attrs.putAll(cap.getAttributes());
-			return caseInsensitive ? new CIMapMemberProvider(attrs) : new MapMemberProvider(attrs);
-		}
 		throw new IllegalArgumentException();
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
index 47aa3ee..a1c0f3a 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IProvidedCapability.java
@@ -28,24 +28,23 @@ import java.util.Map;
  * @see IRequirement
  */
 public interface IProvidedCapability {
-
 	/**
 	 * 
-	 * @return String the String representation of the special "name" attribute of this capability.
+	 * @return String the namespace of this capability.
 	 * @noreference This method is not intended to be referenced by clients.
 	 */
-	public String getName();
+	public String getNamespace();
 
 	/**
 	 * 
-	 * @return String the namespace of this capability.
+	 * @return String the attribute stored under a key equal to {@link #getNamespace()} attribute of this capability.
 	 * @noreference This method is not intended to be referenced by clients.
 	 */
-	public String getNamespace();
+	public String getName();
 
 	/**
 	 * 
-	 * @return String the special "version" attribute of this capability.
+	 * @return String the special <code>version</code> attribute of this capability.
 	 * @noreference This method is not intended to be referenced by clients.
 	 */
 	public Version getVersion();
@@ -54,6 +53,7 @@ public interface IProvidedCapability {
 	 * 
 	 * @return A full description of this capability
 	 * @noreference This method is not intended to be referenced by clients.
+	 * @since 2.4
 	 */
 	public Map<String, Object> getAttributes();
 
@@ -63,9 +63,8 @@ public interface IProvidedCapability {
 	 * This method returns <i>true</i> if:
 	 * <ul>
 	 *  <li> Both this object and the given object are of type IProvidedCapability
-	 *  <li> The result of <b>getName()</b> on both objects are equal
 	 *  <li> The result of <b>getNamespace()</b> on both objects are equal
-	 *  <li> The result of <b>getVersion()</b> on both objects are equal
+	 *  <li> The result of <b>getAttributes()</b> on both objects are equal
 	 * </ul> 
 	 */
 	public boolean equals(Object other);
diff --git a/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java b/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
index 925f082..95777c8 100644
--- a/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/equinox/p2/publisher/eclipse/BundlesAction.java
@@ -22,7 +22,6 @@ import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.frameworkadmin.BundleInfo;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
 import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
-import org.eclipse.equinox.internal.p2.metadata.ProvidedCapability;
 import org.eclipse.equinox.internal.p2.publisher.Messages;
 import org.eclipse.equinox.internal.p2.publisher.eclipse.GeneratorBundleInfo;
 import org.eclipse.equinox.p2.metadata.*;
@@ -79,6 +78,7 @@ public class BundlesAction extends AbstractPublisherAction {
 	public static final String OSGI_BUNDLE_CLASSIFIER = "osgi.bundle"; //$NON-NLS-1$
 	public static final String CAPABILITY_NS_OSGI_BUNDLE = "osgi.bundle"; //$NON-NLS-1$
 	public static final String CAPABILITY_NS_OSGI_FRAGMENT = "osgi.fragment"; //$NON-NLS-1$
+	public static final String CAPABILITY_ATTR_VERSION = "version"; //$NON-NLS-1$
 
 	public static final IProvidedCapability BUNDLE_CAPABILITY = MetadataFactory.createProvidedCapability(PublisherHelper.NAMESPACE_ECLIPSE_TYPE, TYPE_ECLIPSE_BUNDLE, Version.createOSGi(1, 0, 0));
 	public static final IProvidedCapability SOURCE_BUNDLE_CAPABILITY = MetadataFactory.createProvidedCapability(PublisherHelper.NAMESPACE_ECLIPSE_TYPE, TYPE_ECLIPSE_SOURCE, Version.createOSGi(1, 0, 0));
@@ -218,30 +218,13 @@ public class BundlesAction extends AbstractPublisherAction {
 		// Bug 360659, Bug 525368. E.g. with IProvidedCapability.getDirectives()
 
 		// TODO
-		// The "osgi.wiring.bundle" capability seems equal to p2 "osgi.bundle" capability.
-		// It may be better to derive it at runtime.
-
-		// TODO
 		// It may be possible map the "osgi.identity" capability to elements of the IU like the id, the license, etc.
 		// It may be better to derive it at runtime.
 
-		int numCapName = 0;
+		int capNo = 0;
 		for (GenericDescription genericCap : bd.getGenericCapabilities()) {
-			String capNs = genericCap.getType();
-
-			Map<String, Object> capAttrs = genericCap.getDeclaredAttributes();
-
-			// Some capabilities do not follow the OSGi convention to have an attribute with a key equal to their namespace (e.g. "osgi.service")
-			// In such cases synthesize a unique name
-			if (!capAttrs.containsKey(capNs)) {
-				capAttrs = new HashMap<>(capAttrs);
-				capAttrs.put(
-						ProvidedCapability.MEMBER_NAME,
-						String.format("%s_%s-%s", iu.getId(), iu.getVersion(), numCapName++)); //$NON-NLS-1$
-				numCapName++;
-			}
-
-			providedCapabilities.add(MetadataFactory.createProvidedCapability(capNs, capAttrs));
+			addGenericCapability(providedCapabilities, genericCap, iu, capNo);
+			capNo++;
 		}
 
 		// Add capability to describe the type of bundle
@@ -318,11 +301,12 @@ public class BundlesAction extends AbstractPublisherAction {
 	}
 
 	// TODO Handle all attributes and directives somehow? Especially the "effective" directive.
-	// TODO Make these optional and greedy for backward compatibility?
 	protected void addGenericRequirement(List<IRequirement> reqsDeps, GenericSpecification requireCapSpec, ManifestElement[] rawRequiresPackageHeader) {
+		String ns = requireCapSpec.getType();
 		String ldap = requireCapSpec.getMatchingFilter();
-		ldap = "(&(namespace=" + requireCapSpec.getType() + ")" + ldap + ")"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-		IExpression expr = ExpressionUtil.parse("providedCapabilities.exists(pc | pc ~= filter('" + ldap + "'))"); //$NON-NLS-1$ //$NON-NLS-2$
+		String matcher = "providedCapabilities.exists(pc | pc.namespace == '" + ns + "' && pc.attributes ~= filter('" + ldap + "'))"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+
+		IExpression expr = ExpressionUtil.parse(matcher);
 		IMatchExpression<IInstallableUnit> matchExpr = ExpressionUtil.getFactory().matchExpression(expr);
 
 		// Optional and greedy in order to be backward compatible.
@@ -341,6 +325,40 @@ public class BundlesAction extends AbstractPublisherAction {
 		reqsDeps.add(MetadataFactory.createRequirement(CAPABILITY_NS_OSGI_BUNDLE, requiredBundle.getName(), PublisherHelper.fromOSGiVersionRange(requiredBundle.getVersionRange()), null, optional ? 0 : 1, 1, greedy));
 	}
 
+	protected void addGenericCapability(List<IProvidedCapability> caps, GenericDescription provideCapDesc, InstallableUnitDescription iu, int capNo) {
+		String capNs = provideCapDesc.getType();
+		Map<String, Object> capAttrs = new HashMap<>(provideCapDesc.getDeclaredAttributes());
+
+		// Resolve the p2 name
+		// By convention OSGi capabilities have an attribute named like the capability namespace.
+		// If this is not the case synthesize a unique name (e.g. "osgi.service" has an "objectClass" attribute instead).
+		// TODO If present but not a String log a warning somehow that it is ignored? Or fail the publication?
+		capAttrs.compute(
+				capNs,
+				(k, v) -> (v instanceof String) ? v : String.format("%s_%s-%s", iu.getId(), iu.getVersion(), capNo)); //$NON-NLS-1$
+
+		// Convert all OSGi versions to P2 versions
+		for (String key : new HashSet<>(capAttrs.keySet())) {
+			Object val = capAttrs.get(key);
+			if (!(val instanceof org.osgi.framework.Version)) {
+				continue;
+			}
+			org.osgi.framework.Version osgiVer = (org.osgi.framework.Version) val;
+			Version p2Ver = Version.createOSGi(osgiVer.getMajor(), osgiVer.getMinor(), osgiVer.getMicro(), osgiVer.getQualifier());
+			capAttrs.put(key, p2Ver);
+		}
+
+		// Resolve the version
+		// By convention versioned OSGi capabilities have a "version" attribute containing the OSGi Version object
+		// If this is not the case use an empty version (e.g. "osgi.ee" has a list of versions).
+		// TODO If present but not a Version log a warning somehow that it is ignored? Or fail the publication?
+		capAttrs.compute(
+				CAPABILITY_ATTR_VERSION,
+				(k, v) -> (v instanceof Version) ? v : Version.emptyVersion);
+
+		caps.add(MetadataFactory.createProvidedCapability(capNs, capAttrs));
+	}
+
 	static VersionRange computeUpdateRange(org.osgi.framework.Version base) {
 		VersionRange updateRange = null;
 		if (!base.equals(org.osgi.framework.Version.emptyVersion)) {
diff --git a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
index baacf2e..26a1b0d 100644
--- a/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
+++ b/bundles/org.eclipse.equinox.p2.publisher/src/org/eclipse/equinox/p2/publisher/actions/JREAction.java
@@ -41,6 +41,7 @@ public class JREAction extends AbstractPublisherAction {
 	private static final String PROFILE_SYSTEM_PACKAGES = "org.osgi.framework.system.packages"; //$NON-NLS-1$
 
 	public static final String NAMESPACE_OSGI_EE = "osgi.ee"; //$NON-NLS-1$
+	public static final String VERSION_OSGI_EE = "version"; //$NON-NLS-1$
 
 	private File jreLocation;
 	private String environment;
@@ -224,7 +225,7 @@ public class JREAction extends AbstractPublisherAction {
 				// complete record -> store
 				Map<String, Object> capAttrs = new HashMap<>();
 				capAttrs.put(NAMESPACE_OSGI_EE, eeName);
-				capAttrs.put("version", parsedVersion); //$NON-NLS-1$
+				capAttrs.put(VERSION_OSGI_EE, parsedVersion);
 
 				parsingResult.add(MetadataFactory.createProvidedCapability(NAMESPACE_OSGI_EE, capAttrs));
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
index 752e160..6f067c0 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
@@ -176,7 +176,6 @@ public class SPIMetadataRepositoryTest extends AbstractProvisioningTest {
 	}
 
 	class SPIProvidedCapability implements IProvidedCapability {
-
 		String namespace;
 		Map<String, Object> attributes;
 
@@ -184,14 +183,12 @@ public class SPIMetadataRepositoryTest extends AbstractProvisioningTest {
 			this.namespace = namespace;
 
 			this.attributes = new HashMap<>();
-			attributes.put(ProvidedCapability.MEMBER_NAME, name);
-			attributes.put(ProvidedCapability.MEMBER_VERSION, version);
+			attributes.put(namespace, name);
+			attributes.put(ProvidedCapability.ATTRIBUTE_VERSION, version);
 		}
 
 		@Override
 		public boolean equals(Object other) {
-			if (other == null)
-				return false;
 			if (!(other instanceof IProvidedCapability))
 				return false;
 			IProvidedCapability otherCapability = (IProvidedCapability) other;
@@ -203,22 +200,23 @@ public class SPIMetadataRepositoryTest extends AbstractProvisioningTest {
 		}
 
 		@Override
+		public String toString() {
+			return namespace + "; " + attributes;
+		}
+
+		@Override
 		public String getName() {
-			return (String) attributes.get(ProvidedCapability.MEMBER_NAME);
+			return (String) attributes.get(namespace);
 		}
 
 		@Override
 		public String getNamespace() {
-			return this.namespace;
+			return namespace;
 		}
 
 		@Override
 		public Version getVersion() {
-			return (Version) attributes.get(ProvidedCapability.MEMBER_VERSION);
-		}
-
-		public boolean satisfies(IRequirement candidate) {
-			return false;
+			return (Version) attributes.get(ProvidedCapability.ATTRIBUTE_VERSION);
 		}
 
 		@Override
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
index 75eef92..f943a78 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/BundlesActionTest.java
@@ -42,8 +42,8 @@ public class BundlesActionTest extends ActionTest {
 	private static final String OSGI = PublisherHelper.OSGI_BUNDLE_CLASSIFIER;
 	private static final String OSGI_IDENTITY = "osgi.identity";
 	private static final String JAVA_PACKAGE = "java.package";//$NON-NLS-1$
-	private static final String JAVA_EE_1_4_REQ = "providedCapabilities.exists(pc | pc ~= filter('(&(namespace=osgi.ee)(|(&(osgi.ee=JavaSE)(version=1.4))(&(osgi.ee=CDC/Foundation)(version=1.1))))'))";
-	private static final String JAVA_EE_1_6_REQ = "providedCapabilities.exists(pc | pc ~= filter('(&(namespace=osgi.ee)(&(osgi.ee=JavaSE)(version=1.6)))'))";
+	private static final String JAVA_EE_1_4_REQ = "providedCapabilities.exists(pc | pc.namespace == 'osgi.ee' && pc.attributes ~= filter('(|(&(osgi.ee=JavaSE)(version=1.4))(&(osgi.ee=CDC/Foundation)(version=1.1)))'))";
+	private static final String JAVA_EE_1_6_REQ = "providedCapabilities.exists(pc | pc.namespace == 'osgi.ee' && pc.attributes ~= filter('(&(osgi.ee=JavaSE)(version=1.6))'))";
 
 	private static final String TEST1_IUD_NAME = "iud";//$NON-NLS-1$
 	private static final String TEST1_PROVZ_NAME = "iuz";//$NON-NLS-1$
