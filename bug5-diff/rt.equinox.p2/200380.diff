commit ea5a3f9fc6a086a5e1fb4616236dfe077ea3c6b6
Author: Pascal Rapicault <prapicau>
Date:   Fri Feb 27 22:58:20 2009 +0000

    Bug 200380 - [planner] Improve detection of incompatible solution

2	2	bundles/org.eclipse.equinox.p2.director/.classpath
7	9	bundles/org.eclipse.equinox.p2.director/.settings/org.eclipse.jdt.core.prefs
3	4	bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
161	0	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Explanation.java
3	3	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
419	462	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
4	2	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Recommendation.java
37	42	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
1	1	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/TwoTierMap.java
8	2	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/ProvisioningPlan.java
53	2	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/RequestStatus.java
22	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/AllExplanation.java
4	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/AllTests.java
54	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationDeepConflict.java
57	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationForOptionalDependencies.java
86	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationForPartialInstallation.java
104	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationSeveralConflictingRoots.java
18	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingDependency.java
13	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingNonGreedyRequirement.java
14	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingNonGreedyRequirement2.java
44	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MultipleSingleton.java
15	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest10.java
12	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest12.java
28	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest2.java
14	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest6.java
14	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest9.java
16	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate.java
6	6	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ProvisioningPlanQueryTest.java
11	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SimpleSingleton.java
diff --git a/bundles/org.eclipse.equinox.p2.director/.classpath b/bundles/org.eclipse.equinox.p2.director/.classpath
index 7cdeb73..64c5e31 100644
--- a/bundles/org.eclipse.equinox.p2.director/.classpath
+++ b/bundles/org.eclipse.equinox.p2.director/.classpath
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/CDC-1.1%Foundation-1.1"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/bundles/org.eclipse.equinox.p2.director/.settings/org.eclipse.jdt.core.prefs b/bundles/org.eclipse.equinox.p2.director/.settings/org.eclipse.jdt.core.prefs
index 78523cd..8dd4765 100644
--- a/bundles/org.eclipse.equinox.p2.director/.settings/org.eclipse.jdt.core.prefs
+++ b/bundles/org.eclipse.equinox.p2.director/.settings/org.eclipse.jdt.core.prefs
@@ -1,4 +1,4 @@
-#Thu Aug 16 11:00:59 EDT 2007
+#Fri Feb 27 17:27:15 EST 2009
 eclipse.preferences.version=1
 org.eclipse.jdt.core.builder.cleanOutputFolder=clean
 org.eclipse.jdt.core.builder.duplicateResourceTask=warning
@@ -7,24 +7,24 @@ org.eclipse.jdt.core.builder.resourceCopyExclusionFilter=*.launch
 org.eclipse.jdt.core.circularClasspath=error
 org.eclipse.jdt.core.classpath.exclusionPatterns=enabled
 org.eclipse.jdt.core.classpath.multipleOutputLocations=enabled
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=disabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.2
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
 org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.4
+org.eclipse.jdt.core.compiler.compliance=1.5
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
 org.eclipse.jdt.core.compiler.doc.comment.support=enabled
 org.eclipse.jdt.core.compiler.maxProblemPerUnit=1000
 org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=warning
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
 org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
 org.eclipse.jdt.core.compiler.problem.deprecation=warning
 org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
 org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=enabled
 org.eclipse.jdt.core.compiler.problem.discouragedReference=error
 org.eclipse.jdt.core.compiler.problem.emptyStatement=warning
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=warning
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
 org.eclipse.jdt.core.compiler.problem.fieldHiding=warning
 org.eclipse.jdt.core.compiler.problem.finalParameterBound=ignore
 org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
@@ -62,7 +62,6 @@ org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.unnecessaryElse=warning
 org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=warning
 org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
-org.eclipse.jdt.core.compiler.problem.unsafeTypeOperation=warning
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=warning
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=enabled
 org.eclipse.jdt.core.compiler.problem.unusedImport=error
@@ -72,7 +71,7 @@ org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=en
 org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=enabled
 org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=error
 org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
-org.eclipse.jdt.core.compiler.source=1.3
+org.eclipse.jdt.core.compiler.source=1.5
 org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
@@ -144,7 +143,6 @@ org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
 org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
 org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=true
 org.eclipse.jdt.core.formatter.indentation.size=4
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation=insert
 org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
diff --git a/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
index 0432bc8..7632ca2 100644
--- a/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
@@ -35,8 +35,7 @@ Export-Package: org.eclipse.equinox.internal.p2.director;x-friends:="org.eclipse
    org.eclipse.pde.ui"
 Bundle-Activator: org.eclipse.equinox.internal.p2.director.DirectorActivator
 Eclipse-LazyStart: true
-Bundle-RequiredExecutionEnvironment: CDC-1.1/Foundation-1.1,
- J2SE-1.4
+Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Require-Bundle: org.eclipse.equinox.common;bundle-version="[3.5.0,4.0.0)",
- org.sat4j.core;bundle-version="2.0.0",
- org.sat4j.pb;bundle-version="2.0.0"
+ org.sat4j.core;bundle-version="2.1.0",
+ org.sat4j.pb;bundle-version="2.1.0"
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Explanation.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Explanation.java
new file mode 100644
index 0000000..34305b0
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Explanation.java
@@ -0,0 +1,161 @@
+package org.eclipse.equinox.internal.p2.director;
+
+import java.util.Arrays;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+
+public abstract class Explanation implements Comparable<Explanation> {
+
+	private static final String HARD_DEPENDENCY = "Hard Dependency";
+	private static final String OPTIONAL_DEPENDENCY = "Optional Dependency";
+	private static final String SINGLETON_CONSTRAINT = "Singleton Constraint";
+	private static final String IU_TO_INSTALL = "IU to install";
+	private static final String IU_INSTALLED = "IU already installed";
+	private static final String IU_MISSING = "Missing Requirement";
+
+	public static final int MISSING_REQUIREMENT = 1;
+	public static final int VIOLATED_SINGLETON_CONSTRAINT = 2;
+
+	private Explanation() {
+		// no instance of that class for the moment
+	}
+
+	protected abstract int orderValue();
+
+	public int shortAnswer() {
+		throw new UnsupportedOperationException();
+	}
+
+	public static class IUToInstall extends Explanation {
+		public final IInstallableUnit iu;
+
+		public IUToInstall(IInstallableUnit iu) {
+			this.iu = iu;
+		}
+
+		public String toString() {
+			return IU_TO_INSTALL + ":" + iu;
+		}
+
+		@Override
+		public int orderValue() {
+			return 1;
+		}
+	}
+
+	public static class IUInstalled extends Explanation {
+		public final IInstallableUnit iu;
+
+		public IUInstalled(IInstallableUnit iu) {
+			this.iu = iu;
+		}
+
+		public String toString() {
+			return IU_INSTALLED + ":" + iu;
+		}
+
+		@Override
+		public int orderValue() {
+			return 2;
+		}
+	}
+
+	public static class MissingIU extends Explanation {
+		public final IInstallableUnit iu;
+		public final IRequiredCapability req;
+
+		public MissingIU(IInstallableUnit iu, IRequiredCapability req) {
+			this.iu = iu;
+			this.req = req;
+		}
+
+		public String toString() {
+			return IU_MISSING + ":" + iu + " missing required " + req;
+		}
+
+		@Override
+		public int orderValue() {
+			return 3;
+		}
+
+		@Override
+		public int shortAnswer() {
+			return MISSING_REQUIREMENT;
+		}
+
+	}
+
+	public static class Singleton extends Explanation {
+		public final IInstallableUnit[] ius;
+
+		public Singleton(IInstallableUnit[] ius) {
+			this.ius = ius;
+		}
+
+		public String toString() {
+			return SINGLETON_CONSTRAINT + ":" + Arrays.asList(ius);
+		}
+
+		@Override
+		public int orderValue() {
+			return 4;
+		}
+
+		@Override
+		public int shortAnswer() {
+			return VIOLATED_SINGLETON_CONSTRAINT;
+		}
+	}
+
+	public static class HardRequirement extends Explanation {
+		public final IInstallableUnit iu;
+		public final IRequiredCapability req;
+		public final IInstallableUnitPatch patch;
+
+		public HardRequirement(IInstallableUnit iu, IRequiredCapability req) {
+			this.iu = iu;
+			this.req = req;
+			this.patch = null;
+		}
+
+		public HardRequirement(IInstallableUnit iu, IInstallableUnitPatch patch) {
+			this.iu = iu;
+			this.req = null;
+			this.patch = patch;
+		}
+
+		public HardRequirement(IInstallableUnit iu, IRequiredCapability req, IInstallableUnitPatch patch) {
+			this.iu = iu;
+			this.req = req;
+			this.patch = patch;
+		}
+
+		public String toString() {
+			return HARD_DEPENDENCY + ":" + (patch == null ? "" : patch.toString() + " ") + iu + "-> " + req;
+		}
+
+		@Override
+		public int orderValue() {
+			return 5;
+		}
+	}
+
+	public static final Explanation OPTIONAL_REQUIREMENT = new Explanation() {
+
+		public String toString() {
+			return OPTIONAL_DEPENDENCY;
+		}
+
+		@Override
+		public int orderValue() {
+			// TODO Auto-generated method stub
+			return 6;
+		}
+	};
+
+	public int compareTo(Explanation arg0) {
+		if (this.orderValue() == arg0.orderValue()) {
+			return this.toString().compareTo(arg0.toString());
+		}
+		return this.orderValue() - arg0.orderValue();
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
index 66fbc4a..6e57266 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
@@ -28,7 +28,7 @@ import org.osgi.framework.InvalidSyntaxException;
  */
 public class NewDependencyExpander {
 
-	private class Match {
+	private static class Match {
 		/**
 		 * The {@link IInstallableUnit}s satisfying this requirement.
 		 */
@@ -59,7 +59,7 @@ public class NewDependencyExpander {
 	/**
 	 * Represents a requirement name in the map of required capabilities.
 	 */
-	private class MatchKey {
+	private static class MatchKey {
 		String name;
 		String namespace;
 
@@ -85,7 +85,7 @@ public class NewDependencyExpander {
 	}
 
 	// Installable units that are optional have a dependency on themselves.
-	private class OptionalInstallableUnit implements IInstallableUnit {
+	private static class OptionalInstallableUnit implements IInstallableUnit {
 		private boolean optionalReqs;
 		private IInstallableUnit wrapped;
 
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
index d728942..0a1816b 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
@@ -3,14 +3,15 @@
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
- * 
+ *
  * Contributors: IBM Corporation - initial API and implementation
- * 	Daniel Le Berre - Fix in the encoding and the optimization function
+ * Daniel Le Berre - Fix in the encoding and the optimization function
  * Alban Browaeys - Optimized string concatenation in bug 251357
+ * Jed Anderson - switch from opb files to API calls to DependencyHelper in bug 200380
  ******************************************************************************/
 package org.eclipse.equinox.internal.p2.director;
 
-import java.io.*;
+import java.math.BigInteger;
 import java.util.*;
 import java.util.Map.Entry;
 import org.eclipse.core.runtime.*;
@@ -24,8 +25,8 @@ import org.eclipse.osgi.util.NLS;
 import org.osgi.framework.InvalidSyntaxException;
 import org.sat4j.pb.IPBSolver;
 import org.sat4j.pb.SolverFactory;
-import org.sat4j.pb.reader.OPBEclipseReader2007;
-import org.sat4j.reader.ParseFormatException;
+import org.sat4j.pb.tools.DependencyHelper;
+import org.sat4j.pb.tools.WeightedObject;
 import org.sat4j.specs.*;
 
 /**
@@ -35,52 +36,61 @@ import org.sat4j.specs.*;
  */
 public class Projector {
 	private static boolean DEBUG = Tracing.DEBUG_PLANNER_PROJECTOR;
+	private static boolean DEBUG_ENCODING = false;
 	private IQueryable picker;
+	private QueryableArray patches;
 
-	private Map variables; //key IU, value corresponding variable in the problem
-	private Map noopVariables; //key IU, value corresponding no optionality variable in the problem, 
+	private Map noopVariables; //key IU, value AbstractVariable
 	private List abstractVariables;
 
 	private TwoTierMap slice; //The IUs that have been considered to be part of the problem
 
 	private Dictionary selectionContext;
 
-	private int varCount = 1;
-
-	private ArrayList constraints;
-	private ArrayList dependencies;
-	private ArrayList tautologies;
-	private StringBuffer objective;
-	private StringBuffer explanation = new StringBuffer("explain: "); //$NON-NLS-1$
+	private DependencyHelper dependencyHelper;
 	private Collection solution;
+	private Collection assumptions;
 
-	private File problemFile;
 	private MultiStatus result;
 
-	private int commentsCount = 0;
+	private Collection alreadyInstalledIUs;
+
+	static class AbstractVariable {
+		@Override
+		public String toString() {
+			return "AbstractVariable: " + hashCode();
+		}
+	}
 
 	public Projector(IQueryable q, Dictionary context) {
 		picker = q;
-		variables = new HashMap();
 		noopVariables = new HashMap();
 		slice = new TwoTierMap();
-		constraints = new ArrayList();
-		tautologies = new ArrayList();
-		dependencies = new ArrayList();
 		selectionContext = context;
 		abstractVariables = new ArrayList();
 		result = new MultiStatus(DirectorActivator.PI_DIRECTOR, IStatus.OK, Messages.Planner_Problems_resolving_plan, null);
+		assumptions = new ArrayList();
 	}
 
-	public void encode(IInstallableUnit[] ius, IProgressMonitor monitor) {
+	public void encode(IInstallableUnit metaIu, IInstallableUnit[] alreadyExistingRoots, IInstallableUnit[] newRoots, IProgressMonitor monitor) {
+		alreadyInstalledIUs = Arrays.asList(alreadyExistingRoots);
 		try {
 			long start = 0;
 			if (DEBUG) {
 				start = System.currentTimeMillis();
 				Tracing.debug("Start projection: " + start); //$NON-NLS-1$
 			}
+			IPBSolver solver;
+			if (DEBUG_ENCODING) {
+				solver = SolverFactory.newOPBStringSolver();
+			} else {
+				solver = SolverFactory.newEclipseP2();
+			}
+			solver.setTimeoutOnConflicts(1000);
+			Collector collector = picker.query(InstallableUnitQuery.ANY, new Collector(), null);
+			dependencyHelper = new DependencyHelper(solver);
 
-			Iterator iusToEncode = picker.query(InstallableUnitQuery.ANY, new Collector(), null).iterator();
+			Iterator iusToEncode = collector.iterator();
 			if (DEBUG) {
 				List iusToOrder = new ArrayList();
 				while (iusToEncode.hasNext()) {
@@ -94,41 +104,39 @@ public class Projector {
 					result.merge(Status.CANCEL_STATUS);
 					throw new OperationCanceledException();
 				}
-				processIU((IInstallableUnit) iusToEncode.next());
+				IInstallableUnit iuToEncode = (IInstallableUnit) iusToEncode.next();
+				if (iuToEncode != metaIu) {
+					processIU(iuToEncode, false);
+				}
 			}
 			createConstraintsForSingleton();
-			for (int i = 0; i < ius.length; i++) {
-				createMustHaves(ius[i]);
-			}
-			createOptimizationFunction(ius);
-			persist();
+
+			createMustHave(metaIu, alreadyExistingRoots, newRoots);
+
+			createOptimizationFunction(metaIu);
 			if (DEBUG) {
 				long stop = System.currentTimeMillis();
 				Tracing.debug("Projection complete: " + (stop - start)); //$NON-NLS-1$
 			}
+			if (DEBUG_ENCODING) {
+				System.out.println(solver.toString());
+			}
 		} catch (IllegalStateException e) {
 			result.add(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, e.getMessage(), e));
+		} catch (ContradictionException e) {
+			result.add(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, Messages.Planner_Unsatisfiable_problem));
 		}
 	}
 
-	// translates a -> -b into pseudo boolean
-	private String impliesNo(String a, String b) {
-		return "-1 " + a + " -1 " + b + ">= -1 ;"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-	}
-
-	private String implies(String a, String b) {
-		return "-1 " + a + " +1 " + b + ">= -1 ;"; //$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$
-	}
+	//Create an optimization function favoring the highest version of each IU
+	private void createOptimizationFunction(IInstallableUnit metaIu) {
 
-	//Create an optimization function favoring the highest version of each IU  
-	private void createOptimizationFunction(IInstallableUnit[] ius) {
-		final String MIN_STR = "min:"; //$NON-NLS-1$
+		List weightedObjects = new ArrayList();
 
-		objective = new StringBuffer(MIN_STR);
 		Set s = slice.entrySet();
-		final int POWER = 2;
+		final BigInteger POWER = BigInteger.valueOf(2);
 
-		long maxWeight = POWER;
+		BigInteger maxWeight = POWER;
 		for (Iterator iterator = s.iterator(); iterator.hasNext();) {
 			Map.Entry entry = (Map.Entry) iterator.next();
 			HashMap conflictingEntries = (HashMap) entry.getValue();
@@ -137,66 +145,81 @@ public class Projector {
 			}
 			List toSort = new ArrayList(conflictingEntries.values());
 			Collections.sort(toSort, Collections.reverseOrder());
-			long weight = POWER;
+			BigInteger weight = BigInteger.ONE;
 			int count = toSort.size();
-			for (int i = 1; i < count; i++) {
-				objective.append(' ').append(weight).append(' ').append(getVariable((IInstallableUnit) toSort.get(i)));
-				weight *= POWER;
+			for (int i = 0; i < count; i++) {
+				weightedObjects.add(WeightedObject.newWO(toSort.get(i), weight));
+				weight = weight.multiply(POWER);
 			}
-			if (weight > maxWeight)
+			if (weight.compareTo(maxWeight) > 0)
 				maxWeight = weight;
 		}
 
-		maxWeight *= POWER;
+		maxWeight = maxWeight.multiply(POWER);
 
+		// Weight the no-op variables beneath the abstract variables
 		for (Iterator iterator = noopVariables.values().iterator(); iterator.hasNext();) {
-			objective.append(' ').append(maxWeight).append(' ').append(iterator.next().toString());
+			weightedObjects.add(WeightedObject.newWO(iterator.next(), maxWeight));
 		}
 
-		maxWeight *= POWER;
+		maxWeight = maxWeight.multiply(POWER);
 
-		//Add the abstract variables
+		// Add the abstract variables
+		BigInteger abstractWeight = maxWeight.negate();
 		for (Iterator iterator = abstractVariables.iterator(); iterator.hasNext();) {
-			objective.append(" -").append(maxWeight).append(" ").append((String) iterator.next()); //$NON-NLS-1$ //$NON-NLS-2$
+			weightedObjects.add(WeightedObject.newWO(iterator.next(), abstractWeight));
 		}
 
-		maxWeight *= POWER;
-		objective.append(' ').append(getPatchesWeight(ius, maxWeight));
-
-		if (MIN_STR.equals(objective.toString().trim())) {
-			objective = new StringBuffer();
-		} else {
-			objective.append(" ;"); //$NON-NLS-1$
-		}
-	}
+		maxWeight = maxWeight.multiply(POWER);
 
-	protected StringBuffer getPatchesWeight(IInstallableUnit ius[], long weight) {
-		StringBuffer patchesWeight = new StringBuffer();
-		if (patches == null)
-			return patchesWeight;
-		for (int i = 0; i < ius.length; i++) {
-			IRequiredCapability[] reqs = ius[i].getRequiredCapabilities();
+		BigInteger patchWeight = maxWeight.negate();
+		if (patches != null) {
+			IRequiredCapability[] reqs = metaIu.getRequiredCapabilities();
 			for (int j = 0; j < reqs.length; j++) {
 				Collector matches = patches.query(new CapabilityQuery(reqs[j]), new Collector(), null);
 				for (Iterator iterator = matches.iterator(); iterator.hasNext();) {
 					IInstallableUnitPatch match = (IInstallableUnitPatch) iterator.next();
-					patchesWeight.append('-').append(weight).append(' ').append(getVariable(match)).append(' ');
+					weightedObjects.add(WeightedObject.newWO(match, patchWeight));
 				}
 			}
+
+		}
+
+		if (!weightedObjects.isEmpty()) {
+			createObjectiveFunction(weightedObjects);
 		}
-		return patchesWeight;
 	}
 
-	private void createMustHaves(IInstallableUnit iu) {
-		tautologies.add(" +1 " + getVariable(iu) + " = 1;"); //$NON-NLS-1$ //$NON-NLS-2$
+	private void createObjectiveFunction(List weightedObjects) {
+		if (DEBUG) {
+			StringBuffer b = new StringBuffer();
+			for (Iterator i = weightedObjects.iterator(); i.hasNext();) {
+				WeightedObject object = (WeightedObject) i.next();
+				if (b.length() > 0)
+					b.append(", "); //$NON-NLS-1$
+				b.append(object.getWeight());
+				b.append(' ');
+				b.append(object.thing);
+			}
+			Tracing.debug("objective function: " + b);
+		}
+		dependencyHelper.setObjectiveFunction((WeightedObject[]) weightedObjects.toArray(new WeightedObject[weightedObjects.size()]));
 	}
 
-	private void createNegation(IInstallableUnit iu) {
-		createNegation(getVariable(iu));
+	private void createMustHave(IInstallableUnit iu, IInstallableUnit[] alreadyExistingRoots, IInstallableUnit[] newRoots) throws ContradictionException {
+		processIU(iu, true);
+		if (DEBUG) {
+			Tracing.debug(iu + "=1"); //$NON-NLS-1$
+		}
+		// dependencyHelper.setTrue(variable, new Explanation.IUToInstall(iu));
+		assumptions.add(iu);
 	}
 
-	private void createNegation(String var) {
-		tautologies.add(" +1" + var + " = 0;"); //$NON-NLS-1$//$NON-NLS-2$
+	private void createNegation(IInstallableUnit iu, IRequiredCapability req) throws ContradictionException {
+		if (DEBUG) {
+			Tracing.debug(iu + "=0"); //$NON-NLS-1$
+		}
+		dependencyHelper.setFalse(iu, new Explanation.MissingIU(iu, req));
 	}
 
 	// Check whether the requirement is applicable
@@ -211,97 +234,6 @@ public class Projector {
 		}
 	}
 
-	//Write the problem generated into a temporary file
-	private void persist() {
-		try {
-			problemFile = File.createTempFile("p2Encoding", ".opb"); //$NON-NLS-1$//$NON-NLS-2$
-			BufferedWriter w = new BufferedWriter(new FileWriter(problemFile));
-			int clauseCount = tautologies.size() + dependencies.size() + constraints.size() - commentsCount;
-
-			w.write("* #variable= " + varCount + " #constraint= " + clauseCount + "  "); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-			w.newLine();
-			w.write("*"); //$NON-NLS-1$
-			w.newLine();
-			displayMappingInComments(w);
-			if (clauseCount == 0) {
-				w.close();
-				return;
-			}
-			w.write(objective.toString());
-			w.newLine();
-			w.newLine();
-			w.write(explanation + " ;"); //$NON-NLS-1$
-			w.newLine();
-			w.newLine();
-
-			for (Iterator iterator = dependencies.iterator(); iterator.hasNext();) {
-				w.write((String) iterator.next());
-				w.newLine();
-			}
-			for (Iterator iterator = constraints.iterator(); iterator.hasNext();) {
-				w.write((String) iterator.next());
-				w.newLine();
-			}
-			for (Iterator iterator = tautologies.iterator(); iterator.hasNext();) {
-				w.write((String) iterator.next());
-				w.newLine();
-			}
-			w.close();
-		} catch (IOException e) {
-			result.add(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Planner_Error_saving_opbfile, problemFile), e));
-		}
-	}
-
-	private void displayMappingInComments(BufferedWriter w) throws IOException {
-		if (!DEBUG)
-			return;
-		List vars = new ArrayList(variables.keySet());
-		Collections.sort(vars);
-		w.write("* IUs variables"); //$NON-NLS-1$
-		w.newLine();
-		w.write("* "); //$NON-NLS-1$
-		w.newLine();
-		Iterator iterator = vars.iterator();
-		while (iterator.hasNext()) {
-			w.write("* "); //$NON-NLS-1$
-			Object key = iterator.next();
-			w.write(key.toString());
-			w.write("=>"); //$NON-NLS-1$
-			w.write(variables.get(key).toString());
-			w.newLine();
-		}
-		w.write("* "); //$NON-NLS-1$
-		w.newLine();
-		w.write("* Abstract variables"); //$NON-NLS-1$
-		w.newLine();
-		w.write("* "); //$NON-NLS-1$
-		w.newLine();
-		iterator = abstractVariables.iterator();
-		w.write("* "); //$NON-NLS-1$
-		while (iterator.hasNext()) {
-			w.write(iterator.next().toString());
-			w.write(' ');
-		}
-		w.newLine();
-		w.write("* "); //$NON-NLS-1$
-		w.newLine();
-		w.write("* NoOp variables"); //$NON-NLS-1$
-		w.newLine();
-		w.write("* "); //$NON-NLS-1$
-		w.newLine();
-		iterator = noopVariables.keySet().iterator();
-		while (iterator.hasNext()) {
-			w.write("* "); //$NON-NLS-1$
-			Object key = iterator.next();
-			w.write(key.toString());
-			w.write("=>"); //$NON-NLS-1$
-			w.write(noopVariables.get(key).toString());
-			w.newLine();
-		}
-		w.write("* "); //$NON-NLS-1$
-		w.newLine();
-	}
-
 	private boolean isApplicable(IInstallableUnit iu) {
 		String enablementFilter = iu.getFilter();
 		if (enablementFilter == null)
@@ -313,101 +245,241 @@ public class Projector {
 		}
 	}
 
-	public void processIU(IInstallableUnit iu) {
+	private void expandRequirement(IRequiredCapability req, IInstallableUnit iu, List optionalAbstractRequirements, boolean isRootIu) throws ContradictionException {
+		if (!isApplicable(req))
+			return;
+		List matches = getApplicableMatches(req);
+		if (!req.isOptional()) {
+			if (matches.isEmpty()) {
+				missingRequirement(iu, req);
+			} else {
+				IInstallableUnit reqIu = (IInstallableUnit) picker.query(new CapabilityQuery(req), new Collector(), null).iterator().next();
+				Explanation explanation;
+				if (isRootIu) {
+					if (alreadyInstalledIUs.contains(reqIu)) {
+						explanation = new Explanation.IUInstalled(reqIu);
+					} else {
+						explanation = new Explanation.IUToInstall(reqIu);
+					}
+				} else {
+					explanation = new Explanation.HardRequirement(iu, req);
+				}
+				createImplication(iu, matches, explanation);
+			}
+		} else {
+			if (!matches.isEmpty()) {
+				AbstractVariable abs = getAbstractVariable();
+				createImplication(abs, matches, Explanation.OPTIONAL_REQUIREMENT);
+				optionalAbstractRequirements.add(abs);
+			}
+		}
+	}
+
+	private void expandRequirements(IRequiredCapability[] reqs, IInstallableUnit iu, boolean isRootIu) throws ContradictionException {
+		if (reqs.length == 0) {
+			return;
+		}
+		List optionalAbstractRequirements = new ArrayList();
+		for (int i = 0; i < reqs.length; i++) {
+			expandRequirement(reqs[i], iu, optionalAbstractRequirements, isRootIu);
+		}
+		createOptionalityExpression(iu, optionalAbstractRequirements);
+	}
+
+	public void processIU(IInstallableUnit iu, boolean isRootIU) throws ContradictionException {
 		iu = iu.unresolved();
 
 		slice.put(iu.getId(), iu.getVersion(), iu);
-		explanation.append(" ").append(getVariable(iu)); //$NON-NLS-1$
 		if (!isApplicable(iu)) {
-			createNegation(iu);
+			createNegation(iu, null);
 			return;
 		}
 
 		Collector patches = getApplicablePatches(iu);
-		expandLifeCycle(iu);
+		expandLifeCycle(iu, isRootIU);
 		//No patches apply, normal code path
 		if (patches.size() == 0) {
-			IRequiredCapability[] reqs = iu.getRequiredCapabilities();
-			if (reqs.length == 0) {
-				return;
-			}
-			for (int i = 0; i < reqs.length; i++) {
-				if (!isApplicable(reqs[i]))
-					continue;
-
-				expandRequirement(null, iu, reqs[i]);
-			}
-			addOptionalityExpression();
+			expandRequirements(iu.getRequiredCapabilities(), iu, isRootIU);
 		} else {
 			//Patches are applicable to the IU
+			expandRequirementsWithPatches(iu, patches, isRootIU);
+		}
+	}
 
-			//Unmodified dependencies
-			Map unchangedRequirements = new HashMap(iu.getRequiredCapabilities().length);
-			for (Iterator iterator = patches.iterator(); iterator.hasNext();) {
-				IInstallableUnitPatch patch = (IInstallableUnitPatch) iterator.next();
-				IRequiredCapability[][] reqs = mergeRequirements(iu, patch);
-				if (reqs.length == 0)
-					return;
-
-				for (int i = 0; i < reqs.length; i++) {
-					//The requirement is unchanged
-					if (reqs[i][0] == reqs[i][1]) {
-						if (!isApplicable(reqs[i][0]))
-							continue;
-
-						List patchesAppliedElseWhere = (List) unchangedRequirements.get(reqs[i][0]);
-						if (patchesAppliedElseWhere == null) {
-							patchesAppliedElseWhere = new ArrayList();
-							unchangedRequirements.put(reqs[i][0], patchesAppliedElseWhere);
-						}
-						patchesAppliedElseWhere.add(patch);
+	private void expandRequirementsWithPatches(IInstallableUnit iu, Collector patches, boolean isRootIu) throws ContradictionException {
+		//Unmodified dependencies
+		Map unchangedRequirements = new HashMap(iu.getRequiredCapabilities().length);
+		for (Iterator iterator = patches.iterator(); iterator.hasNext();) {
+			IInstallableUnitPatch patch = (IInstallableUnitPatch) iterator.next();
+			IRequiredCapability[][] reqs = mergeRequirements(iu, patch);
+			if (reqs.length == 0)
+				return;
+
+			// Optional requirements are encoded via:
+			// ABS -> (match1(req) or match2(req) or ... or matchN(req))
+			// noop(IU)-> ~ABS
+			// IU -> (noop(IU) or ABS)
+			// Therefore we only need one optional requirement statement per IU
+			List optionalAbstractRequirements = new ArrayList();
+			for (int i = 0; i < reqs.length; i++) {
+				//The requirement is unchanged
+				if (reqs[i][0] == reqs[i][1]) {
+					if (!isApplicable(reqs[i][0]))
 						continue;
+
+					List patchesAppliedElseWhere = (List) unchangedRequirements.get(reqs[i][0]);
+					if (patchesAppliedElseWhere == null) {
+						patchesAppliedElseWhere = new ArrayList();
+						unchangedRequirements.put(reqs[i][0], patchesAppliedElseWhere);
 					}
+					patchesAppliedElseWhere.add(patch);
+					continue;
+				}
 
-					//Generate dependency when the patch is applied
-					//P1 -> A -> D (equiv P1 & A -> D equiv -1 P1 -1 A + 1 B >= -1)
-					if (isApplicable(reqs[i][1])) {
-						genericExpandRequirement(" -1 " + getVariable(patch) + " -1 " + getVariable(iu), iu, reqs[i][1], " >= -1", " 1 " + getVariable(patch) + "=0;"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$
+				//Generate dependency when the patch is applied
+				//P1 -> (A -> D) equiv. (P1 & A) -> D
+				if (isApplicable(reqs[i][1])) {
+					IRequiredCapability req = reqs[i][1];
+					List matches = getApplicableMatches(req);
+					if (!req.isOptional()) {
+						if (matches.isEmpty()) {
+							missingRequirement(patch, req);
+						} else {
+							IInstallableUnit reqIu = (IInstallableUnit) picker.query(new CapabilityQuery(req), new Collector(), null).iterator().next();
+							Explanation explanation;
+							if (isRootIu) {
+								if (alreadyInstalledIUs.contains(reqIu)) {
+									explanation = new Explanation.IUInstalled(reqIu);
+								} else {
+									explanation = new Explanation.IUToInstall(reqIu);
+								}
+							} else {
+								explanation = new Explanation.HardRequirement(iu, req, patch);
+							}
+							createImplication(new Object[] {patch, iu}, matches, explanation);
+						}
+					} else {
+						if (!matches.isEmpty()) {
+							AbstractVariable abs = getAbstractVariable();
+							createImplication(new Object[] {patch, abs}, matches, Explanation.OPTIONAL_REQUIREMENT);
+							optionalAbstractRequirements.add(abs);
+						}
+					}
+				}
+				//Generate dependency when the patch is not applied
+				//-P1 -> (A -> B) ( equiv. A -> (P1 or B) )
+				if (isApplicable(reqs[i][0])) {
+					IRequiredCapability req = reqs[i][0];
+					List matches = getApplicableMatches(req);
+					if (!req.isOptional()) {
+						if (matches.isEmpty()) {
+							dependencyHelper.implication(iu).implies(patch).named(new Explanation.HardRequirement(iu, (IInstallableUnitPatch) null));
+						} else {
+							matches.add(patch);
+							IInstallableUnit reqIu = (IInstallableUnit) picker.query(new CapabilityQuery(req), new Collector(), null).iterator().next();
+
+							Explanation explanation;
+							if (isRootIu) {
+								if (alreadyInstalledIUs.contains(reqIu)) {
+									explanation = new Explanation.IUInstalled(reqIu);
+								} else {
+									explanation = new Explanation.IUToInstall(reqIu);
+								}
+							} else {
+								explanation = new Explanation.HardRequirement(iu, req);
+							}
+							createImplication(iu, matches, explanation);
+						}
+					} else {
+						if (!matches.isEmpty()) {
+							AbstractVariable abs = getAbstractVariable();
+							optionalAbstractRequirements.add(patch);
+							createImplication(abs, matches, Explanation.OPTIONAL_REQUIREMENT);
+							optionalAbstractRequirements.add(abs);
+						}
 					}
-					//Generate dependency when the patch is not applied
-					//-P1 -> A -> B ( equiv. -P1 & A -> B equiv 1 P1 - 1 A + 1 B >= 0)
-					if (isApplicable(reqs[i][0]))
-						genericExpandRequirement(" 1 " + getVariable(patch) + " -1 " + getVariable(iu), iu, reqs[i][0], " >= 0", implies(getVariable(iu), getVariable(patch))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
 				}
-				addOptionalityExpression();
 			}
-			for (Iterator iterator = unchangedRequirements.entrySet().iterator(); iterator.hasNext();) {
-				Entry entry = (Entry) iterator.next();
-				StringBuffer expression = new StringBuffer();
-				List patchesApplied = (List) entry.getValue();
-				List allPatches = new ArrayList(patches.toCollection());
-				allPatches.removeAll(patchesApplied);
-				for (Iterator iterator2 = allPatches.iterator(); iterator2.hasNext();) {
-					IInstallableUnitPatch patch = (IInstallableUnitPatch) iterator2.next();
-					expression.append(" 1 " + getVariable(patch)); //$NON-NLS-1$
+			createOptionalityExpression(iu, optionalAbstractRequirements);
+		}
+		List optionalAbstractRequirements = new ArrayList();
+		for (Iterator iterator = unchangedRequirements.entrySet().iterator(); iterator.hasNext();) {
+			Entry entry = (Entry) iterator.next();
+			List patchesApplied = (List) entry.getValue();
+			List allPatches = new ArrayList(patches.toCollection());
+			allPatches.removeAll(patchesApplied);
+			List requiredPatches = new ArrayList();
+			for (Iterator iterator2 = allPatches.iterator(); iterator2.hasNext();) {
+				IInstallableUnitPatch patch = (IInstallableUnitPatch) iterator2.next();
+				requiredPatches.add(patch);
+			}
+			IRequiredCapability req = (IRequiredCapability) entry.getKey();
+			List matches = getApplicableMatches(req);
+			if (!req.isOptional()) {
+				if (matches.isEmpty()) {
+					missingRequirement(iu, req);
+				} else {
+					if (!requiredPatches.isEmpty())
+						matches.addAll(requiredPatches);
+					IInstallableUnit reqIu = (IInstallableUnit) picker.query(new CapabilityQuery(req), new Collector(), null).iterator().next();
+					Explanation explanation;
+					if (isRootIu) {
+						if (alreadyInstalledIUs.contains(reqIu)) {
+							explanation = new Explanation.IUInstalled(reqIu);
+						} else {
+							explanation = new Explanation.IUToInstall(reqIu);
+						}
+					} else {
+						explanation = new Explanation.HardRequirement(iu, req);
+					}
+					createImplication(iu, matches, explanation);
+				}
+			} else {
+				if (!matches.isEmpty()) {
+					if (!requiredPatches.isEmpty())
+						matches.addAll(requiredPatches);
+					AbstractVariable abs = getAbstractVariable();
+					createImplication(abs, matches, Explanation.OPTIONAL_REQUIREMENT);
+					optionalAbstractRequirements.add(abs);
 				}
-				if (allPatches.size() != 0)
-					genericExpandRequirement(expression.toString(), iu, (IRequiredCapability) entry.getKey(), " >= 0", " 1 " + getVariable(iu) + "=0;"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-				else
-					expandRequirement(null, iu, (IRequiredCapability) entry.getKey());
 			}
 		}
+		createOptionalityExpression(iu, optionalAbstractRequirements);
 	}
 
-	private void expandLifeCycle(IInstallableUnit iu) {
+	private void expandLifeCycle(IInstallableUnit iu, boolean isRootIu) throws ContradictionException {
 		if (!(iu instanceof IInstallableUnitPatch))
 			return;
 		IInstallableUnitPatch patch = (IInstallableUnitPatch) iu;
-		if (patch.getLifeCycle() == null)
+		IRequiredCapability req = patch.getLifeCycle();
+		if (req == null)
 			return;
-		expandNormalRequirement(null, iu, patch.getLifeCycle());
+		expandRequirement(req, iu, Collections.EMPTY_LIST, isRootIu);
 	}
 
-	private void genericExpandRequirement(String var, IInstallableUnit iu, IRequiredCapability req, String value, String negationExpression) {
-		if (req.isOptional())
-			genericOptionalRequirementExpansion(var, iu, req, value);
-		else
-			genericRequirementExpansion(var, iu, req, value, negationExpression);
+	private void missingRequirement(IInstallableUnit iu, IRequiredCapability req) throws ContradictionException {
+		result.add(new Status(IStatus.WARNING, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Planner_Unsatisfied_dependency, iu, req)));
+		createNegation(iu, req);
+	}
+
+	/**
+	 *
+	 * @param iu
+	 * @param req
+	 * @param expandedOptionalRequirement a collector list to gather optional requirements. It will be updated
+	 *        if req.isOptional()
+	 * @return a list of mandatory requirements if any, an empty list if req.isOptional().
+	 */
+	private List getApplicableMatches(IRequiredCapability req) {
+		List target = new ArrayList();
+		Collector matches = picker.query(new CapabilityQuery(req), new Collector(), null);
+		for (Iterator iterator = matches.iterator(); iterator.hasNext();) {
+			IInstallableUnit match = (IInstallableUnit) iterator.next();
+			if (isApplicable(match)) {
+				target.add(match);
+			}
+		}
+		return target;
 	}
 
 	//Return a new array of requirements representing the application of the patch
@@ -443,169 +515,39 @@ public class Projector {
 		return (IRequiredCapability[][]) rrr.toArray(new IRequiredCapability[rrr.size()][]);
 	}
 
-	private void addOptionalityExpression() {
-		if (optionalityExpression != null && countOptionalIUs > 0)
-			dependencies.add(optionalityExpression + " >= 0;"); //$NON-NLS-1$
-		optionalityExpression = null;
-		countOptionalIUs = 0;
-	}
-
-	private String optionalityExpression = null;
-	private int countOptionalIUs = 0;
-	private QueryableArray patches;
-
-	private void expandOptionalRequirement(String iuVar, IInstallableUnit iu, IRequiredCapability req) {
-		if (iuVar == null)
-			iuVar = getVariable(iu);
-		String abstractVar = getAbstractVariable();
-		String expression = " -1 " + abstractVar; //$NON-NLS-1$
-		Collector matches = picker.query(new CapabilityQuery(req), new Collector(), null);
-		if (optionalityExpression == null)
-			optionalityExpression = " -1 " + iuVar + " 1 " + getNoOperationVariable(iu); //$NON-NLS-1$ //$NON-NLS-2$ 
-		StringBuffer comment = new StringBuffer();
-		if (DEBUG) {
-			comment.append("* "); //$NON-NLS-1$
-			comment.append(iu.toString());
-			comment.append(" requires optionaly either "); //$NON-NLS-1$
-		}
-		int countMatches = 0;
-		for (Iterator iterator = matches.iterator(); iterator.hasNext();) {
-			IInstallableUnit match = (IInstallableUnit) iterator.next();
-			if (isApplicable(match)) {
-				countMatches++;
-				expression += " 1 " + getVariable(match); //$NON-NLS-1$
-				if (DEBUG) {
-					comment.append(match.toString());
-					comment.append(' ');
-				}
-			}
-		}
-		countOptionalIUs += countMatches;
-		if (countMatches > 0) {
-			if (DEBUG) {
-				dependencies.add(comment.toString());
-				commentsCount++;
-			}
-			dependencies.add(impliesNo(getNoOperationVariable(iu), abstractVar));
-			dependencies.add(expression + " >= 0;"); //$NON-NLS-1$
-			optionalityExpression += " 1 " + abstractVar; //$NON-NLS-1$
-		} else {
-			if (DEBUG)
-				Tracing.debug("No IU found to satisfy optional dependency of " + iu + " req " + req); //$NON-NLS-1$//$NON-NLS-2$
+	/**
+	 * Optional requirements are encoded via:
+	 * ABS -> (match1(req) or match2(req) or ... or matchN(req))
+	 * noop(IU)-> ~ABS
+	 * IU -> (noop(IU) or ABS)
+	 * @param iu
+	 * @param optionalRequirements
+	 * @throws ContradictionException
+	 */
+	private void createOptionalityExpression(IInstallableUnit iu, List optionalRequirements) throws ContradictionException {
+		if (optionalRequirements.isEmpty())
+			return;
+		AbstractVariable noop = getNoOperationVariable(iu);
+		for (Iterator i = optionalRequirements.iterator(); i.hasNext();) {
+			AbstractVariable abs = (AbstractVariable) i.next();
+			createIncompatibleValues(abs, noop);
 		}
+		optionalRequirements.add(noop);
+		createImplication(iu, optionalRequirements, Explanation.OPTIONAL_REQUIREMENT);
 	}
 
-	private void genericOptionalRequirementExpansion(String iuVar, IInstallableUnit iu, IRequiredCapability req, String value) {
-		String abstractVar = getAbstractVariable();
-		String expression = iuVar;
-		Collector matches = picker.query(new CapabilityQuery(req), new Collector(), null);
-		if (optionalityExpression == null)
-			optionalityExpression = " -1 " + getVariable(iu) + " 1 " + getNoOperationVariable(iu); //$NON-NLS-1$ //$NON-NLS-2$ 
-		StringBuffer comment = new StringBuffer();
+	private void createImplication(Object left, List right, Explanation name) throws ContradictionException {
 		if (DEBUG) {
-			comment.append("* "); //$NON-NLS-1$
-			comment.append(iu.toString());
-			comment.append(" requires optionaly either "); //$NON-NLS-1$
-		}
-		int countMatches = 0;
-		for (Iterator iterator = matches.iterator(); iterator.hasNext();) {
-			IInstallableUnit match = (IInstallableUnit) iterator.next();
-			if (isApplicable(match)) {
-				countMatches++;
-				expression += " 1 " + getVariable(match); //$NON-NLS-1$
-				if (DEBUG) {
-					comment.append(match.toString());
-					comment.append(' ');
-				}
-			}
-		}
-		countOptionalIUs += countMatches;
-		if (countMatches > 0) {
-			if (DEBUG) {
-				dependencies.add(comment.toString());
-				commentsCount++;
-			}
-			dependencies.add(impliesNo(getNoOperationVariable(iu), abstractVar));
-			dependencies.add(expression + " " + value + ";"); //$NON-NLS-1$ //$NON-NLS-2$
-			optionalityExpression += " 1 " + abstractVar; //$NON-NLS-1$
-		} else {
-			if (DEBUG)
-				Tracing.debug("No IU found to satisfy optional dependency of " + iu + " req " + req); //$NON-NLS-1$//$NON-NLS-2$
+			Tracing.debug(name + ": " + left + "->" + right); //$NON-NLS-1$ //$NON-NLS-2$
 		}
+		dependencyHelper.implication(left).implies(right.toArray()).named(name);
 	}
 
-	private void genericRequirementExpansion(String varIu, IInstallableUnit iu, IRequiredCapability req, String value, String negationExpression) {
-		String expression = varIu;
-		Collector matches = picker.query(new CapabilityQuery(req), new Collector(), null);
-		StringBuffer comment = new StringBuffer();
+	private void createImplication(Object[] left, List right, Explanation name) throws ContradictionException {
 		if (DEBUG) {
-			comment.append("* "); //$NON-NLS-1$
-			comment.append(iu.toString());
-			comment.append(" requires either "); //$NON-NLS-1$
-		}
-		int countMatches = 0;
-		for (Iterator iterator = matches.iterator(); iterator.hasNext();) {
-			IInstallableUnit match = (IInstallableUnit) iterator.next();
-			if (isApplicable(match)) {
-				countMatches++;
-				expression += " +1 " + getVariable(match); //$NON-NLS-1$
-				if (DEBUG) {
-					comment.append(match.toString());
-					comment.append(' ');
-				}
-			}
-		}
-
-		if (countMatches > 0) {
-			if (DEBUG) {
-				dependencies.add(comment.toString());
-				commentsCount++;
-			}
-			dependencies.add(expression + " " + value + ";"); //$NON-NLS-1$ //$NON-NLS-2$
-		} else {
-			result.add(new Status(IStatus.WARNING, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Planner_Unsatisfied_dependency, iu, req)));
-			dependencies.add(negationExpression);
-		}
-	}
-
-	private void expandNormalRequirement(String varIu, IInstallableUnit iu, IRequiredCapability req) {
-		//Generate the regular requirement
-		if (varIu == null)
-			varIu = getVariable(iu);
-		StringBuffer expression = new StringBuffer("-1 "); //$NON-NLS-1$
-		expression.append(varIu);
-		Collector matches = picker.query(new CapabilityQuery(req), new Collector(), null);
-		StringBuffer comment = new StringBuffer();
-		if (DEBUG) {
-			comment.append("* "); //$NON-NLS-1$
-			comment.append(iu.toString());
-			comment.append(" requires either "); //$NON-NLS-1$
-		}
-		int countMatches = 0;
-		for (Iterator iterator = matches.iterator(); iterator.hasNext();) {
-			IInstallableUnit match = (IInstallableUnit) iterator.next();
-			if (isApplicable(match)) {
-				countMatches++;
-				expression.append(" +1 "); //$NON-NLS-1$
-				expression.append(getVariable(match));
-				if (DEBUG) {
-					comment.append(match.toString());
-					comment.append(' ');
-				}
-			}
-		}
-
-		if (countMatches > 0) {
-			if (DEBUG) {
-				dependencies.add(comment.toString());
-				commentsCount++;
-			}
-			expression.append(" >= 0;"); //$NON-NLS-1$
-			dependencies.add(expression.toString());
-		} else {
-			result.add(new Status(IStatus.WARNING, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Planner_Unsatisfied_dependency, iu, req)));
-			createNegation(varIu);
+			Tracing.debug(name + ": " + Arrays.asList(left) + "->" + right); //$NON-NLS-1$ //$NON-NLS-2$
 		}
+		dependencyHelper.implication(left).implies(right.toArray()).named(name);
 	}
 
 	//Return IUPatches that are applicable for the given iu
@@ -616,16 +558,9 @@ public class Projector {
 		return patches.query(new ApplicablePatchQuery(iu), new Collector(), null);
 	}
 
-	private void expandRequirement(String var, IInstallableUnit iu, IRequiredCapability req) {
-		if (req.isOptional())
-			expandOptionalRequirement(var, iu, req);
-		else
-			expandNormalRequirement(var, iu, req);
-	}
-
 	//Create constraints to deal with singleton
-	//When there is a mix of singleton and non singleton, several constraints are generated 
-	private void createConstraintsForSingleton() {
+	//When there is a mix of singleton and non singleton, several constraints are generated
+	private void createConstraintsForSingleton() throws ContradictionException {
 		Set s = slice.entrySet();
 		for (Iterator iterator = s.iterator(); iterator.hasNext();) {
 			Map.Entry entry = (Map.Entry) iterator.next();
@@ -634,49 +569,58 @@ public class Projector {
 				continue;
 
 			Collection conflictingVersions = conflictingEntries.values();
-			String singletonRule = ""; //$NON-NLS-1$
-			ArrayList nonSingleton = new ArrayList();
-			int countSingleton = 0;
+			List singletons = new ArrayList();
+			List nonSingletons = new ArrayList();
 			for (Iterator conflictIterator = conflictingVersions.iterator(); conflictIterator.hasNext();) {
-				IInstallableUnit conflictElt = (IInstallableUnit) conflictIterator.next();
-				if (conflictElt.isSingleton()) {
-					singletonRule += " -1 " + getVariable(conflictElt); //$NON-NLS-1$
-					countSingleton++;
+				IInstallableUnit iu = (IInstallableUnit) conflictIterator.next();
+				if (iu.isSingleton()) {
+					singletons.add(iu);
 				} else {
-					nonSingleton.add(conflictElt);
+					nonSingletons.add(iu);
 				}
 			}
-			if (countSingleton == 0)
+			if (singletons.isEmpty())
 				continue;
 
-			for (Iterator iterator2 = nonSingleton.iterator(); iterator2.hasNext();) {
-				constraints.add(singletonRule + " -1 " + getVariable((IInstallableUnit) iterator2.next()) + " >= -1;"); //$NON-NLS-1$ //$NON-NLS-2$
+			IInstallableUnit[] singletonArray;
+			if (nonSingletons.isEmpty()) {
+				singletonArray = (IInstallableUnit[]) singletons.toArray(new IInstallableUnit[singletons.size()]);
+				createAtMostOne(singletonArray);
+			} else {
+				singletonArray = (IInstallableUnit[]) singletons.toArray(new IInstallableUnit[singletons.size() + 1]);
+				for (Iterator iterator2 = nonSingletons.iterator(); iterator2.hasNext();) {
+					singletonArray[singletonArray.length - 1] = (IInstallableUnit) iterator2.next();
+					createAtMostOne(singletonArray);
+				}
 			}
-			singletonRule += " >= -1;"; //$NON-NLS-1$
-			constraints.add(singletonRule);
 		}
 	}
 
-	//Return the corresponding variable 
-	private String getVariable(IInstallableUnit iu) {
-		String v = (String) variables.get(iu);
-		if (v == null) {
-			v = new String("x" + varCount++); //$NON-NLS-1$
-			variables.put(iu, v);
+	private void createAtMostOne(IInstallableUnit[] ius) throws ContradictionException {
+		if (DEBUG) {
+			Tracing.debug("At most 1 of " + Arrays.toString(ius)); //$NON-NLS-1$
 		}
-		return v;
+		dependencyHelper.atMost(1, ius).named(new Explanation.Singleton(ius)); //$NON-NLS-1$
+	}
+
+	private void createIncompatibleValues(AbstractVariable v1, AbstractVariable v2) throws ContradictionException {
+		AbstractVariable[] vars = {v1, v2};
+		if (DEBUG) {
+			Tracing.debug("At most 1 of " + Arrays.toString(vars)); //$NON-NLS-1$
+		}
+		dependencyHelper.atMost(1, vars).named(Explanation.OPTIONAL_REQUIREMENT); //$NON-NLS-1$
 	}
 
-	private String getAbstractVariable() {
-		String newVar = new String("x" + varCount++); //$NON-NLS-1$
-		abstractVariables.add(newVar);
-		return newVar;
+	private AbstractVariable getAbstractVariable() {
+		AbstractVariable abstractVariable = new AbstractVariable();
+		abstractVariables.add(abstractVariable);
+		return abstractVariable;
 	}
 
-	private String getNoOperationVariable(IInstallableUnit iu) {
-		String v = (String) noopVariables.get(iu);
+	private AbstractVariable getNoOperationVariable(IInstallableUnit iu) {
+		AbstractVariable v = (AbstractVariable) noopVariables.get(iu);
 		if (v == null) {
-			v = new String("x" + varCount++); //$NON-NLS-1$
+			v = new AbstractVariable();
 			noopVariables.put(iu, v);
 		}
 		return v;
@@ -685,68 +629,47 @@ public class Projector {
 	public IStatus invokeSolver(IProgressMonitor monitor) {
 		if (result.getSeverity() == IStatus.ERROR)
 			return result;
-		IPBSolver solver = SolverFactory.newEclipseP2();
-		solver.setTimeoutOnConflicts(1000);
-		OPBEclipseReader2007 reader = new OPBEclipseReader2007(solver);
-		// CNF filename is given on the command line 
+		// CNF filename is given on the command line
 		long start = System.currentTimeMillis();
 		if (DEBUG)
 			Tracing.debug("Invoking solver: " + start); //$NON-NLS-1$
-		FileReader fr = null;
-		boolean delete = true;
 		try {
 			if (monitor.isCanceled())
 				return Status.CANCEL_STATUS;
-			fr = new FileReader(problemFile);
-			IProblem problem = reader.parseInstance(fr);
-			if (problem.isSatisfiable()) {
-				//				problem.model();
+			if (dependencyHelper.hasASolution(assumptions)) {
 				if (DEBUG) {
 					Tracing.debug("Satisfiable !"); //$NON-NLS-1$
-					Tracing.debug(reader.decode(problem.model()));
 				}
-				backToIU(problem);
+				backToIU();
 				long stop = System.currentTimeMillis();
 				if (DEBUG)
 					Tracing.debug("Solver solution found: " + (stop - start)); //$NON-NLS-1$
 			} else {
-				if (DEBUG)
+				long stop = System.currentTimeMillis();
+				if (DEBUG) {
 					Tracing.debug("Unsatisfiable !"); //$NON-NLS-1$
-				result.merge(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Planner_Unsatisfiable_problem, problemFile)));
+					Tracing.debug("Solver solution NOT found: " + (stop - start)); //$NON-NLS-1$
+				}
+				result.merge(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, Messages.Planner_Unsatisfiable_problem));
 			}
-		} catch (FileNotFoundException e) {
-			result.add(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Planner_Missing_opb_file, problemFile)));
-		} catch (ParseFormatException e) {
-			delete = false;
-			result.add(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Planner_Format_error, problemFile)));
-		} catch (ContradictionException e) {
-			result.merge(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Planner_Trivial_exception, problemFile)));
 		} catch (TimeoutException e) {
-			delete = false;
-			result.merge(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Planner_Timeout, problemFile)));
+			result.merge(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, Messages.Planner_Timeout));
 		} catch (Exception e) {
-			delete = false;
 			result.merge(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, Messages.Planner_Unexpected_problem, e));
-		} finally {
-			try {
-				if (fr != null)
-					fr.close();
-			} catch (IOException e) {
-				//ignore
-			}
-			if (delete)
-				problemFile.delete();
 		}
+		if (DEBUG)
+			System.out.println();
 		return result;
 	}
 
-	private void backToIU(IProblem problem) {
+	private void backToIU() {
 		solution = new ArrayList();
-		for (Iterator allIUs = variables.entrySet().iterator(); allIUs.hasNext();) {
-			Entry entry = (Entry) allIUs.next();
-			int match = Integer.parseInt(((String) entry.getValue()).substring(1));
-			if (problem.model(match)) {
-				solution.add(((IInstallableUnit) entry.getKey()).unresolved());
+		IVec sat4jSolution = dependencyHelper.getSolution();
+		for (Iterator i = sat4jSolution.iterator(); i.hasNext();) {
+			Object var = i.next();
+			if (var instanceof IInstallableUnit) {
+				IInstallableUnit iu = (IInstallableUnit) var;
+				solution.add(iu);
 			}
 		}
 	}
@@ -754,7 +677,8 @@ public class Projector {
 	private void printSolution(Collection state) {
 		ArrayList l = new ArrayList(state);
 		Collections.sort(l);
-		Tracing.debug("Numbers of IUs selected:" + l.size()); //$NON-NLS-1$
+		Tracing.debug("Solution:"); //$NON-NLS-1$
+		Tracing.debug("Numbers of IUs selected: " + l.size()); //$NON-NLS-1$
 		for (Iterator iterator = l.iterator(); iterator.hasNext();) {
 			Tracing.debug(iterator.next().toString());
 		}
@@ -765,4 +689,37 @@ public class Projector {
 			printSolution(solution);
 		return solution;
 	}
-}
+
+	public Set getExplanationFor(IInstallableUnit iu) {
+		//TODO if the iu is resolved then return null.
+		//TODO if the iu is in an unknown state, then return a special value in the set
+		try {
+			return dependencyHelper.whyNot(iu);
+		} catch (TimeoutException e) {
+			return Collections.EMPTY_SET;
+		}
+	}
+
+	public Set getExplanation() {
+		long start = 0, stop;
+		if (DEBUG) {
+			start = System.currentTimeMillis();
+			Tracing.debug("Determining cause of failure: " + start);
+		}
+		Set why;
+		try {
+			why = dependencyHelper.why();
+			if (DEBUG) {
+				stop = System.currentTimeMillis();
+				Tracing.debug("Explanation found: " + (stop - start));
+				Tracing.debug("Explanation:");
+				for (Iterator i = why.iterator(); i.hasNext();) {
+					Tracing.debug(i.next().toString());
+				}
+			}
+			return why;
+		} catch (TimeoutException e) {
+		}
+		return null;
+	}
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Recommendation.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Recommendation.java
index bf746aa..6393620 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Recommendation.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Recommendation.java
@@ -66,7 +66,8 @@ public class Recommendation {
 		} else if (minCompare > 0) {
 			resultMin = r1.getMinimum();
 			resultMinIncluded = r1.getIncludeMinimum();
-		} else if (minCompare == 0) {
+		} else {
+			// minCompare == 0
 			resultMin = r1.getMinimum();
 			resultMinIncluded = r1.getIncludeMinimum() && r2.getIncludeMinimum();
 		}
@@ -78,7 +79,8 @@ public class Recommendation {
 		} else if (maxCompare < 0) {
 			resultMax = r1.getMaximum();
 			resultMaxIncluded = r1.getIncludeMaximum();
-		} else if (maxCompare == 0) {
+		} else {
+			// maxCompare == 0
 			resultMax = r1.getMaximum();
 			resultMaxIncluded = r1.getIncludeMaximum() && r2.getIncludeMaximum();
 		}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
index 930373a..757f893 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
@@ -51,7 +51,7 @@ public class SimplePlanner implements IPlanner {
 				Tracing.debug(operands[i].toString());
 			}
 		}
-		return new ProvisioningPlan(status, operands, computeActualChangeRequest(toState, changeRequest));
+		return new ProvisioningPlan(status, operands, computeActualChangeRequest(toState, changeRequest), null);
 	}
 
 	private Map[] buildDetailedErrors(ProfileChangeRequest changeRequest) {
@@ -59,10 +59,10 @@ public class SimplePlanner implements IPlanner {
 		IInstallableUnit[] removed = changeRequest.getRemovedInstallableUnits();
 		Map requestStatus = new HashMap(added.length + removed.length);
 		for (int i = 0; i < added.length; i++) {
-			requestStatus.put(added[i], new RequestStatus(added[i], RequestStatus.ADDED, IStatus.ERROR));
+			requestStatus.put(added[i], new RequestStatus(added[i], RequestStatus.ADDED, IStatus.ERROR, null));
 		}
 		for (int i = 0; i < removed.length; i++) {
-			requestStatus.put(removed[i], new RequestStatus(removed[i], RequestStatus.REMOVED, IStatus.ERROR));
+			requestStatus.put(removed[i], new RequestStatus(removed[i], RequestStatus.REMOVED, IStatus.ERROR, null));
 		}
 		return new Map[] {requestStatus, null};
 	}
@@ -73,16 +73,16 @@ public class SimplePlanner implements IPlanner {
 		Map requestStatus = new HashMap(added.length + removed.length);
 		for (int i = 0; i < added.length; i++) {
 			if (toState.contains(added[i]))
-				requestStatus.put(added[i], new RequestStatus(added[i], RequestStatus.ADDED, IStatus.OK));
+				requestStatus.put(added[i], new RequestStatus(added[i], RequestStatus.ADDED, IStatus.OK, null));
 			else
-				requestStatus.put(added[i], new RequestStatus(added[i], RequestStatus.ADDED, IStatus.ERROR));
+				requestStatus.put(added[i], new RequestStatus(added[i], RequestStatus.ADDED, IStatus.ERROR, null));
 		}
 
 		for (int i = 0; i < removed.length; i++) {
 			if (!toState.contains(removed[i]))
-				requestStatus.put(removed[i], new RequestStatus(removed[i], RequestStatus.REMOVED, IStatus.OK));
+				requestStatus.put(removed[i], new RequestStatus(removed[i], RequestStatus.REMOVED, IStatus.OK, null));
 			else
-				requestStatus.put(removed[i], new RequestStatus(removed[i], RequestStatus.REMOVED, IStatus.ERROR));
+				requestStatus.put(removed[i], new RequestStatus(removed[i], RequestStatus.REMOVED, IStatus.ERROR, null));
 		}
 
 		//Compute the side effect changes (e.g. things installed optionally going away)
@@ -92,7 +92,7 @@ public class SimplePlanner implements IPlanner {
 		for (Iterator iterator = includedIUs.iterator(); iterator.hasNext();) {
 			IInstallableUnit removal = (IInstallableUnit) iterator.next();
 			if (!requestStatus.containsKey(removal))
-				sideEffectStatus.put(removal, new RequestStatus(removal, RequestStatus.REMOVED, IStatus.INFO));
+				sideEffectStatus.put(removal, new RequestStatus(removal, RequestStatus.REMOVED, IStatus.INFO, null));
 		}
 		return new Map[] {requestStatus, sideEffectStatus};
 	}
@@ -109,33 +109,35 @@ public class SimplePlanner implements IPlanner {
 		}
 		// Now deal with profile property changes/additions
 		Map propertyChanges = profileChangeRequest.getPropertiesToAdd();
-		Iterator iter = propertyChanges.keySet().iterator();
+		Iterator iter = propertyChanges.entrySet().iterator();
 		while (iter.hasNext()) {
-			String key = (String) iter.next();
-			operands.add(new PropertyOperand(key, existingProperties.get(key), propertyChanges.get(key)));
+			Map.Entry entry = (Map.Entry) iter.next();
+			operands.add(new PropertyOperand((String) entry.getKey(), existingProperties.get(entry.getKey()), entry.getValue()));
 		}
 		// Now deal with iu property changes/additions.
 		// TODO we aren't yet checking that the IU will exist in the final profile, will the engine do this?
 		Map allIUPropertyChanges = profileChangeRequest.getInstallableUnitProfilePropertiesToAdd();
-		iter = allIUPropertyChanges.keySet().iterator();
+		iter = allIUPropertyChanges.entrySet().iterator();
 		while (iter.hasNext()) {
-			IInstallableUnit iu = (IInstallableUnit) iter.next();
-			Map iuPropertyChanges = (Map) allIUPropertyChanges.get(iu);
-			Iterator iuPropIter = iuPropertyChanges.keySet().iterator();
+			Map.Entry entry = (Map.Entry) iter.next();
+			IInstallableUnit iu = (IInstallableUnit) entry.getKey();
+			Map iuPropertyChanges = (Map) entry.getValue();
+			Iterator iuPropIter = iuPropertyChanges.entrySet().iterator();
 			while (iuPropIter.hasNext()) {
-				String key = (String) iuPropIter.next();
-				Object oldValue = profile.getInstallableUnitProperty(iu, key);
-				operands.add(new InstallableUnitPropertyOperand(iu, key, oldValue, iuPropertyChanges.get(key)));
+				Map.Entry entry2 = (Map.Entry) iuPropIter.next();
+				Object oldValue = profile.getInstallableUnitProperty(iu, (String) entry2.getKey());
+				operands.add(new InstallableUnitPropertyOperand(iu, (String) entry2.getKey(), oldValue, entry2.getValue()));
 			}
 		}
 		// Now deal with iu property removals.
 		// TODO we could optimize by not generating property removals for IU's that aren't there or won't be there.
 		Map allIUPropertyDeletions = profileChangeRequest.getInstallableUnitProfilePropertiesToRemove();
-		iter = allIUPropertyDeletions.keySet().iterator();
+		iter = allIUPropertyDeletions.entrySet().iterator();
 		while (iter.hasNext()) {
-			IInstallableUnit iu = (IInstallableUnit) iter.next();
+			Map.Entry entry = (Map.Entry) iter.next();
+			IInstallableUnit iu = (IInstallableUnit) entry.getKey();
 			Map existingIUProperties = profile.getInstallableUnitProperties(iu);
-			List iuPropertyRemovals = (List) allIUPropertyDeletions.get(iu);
+			List iuPropertyRemovals = (List) entry.getValue();
 			for (Iterator it = iuPropertyRemovals.iterator(); it.hasNext();) {
 				String key = (String) it.next();
 				if (existingIUProperties.containsKey(key))
@@ -258,7 +260,7 @@ public class SimplePlanner implements IPlanner {
 		try {
 			IProfile profile = profileChangeRequest.getProfile();
 
-			IInstallableUnit[] allIUs = updatePlannerInfo(profileChangeRequest);
+			Object[] updatedPlan = updatePlannerInfo(profileChangeRequest);
 
 			URI[] metadataRepositories = (context != null) ? context.getMetadataRepositories() : null;
 			Dictionary newSelectionContext = createSelectionContext(profileChangeRequest.getProfileProperties());
@@ -271,23 +273,23 @@ public class SimplePlanner implements IPlanner {
 			IInstallableUnit[] availableIUs = gatherAvailableInstallableUnits((IInstallableUnit[]) extraIUs.toArray(new IInstallableUnit[extraIUs.size()]), metadataRepositories, context, sub.newChild(ExpandWork / 4));
 
 			Slicer slicer = new Slicer(new QueryableArray(availableIUs), newSelectionContext);
-			IQueryable slice = slicer.slice(allIUs, sub.newChild(ExpandWork / 4));
+			IQueryable slice = slicer.slice(new IInstallableUnit[] {(IInstallableUnit) updatedPlan[0]}, sub.newChild(ExpandWork / 4));
 			if (slice == null)
 				return new ProvisioningPlan(slicer.getStatus());
 			Projector projector = new Projector(slice, newSelectionContext);
-			projector.encode(allIUs, sub.newChild(ExpandWork / 4));
+			projector.encode((IInstallableUnit) updatedPlan[0], (IInstallableUnit[]) updatedPlan[1], profileChangeRequest.getAddedInstallableUnits(), sub.newChild(ExpandWork / 4));
 			IStatus s = projector.invokeSolver(sub.newChild(ExpandWork / 4));
 			if (s.getSeverity() == IStatus.CANCEL)
 				return new ProvisioningPlan(s);
 			if (s.getSeverity() == IStatus.ERROR) {
 				sub.setTaskName(Messages.Planner_NoSolution);
-				//log the error from the new solver so it is not lost
 				LogHelper.log(s);
-				//We invoke the old resolver to get explanations for now
-				IStatus oldResolverStatus = new NewDependencyExpander(allIUs, null, availableIUs, newSelectionContext, false).expand(sub.newChild(ExpandWork / 4));
-				if (!oldResolverStatus.isOK())
-					s = oldResolverStatus;
-				return new ProvisioningPlan(s, new Operand[0], buildDetailedErrors(profileChangeRequest));
+
+				//Now gather the reasons why things did not resolve and put it in a map that will be passed to the provisioning plan
+				// IInstallableUnit[] added = profileChangeRequest.getAddedInstallableUnits();
+
+				Set explanation = projector.getExplanation();
+				return new ProvisioningPlan(s, new Operand[0], buildDetailedErrors(profileChangeRequest), new RequestStatus(null, RequestStatus.REMOVED, IStatus.ERROR, explanation));
 			}
 			//The resolution succeeded. We can forget about the warnings since there is a solution.
 			if (Tracing.DEBUG && s.getSeverity() != IStatus.OK)
@@ -295,7 +297,7 @@ public class SimplePlanner implements IPlanner {
 			s = Status.OK_STATUS;
 
 			Collection newState = projector.extractSolution();
-			newState.remove(allIUs[0]);
+			newState.remove(updatedPlan[0]);
 
 			ResolutionHelper newStateHelper = new ResolutionHelper(newSelectionContext, null);
 			newState = newStateHelper.attachCUs(newState);
@@ -321,18 +323,11 @@ public class SimplePlanner implements IPlanner {
 	}
 
 	//The planner uses installable unit properties to keep track of what it has been asked to install. This updates this information
-	private IInstallableUnit[] updatePlannerInfo(ProfileChangeRequest profileChangeRequest) {
-		//Support for backward compatibility. Convert planner_marker properties into strict inclusion rules
-		Collector previousMarkers = profileChangeRequest.getProfile().query(new IUProfilePropertyQuery(profileChangeRequest.getProfile(), PLANNER_MARKER, Boolean.TRUE.toString()), new Collector(), null);
-		for (Iterator iterator = previousMarkers.iterator(); iterator.hasNext();) {
-			IInstallableUnit iu = (IInstallableUnit) iterator.next();
-			profileChangeRequest.setInstallableUnitInclusionRules(iu, PlannerHelper.createStrictInclusionRule(iu));
-			profileChangeRequest.removeInstallableUnitProfileProperty(iu, PLANNER_MARKER);
-		}
-
+	//It returns at index 0 a meta IU representing everything that needs to be installed
+	//It returns at index 1 all the IUs that are in the profile after the removal have been done, but before the addition have been done 
+	private Object[] updatePlannerInfo(ProfileChangeRequest profileChangeRequest) {
 		Collection includedIUs = profileChangeRequest.getProfile().query(new IUProfilePropertyQuery(profileChangeRequest.getProfile(), INCLUSION_RULES, null), new Collector(), null).toCollection();
 		Collection alreadyInstalled = new HashSet(includedIUs);
-		alreadyInstalled.addAll(previousMarkers.toCollection());
 
 		IInstallableUnit[] added = profileChangeRequest.getAddedInstallableUnits();
 		IInstallableUnit[] removed = profileChangeRequest.getRemovedInstallableUnits();
@@ -385,7 +380,7 @@ public class SimplePlanner implements IPlanner {
 			}
 			gatheredRequirements.add(profileRequirement);
 		}
-		return new IInstallableUnit[] {createIURepresentingTheProfile(gatheredRequirements)};
+		return new Object[] {createIURepresentingTheProfile(gatheredRequirements), (IInstallableUnit[]) alreadyInstalled.toArray(new IInstallableUnit[alreadyInstalled.size()])};
 	}
 
 	private IRequiredCapability createRequirement(IInstallableUnit iu, String rule) {
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/TwoTierMap.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/TwoTierMap.java
index fdd68d5..bc7d3d1 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/TwoTierMap.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/TwoTierMap.java
@@ -132,7 +132,7 @@ public class TwoTierMap implements Map, Serializable {
 			}
 			return result;
 		}
-		Object result = (innerMap == null) ? null : innerMap.remove(key2);
+		Object result = innerMap.remove(key2);
 		if (result != null && innerMap.isEmpty()) {
 			this.outerMap.remove(key1);
 		}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/ProvisioningPlan.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/ProvisioningPlan.java
index a9b8ca3..7c2c60d 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/ProvisioningPlan.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/ProvisioningPlan.java
@@ -23,18 +23,20 @@ public class ProvisioningPlan {
 	Operand[] operands;
 	Map actualChangeRequest;
 	Map sideEffectChanges;
+	RequestStatus globalRequestStatus;
 
 	public ProvisioningPlan(IStatus status) {
-		this(status, new Operand[0], null);
+		this(status, new Operand[0], null, null);
 	}
 
-	public ProvisioningPlan(IStatus status, Operand[] operands, Map[] actualChangeRequest) {
+	public ProvisioningPlan(IStatus status, Operand[] operands, Map[] actualChangeRequest, RequestStatus globalStatus) {
 		this.status = status;
 		this.operands = operands;
 		if (actualChangeRequest != null) {
 			this.actualChangeRequest = actualChangeRequest[0];
 			this.sideEffectChanges = actualChangeRequest[1];
 		}
+		this.globalRequestStatus = globalStatus;
 	}
 
 	public IStatus getStatus() {
@@ -64,6 +66,10 @@ public class ProvisioningPlan {
 		return (RequestStatus) actualChangeRequest.get(iu);
 	}
 
+	public RequestStatus getRequestStatus() {
+		return globalRequestStatus;
+	}
+
 	public Map getSideEffectChanges() {
 		if (sideEffectChanges == null)
 			return Collections.EMPTY_MAP;
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/RequestStatus.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/RequestStatus.java
index be4e73a..42e5026 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/RequestStatus.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/RequestStatus.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2008-2009 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -9,6 +9,10 @@
  ******************************************************************************/
 package org.eclipse.equinox.internal.provisional.p2.director;
 
+import java.util.*;
+import org.eclipse.equinox.internal.p2.director.Explanation;
+import org.eclipse.equinox.internal.p2.director.Explanation.IUInstalled;
+import org.eclipse.equinox.internal.p2.director.Explanation.IUToInstall;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 
 public class RequestStatus {
@@ -18,11 +22,32 @@ public class RequestStatus {
 	private byte initialRequestType;
 	private IInstallableUnit iu;
 	private int severity;
+	private Set explanation;
+	private Explanation detailedExplanation;
+	private Set conflictingRootIUs;
+	private Set conflictingInstalledIUs;
 
-	public RequestStatus(IInstallableUnit iu, byte initialRequesType, int severity) {
+	public RequestStatus(IInstallableUnit iu, byte initialRequesType, int severity, Set explanation) {
 		this.iu = iu;
 		this.severity = severity;
 		this.initialRequestType = initialRequesType;
+		this.explanation = explanation;
+		conflictingRootIUs = new HashSet();
+		conflictingInstalledIUs = new HashSet();
+		if (explanation != null) {
+			Iterator iterator = explanation.iterator();
+			Object o = null;
+			while (iterator.hasNext() && ((o = iterator.next()) instanceof Explanation.IUToInstall)) {
+				conflictingRootIUs.add(((IUToInstall) o).iu);
+			}
+			if (o instanceof Explanation.IUInstalled) {
+				conflictingInstalledIUs.add(((IUInstalled) o).iu);
+				while (iterator.hasNext() && ((o = iterator.next()) instanceof Explanation.IUInstalled)) {
+					conflictingInstalledIUs.add(((IUInstalled) o).iu);
+				}
+			}
+			detailedExplanation = (Explanation) o;
+		}
 	}
 
 	public byte getInitialRequestType() {
@@ -36,4 +61,30 @@ public class RequestStatus {
 	public int getSeverity() {
 		return severity;
 	}
+
+	//Return the already installed roots with which this IU is in conflict
+	//Return an empty set if there is no conflict
+	public Set getConflictsWithInstalledRoots() {
+		return conflictingRootIUs;
+	}
+
+	//Return the already installed roots with which this IU is in conflict
+	//Return an empty set if there is no conflict
+	public Set getConflictsWithAnyRoots() {
+		return conflictingInstalledIUs;
+	}
+
+	//Return an explanation as to why this IU can not be resolved.
+	public Set getExplanations() {
+		//To start with, this does not have to return the most specific explanation. If it simply returns an global explanation it is good enough.
+		return explanation;
+	}
+
+	public int getShortExplanation() {
+		return detailedExplanation.shortAnswer();
+	}
+
+	public Explanation getExplanationDetails() {
+		return detailedExplanation;
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/AllExplanation.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/AllExplanation.java
new file mode 100644
index 0000000..54cb11c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/AllExplanation.java
@@ -0,0 +1,22 @@
+package org.eclipse.equinox.p2.tests.planner;
+
+import junit.framework.*;
+
+public class AllExplanation extends TestCase {
+
+	public static Test suite() {
+		TestSuite suite = new TestSuite(AllTests.class.getName());
+		suite.addTestSuite(ExplanationDeepConflict.class);
+		suite.addTestSuite(ExplanationForOptionalDependencies.class);
+		suite.addTestSuite(ExplanationForPartialInstallation.class);
+		suite.addTestSuite(ExplanationSeveralConflictingRoots.class);
+		suite.addTestSuite(MissingDependency.class);
+		suite.addTestSuite(MissingNonGreedyRequirement.class);
+		suite.addTestSuite(MissingNonGreedyRequirement2.class);
+		suite.addTestSuite(MultipleSingleton.class);
+		suite.addTestSuite(PatchTest10.class);
+		suite.addTestSuite(PatchTest12.class);
+		return suite;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/AllTests.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/AllTests.java
index 8fd39be..b9286aa 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/AllTests.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/AllTests.java
@@ -34,6 +34,10 @@ public class AllTests extends TestCase {
 		suite.addTestSuite(Bug262580.class);
 		suite.addTestSuite(DependencyOnSelf.class);
 		suite.addTestSuite(DropinsScenario.class);
+		suite.addTestSuite(ExplanationDeepConflict.class);
+		suite.addTestSuite(ExplanationForOptionalDependencies.class);
+		suite.addTestSuite(ExplanationForPartialInstallation.class);
+		suite.addTestSuite(ExplanationSeveralConflictingRoots.class);
 		suite.addTestSuite(GreedyRequirement.class);
 		suite.addTestSuite(InclusionRuleTest.class);
 		suite.addTestSuite(InclusionRuleTest2.class);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationDeepConflict.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationDeepConflict.java
new file mode 100644
index 0000000..6343536
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationDeepConflict.java
@@ -0,0 +1,54 @@
+package org.eclipse.equinox.p2.tests.planner;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+import org.eclipse.equinox.internal.provisional.p2.director.*;
+import org.eclipse.equinox.internal.provisional.p2.engine.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
+
+public class ExplanationDeepConflict extends AbstractProvisioningTest {
+	private IProfile profile;
+	private IPlanner planner;
+	private IEngine engine;
+	private IInstallableUnit sdk;
+
+	@Override
+	protected void setUp() throws Exception {
+		super.setUp();
+		sdk = createIU("SDK", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "SDKPart", new VersionRange("[1.0.0, 1.0.0]"), null));
+		IInstallableUnit sdkPart = createIU("SDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "InnerSDKPart", new VersionRange("[1.0.0, 1.0.0]"), null));
+		IInstallableUnit innerSdkPart = createIU("InnerSDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "InnerInnerSDKPart", new VersionRange("[1.0.0, 1.0.0]"), null));
+		IInstallableUnit innerInnerSDKPart = createIU("InnerInnerSDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), true);
+
+		createTestMetdataRepository(new IInstallableUnit[] {sdk, sdkPart, innerSdkPart, innerInnerSDKPart});
+
+		profile = createProfile("TestProfile." + getName());
+		planner = createPlanner();
+		engine = createEngine();
+
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {sdk});
+		engine.perform(profile, new DefaultPhaseSet(), planner.getProvisioningPlan(pcr, null, null).getOperands(), null, null);
+		assertProfileContains("1.0", profile, new IInstallableUnit[] {sdk, sdkPart, innerSdkPart, innerInnerSDKPart});
+	}
+
+	public void testDeepSingletonConflict() {
+		//CDT will have a singleton conflict with SDK
+		IInstallableUnit cdt = createIU("CDT", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "CDTPart", new VersionRange("[1.0.0, 1.0.0]"), null));
+		IInstallableUnit cdtPart = createIU("CDTPart", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "InnerInnerSDKPart", new VersionRange("[2.0.0, 2.0.0]"), null));
+		IInstallableUnit innerInnerSDKPart2 = createIU("InnerInnerSDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("2.0.0")), true);
+
+		createTestMetdataRepository(new IInstallableUnit[] {cdt, cdtPart, innerInnerSDKPart2});
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {cdt});
+		ProvisioningPlan plan = planner.getProvisioningPlan(pcr, null, null);
+		System.out.println(plan.getRequestStatus().getExplanations());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(cdt));
+		//Here we verify that we only return the roots we asked the installation of. The SDK is installable since it is already installed
+		assertFalse(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(sdk));
+		assertTrue(plan.getRequestStatus().getConflictsWithAnyRoots().contains(sdk));
+		//		assertTrue(plan.getRequestStatus(cdt).getConflictsWithAnyRoots().contains(sdk));
+		//		assertTrue(plan.getRequestStatus(cdt).getConflictsWithInstalledRoots().contains(sdk));
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationForOptionalDependencies.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationForOptionalDependencies.java
new file mode 100644
index 0000000..fa589e4
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationForOptionalDependencies.java
@@ -0,0 +1,57 @@
+package org.eclipse.equinox.p2.tests.planner;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+import org.eclipse.equinox.internal.provisional.p2.director.*;
+import org.eclipse.equinox.internal.provisional.p2.engine.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
+
+public class ExplanationForOptionalDependencies extends AbstractProvisioningTest {
+	private IProfile profile;
+	private IPlanner planner;
+	private IEngine engine;
+	private IInstallableUnit sdk;
+
+	@Override
+	protected void setUp() throws Exception {
+		super.setUp();
+		sdk = createIU("SDK", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "SDKPart", new VersionRange("[1.0.0, 1.0.0]"), null));
+		IInstallableUnit sdkPart = createIU("SDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), true);
+		IInstallableUnit sdkPart2 = createIU("SDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("2.0.0")), true);
+
+		createTestMetdataRepository(new IInstallableUnit[] {sdk, sdkPart, sdkPart2});
+
+		profile = createProfile("TestProfile." + getName());
+		planner = createPlanner();
+		engine = createEngine();
+
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {sdk});
+		engine.perform(profile, new DefaultPhaseSet(), planner.getProvisioningPlan(pcr, null, null).getOperands(), null, null);
+
+	}
+
+	public void testNoProblemWithMissingOptionalDependency() {
+		//CDT will be missing a requirement but it is optional so everything should be good
+		//EMF will be not be good because it is missing a requirement
+		IRequiredCapability missingOptionalDependency = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "MissingSomething", new VersionRange("[1.0.0, 1.0.0]"), null, true, false);
+		IInstallableUnit cdt = createIU("CDT", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), new IRequiredCapability[] {missingOptionalDependency});
+
+		IRequiredCapability emfMissing = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "EMFPart", new VersionRange("[1.0.0, 1.0.0]"), null, false, false);
+		IInstallableUnit emf = createIU("EMF", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), new IRequiredCapability[] {emfMissing}, NO_PROPERTIES, true);
+
+		createTestMetdataRepository(new IInstallableUnit[] {cdt, emf});
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {cdt, emf});
+		ProvisioningPlan plan = planner.getProvisioningPlan(pcr, null, null);
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(emf));
+		assertFalse(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(cdt));
+		assertFalse(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(sdk));
+
+		//		assertTrue(plan.getRequestStatus(cdt).getSeverity() != IStatus.ERROR);
+		//
+		//		assertTrue(plan.getRequestStatus(emf).getSeverity() == IStatus.ERROR);
+		//		assertEquals(0, plan.getRequestStatus(emf).getConflictsWithInstalledRoots());
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationForPartialInstallation.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationForPartialInstallation.java
new file mode 100644
index 0000000..a54d819
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationForPartialInstallation.java
@@ -0,0 +1,86 @@
+package org.eclipse.equinox.p2.tests.planner;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+import org.eclipse.equinox.internal.provisional.p2.director.*;
+import org.eclipse.equinox.internal.provisional.p2.engine.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
+
+public class ExplanationForPartialInstallation extends AbstractProvisioningTest {
+	private IProfile profile;
+	private IPlanner planner;
+	private IEngine engine;
+	private IInstallableUnit sdk;
+
+	@Override
+	protected void setUp() throws Exception {
+		super.setUp();
+		sdk = createIU("SDK", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "SDKPart", new VersionRange("[1.0.0, 1.0.0]"), null));
+		IInstallableUnit sdkPart = createIU("SDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), true);
+		IInstallableUnit sdkPart2 = createIU("SDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("2.0.0")), true);
+
+		createTestMetdataRepository(new IInstallableUnit[] {sdk, sdkPart, sdkPart2});
+
+		profile = createProfile("TestProfile." + getName());
+		planner = createPlanner();
+		engine = createEngine();
+
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {sdk});
+		engine.perform(profile, new DefaultPhaseSet(), planner.getProvisioningPlan(pcr, null, null).getOperands(), null, null);
+
+	}
+
+	public void testPartialProblemSingleton() {
+		//CDT will have a singleton conflict with SDK
+		//EMF will be good
+		IInstallableUnit cdt = createIU("CDT", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "SDKPart", new VersionRange("[2.0.0, 2.0.0]"), null));
+
+		IInstallableUnit emf = createIU("EMF", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), true);
+
+		createTestMetdataRepository(new IInstallableUnit[] {cdt, emf});
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {cdt, emf});
+		ProvisioningPlan plan = planner.getProvisioningPlan(pcr, null, null);
+		System.out.println(plan.getRequestStatus().getExplanations());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(cdt));
+		assertFalse(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(emf));
+		assertFalse(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(sdk));
+
+		//		assertTrue(plan.getRequestStatus(cdt).getSeverity() == IStatus.ERROR);
+		//		assertTrue(plan.getRequestStatus(cdt).getConflictsWithAnyRoots().contains(sdk));
+		//		assertTrue(plan.getRequestStatus(cdt).getConflictsWithInstalledRoots().contains(sdk));
+		//
+		//		assertTrue(plan.getRequestStatus(emf).getSeverity() != IStatus.ERROR);
+		//		assertEquals(0, plan.getRequestStatus(emf).getConflictsWithAnyRoots().size());
+		//		assertEquals(0, plan.getRequestStatus(emf).getConflictsWithInstalledRoots().size());
+		//
+		//		assertNull(plan.getRequestStatus(sdk));
+	}
+
+	public void testPartialProblemRequirement() {
+		//CDT will be missing a requirement
+		//EMF will be good
+		IInstallableUnit cdt = createIU("CDT", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "MissingPart", new VersionRange("[2.0.0, 2.0.0]"), null));
+
+		IInstallableUnit emf = createIU("EMF", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), true);
+
+		createTestMetdataRepository(new IInstallableUnit[] {cdt, emf});
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {cdt, emf});
+		ProvisioningPlan plan = planner.getProvisioningPlan(pcr, null, null);
+		System.out.println(plan.getRequestStatus().getExplanations());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(cdt));
+		assertFalse(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(emf));
+		assertFalse(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(sdk));
+
+		//		assertTrue(plan.getRequestStatus(cdt).getSeverity() == IStatus.ERROR);
+		//		assertEquals(0, plan.getRequestStatus(cdt).getConflictsWithAnyRoots().size());
+		//		assertEquals(0, plan.getRequestStatus(cdt).getConflictsWithInstalledRoots().size());
+		//
+		//		assertTrue(plan.getRequestStatus(emf).getSeverity() != IStatus.ERROR);
+		//		assertEquals(0, plan.getRequestStatus(emf).getConflictsWithAnyRoots().size());
+		//		assertEquals(0, plan.getRequestStatus(emf).getConflictsWithInstalledRoots().size());
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationSeveralConflictingRoots.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationSeveralConflictingRoots.java
new file mode 100644
index 0000000..28c05d0
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ExplanationSeveralConflictingRoots.java
@@ -0,0 +1,104 @@
+package org.eclipse.equinox.p2.tests.planner;
+
+import org.eclipse.equinox.internal.provisional.p2.core.Version;
+import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
+import org.eclipse.equinox.internal.provisional.p2.director.*;
+import org.eclipse.equinox.internal.provisional.p2.engine.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
+
+public class ExplanationSeveralConflictingRoots extends AbstractProvisioningTest {
+	private IProfile profile;
+	private IPlanner planner;
+	private IInstallableUnit sdk;
+
+	@Override
+	protected void setUp() throws Exception {
+		super.setUp();
+		sdk = createIU("SDK", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "SDKPart", new VersionRange("[1.0.0, 1.0.0]"), null));
+		IInstallableUnit sdkPart = createIU("SDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), true);
+		IInstallableUnit sdkPart2 = createIU("SDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("2.0.0")), true);
+
+		createTestMetdataRepository(new IInstallableUnit[] {sdk, sdkPart, sdkPart2});
+
+		profile = createProfile("TestProfile." + getName());
+		planner = createPlanner();
+		IEngine engine = createEngine();
+
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {sdk});
+		engine.perform(profile, new DefaultPhaseSet(), planner.getProvisioningPlan(pcr, null, null).getOperands(), null, null);
+
+	}
+
+	public void testConflictingSingletonAndMissingDependency() {
+		//CDT will have a singleton conflict with SDK
+		//EMF will be missing a dependency
+		IInstallableUnit cdt = createIU("CDT", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "SDKPart", new VersionRange("[2.0.0, 2.0.0]"), null));
+
+		IInstallableUnit emf = createIU("EMF", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "EMFPart", new VersionRange("[1.0.0, 1.0.0]"), null));
+
+		createTestMetdataRepository(new IInstallableUnit[] {cdt, emf});
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {cdt, emf});
+		ProvisioningPlan plan = planner.getProvisioningPlan(pcr, null, null);
+		System.out.println(plan.getRequestStatus().getExplanations());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(cdt));
+		//		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(emf));
+
+		//		assertTrue(plan.getRequestStatus(cdt).getConflictsWithInstalledRoots().contains(sdk));
+		//		assertTrue(plan.getRequestStatus(cdt).getConflictsWithAnyRoots().contains(sdk));
+		//		assertEquals(0, plan.getRequestStatus(emf).getConflictsWithAnyRoots().size());
+		//		assertEquals(0, plan.getRequestStatus(emf).getConflictsWithInstalledRoots().size());
+	}
+
+	public void testConflictingSingletonAndMissingDependency2() {
+		//CDT will have a singleton conflict EMF
+		//EMF will be missing a dependency and will be in conflict with CDT
+		IInstallableUnit cdt = createIU("CDT", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "ASingleton", new VersionRange("[2.0.0, 2.0.0]"), null));
+		IInstallableUnit aSingleton1 = createIU("ASingleton", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), true);
+		IInstallableUnit aSingleton2 = createIU("ASingleton", Version.fromOSGiVersion(new org.osgi.framework.Version("2.0.0")), true);
+
+		IRequiredCapability emfOnSingleton = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "ASingleton", new VersionRange("[1.0.0, 1.0.0]"), null, false, false);
+		IRequiredCapability emfMissing = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "EMFPart", new VersionRange("[1.0.0, 1.0.0]"), null, false, false);
+		IInstallableUnit emf = createIU("EMF", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), new IRequiredCapability[] {emfOnSingleton, emfMissing});
+
+		createTestMetdataRepository(new IInstallableUnit[] {aSingleton1, aSingleton2, cdt, emf});
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {cdt, emf});
+		ProvisioningPlan plan = planner.getProvisioningPlan(pcr, null, null);
+		System.out.println(plan.getRequestStatus().getExplanations());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(cdt));
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(emf));
+
+		//		assertEquals(0, plan.getRequestStatus(cdt).getConflictsWithInstalledRoots().size());
+		//		assertTrue(plan.getRequestStatus(cdt).getConflictsWithAnyRoots().contains(emf));
+		//		assertEquals(0, plan.getRequestStatus(emf).getConflictsWithInstalledRoots().size());
+		//		assertTrue(plan.getRequestStatus(emf).getConflictsWithAnyRoots().contains(cdt));
+	}
+
+	public void testConflictingSingletonAndMissingDependency3() {
+		//CDT will have a singleton conflict EMF and with the SDK
+		//EMF will be conflicting with CDT
+		IInstallableUnit cdt = createIU("CDT", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), createRequiredCapabilities(IInstallableUnit.NAMESPACE_IU_ID, "SDKPart", new VersionRange("[2.0.0, 2.0.0]"), null));
+		IInstallableUnit sdkPart3 = createIU("SDKPart", Version.fromOSGiVersion(new org.osgi.framework.Version("3.0.0")), true);
+
+		IRequiredCapability emfOnSingleton = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "SDKPart", new VersionRange("[1.0.0, 1.0.0]"), null, false, false);
+		IRequiredCapability emfMissing = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, "EMFPart", new VersionRange("[1.0.0, 1.0.0]"), null, false, false);
+		IInstallableUnit emf = createIU("EMF", Version.fromOSGiVersion(new org.osgi.framework.Version("1.0.0")), new IRequiredCapability[] {emfOnSingleton, emfMissing});
+
+		createTestMetdataRepository(new IInstallableUnit[] {sdkPart3, cdt, emf});
+		ProfileChangeRequest pcr = new ProfileChangeRequest(profile);
+		pcr.addInstallableUnits(new IInstallableUnit[] {cdt, emf});
+		ProvisioningPlan plan = planner.getProvisioningPlan(pcr, null, null);
+		System.out.println(plan.getRequestStatus().getExplanations());
+		//		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(cdt));
+		//		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(emf));
+
+		//		assertTrue(plan.getRequestStatus(cdt).getConflictsWithInstalledRoots().contains(sdk));
+		//		assertTrue(plan.getRequestStatus(cdt).getConflictsWithAnyRoots().contains(sdk));
+		//		assertTrue(plan.getRequestStatus(cdt).getConflictsWithAnyRoots().contains(emf));
+		//		assertEquals(0, plan.getRequestStatus(emf).getConflictsWithInstalledRoots().size());
+		//		assertTrue(plan.getRequestStatus(emf).getConflictsWithAnyRoots().contains(cdt));
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingDependency.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingDependency.java
index abcadad..7e97ec8 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingDependency.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingDependency.java
@@ -8,7 +8,9 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.*;
@@ -43,4 +45,20 @@ public class MissingDependency extends AbstractProvisioningTest {
 		ProvisioningPlan plan = planner.getProvisioningPlan(req, null, null);
 		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
 	}
+
+	public void testExplanation() {
+		ProfileChangeRequest req = new ProfileChangeRequest(profile);
+		req.addInstallableUnits(new IInstallableUnit[] {a1, b1});
+		ProvisioningPlan plan = planner.getProvisioningPlan(req, null, null);
+		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
+		Set explanation = plan.getRequestStatus().getExplanations();
+		System.out.println(explanation);
+		assertEquals(2, explanation.size());
+		Set rootConflictingIUs = plan.getRequestStatus().getConflictsWithInstalledRoots();
+		System.out.println(rootConflictingIUs);
+		assertEquals(1, rootConflictingIUs.size());
+		assertTrue(rootConflictingIUs.contains(b1));
+		assertFalse(rootConflictingIUs.contains(a1));
+		assertEquals(Explanation.MISSING_REQUIREMENT, plan.getRequestStatus().getShortExplanation());
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingNonGreedyRequirement.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingNonGreedyRequirement.java
index f1513ab..3da66a8 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingNonGreedyRequirement.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingNonGreedyRequirement.java
@@ -8,7 +8,9 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.*;
@@ -47,4 +49,15 @@ public class MissingNonGreedyRequirement extends AbstractProvisioningTest {
 		ProvisioningPlan plan = planner.getProvisioningPlan(req, null, null);
 		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
 	}
+
+	public void testExplanation() {
+		ProfileChangeRequest req = new ProfileChangeRequest(profile);
+		req.addInstallableUnits(new IInstallableUnit[] {a1});
+		ProvisioningPlan plan = planner.getProvisioningPlan(req, null, null);
+		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
+		Set explanation = plan.getRequestStatus().getExplanations();
+		assertFalse(explanation.isEmpty());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(a1));
+		assertEquals(Explanation.MISSING_REQUIREMENT, plan.getRequestStatus().getShortExplanation());
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingNonGreedyRequirement2.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingNonGreedyRequirement2.java
index c0a32ea..4c42709 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingNonGreedyRequirement2.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MissingNonGreedyRequirement2.java
@@ -8,7 +8,9 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.*;
@@ -44,4 +46,16 @@ public class MissingNonGreedyRequirement2 extends AbstractProvisioningTest {
 		ProvisioningPlan plan = planner.getProvisioningPlan(req, null, null);
 		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
 	}
+
+	public void testExplanation() {
+		ProfileChangeRequest req = new ProfileChangeRequest(profile);
+		req.addInstallableUnits(new IInstallableUnit[] {a1});
+		ProvisioningPlan plan = planner.getProvisioningPlan(req, null, null);
+		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
+		Set explanation = plan.getRequestStatus().getExplanations();
+		assertFalse(explanation.isEmpty());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(a1));
+		assertEquals(Explanation.MISSING_REQUIREMENT, plan.getRequestStatus().getShortExplanation());
+
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MultipleSingleton.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MultipleSingleton.java
index d8c229b..6c7ee0b 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MultipleSingleton.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/MultipleSingleton.java
@@ -8,11 +8,12 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
+import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
-import org.eclipse.equinox.internal.provisional.p2.director.IPlanner;
-import org.eclipse.equinox.internal.provisional.p2.director.ProfileChangeRequest;
+import org.eclipse.equinox.internal.provisional.p2.director.*;
 import org.eclipse.equinox.internal.provisional.p2.engine.IProfile;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
@@ -75,6 +76,20 @@ public class MultipleSingleton extends AbstractProvisioningTest {
 		assertEquals(IStatus.ERROR, planner.getProvisioningPlan(req, null, null).getStatus().getSeverity());
 	}
 
+	public void testExplanation2() {
+		ProfileChangeRequest req = new ProfileChangeRequest(profile);
+		req.addInstallableUnits(new IInstallableUnit[] {y});
+		ProvisioningPlan plan = planner.getProvisioningPlan(req, null, null);
+		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
+		Set explanation = plan.getRequestStatus().getExplanations();
+		System.out.println(explanation);
+		assertFalse(explanation.isEmpty());
+		assertEquals(Explanation.VIOLATED_SINGLETON_CONSTRAINT, plan.getRequestStatus().getShortExplanation());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(y));
+		assertEquals(1, plan.getRequestStatus().getConflictsWithInstalledRoots().size());
+
+	}
+
 	public void test3() {
 		//Test that we can install A3 and A4 together
 		ProfileChangeRequest req = new ProfileChangeRequest(profile);
@@ -89,6 +104,19 @@ public class MultipleSingleton extends AbstractProvisioningTest {
 		assertEquals(IStatus.ERROR, planner.getProvisioningPlan(req, null, null).getStatus().getSeverity());
 	}
 
+	public void testExplanation4() {
+		ProfileChangeRequest req = new ProfileChangeRequest(profile);
+		req.addInstallableUnits(new IInstallableUnit[] {w});
+		ProvisioningPlan plan = planner.getProvisioningPlan(req, null, null);
+		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
+		Set explanation = plan.getRequestStatus().getExplanations();
+		System.out.println(explanation);
+		assertFalse(explanation.isEmpty());
+		assertEquals(Explanation.VIOLATED_SINGLETON_CONSTRAINT, plan.getRequestStatus().getShortExplanation());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(w));
+
+	}
+
 	public void test5b() {
 		//Validate the setup
 		ProfileChangeRequest req = new ProfileChangeRequest(profile);
@@ -109,4 +137,18 @@ public class MultipleSingleton extends AbstractProvisioningTest {
 		req.addInstallableUnits(new IInstallableUnit[] {u, v});
 		assertEquals(IStatus.ERROR, planner.getProvisioningPlan(req, null, null).getStatus().getSeverity());
 	}
+
+	public void testExplanation5() {
+		ProfileChangeRequest req = new ProfileChangeRequest(profile);
+		req.addInstallableUnits(new IInstallableUnit[] {u, v});
+		ProvisioningPlan plan = planner.getProvisioningPlan(req, null, null);
+		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
+		Set explanation = plan.getRequestStatus().getExplanations();
+		assertFalse(explanation.isEmpty());
+		assertEquals(Explanation.VIOLATED_SINGLETON_CONSTRAINT, plan.getRequestStatus().getShortExplanation());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(u));
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(v));
+		System.out.println(explanation);
+
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest10.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest10.java
index 9fcfa7d..cc74981 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest10.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest10.java
@@ -8,8 +8,7 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
-import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
-
+import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
@@ -75,4 +74,18 @@ public class PatchTest10 extends AbstractProvisioningTest {
 		ProvisioningPlan plan3 = planner.getProvisioningPlan(req3, null, null);
 		assertEquals(IStatus.ERROR, plan3.getStatus().getSeverity());
 	}
+
+	public void testExplanation() {
+		ProfileChangeRequest req3 = new ProfileChangeRequest(profile1);
+		req3.addInstallableUnits(new IInstallableUnit[] {a1, p1, pp1});
+		ProvisioningPlan plan3 = planner.getProvisioningPlan(req3, null, null);
+		assertEquals(IStatus.ERROR, plan3.getStatus().getSeverity());
+		Set problems = plan3.getRequestStatus().getConflictsWithInstalledRoots();
+		System.out.println(problems);
+		System.out.println(plan3.getRequestStatus().getExplanations());
+		assertEquals(3, problems.size());
+		assertTrue(problems.contains(a1));
+		assertTrue(problems.contains(p1));
+		assertTrue(problems.contains(pp1));
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest12.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest12.java
index 88b4e2c..4d1f603 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest12.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest12.java
@@ -8,9 +8,9 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
-import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
-
+import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.*;
@@ -66,4 +66,14 @@ public class PatchTest12 extends AbstractProvisioningTest {
 		assertTrue(IStatus.ERROR == plan3.getStatus().getSeverity());
 
 	}
+
+	public void testExplanation1() {
+		ProfileChangeRequest req3 = new ProfileChangeRequest(profile1);
+		req3.addInstallableUnits(new IInstallableUnit[] {a1, p1});
+		ProvisioningPlan plan3 = planner.getProvisioningPlan(req3, null, null);
+		assertTrue(IStatus.ERROR == plan3.getStatus().getSeverity());
+		Set conflictRootIUs = plan3.getRequestStatus().getConflictsWithInstalledRoots();
+		assertTrue(conflictRootIUs.contains(p1));
+		assertEquals(Explanation.MISSING_REQUIREMENT, plan3.getRequestStatus().getShortExplanation());
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest2.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest2.java
index 7d81a4b..60c396e 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest2.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest2.java
@@ -8,9 +8,9 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
-import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
-
+import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.*;
@@ -90,4 +90,30 @@ public class PatchTest2 extends AbstractProvisioningTest {
 		assertEquals(IStatus.ERROR, plan5.getStatus().getSeverity());
 
 	}
+
+	public void testExplanation3() {
+		//p2 does not cause a1 to resolve therefore the application fails
+		ProfileChangeRequest req3 = new ProfileChangeRequest(profile1);
+		req3.addInstallableUnits(new IInstallableUnit[] {a1, p2});
+		ProvisioningPlan plan3 = planner.getProvisioningPlan(req3, null, null);
+		assertEquals(IStatus.ERROR, plan3.getStatus().getSeverity());
+		assertEquals(Explanation.MISSING_REQUIREMENT, plan3.getRequestStatus().getShortExplanation());
+		System.out.println(plan3.getRequestStatus().getExplanations());
+		Set conflictingRoot = plan3.getRequestStatus().getConflictsWithInstalledRoots();
+		assertTrue(conflictingRoot.contains(a1));
+		assertEquals(1, conflictingRoot.size());
+	}
+
+	public void testExplanation5() {
+		//p4 does not cause a1 to resolve therefore the application fails
+		ProfileChangeRequest req5 = new ProfileChangeRequest(profile1);
+		req5.addInstallableUnits(new IInstallableUnit[] {a1, p4});
+		ProvisioningPlan plan5 = planner.getProvisioningPlan(req5, null, null);
+		assertEquals(IStatus.ERROR, plan5.getStatus().getSeverity());
+		assertEquals(Explanation.MISSING_REQUIREMENT, plan5.getRequestStatus().getShortExplanation());
+		System.out.println(plan5.getRequestStatus().getExplanations());
+		Set conflictingRoot = plan5.getRequestStatus().getConflictsWithInstalledRoots();
+		assertTrue(conflictingRoot.contains(a1));
+		assertEquals(1, conflictingRoot.size());
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest6.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest6.java
index cb5831b..e572225 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest6.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest6.java
@@ -8,9 +8,9 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
-import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
-
+import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.*;
@@ -96,4 +96,16 @@ public class PatchTest6 extends AbstractProvisioningTest {
 		assertInstallOperand(plan5, d1);
 		assertInstallOperand(plan5, c1);
 	}
+
+	public void testExplanation1() {
+		//Confirm that a1 and c1 can't be installed
+		ProfileChangeRequest req1 = new ProfileChangeRequest(profile1);
+		req1.addInstallableUnits(new IInstallableUnit[] {a1, c1});
+		ProvisioningPlan plan1 = planner.getProvisioningPlan(req1, null, null);
+		assertEquals(IStatus.ERROR, plan1.getStatus().getSeverity());
+		assertEquals(Explanation.MISSING_REQUIREMENT, plan1.getRequestStatus().getShortExplanation());
+		Set conflictingRoots = plan1.getRequestStatus().getConflictsWithInstalledRoots();
+		assertEquals(1, conflictingRoots.size());
+		assertTrue(conflictingRoots.contains(a1) || conflictingRoots.contains(c1));
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest9.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest9.java
index 47b4a43..ae45ae2 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest9.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTest9.java
@@ -8,9 +8,9 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
-import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
-
+import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.*;
@@ -59,6 +59,18 @@ public class PatchTest9 extends AbstractProvisioningTest {
 		assertEquals(IStatus.ERROR, plan1.getStatus().getSeverity());
 	}
 
+	public void testExplanation() {
+		//The application of the patch does not succeed because there is no C matching the requirement imposed by the patch
+		ProfileChangeRequest req1 = new ProfileChangeRequest(profile1);
+		req1.addInstallableUnits(new IInstallableUnit[] {a1, p1});
+		ProvisioningPlan plan1 = planner.getProvisioningPlan(req1, null, null);
+		assertEquals(IStatus.ERROR, plan1.getStatus().getSeverity());
+		assertEquals(Explanation.MISSING_REQUIREMENT, plan1.getRequestStatus().getShortExplanation());
+		Set conflictingRoots = plan1.getRequestStatus().getConflictsWithInstalledRoots();
+		assertEquals(1, conflictingRoots.size());
+		assertTrue(conflictingRoots.contains(p1));
+	}
+
 	public void testPatchApply() {
 		//The application of the patch succeed because the dependency that PP puts on C is optional
 		ProfileChangeRequest req2 = new ProfileChangeRequest(profile1);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate.java
index f099c2c..f570ed7 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/PatchTestUpdate.java
@@ -8,9 +8,9 @@
  ******************************************************************************/
 package org.eclipse.equinox.p2.tests.planner;
 
-import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
-
+import java.util.Set;
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.director.*;
@@ -77,4 +77,18 @@ public class PatchTestUpdate extends AbstractProvisioningTest {
 		ProvisioningPlan plan = planner.getProvisioningPlan(req1, null, null);
 		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
 	}
+
+	public void testExplanation() {
+		//The update of the feature is expected to fail because the patches are installed without flexibility (strict mode) 
+		ProfileChangeRequest req1 = new ProfileChangeRequest(profile1);
+		req1.addInstallableUnits(new IInstallableUnit[] {p2Feature20});
+		req1.setInstallableUnitInclusionRules(p2Feature20, PlannerHelper.createStrictInclusionRule(p2Feature20));
+		req1.removeInstallableUnits(new IInstallableUnit[] {p2Feature});
+		ProvisioningPlan plan = planner.getProvisioningPlan(req1, null, null);
+		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
+		Set conflictingRoot = plan.getRequestStatus().getConflictsWithInstalledRoots();
+		assertEquals(1, conflictingRoot.size());
+		assertTrue(conflictingRoot.contains(p2Feature20));
+		assertEquals(Explanation.VIOLATED_SINGLETON_CONSTRAINT, plan.getRequestStatus().getShortExplanation());
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ProvisioningPlanQueryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ProvisioningPlanQueryTest.java
index b06c477..025703c 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ProvisioningPlanQueryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/ProvisioningPlanQueryTest.java
@@ -17,22 +17,22 @@ public class ProvisioningPlanQueryTest extends AbstractProvisioningTest {
 
 	public void testAddition() {
 		Operand[] ops = new Operand[] {new InstallableUnitOperand(null, createIU("A"))};
-		Collector c = new ProvisioningPlan(Status.OK_STATUS, ops, null).getAdditions().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor());
+		Collector c = new ProvisioningPlan(Status.OK_STATUS, ops, null, null).getAdditions().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor());
 		assertEquals(1, c.size());
-		assertEquals(0, new ProvisioningPlan(Status.OK_STATUS, ops, null).getRemovals().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor()).size());
+		assertEquals(0, new ProvisioningPlan(Status.OK_STATUS, ops, null, null).getRemovals().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor()).size());
 	}
 
 	public void testRemoval() {
 		Operand[] ops = new Operand[] {new InstallableUnitOperand(createIU("A"), null)};
-		Collector c = new ProvisioningPlan(Status.OK_STATUS, ops, null).getRemovals().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor());
+		Collector c = new ProvisioningPlan(Status.OK_STATUS, ops, null, null).getRemovals().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor());
 		assertEquals(1, c.size());
-		assertEquals(0, new ProvisioningPlan(Status.OK_STATUS, ops, null).getAdditions().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor()).size());
+		assertEquals(0, new ProvisioningPlan(Status.OK_STATUS, ops, null, null).getAdditions().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor()).size());
 	}
 
 	public void testUpdate() {
 		Operand[] ops = new Operand[] {new InstallableUnitOperand(createIU("A"), createIU("B"))};
-		Collector c = new ProvisioningPlan(Status.OK_STATUS, ops, null).getRemovals().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor());
+		Collector c = new ProvisioningPlan(Status.OK_STATUS, ops, null, null).getRemovals().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor());
 		assertEquals(1, c.size());
-		assertEquals(1, new ProvisioningPlan(Status.OK_STATUS, ops, null).getAdditions().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor()).size());
+		assertEquals(1, new ProvisioningPlan(Status.OK_STATUS, ops, null, null).getAdditions().query(InstallableUnitQuery.ANY, new Collector(), new NullProgressMonitor()).size());
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SimpleSingleton.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SimpleSingleton.java
index 3448ba7..6a24664 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SimpleSingleton.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/planner/SimpleSingleton.java
@@ -9,10 +9,10 @@
 package org.eclipse.equinox.p2.tests.planner;
 
 import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.p2.director.Explanation;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
-import org.eclipse.equinox.internal.provisional.p2.director.IPlanner;
-import org.eclipse.equinox.internal.provisional.p2.director.ProfileChangeRequest;
+import org.eclipse.equinox.internal.provisional.p2.director.*;
 import org.eclipse.equinox.internal.provisional.p2.engine.IProfile;
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
@@ -49,4 +49,13 @@ public class SimpleSingleton extends AbstractProvisioningTest {
 		req.addInstallableUnits(new IInstallableUnit[] {y});
 		assertEquals(IStatus.ERROR, planner.getProvisioningPlan(req, null, null).getStatus().getSeverity());
 	}
+
+	public void testExplanation() {
+		ProfileChangeRequest req = new ProfileChangeRequest(profile);
+		req.addInstallableUnits(new IInstallableUnit[] {y});
+		ProvisioningPlan plan = planner.getProvisioningPlan(req, null, null);
+		assertEquals(IStatus.ERROR, plan.getStatus().getSeverity());
+		assertEquals(Explanation.VIOLATED_SINGLETON_CONSTRAINT, plan.getRequestStatus().getShortExplanation());
+		assertTrue(plan.getRequestStatus().getConflictsWithInstalledRoots().contains(y));
+	}
 }
