commit 2fa779438a538c76347292c073b95b2ab4dd3639
Author: John Arthorne <johna>
Date:   Fri Sep 26 19:55:59 2008 +0000

    Bug 235652 RepositoryManager cleanup

0	28	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/AbstractRepositoryManager.java
26	596	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryManager.java
0	5	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/Messages.java
0	5	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/messages.properties
5	145	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/provisional/p2/artifact/repository/IArtifactRepositoryManager.java
4	1	bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
719	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/AbstractRepositoryManager.java
12	1	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/Messages.java
8	1	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/messages.properties
161	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/repository/IRepositoryManager.java
0	4	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/Messages.java
28	676	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryManager.java
0	4	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/messages.properties
5	147	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/provisional/p2/metadata/repository/IMetadataRepositoryManager.java
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/AbstractRepositoryManager.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/AbstractRepositoryManager.java
deleted file mode 100644
index 84e23fc..0000000
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/AbstractRepositoryManager.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.artifact.repository;
-
-import java.net.URL;
-import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
-import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
-import org.eclipse.equinox.internal.provisional.p2.core.repository.RepositoryEvent;
-
-/**
- * Common code shared between artifact and metadata repository managers.
- */
-public class AbstractRepositoryManager {
-	protected void broadcastChangeEvent(URL location, int repositoryType, int kind, boolean isEnabled) {
-		IProvisioningEventBus bus = (IProvisioningEventBus) ServiceHelper.getService(Activator.getContext(), IProvisioningEventBus.class.getName());
-		if (bus != null)
-			bus.publishEvent(new RepositoryEvent(location, repositoryType, kind, isEnabled));
-	}
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryManager.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryManager.java
index 56b6b1a..22ce654 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryManager.java
@@ -10,183 +10,31 @@
  ******************************************************************************/
 package org.eclipse.equinox.internal.p2.artifact.repository;
 
-import java.lang.ref.SoftReference;
-import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.*;
 import org.eclipse.core.runtime.*;
-import org.eclipse.core.runtime.preferences.ConfigurationScope;
-import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
-import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
+import org.eclipse.equinox.internal.p2.core.helpers.*;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.*;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
-import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
-import org.eclipse.equinox.internal.provisional.p2.core.eventbus.ProvisioningListener;
 import org.eclipse.equinox.internal.provisional.p2.core.location.AgentLocation;
 import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
-import org.eclipse.equinox.internal.provisional.p2.core.repository.RepositoryEvent;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IArtifactKey;
 import org.eclipse.equinox.internal.provisional.spi.p2.artifact.repository.IArtifactRepositoryFactory;
-import org.eclipse.osgi.util.NLS;
-import org.osgi.service.prefs.BackingStoreException;
-import org.osgi.service.prefs.Preferences;
 
 /**
  * Default implementation of {@link IArtifactRepositoryManager}.
  * 
  * TODO the current assumption that the "location" is the dir/root limits us to 
  * having just one repository in a given URL..  
- * TODO Merge common parts with MetadataRepositoryManager
  */
-public class ArtifactRepositoryManager extends AbstractRepositoryManager implements IArtifactRepositoryManager, ProvisioningListener {
-	static class RepositoryInfo {
-		String description;
-		boolean isSystem = false;
-		boolean isEnabled = true;
-		URL location;
-		String name;
-		String suffix;
-		SoftReference repository;
-	}
-
-	private static final String ATTR_SUFFIX = "suffix"; //$NON-NLS-1$
-	private static final String DEFAULT_SUFFIX = "artifacts.xml"; //$NON-NLS-1$
-	private static final String EL_FACTORY = "factory"; //$NON-NLS-1$
-
-	private static final String EL_FILTER = "filter"; //$NON-NLS-1$
-	private static final String KEY_DESCRIPTION = "description"; //$NON-NLS-1$
-	private static final String KEY_ENABLED = "enabled"; //$NON-NLS-1$
-	private static final String KEY_NAME = "name"; //$NON-NLS-1$
-	private static final String KEY_PROVIDER = "provider"; //$NON-NLS-1$
-	private static final String KEY_SUFFIX = "suffix"; //$NON-NLS-1$
-	private static final String KEY_SYSTEM = "isSystem"; //$NON-NLS-1$
-	private static final String KEY_TYPE = "type"; //$NON-NLS-1$
-	private static final String KEY_URL = "url"; //$NON-NLS-1$
-	private static final String KEY_VERSION = "version"; //$NON-NLS-1$
-	private static final String NODE_REPOSITORIES = "repositories"; //$NON-NLS-1$
-
-	/**
-	 * Map of String->RepositoryInfo, where String is the repository key
-	 * obtained via getKey(URL).
-	 */
-	private Map repositories = null;
-	//lock object to be held when referring to the repositories field
-	private final Object repositoryLock = new Object();
-
-	/**
-	 * Cache List of repositories that are not reachable. Maintain cache
-	 * for short duration because repository may become available at any time.
-	 */
-	private SoftReference unavailableRepositories;
+public class ArtifactRepositoryManager extends AbstractRepositoryManager implements IArtifactRepositoryManager {
 
 	public ArtifactRepositoryManager() {
-		IProvisioningEventBus bus = (IProvisioningEventBus) ServiceHelper.getService(Activator.getContext(), IProvisioningEventBus.class.getName());
-		if (bus != null)
-			bus.addListener(this);
-		//initialize repositories lazily
+		super();
 	}
 
 	public void addRepository(IArtifactRepository repository) {
-		addRepository(repository, true, null);
-	}
-
-	private void addRepository(IArtifactRepository repository, boolean signalAdd, String suffix) {
-		boolean added = true;
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			String key = getKey(repository);
-			RepositoryInfo info = (RepositoryInfo) repositories.get(key);
-			if (info == null)
-				info = new RepositoryInfo();
-			info.repository = new SoftReference(repository);
-			info.name = repository.getName();
-			info.description = repository.getDescription();
-			info.location = repository.getLocation();
-			String value = (String) repository.getProperties().get(IRepository.PROP_SYSTEM);
-			info.isSystem = value == null ? false : Boolean.valueOf(value).booleanValue();
-			info.suffix = suffix;
-			added = repositories.put(getKey(repository), info) == null;
-		}
-		// save the given repository in the preferences.
-		remember(repository, suffix);
-		if (added && signalAdd)
-			broadcastChangeEvent(repository.getLocation(), IRepository.TYPE_ARTIFACT, RepositoryEvent.ADDED, true);
-	}
-
-	public void addRepository(URL location) {
-		addRepository(location, true);
-	}
-
-	private void addRepository(URL location, boolean isEnabled) {
-		Assert.isNotNull(location);
-		RepositoryInfo info = new RepositoryInfo();
-		info.location = location;
-		info.isEnabled = isEnabled;
-		boolean added = true;
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			if (contains(location))
-				return;
-			added = repositories.put(getKey(location), info) == null;
-		}
-		// save the given repository in the preferences.
-		remember(info);
-		if (added)
-			broadcastChangeEvent(location, IRepository.TYPE_ARTIFACT, RepositoryEvent.ADDED, isEnabled);
-	}
-
-	/**
-	 * Check if we recently attempted to load the given location and failed
-	 * to find anything. Returns <code>true</code> if the repository was not
-	 * found, and <code>false</code> otherwise.
-	 */
-	private boolean checkNotFound(URL location) {
-		if (unavailableRepositories == null)
-			return false;
-		List badRepos = (List) unavailableRepositories.get();
-		if (badRepos == null)
-			return false;
-		return badRepos.contains(location);
-	}
-
-	/**
-	 * Clear the fact that we tried to load a repository at this location and did not find anything.
-	 */
-	private void clearNotFound(URL location) {
-		List badRepos;
-		if (unavailableRepositories != null) {
-			badRepos = (List) unavailableRepositories.get();
-			if (badRepos != null) {
-				badRepos.remove(location);
-				return;
-			}
-		}
-	}
-
-	boolean contains(URL location) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			return repositories.containsKey(getKey(location));
-		}
-	}
-
-	private Object createExecutableExtension(IExtension extension, String element) {
-		IConfigurationElement[] elements = extension.getConfigurationElements();
-		for (int i = 0; i < elements.length; i++) {
-			if (elements[i].getName().equals(element)) {
-				try {
-					return elements[i].createExecutableExtension("class"); //$NON-NLS-1$
-				} catch (CoreException e) {
-					log("Error loading repository extension: " + extension.getUniqueIdentifier(), e); //$NON-NLS-1$
-					return null;
-				}
-			}
-		}
-		log("Malformed repository extension: " + extension.getUniqueIdentifier(), null); //$NON-NLS-1$
-		return null;
+		super.addRepository(repository, true, null);
 	}
 
 	public IArtifactRequest createMirrorRequest(IArtifactKey key, IArtifactRepository destination, Properties destinationDescriptorProperties, Properties destinationRepositoryProperties) {
@@ -195,10 +43,9 @@ public class ArtifactRepositoryManager extends AbstractRepositoryManager impleme
 
 	public IArtifactRepository createRepository(URL location, String name, String type, Map properties) throws ProvisionException {
 		synchronized (repositoryLock) {
-
 			boolean loaded = false;
 			try {
-				loadRepository(location, (IProgressMonitor) null, type, true);
+				loadRepository(location, (IProgressMonitor) null, type);
 				loaded = true;
 			} catch (ProvisionException e) {
 				//expected - fall through and create a new repository
@@ -220,354 +67,48 @@ public class ArtifactRepositoryManager extends AbstractRepositoryManager impleme
 		}
 	}
 
-	private void fail(URL location, int code) throws ProvisionException {
-		String msg = null;
-		switch (code) {
-			case ProvisionException.REPOSITORY_EXISTS :
-				msg = NLS.bind(Messages.repoMan_exists, location);
-				break;
-			case ProvisionException.REPOSITORY_UNKNOWN_TYPE :
-				msg = NLS.bind(Messages.repoMan_unknownType, location);
-				break;
-			case ProvisionException.REPOSITORY_FAILED_READ :
-				msg = NLS.bind(Messages.repoMan_failedRead, location);
-				break;
-			case ProvisionException.REPOSITORY_NOT_FOUND :
-				msg = NLS.bind(Messages.repoMan_notExists, location);
-				break;
-		}
-		if (msg == null)
-			msg = Messages.repoMan_internalError;
-		throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, code, msg, null));
-	}
-
-	private IExtension[] findMatchingRepositoryExtensions(String suffix, String type) {
-		IConfigurationElement[] elt = null;
-		if (type != null && type.length() > 0) {
-			IExtension ext = RegistryFactory.getRegistry().getExtension(Activator.REPO_PROVIDER_XPT, type);
-			elt = (ext != null) ? ext.getConfigurationElements() : new IConfigurationElement[0];
-		} else {
-			elt = RegistryFactory.getRegistry().getConfigurationElementsFor(Activator.REPO_PROVIDER_XPT);
-		}
-		int count = 0;
-		for (int i = 0; i < elt.length; i++) {
-			if (EL_FILTER.equals(elt[i].getName())) {
-				if (!suffix.equals(elt[i].getAttribute(ATTR_SUFFIX))) {
-					elt[i] = null;
-				} else {
-					count++;
-				}
-			} else {
-				elt[i] = null;
-			}
-		}
-		IExtension[] results = new IExtension[count];
-		for (int i = 0; i < elt.length; i++) {
-			if (elt[i] != null)
-				results[--count] = elt[i].getDeclaringExtension();
-		}
-		return results;
-	}
-
-	private String[] getAllSuffixes() {
-		IConfigurationElement[] elements = RegistryFactory.getRegistry().getConfigurationElementsFor(Activator.REPO_PROVIDER_XPT);
-		ArrayList result = new ArrayList(elements.length);
-		result.add(DEFAULT_SUFFIX);
-		for (int i = 0; i < elements.length; i++) {
-			if (elements[i].getName().equals(EL_FILTER)) {
-				String suffix = elements[i].getAttribute(ATTR_SUFFIX);
-				if (!result.contains(suffix))
-					result.add(suffix);
-			}
-		}
-		return (String[]) result.toArray(new String[result.size()]);
-	}
-
-	/*
-	 * Return an encoded repository key that is suitable for using
-	 * as the name of a preference node.
-	 */
-	private String getKey(IArtifactRepository repository) {
-		return getKey(repository.getLocation());
-	}
-
-	/*
-	 * Return a string key based on the given repository location which
-	 * is suitable for use as a preference node name.
-	 */
-	private String getKey(URL location) {
-		String key = location.toExternalForm().replace('/', '_');
-		if (key.endsWith("_")) //$NON-NLS-1$
-			key = key.substring(0, key.length() - 1);
-		return key;
-	}
-
-	public URL[] getKnownRepositories(int flags) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			ArrayList result = new ArrayList();
-			int i = 0;
-			for (Iterator it = repositories.values().iterator(); it.hasNext(); i++) {
-				RepositoryInfo info = (RepositoryInfo) it.next();
-				if (matchesFlags(info, flags))
-					result.add(info.location);
-			}
-			return (URL[]) result.toArray(new URL[result.size()]);
-		}
-	}
-
-	/*
-	 * Return the root preference node where we store the repository information.
-	 */
-	private Preferences getPreferences() {
-		return new ConfigurationScope().getNode(Activator.ID).node(NODE_REPOSITORIES);
-	}
-
-	public IArtifactRepository getRepository(URL location) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
-			if (info == null || info.repository == null)
-				return null;
-			IArtifactRepository repo = (IArtifactRepository) info.repository.get();
-			//update our repository info because the repository may have changed
-			if (repo != null)
-				addRepository(repo);
-			return repo;
-		}
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepositoryManager#getRepositoryProperty(java.net.URL, java.lang.String)
-	 */
-	public String getRepositoryProperty(URL location, String key) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
-			if (info == null)
-				return null;// Repository not found
-			if (IRepository.PROP_DESCRIPTION.equals(key))
-				return info.description;
-			if (IRepository.PROP_NAME.equals(key))
-				return info.name;
-			if (IRepository.PROP_SYSTEM.equals(key))
-				return Boolean.toString(info.isSystem);
-			// Key not known, return null
+	protected IRepository factoryLoad(URL location, IExtension extension, SubMonitor monitor) throws ProvisionException {
+		IArtifactRepositoryFactory factory = (IArtifactRepositoryFactory) createExecutableExtension(extension, EL_FACTORY);
+		if (factory == null)
 			return null;
-		}
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepositoryManager#getEnabled(java.net.URL)
-	 */
-	public boolean isEnabled(URL location) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
-			if (info != null)
-				return info.isEnabled;
-			// Repository not found, return false
-			return false;
-		}
+		return factory.load(location, monitor.newChild(10));
 	}
 
-	public IArtifactRepository loadRepository(URL location, IProgressMonitor monitor) throws ProvisionException {
-		return loadRepository(location, monitor, null, true);
+	protected String getBundleId() {
+		return Activator.ID;
 	}
 
-	private IArtifactRepository loadRepository(URL location, IProgressMonitor monitor, String type, boolean signalAdd) throws ProvisionException {
-		// TODO do something with the monitor
-		synchronized (repositoryLock) {
-			IArtifactRepository result = getRepository(location);
-			if (result != null)
-				return result;
-			if (checkNotFound(location))
-				fail(location, ProvisionException.REPOSITORY_NOT_FOUND);
-			String[] suffixes = sortSuffixes(getAllSuffixes(), location);
-			SubMonitor sub = SubMonitor.convert(monitor, suffixes.length * 100);
-			for (int i = 0; i < suffixes.length; i++) {
-				result = loadRepository(location, suffixes[i], type, sub.newChild(100));
-				if (result != null) {
-					addRepository(result, signalAdd, suffixes[i]);
-					return result;
-				}
-			}
-			if (Boolean.valueOf(getRepositoryProperty(location, IRepository.PROP_SYSTEM)).booleanValue())
-				removeRepository(location);
-			else
-				rememberNotFound(location);
-		}
-		fail(location, ProvisionException.REPOSITORY_NOT_FOUND);
-		return null;
+	protected String getDefaultSuffix() {
+		return "artifacts.xml"; //$NON-NLS-1$
 	}
 
-	private IArtifactRepository loadRepository(URL location, String suffix, String type, SubMonitor monitor) {
-		IExtension[] providers = findMatchingRepositoryExtensions(suffix, type);
-		// Loop over the candidates and return the first one that successfully loads
-		monitor.beginTask("", providers.length * 10); //$NON-NLS-1$
-		for (int i = 0; i < providers.length; i++)
-			try {
-				IArtifactRepositoryFactory factory = (IArtifactRepositoryFactory) createExecutableExtension(providers[i], EL_FACTORY);
-				if (factory != null)
-					return factory.load(location, monitor.newChild(10));
-			} catch (CoreException e) {
-				if (e.getStatus().getCode() != ProvisionException.REPOSITORY_NOT_FOUND)
-					log("Unable to load repository: " + location, e); //$NON-NLS-1$
-			}
-		return null;
-	}
-
-	protected void log(String message, Throwable t) {
-		LogHelper.log(new Status(IStatus.ERROR, Activator.ID, message, t));
-	}
-
-	private boolean matchesFlags(RepositoryInfo info, int flags) {
-		if ((flags & REPOSITORIES_SYSTEM) == REPOSITORIES_SYSTEM)
-			if (!info.isSystem)
-				return false;
-		if ((flags & REPOSITORIES_NON_SYSTEM) == REPOSITORIES_NON_SYSTEM)
-			if (info.isSystem)
-				return false;
-		if ((flags & REPOSITORIES_DISABLED) == REPOSITORIES_DISABLED) {
-			if (info.isEnabled)
-				return false;
-		} else {
-			//ignore disabled repositories for all other flag types
-			if (!info.isEnabled)
-				return false;
-		}
-		if ((flags & REPOSITORIES_LOCAL) == REPOSITORIES_LOCAL)
-			return "file".equals(info.location.getProtocol()); //$NON-NLS-1$
-		return true;
-	}
-
-	/*(non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.core.eventbus.ProvisioningListener#notify(java.util.EventObject)
-	 */
-	public void notify(EventObject o) {
-		if (o instanceof RepositoryEvent) {
-			RepositoryEvent event = (RepositoryEvent) o;
-			if (event.getKind() == RepositoryEvent.DISCOVERED && event.getRepositoryType() == IRepository.TYPE_ARTIFACT)
-				addRepository(event.getRepositoryLocation(), event.isRepositoryEnabled());
-		}
+	protected String getRepositoryProviderExtensionPointId() {
+		return Activator.REPO_PROVIDER_XPT;
 	}
 
 	/**
-	 * Sets a preference and returns <code>true</code> if the preference
-	 * was actually changed.
+	 * Restores metadata repositories specified as system properties.
 	 */
-	private boolean putValue(Preferences node, String key, String newValue) {
-		String oldValue = node.get(key, null);
-		if (oldValue == newValue || (oldValue != null && oldValue.equals(newValue)))
-			return false;
-		if (newValue == null)
-			node.remove(key);
-		else
-			node.put(key, newValue);
-		return true;
+	protected String getRepositorySystemProperty() {
+		return "eclipse.p2.artifactRepository"; //$NON-NLS-1$
 	}
 
-	public IArtifactRepository refreshRepository(URL location, IProgressMonitor monitor) throws ProvisionException {
-		synchronized (repositoryLock) {
-			clearNotFound(location);
-			boolean wasEnabled = isEnabled(location);
-			//remove the repository so  event is broadcast and repositories can clear their caches
-			if (!removeRepository(location))
-				fail(location, ProvisionException.REPOSITORY_NOT_FOUND);
-			try {
-				IArtifactRepository result = loadRepository(location, monitor, null, true);
-				if (!wasEnabled)
-					setEnabled(location, false);
-				return result;
-			} catch (ProvisionException e) {
-				//if we failed to load, make sure the repository is not lost
-				addRepository(location);
-				if (!wasEnabled)
-					setEnabled(location, false);
-				throw e;
-			}
-		}
+	protected int getRepositoryType() {
+		return IRepository.TYPE_ARTIFACT;
 	}
 
-	/*
-	 * Add the given repository object to the preferences and save.
-	 */
-	private void remember(IArtifactRepository repository, String suffix) {
-		boolean changed = false;
-		Preferences node = getPreferences().node(getKey(repository));
-		changed |= putValue(node, KEY_URL, repository.getLocation().toExternalForm());
-		changed |= putValue(node, KEY_DESCRIPTION, repository.getDescription());
-		changed |= putValue(node, KEY_NAME, repository.getName());
-		changed |= putValue(node, KEY_PROVIDER, repository.getProvider());
-		changed |= putValue(node, KEY_TYPE, repository.getType());
-		changed |= putValue(node, KEY_VERSION, repository.getVersion());
-		changed |= putValue(node, KEY_SYSTEM, (String) repository.getProperties().get(IRepository.PROP_SYSTEM));
-		changed |= putValue(node, KEY_SUFFIX, suffix);
-		if (changed)
-			saveToPreferences();
+	public IArtifactRepository loadRepository(URL location, IProgressMonitor monitor) throws ProvisionException {
+		return (IArtifactRepository) loadRepository(location, monitor, null);
 	}
 
-	/*
-	 * Save the list of repositories in the preference store.
-	 */
-	private void remember(RepositoryInfo info) {
-		boolean changed = false;
-		Preferences node = getPreferences().node(getKey(info.location));
-		changed |= putValue(node, KEY_URL, info.location.toExternalForm());
-		changed |= putValue(node, KEY_SYSTEM, Boolean.toString(info.isSystem));
-		changed |= putValue(node, KEY_DESCRIPTION, info.description);
-		changed |= putValue(node, KEY_NAME, info.name);
-		changed |= putValue(node, KEY_ENABLED, Boolean.toString(info.isEnabled));
-		changed |= putValue(node, KEY_SUFFIX, info.suffix);
-		if (changed)
-			saveToPreferences();
+	public IArtifactRepository refreshRepository(URL location, IProgressMonitor monitor) throws ProvisionException {
+		return (IArtifactRepository) basicRefreshRepository(location, monitor);
 	}
 
 	/**
-	 * Cache the fact that we tried to load a repository at this location and did not find anything.
+	 * Restore the download cache
 	 */
-	private void rememberNotFound(URL location) {
-		List badRepos;
-		if (unavailableRepositories != null) {
-			badRepos = (List) unavailableRepositories.get();
-			if (badRepos != null) {
-				badRepos.add(location);
-				return;
-			}
-		}
-		badRepos = new ArrayList();
-		badRepos.add(location);
-		unavailableRepositories = new SoftReference(badRepos);
-	}
-
-	public boolean removeRepository(URL toRemove) {
-		Assert.isNotNull(toRemove);
-		final String repoKey = getKey(toRemove);
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			if (repositories.remove(repoKey) == null)
-				return false;
-		}
-		// remove the repository from the preference store
-		try {
-			getPreferences().node(repoKey).removeNode();
-			saveToPreferences();
-		} catch (BackingStoreException e) {
-			log("Error saving preferences", e); //$NON-NLS-1$
-		}
-		//TODO: compute and pass appropriate isEnabled flag
-		broadcastChangeEvent(toRemove, IRepository.TYPE_ARTIFACT, RepositoryEvent.REMOVED, true);
-		return true;
-	}
-
-	private void restoreDownloadCache() {
+	protected void restoreSpecialRepositories() {
 		// TODO while recreating, we may want to have proxies on repo instead of the real repo object to limit what is activated.
 		AgentLocation location = (AgentLocation) ServiceHelper.getService(Activator.getContext(), AgentLocation.class.getName());
 		if (location == null)
@@ -590,115 +131,4 @@ public class ArtifactRepositoryManager extends AbstractRepositoryManager impleme
 		}
 	}
 
-	/*
-	 * Load the list of repositories from the preferences.
-	 */
-	private void restoreFromPreferences() {
-		// restore the list of repositories from the preference store
-		Preferences node = getPreferences();
-		String[] children;
-		try {
-			children = node.childrenNames();
-		} catch (BackingStoreException e) {
-			log("Error restoring repositories from preferences", e); //$NON-NLS-1$
-			return;
-		}
-		for (int i = 0; i < children.length; i++) {
-			Preferences child = node.node(children[i]);
-			String locationString = child.get(KEY_URL, null);
-			if (locationString == null)
-				continue;
-			try {
-				RepositoryInfo info = new RepositoryInfo();
-				info.location = new URL(locationString);
-				info.name = child.get(KEY_NAME, null);
-				info.description = child.get(KEY_DESCRIPTION, null);
-				info.isSystem = child.getBoolean(KEY_SYSTEM, false);
-				info.isEnabled = child.getBoolean(KEY_ENABLED, true);
-				info.suffix = child.get(KEY_SUFFIX, null);
-				repositories.put(getKey(info.location), info);
-			} catch (MalformedURLException e) {
-				log("Error while restoring repository: " + locationString, e); //$NON-NLS-1$
-			}
-		}
-		// now that we have loaded everything, remember them
-		saveToPreferences();
-	}
-
-	private void restoreFromSystemProperty() {
-		String locationString = Activator.getContext().getProperty("eclipse.p2.artifactRepository"); //$NON-NLS-1$
-		if (locationString != null) {
-			StringTokenizer tokenizer = new StringTokenizer(locationString, ","); //$NON-NLS-1$
-			while (tokenizer.hasMoreTokens()) {
-				try {
-					addRepository(new URL(tokenizer.nextToken()));
-				} catch (MalformedURLException e) {
-					log("Error while restoring repository " + locationString, e); //$NON-NLS-1$
-				}
-			}
-		}
-	}
-
-	/**
-	 * Restores the repository list.
-	 */
-	protected void restoreRepositories() {
-		synchronized (repositoryLock) {
-			repositories = new HashMap();
-			restoreDownloadCache();
-			restoreFromSystemProperty();
-			restoreFromPreferences();
-		}
-	}
-
-	/*
-	 * Save the list of repositories to the file-system.
-	 */
-	private void saveToPreferences() {
-		try {
-			getPreferences().flush();
-		} catch (BackingStoreException e) {
-			log("Error while saving repositories in preferences", e); //$NON-NLS-1$
-		}
-	}
-
-	/*(non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepositoryManager#setEnabled(java.net.URL, boolean)
-	 */
-	public void setEnabled(URL location, boolean enablement) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
-			if (info == null || info.isEnabled == enablement)
-				return;
-			info.isEnabled = enablement;
-			remember(info);
-		}
-	}
-
-	/**
-	 * Optimize the order in which repository suffixes are searched by trying 
-	 * the last successfully loaded suffix first.
-	 */
-	private String[] sortSuffixes(String[] suffixes, URL location) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
-			if (info == null || info.suffix == null)
-				return suffixes;
-			//move lastSuffix to the front of the list but preserve order of remaining entries
-			String lastSuffix = info.suffix;
-			for (int i = 0; i < suffixes.length; i++) {
-				if (lastSuffix.equals(suffixes[i])) {
-					System.arraycopy(suffixes, 0, suffixes, 1, i);
-					suffixes[0] = lastSuffix;
-					return suffixes;
-				}
-			}
-		}
-		return suffixes;
-	}
-
 }
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/Messages.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/Messages.java
index 43f94b8..9b14dc3 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/Messages.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/Messages.java
@@ -19,7 +19,6 @@ public class Messages extends NLS {
 	public static String available_already_in;
 	public static String downloading;
 	public static String error_closing_stream;
-	public static String FileDownloadError;
 	public static String io_failedRead;
 	public static String io_incompatibleVersion;
 	public static String SignatureVerification_failedRead;
@@ -29,11 +28,7 @@ public class Messages extends NLS {
 	public static String SignatureVerifier_OutOfMemory;
 	public static String io_parseError;
 	public static String mirroring;
-	public static String repoMan_exists;
-	public static String repoMan_failedRead;
 	public static String repoMan_internalError;
-	public static String repoMan_notExists;
-	public static String repoMan_unknownType;
 	public static String repoFailedWrite;
 	public static String repoReadOnly;
 
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/messages.properties b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/messages.properties
index 8912066..cdb4cd7 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/messages.properties
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/messages.properties
@@ -13,7 +13,6 @@ available_already_in=The artifact is already available in the repository {0}.
 downloading=Downloading {0}
 error_closing_stream=Error closing the output stream for {0} on repository {1}. 
 
-FileDownloadError=Error downloading {0} to {1}. 
 io_failedRead=Unable to read repository at {0}.
 io_parseError=\
 	Error parsing simple artifact repository.
@@ -24,11 +23,7 @@ mirroring=Mirroring:
 repoFailedWrite=Unable to write to repository: {0}.
 repoReadOnly=Cannot write because repository is read only: {0}
 
-repoMan_exists=Repository already exists at {0}.
-repoMan_failedRead=The repository could not be read: {0}.
 repoMan_internalError=Internal error.
-repoMan_notExists=No repository found at {0}.
-repoMan_unknownType=Unknown repository type at {0}.
 
 SignatureVerification_failedRead=Error reading signed content: 
 SignatureVerification_invalidContent=Invalid content: 
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/provisional/p2/artifact/repository/IArtifactRepositoryManager.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/provisional/p2/artifact/repository/IArtifactRepositoryManager.java
index 3c61210..c83634c 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/provisional/p2/artifact/repository/IArtifactRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/provisional/p2/artifact/repository/IArtifactRepositoryManager.java
@@ -15,69 +15,25 @@ import java.util.Map;
 import java.util.Properties;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
-import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
-import org.eclipse.equinox.internal.provisional.p2.core.repository.RepositoryEvent;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IArtifactKey;
 
 /**
- * The metadata repository manager is used to create, access, and manipulate
- * {@link IArtifactRepository} instances. The manager keeps track of a 
- * set of known repositories, and provides caching of these known repositories
- * to avoid unnecessary loading of repositories from the disk or network.  The
- * manager fires {@link RepositoryEvent}s when the set of known repositories
- * changes.
+ * A metadata repository manager is used to create, access, and manipulate
+ * {@link IArtifactRepository} instances. See {@link IRepositoryManager}
+ * for a general description of the characteristics of repository managers.
  * 
  * @noimplement This interface is not intended to be implemented by clients.
  */
-public interface IArtifactRepositoryManager {
+public interface IArtifactRepositoryManager extends IRepositoryManager {
 	public static final IArtifactRequest[] NO_ARTIFACT_REQUEST = new IArtifactRequest[0];
 
 	/**
-	 * Constant used to indicate that all repositories are of interest.
-	 * @see #getKnownRepositories(int)
-	 */
-	public static final int REPOSITORIES_ALL = 0;
-
-	/**
-	 * Constant used to indicate that system repositories are of interest.
-	 * @see IRepository#PROP_SYSTEM
-	 * @see #getKnownRepositories(int)
-	 */
-	public static final int REPOSITORIES_SYSTEM = 1 << 0;
-
-	/**
-	 * Constant used to indicate that non-system repositories are of interest
-	 * @see IRepository#PROP_SYSTEM
-	 * @see #getKnownRepositories(int)
-	 */
-	public static final int REPOSITORIES_NON_SYSTEM = 1 << 1;
-
-	/**
-	 * Constant used to indicate that local repositories are of interest.
-	 * @see #getKnownRepositories(int)
-	 */
-	public static final int REPOSITORIES_LOCAL = 1 << 2;
-
-	/**
-	 * Constant used to indicate that disabled repositories are of interest.
-	 * @see #getKnownRepositories(int)
-	 */
-	public static final int REPOSITORIES_DISABLED = 1 << 3;
-
-	/**
 	 * Repository type for a simple repository based on a URL or local file system location.
 	 */
 	public static final String TYPE_SIMPLE_REPOSITORY = "org.eclipse.equinox.p2.artifact.repository.simpleRepository"; //$NON-NLS-1$
 
 	/**
-	 * Adds a repository to the list of artifact repositories tracked by the repository
-	 * manager.
-	 * 
-	 * @param location The location of the artifact repository to add
-	 */
-	public void addRepository(URL location);
-
-	/**
 	 * Return a new request to mirror the given artifact into the destination repository.
 	 * @param key the artifact to mirror
 	 * @param destination the destination where the artifact will be mirrored
@@ -114,72 +70,6 @@ public interface IArtifactRepositoryManager {
 	public IArtifactRepository createRepository(URL location, String name, String type, Map properties) throws ProvisionException;
 
 	/**
-	 * Returns the artifact repository locations known to the repository manager.
-	 * <p>
-	 * Note that the repository manager does not guarantee that a valid repository
-	 * exists at any of the returned locations at any particular moment in time.
-	 * A subsequent attempt to load a repository at any of the given locations may
-	 * or may not succeed.
-	 * 
-	 * @param flags an integer bit-mask indicating which repositories should be
-	 * returned.  <code>REPOSITORIES_ALL</code> can be used as the mask when
-	 * all enabled repositories should be returned.
-	 * 
-	 * @return the locations of the repositories managed by this repository manager.
-	 * 
-	 * @see #REPOSITORIES_ALL
-	 * @see #REPOSITORIES_SYSTEM
-	 * @see #REPOSITORIES_NON_SYSTEM
-	 * @see #REPOSITORIES_LOCAL
-	 * @see #REPOSITORIES_DISABLED
-	 */
-	public URL[] getKnownRepositories(int flags);
-
-	/**
-	 * Returns the property associated with the repository at the given URL, 
-	 * without loading the repository.
-	 * <p>
-	 * Note that some properties for a repository can only be
-	 * determined when that repository is loaded.  This method will return <code>null</code>
-	 * for such properties.  Only values for the properties that are already
-	 * known by a repository manager will be returned. 
-	 * <p>
-	 * If a client wishes to retrieve a property value from a repository 
-	 * regardless of the cost of retrieving it, the client should load the 
-	 * repository and then retrieve the property from the repository itself.
-	 * 
-	 * @param location the URL of the repository in question
-	 * @param key the String key of the property desired
-	 * @return the value of the property, or <code>null</code> if the repository
-	 * does not exist, the value does not exist, or the property value 
-	 * could not be determined without loading the repository.
-	 * 
-	 * @see #loadRepository(URL, IProgressMonitor)
-	 * @see IRepository#getProperties()
-	 * 
-	 */
-	public String getRepositoryProperty(URL location, String key);
-
-	/**
-	 * Returns the enablement value of a repository.  Disabled repositories are known
-	 * to the repository manager, but are never used in the context of provisioning
-	 * operation. Disabled repositories are useful as a form of bookmark to indicate that a 
-	 * repository location is of interest, but not currently used.
-	 * <p>
-	 * Note that enablement is a property of the repository manager and not a property
-	 * of the affected repository. The enablement of the repository is discarded when 
-	 * a repository is removed from the repository manager.
-	 * 
-	 * @param location The location of the repository whose enablement is requested
-	 * @return <code>true</code> if the repository is enabled, and
-	 * <code>false</code> if it is not enabled, or if the repository location 
-	 * is not known to the repository manager.
-	 * @see #REPOSITORIES_DISABLED
-	 * @see #setEnabled(URL, boolean)
-	 */
-	public boolean isEnabled(URL location);
-
-	/**
 	 * Loads the repository at the given location.  The location is expected to contain 
 	 * data that describes a valid artifact repository of a known type.  If this manager
 	 * already knows a repository at the given location then that repository is returned.
@@ -221,34 +111,4 @@ public interface IArtifactRepositoryManager {
 	 */
 	public IArtifactRepository refreshRepository(URL location, IProgressMonitor monitor) throws ProvisionException;
 
-	/**
-	 * Remove the given repository from this manager.  Do nothing if the repository
-	 * is not currently managed.
-	 * 
-	 * @param location the location of the repository to remove
-	 * @return <code>true</code> if a repository was removed, and 
-	 * <code>false</code> otherwise.
-	 */
-	public boolean removeRepository(URL location);
-
-	/**
-	 * Sets the enablement of a repository. Disabled repositories are known
-	 * to the repository manager, but are never used in the context of provisioning
-	 * operation. Disabled repositories are useful as a form of bookmark to indicate that a 
-	 * repository location is of interest, but not currently used.
-	 * <p>
-	 * Note that enablement is a property of the repository manager and not a property
-	 * of the affected repository. The enablement of the repository is discarded when 
-	 * a repository is removed from the repository manager.
-	 * <p>
-	 * This method has no effect if the given repository location is not known to the
-	 * repository manager.
-	 * 
-	 * @param location The location of the repository to enable or disable
-	 * @param enablement <code>true</code>to enable the repository, and
-	 * <code>false</code> to disable the repository
-	 * @see #REPOSITORIES_DISABLED
-	 * @see #isEnabled(URL)
-	 */
-	public void setEnabled(URL location, boolean enablement);
 }
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
index 5b66541..8594ad7 100644
--- a/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
@@ -7,6 +7,7 @@ Bundle-Localization: plugin
 Bundle-Version: 1.0.100.qualifier
 Import-Package: javax.xml.parsers,
  org.eclipse.core.runtime.adaptor,
+ org.eclipse.core.runtime.preferences;version="3.2.0",
  org.eclipse.osgi.framework.eventmgr;version="1.0.0",
  org.eclipse.osgi.framework.log;version="1.0.0",
  org.eclipse.osgi.internal.resolver,
@@ -15,6 +16,7 @@ Import-Package: javax.xml.parsers,
  org.eclipse.osgi.service.resolver;version="1.1.0",
  org.eclipse.osgi.util;version="1.0.0",
  org.osgi.framework;version="1.3.0",
+ org.osgi.service.prefs;version="1.1.0",
  org.osgi.util.tracker;version="1.3.3",
  org.xml.sax,
  org.xml.sax.helpers
@@ -155,4 +157,5 @@ Bundle-ClassPath: .
 Bundle-RequiredExecutionEnvironment: J2SE-1.4,
  CDC-1.1/Foundation-1.1
 Bundle-Activator: org.eclipse.equinox.internal.p2.core.Activator
-Require-Bundle: org.eclipse.equinox.common
+Require-Bundle: org.eclipse.equinox.common;bundle-version="[3.4.0,4.0.0)",
+ org.eclipse.equinox.registry;bundle-version="[3.4.0,4.0.0)"
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/AbstractRepositoryManager.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/AbstractRepositoryManager.java
new file mode 100644
index 0000000..6c8bfcb
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/AbstractRepositoryManager.java
@@ -0,0 +1,719 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.core.helpers;
+
+import java.lang.ref.SoftReference;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.*;
+import org.eclipse.core.runtime.*;
+import org.eclipse.core.runtime.preferences.ConfigurationScope;
+import org.eclipse.equinox.internal.p2.core.Activator;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
+import org.eclipse.equinox.internal.provisional.p2.core.eventbus.ProvisioningListener;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.*;
+import org.eclipse.osgi.util.NLS;
+import org.osgi.service.prefs.BackingStoreException;
+import org.osgi.service.prefs.Preferences;
+
+/**
+ * Common code shared between artifact and metadata repository managers.
+ */
+public abstract class AbstractRepositoryManager implements IRepositoryManager, ProvisioningListener {
+	protected static class RepositoryInfo {
+		public String description;
+		public boolean isEnabled = true;
+		public boolean isSystem = false;
+		public URL location;
+		public String name;
+		public SoftReference repository;
+		public String suffix;
+
+		public RepositoryInfo() {
+			super();
+		}
+	}
+
+	public static final String ATTR_SUFFIX = "suffix"; //$NON-NLS-1$
+	public static final String EL_FACTORY = "factory"; //$NON-NLS-1$
+	public static final String EL_FILTER = "filter"; //$NON-NLS-1$
+	public static final String KEY_DESCRIPTION = "description"; //$NON-NLS-1$
+	public static final String KEY_ENABLED = "enabled"; //$NON-NLS-1$
+	public static final String KEY_NAME = "name"; //$NON-NLS-1$
+	public static final String KEY_PROVIDER = "provider"; //$NON-NLS-1$
+	public static final String KEY_SUFFIX = "suffix"; //$NON-NLS-1$
+	public static final String KEY_SYSTEM = "isSystem"; //$NON-NLS-1$
+	public static final String KEY_TYPE = "type"; //$NON-NLS-1$
+	public static final String KEY_URL = "url"; //$NON-NLS-1$
+	public static final String KEY_VERSION = "version"; //$NON-NLS-1$
+
+	public static final String NODE_REPOSITORIES = "repositories"; //$NON-NLS-1$
+
+	/**
+	 * Map of String->RepositoryInfo, where String is the repository key
+	 * obtained via getKey(URL).
+	 */
+	protected Map repositories = null;
+
+	//lock object to be held when referring to the repositories field
+	protected final Object repositoryLock = new Object();
+
+	/**
+	 * Cache List of repositories that are not reachable. Maintain cache
+	 * for short duration because repository may become available at any time.
+	 */
+	protected SoftReference unavailableRepositories;
+
+	protected AbstractRepositoryManager() {
+		IProvisioningEventBus bus = (IProvisioningEventBus) ServiceHelper.getService(Activator.getContext(), IProvisioningEventBus.SERVICE_NAME);
+		if (bus != null)
+			bus.addListener(this);
+	}
+
+	/**
+	 * Adds a repository to the list of known repositories
+	 * @param repository the repository object to add
+	 * @param signalAdd whether a repository change event should be fired
+	 * @param suffix the suffix used to load the repository, or <code>null</code> if unknown
+	 */
+	protected void addRepository(IRepository repository, boolean signalAdd, String suffix) {
+		boolean added = false;
+		synchronized (repositoryLock) {
+			if (repositories == null)
+				restoreRepositories();
+			String key = getKey(repository.getLocation());
+			RepositoryInfo info = (RepositoryInfo) repositories.get(key);
+			if (info == null) {
+				info = new RepositoryInfo();
+				added = true;
+				repositories.put(key, info);
+			}
+			info.repository = new SoftReference(repository);
+			info.name = repository.getName();
+			info.description = repository.getDescription();
+			info.location = repository.getLocation();
+			String value = (String) repository.getProperties().get(IRepository.PROP_SYSTEM);
+			info.isSystem = value == null ? false : Boolean.valueOf(value).booleanValue();
+			info.suffix = suffix;
+		}
+		// save the given repository in the preferences.
+		remember(repository, suffix);
+		if (added && signalAdd)
+			broadcastChangeEvent(repository.getLocation(), IRepository.TYPE_METADATA, RepositoryEvent.ADDED, true);
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager#addRepository(java.net.URL)
+	 */
+	public void addRepository(URL location) {
+		addRepository(location, true, true);
+	}
+
+	/**
+	 * Adds the repository to the list of known repositories. 
+	 * @param location The repository location
+	 * @param isEnabled Whether the repository should be enabled
+	 * @param signalAdd Whether a repository add event should be broadcast
+	 * @return <code>true</code> if the repository was actually added, and 
+	 * <code>false</code> otherwise.
+	 */
+	private boolean addRepository(URL location, boolean isEnabled, boolean signalAdd) {
+		RepositoryInfo info = new RepositoryInfo();
+		info.location = location;
+		info.isEnabled = isEnabled;
+		boolean added = true;
+		synchronized (repositoryLock) {
+			if (repositories == null)
+				restoreRepositories();
+			if (contains(location))
+				return false;
+			added = repositories.put(getKey(location), info) == null;
+			// save the given repository in the preferences.
+			remember(info);
+		}
+		if (added && signalAdd)
+			broadcastChangeEvent(location, getRepositoryType(), RepositoryEvent.ADDED, isEnabled);
+		return added;
+	}
+
+	protected IRepository basicGetRepository(URL location) {
+		synchronized (repositoryLock) {
+			if (repositories == null)
+				restoreRepositories();
+			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
+			if (info == null || info.repository == null)
+				return null;
+			IRepository repo = (IRepository) info.repository.get();
+			//update our repository info because the repository may have changed
+			if (repo != null)
+				addRepository(repo, false, null);
+			return repo;
+		}
+	}
+
+	public IRepository basicRefreshRepository(URL location, IProgressMonitor monitor) throws ProvisionException {
+		clearNotFound(location);
+		boolean wasEnabled = isEnabled(location);
+		//remove the repository so  event is broadcast and repositories can clear their caches
+		if (!removeRepository(location))
+			fail(location, ProvisionException.REPOSITORY_NOT_FOUND);
+		try {
+			IRepository result = loadRepository(location, monitor, null);
+			setEnabled(location, wasEnabled);
+			return result;
+		} catch (ProvisionException e) {
+			//if we failed to load, make sure the repository is not lost
+			addRepository(location);
+			if (!wasEnabled)
+				setEnabled(location, false);
+			throw e;
+		}
+	}
+
+	private void broadcastChangeEvent(URL location, int repositoryType, int kind, boolean isEnabled) {
+		IProvisioningEventBus bus = (IProvisioningEventBus) ServiceHelper.getService(Activator.getContext(), IProvisioningEventBus.class.getName());
+		if (bus != null)
+			bus.publishEvent(new RepositoryEvent(location, repositoryType, kind, isEnabled));
+	}
+
+	/**
+	 * Check if we recently attempted to load the given location and failed
+	 * to find anything. Returns <code>true</code> if the repository was not
+	 * found, and <code>false</code> otherwise.
+	 */
+	private boolean checkNotFound(URL location) {
+		if (unavailableRepositories == null)
+			return false;
+		List badRepos = (List) unavailableRepositories.get();
+		if (badRepos == null)
+			return false;
+		return badRepos.contains(location);
+	}
+
+	/**
+	 * Clear the fact that we tried to load a repository at this location and did not find anything.
+	 */
+	protected void clearNotFound(URL location) {
+		List badRepos;
+		if (unavailableRepositories != null) {
+			badRepos = (List) unavailableRepositories.get();
+			if (badRepos != null) {
+				badRepos.remove(location);
+				return;
+			}
+		}
+	}
+
+	private boolean contains(URL location) {
+		synchronized (repositoryLock) {
+			if (repositories == null)
+				restoreRepositories();
+			return repositories.containsKey(getKey(location));
+		}
+	}
+
+	/**
+	 * Returns the executable extension, or <code>null</code> if there
+	 * was no corresponding extension, or an error occurred loading it
+	 */
+	protected Object createExecutableExtension(IExtension extension, String element) {
+		IConfigurationElement[] elements = extension.getConfigurationElements();
+		CoreException failure = null;
+		for (int i = 0; i < elements.length; i++) {
+			if (elements[i].getName().equals(element)) {
+				try {
+					return elements[i].createExecutableExtension("class"); //$NON-NLS-1$
+				} catch (CoreException e) {
+					log("Error loading repository extension: " + extension.getUniqueIdentifier(), failure); //$NON-NLS-1$
+					return null;
+				}
+			}
+		}
+		log("Malformed repository extension: " + extension.getUniqueIdentifier(), null); //$NON-NLS-1$
+		return null;
+	}
+
+	/**
+	 * Loads and returns a repository using the given repository factory extension. Returns
+	 * null if no factory could be found associated with that extension.
+	 */
+	protected abstract IRepository factoryLoad(URL location, IExtension extension, SubMonitor monitor) throws ProvisionException;
+
+	protected void fail(URL location, int code) throws ProvisionException {
+		String msg = null;
+		switch (code) {
+			case ProvisionException.REPOSITORY_EXISTS :
+				msg = NLS.bind(Messages.repoMan_exists, location);
+				break;
+			case ProvisionException.REPOSITORY_UNKNOWN_TYPE :
+				msg = NLS.bind(Messages.repoMan_unknownType, location);
+				break;
+			case ProvisionException.REPOSITORY_FAILED_READ :
+				msg = NLS.bind(Messages.repoMan_failedRead, location);
+				break;
+			case ProvisionException.REPOSITORY_NOT_FOUND :
+				msg = NLS.bind(Messages.repoMan_notExists, location);
+				break;
+		}
+		if (msg == null)
+			msg = Messages.repoMan_internalError;
+		throw new ProvisionException(new Status(IStatus.ERROR, getBundleId(), code, msg, null));
+	}
+
+	protected IExtension[] findMatchingRepositoryExtensions(String suffix, String type) {
+		IConfigurationElement[] elt = null;
+		if (type != null && type.length() > 0) {
+			IExtension ext = RegistryFactory.getRegistry().getExtension(getRepositoryProviderExtensionPointId(), type);
+			elt = (ext != null) ? ext.getConfigurationElements() : new IConfigurationElement[0];
+		} else {
+			elt = RegistryFactory.getRegistry().getConfigurationElementsFor(getRepositoryProviderExtensionPointId());
+		}
+		int count = 0;
+		for (int i = 0; i < elt.length; i++) {
+			if (EL_FILTER.equals(elt[i].getName())) {
+				if (!suffix.equals(elt[i].getAttribute(ATTR_SUFFIX))) {
+					elt[i] = null;
+				} else {
+					count++;
+				}
+			} else {
+				elt[i] = null;
+			}
+		}
+		IExtension[] results = new IExtension[count];
+		for (int i = 0; i < elt.length; i++) {
+			if (elt[i] != null)
+				results[--count] = elt[i].getDeclaringExtension();
+		}
+		return results;
+	}
+
+	protected String[] getAllSuffixes() {
+		IConfigurationElement[] elements = RegistryFactory.getRegistry().getConfigurationElementsFor(getRepositoryProviderExtensionPointId());
+		ArrayList result = new ArrayList(elements.length);
+		result.add(getDefaultSuffix());
+		for (int i = 0; i < elements.length; i++) {
+			if (elements[i].getName().equals(EL_FILTER)) {
+				String suffix = elements[i].getAttribute(ATTR_SUFFIX);
+				if (!result.contains(suffix))
+					result.add(suffix);
+			}
+		}
+		return (String[]) result.toArray(new String[result.size()]);
+	}
+
+	/**
+	 * Returns the bundle id of the bundle that provides the concrete repository manager
+	 * @return a symbolic bundle id
+	 */
+	protected abstract String getBundleId();
+
+	/**
+	 * Returns the default repository suffix. This is used to ensure a particular
+	 * repository type is preferred over all others.
+	 */
+	protected abstract String getDefaultSuffix();
+
+	/*
+	 * Return a string key based on the given repository location which
+	 * is suitable for use as a preference node name.
+	 * TODO: convert local file system URL to canonical form
+	 */
+	private String getKey(URL location) {
+		String key = location.toExternalForm().replace('/', '_');
+		//remove trailing slash
+		if (key.endsWith("_")) //$NON-NLS-1$
+			key = key.substring(0, key.length() - 1);
+		return key;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager#getKnownRepositories(int)
+	 */
+	public URL[] getKnownRepositories(int flags) {
+		synchronized (repositoryLock) {
+			if (repositories == null)
+				restoreRepositories();
+			ArrayList result = new ArrayList();
+			int i = 0;
+			for (Iterator it = repositories.values().iterator(); it.hasNext(); i++) {
+				RepositoryInfo info = (RepositoryInfo) it.next();
+				if (matchesFlags(info, flags))
+					result.add(info.location);
+			}
+			return (URL[]) result.toArray(new URL[result.size()]);
+		}
+	}
+
+	/**
+	 * Return the preference node which is the root for where we store the repository information.
+	 */
+	private Preferences getPreferences() {
+		return new ConfigurationScope().getNode(getBundleId()).node(NODE_REPOSITORIES);
+	}
+
+	/*(non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager#getRepositoryProperty(java.net.URL, java.lang.String)
+	 */
+	public String getRepositoryProperty(URL location, String key) {
+		synchronized (repositoryLock) {
+			if (repositories == null)
+				restoreRepositories();
+			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
+			if (info == null)
+				return null;// Repository not found
+			if (IRepository.PROP_DESCRIPTION.equals(key))
+				return info.description;
+			if (IRepository.PROP_NAME.equals(key))
+				return info.name;
+			if (IRepository.PROP_SYSTEM.equals(key))
+				return Boolean.toString(info.isSystem);
+			// Key not known, return null
+			return null;
+		}
+	}
+
+	/**
+	 * Returns the fully qualified id of the repository provider extension point.
+	 */
+	protected abstract String getRepositoryProviderExtensionPointId();
+
+	/**
+	 * Returns the system property used to specify additional repositories to be
+	 * automatically added to the list of known repositories.
+	 */
+	protected abstract String getRepositorySystemProperty();
+
+	/**
+	 * Returns the repository type stored in this manager.
+	 */
+	protected abstract int getRepositoryType();
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager#isEnabled(java.net.URL)
+	 */
+	public boolean isEnabled(URL location) {
+		synchronized (repositoryLock) {
+			if (repositories == null)
+				restoreRepositories();
+			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
+			if (info != null)
+				return info.isEnabled;
+			// Repository not found, return false
+			return false;
+		}
+	}
+
+	protected IRepository loadRepository(URL location, IProgressMonitor monitor, String type) throws ProvisionException {
+		boolean added = false;
+		IRepository result = null;
+		synchronized (repositoryLock) {
+			result = basicGetRepository(location);
+			if (result != null)
+				return result;
+			if (checkNotFound(location))
+				fail(location, ProvisionException.REPOSITORY_NOT_FOUND);
+			String[] suffixes = sortSuffixes(getAllSuffixes(), location);
+			SubMonitor sub = SubMonitor.convert(monitor, Messages.repoMan_adding, suffixes.length * 100);
+			//add the repository first so that it will be enabled, but don't send add event until after the load
+			added = addRepository(location, true, false);
+			try {
+				for (int i = 0; i < suffixes.length; i++) {
+					result = loadRepository(location, suffixes[i], type, sub.newChild(100));
+					if (result != null) {
+						addRepository(result, false, suffixes[i]);
+						break;
+					}
+				}
+			} finally {
+				sub.done();
+			}
+			if (result == null) {
+				//if we just added the repository, remove it because it cannot be loaded
+				if (added)
+					removeRepository(location, false);
+				//eagerly cleanup missing system repositories
+				if (Boolean.valueOf(getRepositoryProperty(location, IRepository.PROP_SYSTEM)).booleanValue())
+					removeRepository(location);
+				else
+					rememberNotFound(location);
+				fail(location, ProvisionException.REPOSITORY_NOT_FOUND);
+			}
+		}
+		//broadcast the add event outside sync block
+		if (added)
+			broadcastChangeEvent(location, IRepository.TYPE_METADATA, RepositoryEvent.ADDED, true);
+		return result;
+	}
+
+	private IRepository loadRepository(URL location, String suffix, String type, SubMonitor monitor) {
+		IExtension[] providers = findMatchingRepositoryExtensions(suffix, type);
+		// Loop over the candidates and return the first one that successfully loads
+		monitor.beginTask("", providers.length * 10); //$NON-NLS-1$
+		for (int i = 0; i < providers.length; i++)
+			try {
+				return factoryLoad(location, providers[i], monitor);
+			} catch (CoreException e) {
+				if (e.getStatus().getCode() != ProvisionException.REPOSITORY_NOT_FOUND)
+					log("Unable to load repository: " + location, e); //$NON-NLS-1$
+			}
+		return null;
+	}
+
+	protected void log(String message, Throwable t) {
+		LogHelper.log(new Status(IStatus.ERROR, getBundleId(), message, t));
+	}
+
+	private boolean matchesFlags(RepositoryInfo info, int flags) {
+		if ((flags & REPOSITORIES_SYSTEM) == REPOSITORIES_SYSTEM)
+			if (!info.isSystem)
+				return false;
+		if ((flags & REPOSITORIES_NON_SYSTEM) == REPOSITORIES_NON_SYSTEM)
+			if (info.isSystem)
+				return false;
+		if ((flags & REPOSITORIES_DISABLED) == REPOSITORIES_DISABLED) {
+			if (info.isEnabled)
+				return false;
+		} else {
+			//ignore disabled repositories for all other flag types
+			if (!info.isEnabled)
+				return false;
+		}
+		if ((flags & REPOSITORIES_LOCAL) == REPOSITORIES_LOCAL)
+			return "file".equals(info.location.getProtocol()); //$NON-NLS-1$
+		return true;
+	}
+
+	/*(non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.p2.core.eventbus.ProvisioningListener#notify(java.util.EventObject)
+	 */
+	public void notify(EventObject o) {
+		if (o instanceof RepositoryEvent) {
+			RepositoryEvent event = (RepositoryEvent) o;
+			if (event.getKind() == RepositoryEvent.DISCOVERED && event.getRepositoryType() == getRepositoryType())
+				addRepository(event.getRepositoryLocation(), event.isRepositoryEnabled(), true);
+		}
+	}
+
+	/**
+	 * Sets a preference and returns <code>true</code> if the preference
+	 * was actually changed.
+	 */
+	protected boolean putValue(Preferences node, String key, String newValue) {
+		String oldValue = node.get(key, null);
+		if (oldValue == newValue || (oldValue != null && oldValue.equals(newValue)))
+			return false;
+		if (newValue == null)
+			node.remove(key);
+		else
+			node.put(key, newValue);
+		return true;
+	}
+
+	/*
+	 * Add the given repository object to the preferences and save.
+	 */
+	private void remember(IRepository repository, String suffix) {
+		boolean changed = false;
+		Preferences node = getPreferences().node(getKey(repository.getLocation()));
+		changed |= putValue(node, KEY_URL, repository.getLocation().toExternalForm());
+		changed |= putValue(node, KEY_DESCRIPTION, repository.getDescription());
+		changed |= putValue(node, KEY_NAME, repository.getName());
+		changed |= putValue(node, KEY_PROVIDER, repository.getProvider());
+		changed |= putValue(node, KEY_TYPE, repository.getType());
+		changed |= putValue(node, KEY_VERSION, repository.getVersion());
+		changed |= putValue(node, KEY_SYSTEM, (String) repository.getProperties().get(IRepository.PROP_SYSTEM));
+		changed |= putValue(node, KEY_SUFFIX, suffix);
+		if (changed)
+			saveToPreferences();
+	}
+
+	/*
+	 * Save the list of repositories in the preference store.
+	 */
+	private boolean remember(RepositoryInfo info) {
+		boolean changed = false;
+		Preferences node = getPreferences().node(getKey(info.location));
+		changed |= putValue(node, KEY_URL, info.location.toExternalForm());
+		changed |= putValue(node, KEY_SYSTEM, Boolean.toString(info.isSystem));
+		changed |= putValue(node, KEY_DESCRIPTION, info.description);
+		changed |= putValue(node, KEY_NAME, info.name);
+		changed |= putValue(node, KEY_SUFFIX, info.suffix);
+		changed |= putValue(node, KEY_ENABLED, Boolean.toString(info.isEnabled));
+		if (changed)
+			saveToPreferences();
+		return changed;
+	}
+
+	/**
+	 * Cache the fact that we tried to load a repository at this location and did not find anything.
+	 */
+	private void rememberNotFound(URL location) {
+		List badRepos;
+		if (unavailableRepositories != null) {
+			badRepos = (List) unavailableRepositories.get();
+			if (badRepos != null) {
+				badRepos.add(location);
+				return;
+			}
+		}
+		badRepos = new ArrayList();
+		badRepos.add(location);
+		unavailableRepositories = new SoftReference(badRepos);
+	}
+
+	public boolean removeRepository(URL toRemove) {
+		return removeRepository(toRemove, true);
+	}
+
+	private boolean removeRepository(URL toRemove, boolean signalRemove) {
+		Assert.isNotNull(toRemove);
+		final String repoKey = getKey(toRemove);
+		synchronized (repositoryLock) {
+			if (repositories == null)
+				restoreRepositories();
+			if (repositories.remove(repoKey) == null)
+				return false;
+		}
+		// remove the repository from the preference store
+		try {
+			getPreferences().node(repoKey).removeNode();
+			saveToPreferences();
+		} catch (BackingStoreException e) {
+			log("Error saving preferences", e); //$NON-NLS-1$
+		}
+		//TODO: compute and pass appropriate isEnabled flag
+		if (signalRemove)
+			broadcastChangeEvent(toRemove, getRepositoryType(), RepositoryEvent.REMOVED, true);
+		return true;
+	}
+
+	/*
+	 * Load the list of repositories from the preferences.
+	 */
+	private void restoreFromPreferences() {
+		// restore the list of repositories from the preference store
+		Preferences node = getPreferences();
+		String[] children;
+		try {
+			children = node.childrenNames();
+		} catch (BackingStoreException e) {
+			log("Error restoring repositories from preferences", e); //$NON-NLS-1$
+			return;
+		}
+		for (int i = 0; i < children.length; i++) {
+			Preferences child = node.node(children[i]);
+			String locationString = child.get(KEY_URL, null);
+			if (locationString == null)
+				continue;
+			try {
+				RepositoryInfo info = new RepositoryInfo();
+				info.location = new URL(locationString);
+				info.name = child.get(KEY_NAME, null);
+				info.description = child.get(KEY_DESCRIPTION, null);
+				info.isSystem = child.getBoolean(KEY_SYSTEM, false);
+				info.isEnabled = child.getBoolean(KEY_ENABLED, true);
+				info.suffix = child.get(KEY_SUFFIX, null);
+				repositories.put(getKey(info.location), info);
+			} catch (MalformedURLException e) {
+				log("Error while restoring repository: " + locationString, e); //$NON-NLS-1$
+			}
+		}
+		// now that we have loaded everything, remember them
+		saveToPreferences();
+	}
+
+	private void restoreFromSystemProperty() {
+		String locationString = Activator.getContext().getProperty(getRepositorySystemProperty());
+		if (locationString != null) {
+			StringTokenizer tokenizer = new StringTokenizer(locationString, ","); //$NON-NLS-1$
+			while (tokenizer.hasMoreTokens()) {
+				try {
+					addRepository(new URL(tokenizer.nextToken()));
+				} catch (MalformedURLException e) {
+					log("Error while restoring repository " + locationString, e); //$NON-NLS-1$
+				}
+			}
+		}
+	}
+
+	/**
+	 * Restores the repository list.
+	 */
+	private void restoreRepositories() {
+		synchronized (repositoryLock) {
+			repositories = new HashMap();
+			restoreSpecialRepositories();
+			restoreFromSystemProperty();
+			restoreFromPreferences();
+		}
+	}
+
+	/**
+	 * Hook method to restore special additional repositories.
+	 */
+	protected void restoreSpecialRepositories() {
+		//by default no special repositories
+	}
+
+	/*
+	 * Save the list of repositories to the file-system.
+	 */
+	private void saveToPreferences() {
+		try {
+			getPreferences().flush();
+		} catch (BackingStoreException e) {
+			log("Error while saving repositories in preferences", e); //$NON-NLS-1$
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager#setEnabled(java.net.URL, boolean)
+	 */
+	public void setEnabled(URL location, boolean enablement) {
+		synchronized (repositoryLock) {
+			if (repositories == null)
+				restoreRepositories();
+			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
+			if (info == null || info.isEnabled == enablement)
+				return;
+			info.isEnabled = enablement;
+			remember(info);
+		}
+		broadcastChangeEvent(location, getRepositoryType(), RepositoryEvent.ENABLEMENT, enablement);
+	}
+
+	/**
+	 * Optimize the order in which repository suffixes are searched by trying 
+	 * the last successfully loaded suffix first.
+	 */
+	private String[] sortSuffixes(String[] suffixes, URL location) {
+		synchronized (repositoryLock) {
+			if (repositories == null)
+				restoreRepositories();
+			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
+			if (info == null || info.suffix == null)
+				return suffixes;
+			//move lastSuffix to the front of the list but preserve order of remaining entries
+			String lastSuffix = info.suffix;
+			for (int i = 0; i < suffixes.length; i++) {
+				if (lastSuffix.equals(suffixes[i])) {
+					System.arraycopy(suffixes, 0, suffixes, 1, i);
+					suffixes[0] = lastSuffix;
+					return suffixes;
+				}
+			}
+		}
+		return suffixes;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/Messages.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/Messages.java
index 7b00a7f..8b425b7 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/Messages.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/Messages.java
@@ -12,7 +12,7 @@ package org.eclipse.equinox.internal.p2.core.helpers;
 
 import org.eclipse.osgi.util.NLS;
 
-public class Messages extends NLS {
+class Messages extends NLS {
 
 	private static final String BUNDLE_NAME = "org.eclipse.equinox.internal.p2.core.helpers.messages"; //$NON-NLS-1$
 
@@ -21,6 +21,17 @@ public class Messages extends NLS {
 		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
 	}
 
+	private Messages() {
+		// Do not instantiate
+	}
+
+	public static String repoMan_adding;
+	public static String repoMan_exists;
+	public static String repoMan_failedRead;
+	public static String repoMan_internalError;
+	public static String repoMan_notExists;
+	public static String repoMan_unknownType;
+
 	public static String Util_Invalid_Zip_File_Format;
 	public static String Util_Error_Unzipping;
 
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/messages.properties b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/messages.properties
index b6485bf..7e68ac0 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/messages.properties
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/core/helpers/messages.properties
@@ -1,5 +1,5 @@
 ###############################################################################
-# Copyright (c) 2007 IBM Corporation and others.
+# Copyright (c) 2007, 2008 IBM Corporation and others.
 # All rights reserved. This program and the accompanying materials
 # are made available under the terms of the Eclipse Public License v1.0
 # which accompanies this distribution, and is available at
@@ -9,5 +9,12 @@
 #     IBM Corporation - initial API and implementation
 ###############################################################################
 
+repoMan_adding = Adding repository {0}
+repoMan_exists=Repository already exists at {0}.
+repoMan_failedRead=The repository could not be read: {0}.
+repoMan_internalError=Internal error.
+repoMan_notExists=No repository found at {0}.
+repoMan_unknownType=Unknown repository type at {0}.
+
 Util_Invalid_Zip_File_Format=Invalid zip file format
 Util_Error_Unzipping=Error unzipping {0}: {1}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/repository/IRepositoryManager.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/repository/IRepositoryManager.java
new file mode 100644
index 0000000..e9b45de
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/repository/IRepositoryManager.java
@@ -0,0 +1,161 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core.repository;
+
+import java.net.URL;
+
+/**
+ * The common base class for metadata and artifact repository managers.
+ * <p>
+ * A repository manager keeps track of a set of known repositories, and provides 
+ * caching of these known repositories to avoid unnecessary loading of repositories 
+ * from the disk or network.  The manager fires {@link RepositoryEvent}s when the 
+ * set of known repositories changes.
+ * 
+ * @noimplement This interface is not intended to be implemented by clients.
+ */
+public interface IRepositoryManager {
+	/**
+	 * Constant used to indicate that all enabled repositories are of interest.
+	 */
+	public static final int REPOSITORIES_ALL = 0;
+
+	/**
+	 * Constant used to indicate that disabled repositories are of interest.
+	 * @see #getKnownRepositories(int)
+	 */
+	public static final int REPOSITORIES_DISABLED = 1 << 3;
+
+	/**
+	 * Constant used to indicate that local repositories are of interest.
+	 * @see #getKnownRepositories(int)
+	 */
+	public static final int REPOSITORIES_LOCAL = 1 << 2;
+
+	/**
+	 * Constant used to indicate that non-system repositories are of interest
+	 * @see IRepository#PROP_SYSTEM
+	 * @see #getKnownRepositories(int)
+	 */
+	public static final int REPOSITORIES_NON_SYSTEM = 1 << 1;
+
+	/**
+	 * Constant used to indicate that system repositories are of interest.
+	 * @see IRepository#PROP_SYSTEM
+	 * @see #getKnownRepositories(int)
+	 */
+	public static final int REPOSITORIES_SYSTEM = 1 << 0;
+
+	/**
+	 * Adds the repository at the given location to the list of repositories tracked by 
+	 * this repository manager.
+	 * 
+	 * @param location The location of the metadata repository to add
+	 */
+	public void addRepository(URL location);
+
+	/**
+	 * Returns the artifact repository locations known to the repository manager.
+	 * <p>
+	 * Note that the repository manager does not guarantee that a valid repository
+	 * exists at any of the returned locations at any particular moment in time.
+	 * A subsequent attempt to load a repository at any of the given locations may
+	 * or may not succeed.
+	 * 
+	 * @param flags an integer bit-mask indicating which repositories should be
+	 * returned.  <code>REPOSITORIES_ALL</code> can be used as the mask when
+	 * all enabled repositories should be returned.
+	 * @return the locations of the repositories managed by this repository manager.
+	 * 
+	 * @see #REPOSITORIES_ALL
+	 * @see #REPOSITORIES_SYSTEM
+	 * @see #REPOSITORIES_NON_SYSTEM
+	 * @see #REPOSITORIES_LOCAL
+	 * @see #REPOSITORIES_DISABLED
+	 */
+	public URL[] getKnownRepositories(int flags);
+
+	/**
+	 * Returns the property associated with the repository at the given URL, 
+	 * without loading the repository.
+	 * <p>
+	 * Note that some properties for a repository can only be
+	 * determined when that repository is loaded.  This method will return <code>null</code>
+	 * for such properties.  Only values for the properties that are already
+	 * known by a repository manager will be returned. 
+	 * <p>
+	 * If a client wishes to retrieve a property value from a repository 
+	 * regardless of the cost of retrieving it, the client should load the 
+	 * repository and then retrieve the property from the repository itself.
+	 * 
+	 * @param location the URL of the repository in question
+	 * @param key the String key of the property desired
+	 * @return the value of the property, or <code>null</code> if the repository
+	 * does not exist, the value does not exist, or the property value 
+	 * could not be determined without loading the repository.
+	 * 
+	 * @see IRepository#getProperties()
+	 */
+	public String getRepositoryProperty(URL location, String key);
+
+	/**
+	 * Returns the enablement value of a repository.  Disabled repositories are known
+	 * to the repository manager, but are never used in the context of provisioning
+	 * operations. Disabled repositories are useful as a form of bookmark to indicate that a 
+	 * repository location is of interest, but not currently used.
+	 * <p>
+	 * Note that enablement is a property of the repository manager and not a property
+	 * of the affected repository. The enablement of the repository is discarded when 
+	 * a repository is removed from the repository manager.
+	 * 
+	 * @param location The location of the repository whose enablement is requested
+	 * @return <code>true</code> if the repository is enabled, and
+	 * <code>false</code> if it is not enabled, or if the repository location 
+	 * is not known to the repository manager.
+	 * @see #REPOSITORIES_DISABLED
+	 * @see #setEnabled(URL, boolean)
+	 */
+	public boolean isEnabled(URL location);
+
+	/**
+	 * Removes the repository at the given location from the list of
+	 * repositories known to this repository manager.  The underlying
+	 * repository is not deleted. This method has no effect if the given
+	 * repository is not already known to this repository manager.
+	 * 
+	 * @param location The location of the repository to remove
+	 * @return <code>true</code> if a repository was removed, and 
+	 * <code>false</code> otherwise.
+	 */
+	public boolean removeRepository(URL location);
+
+	/**
+	 * Sets the enablement of a repository. Disabled repositories are known
+	 * to the repository manager, but are never used in the context of provisioning
+	 * operation. Disabled repositories are useful as a form of bookmark to indicate that a 
+	 * repository location is of interest, but not currently used.
+	 * <p>
+	 * Note that enablement is a property of the repository manager and not a property
+	 * of the affected repository. The enablement of the repository is discarded when 
+	 * a repository is removed from the repository manager.
+	 * <p>
+	 * This method has no effect if the given repository location is not known to the
+	 * repository manager.
+	 * 
+	 * @param location The location of the repository to enable or disable
+	 * @param enablement <code>true</code>to enable the repository, and
+	 * <code>false</code> to disable the repository
+	 * @see #REPOSITORIES_DISABLED
+	 * @see #isEnabled(URL)
+	 */
+	public void setEnabled(URL location, boolean enablement);
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/Messages.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/Messages.java
index d6dd8c4..65136a8 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/Messages.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/Messages.java
@@ -28,12 +28,8 @@ public class Messages extends NLS {
 
 	public static String repo_loading;
 
-	public static String repoMan_adding;
-	public static String repoMan_exists;
-	public static String repoMan_failedRead;
 	public static String repoMan_internalError;
 	public static String repoMan_notExists;
-	public static String repoMan_unknownType;
 	public static String repoMan_invalidLocation;
 
 }
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryManager.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryManager.java
index 305a7bf..fed3fef 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/MetadataRepositoryManager.java
@@ -10,232 +10,42 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.metadata.repository;
 
-import java.lang.ref.SoftReference;
-import java.net.MalformedURLException;
 import java.net.URL;
-import java.util.*;
+import java.util.Map;
 import org.eclipse.core.runtime.*;
-import org.eclipse.core.runtime.preferences.ConfigurationScope;
-import org.eclipse.equinox.internal.p2.core.helpers.*;
+import org.eclipse.equinox.internal.p2.core.helpers.AbstractRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
-import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
-import org.eclipse.equinox.internal.provisional.p2.core.eventbus.ProvisioningListener;
 import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
-import org.eclipse.equinox.internal.provisional.p2.core.repository.RepositoryEvent;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.query.Collector;
 import org.eclipse.equinox.internal.provisional.p2.query.Query;
 import org.eclipse.equinox.internal.provisional.spi.p2.metadata.repository.IMetadataRepositoryFactory;
 import org.eclipse.osgi.util.NLS;
-import org.osgi.service.prefs.BackingStoreException;
-import org.osgi.service.prefs.Preferences;
 
 /**
  * Default implementation of {@link IMetadataRepositoryManager}.
  */
-public class MetadataRepositoryManager implements IMetadataRepositoryManager, ProvisioningListener {
-	static class RepositoryInfo {
-		String description;
-		boolean isSystem = false;
-		boolean isEnabled = true;
-		URL location;
-		String name;
-		SoftReference repository;
-		String suffix;
-	}
-
-	private static final String ATTR_SUFFIX = "suffix"; //$NON-NLS-1$
-	private static final String DEFAULT_SUFFIX = "content.xml"; //$NON-NLS-1$
-	private static final String EL_FILTER = "filter"; //$NON-NLS-1$
-
-	private static final String FACTORY = "factory"; //$NON-NLS-1$
-	private static final String KEY_DESCRIPTION = "description"; //$NON-NLS-1$
-	private static final String KEY_ENABLED = "enabled"; //$NON-NLS-1$
-	private static final String KEY_NAME = "name"; //$NON-NLS-1$
-	private static final String KEY_PROVIDER = "provider"; //$NON-NLS-1$
-	private static final String KEY_SUFFIX = "suffix"; //$NON-NLS-1$
-	private static final String KEY_SYSTEM = "isSystem"; //$NON-NLS-1$
-	private static final String KEY_TYPE = "type"; //$NON-NLS-1$
-	private static final String KEY_URL = "url"; //$NON-NLS-1$
-	private static final String KEY_VERSION = "version"; //$NON-NLS-1$
-
-	private static final String NODE_REPOSITORIES = "repositories"; //$NON-NLS-1$
-
-	/**
-	 * Map of String->RepositoryInfo, where String is the repository key
-	 * obtained via getKey(URL).
-	 */
-	private Map repositories = null;
-
-	//lock object to be held when referring to the repositories field
-	private final Object repositoryLock = new Object();
-
-	/**
-	 * Cache List of repositories that are not reachable. Maintain cache
-	 * for short duration because repository may become available at any time.
-	 */
-	private SoftReference unavailableRepositories;
+public class MetadataRepositoryManager extends AbstractRepositoryManager implements IMetadataRepositoryManager {
 
 	public MetadataRepositoryManager() {
-		IProvisioningEventBus bus = (IProvisioningEventBus) ServiceHelper.getService(Activator.getContext(), IProvisioningEventBus.class.getName());
-		if (bus != null)
-			bus.addListener(this);
-		//initialize repositories lazily
+		super();
 	}
 
 	public void addRepository(IMetadataRepository repository) {
-		addRepository(repository, true, null);
-	}
-
-	/**
-	 * Adds a repository to the list of known repositories
-	 * @param repository the repository object to add
-	 * @param signalAdd whether a repository change event should be fired
-	 * @param suffix the suffix used to load the repository, or <code>null</code> if unknown
-	 */
-	private void addRepository(IMetadataRepository repository, boolean signalAdd, String suffix) {
-		boolean added = true;
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			String key = getKey(repository);
-			RepositoryInfo info = (RepositoryInfo) repositories.get(key);
-			if (info == null)
-				info = new RepositoryInfo();
-			info.repository = new SoftReference(repository);
-			info.name = repository.getName();
-			info.description = repository.getDescription();
-			info.location = repository.getLocation();
-			String value = (String) repository.getProperties().get(IRepository.PROP_SYSTEM);
-			info.isSystem = value == null ? false : Boolean.valueOf(value).booleanValue();
-			info.suffix = suffix;
-			added = repositories.put(getKey(repository), info) == null;
-		}
-		// save the given repository in the preferences.
-		remember(repository, suffix);
-		if (added && signalAdd)
-			broadcastChangeEvent(repository.getLocation(), IRepository.TYPE_METADATA, RepositoryEvent.ADDED, true);
-	}
-
-	public void addRepository(URL location) {
-		addRepository(location, true, true);
-	}
-
-	/**
-	 * Adds the repository to the list of known repositories. 
-	 * @param location The repository location
-	 * @param isEnabled Whether the repository should be enabled
-	 * @param signalAdd Whether a repository add event should be broadcast
-	 * @return <code>true</code> if the repository was actually added, and 
-	 * <code>false</code> otherwise.
-	 */
-	private boolean addRepository(URL location, boolean isEnabled, boolean signalAdd) {
-		Assert.isNotNull(location);
-		RepositoryInfo info = new RepositoryInfo();
-		info.location = location;
-		info.isEnabled = isEnabled;
-		boolean added = true;
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			if (contains(location))
-				return false;
-			added = repositories.put(getKey(location), info) == null;
-		}
-		// save the given repository in the preferences.
-		remember(info);
-		if (added && signalAdd)
-			broadcastChangeEvent(location, IRepository.TYPE_METADATA, RepositoryEvent.ADDED, isEnabled);
-		return added;
-	}
-
-	/**
-	 * TODO Eliminate duplication with ArtifactRepositoryManager.
-	 */
-	protected void broadcastChangeEvent(URL location, int repositoryType, int kind, boolean isEnabled) {
-		IProvisioningEventBus bus = (IProvisioningEventBus) ServiceHelper.getService(Activator.getContext(), IProvisioningEventBus.class.getName());
-		if (bus != null)
-			bus.publishEvent(new RepositoryEvent(location, repositoryType, kind, isEnabled));
-	}
-
-	/**
-	 * Check if we recently attempted to load the given location and failed
-	 * to find anything. Returns <code>true</code> if the repository was not
-	 * found, and <code>false</code> otherwise.
-	 */
-	private boolean checkNotFound(URL location) {
-		if (unavailableRepositories == null)
-			return false;
-		List badRepos = (List) unavailableRepositories.get();
-		if (badRepos == null)
-			return false;
-		return badRepos.contains(location);
-	}
-
-	/**
-	 * Clear the fact that we tried to load a repository at this location and did not find anything.
-	 */
-	private void clearNotFound(URL location) {
-		List badRepos;
-		if (unavailableRepositories != null) {
-			badRepos = (List) unavailableRepositories.get();
-			if (badRepos != null) {
-				badRepos.remove(location);
-				return;
-			}
-		}
-	}
-
-	private boolean contains(URL location) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			String key = getKey(location);
-			if (repositories.containsKey(key))
-				return true;
-			//try alternate key with different trailing slash
-			int len = key.length();
-			if (key.charAt(len - 1) == '_')
-				key = key.substring(0, len - 1);
-			else
-				key = key + '_';
-			return repositories.containsKey(key);
-		}
-	}
-
-	/**
-	 * Returns the executable extension, or <code>null</code> if there
-	 * was no corresponding extension, or an error occurred loading it
-	 */
-	private Object createExecutableExtension(IExtension extension, String element) {
-		IConfigurationElement[] elements = extension.getConfigurationElements();
-		CoreException failure = null;
-		for (int i = 0; i < elements.length; i++) {
-			if (elements[i].getName().equals(element)) {
-				try {
-					return elements[i].createExecutableExtension("class"); //$NON-NLS-1$
-				} catch (CoreException e) {
-					log("Error loading repository extension: " + extension.getUniqueIdentifier(), failure); //$NON-NLS-1$
-					return null;
-				}
-			}
-		}
-		log("Malformed repository extension: " + extension.getUniqueIdentifier(), null); //$NON-NLS-1$
-		return null;
+		super.addRepository(repository, true, null);
 	}
 
 	/* (non-Javadoc)
 	 * @see org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager#createRepository(java.net.URL, java.lang.String, java.lang.String, java.util.Map)
 	 */
 	public IMetadataRepository createRepository(URL location, String name, String type, Map properties) throws ProvisionException {
-		Assert.isNotNull(location);
 		Assert.isNotNull(name);
 		Assert.isNotNull(type);
 		boolean loaded = false;
 		try {
 			//repository should not already exist
-			loadRepository(location, (IProgressMonitor) null, type, true);
+			loadRepository(location, (IProgressMonitor) null, type);
 			loaded = true;
 		} catch (ProvisionException e) {
 			//expected - fall through and create the new repository
@@ -246,7 +56,7 @@ public class MetadataRepositoryManager implements IMetadataRepositoryManager, Pr
 		IExtension extension = RegistryFactory.getRegistry().getExtension(Activator.REPO_PROVIDER_XPT, type);
 		if (extension == null)
 			fail(location, ProvisionException.REPOSITORY_UNKNOWN_TYPE);
-		IMetadataRepositoryFactory factory = (IMetadataRepositoryFactory) createExecutableExtension(extension, FACTORY);
+		IMetadataRepositoryFactory factory = (IMetadataRepositoryFactory) createExecutableExtension(extension, EL_FACTORY);
 		if (factory == null)
 			fail(location, ProvisionException.REPOSITORY_FAILED_READ);
 		IMetadataRepository result = factory.create(location, name, type, properties);
@@ -257,289 +67,42 @@ public class MetadataRepositoryManager implements IMetadataRepositoryManager, Pr
 		return result;
 	}
 
-	private void fail(URL location, int code) throws ProvisionException {
-		throw new ProvisionException(failStatus(location, code));
-	}
-
-	private IStatus failStatus(URL location, int code) {
-		String msg = null;
-		switch (code) {
-			case ProvisionException.REPOSITORY_EXISTS :
-				msg = NLS.bind(Messages.repoMan_exists, location);
-				break;
-			case ProvisionException.REPOSITORY_UNKNOWN_TYPE :
-				msg = NLS.bind(Messages.repoMan_unknownType, location);
-				break;
-			case ProvisionException.REPOSITORY_FAILED_READ :
-				msg = NLS.bind(Messages.repoMan_failedRead, location);
-				break;
-			case ProvisionException.REPOSITORY_NOT_FOUND :
-				msg = NLS.bind(Messages.repoMan_notExists, location);
-				break;
-			case ProvisionException.REPOSITORY_INVALID_LOCATION :
-				msg = NLS.bind(Messages.repoMan_invalidLocation, location);
-				break;
-		}
-		if (msg == null)
-			msg = Messages.repoMan_internalError;
-		return new Status(IStatus.ERROR, Activator.ID, code, msg, null);
-	}
-
-	private IExtension[] findMatchingRepositoryExtensions(String suffix, String type) {
-		IConfigurationElement[] elt = null;
-		if (type != null && type.length() > 0) {
-			IExtension ext = RegistryFactory.getRegistry().getExtension(Activator.REPO_PROVIDER_XPT, type);
-			elt = (ext != null) ? ext.getConfigurationElements() : new IConfigurationElement[0];
-		} else {
-			elt = RegistryFactory.getRegistry().getConfigurationElementsFor(Activator.REPO_PROVIDER_XPT);
-		}
-
-		int count = 0;
-		for (int i = 0; i < elt.length; i++) {
-			if (elt[i].getName().equals("filter")) { //$NON-NLS-1$
-				if (!elt[i].getAttribute("suffix").equals(suffix)) { //$NON-NLS-1$
-					elt[i] = null;
-				} else {
-					count++;
-				}
-			} else {
-				elt[i] = null;
-			}
-		}
-		IExtension[] results = new IExtension[count];
-		for (int i = 0; i < elt.length; i++) {
-			if (elt[i] != null)
-				results[--count] = elt[i].getDeclaringExtension();
-		}
-		return results;
-	}
-
-	private String[] getAllSuffixes() {
-		IConfigurationElement[] elements = RegistryFactory.getRegistry().getConfigurationElementsFor(Activator.REPO_PROVIDER_XPT);
-		ArrayList result = new ArrayList(elements.length);
-		result.add(DEFAULT_SUFFIX);
-		for (int i = 0; i < elements.length; i++) {
-			if (elements[i].getName().equals(EL_FILTER)) {
-				String suffix = elements[i].getAttribute(ATTR_SUFFIX);
-				if (!result.contains(suffix))
-					result.add(suffix);
-			}
-		}
-		return (String[]) result.toArray(new String[result.size()]);
-	}
-
-	/*
-	 * Return a string key based on the given repository which
-	 * is suitable for use as a preference node name.
-	 */
-	private String getKey(IMetadataRepository repository) {
-		return getKey(repository.getLocation());
-	}
-
-	/*
-	 * Return a string key based on the given repository location which
-	 * is suitable for use as a preference node name.
-	 */
-	private String getKey(URL location) {
-		return location.toExternalForm().replace('/', '_');
-	}
-
-	public URL[] getKnownRepositories(int flags) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			ArrayList result = new ArrayList();
-			int i = 0;
-			for (Iterator it = repositories.values().iterator(); it.hasNext(); i++) {
-				RepositoryInfo info = (RepositoryInfo) it.next();
-				if (matchesFlags(info, flags))
-					result.add(info.location);
-			}
-			return (URL[]) result.toArray(new URL[result.size()]);
-		}
-	}
-
-	/*
-	 * Return the preference node which is the root for where we store the repository information.
-	 */
-	private Preferences getPreferences() {
-		return new ConfigurationScope().getNode(Activator.ID).node(NODE_REPOSITORIES);
-	}
-
-	public IMetadataRepository getRepository(URL location) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			for (Iterator it = repositories.values().iterator(); it.hasNext();) {
-				RepositoryInfo info = (RepositoryInfo) it.next();
-				if (URLUtil.sameURL(info.location, location)) {
-					if (info.repository == null)
-						return null;
-					IMetadataRepository repo = (IMetadataRepository) info.repository.get();
-					//update our repository info because the repository may have changed
-					if (repo != null)
-						addRepository(repo);
-					return repo;
-				}
-			}
+	protected IRepository factoryLoad(URL location, IExtension extension, SubMonitor monitor) throws ProvisionException {
+		IMetadataRepositoryFactory factory = (IMetadataRepositoryFactory) createExecutableExtension(extension, EL_FACTORY);
+		if (factory == null)
 			return null;
-		}
+		return factory.load(location, monitor.newChild(10));
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager#getRepositoryProperty(java.net.URL, java.lang.String)
-	 */
-	public String getRepositoryProperty(URL location, String key) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			for (Iterator it = repositories.values().iterator(); it.hasNext();) {
-				RepositoryInfo info = (RepositoryInfo) it.next();
-				if (URLUtil.sameURL(info.location, location)) {
-					if (IRepository.PROP_DESCRIPTION.equals(key))
-						return info.description;
-					if (IRepository.PROP_NAME.equals(key))
-						return info.name;
-					if (IRepository.PROP_SYSTEM.equals(key))
-						return Boolean.toString(info.isSystem);
-					// Key not known, return null
-					return null;
-				}
-			}
-			// Repository not found, return null
-			return null;
-		}
+	protected String getBundleId() {
+		return Activator.ID;
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager#getEnabled(java.net.URL)
-	 */
-	public boolean isEnabled(URL location) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			for (Iterator it = repositories.values().iterator(); it.hasNext();) {
-				RepositoryInfo info = (RepositoryInfo) it.next();
-				if (URLUtil.sameURL(info.location, location)) {
-					return info.isEnabled;
-				}
-			}
-			// Repository not found, return false
-			return false;
-		}
+	protected String getDefaultSuffix() {
+		return "content.xml"; //$NON-NLS-1$
 	}
 
-	public IMetadataRepository loadRepository(URL location, IProgressMonitor monitor) throws ProvisionException {
-		return loadRepository(location, monitor, null, true);
+	public IMetadataRepository getRepository(URL location) {
+		return (IMetadataRepository) basicGetRepository(location);
 	}
 
-	private IMetadataRepository loadRepository(URL location, IProgressMonitor monitor, String type, boolean signalAdd) throws ProvisionException {
-		Assert.isNotNull(location);
-		IMetadataRepository result = getRepository(location);
-		if (result != null)
-			return result;
-		if (checkNotFound(location))
-			fail(location, ProvisionException.REPOSITORY_NOT_FOUND);
-		String[] suffixes = sortSuffixes(getAllSuffixes(), location);
-		SubMonitor sub = SubMonitor.convert(monitor, Messages.repoMan_adding, suffixes.length * 100);
-		//add the repository first so that it will be enabled, but don't send add event until after the load
-		boolean added = addRepository(location, true, false);
-		try {
-			for (int i = 0; i < suffixes.length; i++) {
-				result = loadRepository(location, suffixes[i], type, sub.newChild(100));
-				if (result != null) {
-					addRepository(result, false, suffixes[i]);
-					//broadcast the add event now
-					if (added && signalAdd)
-						broadcastChangeEvent(location, IRepository.TYPE_METADATA, RepositoryEvent.ADDED, true);
-					return result;
-				}
-			}
-		} finally {
-			sub.done();
-		}
-		//if we just added the repository, remove it because it cannot be loaded
-		if (added)
-			removeRepository(location, false);
-		if (Boolean.valueOf(getRepositoryProperty(location, IRepository.PROP_SYSTEM)).booleanValue())
-			removeRepository(location);
-		else
-			rememberNotFound(location);
-		fail(location, ProvisionException.REPOSITORY_NOT_FOUND);
-		return null;//cannot get here
+	protected String getRepositoryProviderExtensionPointId() {
+		return Activator.REPO_PROVIDER_XPT;
 	}
 
 	/**
-	 * Try to load a pre-existing repo at the given location
+	 * Restores metadata repositories specified as system properties.
 	 */
-	private IMetadataRepository loadRepository(URL location, String suffix, String type, SubMonitor monitor) {
-		IExtension[] providers = findMatchingRepositoryExtensions(suffix, type);
-		// Loop over the candidates and return the first one that successfully loads
-		monitor.beginTask("", providers.length * 10); //$NON-NLS-1$
-		for (int i = 0; i < providers.length; i++) {
-			IMetadataRepositoryFactory factory = (IMetadataRepositoryFactory) createExecutableExtension(providers[i], FACTORY);
-			try {
-				if (factory != null)
-					return factory.load(location, monitor.newChild(10));
-			} catch (ProvisionException e) {
-				if (e.getStatus().getCode() != ProvisionException.REPOSITORY_NOT_FOUND)
-					log("Unable to load repository: " + location, e); //$NON-NLS-1$
-				//keep trying with other factories
-			}
-		}
-		return null;
+	protected String getRepositorySystemProperty() {
+		return "eclipse.p2.metadataRepository"; //$NON-NLS-1$
 	}
 
-	protected void log(String message, Throwable t) {
-		LogHelper.log(new Status(IStatus.ERROR, Activator.ID, message, t));
-	}
-
-	private boolean matchesFlags(RepositoryInfo info, int flags) {
-		if ((flags & REPOSITORIES_SYSTEM) == REPOSITORIES_SYSTEM)
-			if (!info.isSystem)
-				return false;
-		if ((flags & REPOSITORIES_NON_SYSTEM) == REPOSITORIES_NON_SYSTEM)
-			if (info.isSystem)
-				return false;
-		if ((flags & REPOSITORIES_DISABLED) == REPOSITORIES_DISABLED) {
-			if (info.isEnabled)
-				return false;
-		} else {
-			//ignore disabled repositories for all other flag types
-			if (!info.isEnabled)
-				return false;
-		}
-		if ((flags & REPOSITORIES_LOCAL) == REPOSITORIES_LOCAL)
-			return "file".equals(info.location.getProtocol()); //$NON-NLS-1$
-		return true;
-	}
-
-	/*(non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.core.eventbus.ProvisioningListener#notify(java.util.EventObject)
-	 */
-	public void notify(EventObject o) {
-		if (o instanceof RepositoryEvent) {
-			RepositoryEvent event = (RepositoryEvent) o;
-			if (event.getKind() == RepositoryEvent.DISCOVERED && event.getRepositoryType() == IRepository.TYPE_METADATA)
-				addRepository(event.getRepositoryLocation(), event.isRepositoryEnabled(), true);
-		}
+	protected int getRepositoryType() {
+		return IRepository.TYPE_METADATA;
 	}
 
-	/**
-	 * Sets a preference and returns <code>true</code> if the preference
-	 * was actually changed.
-	 */
-	private boolean putValue(Preferences node, String key, String newValue) {
-		String oldValue = node.get(key, null);
-		if (oldValue == newValue || (oldValue != null && oldValue.equals(newValue)))
-			return false;
-		if (newValue == null)
-			node.remove(key);
-		else
-			node.put(key, newValue);
-		return true;
+	public IMetadataRepository loadRepository(URL location, IProgressMonitor monitor) throws ProvisionException {
+		return (IMetadataRepository) loadRepository(location, monitor, null);
 	}
 
 	/**
@@ -577,220 +140,10 @@ public class MetadataRepositoryManager implements IMetadataRepositoryManager, Pr
 	}
 
 	public IMetadataRepository refreshRepository(URL location, IProgressMonitor monitor) throws ProvisionException {
-		clearNotFound(location);
-		boolean wasEnabled = isEnabled(location);
-		//remove the repository so  event is broadcast and repositories can clear their caches
-		if (!removeRepository(location))
-			fail(location, ProvisionException.REPOSITORY_NOT_FOUND);
-		try {
-			IMetadataRepository result = loadRepository(location, monitor, null, true);
-			if (!wasEnabled)
-				setEnabled(location, false);
-			return result;
-		} catch (ProvisionException e) {
-			//if we failed to load, make sure the repository is not lost
-			addRepository(location);
-			if (!wasEnabled)
-				setEnabled(location, false);
-			throw e;
-		}
-	}
-
-	/*
-	 * Save the list of repositories in the preference store.
-	 */
-	private boolean remember(IMetadataRepository repository, String suffix) {
-		boolean changed = false;
-		Preferences node = getPreferences().node(getKey(repository));
-		changed |= putValue(node, KEY_URL, repository.getLocation().toExternalForm());
-		changed |= putValue(node, KEY_DESCRIPTION, repository.getDescription());
-		changed |= putValue(node, KEY_NAME, repository.getName());
-		changed |= putValue(node, KEY_PROVIDER, repository.getProvider());
-		changed |= putValue(node, KEY_TYPE, repository.getType());
-		changed |= putValue(node, KEY_VERSION, repository.getVersion());
-		changed |= putValue(node, KEY_SYSTEM, (String) repository.getProperties().get(IRepository.PROP_SYSTEM));
-		changed |= putValue(node, KEY_SUFFIX, suffix);
-		if (changed)
-			saveToPreferences();
-		return changed;
-	}
-
-	/*
-	 * Save the list of repositories in the preference store.
-	 */
-	private boolean remember(RepositoryInfo info) {
-		boolean changed = false;
-		Preferences node = getPreferences().node(getKey(info.location));
-		changed |= putValue(node, KEY_URL, info.location.toExternalForm());
-		changed |= putValue(node, KEY_SYSTEM, Boolean.toString(info.isSystem));
-		changed |= putValue(node, KEY_DESCRIPTION, info.description);
-		changed |= putValue(node, KEY_NAME, info.name);
-		changed |= putValue(node, KEY_SUFFIX, info.suffix);
-		changed |= putValue(node, KEY_ENABLED, Boolean.toString(info.isEnabled));
-		if (changed)
-			saveToPreferences();
-		return changed;
-	}
-
-	/**
-	 * Cache the fact that we tried to load a repository at this location and did not find anything.
-	 */
-	private void rememberNotFound(URL location) {
-		List badRepos;
-		if (unavailableRepositories != null) {
-			badRepos = (List) unavailableRepositories.get();
-			if (badRepos != null) {
-				badRepos.add(location);
-				return;
-			}
-		}
-		badRepos = new ArrayList();
-		badRepos.add(location);
-		unavailableRepositories = new SoftReference(badRepos);
-	}
-
-	public boolean removeRepository(URL toRemove) {
-		return removeRepository(toRemove, true);
-	}
-
-	public boolean removeRepository(URL toRemove, boolean signalRemove) {
-		Assert.isNotNull(toRemove);
-		final String repoKey = getKey(toRemove);
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			if (repositories.remove(repoKey) == null)
-				return false;
-		}
-		// remove the repository from the preference store
-		try {
-			getPreferences().node(repoKey).removeNode();
-			saveToPreferences();
-		} catch (BackingStoreException e) {
-			log("Error saving preferences", e); //$NON-NLS-1$
-		}
-		//TODO: compute and pass appropriate isEnabled flag
-		if (signalRemove)
-			broadcastChangeEvent(toRemove, IRepository.TYPE_METADATA, RepositoryEvent.REMOVED, true);
-		return true;
-	}
-
-	/**
-	 * Restore the list of repositories from the preference store.
-	 */
-	private void restoreFromPreferences() {
-		// restore the list of repositories from the preference store
-		Preferences node = getPreferences();
-		String[] children;
-		try {
-			children = node.childrenNames();
-		} catch (BackingStoreException e) {
-			log("Error restoring repositories from preferences", e); //$NON-NLS-1$
-			return;
-		}
-		for (int i = 0; i < children.length; i++) {
-			Preferences child = node.node(children[i]);
-			String locationString = child.get(KEY_URL, null);
-			if (locationString == null)
-				continue;
-			try {
-				RepositoryInfo info = new RepositoryInfo();
-				info.location = new URL(locationString);
-				info.name = child.get(KEY_NAME, null);
-				info.description = child.get(KEY_DESCRIPTION, null);
-				info.isSystem = child.getBoolean(KEY_SYSTEM, false);
-				info.isEnabled = child.getBoolean(KEY_ENABLED, true);
-				info.suffix = child.get(KEY_SUFFIX, null);
-				repositories.put(getKey(info.location), info);
-			} catch (MalformedURLException e) {
-				log("Error while restoring repository: " + locationString, e); //$NON-NLS-1$
-			}
-		}
-	}
-
-	/**
-	 * Restores metadata repositories specified as system properties.
-	 */
-	private void restoreFromSystemProperty() {
-		String locationString = Activator.getContext().getProperty("eclipse.p2.metadataRepository"); //$NON-NLS-1$
-		if (locationString == null)
-			return;
-		StringTokenizer tokenizer = new StringTokenizer(locationString, ","); //$NON-NLS-1$
-		while (tokenizer.hasMoreTokens()) {
-			String pathString = tokenizer.nextToken();
-			try {
-				RepositoryInfo info = new RepositoryInfo();
-				info.location = new URL(pathString);
-				repositories.put(getKey(info.location), info);
-			} catch (MalformedURLException e) {
-				log("Error while restoring repository " + pathString, e); //$NON-NLS-1$
-			}
-		}
-	}
-
-	/**
-	 * Restores the repository list.
-	 */
-	protected void restoreRepositories() {
-		synchronized (repositoryLock) {
-			repositories = new HashMap();
-			restoreFromSystemProperty();
-			restoreFromPreferences();
-		}
-	}
-
-	/*
-	 * Save the repository list in the file-system
-	 */
-	private void saveToPreferences() {
-		try {
-			getPreferences().flush();
-		} catch (BackingStoreException e) {
-			log("Error while saving repositories in preferences", e); //$NON-NLS-1$
-		}
-	}
-
-	/*(non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager#setEnabled(java.net.URL, boolean)
-	 */
-	public void setEnabled(URL location, boolean enablement) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
-			if (info == null || info.isEnabled == enablement)
-				return;
-			info.isEnabled = enablement;
-			remember(info);
-		}
-	}
-
-	/**
-	 * Optimize the order in which repository suffixes are searched by trying 
-	 * the last successfully loaded suffix first.
-	 */
-	private String[] sortSuffixes(String[] suffixes, URL location) {
-		synchronized (repositoryLock) {
-			if (repositories == null)
-				restoreRepositories();
-			RepositoryInfo info = (RepositoryInfo) repositories.get(getKey(location));
-			if (info == null || info.suffix == null)
-				return suffixes;
-			//move lastSuffix to the front of the list but preserve order of remaining entries
-			String lastSuffix = info.suffix;
-			for (int i = 0; i < suffixes.length; i++) {
-				if (lastSuffix.equals(suffixes[i])) {
-					System.arraycopy(suffixes, 0, suffixes, 1, i);
-					suffixes[0] = lastSuffix;
-					return suffixes;
-				}
-			}
-		}
-		return suffixes;
+		return (IMetadataRepository) basicRefreshRepository(location, monitor);
 	}
 
 	public IStatus validateRepositoryLocation(URL location, IProgressMonitor monitor) {
-		Assert.isNotNull(location);
 		IMetadataRepository result = getRepository(location);
 		if (result != null)
 			return Status.OK_STATUS;
@@ -803,7 +156,7 @@ public class MetadataRepositoryManager implements IMetadataRepositoryManager, Pr
 			// Loop over the candidates and return the first one that successfully loads
 			loopMonitor.beginTask("", providers.length * 10); //$NON-NLS-1$
 			for (int j = 0; j < providers.length; j++) {
-				IMetadataRepositoryFactory factory = (IMetadataRepositoryFactory) createExecutableExtension(providers[j], FACTORY);
+				IMetadataRepositoryFactory factory = (IMetadataRepositoryFactory) createExecutableExtension(providers[j], EL_FACTORY);
 				if (factory != null) {
 					status = factory.validate(location, loopMonitor.newChild(10));
 					if (status.isOK()) {
@@ -817,5 +170,4 @@ public class MetadataRepositoryManager implements IMetadataRepositoryManager, Pr
 		sub.done();
 		return status;
 	}
-
 }
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/messages.properties b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/messages.properties
index 343d627..a82e32b 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/messages.properties
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/messages.properties
@@ -17,10 +17,6 @@ Error parsing metadata repository
 
 repo_loading = Loading the repository {0}
 
-repoMan_adding = Adding repository {0}
-repoMan_exists=Repository already exists at {0}
-repoMan_failedRead=The repository could not be read: {0}
 repoMan_internalError=Internal error
 repoMan_notExists=No repository found at {0}
-repoMan_unknownType=Unknown repository type at {0}
 repoMan_invalidLocation={0} is not a valid repository location
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/provisional/p2/metadata/repository/IMetadataRepositoryManager.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/provisional/p2/metadata/repository/IMetadataRepositoryManager.java
index d83f689..2dd0d55 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/provisional/p2/metadata/repository/IMetadataRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/provisional/p2/metadata/repository/IMetadataRepositoryManager.java
@@ -15,52 +15,17 @@ import java.util.Map;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
-import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
-import org.eclipse.equinox.internal.provisional.p2.core.repository.RepositoryEvent;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.query.IQueryable;
 
 /**
- * The metadata repository manager is used to create, access, and manipulate
- * {@link IMetadataRepository} instances. The manager keeps track of a 
- * set of known repositories, and provides caching of these known repositories
- * to avoid unnecessary loading of repositories from the disk or network.  The
- * manager fires {@link RepositoryEvent}s when the set of known repositories
- * changes.
+ * A metadata repository manager is used to create, access, and manipulate
+ * {@link IMetadataRepository} instances. See {@link IRepositoryManager}
+ * for a general description of the characteristics of repository managers.
  * 
  * @noimplement This interface is not intended to be implemented by clients.
  */
-public interface IMetadataRepositoryManager extends IQueryable {
-
-	/**
-	 * Constant used to indicate that all enabled repositories are of interest.
-	 */
-	public static final int REPOSITORIES_ALL = 0;
-
-	/**
-	 * Constant used to indicate that system repositories are of interest.
-	 * @see IRepository#PROP_SYSTEM
-	 * @see #getKnownRepositories(int)
-	 */
-	public static final int REPOSITORIES_SYSTEM = 1 << 0;
-
-	/**
-	 * Constant used to indicate that non-system repositories are of interest
-	 * @see IRepository#PROP_SYSTEM
-	 * @see #getKnownRepositories(int)
-	 */
-	public static final int REPOSITORIES_NON_SYSTEM = 1 << 1;
-
-	/**
-	 * Constant used to indicate that local repositories are of interest.
-	 * @see #getKnownRepositories(int)
-	 */
-	public static final int REPOSITORIES_LOCAL = 1 << 2;
-
-	/**
-	 * Constant used to indicate that disabled repositories are of interest.
-	 * @see #getKnownRepositories(int)
-	 */
-	public static final int REPOSITORIES_DISABLED = 1 << 3;
+public interface IMetadataRepositoryManager extends IRepositoryManager, IQueryable {
 
 	/**
 	 * Repository type for a simple repository based on a URL or local file system location.
@@ -68,13 +33,6 @@ public interface IMetadataRepositoryManager extends IQueryable {
 	public static final String TYPE_SIMPLE_REPOSITORY = "org.eclipse.equinox.p2.metadata.repository.simpleRepository"; //$NON-NLS-1$
 
 	/**
-	 * Adds a repository to the list of metadata repositories tracked by the repository
-	 * manager.
-	 * @param location The location of the metadata repository to add
-	 */
-	public void addRepository(URL location);
-
-	/**
 	 * Creates and returns a new empty metadata repository of the given type at 
 	 * the given location.
 	 * <p>
@@ -99,74 +57,6 @@ public interface IMetadataRepositoryManager extends IQueryable {
 	public IMetadataRepository createRepository(URL location, String name, String type, Map properties) throws ProvisionException;
 
 	/**
-	 * Returns the metadata repository locations known to the repository manager.
-	 * <p>
-	 * Note that the repository manager does not guarantee that a valid repository
-	 * exists at any of the returned locations at any particular moment in time.
-	 * A subsequent attempt to load a repository at any of the given locations may
-	 * or may not succeed.
-	 * 
-	 * @param flags an integer bit-mask indicating which repositories should be
-	 * returned.  <code>REPOSITORIES_ALL</code> can be used as the mask when
-	 * all enabled repositories should be returned.  Where multiple masks are combined, only
-	 * the repositories that satisfy all the given criteria are returned. For example,
-	 * a flag value of (REPOSITORIES_SYSTEM|REPOSITORIES_LOCAL) will only
-	 * return repositories that are both system and local repositories.
-	 * 
-	 * @return the locations of the repositories managed by this repository manager.
-	 * 
-	 * @see #REPOSITORIES_ALL
-	 * @see #REPOSITORIES_SYSTEM
-	 * @see #REPOSITORIES_LOCAL
-	 * @see #REPOSITORIES_NON_SYSTEM
-	 * @see #REPOSITORIES_DISABLED
-	 */
-	public URL[] getKnownRepositories(int flags);
-
-	/**
-	 * Returns the property associated with the repository at the given URL, 
-	 * without loading the repository.
-	 * <p>
-	 * Note that some properties for a repository can only be
-	 * determined when that repository is loaded.  This method will return <code>null</code>
-	 * for such properties.  Only values for the properties that are already
-	 * known by a repository manager will be returned. 
-	 * <p>
-	 * If a client wishes to retrieve a property value from a repository 
-	 * regardless of the cost of retrieving it, the client should load the 
-	 * repository and then retrieve the property from the repository itself.
-	 * 
-	 * @param location the URL of the repository in question
-	 * @param key the String key of the property desired
-	 * @return the value of the property, or <code>null</code> if the repository
-	 * does not exist, the value does not exist, or the property value 
-	 * could not be determined without loading the repository.
-	 * 
-	 * @see #loadRepository(URL, IProgressMonitor)
-	 * @see IRepository#getProperties()
-	 */
-	public String getRepositoryProperty(URL location, String key);
-
-	/**
-	 * Returns the enablement value of a repository.  Disabled repositories are known
-	 * to the repository manager, but are never used in the context of provisioning
-	 * operation. Disabled repositories are useful as a form of bookmark to indicate that a 
-	 * repository location is of interest, but not currently used.
-	 * <p>
-	 * Note that enablement is a property of the repository manager and not a property
-	 * of the affected repository. The enablement of the repository is discarded when 
-	 * a repository is removed from the repository manager.
-	 * 
-	 * @param location The location of the repository whose enablement is requested
-	 * @return <code>true</code> if the repository is enabled, and
-	 * <code>false</code> if it is not enabled, or if the repository location 
-	 * is not known to the repository manager.
-	 * @see #REPOSITORIES_DISABLED
-	 * @see #setEnabled(URL, boolean)
-	 */
-	public boolean isEnabled(URL location);
-
-	/**
 	 * Loads a repository corresponding to the given URL.  If a repository has
 	 * previously been loaded at the given location, the same cached repository
 	 * may be returned.
@@ -209,38 +99,6 @@ public interface IMetadataRepositoryManager extends IQueryable {
 	public IMetadataRepository refreshRepository(URL location, IProgressMonitor monitor) throws ProvisionException;
 
 	/**
-	 * Removes the metadata repository at the given location from the list of
-	 * metadata repositories tracked by the repository manager.  The underlying
-	 * repository is not deleted.
-	 * 
-	 * @param location The location of the repository to remove
-	 * @return <code>true</code> if a repository was removed, and 
-	 * <code>false</code> otherwise.
-	 */
-	public boolean removeRepository(URL location);
-
-	/**
-	 * Sets the enablement of a repository. Disabled repositories are known
-	 * to the repository manager, but are never used in the context of provisioning
-	 * operation. Disabled repositories are useful as a form of bookmark to indicate that a 
-	 * repository location is of interest, but not currently used.
-	 * <p>
-	 * Note that enablement is a property of the repository manager and not a property
-	 * of the affected repository. The enablement of the repository is discarded when 
-	 * a repository is removed from the repository manager.
-	 * <p>
-	 * This method has no effect if the given repository location is not known to the
-	 * repository manager.
-	 * 
-	 * @param location The location of the repository to enable or disable
-	 * @param enablement <code>true</code>to enable the repository, and
-	 * <code>false</code> to disable the repository
-	 * @see #REPOSITORIES_DISABLED
-	 * @see #isEnabled(URL)
-	 */
-	public void setEnabled(URL location, boolean enablement);
-
-	/**
 	 * Validates a given URL and returns a status indicating whether a valid repository is likely
 	 * to be found at the given URL.  Callers must assume that the validity of a 
 	 * repository location cannot be completely determined until an attempt to load 
