commit 9a15ce2a2a6dc74c50a95eb6aea2545a60a89a4c
Author: Jeff McAffer <jeff>
Date:   Thu Jan 15 02:21:14 2009 +0000

    Bug 260012 [Query] Cannot properly compose queries

11	2	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/Collector.java
41	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/CompositeQuery.java
140	21	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/CompoundQuery.java
40	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/ContextQuery.java
30	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/IMatchQuery.java
50	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/MatchQuery.java
16	32	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/Query.java
3	2	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/ApplicablePatchQuery.java
1	1	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
2	3	bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/internal/provisional/p2/directorywatcher/RepositoryListener.java
4	5	bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/SurrogateProfileHandler.java
2	2	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/ProductQuery.java
2	2	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/mirror/RangeQuery.java
13	5	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
2	2	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/CapabilityQuery.java
2	2	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/IUPropertyQuery.java
2	2	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/InstallableUnitQuery.java
2	2	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/UpdateQuery.java
2	1	bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/query/AbstractQueryTest.java
311	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AggregateQueryTest.java
1	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AllTests.java
69	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/CollectorTest.java
2	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/QueryTest.java
2	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
4	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
2	2	bundles/org.eclipse.equinox.p2.tools/src/org/eclipse/equinox/internal/p2/tools/mirror/RangeQuery.java
29	4	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
4	4	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/DefaultQueryProvider.java
2	2	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/AnyRequiredCapabilityQuery.java
14	7	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/QueryableProfileRegistry.java
15	9	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/QueryableUpdates.java
14	7	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/QueryableArtifactRepositoryManager.java
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/Collector.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/Collector.java
index ffc892a..79aa6c2 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/Collector.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/Collector.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,11 +7,13 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
  *******************************************************************************/
 package org.eclipse.equinox.internal.provisional.p2.query;
 
 import java.lang.reflect.Array;
 import java.util.*;
+import org.eclipse.core.runtime.IProgressMonitor;
 
 /**
  * A collector is a generic visitor that collects objects passed to it,
@@ -22,7 +24,7 @@ import java.util.*;
  * This default collector just accepts all objects passed to it.  Clients may subclass
  * to perform different processing on the objects passed to it.
  */
-public class Collector {
+public class Collector implements IQueryable {
 	private Set collected = null;
 
 	/**
@@ -112,4 +114,11 @@ public class Collector {
 	public Collection toCollection() {
 		return collected == null ? Collections.EMPTY_SET : Collections.unmodifiableSet(collected);
 	}
+
+	/**
+	 * Performs a query on this results of this collector.  
+	 */
+	public Collector query(Query query, Collector collector, IProgressMonitor monitor) {
+		return query.perform(toCollection().iterator(), collector);
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/CompositeQuery.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/CompositeQuery.java
new file mode 100644
index 0000000..5a99972
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/CompositeQuery.java
@@ -0,0 +1,41 @@
+/******************************************************************************* 
+* Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+* program and the accompanying materials are made available under the terms of
+* the Eclipse Public License v1.0 which accompanies this distribution, and is
+* available at http://www.eclipse.org/legal/epl-v10.html
+*
+* Contributors:
+*   EclipseSource - initial API and implementation
+******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.query;
+
+import java.util.Iterator;
+
+/**
+ * A Composite Query is an aggregate query in which each sub-query
+ * is executed in succession.  The results from the ith sub-query
+ * are piped as input into the i+1th sub-query.
+ */
+public class CompositeQuery implements Query {
+	protected Query[] queries;
+
+	public CompositeQuery(Query[] queries) {
+		this.queries = queries;
+	}
+
+	public Collector perform(Iterator iterator, Collector result) {
+		Collector collector;
+		Iterator iter = iterator;
+		for (int i = 0; i < queries.length; i++) {
+			// Take the results of the previous query and using them
+			// to drive the next one (i.e. composing queries)
+			collector = queries[i].perform(iter, new Collector());
+			iter = collector.iterator();
+		}
+		boolean gatherResults = true;
+		while (iter.hasNext() && gatherResults)
+			gatherResults = result.accept(iter.next());
+		return result;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/CompoundQuery.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/CompoundQuery.java
index 0b3770a..5b2264f 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/CompoundQuery.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/CompoundQuery.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,15 +7,28 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
  *******************************************************************************/
 package org.eclipse.equinox.internal.provisional.p2.query;
 
+import java.util.*;
+
 /**
- * A query that combines a group of other queries.
+ * A query that combines a group of sub-queries.<P>
+ * 
+ * In a CompoundQuery each sub-query is executed and the results are combined using
+ * either logical AND or logical OR operations. <P>
+ * 
+ * Clients are expected to call {@link CompoundQuery#createCompoundQuery(Query[], boolean)}
+ * to create a concrete instance of a CompoundQuery.  If all Queries are instances of 
+ * {@link IMatchQuery} then the resulting compound query will be a MatchCompoundQuery, otherwise the
+ * resulting compound query will be a {@link ContextQuery}.
+ * 
+ * @noextend This class is not intended to be subclassed by clients.
  */
-public class CompoundQuery extends Query {
-	private boolean and;
-	private Query[] queries;
+public abstract class CompoundQuery implements Query {
+	protected Query[] queries;
+	protected boolean and;
 
 	/**
 	 * Creates a compound query that combines the given queries. The queries
@@ -23,15 +36,24 @@ public class CompoundQuery extends Query {
 	 * might not perform all queries if it can determine the result of the compound
 	 * expression without doing so.
 	 * 
+	 * If all the queries are instances of {@link IMatchQuery} then the resulting
+	 * compound query will be an instance of IMatchQuery, otherwise the resulting
+	 * compound query will be a context query.
+	 * 
 	 * @param queries The queries to perform
 	 * @param and <code>true</code> if this query represents a logical 'and', and
 	 * <code>false</code> if this query represents a logical 'or'.
 	 */
-	public CompoundQuery(Query[] queries, boolean and) {
-		this.queries = queries;
-		this.and = and;
+	public static CompoundQuery createCompoundQuery(Query[] queries, boolean and) {
+		if (isMatchQueries(queries)) {
+			return new CompoundQuery.MatchCompoundQuery(queries, and);
+		}
+		return new CompoundQuery.ContextCompoundQuery(queries, and);
 	}
 
+	/**
+	 * Returns the queries that make up this compound query
+	 */
 	public Query[] getQueries() {
 		return queries;
 	}
@@ -46,22 +68,119 @@ public class CompoundQuery extends Query {
 		return and;
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.p2.query2.Query#isMatch(java.lang.Object)
+	protected CompoundQuery(Query[] queries, boolean and) {
+		this.queries = queries;
+		this.and = and;
+	}
+
+	/**
+	 * @param queries
 	 */
-	public boolean isMatch(Object candidate) {
+	private static boolean isMatchQueries(Query[] queries) {
 		for (int i = 0; i < queries.length; i++) {
-			boolean valid = queries[i].isMatch(candidate);
-			// if we are OR'ing then the first time we find a requirement that is met, return success
-			if (valid && !and)
-				return true;
-			// if we are AND'ing then the first time we find a requirement that is NOT met, return failure
-			if (!valid && and)
+			if (!(queries[i] instanceof IMatchQuery)) {
 				return false;
+			}
 		}
-		// if we get past the requirements check and we are AND'ing then return true 
-		// since all requirements must have been met.  If we are OR'ing then return false 
-		// since none of the requirements were met.
-		return and;
+		return true;
+	}
+
+	/**
+	 * The compound query insatiated when all queries are Match Queries.
+	 */
+	private static class MatchCompoundQuery extends CompoundQuery implements IMatchQuery {
+
+		protected MatchCompoundQuery(Query[] queries, boolean and) {
+			super(queries, and);
+		}
+
+		public boolean isMatch(Object candidate) {
+			for (int i = 0; i < queries.length; i++) {
+				boolean valid = ((IMatchQuery) queries[i]).isMatch(candidate);
+				// if we are OR'ing then the first time we find a requirement that is met, return success
+				if (valid && !and)
+					return true;
+				// if we are AND'ing then the first time we find a requirement that is NOT met, return failure
+				if (!valid && and)
+					return false;
+			}
+			// if we get past the requirements check and we are AND'ing then return true 
+			// since all requirements must have been met.  If we are OR'ing then return false 
+			// since none of the requirements were met.
+			return and;
+		}
+
+		/**
+		 * Performs this query on the given iterator, passing all objects in the iterator 
+		 * that match the criteria of this query to the given result.
+		 */
+		public final Collector perform(Iterator iterator, Collector result) {
+			while (iterator.hasNext()) {
+				Object candidate = iterator.next();
+				if (isMatch(candidate))
+					if (!result.accept(candidate))
+						break;
+			}
+			return result;
+		}
+	}
+
+	/**
+	 * The compound query insatiated when any of the queries are not 
+	 * match queries.
+	 */
+	private static class ContextCompoundQuery extends CompoundQuery {
+
+		protected ContextCompoundQuery(Query[] queries, boolean and) {
+			super(queries, and);
+		}
+
+		/*
+		 * A collector that takes the set to puts the elements in.
+		 */
+		class SetCollector extends Collector {
+			Set s = null;
+
+			public SetCollector(Set s) {
+				this.s = s;
+			}
+
+			public boolean accept(Object object) {
+				s.add(object);
+				return true;
+			}
+		}
+
+		public Collector perform(Iterator iterator, Collector result) {
+			if (queries.length < 1)
+				return result;
+
+			Collection data = new LinkedList();
+
+			while (iterator.hasNext()) {
+				data.add(iterator.next());
+			}
+
+			Set[] resultSets = new Set[queries.length];
+			for (int i = 0; i < queries.length; i++) {
+				resultSets[i] = new HashSet();
+				queries[i].perform(data.iterator(), new SetCollector(resultSets[i]));
+			}
+
+			Set set = resultSets[0];
+			for (int i = 1; i < resultSets.length; i++) {
+				if (isAnd())
+					set.retainAll(resultSets[i]);
+				else
+					set.addAll(resultSets[i]);
+			}
+
+			Iterator resultIterator = set.iterator();
+			boolean gatherResults = true;
+			while (resultIterator.hasNext() && gatherResults)
+				gatherResults = result.accept(resultIterator.next());
+			return result;
+		}
+
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/ContextQuery.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/ContextQuery.java
new file mode 100644
index 0000000..8277b84
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/ContextQuery.java
@@ -0,0 +1,40 @@
+/******************************************************************************* 
+* Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+* program and the accompanying materials are made available under the terms of
+* the Eclipse Public License v1.0 which accompanies this distribution, and is
+* available at http://www.eclipse.org/legal/epl-v10.html
+*
+* Contributors:
+*   EclipseSource - initial API and implementation
+******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.query;
+
+import java.util.Iterator;
+
+/**
+ * ContextQuery is the abstract superclass for Queries that require the entire
+ * input to evaluate the results.  Queries must consider the group of elements before
+ * processing the results. <P>
+ * 
+ * Users of this query must call {@link #perform(Iterator, Collector)} to compute 
+ * the results. <P>
+ * This class may be subclassed by clients. Subclasses should specify the type
+ * of object they support querying on. Subclasses are also encouraged to clearly
+ * specify their match algorithm, and expose the parameters involved in the match
+ * computation, to allow {@link IQueryable} implementations to optimize their
+ * execution of the query. <P>
+ *
+ */
+public abstract class ContextQuery implements Query {
+
+	/**
+	 * Evaluates the query for a specific input.  
+	 * 
+	 * @param iterator The elements for which to evaluate the query on
+	 * @param result A collector to collect the results.  For each element accepted 
+	 * by the query,{@link Collector#accept(Object)} must be called.
+	 * @return The results of the query.  The collector returned must be
+	 * the collector passed in.
+	 */
+	public abstract Collector perform(Iterator iterator, Collector result);
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/IMatchQuery.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/IMatchQuery.java
new file mode 100644
index 0000000..3af11de
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/IMatchQuery.java
@@ -0,0 +1,30 @@
+/******************************************************************************* 
+* Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+* program and the accompanying materials are made available under the terms of
+* the Eclipse Public License v1.0 which accompanies this distribution, and is
+* available at http://www.eclipse.org/legal/epl-v10.html
+*
+* Contributors:
+*   EclipseSource - initial API and implementation
+******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.query;
+
+/**
+ * A query in which the elements can be evaluated by calling isMatch on. Each
+ * element can be evaluated independently of all other elements.  Match queries
+ * can be evaluated in parallel as each call {@link #isMatch(Object)} is mutually
+ * exclusive from all other calls. <P>
+ * 
+ * @spi Clients should not implement this interface, but rather extend {@link MatchQuery}.
+ */
+public interface IMatchQuery extends Query {
+
+	/**
+	 * Returns whether the given object satisfies the parameters of this query.
+	 * 
+	 * @param candidate The object to perform the query against
+	 * @return <code>true</code> if the unit satisfies the parameters
+	 * of this query, and <code>false</code> otherwise
+	 */
+	public boolean isMatch(Object candidate);
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/MatchQuery.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/MatchQuery.java
new file mode 100644
index 0000000..9fbf0a3
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/MatchQuery.java
@@ -0,0 +1,50 @@
+/******************************************************************************* 
+* Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+* program and the accompanying materials are made available under the terms of
+* the Eclipse Public License v1.0 which accompanies this distribution, and is
+* available at http://www.eclipse.org/legal/epl-v10.html
+*
+* Contributors:
+*   EclipseSource - initial API and implementation
+******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.query;
+
+import java.util.Iterator;
+
+/**
+ * This class represents the superclass of most of p2's queries.  Every element
+ * in the query can be evaluated by calling isMatch on it. If {@link #isMatch(Object)} returns true, 
+ * then the element WILL be included in the result set, if {@link #isMatch(Object)} returns false, then 
+ * the element WILL NOT be included in the result set. <P>
+ *
+ * This class may be subclassed by clients. Subclasses should specify the type
+ * of object they support querying on. Subclasses are also encouraged to clearly
+ * specify their match algorithm, and expose the parameters involved in the match
+ * computation, to allow {@link IQueryable} implementations to optimize their
+ * execution of the query. <P>
+ */
+public abstract class MatchQuery implements IMatchQuery {
+
+	/**
+	 * Returns whether the given object satisfies the parameters of this query.
+	 * 
+	 * @param candidate The object to perform the query against
+	 * @return <code>true</code> if the unit satisfies the parameters
+	 * of this query, and <code>false</code> otherwise
+	 */
+	public abstract boolean isMatch(Object candidate);
+
+	/**
+	 * Performs this query on the given iterator, passing all objects in the iterator 
+	 * that match the criteria of this query to the given result.
+	 */
+	public final Collector perform(Iterator iterator, Collector result) {
+		while (iterator.hasNext()) {
+			Object candidate = iterator.next();
+			if (isMatch(candidate))
+				if (!result.accept(candidate))
+					break;
+		}
+		return result;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/Query.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/Query.java
index d633ba9..9c9845f 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/Query.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/query/Query.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
  *******************************************************************************/
 package org.eclipse.equinox.internal.provisional.p2.query;
 
@@ -15,40 +16,23 @@ import java.util.Iterator;
 /**
  * The superclass of all queries that can be performed on an {@link IQueryable}.
  * <p>
- * This class may be subclassed by clients. Subclasses should specify the type
- * of object they support querying on. Subclasses are also encouraged to clearly
- * specify their match algorithm, and expose the parameters involved in the match
- * computation, to allow {@link IQueryable} implementations to optimize their
- * execution of the query.
+ * 
+ * <B>NOTE:  This interface does not follow the proper naming convention. It should 
+ * be IQuery, however, for historic reasons it is Query.  This is likely to change.</B>
+ * 
+ * @noimplement This interface is not intended to be implemented by clients.
+ * @noextend This interface is not intended to be extended by clients.
  */
-public abstract class Query {
-	/**
-	 * Creates a new query.
-	 */
-	public Query() {
-		super();
-	}
+public interface Query {
 
 	/**
-	 * Returns whether the given object satisfies the parameters of this query.
+	 * Evaluates the query for a specific input.  
 	 * 
-	 * @param candidate The object to perform the query against
-	 * @return <code>true</code> if the unit satisfies the parameters
-	 * of this query, and <code>false</code> otherwise
-	 */
-	public abstract boolean isMatch(Object candidate);
-
-	/**
-	 * Performs this query on the given iterator, passing all objects in the iterator 
-	 * that match the criteria of this query to the given result.
+	 * @param iterator The elements for which to evaluate the query on
+	 * @param result A collector to collect the results.  For each element accepted 
+	 * by the query,{@link Collector#accept(Object)} must be called.
+	 * @return The results of the query.  The collector returned must be
+	 * the collector passed in.
 	 */
-	public Collector perform(Iterator iterator, Collector result) {
-		while (iterator.hasNext()) {
-			Object candidate = iterator.next();
-			if (isMatch(candidate))
-				if (!result.accept(candidate))
-					break;
-		}
-		return result;
-	}
+	public abstract Collector perform(Iterator iterator, Collector result);
 }
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/ApplicablePatchQuery.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/ApplicablePatchQuery.java
index c0f7cd7..3f001c8 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/ApplicablePatchQuery.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/ApplicablePatchQuery.java
@@ -9,17 +9,18 @@
 package org.eclipse.equinox.internal.p2.director;
 
 import org.eclipse.equinox.internal.provisional.p2.metadata.*;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 import org.eclipse.equinox.internal.provisional.p2.query.Query;
 
 /**
  * A query that accepts any patch that applies to a given installable unit.
  */
-public class ApplicablePatchQuery extends Query {
+public class ApplicablePatchQuery extends MatchQuery {
 
 	/**
 	 * A query that matches any patch.
 	 */
-	public static final Query ANY = new Query() {
+	public static final Query ANY = new MatchQuery() {
 		public boolean isMatch(Object candidate) {
 			return candidate instanceof IInstallableUnitPatch;
 		}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
index e269754..c2d457a 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
@@ -161,7 +161,7 @@ public class SimplePlanner implements IPlanner {
 	}
 
 	public static IInstallableUnit[] findPlannerMarkedIUs(final IProfile profile) {
-		Query markerQuery = new Query() {
+		Query markerQuery = new MatchQuery() {
 			public boolean isMatch(Object candidate) {
 				if (!(candidate instanceof IInstallableUnit))
 					return false;
diff --git a/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/internal/provisional/p2/directorywatcher/RepositoryListener.java b/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/internal/provisional/p2/directorywatcher/RepositoryListener.java
index 0fe815f..2492395 100644
--- a/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/internal/provisional/p2/directorywatcher/RepositoryListener.java
+++ b/bundles/org.eclipse.equinox.p2.directorywatcher/src/org/eclipse/equinox/internal/provisional/p2/directorywatcher/RepositoryListener.java
@@ -24,8 +24,7 @@ import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
-import org.eclipse.equinox.internal.provisional.p2.query.Collector;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.*;
 import org.eclipse.equinox.p2.publisher.*;
 import org.eclipse.equinox.p2.publisher.eclipse.BundlesAction;
 import org.eclipse.equinox.p2.publisher.eclipse.FeaturesAction;
@@ -211,7 +210,7 @@ public class RepositoryListener extends DirectoryChangeListener {
 		// first remove any IUs that have changed or that are associated with removed files
 		if (!removedFiles.isEmpty() || !changes.isEmpty()) {
 			// create a query that will identify all ius related to removed files or ius that have changed
-			Query removeQuery = new Query() {
+			IMatchQuery removeQuery = new MatchQuery() {
 				public boolean isMatch(Object candidate) {
 					if (!(candidate instanceof IInstallableUnit))
 						return false;
diff --git a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/SurrogateProfileHandler.java b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/SurrogateProfileHandler.java
index 3c00622..30b88cf 100644
--- a/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/SurrogateProfileHandler.java
+++ b/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/SurrogateProfileHandler.java
@@ -18,8 +18,7 @@ import org.eclipse.equinox.internal.provisional.p2.engine.IProfile;
 import org.eclipse.equinox.internal.provisional.p2.engine.ISurrogateProfileHandler;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
-import org.eclipse.equinox.internal.provisional.p2.query.Collector;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.*;
 import org.eclipse.osgi.service.datalocation.Location;
 import org.eclipse.osgi.util.NLS;
 
@@ -41,7 +40,7 @@ public class SurrogateProfileHandler implements ISurrogateProfileHandler {
 	private SimpleProfileRegistry profileRegistry;
 
 	private static void addSharedProfileBaseIUs(final IProfile sharedProfile, final Profile userProfile) {
-		Query rootIUQuery = new Query() {
+		Query rootIUQuery = new MatchQuery() {
 			public boolean isMatch(Object candidate) {
 				if (candidate instanceof IInstallableUnit) {
 					IInstallableUnit iu = (IInstallableUnit) candidate;
@@ -64,7 +63,7 @@ public class SurrogateProfileHandler implements ISurrogateProfileHandler {
 	}
 
 	private static void removeUserProfileBaseIUs(final Profile userProfile) {
-		Query rootIUQuery = new Query() {
+		Query rootIUQuery = new MatchQuery() {
 			public boolean isMatch(Object candidate) {
 				if (candidate instanceof IInstallableUnit) {
 					IInstallableUnit iu = (IInstallableUnit) candidate;
@@ -82,7 +81,7 @@ public class SurrogateProfileHandler implements ISurrogateProfileHandler {
 	}
 
 	private static void markRootsOptional(final Profile userProfile) {
-		Query rootIUQuery = new Query() {
+		Query rootIUQuery = new MatchQuery() {
 			public boolean isMatch(Object candidate) {
 				if (candidate instanceof IInstallableUnit) {
 					IInstallableUnit iu = (IInstallableUnit) candidate;
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/ProductQuery.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/ProductQuery.java
index 6e81c68..127a9ca 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/ProductQuery.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/ProductQuery.java
@@ -19,9 +19,9 @@ import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.internal.provisional.p2.metadata.generator.MetadataGeneratorHelper;
 import org.eclipse.equinox.internal.provisional.p2.metadata.generator.Generator.GeneratorResult;
 import org.eclipse.equinox.internal.provisional.p2.query.Collector;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 
-public class ProductQuery extends Query {
+public class ProductQuery extends MatchQuery {
 	private static final String EQUINOX_LAUNCHER = "org.eclipse.equinox.launcher"; //$NON-NLS-1$
 
 	private final ProductFile product;
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/mirror/RangeQuery.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/mirror/RangeQuery.java
index e8f7a2c..1639e81 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/mirror/RangeQuery.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/mirror/RangeQuery.java
@@ -11,13 +11,13 @@
 package org.eclipse.equinox.internal.p2.metadata.mirror;
 
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 
 /**
  * A convenience query that will match any {@link IInstallableUnit}
  * it encounters.
  */
-public class RangeQuery extends Query {
+public class RangeQuery extends MatchQuery {
 	private VersionRangedName[] targets;
 
 	/**
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
index 0678273..2d925dd 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/LocalMetadataRepository.java
@@ -25,8 +25,7 @@ import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
 import org.eclipse.equinox.internal.provisional.p2.core.repository.RepositoryEvent;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
-import org.eclipse.equinox.internal.provisional.p2.query.Collector;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.*;
 import org.eclipse.equinox.internal.provisional.spi.p2.metadata.repository.AbstractMetadataRepository;
 import org.eclipse.equinox.internal.provisional.spi.p2.metadata.repository.RepositoryReference;
 
@@ -154,11 +153,20 @@ public class LocalMetadataRepository extends AbstractMetadataRepository {
 
 	public synchronized boolean removeInstallableUnits(Query query, IProgressMonitor monitor) {
 		boolean changed = false;
-		for (Iterator it = units.iterator(); it.hasNext();)
-			if (query.isMatch(it.next())) {
-				it.remove();
+		if (query instanceof IMatchQuery) {
+			IMatchQuery matchQuery = (IMatchQuery) query;
+			for (Iterator it = units.iterator(); it.hasNext();)
+				if (matchQuery.isMatch(it.next())) {
+					it.remove();
+					changed = true;
+				}
+		} else {
+			Collector results = query.perform(units.iterator(), new Collector());
+			if (results.size() > 0) {
 				changed = true;
+				units.removeAll(results.toCollection());
 			}
+		}
 		if (changed)
 			save();
 		return changed;
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/CapabilityQuery.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/CapabilityQuery.java
index c85d4c8..6c4013f 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/CapabilityQuery.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/CapabilityQuery.java
@@ -12,13 +12,13 @@ package org.eclipse.equinox.internal.provisional.p2.metadata.query;
 
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IRequiredCapability;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 
 /**
  * A query that searches for {@link IInstallableUnit} instances that provide
  * capabilities that match one or more required capabilities.
  */
-public class CapabilityQuery extends Query {
+public class CapabilityQuery extends MatchQuery {
 	private IRequiredCapability[] required;
 
 	/**
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/IUPropertyQuery.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/IUPropertyQuery.java
index ea608d8..22983d6 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/IUPropertyQuery.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/IUPropertyQuery.java
@@ -11,14 +11,14 @@
 package org.eclipse.equinox.internal.provisional.p2.metadata.query;
 
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 
 /**
  * A query that searches for {@link IInstallableUnit} instances that have
  * a property whose value matches the provided value.  If no property name is 
  * specified, then all {@link IInstallableUnit} instances are accepted.
  */
-public class IUPropertyQuery extends Query {
+public class IUPropertyQuery extends MatchQuery {
 	private String propertyName;
 	private String propertyValue;
 
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/InstallableUnitQuery.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/InstallableUnitQuery.java
index 905c40a..28ab866 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/InstallableUnitQuery.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/InstallableUnitQuery.java
@@ -13,12 +13,12 @@ package org.eclipse.equinox.internal.provisional.p2.metadata.query;
 import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.core.VersionRange;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 
 /**
  * A query that matches on the id and version of an {@link IInstallableUnit}.
  */
-public class InstallableUnitQuery extends Query {
+public class InstallableUnitQuery extends MatchQuery {
 	/**
 	 * A convenience query that will match any {@link IInstallableUnit}
 	 * it encounters.
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/UpdateQuery.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/UpdateQuery.java
index cb70bf9..8036c1f 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/UpdateQuery.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/provisional/p2/metadata/query/UpdateQuery.java
@@ -10,9 +10,9 @@ package org.eclipse.equinox.internal.provisional.p2.metadata.query;
 
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IUpdateDescriptor;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 
-public class UpdateQuery extends Query {
+public class UpdateQuery extends MatchQuery {
 	private IInstallableUnit updateFrom;
 
 	public UpdateQuery(IInstallableUnit updateFrom) {
diff --git a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/query/AbstractQueryTest.java b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/query/AbstractQueryTest.java
index 0a033ad..4d06a04 100644
--- a/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/query/AbstractQueryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests.ui/src/org/eclipse/equinox/p2/tests/ui/query/AbstractQueryTest.java
@@ -11,6 +11,7 @@
 package org.eclipse.equinox.p2.tests.ui.query;
 
 import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 import org.eclipse.equinox.internal.provisional.p2.query.Query;
 import org.eclipse.equinox.internal.provisional.p2.ui.policy.IUViewQueryContext;
 import org.eclipse.equinox.internal.provisional.p2.ui.policy.Policy;
@@ -43,7 +44,7 @@ public abstract class AbstractQueryTest extends AbstractProvisioningTest {
 	}
 
 	protected Query getMockQuery() {
-		return new Query() {
+		return new MatchQuery() {
 			public boolean isMatch(Object candidate) {
 				return true;
 			}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AggregateQueryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AggregateQueryTest.java
new file mode 100644
index 0000000..a35964e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AggregateQueryTest.java
@@ -0,0 +1,311 @@
+/******************************************************************************* 
+* Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+* program and the accompanying materials are made available under the terms of
+* the Eclipse Public License v1.0 which accompanies this distribution, and is
+* available at http://www.eclipse.org/legal/epl-v10.html
+*
+* Contributors:
+*   EclipseSource - initial API and implementation
+******************************************************************************/
+package org.eclipse.equinox.p2.tests.core;
+
+import java.util.*;
+import junit.framework.TestCase;
+import org.eclipse.equinox.internal.provisional.p2.query.*;
+
+/**
+ * This tests both Compound and Composite queries
+ * 
+ */
+public class AggregateQueryTest extends TestCase {
+
+	public List getABCDE() {
+		return Arrays.asList("A", "B", "C", "D", "E");
+	}
+
+	public List get123() {
+		return Arrays.asList("1", "2", "3");
+	}
+
+	public void testEmptyCompositeQuery() {
+		CompositeQuery query = new CompositeQuery(new Query[0]);
+		query.perform(getABCDE().iterator(), new Collector());
+		// We should not throw an exception.  No guarantee on what perform
+		// will return in this case
+	}
+
+	public void testSymmetry() {
+		Query getLatest = new ContextQuery() {
+
+			public Collector perform(Iterator iterator, Collector result) {
+				List list = new ArrayList();
+				while (iterator.hasNext()) {
+					list.add(iterator.next());
+				}
+				Collections.sort(list);
+				result.accept(list.get(list.size() - 1));
+				return result;
+			}
+		};
+
+		Query getAllBut3 = new ContextQuery() {
+
+			public Collector perform(Iterator iterator, Collector result) {
+				while (iterator.hasNext()) {
+					Object o = iterator.next();
+					if (!o.equals("3"))
+						result.accept(o);
+				}
+				return result;
+			}
+		};
+
+		CompoundQuery compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {getLatest, getAllBut3}, true);
+		Collector result = compoundQuery.perform(get123().iterator(), new Collector());
+		assertEquals(0, result.size());
+
+		compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {getAllBut3, getLatest}, true);
+		result = compoundQuery.perform(get123().iterator(), new Collector());
+		assertEquals(0, result.size());
+
+		compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {getLatest, getAllBut3}, false);
+		result = compoundQuery.perform(get123().iterator(), new Collector());
+		assertEquals(3, result.size());
+
+		compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {getAllBut3, getLatest}, false);
+		result = compoundQuery.perform(get123().iterator(), new Collector());
+		assertEquals(3, result.size());
+
+	}
+
+	/**
+	 * The CompositeQuery should not support symmetry.
+	 * This method tests that
+	 */
+	public void testNonSymmetry() {
+		Query getLatest = new ContextQuery() {
+
+			public Collector perform(Iterator iterator, Collector result) {
+				List list = new ArrayList();
+				while (iterator.hasNext()) {
+					list.add(iterator.next());
+				}
+				Collections.sort(list);
+				result.accept(list.get(list.size() - 1));
+				return result;
+			}
+		};
+
+		Query getAllBut3 = new ContextQuery() {
+
+			public Collector perform(Iterator iterator, Collector result) {
+				while (iterator.hasNext()) {
+					Object o = iterator.next();
+					if (!o.equals("3"))
+						result.accept(o);
+				}
+				return result;
+			}
+		};
+
+		CompositeQuery compoundQuery = new CompositeQuery(new Query[] {getLatest, getAllBut3});
+		Collector result = compoundQuery.perform(get123().iterator(), new Collector());
+		assertEquals(0, result.size());
+
+		compoundQuery = new CompositeQuery(new Query[] {getAllBut3, getLatest});
+		result = compoundQuery.perform(get123().iterator(), new Collector());
+		assertEquals(1, result.size());
+		assertEquals("2", result.toCollection().iterator().next());
+
+	}
+
+	public void testCompoundAllMatchQueries() {
+		Query A = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				return false;
+			}
+		};
+		Query B = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				return false;
+			}
+		};
+		Query C = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				return false;
+			}
+		};
+		CompoundQuery compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {A, B, C}, true);
+		assertTrue("1.0", compoundQuery instanceof IMatchQuery);
+		assertEquals("1.1", 3, compoundQuery.getQueries().length);
+		assertEquals("1.2", A, compoundQuery.getQueries()[0]);
+		assertEquals("1.3", B, compoundQuery.getQueries()[1]);
+		assertEquals("1.4", C, compoundQuery.getQueries()[2]);
+	}
+
+	public void testCompoundSomeMatchQueries() {
+		Query A = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				return false;
+			}
+		};
+		Query B = new ContextQuery() {
+			public Collector perform(Iterator iterator, Collector result) {
+				// TODO Auto-generated method stub
+				return null;
+			}
+		};
+		Query C = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				return false;
+			}
+		};
+		CompoundQuery compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {A, B, C}, true);
+		assertTrue("1.0", !(compoundQuery instanceof IMatchQuery));
+		assertEquals("1.1", 3, compoundQuery.getQueries().length);
+		assertEquals("1.2", A, compoundQuery.getQueries()[0]);
+		assertEquals("1.3", B, compoundQuery.getQueries()[1]);
+		assertEquals("1.4", C, compoundQuery.getQueries()[2]);
+	}
+
+	public void testCompoundNoMatchQueries() {
+		Query A = new ContextQuery() {
+			public Collector perform(Iterator iterator, Collector result) {
+				// TODO Auto-generated method stub
+				return null;
+			}
+		};
+		Query B = new ContextQuery() {
+			public Collector perform(Iterator iterator, Collector result) {
+				// TODO Auto-generated method stub
+				return null;
+			}
+		};
+		Query C = new ContextQuery() {
+			public Collector perform(Iterator iterator, Collector result) {
+				// TODO Auto-generated method stub
+				return null;
+			}
+		};
+		CompoundQuery compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {A, B, C}, true);
+		assertTrue("1.0", !(compoundQuery instanceof IMatchQuery));
+		assertEquals("1.1", 3, compoundQuery.getQueries().length);
+		assertEquals("1.2", A, compoundQuery.getQueries()[0]);
+		assertEquals("1.3", B, compoundQuery.getQueries()[1]);
+		assertEquals("1.4", C, compoundQuery.getQueries()[2]);
+	}
+
+	public void testIntersection() {
+		Query ABC = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				if (candidate.equals("A") || candidate.equals("B") || candidate.equals("C"))
+					return true;
+				return false;
+			}
+		};
+
+		Query BCDE = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				if (candidate.equals("B") || candidate.equals("C") || candidate.equals("D") || candidate.equals("E"))
+					return true;
+				return false;
+			}
+		};
+
+		CompoundQuery compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {ABC, BCDE}, true);
+		Collector result = compoundQuery.perform(getABCDE().iterator(), new Collector());
+		assertEquals("1.0", result.size(), 2);
+		assertTrue("1.1", result.toCollection().contains("B"));
+		assertTrue("1.2", result.toCollection().contains("C"));
+	}
+
+	public void testIntersection2() {
+		Query ABC = new Query() {
+			public Collector perform(Iterator iterator, Collector result) {
+				while (iterator.hasNext()) {
+					Object o = iterator.next();
+					if (o.equals("A") || o.equals("B") || o.equals("C"))
+						result.accept(o);
+				}
+				return result;
+			}
+		};
+
+		Query BCDE = new Query() {
+			public Collector perform(Iterator iterator, Collector result) {
+				while (iterator.hasNext()) {
+					Object o = iterator.next();
+					if (o.equals("B") || o.equals("C") || o.equals("D") || o.equals("E"))
+						result.accept(o);
+				}
+				return result;
+			}
+		};
+
+		CompoundQuery compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {ABC, BCDE}, true);
+		Collector result = compoundQuery.perform(getABCDE().iterator(), new Collector());
+		assertEquals("1.0", result.size(), 2);
+		assertTrue("1.1", result.toCollection().contains("B"));
+		assertTrue("1.2", result.toCollection().contains("C"));
+	}
+
+	public void testUnion() {
+		Query ABC = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				if (candidate.equals("A") || candidate.equals("B") || candidate.equals("C"))
+					return true;
+				return false;
+			}
+		};
+
+		Query BCDE = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				if (candidate.equals("B") || candidate.equals("C") || candidate.equals("D") || candidate.equals("E"))
+					return true;
+				return false;
+			}
+		};
+
+		CompoundQuery compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {ABC, BCDE}, false);
+		Collector result = compoundQuery.perform(getABCDE().iterator(), new Collector());
+		assertEquals("1.0", result.size(), 5);
+		assertTrue("1.1", result.toCollection().contains("A"));
+		assertTrue("1.2", result.toCollection().contains("B"));
+		assertTrue("1.3", result.toCollection().contains("C"));
+		assertTrue("1.4", result.toCollection().contains("D"));
+		assertTrue("1.5", result.toCollection().contains("E"));
+	}
+
+	public void testUnion2() {
+		Query ABC = new Query() {
+			public Collector perform(Iterator iterator, Collector result) {
+				while (iterator.hasNext()) {
+					Object o = iterator.next();
+					if (o.equals("A") || o.equals("B") || o.equals("C"))
+						result.accept(o);
+				}
+				return result;
+			}
+		};
+
+		Query BCDE = new Query() {
+			public Collector perform(Iterator iterator, Collector result) {
+				while (iterator.hasNext()) {
+					Object o = iterator.next();
+					if (o.equals("B") || o.equals("C") || o.equals("D") || o.equals("E"))
+						result.accept(o);
+				}
+				return result;
+			}
+		};
+
+		CompoundQuery compoundQuery = CompoundQuery.createCompoundQuery(new Query[] {ABC, BCDE}, false);
+		Collector result = compoundQuery.perform(getABCDE().iterator(), new Collector());
+		assertEquals("1.0", result.size(), 5);
+		assertTrue("1.1", result.toCollection().contains("A"));
+		assertTrue("1.2", result.toCollection().contains("B"));
+		assertTrue("1.3", result.toCollection().contains("C"));
+		assertTrue("1.4", result.toCollection().contains("D"));
+		assertTrue("1.5", result.toCollection().contains("E"));
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AllTests.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AllTests.java
index 807e067..87118cf 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AllTests.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/AllTests.java
@@ -23,6 +23,7 @@ public class AllTests extends TestCase {
 		suite.addTestSuite(FileUtilsTest.class);
 		suite.addTestSuite(OrderedPropertiesTest.class);
 		suite.addTestSuite(QueryTest.class);
+		suite.addTestSuite(AggregateQueryTest.class);
 		suite.addTestSuite(URLUtilTest.class);
 		return suite;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/CollectorTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/CollectorTest.java
index 3e49c29..1288ff6 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/CollectorTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/CollectorTest.java
@@ -7,11 +7,12 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
  *******************************************************************************/
 package org.eclipse.equinox.p2.tests.core;
 
-import java.util.Collection;
-import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import java.util.*;
+import org.eclipse.equinox.internal.provisional.p2.query.*;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
 
 /**
@@ -40,6 +41,72 @@ public class CollectorTest extends AbstractProvisioningTest {
 		assertEquals("1.0", false, collector.isEmpty());
 	}
 
+	/**
+	 * This tests the query method on the collector.
+	 */
+	public void testCompositeCollectors() {
+		String[] s = new String[] {"A", "B", "C", "D", "E", "F", "G", "1", "2", "3", "4", "5", "6", "7"};
+		List list = Arrays.asList(s);
+		Query numeric = new MatchQuery() {
+
+			public boolean isMatch(Object candidate) {
+				if (((String) candidate).compareTo("0") > 0 && ((String) candidate).compareTo("8") < 0) {
+					return true;
+				}
+				return false;
+			}
+		};
+
+		Query fourOrFiveOrABC = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				if (((String) candidate).equals("4") || ((String) candidate).equals("5") || ((String) candidate).equals("A") || ((String) candidate).equals("B") || ((String) candidate).equals("C")) {
+					return true;
+				}
+				return false;
+			}
+		};
+		Collector collector = numeric.perform(list.iterator(), new Collector());
+		assertEquals("1.0", 7, collector.toCollection().size());
+
+		collector = collector.query(fourOrFiveOrABC, new Collector(), null);
+		Collection collection = collector.toCollection();
+		assertEquals("2.0", 2, collection.size());
+		assertTrue("2.1", collection.contains("4"));
+		assertTrue("2.2", collection.contains("5"));
+	}
+
+	/**
+	 * This tests the query method on the collector.
+	 */
+	public void testEmptyCompositeCollectors() {
+		String[] s = new String[] {"A", "B", "C", "D", "E", "F", "G", "1", "2", "3", "4", "5", "6", "7"};
+		List list = Arrays.asList(s);
+		Query eightOrNine = new MatchQuery() {
+
+			public boolean isMatch(Object candidate) {
+				if (((String) candidate).compareTo("8") > 0 && ((String) candidate).compareTo("9") < 0) {
+					return true;
+				}
+				return false;
+			}
+		};
+
+		Query fourOrFiveOrABC = new MatchQuery() {
+			public boolean isMatch(Object candidate) {
+				if (((String) candidate).equals("4") || ((String) candidate).equals("5") || ((String) candidate).equals("A") || ((String) candidate).equals("B") || ((String) candidate).equals("C")) {
+					return true;
+				}
+				return false;
+			}
+		};
+		Collector collector = eightOrNine.perform(list.iterator(), new Collector());
+		assertEquals("1.0", 0, collector.toCollection().size());
+
+		collector = collector.query(fourOrFiveOrABC, new Collector(), null);
+		Collection collection = collector.toCollection();
+		assertEquals("2.0", 0, collection.size());
+	}
+
 	public void testToCollection() {
 		Collector collector = new Collector();
 		Collection result = collector.toCollection();
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/QueryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/QueryTest.java
index 3782114..b760d0e 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/QueryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/core/QueryTest.java
@@ -12,14 +12,13 @@ package org.eclipse.equinox.p2.tests.core;
 
 import java.util.*;
 import junit.framework.TestCase;
-import org.eclipse.equinox.internal.provisional.p2.query.Collector;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.*;
 
 /**
  * Tests for the {@link org.eclipse.equinox.internal.provisional.p2.query.Query} class.
  */
 public class QueryTest extends TestCase {
-	static class AnyStringQuery extends Query {
+	static class AnyStringQuery extends MatchQuery {
 		@Override
 		public boolean isMatch(Object candidate) {
 			return candidate instanceof String;
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
index de663a6..a2f3563 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/SPIMetadataRepositoryTest.java
@@ -27,7 +27,7 @@ import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.Inst
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.query.Collector;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
 
 /**
@@ -589,7 +589,7 @@ public class SPIMetadataRepositoryTest extends AbstractProvisioningTest {
 
 	}
 
-	class AllAcceptingQuery extends Query {
+	class AllAcceptingQuery extends MatchQuery {
 		public boolean isMatch(Object candidate) {
 			return true;
 		}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
index 4e98477..d2d3c14 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/publisher/actions/RootIUActionTest.java
@@ -20,6 +20,7 @@ import org.eclipse.equinox.internal.provisional.p2.core.Version;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IRequiredCapability;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 import org.eclipse.equinox.internal.provisional.p2.query.Query;
 import org.eclipse.equinox.p2.publisher.IPublisherResult;
 import org.eclipse.equinox.p2.publisher.actions.*;
@@ -231,7 +232,7 @@ public class RootIUActionTest extends ActionTest {
 		Query query = null;
 		rootIUAdviceCollection = new ArrayList();
 		if ((testSpec & CONTAINS_A) > 0) {
-			query = new Query() {
+			query = new MatchQuery() {
 				public boolean isMatch(Object candidate) {
 					if (candidate instanceof IInstallableUnit)
 						if (((IInstallableUnit) candidate).getId().equals(iu_A))
@@ -242,7 +243,7 @@ public class RootIUActionTest extends ActionTest {
 			rootIUAdviceCollection.add(new RootIUResultFilterAdvice(query));
 		}
 		if ((testSpec & CONTAINS_B) > 0) {
-			query = new Query() {
+			query = new MatchQuery() {
 				public boolean isMatch(Object candidate) {
 					if (candidate instanceof IInstallableUnit)
 						if (((IInstallableUnit) candidate).getId().equals(iu_B))
@@ -253,7 +254,7 @@ public class RootIUActionTest extends ActionTest {
 			rootIUAdviceCollection.add(new RootIUResultFilterAdvice(query));
 		}
 		if ((testSpec & EMPTY) > 0) {
-			query = new Query() {
+			query = new MatchQuery() {
 				public boolean isMatch(Object candidate) {
 					return false;
 				}
diff --git a/bundles/org.eclipse.equinox.p2.tools/src/org/eclipse/equinox/internal/p2/tools/mirror/RangeQuery.java b/bundles/org.eclipse.equinox.p2.tools/src/org/eclipse/equinox/internal/p2/tools/mirror/RangeQuery.java
index 468a402..4f967e1 100644
--- a/bundles/org.eclipse.equinox.p2.tools/src/org/eclipse/equinox/internal/p2/tools/mirror/RangeQuery.java
+++ b/bundles/org.eclipse.equinox.p2.tools/src/org/eclipse/equinox/internal/p2/tools/mirror/RangeQuery.java
@@ -11,13 +11,13 @@
 package org.eclipse.equinox.internal.p2.tools.mirror;
 
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 
 /**
  * A convenience query that will match any {@link IInstallableUnit}
  * it encounters.
  */
-public class RangeQuery extends Query {
+public class RangeQuery extends MatchQuery {
 	private VersionRangedName[] targets;
 
 	/**
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
index 53e9fcc..cc84362 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
@@ -19,6 +19,7 @@ import org.eclipse.equinox.internal.provisional.p2.engine.IProfileRegistry;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.internal.provisional.p2.metadata.query.IUPropertyQuery;
 import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import org.eclipse.equinox.internal.provisional.p2.query.ContextQuery;
 import org.eclipse.equinox.internal.provisional.p2.query.Query;
 import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker;
 import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener;
@@ -55,14 +56,17 @@ public class AutomaticUpdateScheduler implements IStartup {
 	 * this query to the automatic update checker and it will be referenced during
 	 * the life of the platform.  
 	 */
-	private class IUProfilePropertyByIdQuery extends IUPropertyQuery {
+	private class IUProfilePropertyByIdQuery extends ContextQuery {
 		private IProfile cachedProfile;
+		private String propertyName;
+		private String propertyValue;
 
 		/**
 		 * Creates a new query on the given property name and value.
 		 */
 		public IUProfilePropertyByIdQuery(String propertyName, String propertyValue) {
-			super(propertyName, propertyValue);
+			this.propertyName = propertyName;
+			this.propertyValue = propertyValue;
 		}
 
 		protected String getProperty(IInstallableUnit iu, String name) {
@@ -81,10 +85,31 @@ public class AutomaticUpdateScheduler implements IStartup {
 			return cachedProfile;
 		}
 
+		/* (non-Javadoc)
+		 * @see org.eclipse.equinox.p2.query2.Query#isMatch(java.lang.Object)
+		 */
+		public boolean isMatch(Object object) {
+			if (!(object instanceof IInstallableUnit))
+				return false;
+			IInstallableUnit candidate = (IInstallableUnit) object;
+			if (propertyName == null)
+				return true;
+			String value = getProperty(candidate, propertyName);
+			if (value != null
+					&& (value.equals(propertyValue) || propertyValue == null))
+				return true;
+			return false;
+		}
+		
 		public Collector perform(Iterator iterator, Collector result) {
-			Collector collector = super.perform(iterator, result);
+			while (iterator.hasNext()) {
+				Object candidate = iterator.next();
+				if (isMatch(candidate))
+					if (!result.accept(candidate))
+						break;
+			}
 			cachedProfile = null;
-			return collector;
+			return result;
 		}
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/DefaultQueryProvider.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/DefaultQueryProvider.java
index d550436..ab2a36d 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/DefaultQueryProvider.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/DefaultQueryProvider.java
@@ -37,7 +37,7 @@ public class DefaultQueryProvider extends QueryProvider {
 
 	private Policy policy;
 
-	private Query allQuery = new Query() {
+	private Query allQuery = new MatchQuery() {
 		public boolean isMatch(Object candidate) {
 			return true;
 		}
@@ -122,7 +122,7 @@ public class DefaultQueryProvider extends QueryProvider {
 					if (element instanceof CategoryElement)
 						return new ElementQueryDescriptor(queryable, meetsAnyRequirementQuery, availableIUCollector);
 					// If it's not a category, these are generic requirements and should be filtered by the visibility property (topLevelQuery)
-					return new ElementQueryDescriptor(queryable, new CompoundQuery(new Query[] {topLevelQuery, meetsAnyRequirementQuery}, true), availableIUCollector);
+					return new ElementQueryDescriptor(queryable, CompoundQuery.createCompoundQuery(new Query[] {topLevelQuery, meetsAnyRequirementQuery}, true), availableIUCollector);
 				}
 				return null;
 
@@ -159,7 +159,7 @@ public class DefaultQueryProvider extends QueryProvider {
 				if (element instanceof IIUElement && context.getShowInstallChildren()) {
 					Query meetsAnyRequirementQuery = new AnyRequiredCapabilityQuery(((IIUElement) element).getRequirements());
 					Query visibleAsAvailableQuery = new IUPropertyQuery(context.getVisibleAvailableIUProperty(), Boolean.TRUE.toString());
-					return new ElementQueryDescriptor(queryable, new CompoundQuery(new Query[] {visibleAsAvailableQuery, meetsAnyRequirementQuery}, true), new InstalledIUCollector(queryable, element));
+					return new ElementQueryDescriptor(queryable, CompoundQuery.createCompoundQuery(new Query[] {visibleAsAvailableQuery, meetsAnyRequirementQuery}, true), new InstalledIUCollector(queryable, element));
 				}
 				profile = (IProfile) ProvUI.getAdapter(element, IProfile.class);
 				if (profile == null)
@@ -178,7 +178,7 @@ public class DefaultQueryProvider extends QueryProvider {
 
 			case QueryProvider.PROFILES :
 				queryable = new QueryableProfileRegistry();
-				return new ElementQueryDescriptor(queryable, new Query() {
+				return new ElementQueryDescriptor(queryable, new MatchQuery() {
 					public boolean isMatch(Object candidate) {
 						return ProvUI.getAdapter(candidate, IProfile.class) != null;
 					}
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/AnyRequiredCapabilityQuery.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/AnyRequiredCapabilityQuery.java
index 4d4069a..77e3feb 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/AnyRequiredCapabilityQuery.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/AnyRequiredCapabilityQuery.java
@@ -12,13 +12,13 @@ package org.eclipse.equinox.internal.p2.ui.query;
 
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IRequiredCapability;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.query.MatchQuery;
 
 /**
  * A query that searches a repository for all {@link IInstallableUnit} instances that 
  * meet any one of the given capabilities.  
  */
-public class AnyRequiredCapabilityQuery extends Query {
+public class AnyRequiredCapabilityQuery extends MatchQuery {
 	private IRequiredCapability[] requirements;
 
 	/**
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/QueryableProfileRegistry.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/QueryableProfileRegistry.java
index b27fa92..21ab865 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/QueryableProfileRegistry.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/QueryableProfileRegistry.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,9 +7,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.ui.query;
 
+import java.util.Arrays;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.internal.p2.ui.ProvUIActivator;
@@ -34,12 +36,17 @@ public class QueryableProfileRegistry implements IQueryable {
 		IProfile[] profiles = profileRegistry.getProfiles();
 		SubMonitor sub = SubMonitor.convert(monitor, ProvUIMessages.QueryableProfileRegistry_QueryProfileProgress, profiles.length);
 		try {
-			for (int i = 0; i < profiles.length; i++) {
-				if (query.isMatch(profiles[i]))
-					if (!result.accept(profiles[i]))
-						break;
-				sub.worked(1);
-			}
+			if (query instanceof IMatchQuery) {
+				IMatchQuery isMatchQuery = (IMatchQuery) query;
+				for (int i = 0; i < profiles.length; i++) {
+					if (isMatchQuery.isMatch(profiles[i]))
+						if (!result.accept(profiles[i]))
+							break;
+					sub.worked(1);
+				}
+			} else
+				query.perform(Arrays.asList(profiles).iterator(), result);
+
 		} finally {
 			sub.done();
 		}
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/QueryableUpdates.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/QueryableUpdates.java
index db34a51..644553f 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/QueryableUpdates.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/query/QueryableUpdates.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
+ * Copyright (c) 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.ui.query;
 
@@ -52,14 +53,19 @@ public class QueryableUpdates implements IQueryable {
 				for (int j = 0; j < updates.length; j++)
 					allUpdates.add(updates[j]);
 			}
-			for (int i = 0; i < allUpdates.size(); i++) {
-				if (monitor.isCanceled())
-					return result;
-				if (query.isMatch(allUpdates.get(i)))
-					if (!result.accept(allUpdates.get(i)))
-						break;
-				monitor.worked(totalWork / 2 / allUpdates.size());
-			}
+			if (query instanceof IMatchQuery) {
+				IMatchQuery isMatchQuery = (IMatchQuery) query;
+				for (int i = 0; i < allUpdates.size(); i++) {
+					if (monitor.isCanceled())
+						return result;
+					if (isMatchQuery.isMatch(allUpdates.get(i)))
+						if (!result.accept(allUpdates.get(i)))
+							break;
+					monitor.worked(totalWork / 2 / allUpdates.size());
+				}
+			} else
+				query.perform(allUpdates.iterator(), result);
+
 		} catch (OperationCanceledException e) {
 			// Nothing more to do, return result
 		} finally {
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/QueryableArtifactRepositoryManager.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/QueryableArtifactRepositoryManager.java
index 6258509..40e5f33 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/QueryableArtifactRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/QueryableArtifactRepositoryManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * Copyright (c) 2007, 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,10 +7,12 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     EclipseSource - ongoing development
  *******************************************************************************/
 package org.eclipse.equinox.internal.provisional.p2.ui;
 
 import java.net.URI;
+import java.util.Arrays;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.internal.p2.ui.ProvUIActivator;
@@ -62,12 +64,17 @@ public class QueryableArtifactRepositoryManager implements IQueryable {
 		if (monitor == null)
 			monitor = new NullProgressMonitor();
 		monitor.beginTask(ProvUIMessages.QueryableArtifactRepositoryManager_RepositoryQueryProgress, repoLocations.length);
-		for (int i = 0; i < repoLocations.length; i++) {
-			if (query == null || query.isMatch(repoLocations[i]))
-				if (!result.accept(repoLocations[i]))
-					break;
-			monitor.worked(1);
-		}
+		if (query instanceof IMatchQuery) {
+			IMatchQuery isMatchQuery = (IMatchQuery) query;
+			for (int i = 0; i < repoLocations.length; i++) {
+				if (isMatchQuery == null || isMatchQuery.isMatch(repoLocations[i]))
+					if (!result.accept(repoLocations[i]))
+						break;
+				monitor.worked(1);
+			}
+		} else
+			query.perform(Arrays.asList(repoLocations).iterator(), result);
+
 		monitor.done();
 		return result;
 	}
