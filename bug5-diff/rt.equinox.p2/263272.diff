commit cb2471d74d0fc641df5bc1d1c251f752a376b506
Author: Andrew Niefer <aniefer>
Date:   Mon Feb 23 16:55:10 2009 +0000

    bug 263272 - jar comparator

7	0	bundles/org.eclipse.equinox.p2.repository.tools/plugin.xml
90	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Annotation.java
60	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationComponent.java
277	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationComponentValue.java
35	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationDefaultAttribute.java
142	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AttributeNamesConstants.java
602	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CharOperation.java
47	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileAttribute.java
468	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileReader.java
82	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileStruct.java
59	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFormatException.java
1114	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CodeAttribute.java
104	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPool.java
39	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolConstant.java
396	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolEntry.java
37	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantValueAttribute.java
2071	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/DefaultBytecodeVisitor.java
1138	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Disassembler.java
101	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/EnclosingMethodAttribute.java
61	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionAttribute.java
70	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionTableEntry.java
170	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/FieldInfo.java
104	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/IModifierConstants.java
220	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/IOpcodeMnemonics.java
56	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttribute.java
100	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttributeEntry.java
222	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/JarComparator.java
114	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Messages.java
213	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/MethodInfo.java
222	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/OpcodeStringValues.java
63	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ParameterAnnotation.java
56	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeInvisibleAnnotationsAttribute.java
56	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeInvisibleParameterAnnotationsAttribute.java
56	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeVisibleAnnotationsAttribute.java
56	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeVisibleParameterAnnotationsAttribute.java
1163	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Signature.java
42	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SignatureAttribute.java
49	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SourceFileAttribute.java
153	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/TypeConstants.java
681	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Utility.java
105	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/messages.properties
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/plugin.xml b/bundles/org.eclipse.equinox.p2.repository.tools/plugin.xml
index 2399269..77627fb 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/plugin.xml
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/plugin.xml
@@ -31,5 +31,12 @@
       </application>
    </extension>
 
+	<extension
+    	point="org.eclipse.equinox.p2.artifact.repository.artifactComparators">
+		<artifactComparator
+			class="org.eclipse.equinox.p2.internal.repository.comparator.JarComparator"
+			id="org.eclipse.equinox.p2.repository.tools.jar.comparator">
+		</artifactComparator>
+	</extension>
 
 </plugin>
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Annotation.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Annotation.java
new file mode 100644
index 0000000..2771ea6
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Annotation.java
@@ -0,0 +1,90 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class Annotation extends ClassFileStruct {
+
+	private static final AnnotationComponent[] NO_ENTRIES = new AnnotationComponent[0];
+
+	private int typeIndex;
+	private char[] typeName;
+	private int componentsNumber;
+	private AnnotationComponent[] components;
+	private int readOffset;
+
+	/**
+	 * Constructor for Annotation.
+	 *
+	 * @param classFileBytes
+	 * @param constantPool
+	 * @param offset
+	 * @throws ClassFormatException
+	 */
+	public Annotation(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+
+		final int index = u2At(classFileBytes, 0, offset);
+		this.typeIndex = index;
+		if (index != 0) {
+			ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(index);
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			this.typeName = constantPoolEntry.getUtf8Value();
+		} else {
+			throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+		}
+		final int length = u2At(classFileBytes, 2, offset);
+		this.componentsNumber = length;
+		this.readOffset = 4;
+		if (length != 0) {
+			this.components = new AnnotationComponent[length];
+			for (int i = 0; i < length; i++) {
+				AnnotationComponent component = new AnnotationComponent(classFileBytes, constantPool, offset + this.readOffset);
+				this.components[i] = component;
+				this.readOffset += component.sizeInBytes();
+			}
+		} else {
+			this.components = NO_ENTRIES;
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotation#getTypeIndex()
+	 */
+	public int getTypeIndex() {
+		return this.typeIndex;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotation#getComponentsNumber()
+	 */
+	public int getComponentsNumber() {
+		return this.componentsNumber;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotation#getComponents()
+	 */
+	public AnnotationComponent[] getComponents() {
+		return this.components;
+	}
+
+	int sizeInBytes() {
+		return this.readOffset;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotation#getTypeName()
+	 */
+	public char[] getTypeName() {
+		return this.typeName;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationComponent.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationComponent.java
new file mode 100644
index 0000000..ac83743
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationComponent.java
@@ -0,0 +1,60 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class AnnotationComponent extends ClassFileStruct {
+
+	private int componentNameIndex;
+	private char[] componentName;
+	private AnnotationComponentValue componentValue;
+	private int readOffset;
+
+	public AnnotationComponent(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		final int nameIndex = u2At(classFileBytes, 0, offset);
+		this.componentNameIndex = nameIndex;
+		if (nameIndex != 0) {
+			ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(nameIndex);
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			this.componentName = constantPoolEntry.getUtf8Value();
+		}
+		this.readOffset = 2;
+		AnnotationComponentValue value = new AnnotationComponentValue(classFileBytes, constantPool, offset + this.readOffset);
+		this.componentValue = value;
+		this.readOffset += value.sizeInBytes();
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponent#getComponentNameIndex()
+	 */
+	public int getComponentNameIndex() {
+		return this.componentNameIndex;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponent#getComponentName()
+	 */
+	public char[] getComponentName() {
+		return this.componentName;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponent#getComponentValue()
+	 */
+	public AnnotationComponentValue getComponentValue() {
+		return this.componentValue;
+	}
+
+	int sizeInBytes() {
+		return this.readOffset;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationComponentValue.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationComponentValue.java
new file mode 100644
index 0000000..3866439
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationComponentValue.java
@@ -0,0 +1,277 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class AnnotationComponentValue extends ClassFileStruct {
+	/**
+	 * Tag value for a constant of type <code>byte</code>
+	 * @since 3.1
+	 */
+	public static final int BYTE_TAG = 'B';
+	/**
+	 * Tag value for a constant of type <code>char</code>
+	 * @since 3.1
+	 */
+	public static final int CHAR_TAG = 'C';
+	/**
+	 * Tag value for a constant of type <code>double</code>
+	 * @since 3.1
+	 */
+	public static final int DOUBLE_TAG = 'D';
+	/**
+	 * Tag value for a constant of type <code>float</code>
+	 * @since 3.1
+	 */
+	public static final int FLOAT_TAG = 'F';
+	/**
+	 * Tag value for a constant of type <code>int</code>
+	 * @since 3.1
+	 */
+	public static final int INTEGER_TAG = 'I';
+	/**
+	 * Tag value for a constant of type <code>long</code>
+	 * @since 3.1
+	 */
+	public static final int LONG_TAG = 'J';
+	/**
+	 * Tag value for a constant of type <code>short</code>
+	 * @since 3.1
+	 */
+	public static final int SHORT_TAG = 'S';
+	/**
+	 * Tag value for a constant of type <code>boolean</code>
+	 * @since 3.1
+	 */
+	public static final int BOOLEAN_TAG = 'Z';
+	/**
+	 * Tag value for a constant of type <code>java.lang.String</code>
+	 * @since 3.1
+	 */
+	public static final int STRING_TAG = 's';
+	/**
+	 * Tag value for a value that represents an enum constant
+	 * @since 3.1
+	 */
+	public static final int ENUM_TAG = 'e';
+	/**
+	 * Tag value for a value that represents a class
+	 * @since 3.1
+	 */
+	public static final int CLASS_TAG = 'c';
+	/**
+	 * Tag value for a value that represents an annotation
+	 * @since 3.1
+	 */
+	public static final int ANNOTATION_TAG = '@';
+	/**
+	 * Tag value for a value that represents an array
+	 * @since 3.1
+	 */
+	public static final int ARRAY_TAG = '[';
+
+	private static final AnnotationComponentValue[] NO_VALUES = new AnnotationComponentValue[0];
+
+	private AnnotationComponentValue[] annotationComponentValues;
+	private Annotation annotationValue;
+	private ConstantPoolEntry classInfo;
+	private int classFileInfoIndex;
+	private ConstantPoolEntry constantValue;
+	private int constantValueIndex;
+	private int enumConstantTypeNameIndex;
+	private int enumConstantNameIndex;
+	private char[] enumConstantTypeName;
+	private char[] enumConstantName;
+
+	private int readOffset;
+	private int tag;
+	private int valuesNumber;
+
+	public AnnotationComponentValue(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		this.classFileInfoIndex = -1;
+		this.constantValueIndex = -1;
+		this.enumConstantTypeNameIndex = -1;
+		this.enumConstantNameIndex = -1;
+		final int t = u1At(classFileBytes, 0, offset);
+		this.tag = t;
+		this.readOffset = 1;
+		switch (t) {
+			case 'B' :
+			case 'C' :
+			case 'D' :
+			case 'F' :
+			case 'I' :
+			case 'J' :
+			case 'S' :
+			case 'Z' :
+			case 's' :
+				final int constantIndex = u2At(classFileBytes, this.readOffset, offset);
+				this.constantValueIndex = constantIndex;
+				if (constantIndex != 0) {
+					ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(constantIndex);
+					switch (constantPoolEntry.getKind()) {
+						case ConstantPoolConstant.CONSTANT_Long :
+						case ConstantPoolConstant.CONSTANT_Float :
+						case ConstantPoolConstant.CONSTANT_Double :
+						case ConstantPoolConstant.CONSTANT_Integer :
+						case ConstantPoolConstant.CONSTANT_Utf8 :
+							break;
+						default :
+							throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					this.constantValue = constantPoolEntry;
+				}
+				this.readOffset += 2;
+				break;
+			case 'e' :
+				int index = u2At(classFileBytes, this.readOffset, offset);
+				this.enumConstantTypeNameIndex = index;
+				if (index != 0) {
+					ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					this.enumConstantTypeName = constantPoolEntry.getUtf8Value();
+				}
+				this.readOffset += 2;
+				index = u2At(classFileBytes, this.readOffset, offset);
+				this.enumConstantNameIndex = index;
+				if (index != 0) {
+					ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					this.enumConstantName = constantPoolEntry.getUtf8Value();
+				}
+				this.readOffset += 2;
+				break;
+			case 'c' :
+				final int classFileIndex = u2At(classFileBytes, this.readOffset, offset);
+				this.classFileInfoIndex = classFileIndex;
+				if (classFileIndex != 0) {
+					ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(classFileIndex);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					this.classInfo = constantPoolEntry;
+				}
+				this.readOffset += 2;
+				break;
+			case '@' :
+				Annotation annotation = new Annotation(classFileBytes, constantPool, this.readOffset + offset);
+				this.annotationValue = annotation;
+				this.readOffset += annotation.sizeInBytes();
+				break;
+			case '[' :
+				final int numberOfValues = u2At(classFileBytes, this.readOffset, offset);
+				this.valuesNumber = numberOfValues;
+				this.readOffset += 2;
+				if (numberOfValues != 0) {
+					this.annotationComponentValues = new AnnotationComponentValue[numberOfValues];
+					for (int i = 0; i < numberOfValues; i++) {
+						AnnotationComponentValue value = new AnnotationComponentValue(classFileBytes, constantPool, offset + this.readOffset);
+						this.annotationComponentValues[i] = value;
+						this.readOffset += value.sizeInBytes();
+					}
+				} else {
+					this.annotationComponentValues = NO_VALUES;
+				}
+				break;
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getAnnotationComponentValues()
+	 */
+	public AnnotationComponentValue[] getAnnotationComponentValues() {
+		return this.annotationComponentValues;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getAnnotationValue()
+	 */
+	public Annotation getAnnotationValue() {
+		return this.annotationValue;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getClassInfo()
+	 */
+	public ConstantPoolEntry getClassInfo() {
+		return this.classInfo;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getClassInfoIndex()
+	 */
+	public int getClassInfoIndex() {
+		return this.classFileInfoIndex;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getConstantValue()
+	 */
+	public ConstantPoolEntry getConstantValue() {
+		return this.constantValue;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getConstantValueIndex()
+	 */
+	public int getConstantValueIndex() {
+		return this.constantValueIndex;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getEnumConstantName()
+	 */
+	public char[] getEnumConstantName() {
+		return this.enumConstantName;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getEnumConstantNameIndex()
+	 */
+	public int getEnumConstantNameIndex() {
+		return this.enumConstantNameIndex;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getEnumConstantTypeName()
+	 */
+	public char[] getEnumConstantTypeName() {
+		return this.enumConstantTypeName;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getEnumConstantTypeNameIndex()
+	 */
+	public int getEnumConstantTypeNameIndex() {
+		return this.enumConstantTypeNameIndex;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getTag()
+	 */
+	public int getTag() {
+		return this.tag;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationComponentValue#getValuesNumber()
+	 */
+	public int getValuesNumber() {
+		return this.valuesNumber;
+	}
+
+	int sizeInBytes() {
+		return this.readOffset;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationDefaultAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationDefaultAttribute.java
new file mode 100644
index 0000000..a52692c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AnnotationDefaultAttribute.java
@@ -0,0 +1,35 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class AnnotationDefaultAttribute extends ClassFileAttribute {
+
+	private AnnotationComponentValue memberValue;
+
+	/**
+	 * Constructor for AnnotationDefaultAttribute.
+	 * @param classFileBytes
+	 * @param constantPool
+	 * @param offset
+	 * @throws ClassFormatException
+	 */
+	public AnnotationDefaultAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		this.memberValue = new AnnotationComponentValue(classFileBytes, constantPool, offset + 6);
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IAnnotationDefaultAttribute#getMemberValue()
+	 */
+	public AnnotationComponentValue getMemberValue() {
+		return this.memberValue;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AttributeNamesConstants.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AttributeNamesConstants.java
new file mode 100644
index 0000000..af9859f
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AttributeNamesConstants.java
@@ -0,0 +1,142 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public interface AttributeNamesConstants {
+	/**
+	 * "Synthetic" attribute.
+	 * <p>Note that prior to JDK 1.5, synthetic elements were always marked
+	 * using an attribute; with 1.5, synthetic elements can also be marked
+	 * using the {@link IModifierConstants#ACC_SYNTHETIC} flag.
+	 * </p>
+	 * @since 2.0
+	 */
+	char[] SYNTHETIC = "Synthetic".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "ConstantValue" attribute.
+	 * @since 2.0
+	 */
+	char[] CONSTANT_VALUE = "ConstantValue".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "LineNumberTable" attribute.
+	 * @since 2.0
+	 */
+	char[] LINE_NUMBER = "LineNumberTable".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "LocalVariableTable" attribute.
+	 * @since 2.0
+	 */
+	char[] LOCAL_VARIABLE = "LocalVariableTable".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "InnerClasses" attribute.
+	 * @since 2.0
+	 */
+	char[] INNER_CLASSES = "InnerClasses".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "Code" attribute.
+	 * @since 2.0
+	 */
+	char[] CODE = "Code".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "Exceptions" attribute.
+	 * @since 2.0
+	 */
+	char[] EXCEPTIONS = "Exceptions".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "SourceFile" attribute.
+	 * @since 2.0
+	 */
+	char[] SOURCE = "SourceFile".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "Deprecated" attribute.
+	 * @since 2.0
+	 */
+	char[] DEPRECATED = "Deprecated".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "Signature" attribute (added in J2SE 1.5).
+	 * Class file readers which support J2SE 1.5 return
+	 * attributes with this name represented by objects
+	 * implementing {@link ISignatureAttribute}.
+	 * @since 3.0
+	 */
+	char[] SIGNATURE = "Signature".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "EnclosingMethod" attribute (added in J2SE 1.5).
+	 * Class file readers which support J2SE 1.5 return
+	 * attributes with this name represented by objects
+	 * implementing {@link IEnclosingMethodAttribute}.
+	 * @since 3.0
+	 */
+	char[] ENCLOSING_METHOD = "EnclosingMethod".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "LocalVariableTypeTable" attribute (added in J2SE 1.5).
+	 * @since 3.0
+	 */
+	char[] LOCAL_VARIABLE_TYPE_TABLE = "LocalVariableTypeTable".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "RuntimeVisibleAnnotations" attribute (added in J2SE 1.5).
+	 * @since 3.0
+	 */
+	char[] RUNTIME_VISIBLE_ANNOTATIONS = "RuntimeVisibleAnnotations".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "RuntimeInvisibleAnnotations" attribute (added in J2SE 1.5).
+	 * @since 3.0
+	 */
+	char[] RUNTIME_INVISIBLE_ANNOTATIONS = "RuntimeInvisibleAnnotations".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "RuntimeVisibleParameterAnnotations" attribute (added in J2SE 1.5).
+	 * @since 3.0
+	 */
+	char[] RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = "RuntimeVisibleParameterAnnotations".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "RuntimeInvisibleParameterAnnotations" attribute (added in J2SE 1.5).
+	 * @since 3.0
+	 */
+	char[] RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = "RuntimeInvisibleParameterAnnotations".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "AnnotationDefault" attribute (added in J2SE 1.5).
+	 * @since 3.0
+	 */
+	char[] ANNOTATION_DEFAULT = "AnnotationDefault".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "StackMapTable" attribute (added in J2SE 1.6).
+	 * @since 3.2
+	 */
+	char[] STACK_MAP_TABLE = "StackMapTable".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "StackMap" attribute (added in cldc1.0).
+	 * @since 3.2
+	 */
+	char[] STACK_MAP = "StackMap".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "Varargs" attribute (unspecified).
+	 */
+	char[] VAR_ARGS = "Varargs".toCharArray(); //$NON-NLS-1$
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CharOperation.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CharOperation.java
new file mode 100644
index 0000000..2f1ae4d
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CharOperation.java
@@ -0,0 +1,602 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public final class CharOperation {
+	public static final char[] This = "this".toCharArray(); //$NON-NLS-1$
+
+	public static final char[] JAVA_LANG_ANNOTATION_DOCUMENTED = "Ljava/lang/annotation/Documented;".toCharArray(); //$NON-NLS-1$
+	public static final char[] JAVA_LANG_ANNOTATION_ELEMENTTYPE = "Ljava/lang/annotation/ElementType;".toCharArray(); //$NON-NLS-1$
+	public static final char[] JAVA_LANG_ANNOTATION_RETENTION = "Ljava/lang/annotation/Retention;".toCharArray(); //$NON-NLS-1$
+	public static final char[] JAVA_LANG_ANNOTATION_RETENTIONPOLICY = "Ljava/lang/annotation/RetentionPolicy;".toCharArray(); //$NON-NLS-1$
+	public static final char[] JAVA_LANG_ANNOTATION_TARGET = "Ljava/lang/annotation/Target;".toCharArray(); //$NON-NLS-1$
+	public static final char[] JAVA_LANG_DEPRECATED = "Ljava/lang/Deprecated;".toCharArray(); //$NON-NLS-1$
+	public static final char[] JAVA_LANG_ANNOTATION_INHERITED = "Ljava/lang/annotation/Inherited;".toCharArray(); //$NON-NLS-1$
+	/**
+	 * Constant for an empty char array
+	 */
+	public static final char[] NO_CHAR = new char[0];
+
+	/**
+	 * Constant for an empty char array with two dimensions.
+	 */
+	public static final char[][] NO_CHAR_CHAR = new char[0][];
+
+	/**
+	 * Answers a hashcode for the array
+	 *
+	 * @param array the array for which a hashcode is required
+	 * @return the hashcode
+	 * @throws NullPointerException if array is null
+	 */
+	public static final int hashCode(char[] array) {
+		int length = array.length;
+		int hash = length == 0 ? 31 : array[0];
+		if (length < 8) {
+			for (int i = length; --i > 0;)
+				hash = (hash * 31) + array[i];
+		} else {
+			// 8 characters is enough to compute a decent hash code, don't waste time examining every character
+			for (int i = length - 1, last = i > 16 ? i - 16 : 0; i > last; i -= 2)
+				hash = (hash * 31) + array[i];
+		}
+		return hash & 0x7FFFFFFF;
+	}
+
+	/**
+	 * Answers the last index in the array for which the corresponding character is
+	 * equal to toBeFound starting from the end of the array.
+	 * Answers -1 if no occurrence of this character is found.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    toBeFound = 'c'
+	 *    array = { ' a', 'b', 'c', 'd' , 'c', 'e' }
+	 *    result => 4
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    toBeFound = 'e'
+	 *    array = { ' a', 'b', 'c', 'd' }
+	 *    result => -1
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param toBeFound the character to search
+	 * @param array the array to be searched
+	 * @return the last index in the array for which the corresponding character is
+	 * equal to toBeFound starting from the end of the array, -1 otherwise
+	 * @throws NullPointerException if array is null
+	 */
+	public static final int lastIndexOf(char toBeFound, char[] array) {
+		for (int i = array.length; --i >= 0;)
+			if (toBeFound == array[i])
+				return i;
+		return -1;
+	}
+
+	/**
+	 * Return a new array which is the split of the given array using the given divider.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    divider = 'b'
+	 *    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
+	 *    result => { { 'a' }, {  }, { 'a' }, { 'a' } }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    divider = 'c'
+	 *    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
+	 *    result => { { 'a', 'b', 'b', 'a', 'b', 'a' } }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    divider = 'c'
+	 *    array = { ' ', ' ', 'a' , 'b', 'b', 'a', 'b', 'a', ' ' }
+	 *    result => { { ' ', 'a', 'b', 'b', 'a', 'b', 'a', ' ' } }
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param divider the given divider
+	 * @param array the given array
+	 * @return a new array which is the split of the given array using the given divider
+	 */
+	public static final char[][] splitOn(char divider, char[] array) {
+		int length = array == null ? 0 : array.length;
+		if (length == 0)
+			return NO_CHAR_CHAR;
+
+		int wordCount = 1;
+		for (int i = 0; i < length; i++)
+			if (array[i] == divider)
+				wordCount++;
+		char[][] split = new char[wordCount][];
+		int last = 0, currentWord = 0;
+		for (int i = 0; i < length; i++) {
+			if (array[i] == divider) {
+				split[currentWord] = new char[i - last];
+				System.arraycopy(array, last, split[currentWord++], 0, i - last);
+				last = i + 1;
+			}
+		}
+		split[currentWord] = new char[length - last];
+		System.arraycopy(array, last, split[currentWord], 0, length - last);
+		return split;
+	}
+
+	/**
+	 * Answers the first index in the array for which the corresponding character is
+	 * equal to toBeFound starting the search at index start.
+	 * Answers -1 if no occurrence of this character is found.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    toBeFound = 'c'
+	 *    array = { ' a', 'b', 'c', 'd' }
+	 *    start = 2
+	 *    result => 2
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    toBeFound = 'c'
+	 *    array = { ' a', 'b', 'c', 'd' }
+	 *    start = 3
+	 *    result => -1
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    toBeFound = 'e'
+	 *    array = { ' a', 'b', 'c', 'd' }
+	 *    start = 1
+	 *    result => -1
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param toBeFound the character to search
+	 * @param array the array to be searched
+	 * @param start the starting index
+	 * @return the first index in the array for which the corresponding character is
+	 * equal to toBeFound, -1 otherwise
+	 * @throws NullPointerException if array is null
+	 * @throws ArrayIndexOutOfBoundsException if  start is lower than 0
+	 */
+	public static final int indexOf(char toBeFound, char[] array, int start) {
+		for (int i = start; i < array.length; i++)
+			if (toBeFound == array[i])
+				return i;
+		return -1;
+	}
+
+	/**
+	 * Answers a new array with prepending the prefix character and appending the suffix
+	 * character at the end of the array. If array is null, it answers a new array containing the
+	 * prefix and the suffix characters.
+	 * <br>
+	 * <br>
+	 * For example:<br>
+	 * <ol>
+	 * <li><pre>
+	 *    prefix = 'a'
+	 *    array = { 'b' }
+	 *    suffix = 'c'
+	 *    => result = { 'a', 'b' , 'c' }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    prefix = 'a'
+	 *    array = null
+	 *    suffix = 'c'
+	 *    => result = { 'a', 'c' }
+	 * </pre></li>
+	 * </ol>
+	 *
+	 * @param prefix the prefix character
+	 * @param array the array that is concatenated with the prefix and suffix characters
+	 * @param suffix the suffix character
+	 * @return the new array
+	 */
+	public static final char[] concat(char prefix, char[] array, char suffix) {
+		if (array == null)
+			return new char[] {prefix, suffix};
+
+		int length = array.length;
+		char[] result = new char[length + 2];
+		result[0] = prefix;
+		System.arraycopy(array, 0, result, 1, length);
+		result[length + 1] = suffix;
+		return result;
+	}
+
+	/**
+	 * Answers the concatenation of the three arrays. It answers null if the three arrays are null.
+	 * If first is null, it answers the concatenation of second and third.
+	 * If second is null, it answers the concatenation of first and third.
+	 * If third is null, it answers the concatenation of first and second.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    first = null
+	 *    second = { 'a' }
+	 *    third = { 'b' }
+	 *    => result = { ' a', 'b' }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    first = { 'a' }
+	 *    second = null
+	 *    third = { 'b' }
+	 *    => result = { ' a', 'b' }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    first = { 'a' }
+	 *    second = { 'b' }
+	 *    third = null
+	 *    => result = { ' a', 'b' }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    first = null
+	 *    second = null
+	 *    third = null
+	 *    => result = null
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    first = { 'a' }
+	 *    second = { 'b' }
+	 *    third = { 'c' }
+	 *    => result = { 'a', 'b', 'c' }
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param first the first array to concatenate
+	 * @param second the second array to concatenate
+	 * @param third the third array to concatenate
+	 *
+	 * @return the concatenation of the three arrays, or null if the three arrays are null.
+	 */
+	public static final char[] concat(char[] first, char[] second, char[] third) {
+		if (first == null)
+			return concat(second, third);
+		if (second == null)
+			return concat(first, third);
+		if (third == null)
+			return concat(first, second);
+
+		int length1 = first.length;
+		int length2 = second.length;
+		int length3 = third.length;
+		char[] result = new char[length1 + length2 + length3];
+		System.arraycopy(first, 0, result, 0, length1);
+		System.arraycopy(second, 0, result, length1, length2);
+		System.arraycopy(third, 0, result, length1 + length2, length3);
+		return result;
+	}
+
+	/**
+	 * Answers the concatenation of the two arrays. It answers null if the two arrays are null.
+	 * If the first array is null, then the second array is returned.
+	 * If the second array is null, then the first array is returned.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    first = null
+	 *    second = { 'a' }
+	 *    => result = { ' a' }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    first = { ' a' }
+	 *    second = null
+	 *    => result = { ' a' }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    first = { ' a' }
+	 *    second = { ' b' }
+	 *    => result = { ' a' , ' b' }
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param first the first array to concatenate
+	 * @param second the second array to concatenate
+	 * @return the concatenation of the two arrays, or null if the two arrays are null.
+	 */
+	public static final char[] concat(char[] first, char[] second) {
+		if (first == null)
+			return second;
+		if (second == null)
+			return first;
+
+		int length1 = first.length;
+		int length2 = second.length;
+		char[] result = new char[length1 + length2];
+		System.arraycopy(first, 0, result, 0, length1);
+		System.arraycopy(second, 0, result, length1, length2);
+		return result;
+	}
+
+	/**
+	 * Replace all occurrence of the character to be replaced with the replacement character in the
+	 * given array.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
+	 *    toBeReplaced = 'b'
+	 *    replacementChar = 'a'
+	 *    result => No returned value, but array is now equals to { 'a' , 'a', 'a', 'a', 'a', 'a' }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
+	 *    toBeReplaced = 'c'
+	 *    replacementChar = 'a'
+	 *    result => No returned value, but array is now equals to { 'a' , 'b', 'b', 'a', 'b', 'a' }
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param array the given array
+	 * @param toBeReplaced the character to be replaced
+	 * @param replacementChar the replacement character
+	 * @throws NullPointerException if the given array is null
+	 */
+	public static final void replace(char[] array, char toBeReplaced, char replacementChar) {
+		if (toBeReplaced != replacementChar) {
+			for (int i = 0, max = array.length; i < max; i++) {
+				if (array[i] == toBeReplaced)
+					array[i] = replacementChar;
+			}
+		}
+	}
+
+	/**
+	 * Replace all occurrence of the character to be replaced with the replacement character
+	 * in a copy of the given array. Returns the given array if no occurrences of the character
+	 * to be replaced are found.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
+	 *    toBeReplaced = 'b'
+	 *    replacementChar = 'a'
+	 *    result => A new array that is equals to { 'a' , 'a', 'a', 'a', 'a', 'a' }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
+	 *    toBeReplaced = 'c'
+	 *    replacementChar = 'a'
+	 *    result => The original array that remains unchanged.
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param array the given array
+	 * @param toBeReplaced the character to be replaced
+	 * @param replacementChar the replacement character
+	 * @throws NullPointerException if the given array is null
+	 * @since 3.1
+	 */
+	public static final char[] replaceOnCopy(char[] array, char toBeReplaced, char replacementChar) {
+
+		char[] result = null;
+		for (int i = 0, length = array.length; i < length; i++) {
+			char c = array[i];
+			if (c == toBeReplaced) {
+				if (result == null) {
+					result = new char[length];
+					System.arraycopy(array, 0, result, 0, i);
+				}
+				result[i] = replacementChar;
+			} else if (result != null) {
+				result[i] = c;
+			}
+		}
+		if (result == null)
+			return array;
+		return result;
+	}
+
+	/**
+	 * Answers the first index in the array for which the corresponding character is
+	 * equal to toBeFound. Answers -1 if no occurrence of this character is found.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    toBeFound = 'c'
+	 *    array = { ' a', 'b', 'c', 'd' }
+	 *    result => 2
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    toBeFound = 'e'
+	 *    array = { ' a', 'b', 'c', 'd' }
+	 *    result => -1
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param toBeFound the character to search
+	 * @param array the array to be searched
+	 * @return the first index in the array for which the corresponding character is
+	 * equal to toBeFound, -1 otherwise
+	 * @throws NullPointerException if array is null
+	 */
+	public static final int indexOf(char toBeFound, char[] array) {
+		return indexOf(toBeFound, array, 0);
+	}
+
+	/**
+	 * Answers a new array which is a copy of the given array starting at the given start and
+	 * ending at the given end. The given start is inclusive and the given end is exclusive.
+	 * Answers null if start is greater than end, if start is lower than 0 or if end is greater
+	 * than the length of the given array. If end  equals -1, it is converted to the array length.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    array = { 'a' , 'b' }
+	 *    start = 0
+	 *    end = 1
+	 *    result => { 'a' }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    array = { 'a', 'b' }
+	 *    start = 0
+	 *    end = -1
+	 *    result => { 'a' , 'b' }
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param array the given array
+	 * @param start the given starting index
+	 * @param end the given ending index
+	 * @return a new array which is a copy of the given array starting at the given start and
+	 * ending at the given end
+	 * @throws NullPointerException if the given array is null
+	 */
+	public static final char[] subarray(char[] array, int start, int end) {
+		if (end == -1)
+			end = array.length;
+		if (start > end)
+			return null;
+		if (start < 0)
+			return null;
+		if (end > array.length)
+			return null;
+
+		char[] result = new char[end - start];
+		System.arraycopy(array, start, result, 0, end - start);
+		return result;
+	}
+
+	/**
+	 * Answers a new array which is a copy of the given array starting at the given start and
+	 * ending at the given end. The given start is inclusive and the given end is exclusive.
+	 * Answers null if start is greater than end, if start is lower than 0 or if end is greater
+	 * than the length of the given array. If end  equals -1, it is converted to the array length.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    array = { { 'a' } , { 'b' } }
+	 *    start = 0
+	 *    end = 1
+	 *    result => { { 'a' } }
+	 * </pre>
+	 * </li>
+	 * <li><pre>
+	 *    array = { { 'a' } , { 'b' } }
+	 *    start = 0
+	 *    end = -1
+	 *    result => { { 'a' }, { 'b' } }
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param array the given array
+	 * @param start the given starting index
+	 * @param end the given ending index
+	 * @return a new array which is a copy of the given array starting at the given start and
+	 * ending at the given end
+	 * @throws NullPointerException if the given array is null
+	 */
+	public static final char[][] subarray(char[][] array, int start, int end) {
+		if (end == -1)
+			end = array.length;
+		if (start > end)
+			return null;
+		if (start < 0)
+			return null;
+		if (end > array.length)
+			return null;
+
+		char[][] result = new char[end - start][];
+		System.arraycopy(array, start, result, 0, end - start);
+		return result;
+	}
+
+	/**
+	 * Return a new array which is the split of the given array using the given divider. The given end
+	 * is exclusive and the given start is inclusive.
+	 * <br>
+	 * <br>
+	 * For example:
+	 * <ol>
+	 * <li><pre>
+	 *    divider = 'b'
+	 *    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
+	 *    start = 2
+	 *    end = 5
+	 *    result => { {  }, { 'a' }, {  } }
+	 * </pre>
+	 * </li>
+	 * </ol>
+	 *
+	 * @param divider the given divider
+	 * @param array the given array
+	 * @param start the given starting index
+	 * @param end the given ending index
+	 * @return a new array which is the split of the given array using the given divider
+	 * @throws ArrayIndexOutOfBoundsException if start is lower than 0 or end is greater than the array length
+	 */
+	public static final char[][] splitOn(char divider, char[] array, int start, int end) {
+		int length = array == null ? 0 : array.length;
+		if (length == 0 || start > end)
+			return NO_CHAR_CHAR;
+
+		int wordCount = 1;
+		for (int i = start; i < end; i++)
+			if (array[i] == divider)
+				wordCount++;
+		char[][] split = new char[wordCount][];
+		int last = start, currentWord = 0;
+		for (int i = start; i < end; i++) {
+			if (array[i] == divider) {
+				split[currentWord] = new char[i - last];
+				System.arraycopy(array, last, split[currentWord++], 0, i - last);
+				last = i + 1;
+			}
+		}
+		split[currentWord] = new char[end - last];
+		System.arraycopy(array, last, split[currentWord], 0, end - last);
+		return split;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileAttribute.java
new file mode 100644
index 0000000..0c2ad09
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileAttribute.java
@@ -0,0 +1,47 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class ClassFileAttribute extends ClassFileStruct {
+	public static final ClassFileAttribute[] NO_ATTRIBUTES = new ClassFileAttribute[0];
+	private long attributeLength;
+	private int attributeNameIndex;
+	private char[] attributeName;
+
+	public ClassFileAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		this.attributeNameIndex = u2At(classFileBytes, 0, offset);
+		this.attributeLength = u4At(classFileBytes, 2, offset);
+		ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(this.attributeNameIndex);
+		if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+			throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+		}
+		this.attributeName = constantPoolEntry.getUtf8Value();
+	}
+
+	public int getAttributeNameIndex() {
+		return this.attributeNameIndex;
+	}
+
+	/**
+	 * @see IClassFileAttribute#getAttributeName()
+	 */
+	public char[] getAttributeName() {
+		return this.attributeName;
+	}
+
+	/**
+	 * @see IClassFileAttribute#getAttributeLength()
+	 */
+	public long getAttributeLength() {
+		return this.attributeLength;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileReader.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileReader.java
new file mode 100644
index 0000000..497b552
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileReader.java
@@ -0,0 +1,468 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+import java.util.Arrays;
+
+public class ClassFileReader extends ClassFileStruct {
+	/**
+	 * This value should be used to read completely each part of a .class file.
+	 */
+	public static final int ALL = 0xFFFF;
+
+	/**
+	 * This value should be used to read only the constant pool entries of a .class file.
+	 */
+	public static final int CONSTANT_POOL = 0x0001;
+
+	/**
+	 * This value should be used to read the constant pool entries and
+	 * the method infos of a .class file.
+	 */
+	public static final int METHOD_INFOS = 0x0002 + CONSTANT_POOL;
+
+	/**
+	 * This value should be used to read the constant pool entries and
+	 * the field infos of a .class file.
+	 */
+	public static final int FIELD_INFOS = 0x0004 + CONSTANT_POOL;
+
+	/**
+	 * This value should be used to read the constant pool entries and
+	 * the super interface names of a .class file.
+	 */
+	public static final int SUPER_INTERFACES = 0x0008 + CONSTANT_POOL;
+
+	/**
+	 * This value should be used to read the constant pool entries and
+	 * the attributes of a .class file.
+	 */
+	public static final int CLASSFILE_ATTRIBUTES = 0x0010 + CONSTANT_POOL;
+
+	/**
+	 * This value should be used to read the method bodies.
+	 * It has to be used with METHOD_INFOS.
+	 */
+	public static final int METHOD_BODIES = 0x0020;
+
+	/**
+	 * This value should be used to read the whole contents of the .class file except the
+	 * method bodies.
+	 */
+	public static final int ALL_BUT_METHOD_BODIES = ALL & ~METHOD_BODIES;
+
+	private static final FieldInfo[] NO_FIELD_INFOS = new FieldInfo[0];
+	private static final char[][] NO_INTERFACES_NAMES = CharOperation.NO_CHAR_CHAR;
+	private static final MethodInfo[] NO_METHOD_INFOS = new MethodInfo[0];
+	private int accessFlags;
+	private ClassFileAttribute[] attributes;
+	private int attributesCount;
+	private char[] className;
+	private int classNameIndex;
+
+	private ConstantPool constantPool;
+	private FieldInfo[] fields;
+	private int fieldsCount;
+	private InnerClassesAttribute innerClassesAttribute;
+	private int[] interfaceIndexes;
+	private char[][] interfaceNames;
+	private int interfacesCount;
+	private int magicNumber;
+	private int majorVersion;
+	private MethodInfo[] methods;
+	private int methodsCount;
+	private int minorVersion;
+	private SourceFileAttribute sourceFileAttribute;
+	private char[] superclassName;
+	private int superclassNameIndex;
+
+	/**
+	 * Constructor for ClassFileReader.
+	 *
+	 * @param classFileBytes the raw bytes of the .class file
+	 * @param decodingFlags the decoding flags
+	 *
+	 * @see IClassFileReader#ALL
+	 * @see IClassFileReader#CLASSFILE_ATTRIBUTES
+	 * @see IClassFileReader#CONSTANT_POOL
+	 * @see IClassFileReader#FIELD_INFOS
+	 */
+	public ClassFileReader(byte[] classFileBytes, int decodingFlags) throws ClassFormatException {
+
+		// This method looks ugly but is actually quite simple, the constantPool is constructed
+		// in 3 passes.  All non-primitive constant pool members that usually refer to other members
+		// by index are tweaked to have their value in inst vars, this minor cost at read-time makes
+		// all subsequent uses of the constant pool element faster.
+		int constantPoolCount;
+		int[] constantPoolOffsets;
+		try {
+			this.magicNumber = (int) u4At(classFileBytes, 0, 0);
+			if (this.magicNumber != 0xCAFEBABE) {
+				throw new ClassFormatException(ClassFormatException.INVALID_MAGIC_NUMBER);
+			}
+
+			int readOffset = 10;
+			this.minorVersion = u2At(classFileBytes, 4, 0);
+			this.majorVersion = u2At(classFileBytes, 6, 0);
+
+			if ((decodingFlags & CONSTANT_POOL) == 0) {
+				// no need to go further
+				return;
+			}
+
+			constantPoolCount = u2At(classFileBytes, 8, 0);
+			// Pass #1 - Fill in all primitive constants
+			constantPoolOffsets = new int[constantPoolCount];
+			for (int i = 1; i < constantPoolCount; i++) {
+				int tag = u1At(classFileBytes, readOffset, 0);
+				switch (tag) {
+					case ConstantPoolConstant.CONSTANT_Utf8 :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += u2At(classFileBytes, readOffset + 1, 0);
+						readOffset += ConstantPoolConstant.CONSTANT_Utf8_SIZE;
+						break;
+					case ConstantPoolConstant.CONSTANT_Integer :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += ConstantPoolConstant.CONSTANT_Integer_SIZE;
+						break;
+					case ConstantPoolConstant.CONSTANT_Float :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += ConstantPoolConstant.CONSTANT_Float_SIZE;
+						break;
+					case ConstantPoolConstant.CONSTANT_Long :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += ConstantPoolConstant.CONSTANT_Long_SIZE;
+						i++;
+						break;
+					case ConstantPoolConstant.CONSTANT_Double :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += ConstantPoolConstant.CONSTANT_Double_SIZE;
+						i++;
+						break;
+					case ConstantPoolConstant.CONSTANT_Class :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += ConstantPoolConstant.CONSTANT_Class_SIZE;
+						break;
+					case ConstantPoolConstant.CONSTANT_String :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += ConstantPoolConstant.CONSTANT_String_SIZE;
+						break;
+					case ConstantPoolConstant.CONSTANT_Fieldref :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += ConstantPoolConstant.CONSTANT_Fieldref_SIZE;
+						break;
+					case ConstantPoolConstant.CONSTANT_Methodref :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += ConstantPoolConstant.CONSTANT_Methodref_SIZE;
+						break;
+					case ConstantPoolConstant.CONSTANT_InterfaceMethodref :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += ConstantPoolConstant.CONSTANT_InterfaceMethodref_SIZE;
+						break;
+					case ConstantPoolConstant.CONSTANT_NameAndType :
+						constantPoolOffsets[i] = readOffset;
+						readOffset += ConstantPoolConstant.CONSTANT_NameAndType_SIZE;
+						break;
+					default :
+						throw new ClassFormatException(ClassFormatException.INVALID_TAG_CONSTANT);
+				}
+			}
+
+			this.constantPool = new ConstantPool(classFileBytes, constantPoolOffsets);
+			// Read and validate access flags
+			this.accessFlags = u2At(classFileBytes, readOffset, 0);
+			readOffset += 2;
+
+			// Read the classname, use exception handlers to catch bad format
+			this.classNameIndex = u2At(classFileBytes, readOffset, 0);
+			this.className = getConstantClassNameAt(classFileBytes, constantPoolOffsets, this.classNameIndex);
+			readOffset += 2;
+
+			// Read the superclass name, can be zero for java.lang.Object
+			this.superclassNameIndex = u2At(classFileBytes, readOffset, 0);
+			readOffset += 2;
+			// if superclassNameIndex is equals to 0 there is no need to set a value for the
+			// field this.superclassName. null is fine.
+			if (this.superclassNameIndex != 0) {
+				this.superclassName = getConstantClassNameAt(classFileBytes, constantPoolOffsets, this.superclassNameIndex);
+			}
+
+			// Read the interfaces, use exception handlers to catch bad format
+			this.interfacesCount = u2At(classFileBytes, readOffset, 0);
+			readOffset += 2;
+			this.interfaceNames = NO_INTERFACES_NAMES;
+			this.interfaceIndexes = Utility.EMPTY_INT_ARRAY;
+			if (this.interfacesCount != 0) {
+				if ((decodingFlags & SUPER_INTERFACES) != CONSTANT_POOL) {
+					this.interfaceNames = new char[this.interfacesCount][];
+					this.interfaceIndexes = new int[this.interfacesCount];
+					for (int i = 0; i < this.interfacesCount; i++) {
+						this.interfaceIndexes[i] = u2At(classFileBytes, readOffset, 0);
+						this.interfaceNames[i] = getConstantClassNameAt(classFileBytes, constantPoolOffsets, this.interfaceIndexes[i]);
+						readOffset += 2;
+					}
+				} else {
+					readOffset += (2 * this.interfacesCount);
+				}
+			}
+			// Read the this.fields, use exception handlers to catch bad format
+			this.fieldsCount = u2At(classFileBytes, readOffset, 0);
+			readOffset += 2;
+			this.fields = NO_FIELD_INFOS;
+			if (this.fieldsCount != 0) {
+				if ((decodingFlags & FIELD_INFOS) != CONSTANT_POOL) {
+					FieldInfo field;
+					this.fields = new FieldInfo[this.fieldsCount];
+					for (int i = 0; i < this.fieldsCount; i++) {
+						field = new FieldInfo(classFileBytes, this.constantPool, readOffset);
+						this.fields[i] = field;
+						readOffset += field.sizeInBytes();
+					}
+				} else {
+					for (int i = 0; i < this.fieldsCount; i++) {
+						int attributeCountForField = u2At(classFileBytes, 6, readOffset);
+						readOffset += 8;
+						if (attributeCountForField != 0) {
+							for (int j = 0; j < attributeCountForField; j++) {
+								int attributeLength = (int) u4At(classFileBytes, 2, readOffset);
+								readOffset += (6 + attributeLength);
+							}
+						}
+					}
+				}
+			}
+			// Read the this.methods
+			this.methodsCount = u2At(classFileBytes, readOffset, 0);
+			readOffset += 2;
+			this.methods = NO_METHOD_INFOS;
+			if (this.methodsCount != 0) {
+				if ((decodingFlags & METHOD_INFOS) != CONSTANT_POOL) {
+					this.methods = new MethodInfo[this.methodsCount];
+					MethodInfo method;
+					for (int i = 0; i < this.methodsCount; i++) {
+						method = new MethodInfo(classFileBytes, this.constantPool, readOffset, decodingFlags);
+						this.methods[i] = method;
+						readOffset += method.sizeInBytes();
+					}
+				} else {
+					for (int i = 0; i < this.methodsCount; i++) {
+						int attributeCountForMethod = u2At(classFileBytes, 6, readOffset);
+						readOffset += 8;
+						if (attributeCountForMethod != 0) {
+							for (int j = 0; j < attributeCountForMethod; j++) {
+								int attributeLength = (int) u4At(classFileBytes, 2, readOffset);
+								readOffset += (6 + attributeLength);
+							}
+						}
+					}
+				}
+			}
+
+			// Read the attributes
+			this.attributesCount = u2At(classFileBytes, readOffset, 0);
+			readOffset += 2;
+
+			int attributesIndex = 0;
+			this.attributes = ClassFileAttribute.NO_ATTRIBUTES;
+			if (this.attributesCount != 0) {
+				if ((decodingFlags & CLASSFILE_ATTRIBUTES) != CONSTANT_POOL) {
+					this.attributes = new ClassFileAttribute[this.attributesCount];
+					for (int i = 0; i < this.attributesCount; i++) {
+						int utf8Offset = constantPoolOffsets[u2At(classFileBytes, readOffset, 0)];
+						char[] attributeName = utf8At(classFileBytes, utf8Offset + 3, 0, u2At(classFileBytes, utf8Offset + 1, 0));
+						if (Arrays.equals(attributeName, AttributeNamesConstants.INNER_CLASSES)) {
+							this.innerClassesAttribute = new InnerClassesAttribute(classFileBytes, this.constantPool, readOffset);
+							this.attributes[attributesIndex++] = this.innerClassesAttribute;
+						} else if (Arrays.equals(attributeName, AttributeNamesConstants.SOURCE)) {
+							this.sourceFileAttribute = new SourceFileAttribute(classFileBytes, this.constantPool, readOffset);
+							this.attributes[attributesIndex++] = this.sourceFileAttribute;
+						} else if (Arrays.equals(attributeName, AttributeNamesConstants.ENCLOSING_METHOD)) {
+							this.attributes[attributesIndex++] = new EnclosingMethodAttribute(classFileBytes, this.constantPool, readOffset);
+						} else if (Arrays.equals(attributeName, AttributeNamesConstants.SIGNATURE)) {
+							this.attributes[attributesIndex++] = new SignatureAttribute(classFileBytes, this.constantPool, readOffset);
+						} else if (Arrays.equals(attributeName, AttributeNamesConstants.RUNTIME_VISIBLE_ANNOTATIONS)) {
+							this.attributes[attributesIndex++] = new RuntimeVisibleAnnotationsAttribute(classFileBytes, this.constantPool, readOffset);
+						} else if (Arrays.equals(attributeName, AttributeNamesConstants.RUNTIME_INVISIBLE_ANNOTATIONS)) {
+							this.attributes[attributesIndex++] = new RuntimeInvisibleAnnotationsAttribute(classFileBytes, this.constantPool, readOffset);
+						} else {
+							this.attributes[attributesIndex++] = new ClassFileAttribute(classFileBytes, this.constantPool, readOffset);
+						}
+						readOffset += (6 + u4At(classFileBytes, readOffset + 2, 0));
+					}
+				} else {
+					for (int i = 0; i < this.attributesCount; i++) {
+						readOffset += (6 + u4At(classFileBytes, readOffset + 2, 0));
+					}
+				}
+			}
+			if (readOffset != classFileBytes.length) {
+				throw new ClassFormatException(ClassFormatException.TOO_MANY_BYTES);
+			}
+		} catch (ClassFormatException e) {
+			throw e;
+		} catch (Exception e) {
+			e.printStackTrace();
+			throw new ClassFormatException(ClassFormatException.ERROR_TRUNCATED_INPUT);
+		}
+	}
+
+	/**
+	 * @see IClassFileReader#getAccessFlags()
+	 */
+	public int getAccessFlags() {
+		return this.accessFlags;
+	}
+
+	/**
+	 * @see IClassFileReader#getAttributeCount()
+	 */
+	public int getAttributeCount() {
+		return this.attributesCount;
+	}
+
+	/**
+	 * @see IClassFileReader#getAttributes()
+	 */
+	public ClassFileAttribute[] getAttributes() {
+		return this.attributes;
+	}
+
+	/**
+	 * @see IClassFileReader#getClassIndex()
+	 */
+	public int getClassIndex() {
+		return this.classNameIndex;
+	}
+
+	/**
+	 * @see IClassFileReader#getClassName()
+	 */
+	public char[] getClassName() {
+		return this.className;
+	}
+
+	private char[] getConstantClassNameAt(byte[] classFileBytes, int[] constantPoolOffsets, int constantPoolIndex) {
+		int utf8Offset = constantPoolOffsets[u2At(classFileBytes, constantPoolOffsets[constantPoolIndex] + 1, 0)];
+		return utf8At(classFileBytes, utf8Offset + 3, 0, u2At(classFileBytes, utf8Offset + 1, 0));
+	}
+
+	/**
+	 * @see IClassFileReader#getConstantPool()
+	 */
+	public ConstantPool getConstantPool() {
+		return this.constantPool;
+	}
+
+	/**
+	 * @see IClassFileReader#getFieldInfos()
+	 */
+	public FieldInfo[] getFieldInfos() {
+		return this.fields;
+	}
+
+	/**
+	 * @see IClassFileReader#getFieldsCount()
+	 */
+	public int getFieldsCount() {
+		return this.fieldsCount;
+	}
+
+	/**
+	 * @see IClassFileReader#getInnerClassesAttribute()
+	 */
+	public InnerClassesAttribute getInnerClassesAttribute() {
+		return this.innerClassesAttribute;
+	}
+
+	/**
+	 * @see IClassFileReader#getInterfaceIndexes()
+	 */
+	public int[] getInterfaceIndexes() {
+		return this.interfaceIndexes;
+	}
+
+	/**
+	 * @see IClassFileReader#getInterfaceNames()
+	 */
+	public char[][] getInterfaceNames() {
+		return this.interfaceNames;
+	}
+
+	/**
+	 * @see IClassFileReader#getMagic()
+	 */
+	public int getMagic() {
+		return this.magicNumber;
+	}
+
+	/**
+	 * @see IClassFileReader#getMajorVersion()
+	 */
+	public int getMajorVersion() {
+		return this.majorVersion;
+	}
+
+	/**
+	 * @see IClassFileReader#getMethodInfos()
+	 */
+	public MethodInfo[] getMethodInfos() {
+		return this.methods;
+	}
+
+	/**
+	 * @see IClassFileReader#getMethodsCount()
+	 */
+	public int getMethodsCount() {
+		return this.methodsCount;
+	}
+
+	/**
+	 * @see IClassFileReader#getMinorVersion()
+	 */
+	public int getMinorVersion() {
+		return this.minorVersion;
+	}
+
+	/**
+	 * @see IClassFileReader#getSourceFileAttribute()
+	 */
+	public SourceFileAttribute getSourceFileAttribute() {
+		return this.sourceFileAttribute;
+	}
+
+	/**
+	 * @see IClassFileReader#getSuperclassIndex()
+	 */
+	public int getSuperclassIndex() {
+		return this.superclassNameIndex;
+	}
+
+	/**
+	 * @see IClassFileReader#getSuperclassName()
+	 */
+	public char[] getSuperclassName() {
+		return this.superclassName;
+	}
+
+	/**
+	 * @see IClassFileReader#isClass()
+	 */
+	public boolean isClass() {
+		return !isInterface();
+	}
+
+	/**
+	 * @see IClassFileReader#isInterface()
+	 */
+	public boolean isInterface() {
+		return (getAccessFlags() & IModifierConstants.ACC_INTERFACE) != 0;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileStruct.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileStruct.java
new file mode 100644
index 0000000..a8c6038
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileStruct.java
@@ -0,0 +1,82 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public abstract class ClassFileStruct {
+
+	protected double doubleAt(byte[] reference, int relativeOffset, int structOffset) {
+		return (Double.longBitsToDouble(i8At(reference, relativeOffset, structOffset)));
+	}
+
+	protected float floatAt(byte[] reference, int relativeOffset, int structOffset) {
+		return (Float.intBitsToFloat(i4At(reference, relativeOffset, structOffset)));
+	}
+
+	protected int i1At(byte[] reference, int relativeOffset, int structOffset) {
+		return reference[relativeOffset + structOffset];
+	}
+
+	protected int i2At(byte[] reference, int relativeOffset, int structOffset) {
+		int position = relativeOffset + structOffset;
+		return (reference[position++] << 8) + (reference[position] & 0xFF);
+	}
+
+	protected int i4At(byte[] reference, int relativeOffset, int structOffset) {
+		int position = relativeOffset + structOffset;
+		return ((reference[position++] & 0xFF) << 24) + ((reference[position++] & 0xFF) << 16) + ((reference[position++] & 0xFF) << 8) + (reference[position] & 0xFF);
+	}
+
+	protected long i8At(byte[] reference, int relativeOffset, int structOffset) {
+		int position = relativeOffset + structOffset;
+		return (((long) (reference[position++] & 0xFF)) << 56) + (((long) (reference[position++] & 0xFF)) << 48) + (((long) (reference[position++] & 0xFF)) << 40) + (((long) (reference[position++] & 0xFF)) << 32) + (((long) (reference[position++] & 0xFF)) << 24) + (((long) (reference[position++] & 0xFF)) << 16) + (((long) (reference[position++] & 0xFF)) << 8) + (reference[position++] & 0xFF);
+	}
+
+	protected int u1At(byte[] reference, int relativeOffset, int structOffset) {
+		return (reference[relativeOffset + structOffset] & 0xFF);
+	}
+
+	protected int u2At(byte[] reference, int relativeOffset, int structOffset) {
+		int position = relativeOffset + structOffset;
+		return ((reference[position++] & 0xFF) << 8) + (reference[position] & 0xFF);
+	}
+
+	protected long u4At(byte[] reference, int relativeOffset, int structOffset) {
+		int position = relativeOffset + structOffset;
+		return (((reference[position++] & 0xFFL) << 24) + ((reference[position++] & 0xFF) << 16) + ((reference[position++] & 0xFF) << 8) + (reference[position] & 0xFF));
+	}
+
+	protected char[] utf8At(byte[] reference, int relativeOffset, int structOffset, int bytesAvailable) {
+		int length = bytesAvailable;
+		char outputBuf[] = new char[bytesAvailable];
+		int outputPos = 0;
+		int readOffset = structOffset + relativeOffset;
+
+		while (length != 0) {
+			int x = reference[readOffset++] & 0xFF;
+			length--;
+			if ((0x80 & x) != 0) {
+				if ((x & 0x20) != 0) {
+					length -= 2;
+					x = ((x & 0xF) << 12) + ((reference[readOffset++] & 0x3F) << 6) + (reference[readOffset++] & 0x3F);
+				} else {
+					length--;
+					x = ((x & 0x1F) << 6) + (reference[readOffset++] & 0x3F);
+				}
+			}
+			outputBuf[outputPos++] = (char) x;
+		}
+
+		if (outputPos != bytesAvailable) {
+			System.arraycopy(outputBuf, 0, (outputBuf = new char[outputPos]), 0, outputPos);
+		}
+		return outputBuf;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFormatException.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFormatException.java
new file mode 100644
index 0000000..acff39c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFormatException.java
@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class ClassFormatException extends Exception {
+
+	public static final int ERROR_MALFORMED_UTF8 = 1;
+	public static final int ERROR_TRUNCATED_INPUT = 2;
+	public static final int INVALID_CONSTANT_POOL_ENTRY = 3;
+	public static final int TOO_MANY_BYTES = 4;
+	public static final int INVALID_ARGUMENTS_FOR_INVOKEINTERFACE = 5;
+	public static final int INVALID_BYTECODE = 6;
+
+	/**
+	 * @since 3.0
+	 */
+	public static final int INVALID_TAG_CONSTANT = 7;
+
+	/**
+	 * @since 3.0
+	 */
+	public static final int INVALID_MAGIC_NUMBER = 8;
+
+	private static final long serialVersionUID = 6582900558320612988L; // backward compatible
+
+	/**
+	 * Constructor for ClassFormatException.
+	 * @param errorID the given error ID
+	 */
+	public ClassFormatException(int errorID) {
+		// TODO (olivier) what is the errorID?
+	}
+
+	/**
+	 * Constructor for ClassFormatException.
+	 * @param message the message for the exception
+	 */
+	public ClassFormatException(String message) {
+		super(message);
+	}
+
+	/**
+	 * Constructor for ClassFormatException.
+	 * @param message the message for the exception
+	 * @param  cause  the cause of the exception
+	 * @since 3.5
+	 */
+	public ClassFormatException(String message, Throwable cause) {
+		super(message, cause);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CodeAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CodeAttribute.java
new file mode 100644
index 0000000..74101cb
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CodeAttribute.java
@@ -0,0 +1,1114 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class CodeAttribute extends ClassFileAttribute {
+	private static final ExceptionTableEntry[] NO_EXCEPTION_TABLE = new ExceptionTableEntry[0];
+	private ClassFileAttribute[] attributes;
+	private int attributesCount;
+	private byte[] bytecodes;
+	private byte[] classFileBytes;
+	private long codeLength;
+	private int codeOffset;
+	private ConstantPool constantPool;
+	private ExceptionTableEntry[] exceptionTableEntries;
+	private int exceptionTableLength;
+	private int maxLocals;
+	private int maxStack;
+
+	CodeAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		this.classFileBytes = classFileBytes;
+		this.constantPool = constantPool;
+		this.maxStack = u2At(classFileBytes, 6, offset);
+		this.maxLocals = u2At(classFileBytes, 8, offset);
+		this.codeLength = u4At(classFileBytes, 10, offset);
+		this.codeOffset = offset + 14;
+		int readOffset = (int) (14 + this.codeLength);
+		this.exceptionTableLength = u2At(classFileBytes, readOffset, offset);
+		readOffset += 2;
+		this.exceptionTableEntries = NO_EXCEPTION_TABLE;
+		if (this.exceptionTableLength != 0) {
+			this.exceptionTableEntries = new ExceptionTableEntry[this.exceptionTableLength];
+			for (int i = 0; i < this.exceptionTableLength; i++) {
+				this.exceptionTableEntries[i] = new ExceptionTableEntry(classFileBytes, constantPool, offset + readOffset);
+				readOffset += 8;
+			}
+		}
+		this.attributesCount = u2At(classFileBytes, readOffset, offset);
+		this.attributes = ClassFileAttribute.NO_ATTRIBUTES;
+		if (this.attributesCount != 0) {
+			this.attributes = new ClassFileAttribute[this.attributesCount];
+		}
+		readOffset += 2;
+		for (int i = 0; i < this.attributesCount; i++) {
+			ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(u2At(classFileBytes, readOffset, offset));
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			readOffset += (6 + u4At(classFileBytes, readOffset + 2, offset));
+		}
+	}
+
+	/**
+	 * @see ICodeAttribute#getAttributes()
+	 */
+	public ClassFileAttribute[] getAttributes() {
+		return this.attributes;
+	}
+
+	/**
+	 * @see ICodeAttribute#getAttributesCount()
+	 */
+	public int getAttributesCount() {
+		return this.attributesCount;
+	}
+
+	/**
+	 * @see ICodeAttribute#getBytecodes()
+	 */
+	public byte[] getBytecodes() {
+		if (this.bytecodes == null) {
+			System.arraycopy(this.classFileBytes, this.codeOffset, (this.bytecodes = new byte[(int) this.codeLength]), 0, (int) this.codeLength);
+		}
+		return this.bytecodes;
+	}
+
+	/**
+	 * @see ICodeAttribute#getCodeLength()
+	 */
+	public long getCodeLength() {
+		return this.codeLength;
+	}
+
+	/**
+	 * @see ICodeAttribute#getExceptionTable()
+	 */
+	public ExceptionTableEntry[] getExceptionTable() {
+		return this.exceptionTableEntries;
+	}
+
+	/**
+	 * @see ICodeAttribute#getExceptionTableLength()
+	 */
+	public int getExceptionTableLength() {
+		return this.exceptionTableLength;
+	}
+
+	/**
+	 * @see ICodeAttribute#getMaxLocals()
+	 */
+	public int getMaxLocals() {
+		return this.maxLocals;
+	}
+
+	/**
+	 * @see ICodeAttribute#getMaxStack()
+	 */
+	public int getMaxStack() {
+		return this.maxStack;
+	}
+
+	/**
+	 * @see ICodeAttribute#traverse(IBytecodeVisitor visitor)
+	 */
+	public void traverse(DefaultBytecodeVisitor visitor) throws ClassFormatException {
+		int pc = this.codeOffset;
+		int opcode, index, _const, branchOffset;
+		ConstantPoolEntry constantPoolEntry;
+		while (true) {
+			opcode = u1At(this.classFileBytes, 0, pc);
+			switch (opcode) {
+				case IOpcodeMnemonics.NOP :
+					visitor._nop(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ACONST_NULL :
+					visitor._aconst_null(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ICONST_M1 :
+					visitor._iconst_m1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ICONST_0 :
+					visitor._iconst_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ICONST_1 :
+					visitor._iconst_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ICONST_2 :
+					visitor._iconst_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ICONST_3 :
+					visitor._iconst_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ICONST_4 :
+					visitor._iconst_4(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ICONST_5 :
+					visitor._iconst_5(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LCONST_0 :
+					visitor._lconst_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LCONST_1 :
+					visitor._lconst_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FCONST_0 :
+					visitor._fconst_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FCONST_1 :
+					visitor._fconst_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FCONST_2 :
+					visitor._fconst_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DCONST_0 :
+					visitor._dconst_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DCONST_1 :
+					visitor._dconst_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.BIPUSH :
+					visitor._bipush(pc - this.codeOffset, (byte) i1At(this.classFileBytes, 1, pc));
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.SIPUSH :
+					visitor._sipush(pc - this.codeOffset, (short) i2At(this.classFileBytes, 1, pc));
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.LDC :
+					index = u1At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Float && constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Integer && constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_String && constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._ldc(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.LDC_W :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Float && constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Integer && constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_String && constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._ldc_w(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.LDC2_W :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Double && constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Long) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._ldc2_w(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.ILOAD :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._iload(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.LLOAD :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._lload(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.FLOAD :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._fload(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.DLOAD :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._dload(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.ALOAD :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._aload(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.ILOAD_0 :
+					visitor._iload_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ILOAD_1 :
+					visitor._iload_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ILOAD_2 :
+					visitor._iload_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ILOAD_3 :
+					visitor._iload_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LLOAD_0 :
+					visitor._lload_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LLOAD_1 :
+					visitor._lload_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LLOAD_2 :
+					visitor._lload_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LLOAD_3 :
+					visitor._lload_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FLOAD_0 :
+					visitor._fload_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FLOAD_1 :
+					visitor._fload_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FLOAD_2 :
+					visitor._fload_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FLOAD_3 :
+					visitor._fload_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DLOAD_0 :
+					visitor._dload_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DLOAD_1 :
+					visitor._dload_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DLOAD_2 :
+					visitor._dload_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DLOAD_3 :
+					visitor._dload_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ALOAD_0 :
+					visitor._aload_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ALOAD_1 :
+					visitor._aload_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ALOAD_2 :
+					visitor._aload_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ALOAD_3 :
+					visitor._aload_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IALOAD :
+					visitor._iaload(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LALOAD :
+					visitor._laload(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FALOAD :
+					visitor._faload(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DALOAD :
+					visitor._daload(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.AALOAD :
+					visitor._aaload(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.BALOAD :
+					visitor._baload(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.CALOAD :
+					visitor._caload(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.SALOAD :
+					visitor._saload(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ISTORE :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._istore(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.LSTORE :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._lstore(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.FSTORE :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._fstore(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.DSTORE :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._dstore(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.ASTORE :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._astore(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.ISTORE_0 :
+					visitor._istore_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ISTORE_1 :
+					visitor._istore_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ISTORE_2 :
+					visitor._istore_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ISTORE_3 :
+					visitor._istore_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LSTORE_0 :
+					visitor._lstore_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LSTORE_1 :
+					visitor._lstore_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LSTORE_2 :
+					visitor._lstore_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LSTORE_3 :
+					visitor._lstore_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FSTORE_0 :
+					visitor._fstore_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FSTORE_1 :
+					visitor._fstore_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FSTORE_2 :
+					visitor._fstore_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FSTORE_3 :
+					visitor._fstore_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DSTORE_0 :
+					visitor._dstore_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DSTORE_1 :
+					visitor._dstore_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DSTORE_2 :
+					visitor._dstore_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DSTORE_3 :
+					visitor._dstore_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ASTORE_0 :
+					visitor._astore_0(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ASTORE_1 :
+					visitor._astore_1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ASTORE_2 :
+					visitor._astore_2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ASTORE_3 :
+					visitor._astore_3(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IASTORE :
+					visitor._iastore(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LASTORE :
+					visitor._lastore(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FASTORE :
+					visitor._fastore(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DASTORE :
+					visitor._dastore(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.AASTORE :
+					visitor._aastore(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.BASTORE :
+					visitor._bastore(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.CASTORE :
+					visitor._castore(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.SASTORE :
+					visitor._sastore(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.POP :
+					visitor._pop(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.POP2 :
+					visitor._pop2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DUP :
+					visitor._dup(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DUP_X1 :
+					visitor._dup_x1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DUP_X2 :
+					visitor._dup_x2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DUP2 :
+					visitor._dup2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DUP2_X1 :
+					visitor._dup2_x1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DUP2_X2 :
+					visitor._dup2_x2(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.SWAP :
+					visitor._swap(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IADD :
+					visitor._iadd(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LADD :
+					visitor._ladd(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FADD :
+					visitor._fadd(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DADD :
+					visitor._dadd(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ISUB :
+					visitor._isub(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LSUB :
+					visitor._lsub(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FSUB :
+					visitor._fsub(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DSUB :
+					visitor._dsub(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IMUL :
+					visitor._imul(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LMUL :
+					visitor._lmul(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FMUL :
+					visitor._fmul(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DMUL :
+					visitor._dmul(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IDIV :
+					visitor._idiv(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LDIV :
+					visitor._ldiv(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FDIV :
+					visitor._fdiv(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DDIV :
+					visitor._ddiv(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IREM :
+					visitor._irem(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LREM :
+					visitor._lrem(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FREM :
+					visitor._frem(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DREM :
+					visitor._drem(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.INEG :
+					visitor._ineg(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LNEG :
+					visitor._lneg(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FNEG :
+					visitor._fneg(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DNEG :
+					visitor._dneg(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ISHL :
+					visitor._ishl(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LSHL :
+					visitor._lshl(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ISHR :
+					visitor._ishr(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LSHR :
+					visitor._lshr(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IUSHR :
+					visitor._iushr(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LUSHR :
+					visitor._lushr(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IAND :
+					visitor._iand(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LAND :
+					visitor._land(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IOR :
+					visitor._ior(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LOR :
+					visitor._lor(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IXOR :
+					visitor._ixor(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LXOR :
+					visitor._lxor(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IINC :
+					index = u1At(this.classFileBytes, 1, pc);
+					_const = i1At(this.classFileBytes, 2, pc);
+					visitor._iinc(pc - this.codeOffset, index, _const);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.I2L :
+					visitor._i2l(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.I2F :
+					visitor._i2f(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.I2D :
+					visitor._i2d(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.L2I :
+					visitor._l2i(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.L2F :
+					visitor._l2f(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.L2D :
+					visitor._l2d(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.F2I :
+					visitor._f2i(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.F2L :
+					visitor._f2l(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.F2D :
+					visitor._f2d(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.D2I :
+					visitor._d2i(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.D2L :
+					visitor._d2l(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.D2F :
+					visitor._d2f(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.I2B :
+					visitor._i2b(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.I2C :
+					visitor._i2c(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.I2S :
+					visitor._i2s(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LCMP :
+					visitor._lcmp(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FCMPL :
+					visitor._fcmpl(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FCMPG :
+					visitor._fcmpg(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DCMPL :
+					visitor._dcmpl(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DCMPG :
+					visitor._dcmpg(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IFEQ :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._ifeq(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IFNE :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._ifne(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IFLT :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._iflt(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IFGE :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._ifge(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IFGT :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._ifgt(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IFLE :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._ifle(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IF_ICMPEQ :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._if_icmpeq(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IF_ICMPNE :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._if_icmpne(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IF_ICMPLT :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._if_icmplt(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IF_ICMPGE :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._if_icmpge(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IF_ICMPGT :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._if_icmpgt(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IF_ICMPLE :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._if_icmple(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IF_ACMPEQ :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._if_acmpeq(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IF_ACMPNE :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._if_acmpne(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.GOTO :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._goto(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.JSR :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._jsr(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.RET :
+					index = u1At(this.classFileBytes, 1, pc);
+					visitor._ret(pc - this.codeOffset, index);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.TABLESWITCH :
+					int startpc = pc;
+					pc++;
+					while (((pc - this.codeOffset) & 0x03) != 0) { // faster than % 4
+						pc++;
+					}
+					int defaultOffset = i4At(this.classFileBytes, 0, pc);
+					pc += 4;
+					int low = i4At(this.classFileBytes, 0, pc);
+					pc += 4;
+					int high = i4At(this.classFileBytes, 0, pc);
+					pc += 4;
+					int length = high - low + 1;
+					int[] jumpOffsets = new int[length];
+					for (int i = 0; i < length; i++) {
+						jumpOffsets[i] = i4At(this.classFileBytes, 0, pc);
+						pc += 4;
+					}
+					visitor._tableswitch(startpc - this.codeOffset, defaultOffset, low, high, jumpOffsets);
+					break;
+				case IOpcodeMnemonics.LOOKUPSWITCH :
+					startpc = pc;
+					pc++;
+					while (((pc - this.codeOffset) & 0x03) != 0) {
+						pc++;
+					}
+					defaultOffset = i4At(this.classFileBytes, 0, pc);
+					pc += 4;
+					int npairs = (int) u4At(this.classFileBytes, 0, pc);
+					int[][] offset_pairs = new int[npairs][2];
+					pc += 4;
+					for (int i = 0; i < npairs; i++) {
+						offset_pairs[i][0] = i4At(this.classFileBytes, 0, pc);
+						pc += 4;
+						offset_pairs[i][1] = i4At(this.classFileBytes, 0, pc);
+						pc += 4;
+					}
+					visitor._lookupswitch(startpc - this.codeOffset, defaultOffset, npairs, offset_pairs);
+					break;
+				case IOpcodeMnemonics.IRETURN :
+					visitor._ireturn(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.LRETURN :
+					visitor._lreturn(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.FRETURN :
+					visitor._freturn(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.DRETURN :
+					visitor._dreturn(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ARETURN :
+					visitor._areturn(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.RETURN :
+					visitor._return(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.GETSTATIC :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Fieldref) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._getstatic(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.PUTSTATIC :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Fieldref) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._putstatic(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.GETFIELD :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Fieldref) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._getfield(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.PUTFIELD :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Fieldref) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._putfield(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.INVOKEVIRTUAL :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Methodref) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._invokevirtual(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.INVOKESPECIAL :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Methodref) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._invokespecial(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.INVOKESTATIC :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Methodref) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._invokestatic(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.INVOKEINTERFACE :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_InterfaceMethodref) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					byte count = (byte) u1At(this.classFileBytes, 3, pc);
+					int extraArgs = u1At(this.classFileBytes, 4, pc);
+					if (extraArgs != 0) {
+						throw new ClassFormatException(ClassFormatException.INVALID_ARGUMENTS_FOR_INVOKEINTERFACE);
+					}
+					visitor._invokeinterface(pc - this.codeOffset, index, count, constantPoolEntry);
+					pc += 5;
+					break;
+				case IOpcodeMnemonics.NEW :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._new(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.NEWARRAY :
+					int atype = u1At(this.classFileBytes, 1, pc);
+					visitor._newarray(pc - this.codeOffset, atype);
+					pc += 2;
+					break;
+				case IOpcodeMnemonics.ANEWARRAY :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._anewarray(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.ARRAYLENGTH :
+					visitor._arraylength(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.ATHROW :
+					visitor._athrow(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.CHECKCAST :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._checkcast(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.INSTANCEOF :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					visitor._instanceof(pc - this.codeOffset, index, constantPoolEntry);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.MONITORENTER :
+					visitor._monitorenter(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.MONITOREXIT :
+					visitor._monitorexit(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.WIDE :
+					opcode = u1At(this.classFileBytes, 1, pc);
+					if (opcode == IOpcodeMnemonics.IINC) {
+						index = u2At(this.classFileBytes, 2, pc);
+						_const = i2At(this.classFileBytes, 4, pc);
+						visitor._wide(pc - this.codeOffset, opcode, index, _const);
+						pc += 6;
+					} else {
+						index = u2At(this.classFileBytes, 2, pc);
+						visitor._wide(pc - this.codeOffset, opcode, index);
+						pc += 4;
+					}
+					break;
+				case IOpcodeMnemonics.MULTIANEWARRAY :
+					index = u2At(this.classFileBytes, 1, pc);
+					constantPoolEntry = this.constantPool.decodeEntry(index);
+					if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					int dimensions = u1At(this.classFileBytes, 3, pc);
+					visitor._multianewarray(pc - this.codeOffset, index, dimensions, constantPoolEntry);
+					pc += 4;
+					break;
+				case IOpcodeMnemonics.IFNULL :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._ifnull(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.IFNONNULL :
+					branchOffset = i2At(this.classFileBytes, 1, pc);
+					visitor._ifnonnull(pc - this.codeOffset, branchOffset);
+					pc += 3;
+					break;
+				case IOpcodeMnemonics.GOTO_W :
+					branchOffset = i4At(this.classFileBytes, 1, pc);
+					visitor._goto_w(pc - this.codeOffset, branchOffset);
+					pc += 5;
+					break;
+				case IOpcodeMnemonics.JSR_W :
+					branchOffset = i4At(this.classFileBytes, 1, pc);
+					visitor._jsr_w(pc - this.codeOffset, branchOffset);
+					pc += 5;
+					break;
+				case IOpcodeMnemonics.BREAKPOINT :
+					visitor._breakpoint(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IMPDEP1 :
+					visitor._impdep1(pc - this.codeOffset);
+					pc++;
+					break;
+				case IOpcodeMnemonics.IMPDEP2 :
+					visitor._impdep2(pc - this.codeOffset);
+					pc++;
+					break;
+				default :
+					throw new ClassFormatException(ClassFormatException.INVALID_BYTECODE);
+			}
+			if (pc >= (this.codeLength + this.codeOffset)) {
+				break;
+			}
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPool.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPool.java
new file mode 100644
index 0000000..caeaf25
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPool.java
@@ -0,0 +1,104 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class ConstantPool extends ClassFileStruct {
+
+	private int constantPoolCount;
+	private int[] constantPoolOffset;
+	private byte[] classFileBytes;
+
+	ConstantPool(byte[] reference, int[] constantPoolOffset) {
+		this.constantPoolCount = constantPoolOffset.length;
+		this.constantPoolOffset = constantPoolOffset;
+		this.classFileBytes = reference;
+	}
+
+	/**
+	 * @see IConstantPool#decodeEntry(int)
+	 */
+	public ConstantPoolEntry decodeEntry(int index) {
+		ConstantPoolEntry constantPoolEntry = new ConstantPoolEntry();
+		constantPoolEntry.reset();
+		int kind = getEntryKind(index);
+		constantPoolEntry.setKind(kind);
+		switch (kind) {
+			case ConstantPoolConstant.CONSTANT_Class :
+				constantPoolEntry.setClassInfoNameIndex(u2At(this.classFileBytes, 1, this.constantPoolOffset[index]));
+				constantPoolEntry.setClassInfoName(getUtf8ValueAt(constantPoolEntry.getClassInfoNameIndex()));
+				break;
+			case ConstantPoolConstant.CONSTANT_Double :
+				constantPoolEntry.setDoubleValue(doubleAt(this.classFileBytes, 1, this.constantPoolOffset[index]));
+				break;
+			case ConstantPoolConstant.CONSTANT_Fieldref :
+				constantPoolEntry.setClassIndex(u2At(this.classFileBytes, 1, this.constantPoolOffset[index]));
+				int declaringClassIndex = u2At(this.classFileBytes, 1, this.constantPoolOffset[constantPoolEntry.getClassIndex()]);
+				constantPoolEntry.setClassName(getUtf8ValueAt(declaringClassIndex));
+				constantPoolEntry.setNameAndTypeIndex(u2At(this.classFileBytes, 3, this.constantPoolOffset[index]));
+				int fieldNameIndex = u2At(this.classFileBytes, 1, this.constantPoolOffset[constantPoolEntry.getNameAndTypeIndex()]);
+				int fieldDescriptorIndex = u2At(this.classFileBytes, 3, this.constantPoolOffset[constantPoolEntry.getNameAndTypeIndex()]);
+				constantPoolEntry.setFieldName(getUtf8ValueAt(fieldNameIndex));
+				constantPoolEntry.setFieldDescriptor(getUtf8ValueAt(fieldDescriptorIndex));
+				break;
+			case ConstantPoolConstant.CONSTANT_Methodref :
+			case ConstantPoolConstant.CONSTANT_InterfaceMethodref :
+				constantPoolEntry.setClassIndex(u2At(this.classFileBytes, 1, this.constantPoolOffset[index]));
+				declaringClassIndex = u2At(this.classFileBytes, 1, this.constantPoolOffset[constantPoolEntry.getClassIndex()]);
+				constantPoolEntry.setClassName(getUtf8ValueAt(declaringClassIndex));
+				constantPoolEntry.setNameAndTypeIndex(u2At(this.classFileBytes, 3, this.constantPoolOffset[index]));
+				int methodNameIndex = u2At(this.classFileBytes, 1, this.constantPoolOffset[constantPoolEntry.getNameAndTypeIndex()]);
+				int methodDescriptorIndex = u2At(this.classFileBytes, 3, this.constantPoolOffset[constantPoolEntry.getNameAndTypeIndex()]);
+				constantPoolEntry.setMethodName(getUtf8ValueAt(methodNameIndex));
+				constantPoolEntry.setMethodDescriptor(getUtf8ValueAt(methodDescriptorIndex));
+				break;
+			case ConstantPoolConstant.CONSTANT_Float :
+				constantPoolEntry.setFloatValue(floatAt(this.classFileBytes, 1, this.constantPoolOffset[index]));
+				break;
+			case ConstantPoolConstant.CONSTANT_Integer :
+				constantPoolEntry.setIntegerValue(i4At(this.classFileBytes, 1, this.constantPoolOffset[index]));
+				break;
+			case ConstantPoolConstant.CONSTANT_Long :
+				constantPoolEntry.setLongValue(i8At(this.classFileBytes, 1, this.constantPoolOffset[index]));
+				break;
+			case ConstantPoolConstant.CONSTANT_NameAndType :
+				constantPoolEntry.setNameAndTypeNameIndex(u2At(this.classFileBytes, 1, this.constantPoolOffset[index]));
+				constantPoolEntry.setNameAndTypeDescriptorIndex(u2At(this.classFileBytes, 3, this.constantPoolOffset[index]));
+				break;
+			case ConstantPoolConstant.CONSTANT_String :
+				constantPoolEntry.setStringIndex(u2At(this.classFileBytes, 1, this.constantPoolOffset[index]));
+				constantPoolEntry.setStringValue(getUtf8ValueAt(constantPoolEntry.getStringIndex()));
+				break;
+			case ConstantPoolConstant.CONSTANT_Utf8 :
+				constantPoolEntry.setUtf8Length(u2At(this.classFileBytes, 1, this.constantPoolOffset[index]));
+				constantPoolEntry.setUtf8Value(getUtf8ValueAt(index));
+		}
+		return constantPoolEntry;
+	}
+
+	/**
+	 * @see IConstantPool#getConstantPoolCount()
+	 */
+	public int getConstantPoolCount() {
+		return this.constantPoolCount;
+	}
+
+	/**
+	 * @see IConstantPool#getEntryKind(int)
+	 */
+	public int getEntryKind(int index) {
+		return u1At(this.classFileBytes, 0, this.constantPoolOffset[index]);
+	}
+
+	private char[] getUtf8ValueAt(int utf8Index) {
+		int utf8Offset = this.constantPoolOffset[utf8Index];
+		return utf8At(this.classFileBytes, 0, utf8Offset + 3, u2At(this.classFileBytes, 0, utf8Offset + 1));
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolConstant.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolConstant.java
new file mode 100644
index 0000000..7cebf66
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolConstant.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public interface ConstantPoolConstant {
+
+	int CONSTANT_Class = 7;
+	int CONSTANT_Fieldref = 9;
+	int CONSTANT_Methodref = 10;
+	int CONSTANT_InterfaceMethodref = 11;
+	int CONSTANT_String = 8;
+	int CONSTANT_Integer = 3;
+	int CONSTANT_Float = 4;
+	int CONSTANT_Long = 5;
+	int CONSTANT_Double = 6;
+	int CONSTANT_NameAndType = 12;
+	int CONSTANT_Utf8 = 1;
+
+	int CONSTANT_Methodref_SIZE = 5;
+	int CONSTANT_Class_SIZE = 3;
+	int CONSTANT_Double_SIZE = 9;
+	int CONSTANT_Fieldref_SIZE = 5;
+	int CONSTANT_Float_SIZE = 5;
+	int CONSTANT_Integer_SIZE = 5;
+	int CONSTANT_InterfaceMethodref_SIZE = 5;
+	int CONSTANT_Long_SIZE = 9;
+	int CONSTANT_String_SIZE = 3;
+	int CONSTANT_Utf8_SIZE = 3;
+	int CONSTANT_NameAndType_SIZE = 5;
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolEntry.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolEntry.java
new file mode 100644
index 0000000..4d4d8d4
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolEntry.java
@@ -0,0 +1,396 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class ConstantPoolEntry {
+
+	private int kind;
+	private int classInfoNameIndex;
+	private int classIndex;
+	private int nameAndTypeIndex;
+	private int stringIndex;
+	private char[] stringValue;
+	private int integerValue;
+	private float floatValue;
+	private double doubleValue;
+	private long longValue;
+	private int nameAndTypeDescriptorIndex;
+	private int nameAndTypeNameIndex;
+	private char[] className;
+	private char[] fieldName;
+	private char[] methodName;
+	private char[] fieldDescriptor;
+	private char[] methodDescriptor;
+	private char[] utf8Value;
+	private int utf8Length;
+	private char[] classInfoName;
+
+	public ConstantPoolEntry() {
+		this.classInfoNameIndex = -1;
+		this.classIndex = -1;
+		this.nameAndTypeIndex = -1;
+		this.stringIndex = -1;
+		this.stringValue = null;
+		this.integerValue = -1;
+		this.floatValue = -0.0f;
+		this.doubleValue = -0 - 0;
+		this.longValue = -1;
+		this.nameAndTypeDescriptorIndex = -1;
+		this.nameAndTypeNameIndex = -1;
+		this.className = null;
+		this.fieldName = null;
+		this.methodName = null;
+		this.fieldDescriptor = null;
+		this.methodDescriptor = null;
+		this.utf8Value = null;
+		this.utf8Length = -1;
+		this.classInfoName = null;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getKind()
+	 */
+	public int getKind() {
+		return this.kind;
+	}
+
+	/**
+	 * Sets the kind.
+	 * @param kind The kind to set
+	 */
+	public void setKind(int kind) {
+		this.kind = kind;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getClassInfoNameIndex()
+	 */
+	public int getClassInfoNameIndex() {
+		return this.classInfoNameIndex;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getClassIndex()
+	 */
+	public int getClassIndex() {
+		return this.classIndex;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getNameAndTypeIndex()
+	 */
+	public int getNameAndTypeIndex() {
+		return this.nameAndTypeIndex;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getStringIndex()
+	 */
+	public int getStringIndex() {
+		return this.stringIndex;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getStringValue()
+	 */
+	public String getStringValue() {
+		return new String(this.stringValue);
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getIntegerValue()
+	 */
+	public int getIntegerValue() {
+		return this.integerValue;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getFloatValue()
+	 */
+	public float getFloatValue() {
+		return this.floatValue;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getDoubleValue()
+	 */
+	public double getDoubleValue() {
+		return this.doubleValue;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getLongValue()
+	 */
+	public long getLongValue() {
+		return this.longValue;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getNameAndTypeInfoDescriptorIndex()
+	 */
+	public int getNameAndTypeInfoDescriptorIndex() {
+		return this.nameAndTypeDescriptorIndex;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getNameAndTypeInfoNameIndex()
+	 */
+	public int getNameAndTypeInfoNameIndex() {
+		return this.nameAndTypeNameIndex;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getClassName()
+	 */
+	public char[] getClassName() {
+		return this.className;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getFieldName()
+	 */
+	public char[] getFieldName() {
+		return this.fieldName;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getMethodName()
+	 */
+	public char[] getMethodName() {
+		return this.methodName;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getFieldDescriptor()
+	 */
+	public char[] getFieldDescriptor() {
+		return this.fieldDescriptor;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getMethodDescriptor()
+	 */
+	public char[] getMethodDescriptor() {
+		return this.methodDescriptor;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getUtf8Value()
+	 */
+	public char[] getUtf8Value() {
+		return this.utf8Value;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getClassInfoName()
+	 */
+	public char[] getClassInfoName() {
+		return this.classInfoName;
+	}
+
+	/**
+	 * Sets the classInfoNameIndex.
+	 * @param classInfoNameIndex The classInfoNameIndex to set
+	 */
+	public void setClassInfoNameIndex(int classInfoNameIndex) {
+		this.classInfoNameIndex = classInfoNameIndex;
+	}
+
+	/**
+	 * Sets the classIndex.
+	 * @param classIndex The classIndex to set
+	 */
+	public void setClassIndex(int classIndex) {
+		this.classIndex = classIndex;
+	}
+
+	/**
+	 * Sets the nameAndTypeIndex.
+	 * @param nameAndTypeIndex The nameAndTypeIndex to set
+	 */
+	public void setNameAndTypeIndex(int nameAndTypeIndex) {
+		this.nameAndTypeIndex = nameAndTypeIndex;
+	}
+
+	/**
+	 * Sets the stringIndex.
+	 * @param stringIndex The stringIndex to set
+	 */
+	public void setStringIndex(int stringIndex) {
+		this.stringIndex = stringIndex;
+	}
+
+	/**
+	 * Sets the stringValue.
+	 * @param stringValue The stringValue to set
+	 */
+	public void setStringValue(char[] stringValue) {
+		this.stringValue = stringValue;
+	}
+
+	/**
+	 * Sets the integerValue.
+	 * @param integerValue The integerValue to set
+	 */
+	public void setIntegerValue(int integerValue) {
+		this.integerValue = integerValue;
+	}
+
+	/**
+	 * Sets the floatValue.
+	 * @param floatValue The floatValue to set
+	 */
+	public void setFloatValue(float floatValue) {
+		this.floatValue = floatValue;
+	}
+
+	/**
+	 * Sets the doubleValue.
+	 * @param doubleValue The doubleValue to set
+	 */
+	public void setDoubleValue(double doubleValue) {
+		this.doubleValue = doubleValue;
+	}
+
+	/**
+	 * Sets the longValue.
+	 * @param longValue The longValue to set
+	 */
+	public void setLongValue(long longValue) {
+		this.longValue = longValue;
+	}
+
+	/**
+	 * Gets the nameAndTypeDescriptorIndex.
+	 * @return Returns a int
+	 */
+	public int getNameAndTypeDescriptorIndex() {
+		return this.nameAndTypeDescriptorIndex;
+	}
+
+	/**
+	 * Sets the nameAndTypeDescriptorIndex.
+	 * @param nameAndTypeDescriptorIndex The nameAndTypeDescriptorIndex to set
+	 */
+	public void setNameAndTypeDescriptorIndex(int nameAndTypeDescriptorIndex) {
+		this.nameAndTypeDescriptorIndex = nameAndTypeDescriptorIndex;
+	}
+
+	/**
+	 * Gets the nameAndTypeNameIndex.
+	 * @return Returns a int
+	 */
+	public int getNameAndTypeNameIndex() {
+		return this.nameAndTypeNameIndex;
+	}
+
+	/**
+	 * Sets the nameAndTypeNameIndex.
+	 * @param nameAndTypeNameIndex The nameAndTypeNameIndex to set
+	 */
+	public void setNameAndTypeNameIndex(int nameAndTypeNameIndex) {
+		this.nameAndTypeNameIndex = nameAndTypeNameIndex;
+	}
+
+	/**
+	 * Sets the className.
+	 * @param className The className to set
+	 */
+	public void setClassName(char[] className) {
+		this.className = className;
+	}
+
+	/**
+	 * Sets the fieldName.
+	 * @param fieldName The fieldName to set
+	 */
+	public void setFieldName(char[] fieldName) {
+		this.fieldName = fieldName;
+	}
+
+	/**
+	 * Sets the methodName.
+	 * @param methodName The methodName to set
+	 */
+	public void setMethodName(char[] methodName) {
+		this.methodName = methodName;
+	}
+
+	/**
+	 * Sets the fieldDescriptor.
+	 * @param fieldDescriptor The fieldDescriptor to set
+	 */
+	public void setFieldDescriptor(char[] fieldDescriptor) {
+		this.fieldDescriptor = fieldDescriptor;
+	}
+
+	/**
+	 * Sets the methodDescriptor.
+	 * @param methodDescriptor The methodDescriptor to set
+	 */
+	public void setMethodDescriptor(char[] methodDescriptor) {
+		this.methodDescriptor = methodDescriptor;
+	}
+
+	/**
+	 * Sets the utf8Value.
+	 * @param utf8Value The utf8Value to set
+	 */
+	public void setUtf8Value(char[] utf8Value) {
+		this.utf8Value = utf8Value;
+	}
+
+	/**
+	 * Sets the classInfoName.
+	 * @param classInfoName The classInfoName to set
+	 */
+	public void setClassInfoName(char[] classInfoName) {
+		this.classInfoName = classInfoName;
+	}
+
+	/**
+	 * @see IConstantPoolEntry#getUtf8Length()
+	 */
+	public int getUtf8Length() {
+		return this.utf8Length;
+	}
+
+	/**
+	 * Sets the utf8Length.
+	 * @param utf8Length The utf8Length to set
+	 */
+	public void setUtf8Length(int utf8Length) {
+		this.utf8Length = utf8Length;
+	}
+
+	public void reset() {
+		this.kind = 0;
+		this.classInfoNameIndex = 0;
+		this.classIndex = 0;
+		this.nameAndTypeIndex = 0;
+		this.stringIndex = 0;
+		this.stringValue = null;
+		this.integerValue = 0;
+		this.floatValue = 0.0f;
+		this.doubleValue = 0.0;
+		this.longValue = 0L;
+		this.nameAndTypeDescriptorIndex = 0;
+		this.nameAndTypeNameIndex = 0;
+		this.className = null;
+		this.fieldName = null;
+		this.methodName = null;
+		this.fieldDescriptor = null;
+		this.methodDescriptor = null;
+		this.utf8Value = null;
+		this.utf8Length = 0;
+		this.classInfoName = null;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantValueAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantValueAttribute.java
new file mode 100644
index 0000000..bab9881
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantValueAttribute.java
@@ -0,0 +1,37 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class ConstantValueAttribute extends ClassFileAttribute {
+
+	private int constantValueIndex;
+	private ConstantPoolEntry constantPoolEntry;
+
+	ConstantValueAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		this.constantValueIndex = u2At(classFileBytes, 6, offset);
+		this.constantPoolEntry = constantPool.decodeEntry(this.constantValueIndex);
+	}
+
+	/**
+	 * @see IConstantValueAttribute#getConstantValue()
+	 */
+	public ConstantPoolEntry getConstantValue() {
+		return this.constantPoolEntry;
+	}
+
+	/**
+	 * @see IConstantValueAttribute#getConstantValueIndex()
+	 */
+	public int getConstantValueIndex() {
+		return this.constantValueIndex;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/DefaultBytecodeVisitor.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/DefaultBytecodeVisitor.java
new file mode 100644
index 0000000..c27c538
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/DefaultBytecodeVisitor.java
@@ -0,0 +1,2071 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+import org.eclipse.osgi.util.NLS;
+
+public class DefaultBytecodeVisitor {
+	private static final String EMPTY_CLASS_NAME = "\"\""; //$NON-NLS-1$
+	private static final String EMPTY_LOCAL_NAME = ""; //$NON-NLS-1$
+	private static final int T_BOOLEAN = 4;
+	private static final int T_CHAR = 5;
+	private static final int T_FLOAT = 6;
+	private static final int T_DOUBLE = 7;
+	private static final int T_BYTE = 8;
+	private static final int T_SHORT = 9;
+	private static final int T_INT = 10;
+	private static final int T_LONG = 11;
+
+	private StringBuffer buffer;
+	private String lineSeparator;
+	private int tabNumber;
+	private int digitNumberForPC;
+	private int mode;
+
+	public DefaultBytecodeVisitor(CodeAttribute codeAttribute, char[] methodDescriptor, boolean isStatic, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		this.buffer = buffer;
+		this.lineSeparator = lineSeparator;
+		this.tabNumber = tabNumber + 1;
+		long codeLength = codeAttribute.getCodeLength();
+		this.digitNumberForPC = Long.toString(codeLength).length();
+		this.mode = mode;
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_aaload(int)
+	 */
+	public void _aaload(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.AALOAD]);
+		writeNewLine();
+	}
+
+	private void dumpPcNumber(int pc) {
+		writeTabs();
+		int digitForPC = 1;
+		if (pc != 0) {
+			digitForPC = Integer.toString(pc).length();
+		}
+		for (int i = 0, max = this.digitNumberForPC - digitForPC; i < max; i++) {
+			this.buffer.append(' ');
+		}
+		this.buffer.append(pc);
+		this.buffer.append(Messages.disassembler_indentation);
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_aastore(int)
+	 */
+	public void _aastore(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.AASTORE]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_aconst_null(int)
+	 */
+	public void _aconst_null(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ACONST_NULL]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_aload_0(int)
+	 */
+	public void _aload_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ALOAD_0], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_aload_1(int)
+	 */
+	public void _aload_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ALOAD_1], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_aload_2(int)
+	 */
+	public void _aload_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ALOAD_2], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_aload_3(int)
+	 */
+	public void _aload_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ALOAD_3], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_aload(int, int)
+	 */
+	public void _aload(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ALOAD], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_anewarray(int, int, ConstantPoolEntry)
+	 */
+	public void _anewarray(int pc, int index, ConstantPoolEntry constantClass) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_anewarray, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ANEWARRAY], returnConstantClassName(constantClass)}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_areturn(int)
+	 */
+	public void _areturn(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ARETURN]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_arraylength(int)
+	 */
+	public void _arraylength(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ARRAYLENGTH]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_astore_0(int)
+	 */
+	public void _astore_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ASTORE_0], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_astore_1(int)
+	 */
+	public void _astore_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ASTORE_1], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_astore_2(int)
+	 */
+	public void _astore_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ASTORE_2], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_astore_3(int)
+	 */
+	public void _astore_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ASTORE_3], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_astore(int, int)
+	 */
+	public void _astore(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ASTORE], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_athrow(int)
+	 */
+	public void _athrow(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ATHROW]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_baload(int)
+	 */
+	public void _baload(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.BALOAD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_bastore(int)
+	 */
+	public void _bastore(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.BASTORE]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_bipush(int, byte)
+	 */
+	public void _bipush(int pc, byte _byte) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.BIPUSH]).append(Messages.disassembler_space).append(_byte);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_caload(int)
+	 */
+	public void _caload(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.CALOAD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_castore(int)
+	 */
+	public void _castore(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.CASTORE]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_checkcast(int, int, ConstantPoolEntry)
+	 */
+	public void _checkcast(int pc, int index, ConstantPoolEntry constantClass) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_checkcast, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.CHECKCAST], returnConstantClassName(constantClass)}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_d2f(int)
+	 */
+	public void _d2f(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.D2F]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_d2i(int)
+	 */
+	public void _d2i(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.D2I]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_d2l(int)
+	 */
+	public void _d2l(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.D2L]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dadd(int)
+	 */
+	public void _dadd(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DADD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_daload(int)
+	 */
+	public void _daload(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DALOAD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dastore(int)
+	 */
+	public void _dastore(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DASTORE]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dcmpg(int)
+	 */
+	public void _dcmpg(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DCMPG]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dcmpl(int)
+	 */
+	public void _dcmpl(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DCMPL]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dconst_0(int)
+	 */
+	public void _dconst_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DCONST_0]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dconst_1(int)
+	 */
+	public void _dconst_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DCONST_1]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ddiv(int)
+	 */
+	public void _ddiv(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DDIV]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dload_0(int)
+	 */
+	public void _dload_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DLOAD_0], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dload_1(int)
+	 */
+	public void _dload_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DLOAD_1], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dload_2(int)
+	 */
+	public void _dload_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DLOAD_2], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dload_3(int)
+	 */
+	public void _dload_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DLOAD_3], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dload(int, int)
+	 */
+	public void _dload(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DLOAD], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dmul(int)
+	 */
+	public void _dmul(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DMUL]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dneg(int)
+	 */
+	public void _dneg(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DNEG]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_drem(int)
+	 */
+	public void _drem(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DREM]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dreturn(int)
+	 */
+	public void _dreturn(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DRETURN]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dstore_0(int)
+	 */
+	public void _dstore_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DSTORE_0], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dstore_1(int)
+	 */
+	public void _dstore_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DSTORE_1], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dstore_2(int)
+	 */
+	public void _dstore_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DSTORE_2], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dstore_3(int)
+	 */
+	public void _dstore_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DSTORE_3], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dstore(int,int)
+	 */
+	public void _dstore(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DSTORE], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dsub(int)
+	 */
+	public void _dsub(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DSUB]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dup_x1(int)
+	 */
+	public void _dup_x1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DUP_X1]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dup_x2(int)
+	 */
+	public void _dup_x2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DUP_X2]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dup(int)
+	 */
+	public void _dup(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DUP]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dup2_x1(int)
+	 */
+	public void _dup2_x1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DUP2_X1]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dup2_x2(int)
+	 */
+	public void _dup2_x2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DUP2_X2]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_dup2(int)
+	 */
+	public void _dup2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.DUP2]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_f2d(int)
+	 */
+	public void _f2d(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.F2D]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_f2i(int)
+	 */
+	public void _f2i(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.F2I]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_f2l(int)
+	 */
+	public void _f2l(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.F2L]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fadd(int)
+	 */
+	public void _fadd(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FADD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_faload(int)
+	 */
+	public void _faload(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FALOAD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fastore(int)
+	 */
+	public void _fastore(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FASTORE]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fcmpg(int)
+	 */
+	public void _fcmpg(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FCMPG]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fcmpl(int)
+	 */
+	public void _fcmpl(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FCMPL]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fconst_0(int)
+	 */
+	public void _fconst_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FCONST_0]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fconst_1(int)
+	 */
+	public void _fconst_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FCONST_1]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fconst_2(int)
+	 */
+	public void _fconst_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FCONST_2]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fdiv(int)
+	 */
+	public void _fdiv(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FDIV]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fload_0(int)
+	 */
+	public void _fload_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FLOAD_0], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fload_1(int)
+	 */
+	public void _fload_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FLOAD_1], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fload_2(int)
+	 */
+	public void _fload_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FLOAD_2], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fload_3(int)
+	 */
+	public void _fload_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FLOAD_3], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fload(int, int)
+	 */
+	public void _fload(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FLOAD], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fmul(int)
+	 */
+	public void _fmul(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FMUL]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fneg(int)
+	 */
+	public void _fneg(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FNEG]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_frem(int)
+	 */
+	public void _frem(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FREM]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_freturn(int)
+	 */
+	public void _freturn(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FRETURN]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fstore_0(int)
+	 */
+	public void _fstore_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FSTORE_0], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fstore_1(int)
+	 */
+	public void _fstore_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FSTORE_1], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fstore_2(int)
+	 */
+	public void _fstore_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FSTORE_2], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fstore_3(int)
+	 */
+	public void _fstore_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FSTORE_3], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fstore(int, int)
+	 */
+	public void _fstore(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FSTORE], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_fsub(int)
+	 */
+	public void _fsub(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.FSUB]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_getfield(int, int, ConstantPoolEntry)
+	 */
+	public void _getfield(int pc, int index, ConstantPoolEntry constantFieldref) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_getfield, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.GETFIELD], returnDeclaringClassName(constantFieldref), new String(constantFieldref.getFieldName()), returnClassName(Signature.toCharArray(constantFieldref.getFieldDescriptor()))}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_getstatic(int, int, ConstantPoolEntry)
+	 */
+	public void _getstatic(int pc, int index, ConstantPoolEntry constantFieldref) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_getstatic, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.GETSTATIC], returnDeclaringClassName(constantFieldref), new String(constantFieldref.getFieldName()), returnClassName(Signature.toCharArray(constantFieldref.getFieldDescriptor()))}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_goto_w(int, int)
+	 */
+	public void _goto_w(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.GOTO_W]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_goto(int, int)
+	 */
+	public void _goto(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.GOTO]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_i2b(int)
+	 */
+	public void _i2b(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.I2B]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_i2c(int)
+	 */
+	public void _i2c(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.I2C]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_i2d(int)
+	 */
+	public void _i2d(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.I2D]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_i2f(int)
+	 */
+	public void _i2f(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.I2F]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_i2l(int)
+	 */
+	public void _i2l(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.I2L]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_i2s(int)
+	 */
+	public void _i2s(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.I2S]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iadd(int)
+	 */
+	public void _iadd(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IADD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iaload(int)
+	 */
+	public void _iaload(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IALOAD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iand(int)
+	 */
+	public void _iand(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IAND]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iastore(int)
+	 */
+	public void _iastore(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IASTORE]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_if_acmpeq(int, int)
+	 */
+	public void _if_acmpeq(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IF_ACMPEQ]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_if_acmpne(int, int)
+	 */
+	public void _if_acmpne(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IF_ACMPNE]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_if_icmpeq(int, int)
+	 */
+	public void _if_icmpeq(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IF_ICMPEQ]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_if_icmpge(int, int)
+	 */
+	public void _if_icmpge(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IF_ICMPGE]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_if_icmpgt(int, int)
+	 */
+	public void _if_icmpgt(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IF_ICMPGT]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_if_icmple(int, int)
+	 */
+	public void _if_icmple(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IF_ICMPLE]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_if_icmplt(int, int)
+	 */
+	public void _if_icmplt(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IF_ICMPLT]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_if_icmpne(int, int)
+	 */
+	public void _if_icmpne(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IF_ICMPNE]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iconst_0(int)
+	 */
+	public void _iconst_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ICONST_0]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iconst_1(int)
+	 */
+	public void _iconst_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ICONST_1]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iconst_2(int)
+	 */
+	public void _iconst_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ICONST_2]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iconst_3(int)
+	 */
+	public void _iconst_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ICONST_3]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iconst_4(int)
+	 */
+	public void _iconst_4(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ICONST_4]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iconst_5(int)
+	 */
+	public void _iconst_5(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ICONST_5]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iconst_m1(int)
+	 */
+	public void _iconst_m1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ICONST_M1]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_idiv(int)
+	 */
+	public void _idiv(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IDIV]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ifeq(int, int)
+	 */
+	public void _ifeq(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IFEQ]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ifge(int, int)
+	 */
+	public void _ifge(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IFGE]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ifgt(int, int)
+	 */
+	public void _ifgt(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IFGT]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ifle(int, int)
+	 */
+	public void _ifle(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IFLE]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iflt(int, int)
+	 */
+	public void _iflt(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IFLT]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ifne(int, int)
+	 */
+	public void _ifne(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IFNE]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ifnonnull(int, int)
+	 */
+	public void _ifnonnull(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IFNONNULL]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ifnull(int, int)
+	 */
+	public void _ifnull(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IFNULL]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iinc(int, int, int)
+	 */
+	public void _iinc(int pc, int index, int _const) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_iinc, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IINC], Integer.toString(index), Integer.toString(_const), EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iload_0(int)
+	 */
+	public void _iload_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ILOAD_0], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iload_1(int)
+	 */
+	public void _iload_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ILOAD_1], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iload_2(int)
+	 */
+	public void _iload_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ILOAD_2], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iload_3(int)
+	 */
+	public void _iload_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ILOAD_3], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iload(int, int)
+	 */
+	public void _iload(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ILOAD], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_imul(int)
+	 */
+	public void _imul(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IMUL]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ineg(int)
+	 */
+	public void _ineg(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.INEG]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_instanceof(int, int, ConstantPoolEntry)
+	 */
+	public void _instanceof(int pc, int index, ConstantPoolEntry constantClass) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_instanceof, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.INSTANCEOF], returnConstantClassName(constantClass)}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_invokeinterface(int, int, byte, ConstantPoolEntry)
+	 */
+	public void _invokeinterface(int pc, int index, byte nargs, ConstantPoolEntry constantInterfaceMethodref) {
+
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_invokeinterface, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.INVOKEINTERFACE], Integer.toString(nargs), Utility.toString(constantInterfaceMethodref.getClassName(), constantInterfaceMethodref.getMethodName(), constantInterfaceMethodref.getMethodDescriptor(), true, isCompact())}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_invokespecial(int, int, ConstantPoolEntry)
+	 */
+	public void _invokespecial(int pc, int index, ConstantPoolEntry constantMethodref) {
+		dumpPcNumber(pc);
+		final String signature = returnMethodSignature(constantMethodref);
+		this.buffer.append(NLS.bind(Messages.classformat_invokespecial, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.INVOKESPECIAL], signature}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_invokestatic(int, int, ConstantPoolEntry)
+	 */
+	public void _invokestatic(int pc, int index, ConstantPoolEntry constantMethodref) {
+		dumpPcNumber(pc);
+		final String signature = returnMethodSignature(constantMethodref);
+		this.buffer.append(NLS.bind(Messages.classformat_invokestatic, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.INVOKESTATIC], signature}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_invokevirtual(int, int, ConstantPoolEntry)
+	 */
+	public void _invokevirtual(int pc, int index, ConstantPoolEntry constantMethodref) {
+		dumpPcNumber(pc);
+		final String signature = returnMethodSignature(constantMethodref);
+		this.buffer.append(NLS.bind(Messages.classformat_invokevirtual, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.INVOKEVIRTUAL], signature}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ior(int)
+	 */
+	public void _ior(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IOR]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_irem(int)
+	 */
+	public void _irem(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IREM]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ireturn(int)
+	 */
+	public void _ireturn(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IRETURN]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ishl(int)
+	 */
+	public void _ishl(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ISHL]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ishr(int)
+	 */
+	public void _ishr(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ISHR]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_istore_0(int)
+	 */
+	public void _istore_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ISTORE_0], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_istore_1(int)
+	 */
+	public void _istore_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ISTORE_1], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_istore_2(int)
+	 */
+	public void _istore_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ISTORE_2], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_istore_3(int)
+	 */
+	public void _istore_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ISTORE_3], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_istore(int, int)
+	 */
+	public void _istore(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ISTORE], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_isub(int)
+	 */
+	public void _isub(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ISUB]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_iushr(int)
+	 */
+	public void _iushr(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IUSHR]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ixor(int)
+	 */
+	public void _ixor(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IXOR]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_jsr_w(int, int)
+	 */
+	public void _jsr_w(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.JSR_W]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_jsr(int, int)
+	 */
+	public void _jsr(int pc, int branchOffset) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.JSR]).append(Messages.disassembler_space).append(branchOffset + pc);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_l2d(int)
+	 */
+	public void _l2d(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.L2D]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_l2f(int)
+	 */
+	public void _l2f(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.L2F]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_l2i(int)
+	 */
+	public void _l2i(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.L2I]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ladd(int)
+	 */
+	public void _ladd(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LADD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_laload(int)
+	 */
+	public void _laload(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LALOAD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_land(int)
+	 */
+	public void _land(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LAND]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lastore(int)
+	 */
+	public void _lastore(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LASTORE]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lcmp(int)
+	 */
+	public void _lcmp(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LCMP]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lconst_0(int)
+	 */
+	public void _lconst_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LCONST_0]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lconst_1(int)
+	 */
+	public void _lconst_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LCONST_1]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ldc_w(int, int, ConstantPoolEntry)
+	 */
+	public void _ldc_w(int pc, int index, ConstantPoolEntry constantPoolEntry) {
+		dumpPcNumber(pc);
+		switch (constantPoolEntry.getKind()) {
+			case ConstantPoolConstant.CONSTANT_Float :
+				this.buffer.append(NLS.bind(Messages.classformat_ldc_w_float, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC_W], Float.toString(constantPoolEntry.getFloatValue())}));
+				break;
+			case ConstantPoolConstant.CONSTANT_Integer :
+				this.buffer.append(NLS.bind(Messages.classformat_ldc_w_integer, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC_W], Integer.toString(constantPoolEntry.getIntegerValue())}));
+				break;
+			case ConstantPoolConstant.CONSTANT_String :
+				this.buffer.append(NLS.bind(Messages.classformat_ldc_w_string, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC_W], Disassembler.escapeString(constantPoolEntry.getStringValue())}));
+				break;
+			case ConstantPoolConstant.CONSTANT_Class :
+				this.buffer.append(NLS.bind(Messages.classformat_ldc_w_class, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC_W], returnConstantClassName(constantPoolEntry)}));
+		}
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ldc(int, int, ConstantPoolEntry)
+	 */
+	public void _ldc(int pc, int index, ConstantPoolEntry constantPoolEntry) {
+		dumpPcNumber(pc);
+		switch (constantPoolEntry.getKind()) {
+			case ConstantPoolConstant.CONSTANT_Float :
+				this.buffer.append(NLS.bind(Messages.classformat_ldc_w_float, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC], Float.toString(constantPoolEntry.getFloatValue())}));
+				break;
+			case ConstantPoolConstant.CONSTANT_Integer :
+				this.buffer.append(NLS.bind(Messages.classformat_ldc_w_integer, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC], Integer.toString(constantPoolEntry.getIntegerValue())}));
+				break;
+			case ConstantPoolConstant.CONSTANT_String :
+				this.buffer.append(NLS.bind(Messages.classformat_ldc_w_string, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC], Disassembler.escapeString(constantPoolEntry.getStringValue())}));
+				break;
+			case ConstantPoolConstant.CONSTANT_Class :
+				this.buffer.append(NLS.bind(Messages.classformat_ldc_w_class, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC], returnConstantClassName(constantPoolEntry)}));
+		}
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ldc2_w(int, int, ConstantPoolEntry)
+	 */
+	public void _ldc2_w(int pc, int index, ConstantPoolEntry constantPoolEntry) {
+		dumpPcNumber(pc);
+		switch (constantPoolEntry.getKind()) {
+			case ConstantPoolConstant.CONSTANT_Long :
+				this.buffer.append(NLS.bind(Messages.classformat_ldc2_w_long, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC2_W], Long.toString(constantPoolEntry.getLongValue())}));
+				break;
+			case ConstantPoolConstant.CONSTANT_Double :
+				this.buffer.append(NLS.bind(Messages.classformat_ldc2_w_double, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC2_W], Double.toString(constantPoolEntry.getDoubleValue())}));
+		}
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ldiv(int)
+	 */
+	public void _ldiv(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDIV]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lload_0(int)
+	 */
+	public void _lload_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LLOAD_0], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lload_1(int)
+	 */
+	public void _lload_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LLOAD_1], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lload_2(int)
+	 */
+	public void _lload_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LLOAD_2], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lload_3(int)
+	 */
+	public void _lload_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LLOAD_3], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lload(int, int)
+	 */
+	public void _lload(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_load, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LLOAD], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lmul(int)
+	 */
+	public void _lmul(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LMUL]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lneg(int)
+	 */
+	public void _lneg(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LNEG]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lookupswitch(int, int, int, int[][])
+	 */
+	public void _lookupswitch(int pc, int defaultoffset, int npairs, int[][] offset_pairs) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LOOKUPSWITCH]).append(" default: ") //$NON-NLS-1$
+				.append(defaultoffset + pc);
+		writeNewLine();
+		for (int i = 0; i < npairs; i++) {
+			writeExtraTabs(3);
+			this.buffer.append("case ") //$NON-NLS-1$
+					.append(offset_pairs[i][0]).append(": ") //$NON-NLS-1$
+					.append(offset_pairs[i][1] + pc);
+			writeNewLine();
+		}
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lor(int)
+	 */
+	public void _lor(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LOR]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lrem(int)
+	 */
+	public void _lrem(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LREM]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lreturn(int)
+	 */
+	public void _lreturn(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LRETURN]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lshl(int)
+	 */
+	public void _lshl(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LSHL]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lshr(int)
+	 */
+	public void _lshr(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LSHR]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lstore_0(int)
+	 */
+	public void _lstore_0(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LSTORE_0], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lstore_1(int)
+	 */
+	public void _lstore_1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LSTORE_1], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lstore_2(int)
+	 */
+	public void _lstore_2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LSTORE_2], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lstore_3(int)
+	 */
+	public void _lstore_3(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LSTORE_3], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lstore(int, int)
+	 */
+	public void _lstore(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_store, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LSTORE], EMPTY_LOCAL_NAME}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lsub(int)
+	 */
+	public void _lsub(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LSUB]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lushr(int)
+	 */
+	public void _lushr(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LUSHR]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_lxor(int)
+	 */
+	public void _lxor(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LXOR]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_monitorenter(int)
+	 */
+	public void _monitorenter(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.MONITORENTER]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_monitorexit(int)
+	 */
+	public void _monitorexit(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.MONITOREXIT]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_multianewarray(int, int, int, ConstantPoolEntry)
+	 */
+	public void _multianewarray(int pc, int index, int dimensions, ConstantPoolEntry constantClass) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_multianewarray, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.MULTIANEWARRAY], returnConstantClassName(constantClass)}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_new(int, int, ConstantPoolEntry)
+	 */
+	public void _new(int pc, int index, ConstantPoolEntry constantClass) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_new, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEW], returnConstantClassName(constantClass)}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_newarray(int, int)
+	 */
+	public void _newarray(int pc, int atype) {
+		dumpPcNumber(pc);
+		switch (atype) {
+			case T_BOOLEAN :
+				this.buffer.append(NLS.bind(Messages.classformat_newarray_boolean, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEWARRAY], Integer.toString(atype)}));
+				break;
+			case T_CHAR :
+				this.buffer.append(NLS.bind(Messages.classformat_newarray_char, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEWARRAY], Integer.toString(atype)}));
+				break;
+			case T_FLOAT :
+				this.buffer.append(NLS.bind(Messages.classformat_newarray_float, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEWARRAY], Integer.toString(atype)}));
+				break;
+			case T_DOUBLE :
+				this.buffer.append(NLS.bind(Messages.classformat_newarray_double, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEWARRAY], Integer.toString(atype)}));
+				break;
+			case T_BYTE :
+				this.buffer.append(NLS.bind(Messages.classformat_newarray_byte, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEWARRAY], Integer.toString(atype)}));
+				break;
+			case T_SHORT :
+				this.buffer.append(NLS.bind(Messages.classformat_newarray_short, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEWARRAY], Integer.toString(atype)}));
+				break;
+			case T_INT :
+				this.buffer.append(NLS.bind(Messages.classformat_newarray_int, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEWARRAY], Integer.toString(atype)}));
+				break;
+			case T_LONG :
+				this.buffer.append(NLS.bind(Messages.classformat_newarray_long, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEWARRAY], Integer.toString(atype)}));
+		}
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_nop(int)
+	 */
+	public void _nop(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NOP]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_pop(int)
+	 */
+	public void _pop(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.POP]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_pop2(int)
+	 */
+	public void _pop2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.POP2]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_putfield(int, int, ConstantPoolEntry)
+	 */
+	public void _putfield(int pc, int index, ConstantPoolEntry constantFieldref) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_putfield, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.PUTFIELD], returnDeclaringClassName(constantFieldref), new String(constantFieldref.getFieldName()), returnClassName(Signature.toCharArray(constantFieldref.getFieldDescriptor()))}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_putstatic(int, int, ConstantPoolEntry)
+	 */
+	public void _putstatic(int pc, int index, ConstantPoolEntry constantFieldref) {
+		dumpPcNumber(pc);
+		this.buffer.append(NLS.bind(Messages.classformat_putstatic, new String[] {OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.PUTSTATIC], returnDeclaringClassName(constantFieldref), new String(constantFieldref.getFieldName()), returnClassName(Signature.toCharArray(constantFieldref.getFieldDescriptor()))}));
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_ret(int, int)
+	 */
+	public void _ret(int pc, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.RET]).append(Messages.disassembler_space).append(index);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_return(int)
+	 */
+	public void _return(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.RETURN]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_saload(int)
+	 */
+	public void _saload(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.SALOAD]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_sastore(int)
+	 */
+	public void _sastore(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.SASTORE]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_sipush(int, short)
+	 */
+	public void _sipush(int pc, short value) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.SIPUSH]).append(Messages.disassembler_space).append(value);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_swap(int)
+	 */
+	public void _swap(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.SWAP]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_tableswitch(int, int, int, int, int[])
+	 */
+	public void _tableswitch(int pc, int defaultoffset, int low, int high, int[] jump_offsets) {
+
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.TABLESWITCH]).append(" default: ") //$NON-NLS-1$
+				.append(defaultoffset + pc);
+		writeNewLine();
+		for (int i = low; i < high + 1; i++) {
+			writeExtraTabs(3);
+			this.buffer.append("case ") //$NON-NLS-1$
+					.append(i).append(": ") //$NON-NLS-1$
+					.append(jump_offsets[i - low] + pc);
+			writeNewLine();
+		}
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_wide(int, int, int)
+	 */
+	public void _wide(int pc, int iincopcode, int index, int _const) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.WIDE]);
+		writeNewLine();
+		_iinc(pc + 1, index, _const);
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_wide(int, int, int)
+	 */
+	public void _wide(int pc, int opcode, int index) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.WIDE]);
+		writeNewLine();
+		switch (opcode) {
+			case IOpcodeMnemonics.ILOAD :
+				_iload(pc + 1, index);
+				break;
+			case IOpcodeMnemonics.FLOAD :
+				_fload(pc + 1, index);
+				break;
+			case IOpcodeMnemonics.ALOAD :
+				_aload(pc + 1, index);
+				break;
+			case IOpcodeMnemonics.LLOAD :
+				_lload(pc + 1, index);
+				break;
+			case IOpcodeMnemonics.DLOAD :
+				_dload(pc + 1, index);
+				break;
+			case IOpcodeMnemonics.ISTORE :
+				_istore(pc + 1, index);
+				break;
+			case IOpcodeMnemonics.FSTORE :
+				_fstore(pc + 1, index);
+				break;
+			case IOpcodeMnemonics.ASTORE :
+				_astore(pc + 1, index);
+				break;
+			case IOpcodeMnemonics.LSTORE :
+				_lstore(pc + 1, index);
+				break;
+			case IOpcodeMnemonics.DSTORE :
+				_dstore(pc + 1, index);
+				break;
+			case IOpcodeMnemonics.RET :
+				_ret(pc + 1, index);
+		}
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_breakpoint(int)
+	 */
+	public void _breakpoint(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.BREAKPOINT]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_impdep1(int)
+	 */
+	public void _impdep1(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IMPDEP1]);
+		writeNewLine();
+	}
+
+	/**
+	 * @see IBytecodeVisitor#_impdep2(int)
+	 */
+	public void _impdep2(int pc) {
+		dumpPcNumber(pc);
+		this.buffer.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IMPDEP2]);
+		writeNewLine();
+	}
+
+	private boolean isCompact() {
+		return (this.mode & Disassembler.COMPACT) != 0;
+	}
+
+	private String returnConstantClassName(ConstantPoolEntry constantClass) {
+		char[] className = constantClass.getClassInfoName();
+		if (className.length == 0) {
+			return EMPTY_CLASS_NAME;
+		}
+		switch (className[0]) {
+			case '[' :
+				StringBuffer classNameBuffer = new StringBuffer();
+				Utility.appendTypeSignature(className, 0, classNameBuffer, isCompact());
+				return classNameBuffer.toString();
+			default :
+				return returnClassName(className);
+		}
+	}
+
+	private String returnClassName(char[] classInfoName) {
+		if (classInfoName.length == 0) {
+			return EMPTY_CLASS_NAME;
+		} else if (isCompact()) {
+			int lastIndexOfSlash = CharOperation.lastIndexOf('/', classInfoName);
+			if (lastIndexOfSlash != -1) {
+				return new String(classInfoName, lastIndexOfSlash + 1, classInfoName.length - lastIndexOfSlash - 1);
+			}
+		}
+		CharOperation.replace(classInfoName, '/', '.');
+		return new String(classInfoName);
+	}
+
+	private String returnDeclaringClassName(ConstantPoolEntry constantRef) {
+		final char[] className = constantRef.getClassName();
+		return returnClassName(className);
+	}
+
+	private String returnMethodSignature(ConstantPoolEntry constantMethodref) {
+		final char[] methodDescriptor = constantMethodref.getMethodDescriptor();
+		CharOperation.replace(methodDescriptor, '$', '#');
+		final char[] signature = Utility.toString(constantMethodref.getClassName(), constantMethodref.getMethodName(), methodDescriptor, true, isCompact()).toCharArray();
+		CharOperation.replace(signature, '#', '$');
+		return String.valueOf(signature);
+	}
+
+	private void writeNewLine() {
+		this.buffer.append(this.lineSeparator);
+	}
+
+	private void writeTabs() {
+		for (int i = 0, max = this.tabNumber; i < max; i++) {
+			this.buffer.append(Messages.disassembler_indentation);
+		}
+	}
+
+	private void writeExtraTabs(int extraTabs) {
+		for (int i = 0, max = this.tabNumber + extraTabs; i < max; i++) {
+			this.buffer.append(Messages.disassembler_indentation);
+		}
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Disassembler.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Disassembler.java
new file mode 100644
index 0000000..1feec44
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Disassembler.java
@@ -0,0 +1,1138 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+import java.util.Arrays;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * Disassembler of .class files. It generates an output in the Writer that looks close to
+ * the javap output.
+ */
+public class Disassembler {
+	/**
+	 * The mode is the detailed mode to disassemble ClassFileReader. It returns the magic
+	 * numbers, the version numbers and field and method descriptors.
+	 */
+	public final static int DETAILED = 1;
+
+	/**
+	 * This mode is used to compact the class name to a simple name instead of a qualified name.
+	 * @since 3.1
+	 */
+	public final static int COMPACT = 8;
+
+	private static final char[] ANY_EXCEPTION = Messages.classfileformat_anyexceptionhandler.toCharArray();
+	private static final String VERSION_UNKNOWN = Messages.classfileformat_versionUnknown;
+
+	private boolean appendModifier(StringBuffer buffer, int accessFlags, int modifierConstant, String modifier, boolean firstModifier) {
+		if ((accessFlags & modifierConstant) != 0) {
+			if (!firstModifier) {
+				buffer.append(Messages.disassembler_space);
+			}
+			if (firstModifier) {
+				firstModifier = false;
+			}
+			buffer.append(modifier);
+		}
+		return firstModifier;
+	}
+
+	private void decodeModifiers(StringBuffer buffer, int accessFlags, int[] checkBits) {
+		decodeModifiers(buffer, accessFlags, false, false, checkBits);
+	}
+
+	private void decodeModifiers(StringBuffer buffer, int accessFlags, boolean printDefault, boolean asBridge, int[] checkBits) {
+		if (checkBits == null)
+			return;
+		boolean firstModifier = true;
+		for (int i = 0, max = checkBits.length; i < max; i++) {
+			switch (checkBits[i]) {
+				case IModifierConstants.ACC_PUBLIC :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_PUBLIC, "public", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_PROTECTED :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_PROTECTED, "protected", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_PRIVATE :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_PRIVATE, "private", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_ABSTRACT :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_ABSTRACT, "abstract", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_STATIC :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_STATIC, "static", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_FINAL :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_FINAL, "final", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_SYNCHRONIZED :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_SYNCHRONIZED, "synchronized", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_NATIVE :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_NATIVE, "native", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_STRICT :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_STRICT, "strictfp", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_TRANSIENT :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_TRANSIENT, "transient", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_VOLATILE :
+					// case IModifierConstants.ACC_BRIDGE :
+					if (asBridge) {
+						firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_BRIDGE, "bridge", firstModifier); //$NON-NLS-1$
+					} else {
+						firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_VOLATILE, "volatile", firstModifier); //$NON-NLS-1$
+					}
+					break;
+				case IModifierConstants.ACC_ENUM :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_ENUM, "enum", firstModifier); //$NON-NLS-1$
+					break;
+			}
+		}
+		if (!firstModifier) {
+			if (!printDefault)
+				buffer.append(Messages.disassembler_space);
+		} else if (printDefault) {
+			// no modifier: package default visibility
+			buffer.append("default"); //$NON-NLS-1$
+		}
+	}
+
+	private void decodeModifiersForField(StringBuffer buffer, int accessFlags) {
+		decodeModifiers(buffer, accessFlags, new int[] {IModifierConstants.ACC_PUBLIC, IModifierConstants.ACC_PROTECTED, IModifierConstants.ACC_PRIVATE, IModifierConstants.ACC_STATIC, IModifierConstants.ACC_FINAL, IModifierConstants.ACC_TRANSIENT, IModifierConstants.ACC_VOLATILE, IModifierConstants.ACC_ENUM});
+	}
+
+	private final void decodeModifiersForInnerClasses(StringBuffer buffer, int accessFlags, boolean printDefault) {
+		decodeModifiers(buffer, accessFlags, printDefault, false, new int[] {IModifierConstants.ACC_PUBLIC, IModifierConstants.ACC_PROTECTED, IModifierConstants.ACC_PRIVATE, IModifierConstants.ACC_ABSTRACT, IModifierConstants.ACC_STATIC, IModifierConstants.ACC_FINAL,});
+	}
+
+	private final void decodeModifiersForMethod(StringBuffer buffer, int accessFlags) {
+		decodeModifiers(buffer, accessFlags, false, true, new int[] {IModifierConstants.ACC_PUBLIC, IModifierConstants.ACC_PROTECTED, IModifierConstants.ACC_PRIVATE, IModifierConstants.ACC_ABSTRACT, IModifierConstants.ACC_STATIC, IModifierConstants.ACC_FINAL, IModifierConstants.ACC_SYNCHRONIZED, IModifierConstants.ACC_NATIVE, IModifierConstants.ACC_STRICT, IModifierConstants.ACC_BRIDGE,});
+	}
+
+	private final void decodeModifiersForType(StringBuffer buffer, int accessFlags) {
+		decodeModifiers(buffer, accessFlags, new int[] {IModifierConstants.ACC_PUBLIC, IModifierConstants.ACC_ABSTRACT, IModifierConstants.ACC_FINAL,});
+	}
+
+	public static String escapeString(String s) {
+		StringBuffer buffer = new StringBuffer();
+		for (int i = 0, max = s.length(); i < max; i++) {
+			char c = s.charAt(i);
+			switch (c) {
+				case '\b' :
+					buffer.append("\\b"); //$NON-NLS-1$
+					break;
+				case '\t' :
+					buffer.append("\\t"); //$NON-NLS-1$
+					break;
+				case '\n' :
+					buffer.append("\\n"); //$NON-NLS-1$
+					break;
+				case '\f' :
+					buffer.append("\\f"); //$NON-NLS-1$
+					break;
+				case '\r' :
+					buffer.append("\\r"); //$NON-NLS-1$
+					break;
+				case '\0' :
+					buffer.append("\\0"); //$NON-NLS-1$
+					break;
+				case '\1' :
+					buffer.append("\\1"); //$NON-NLS-1$
+					break;
+				case '\2' :
+					buffer.append("\\2"); //$NON-NLS-1$
+					break;
+				case '\3' :
+					buffer.append("\\3"); //$NON-NLS-1$
+					break;
+				case '\4' :
+					buffer.append("\\4"); //$NON-NLS-1$
+					break;
+				case '\5' :
+					buffer.append("\\5"); //$NON-NLS-1$
+					break;
+				case '\6' :
+					buffer.append("\\6"); //$NON-NLS-1$
+					break;
+				case '\7' :
+					buffer.append("\\7"); //$NON-NLS-1$
+					break;
+				default :
+					buffer.append(c);
+			}
+		}
+		return buffer.toString();
+	}
+
+	static String decodeStringValue(char[] chars) {
+		StringBuffer buffer = new StringBuffer();
+		for (int i = 0, max = chars.length; i < max; i++) {
+			char c = chars[i];
+			switch (c) {
+				case '\b' :
+					buffer.append("\\b"); //$NON-NLS-1$
+					break;
+				case '\t' :
+					buffer.append("\\t"); //$NON-NLS-1$
+					break;
+				case '\n' :
+					buffer.append("\\n"); //$NON-NLS-1$
+					break;
+				case '\f' :
+					buffer.append("\\f"); //$NON-NLS-1$
+					break;
+				case '\r' :
+					buffer.append("\\r"); //$NON-NLS-1$
+					break;
+				case '\0' :
+					buffer.append("\\0"); //$NON-NLS-1$
+					break;
+				case '\1' :
+					buffer.append("\\1"); //$NON-NLS-1$
+					break;
+				case '\2' :
+					buffer.append("\\2"); //$NON-NLS-1$
+					break;
+				case '\3' :
+					buffer.append("\\3"); //$NON-NLS-1$
+					break;
+				case '\4' :
+					buffer.append("\\4"); //$NON-NLS-1$
+					break;
+				case '\5' :
+					buffer.append("\\5"); //$NON-NLS-1$
+					break;
+				case '\6' :
+					buffer.append("\\6"); //$NON-NLS-1$
+					break;
+				case '\7' :
+					buffer.append("\\7"); //$NON-NLS-1$
+					break;
+				default :
+					buffer.append(c);
+			}
+		}
+		return buffer.toString();
+	}
+
+	static String decodeStringValue(String s) {
+		return decodeStringValue(s.toCharArray());
+	}
+
+	/**
+	 * @see org.eclipse.jdt.core.util.ClassFileBytesDisassembler#disassemble(byte[], java.lang.String, int)
+	 */
+	public String disassemble(byte[] classFileBytes, String lineSeparator, int mode) throws ClassFormatException {
+		try {
+			return disassemble(new ClassFileReader(classFileBytes, ClassFileReader.ALL), lineSeparator, mode);
+		} catch (ArrayIndexOutOfBoundsException e) {
+			throw new ClassFormatException(e.getMessage(), e);
+		}
+	}
+
+	private void disassemble(Annotation annotation, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		final char[] typeName = CharOperation.replaceOnCopy(annotation.getTypeName(), '/', '.');
+		buffer.append(NLS.bind(Messages.disassembler_annotationentrystart, new String[] {new String(returnClassName(Signature.toCharArray(typeName), '.', mode))}));
+		final AnnotationComponent[] components = annotation.getComponents();
+		for (int i = 0, max = components.length; i < max; i++) {
+			disassemble(components[i], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		buffer.append(Messages.disassembler_annotationentryend);
+	}
+
+	private void disassemble(AnnotationComponent annotationComponent, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		buffer.append(NLS.bind(Messages.disassembler_annotationcomponent, new String[] {new String(annotationComponent.getComponentName())}));
+		disassemble(annotationComponent.getComponentValue(), buffer, lineSeparator, tabNumber + 1, mode);
+	}
+
+	private void disassemble(AnnotationComponentValue annotationComponentValue, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		switch (annotationComponentValue.getTag()) {
+			case AnnotationComponentValue.BYTE_TAG :
+			case AnnotationComponentValue.CHAR_TAG :
+			case AnnotationComponentValue.DOUBLE_TAG :
+			case AnnotationComponentValue.FLOAT_TAG :
+			case AnnotationComponentValue.INTEGER_TAG :
+			case AnnotationComponentValue.LONG_TAG :
+			case AnnotationComponentValue.SHORT_TAG :
+			case AnnotationComponentValue.BOOLEAN_TAG :
+			case AnnotationComponentValue.STRING_TAG :
+				ConstantPoolEntry constantPoolEntry = annotationComponentValue.getConstantValue();
+				String value = null;
+				switch (constantPoolEntry.getKind()) {
+					case ConstantPoolConstant.CONSTANT_Long :
+						value = constantPoolEntry.getLongValue() + "L"; //$NON-NLS-1$
+						break;
+					case ConstantPoolConstant.CONSTANT_Float :
+						value = constantPoolEntry.getFloatValue() + "f"; //$NON-NLS-1$
+						break;
+					case ConstantPoolConstant.CONSTANT_Double :
+						value = Double.toString(constantPoolEntry.getDoubleValue());
+						break;
+					case ConstantPoolConstant.CONSTANT_Integer :
+						switch (annotationComponentValue.getTag()) {
+							case AnnotationComponentValue.CHAR_TAG :
+								value = "'" + (char) constantPoolEntry.getIntegerValue() + "'"; //$NON-NLS-1$//$NON-NLS-2$
+								break;
+							case AnnotationComponentValue.BOOLEAN_TAG :
+								value = constantPoolEntry.getIntegerValue() == 1 ? "true" : "false";//$NON-NLS-1$//$NON-NLS-2$
+								break;
+							case AnnotationComponentValue.BYTE_TAG :
+								value = "(byte) " + constantPoolEntry.getIntegerValue(); //$NON-NLS-1$
+								break;
+							case AnnotationComponentValue.SHORT_TAG :
+								value = "(short) " + constantPoolEntry.getIntegerValue(); //$NON-NLS-1$
+								break;
+							case AnnotationComponentValue.INTEGER_TAG :
+								value = "(int) " + constantPoolEntry.getIntegerValue(); //$NON-NLS-1$
+						}
+						break;
+					case ConstantPoolConstant.CONSTANT_Utf8 :
+						value = "\"" + decodeStringValue(constantPoolEntry.getUtf8Value()) + "\"";//$NON-NLS-1$//$NON-NLS-2$
+				}
+				buffer.append(NLS.bind(Messages.disassembler_annotationdefaultvalue, value));
+				break;
+			case AnnotationComponentValue.ENUM_TAG :
+				final char[] typeName = CharOperation.replaceOnCopy(annotationComponentValue.getEnumConstantTypeName(), '/', '.');
+				final char[] constantName = annotationComponentValue.getEnumConstantName();
+				buffer.append(NLS.bind(Messages.disassembler_annotationenumvalue, new String[] {new String(returnClassName(Signature.toCharArray(typeName), '.', mode)), new String(constantName)}));
+				break;
+			case AnnotationComponentValue.CLASS_TAG :
+				constantPoolEntry = annotationComponentValue.getClassInfo();
+				final char[] className = CharOperation.replaceOnCopy(constantPoolEntry.getUtf8Value(), '/', '.');
+				buffer.append(NLS.bind(Messages.disassembler_annotationclassvalue, new String[] {new String(returnClassName(Signature.toCharArray(className), '.', mode))}));
+				break;
+			case AnnotationComponentValue.ANNOTATION_TAG :
+				buffer.append(Messages.disassembler_annotationannotationvalue);
+				Annotation annotation = annotationComponentValue.getAnnotationValue();
+				disassemble(annotation, buffer, lineSeparator, tabNumber + 1, mode);
+				break;
+			case AnnotationComponentValue.ARRAY_TAG :
+				buffer.append(Messages.disassembler_annotationarrayvaluestart);
+				final AnnotationComponentValue[] annotationComponentValues = annotationComponentValue.getAnnotationComponentValues();
+				for (int i = 0, max = annotationComponentValues.length; i < max; i++) {
+					writeNewLine(buffer, lineSeparator, tabNumber + 1);
+					disassemble(annotationComponentValues[i], buffer, lineSeparator, tabNumber + 1, mode);
+				}
+				writeNewLine(buffer, lineSeparator, tabNumber + 1);
+				buffer.append(Messages.disassembler_annotationarrayvalueend);
+		}
+	}
+
+	private void disassemble(AnnotationDefaultAttribute annotationDefaultAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		buffer.append(Messages.disassembler_annotationdefaultheader);
+		AnnotationComponentValue componentValue = annotationDefaultAttribute.getMemberValue();
+		writeNewLine(buffer, lineSeparator, tabNumber + 2);
+		disassemble(componentValue, buffer, lineSeparator, tabNumber + 1, mode);
+	}
+
+	/**
+	 * Disassemble a method info header
+	 */
+	private void disassemble(ClassFileReader classFileReader, char[] className, MethodInfo methodInfo, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber);
+		final CodeAttribute codeAttribute = methodInfo.getCodeAttribute();
+		final char[] methodDescriptor = methodInfo.getDescriptor();
+		final SignatureAttribute signatureAttribute = (SignatureAttribute) Utility.getAttribute(methodInfo, AttributeNamesConstants.SIGNATURE);
+		final ClassFileAttribute runtimeVisibleAnnotationsAttribute = Utility.getAttribute(methodInfo, AttributeNamesConstants.RUNTIME_VISIBLE_ANNOTATIONS);
+		final ClassFileAttribute runtimeInvisibleAnnotationsAttribute = Utility.getAttribute(methodInfo, AttributeNamesConstants.RUNTIME_INVISIBLE_ANNOTATIONS);
+		final ClassFileAttribute runtimeVisibleParameterAnnotationsAttribute = Utility.getAttribute(methodInfo, AttributeNamesConstants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS);
+		final ClassFileAttribute runtimeInvisibleParameterAnnotationsAttribute = Utility.getAttribute(methodInfo, AttributeNamesConstants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS);
+		final ClassFileAttribute annotationDefaultAttribute = Utility.getAttribute(methodInfo, AttributeNamesConstants.ANNOTATION_DEFAULT);
+		if (checkMode(mode, DETAILED)) {
+			buffer.append(NLS.bind(Messages.classfileformat_methoddescriptor, new String[] {new String(methodDescriptor)}));
+			if (methodInfo.isDeprecated()) {
+				buffer.append(Messages.disassembler_deprecated);
+			}
+			writeNewLine(buffer, lineSeparator, tabNumber);
+			if (signatureAttribute != null) {
+				buffer.append(NLS.bind(Messages.disassembler_signatureattributeheader, new String(signatureAttribute.getSignature())));
+				writeNewLine(buffer, lineSeparator, tabNumber);
+			}
+			if (codeAttribute != null) {
+				buffer.append(NLS.bind(Messages.classfileformat_stacksAndLocals, new String[] {Integer.toString(codeAttribute.getMaxStack()), Integer.toString(codeAttribute.getMaxLocals())}));
+				writeNewLine(buffer, lineSeparator, tabNumber);
+			}
+			// disassemble compact version of annotations
+			if (runtimeInvisibleAnnotationsAttribute != null) {
+				disassembleAsModifier((RuntimeInvisibleAnnotationsAttribute) runtimeInvisibleAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
+				writeNewLine(buffer, lineSeparator, tabNumber);
+			}
+			if (runtimeVisibleAnnotationsAttribute != null) {
+				disassembleAsModifier((RuntimeVisibleAnnotationsAttribute) runtimeVisibleAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
+				writeNewLine(buffer, lineSeparator, tabNumber);
+			}
+		}
+		final int accessFlags = methodInfo.getAccessFlags();
+		decodeModifiersForMethod(buffer, accessFlags);
+		if (methodInfo.isSynthetic()) {
+			buffer.append("synthetic"); //$NON-NLS-1$
+			buffer.append(Messages.disassembler_space);
+		}
+		CharOperation.replace(methodDescriptor, '/', '.');
+		final boolean isVarArgs = isVarArgs(methodInfo);
+		char[] methodHeader = null;
+		if (methodInfo.isConstructor()) {
+			methodHeader = Signature.toCharArray(methodDescriptor, returnClassName(className, '.', COMPACT), null, !checkMode(mode, COMPACT), false, isVarArgs);
+		} else if (methodInfo.isClinit()) {
+			methodHeader = Messages.classfileformat_clinitname.toCharArray();
+		} else {
+			methodHeader = Signature.toCharArray(methodDescriptor, methodInfo.getName(), null, !checkMode(mode, COMPACT), true, isVarArgs);
+		}
+		if (checkMode(mode, DETAILED) && (runtimeInvisibleParameterAnnotationsAttribute != null || runtimeVisibleParameterAnnotationsAttribute != null)) {
+			ParameterAnnotation[] invisibleParameterAnnotations = null;
+			ParameterAnnotation[] visibleParameterAnnotations = null;
+			int length = -1;
+			if (runtimeInvisibleParameterAnnotationsAttribute != null) {
+				RuntimeInvisibleParameterAnnotationsAttribute attribute = (RuntimeInvisibleParameterAnnotationsAttribute) runtimeInvisibleParameterAnnotationsAttribute;
+				invisibleParameterAnnotations = attribute.getParameterAnnotations();
+				length = invisibleParameterAnnotations.length;
+			}
+			if (runtimeVisibleParameterAnnotationsAttribute != null) {
+				RuntimeVisibleParameterAnnotationsAttribute attribute = (RuntimeVisibleParameterAnnotationsAttribute) runtimeVisibleParameterAnnotationsAttribute;
+				visibleParameterAnnotations = attribute.getParameterAnnotations();
+				length = visibleParameterAnnotations.length;
+			}
+			int insertionPosition = CharOperation.indexOf('(', methodHeader) + 1;
+			int start = 0;
+			StringBuffer stringBuffer = new StringBuffer();
+			stringBuffer.append(methodHeader, 0, insertionPosition);
+			for (int i = 0; i < length; i++) {
+				if (i > 0) {
+					stringBuffer.append(' ');
+				}
+				int stringBufferSize = stringBuffer.length();
+				if (runtimeVisibleParameterAnnotationsAttribute != null) {
+					disassembleAsModifier((RuntimeVisibleParameterAnnotationsAttribute) runtimeVisibleParameterAnnotationsAttribute, stringBuffer, i, lineSeparator, tabNumber, mode);
+				}
+				if (runtimeInvisibleParameterAnnotationsAttribute != null) {
+					if (stringBuffer.length() != stringBufferSize) {
+						stringBuffer.append(' ');
+						stringBufferSize = stringBuffer.length();
+					}
+					disassembleAsModifier((RuntimeInvisibleParameterAnnotationsAttribute) runtimeInvisibleParameterAnnotationsAttribute, stringBuffer, i, lineSeparator, tabNumber, mode);
+				}
+				if (i == 0 && stringBuffer.length() != stringBufferSize) {
+					stringBuffer.append(' ');
+				}
+				start = insertionPosition;
+				insertionPosition = CharOperation.indexOf(',', methodHeader, start + 1) + 1;
+				if (insertionPosition == 0) {
+					stringBuffer.append(methodHeader, start, methodHeader.length - start);
+				} else {
+					stringBuffer.append(methodHeader, start, insertionPosition - start);
+				}
+			}
+			buffer.append(stringBuffer);
+		} else {
+			buffer.append(methodHeader);
+		}
+		ExceptionAttribute exceptionAttribute = methodInfo.getExceptionAttribute();
+		if (exceptionAttribute != null) {
+			buffer.append(" throws "); //$NON-NLS-1$
+			char[][] exceptionNames = exceptionAttribute.getExceptionNames();
+			int length = exceptionNames.length;
+			for (int i = 0; i < length; i++) {
+				if (i != 0) {
+					buffer.append(Messages.disassembler_comma).append(Messages.disassembler_space);
+				}
+				char[] exceptionName = exceptionNames[i];
+				CharOperation.replace(exceptionName, '/', '.');
+				buffer.append(returnClassName(exceptionName, '.', mode));
+			}
+		}
+		if (checkMode(mode, DETAILED)) {
+			if (annotationDefaultAttribute != null) {
+				buffer.append(" default "); //$NON-NLS-1$
+				disassembleAsModifier((AnnotationDefaultAttribute) annotationDefaultAttribute, buffer, lineSeparator, tabNumber, mode);
+			}
+		}
+		buffer.append(Messages.disassembler_endofmethodheader);
+
+		if (checkMode(mode, DETAILED)) {
+			if (codeAttribute != null) {
+				disassemble(codeAttribute, methodDescriptor, (accessFlags & IModifierConstants.ACC_STATIC) != 0, buffer, lineSeparator, tabNumber, mode);
+			}
+			if (annotationDefaultAttribute != null) {
+				disassemble((AnnotationDefaultAttribute) annotationDefaultAttribute, buffer, lineSeparator, tabNumber, mode);
+			}
+			if (runtimeVisibleAnnotationsAttribute != null) {
+				disassemble((RuntimeVisibleAnnotationsAttribute) runtimeVisibleAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
+			}
+			if (runtimeInvisibleAnnotationsAttribute != null) {
+				disassemble((RuntimeInvisibleAnnotationsAttribute) runtimeInvisibleAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
+			}
+			if (runtimeVisibleParameterAnnotationsAttribute != null) {
+				disassemble((RuntimeVisibleParameterAnnotationsAttribute) runtimeVisibleParameterAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
+			}
+			if (runtimeInvisibleParameterAnnotationsAttribute != null) {
+				disassemble((RuntimeInvisibleParameterAnnotationsAttribute) runtimeInvisibleParameterAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
+			}
+		}
+	}
+
+	/**
+	 * @see #disassemble(org.eclipse.jdt.core.util.ClassFileReader, java.lang.String, int)
+	 */
+	public String disassemble(ClassFileReader classFileReader, String lineSeparator) {
+		return disassemble(classFileReader, lineSeparator, Disassembler.DETAILED);
+	}
+
+	/**
+	 * Answers back the disassembled string of the ClassFileReader according to the
+	 * mode.
+	 * This is an output quite similar to the javap tool.
+	 *
+	 * @param classFileReader The classFileReader to be disassembled
+	 * @param lineSeparator the line separator to use.
+	 * @param mode the mode used to disassemble the ClassFileReader
+	 *
+	 * @return the disassembled string of the ClassFileReader according to the mode
+	 */
+	public String disassemble(ClassFileReader classFileReader, String lineSeparator, int mode) {
+		if (classFileReader == null)
+			return Utility.EMPTY_STRING;
+		char[] className = classFileReader.getClassName();
+		if (className == null) {
+			// incomplete initialization. We cannot go further.
+			return Utility.EMPTY_STRING;
+		}
+		className = CharOperation.replaceOnCopy(className, '/', '.');
+		final int accessFlags = classFileReader.getAccessFlags();
+		final boolean isEnum = (accessFlags & IModifierConstants.ACC_ENUM) != 0;
+
+		StringBuffer buffer = new StringBuffer();
+		SourceFileAttribute sourceAttribute = classFileReader.getSourceFileAttribute();
+		ClassFileAttribute classFileAttribute = Utility.getAttribute(classFileReader, AttributeNamesConstants.SIGNATURE);
+		SignatureAttribute signatureAttribute = (SignatureAttribute) classFileAttribute;
+		if (checkMode(mode, DETAILED)) {
+			int minorVersion = classFileReader.getMinorVersion();
+			int majorVersion = classFileReader.getMajorVersion();
+			buffer.append(Messages.disassembler_begincommentline);
+			if (sourceAttribute != null) {
+				buffer.append(Messages.disassembler_sourceattributeheader);
+				buffer.append(sourceAttribute.getSourceFileName());
+			}
+			String versionNumber = VERSION_UNKNOWN;
+			if (minorVersion == 3 && majorVersion == 45) {
+				versionNumber = IModifierConstants.VERSION_1_1;
+			} else if (minorVersion == 0 && majorVersion == 46) {
+				versionNumber = IModifierConstants.VERSION_1_2;
+			} else if (minorVersion == 0 && majorVersion == 47) {
+				versionNumber = IModifierConstants.VERSION_1_3;
+			} else if (minorVersion == 0 && majorVersion == 48) {
+				versionNumber = IModifierConstants.VERSION_1_4;
+			} else if (minorVersion == 0 && majorVersion == 49) {
+				versionNumber = IModifierConstants.VERSION_1_5;
+			} else if (minorVersion == 0 && majorVersion == 50) {
+				versionNumber = IModifierConstants.VERSION_1_6;
+			} else if (minorVersion == 0 && majorVersion == 51) {
+				versionNumber = IModifierConstants.VERSION_1_7;
+			}
+			buffer.append(NLS.bind(Messages.classfileformat_versiondetails, new String[] {versionNumber, Integer.toString(majorVersion), Integer.toString(minorVersion), ((accessFlags & IModifierConstants.ACC_SUPER) != 0 ? Messages.classfileformat_superflagisset : Messages.classfileformat_superflagisnotset) + (isDeprecated(classFileReader) ? ", deprecated" : Utility.EMPTY_STRING)//$NON-NLS-1$
+			}));
+			writeNewLine(buffer, lineSeparator, 0);
+			if (signatureAttribute != null) {
+				buffer.append(NLS.bind(Messages.disassembler_signatureattributeheader, new String(signatureAttribute.getSignature())));
+				writeNewLine(buffer, lineSeparator, 0);
+			}
+		}
+
+		InnerClassesAttribute innerClassesAttribute = classFileReader.getInnerClassesAttribute();
+		ClassFileAttribute runtimeVisibleAnnotationsAttribute = Utility.getAttribute(classFileReader, AttributeNamesConstants.RUNTIME_VISIBLE_ANNOTATIONS);
+		ClassFileAttribute runtimeInvisibleAnnotationsAttribute = Utility.getAttribute(classFileReader, AttributeNamesConstants.RUNTIME_INVISIBLE_ANNOTATIONS);
+
+		if (checkMode(mode, DETAILED)) {
+			// disassemble compact version of annotations
+			if (runtimeInvisibleAnnotationsAttribute != null) {
+				disassembleAsModifier((RuntimeInvisibleAnnotationsAttribute) runtimeInvisibleAnnotationsAttribute, buffer, lineSeparator, 0, mode);
+				writeNewLine(buffer, lineSeparator, 0);
+			}
+			if (runtimeVisibleAnnotationsAttribute != null) {
+				disassembleAsModifier((RuntimeVisibleAnnotationsAttribute) runtimeVisibleAnnotationsAttribute, buffer, lineSeparator, 0, mode);
+				writeNewLine(buffer, lineSeparator, 0);
+			}
+		}
+		boolean decoded = false;
+		if (innerClassesAttribute != null) {
+			// search the right entry
+			InnerClassesAttributeEntry[] entries = innerClassesAttribute.getInnerClassAttributesEntries();
+			for (int i = 0, max = entries.length; i < max; i++) {
+				InnerClassesAttributeEntry entry = entries[i];
+				char[] innerClassName = entry.getInnerClassName();
+				if (innerClassName != null) {
+					if (Arrays.equals(classFileReader.getClassName(), innerClassName)) {
+						decodeModifiersForInnerClasses(buffer, entry.getAccessFlags(), false);
+						decoded = true;
+					}
+				}
+			}
+		}
+		if (!decoded) {
+			decodeModifiersForType(buffer, accessFlags);
+			if (isSynthetic(classFileReader)) {
+				buffer.append("synthetic"); //$NON-NLS-1$
+				buffer.append(Messages.disassembler_space);
+			}
+		}
+
+		final boolean isAnnotation = (accessFlags & IModifierConstants.ACC_ANNOTATION) != 0;
+		boolean isInterface = false;
+		if (isEnum) {
+			buffer.append("enum "); //$NON-NLS-1$
+		} else if (classFileReader.isClass()) {
+			buffer.append("class "); //$NON-NLS-1$
+		} else {
+			if (isAnnotation) {
+				buffer.append("@"); //$NON-NLS-1$
+			}
+			buffer.append("interface "); //$NON-NLS-1$
+			isInterface = true;
+		}
+
+		buffer.append(className);
+
+		char[] superclassName = classFileReader.getSuperclassName();
+		if (superclassName != null) {
+			CharOperation.replace(superclassName, '/', '.');
+			if (!isJavaLangObject(superclassName) && !isEnum) {
+				buffer.append(" extends "); //$NON-NLS-1$
+				buffer.append(returnClassName(superclassName, '.', mode));
+			}
+		}
+		if (!isAnnotation) {
+			char[][] superclassInterfaces = classFileReader.getInterfaceNames();
+			int length = superclassInterfaces.length;
+			if (length != 0) {
+				if (isInterface) {
+					buffer.append(" extends "); //$NON-NLS-1$
+				} else {
+					buffer.append(" implements "); //$NON-NLS-1$
+				}
+				for (int i = 0; i < length; i++) {
+					if (i != 0) {
+						buffer.append(Messages.disassembler_comma).append(Messages.disassembler_space);
+					}
+					char[] superinterface = superclassInterfaces[i];
+					CharOperation.replace(superinterface, '/', '.');
+					buffer.append(returnClassName(superinterface, '.', mode));
+				}
+			}
+		}
+		buffer.append(Messages.disassembler_opentypedeclaration);
+		disassembleTypeMembers(classFileReader, className, buffer, lineSeparator, 1, mode, isEnum);
+		if (checkMode(mode, DETAILED)) {
+			ClassFileAttribute[] attributes = classFileReader.getAttributes();
+			int length = attributes.length;
+			EnclosingMethodAttribute enclosingMethodAttribute = getEnclosingMethodAttribute(classFileReader);
+			int remainingAttributesLength = length;
+			if (innerClassesAttribute != null) {
+				remainingAttributesLength--;
+			}
+			if (enclosingMethodAttribute != null) {
+				remainingAttributesLength--;
+			}
+			if (sourceAttribute != null) {
+				remainingAttributesLength--;
+			}
+			if (signatureAttribute != null) {
+				remainingAttributesLength--;
+			}
+			if (innerClassesAttribute != null || enclosingMethodAttribute != null || remainingAttributesLength != 0) {
+				writeNewLine(buffer, lineSeparator, 0);
+			}
+			if (innerClassesAttribute != null) {
+				disassemble(innerClassesAttribute, buffer, lineSeparator, 1);
+			}
+			if (enclosingMethodAttribute != null) {
+				disassemble(enclosingMethodAttribute, buffer, lineSeparator, 0);
+			}
+			if (runtimeVisibleAnnotationsAttribute != null) {
+				disassemble((RuntimeVisibleAnnotationsAttribute) runtimeVisibleAnnotationsAttribute, buffer, lineSeparator, 0, mode);
+			}
+			if (runtimeInvisibleAnnotationsAttribute != null) {
+				disassemble((RuntimeInvisibleAnnotationsAttribute) runtimeInvisibleAnnotationsAttribute, buffer, lineSeparator, 0, mode);
+			}
+		}
+		writeNewLine(buffer, lineSeparator, 0);
+		buffer.append(Messages.disassembler_closetypedeclaration);
+		return buffer.toString();
+	}
+
+	private boolean isJavaLangObject(final char[] className) {
+		return Arrays.equals(TypeConstants.JAVA_LANG_OBJECT, CharOperation.splitOn('.', className));
+	}
+
+	private boolean isVarArgs(MethodInfo methodInfo) {
+		int accessFlags = methodInfo.getAccessFlags();
+		if ((accessFlags & IModifierConstants.ACC_VARARGS) != 0)
+			return true;
+		// check the presence of the unspecified Varargs attribute
+		return Utility.getAttribute(methodInfo, AttributeNamesConstants.VAR_ARGS) != null;
+	}
+
+	private void disassemble(CodeAttribute codeAttribute, char[] methodDescriptor, boolean isStatic, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber - 1);
+		DefaultBytecodeVisitor visitor = new DefaultBytecodeVisitor(codeAttribute, methodDescriptor, isStatic, buffer, lineSeparator, tabNumber, mode);
+		try {
+			codeAttribute.traverse(visitor);
+		} catch (ClassFormatException e) {
+			dumpTab(tabNumber + 2, buffer);
+			buffer.append(Messages.classformat_classformatexception);
+			writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		}
+		final int exceptionTableLength = codeAttribute.getExceptionTableLength();
+		if (exceptionTableLength != 0) {
+			final int tabNumberForExceptionAttribute = tabNumber + 2;
+			dumpTab(tabNumberForExceptionAttribute, buffer);
+			final ExceptionTableEntry[] exceptionTableEntries = codeAttribute.getExceptionTable();
+			buffer.append(Messages.disassembler_exceptiontableheader);
+			writeNewLine(buffer, lineSeparator, tabNumberForExceptionAttribute + 1);
+			for (int i = 0; i < exceptionTableLength; i++) {
+				if (i != 0) {
+					writeNewLine(buffer, lineSeparator, tabNumberForExceptionAttribute + 1);
+				}
+				ExceptionTableEntry exceptionTableEntry = exceptionTableEntries[i];
+				char[] catchType;
+				if (exceptionTableEntry.getCatchTypeIndex() != 0) {
+					catchType = exceptionTableEntry.getCatchType();
+					CharOperation.replace(catchType, '/', '.');
+					catchType = returnClassName(catchType, '.', mode);
+				} else {
+					catchType = ANY_EXCEPTION;
+				}
+				buffer.append(NLS.bind(Messages.classfileformat_exceptiontableentry, new String[] {Integer.toString(exceptionTableEntry.getStartPC()), Integer.toString(exceptionTableEntry.getEndPC()), Integer.toString(exceptionTableEntry.getHandlerPC()), new String(catchType),}));
+			}
+		}
+	}
+
+	private void disassemble(EnclosingMethodAttribute enclosingMethodAttribute, StringBuffer buffer, String lineSeparator, int tabNumber) {
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		buffer.append(Messages.disassembler_enclosingmethodheader);
+		buffer.append(" ")//$NON-NLS-1$
+				.append(enclosingMethodAttribute.getEnclosingClass());
+		if (enclosingMethodAttribute.getMethodNameAndTypeIndex() != 0) {
+			buffer.append(".")//$NON-NLS-1$
+					.append(enclosingMethodAttribute.getMethodName()).append(enclosingMethodAttribute.getMethodDescriptor());
+		}
+	}
+
+	/**
+	 * Disassemble a field info
+	 */
+	private void disassemble(FieldInfo fieldInfo, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber);
+		final char[] fieldDescriptor = fieldInfo.getDescriptor();
+		final SignatureAttribute signatureAttribute = (SignatureAttribute) Utility.getAttribute(fieldInfo, AttributeNamesConstants.SIGNATURE);
+		if (checkMode(mode, DETAILED)) {
+			buffer.append(NLS.bind(Messages.classfileformat_fieldddescriptor, new String[] {new String(fieldDescriptor)}));
+			if (fieldInfo.isDeprecated()) {
+				buffer.append(Messages.disassembler_deprecated);
+			}
+			writeNewLine(buffer, lineSeparator, tabNumber);
+			if (signatureAttribute != null) {
+				buffer.append(NLS.bind(Messages.disassembler_signatureattributeheader, new String(signatureAttribute.getSignature())));
+				writeNewLine(buffer, lineSeparator, tabNumber);
+			}
+		}
+		final ClassFileAttribute runtimeVisibleAnnotationsAttribute = Utility.getAttribute(fieldInfo, AttributeNamesConstants.RUNTIME_VISIBLE_ANNOTATIONS);
+		final ClassFileAttribute runtimeInvisibleAnnotationsAttribute = Utility.getAttribute(fieldInfo, AttributeNamesConstants.RUNTIME_INVISIBLE_ANNOTATIONS);
+		if (checkMode(mode, DETAILED)) {
+			// disassemble compact version of annotations
+			if (runtimeInvisibleAnnotationsAttribute != null) {
+				disassembleAsModifier((RuntimeInvisibleAnnotationsAttribute) runtimeInvisibleAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
+				writeNewLine(buffer, lineSeparator, tabNumber);
+			}
+			if (runtimeVisibleAnnotationsAttribute != null) {
+				disassembleAsModifier((RuntimeVisibleAnnotationsAttribute) runtimeVisibleAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
+				writeNewLine(buffer, lineSeparator, tabNumber);
+			}
+		}
+		decodeModifiersForField(buffer, fieldInfo.getAccessFlags());
+		if (fieldInfo.isSynthetic()) {
+			buffer.append("synthetic"); //$NON-NLS-1$
+			buffer.append(Messages.disassembler_space);
+		}
+		buffer.append(returnClassName(getSignatureForField(fieldDescriptor), '.', mode));
+		buffer.append(' ');
+		buffer.append(new String(fieldInfo.getName()));
+		ConstantValueAttribute constantValueAttribute = fieldInfo.getConstantValueAttribute();
+		if (constantValueAttribute != null) {
+			buffer.append(Messages.disassembler_fieldhasconstant);
+			ConstantPoolEntry constantPoolEntry = constantValueAttribute.getConstantValue();
+			switch (constantPoolEntry.getKind()) {
+				case ConstantPoolConstant.CONSTANT_Long :
+					buffer.append(constantPoolEntry.getLongValue() + "L"); //$NON-NLS-1$
+					break;
+				case ConstantPoolConstant.CONSTANT_Float :
+					buffer.append(constantPoolEntry.getFloatValue() + "f"); //$NON-NLS-1$
+					break;
+				case ConstantPoolConstant.CONSTANT_Double :
+					buffer.append(constantPoolEntry.getDoubleValue());
+					break;
+				case ConstantPoolConstant.CONSTANT_Integer :
+					switch (fieldDescriptor[0]) {
+						case 'C' :
+							buffer.append("'" + (char) constantPoolEntry.getIntegerValue() + "'"); //$NON-NLS-1$//$NON-NLS-2$
+							break;
+						case 'Z' :
+							buffer.append(constantPoolEntry.getIntegerValue() == 1 ? "true" : "false");//$NON-NLS-1$//$NON-NLS-2$
+							break;
+						case 'B' :
+							buffer.append(constantPoolEntry.getIntegerValue());
+							break;
+						case 'S' :
+							buffer.append(constantPoolEntry.getIntegerValue());
+							break;
+						case 'I' :
+							buffer.append(constantPoolEntry.getIntegerValue());
+					}
+					break;
+				case ConstantPoolConstant.CONSTANT_String :
+					buffer.append("\"" + decodeStringValue(constantPoolEntry.getStringValue()) + "\"");//$NON-NLS-1$//$NON-NLS-2$
+			}
+		}
+		buffer.append(Messages.disassembler_endoffieldheader);
+		if (checkMode(mode, DETAILED)) {
+			if (runtimeVisibleAnnotationsAttribute != null) {
+				disassemble((RuntimeVisibleAnnotationsAttribute) runtimeVisibleAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
+			}
+			if (runtimeInvisibleAnnotationsAttribute != null) {
+				disassemble((RuntimeInvisibleAnnotationsAttribute) runtimeInvisibleAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
+			}
+		}
+	}
+
+	private void disassemble(InnerClassesAttribute innerClassesAttribute, StringBuffer buffer, String lineSeparator, int tabNumber) {
+		writeNewLine(buffer, lineSeparator, tabNumber);
+		buffer.append(Messages.disassembler_innerattributesheader);
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		InnerClassesAttributeEntry[] innerClassesAttributeEntries = innerClassesAttribute.getInnerClassAttributesEntries();
+		int length = innerClassesAttributeEntries.length;
+		int innerClassNameIndex, outerClassNameIndex, innerNameIndex, accessFlags;
+		InnerClassesAttributeEntry innerClassesAttributeEntry;
+		for (int i = 0; i < length; i++) {
+			if (i != 0) {
+				buffer.append(Messages.disassembler_comma);
+				writeNewLine(buffer, lineSeparator, tabNumber + 1);
+			}
+			innerClassesAttributeEntry = innerClassesAttributeEntries[i];
+			innerClassNameIndex = innerClassesAttributeEntry.getInnerClassNameIndex();
+			outerClassNameIndex = innerClassesAttributeEntry.getOuterClassNameIndex();
+			innerNameIndex = innerClassesAttributeEntry.getInnerNameIndex();
+			accessFlags = innerClassesAttributeEntry.getAccessFlags();
+			buffer.append(Messages.disassembler_openinnerclassentry).append(Messages.disassembler_inner_class_info_name);
+			if (innerClassNameIndex != 0) {
+				buffer.append(Messages.disassembler_space).append(innerClassesAttributeEntry.getInnerClassName());
+			}
+			buffer.append(Messages.disassembler_comma).append(Messages.disassembler_space).append(Messages.disassembler_outer_class_info_name);
+			if (outerClassNameIndex != 0) {
+				buffer.append(Messages.disassembler_space).append(innerClassesAttributeEntry.getOuterClassName());
+			}
+			writeNewLine(buffer, lineSeparator, tabNumber);
+			dumpTab(tabNumber, buffer);
+			buffer.append(Messages.disassembler_space);
+			buffer.append(Messages.disassembler_inner_name);
+			if (innerNameIndex != 0) {
+				buffer.append(Messages.disassembler_space).append(innerClassesAttributeEntry.getInnerName());
+			}
+			buffer.append(Messages.disassembler_comma).append(Messages.disassembler_space).append(Messages.disassembler_inner_accessflags).append(accessFlags).append(Messages.disassembler_space);
+			decodeModifiersForInnerClasses(buffer, accessFlags, true);
+			buffer.append(Messages.disassembler_closeinnerclassentry);
+		}
+	}
+
+	private void disassemble(int index, ParameterAnnotation parameterAnnotation, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		Annotation[] annotations = parameterAnnotation.getAnnotations();
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		buffer.append(NLS.bind(Messages.disassembler_parameterannotationentrystart, new String[] {Integer.toString(index), Integer.toString(annotations.length)}));
+		for (int i = 0, max = annotations.length; i < max; i++) {
+			disassemble(annotations[i], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+	}
+
+	private void disassemble(RuntimeInvisibleAnnotationsAttribute runtimeInvisibleAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		buffer.append(Messages.disassembler_runtimeinvisibleannotationsattributeheader);
+		Annotation[] annotations = runtimeInvisibleAnnotationsAttribute.getAnnotations();
+		for (int i = 0, max = annotations.length; i < max; i++) {
+			disassemble(annotations[i], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+	}
+
+	private void disassemble(RuntimeInvisibleParameterAnnotationsAttribute runtimeInvisibleParameterAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		buffer.append(Messages.disassembler_runtimeinvisibleparameterannotationsattributeheader);
+		ParameterAnnotation[] parameterAnnotations = runtimeInvisibleParameterAnnotationsAttribute.getParameterAnnotations();
+		for (int i = 0, max = parameterAnnotations.length; i < max; i++) {
+			disassemble(i, parameterAnnotations[i], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+	}
+
+	private void disassemble(RuntimeVisibleAnnotationsAttribute runtimeVisibleAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		buffer.append(Messages.disassembler_runtimevisibleannotationsattributeheader);
+		Annotation[] annotations = runtimeVisibleAnnotationsAttribute.getAnnotations();
+		for (int i = 0, max = annotations.length; i < max; i++) {
+			disassemble(annotations[i], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+	}
+
+	private void disassemble(RuntimeVisibleParameterAnnotationsAttribute runtimeVisibleParameterAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		buffer.append(Messages.disassembler_runtimevisibleparameterannotationsattributeheader);
+		ParameterAnnotation[] parameterAnnotations = runtimeVisibleParameterAnnotationsAttribute.getParameterAnnotations();
+		for (int i = 0, max = parameterAnnotations.length; i < max; i++) {
+			disassemble(i, parameterAnnotations[i], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+	}
+
+	private void disassembleAsModifier(Annotation annotation, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		final char[] typeName = CharOperation.replaceOnCopy(annotation.getTypeName(), '/', '.');
+		buffer.append('@').append(returnClassName(Signature.toCharArray(typeName), '.', mode));
+		final AnnotationComponent[] components = annotation.getComponents();
+		final int length = components.length;
+		if (length != 0) {
+			buffer.append('(');
+			for (int i = 0; i < length; i++) {
+				if (i > 0) {
+					buffer.append(',');
+					writeNewLine(buffer, lineSeparator, tabNumber);
+				}
+				disassembleAsModifier(components[i], buffer, lineSeparator, tabNumber + 1, mode);
+			}
+			buffer.append(')');
+		}
+	}
+
+	private void disassembleAsModifier(AnnotationComponent annotationComponent, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		buffer.append(annotationComponent.getComponentName()).append('=');
+		disassembleAsModifier(annotationComponent.getComponentValue(), buffer, lineSeparator, tabNumber + 1, mode);
+	}
+
+	private void disassembleAsModifier(AnnotationComponentValue annotationComponentValue, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		switch (annotationComponentValue.getTag()) {
+			case AnnotationComponentValue.BYTE_TAG :
+			case AnnotationComponentValue.CHAR_TAG :
+			case AnnotationComponentValue.DOUBLE_TAG :
+			case AnnotationComponentValue.FLOAT_TAG :
+			case AnnotationComponentValue.INTEGER_TAG :
+			case AnnotationComponentValue.LONG_TAG :
+			case AnnotationComponentValue.SHORT_TAG :
+			case AnnotationComponentValue.BOOLEAN_TAG :
+			case AnnotationComponentValue.STRING_TAG :
+				ConstantPoolEntry constantPoolEntry = annotationComponentValue.getConstantValue();
+				String value = null;
+				switch (constantPoolEntry.getKind()) {
+					case ConstantPoolConstant.CONSTANT_Long :
+						value = constantPoolEntry.getLongValue() + "L"; //$NON-NLS-1$
+						break;
+					case ConstantPoolConstant.CONSTANT_Float :
+						value = constantPoolEntry.getFloatValue() + "f"; //$NON-NLS-1$
+						break;
+					case ConstantPoolConstant.CONSTANT_Double :
+						value = Double.toString(constantPoolEntry.getDoubleValue());
+						break;
+					case ConstantPoolConstant.CONSTANT_Integer :
+						switch (annotationComponentValue.getTag()) {
+							case AnnotationComponentValue.CHAR_TAG :
+								value = "'" + (char) constantPoolEntry.getIntegerValue() + "'"; //$NON-NLS-1$//$NON-NLS-2$
+								break;
+							case AnnotationComponentValue.BOOLEAN_TAG :
+								value = constantPoolEntry.getIntegerValue() == 1 ? "true" : "false";//$NON-NLS-1$//$NON-NLS-2$
+								break;
+							case AnnotationComponentValue.BYTE_TAG :
+								value = "(byte) " + constantPoolEntry.getIntegerValue(); //$NON-NLS-1$
+								break;
+							case AnnotationComponentValue.SHORT_TAG :
+								value = "(short) " + constantPoolEntry.getIntegerValue(); //$NON-NLS-1$
+								break;
+							case AnnotationComponentValue.INTEGER_TAG :
+								value = "(int) " + constantPoolEntry.getIntegerValue(); //$NON-NLS-1$
+						}
+						break;
+					case ConstantPoolConstant.CONSTANT_Utf8 :
+						value = "\"" + decodeStringValue(constantPoolEntry.getUtf8Value()) + "\"";//$NON-NLS-1$//$NON-NLS-2$
+				}
+				buffer.append(value);
+				break;
+			case AnnotationComponentValue.ENUM_TAG :
+				final char[] typeName = CharOperation.replaceOnCopy(annotationComponentValue.getEnumConstantTypeName(), '/', '.');
+				final char[] constantName = annotationComponentValue.getEnumConstantName();
+				buffer.append(returnClassName(Signature.toCharArray(typeName), '.', mode)).append('.').append(constantName);
+				break;
+			case AnnotationComponentValue.CLASS_TAG :
+				constantPoolEntry = annotationComponentValue.getClassInfo();
+				final char[] className = CharOperation.replaceOnCopy(constantPoolEntry.getUtf8Value(), '/', '.');
+				buffer.append(returnClassName(Signature.toCharArray(className), '.', mode));
+				break;
+			case AnnotationComponentValue.ANNOTATION_TAG :
+				Annotation annotation = annotationComponentValue.getAnnotationValue();
+				disassembleAsModifier(annotation, buffer, lineSeparator, tabNumber + 1, mode);
+				break;
+			case AnnotationComponentValue.ARRAY_TAG :
+				final AnnotationComponentValue[] annotationComponentValues = annotationComponentValue.getAnnotationComponentValues();
+				buffer.append('{');
+				for (int i = 0, max = annotationComponentValues.length; i < max; i++) {
+					if (i > 0) {
+						buffer.append(',');
+					}
+					disassembleAsModifier(annotationComponentValues[i], buffer, lineSeparator, tabNumber + 1, mode);
+				}
+				buffer.append('}');
+		}
+	}
+
+	private void disassembleAsModifier(AnnotationDefaultAttribute annotationDefaultAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		AnnotationComponentValue componentValue = annotationDefaultAttribute.getMemberValue();
+		disassembleAsModifier(componentValue, buffer, lineSeparator, tabNumber + 1, mode);
+	}
+
+	private void disassembleAsModifier(RuntimeInvisibleAnnotationsAttribute runtimeInvisibleAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		Annotation[] annotations = runtimeInvisibleAnnotationsAttribute.getAnnotations();
+		for (int i = 0, max = annotations.length; i < max; i++) {
+			disassembleAsModifier(annotations[i], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+	}
+
+	private void disassembleAsModifier(RuntimeInvisibleParameterAnnotationsAttribute runtimeInvisibleParameterAnnotationsAttribute, StringBuffer buffer, int index, String lineSeparator, int tabNumber, int mode) {
+		ParameterAnnotation[] parameterAnnotations = runtimeInvisibleParameterAnnotationsAttribute.getParameterAnnotations();
+		if (parameterAnnotations.length > index) {
+			disassembleAsModifier(parameterAnnotations[index], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+	}
+
+	private void disassembleAsModifier(RuntimeVisibleParameterAnnotationsAttribute runtimeVisibleParameterAnnotationsAttribute, StringBuffer buffer, int index, String lineSeparator, int tabNumber, int mode) {
+		ParameterAnnotation[] parameterAnnotations = runtimeVisibleParameterAnnotationsAttribute.getParameterAnnotations();
+		if (parameterAnnotations.length > index) {
+			disassembleAsModifier(parameterAnnotations[index], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+	}
+
+	private void disassembleAsModifier(ParameterAnnotation parameterAnnotation, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		Annotation[] annotations = parameterAnnotation.getAnnotations();
+		for (int i = 0, max = annotations.length; i < max; i++) {
+			if (i > 0) {
+				buffer.append(' ');
+			}
+			disassembleAsModifier(annotations[i], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+	}
+
+	private void disassembleAsModifier(RuntimeVisibleAnnotationsAttribute runtimeVisibleAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		Annotation[] annotations = runtimeVisibleAnnotationsAttribute.getAnnotations();
+		for (int i = 0, max = annotations.length; i < max; i++) {
+			if (i > 0) {
+				writeNewLine(buffer, lineSeparator, tabNumber);
+			}
+			disassembleAsModifier(annotations[i], buffer, lineSeparator, tabNumber + 1, mode);
+		}
+	}
+
+	private void disassembleTypeMembers(ClassFileReader classFileReader, char[] className, StringBuffer buffer, String lineSeparator, int tabNumber, int mode, boolean isEnum) {
+		FieldInfo[] fields = classFileReader.getFieldInfos();
+		for (int i = 0, max = fields.length; i < max; i++) {
+			writeNewLine(buffer, lineSeparator, tabNumber);
+			disassemble(fields[i], buffer, lineSeparator, tabNumber, mode);
+		}
+		MethodInfo[] methods = classFileReader.getMethodInfos();
+		for (int i = 0, max = methods.length; i < max; i++) {
+			writeNewLine(buffer, lineSeparator, tabNumber);
+			disassemble(classFileReader, className, methods[i], buffer, lineSeparator, tabNumber, mode);
+		}
+	}
+
+	private final void dumpTab(int tabNumber, StringBuffer buffer) {
+		for (int i = 0; i < tabNumber; i++) {
+			buffer.append(Messages.disassembler_indentation);
+		}
+	}
+
+	/**
+	 * @see org.eclipse.jdt.core.util.ClassFileBytesDisassembler#getDescription()
+	 */
+	public String getDescription() {
+		return Messages.disassembler_description;
+	}
+
+	private EnclosingMethodAttribute getEnclosingMethodAttribute(ClassFileReader classFileReader) {
+		ClassFileAttribute[] attributes = classFileReader.getAttributes();
+		for (int i = 0, max = attributes.length; i < max; i++) {
+			if (Arrays.equals(attributes[i].getAttributeName(), AttributeNamesConstants.ENCLOSING_METHOD)) {
+				return (EnclosingMethodAttribute) attributes[i];
+			}
+		}
+		return null;
+	}
+
+	private char[] getSignatureForField(char[] fieldDescriptor) {
+		char[] newFieldDescriptor = CharOperation.replaceOnCopy(fieldDescriptor, '/', '.');
+		newFieldDescriptor = CharOperation.replaceOnCopy(newFieldDescriptor, '$', '%');
+		char[] fieldDescriptorSignature = Signature.toCharArray(newFieldDescriptor);
+		CharOperation.replace(fieldDescriptorSignature, '%', '$');
+		return fieldDescriptorSignature;
+	}
+
+	private boolean isDeprecated(ClassFileReader classFileReader) {
+		ClassFileAttribute[] attributes = classFileReader.getAttributes();
+		for (int i = 0, max = attributes.length; i < max; i++) {
+			if (Arrays.equals(attributes[i].getAttributeName(), AttributeNamesConstants.DEPRECATED)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	private boolean isSynthetic(ClassFileReader classFileReader) {
+		int flags = classFileReader.getAccessFlags();
+		if ((flags & IModifierConstants.ACC_SYNTHETIC) != 0) {
+			return true;
+		}
+		ClassFileAttribute[] attributes = classFileReader.getAttributes();
+		for (int i = 0, max = attributes.length; i < max; i++) {
+			if (Arrays.equals(attributes[i].getAttributeName(), AttributeNamesConstants.SYNTHETIC)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	private boolean checkMode(int mode, int flag) {
+		return (mode & flag) != 0;
+	}
+
+	private boolean isCompact(int mode) {
+		return (mode & Disassembler.COMPACT) != 0;
+	}
+
+	private char[] returnClassName(char[] classInfoName, char separator, int mode) {
+		if (classInfoName.length == 0) {
+			return CharOperation.NO_CHAR;
+		} else if (isCompact(mode)) {
+			int lastIndexOfSlash = CharOperation.lastIndexOf(separator, classInfoName);
+			if (lastIndexOfSlash != -1) {
+				return CharOperation.subarray(classInfoName, lastIndexOfSlash + 1, classInfoName.length);
+			}
+		}
+		return classInfoName;
+	}
+
+	private void writeNewLine(StringBuffer buffer, String lineSeparator, int tabNumber) {
+		buffer.append(lineSeparator);
+		dumpTab(tabNumber, buffer);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/EnclosingMethodAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/EnclosingMethodAttribute.java
new file mode 100644
index 0000000..f764778
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/EnclosingMethodAttribute.java
@@ -0,0 +1,101 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class EnclosingMethodAttribute extends ClassFileAttribute {
+
+	private int enclosingClassIndex;
+	private char[] enclosingClassName;
+	private int methodDescriptorIndex;
+	private char[] methodDescriptor;
+	private int methodNameIndex;
+	private char[] methodName;
+	private int methodNameAndTypeIndex;
+
+	EnclosingMethodAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		int index = u2At(classFileBytes, 6, offset);
+		this.enclosingClassIndex = index;
+		ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(index);
+		if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+			throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+		}
+		this.enclosingClassName = constantPoolEntry.getClassInfoName();
+		this.methodNameAndTypeIndex = u2At(classFileBytes, 8, offset);
+		if (this.methodNameAndTypeIndex != 0) {
+			constantPoolEntry = constantPool.decodeEntry(this.methodNameAndTypeIndex);
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_NameAndType) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			this.methodDescriptorIndex = constantPoolEntry.getNameAndTypeInfoDescriptorIndex();
+			this.methodNameIndex = constantPoolEntry.getNameAndTypeInfoNameIndex();
+			constantPoolEntry = constantPool.decodeEntry(this.methodDescriptorIndex);
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			this.methodDescriptor = constantPoolEntry.getUtf8Value();
+			constantPoolEntry = constantPool.decodeEntry(this.methodNameIndex);
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			this.methodName = constantPoolEntry.getUtf8Value();
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IEnclosingMethodAttribute#getEnclosingClass()
+	 */
+	public char[] getEnclosingClass() {
+		return this.enclosingClassName;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IEnclosingMethodAttribute#getMethodDeclaringClassDescriptorIndex()
+	 */
+	public int getEnclosingClassIndex() {
+		return this.enclosingClassIndex;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IEnclosingMethodAttribute#getMethodDescriptor()
+	 */
+	public char[] getMethodDescriptor() {
+		return this.methodDescriptor;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IEnclosingMethodAttribute#getMethodDescriptorIndex()
+	 */
+	public int getMethodDescriptorIndex() {
+		return this.methodDescriptorIndex;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IEnclosingMethodAttribute#getMethodName()
+	 */
+	public char[] getMethodName() {
+		return this.methodName;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IEnclosingMethodAttribute#getMethodNameIndex()
+	 */
+	public int getMethodNameIndex() {
+		return this.methodNameIndex;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IEnclosingMethodAttribute#getMethodNameAndTypeIndex()
+	 */
+	public int getMethodNameAndTypeIndex() {
+		return this.methodNameAndTypeIndex;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionAttribute.java
new file mode 100644
index 0000000..cfb2534
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionAttribute.java
@@ -0,0 +1,61 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class ExceptionAttribute extends ClassFileAttribute {
+	private int exceptionsNumber;
+	private char[][] exceptionNames;
+	private int[] exceptionIndexes;
+
+	ExceptionAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		this.exceptionsNumber = u2At(classFileBytes, 6, offset);
+		int exceptionLength = this.exceptionsNumber;
+		this.exceptionNames = CharOperation.NO_CHAR_CHAR;
+		this.exceptionIndexes = Utility.EMPTY_INT_ARRAY;
+		if (exceptionLength != 0) {
+			this.exceptionNames = new char[exceptionLength][];
+			this.exceptionIndexes = new int[exceptionLength];
+		}
+		int readOffset = 8;
+		ConstantPoolEntry constantPoolEntry;
+		for (int i = 0; i < exceptionLength; i++) {
+			this.exceptionIndexes[i] = u2At(classFileBytes, readOffset, offset);
+			constantPoolEntry = constantPool.decodeEntry(this.exceptionIndexes[i]);
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			this.exceptionNames[i] = constantPoolEntry.getClassInfoName();
+			readOffset += 2;
+		}
+	}
+
+	/**
+	 * @see IExceptionAttribute#getExceptionIndexes()
+	 */
+	public int[] getExceptionIndexes() {
+		return this.exceptionIndexes;
+	}
+
+	/**
+	 * @see IExceptionAttribute#getExceptionNames()
+	 */
+	public char[][] getExceptionNames() {
+		return this.exceptionNames;
+	}
+
+	/**
+	 * @see IExceptionAttribute#getExceptionsNumber()
+	 */
+	public int getExceptionsNumber() {
+		return this.exceptionsNumber;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionTableEntry.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionTableEntry.java
new file mode 100644
index 0000000..2faba69
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionTableEntry.java
@@ -0,0 +1,70 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class ExceptionTableEntry extends ClassFileStruct {
+
+	private int startPC;
+	private int endPC;
+	private int handlerPC;
+	private int catchTypeIndex;
+	private char[] catchType;
+
+	ExceptionTableEntry(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		this.startPC = u2At(classFileBytes, 0, offset);
+		this.endPC = u2At(classFileBytes, 2, offset);
+		this.handlerPC = u2At(classFileBytes, 4, offset);
+		this.catchTypeIndex = u2At(classFileBytes, 6, offset);
+		if (this.catchTypeIndex != 0) {
+			ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(this.catchTypeIndex);
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			this.catchType = constantPoolEntry.getClassInfoName();
+		}
+	}
+
+	/**
+	 * @see IExceptionTableEntry#getStartPC()
+	 */
+	public int getStartPC() {
+		return this.startPC;
+	}
+
+	/**
+	 * @see IExceptionTableEntry#getEndPC()
+	 */
+	public int getEndPC() {
+		return this.endPC;
+	}
+
+	/**
+	 * @see IExceptionTableEntry#getHandlerPC()
+	 */
+	public int getHandlerPC() {
+		return this.handlerPC;
+	}
+
+	/**
+	 * @see IExceptionTableEntry#getCatchTypeIndex()
+	 */
+	public int getCatchTypeIndex() {
+		return this.catchTypeIndex;
+	}
+
+	/**
+	 * @see IExceptionTableEntry#getCatchType()
+	 */
+	public char[] getCatchType() {
+		return this.catchType;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/FieldInfo.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/FieldInfo.java
new file mode 100644
index 0000000..f4b0395
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/FieldInfo.java
@@ -0,0 +1,170 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+import java.util.Arrays;
+
+public class FieldInfo extends ClassFileStruct {
+	private int accessFlags;
+	private int attributeBytes;
+	private ClassFileAttribute[] attributes;
+	private int attributesCount;
+	private ConstantValueAttribute constantValueAttribute;
+	private char[] descriptor;
+	private int descriptorIndex;
+	private boolean isDeprecated;
+	private boolean isSynthetic;
+	private char[] name;
+	private int nameIndex;
+
+	/**
+	 * @param classFileBytes byte[]
+	 * @param constantPool IConstantPool
+	 * @param offset int
+	 */
+	public FieldInfo(byte classFileBytes[], ConstantPool constantPool, int offset) throws ClassFormatException {
+		final int flags = u2At(classFileBytes, 0, offset);
+		this.accessFlags = flags;
+		if ((flags & IModifierConstants.ACC_SYNTHETIC) != 0) {
+			this.isSynthetic = true;
+		}
+		this.nameIndex = u2At(classFileBytes, 2, offset);
+		ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(this.nameIndex);
+		if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+			throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+		}
+		this.name = constantPoolEntry.getUtf8Value();
+
+		this.descriptorIndex = u2At(classFileBytes, 4, offset);
+		constantPoolEntry = constantPool.decodeEntry(this.descriptorIndex);
+		if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+			throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+		}
+		this.descriptor = constantPoolEntry.getUtf8Value();
+
+		this.attributesCount = u2At(classFileBytes, 6, offset);
+		this.attributes = ClassFileAttribute.NO_ATTRIBUTES;
+		int readOffset = 8;
+		if (this.attributesCount != 0) {
+			this.attributes = new ClassFileAttribute[this.attributesCount];
+		}
+		int attributesIndex = 0;
+		for (int i = 0; i < this.attributesCount; i++) {
+			constantPoolEntry = constantPool.decodeEntry(u2At(classFileBytes, readOffset, offset));
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			char[] attributeName = constantPoolEntry.getUtf8Value();
+			if (Arrays.equals(attributeName, AttributeNamesConstants.DEPRECATED)) {
+				this.isDeprecated = true;
+				this.attributes[attributesIndex++] = new ClassFileAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.SYNTHETIC)) {
+				this.isSynthetic = true;
+				this.attributes[attributesIndex++] = new ClassFileAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.CONSTANT_VALUE)) {
+				this.constantValueAttribute = new ConstantValueAttribute(classFileBytes, constantPool, offset + readOffset);
+				this.attributes[attributesIndex++] = this.constantValueAttribute;
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.SIGNATURE)) {
+				this.attributes[attributesIndex++] = new SignatureAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.RUNTIME_VISIBLE_ANNOTATIONS)) {
+				this.attributes[attributesIndex++] = new RuntimeVisibleAnnotationsAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.RUNTIME_INVISIBLE_ANNOTATIONS)) {
+				this.attributes[attributesIndex++] = new RuntimeInvisibleAnnotationsAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else {
+				this.attributes[attributesIndex++] = new ClassFileAttribute(classFileBytes, constantPool, offset + readOffset);
+			}
+			readOffset += (6 + u4At(classFileBytes, readOffset + 2, offset));
+		}
+
+		this.attributeBytes = readOffset;
+	}
+
+	/**
+	 * @see IFieldInfo#getAccessFlags()
+	 */
+	public int getAccessFlags() {
+		return this.accessFlags;
+	}
+
+	/**
+	 * @see IFieldInfo#getAttributeCount()
+	 */
+	public int getAttributeCount() {
+		return this.attributesCount;
+	}
+
+	/**
+	 * @see IFieldInfo#getAttributes()
+	 */
+	public ClassFileAttribute[] getAttributes() {
+		return this.attributes;
+	}
+
+	/**
+	 * @see IFieldInfo#getConstantValueAttribute()
+	 */
+	public ConstantValueAttribute getConstantValueAttribute() {
+		return this.constantValueAttribute;
+	}
+
+	/**
+	 * @see IFieldInfo#getDescriptor()
+	 */
+	public char[] getDescriptor() {
+		return this.descriptor;
+	}
+
+	/**
+	 * @see IFieldInfo#getDescriptorIndex()
+	 */
+	public int getDescriptorIndex() {
+		return this.descriptorIndex;
+	}
+
+	/**
+	 * @see IFieldInfo#getName()
+	 */
+	public char[] getName() {
+		return this.name;
+	}
+
+	/**
+	 * @see IFieldInfo#getNameIndex()
+	 */
+	public int getNameIndex() {
+		return this.nameIndex;
+	}
+
+	/**
+	 * @see IFieldInfo#hasConstantValueAttribute()
+	 */
+	public boolean hasConstantValueAttribute() {
+		return this.constantValueAttribute != null;
+	}
+
+	/**
+	 * @see IFieldInfo#isDeprecated()
+	 */
+	public boolean isDeprecated() {
+		return this.isDeprecated;
+	}
+
+	/**
+	 * @see IFieldInfo#isSynthetic()
+	 */
+	public boolean isSynthetic() {
+		return this.isSynthetic;
+	}
+
+	int sizeInBytes() {
+		return this.attributeBytes;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/IModifierConstants.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/IModifierConstants.java
new file mode 100644
index 0000000..17607b1
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/IModifierConstants.java
@@ -0,0 +1,104 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public interface IModifierConstants {
+
+	int ACC_PUBLIC = 0x0001;
+	int ACC_PRIVATE = 0x0002;
+	int ACC_PROTECTED = 0x0004;
+	int ACC_STATIC = 0x0008;
+	int ACC_FINAL = 0x0010;
+	int ACC_SUPER = 0x0020;
+	int ACC_SYNCHRONIZED = 0x0020;
+	int ACC_VOLATILE = 0x0040;
+
+	/**
+	 * Indicates a bridge method (added in J2SE 1.5).
+	 * @since 3.0
+	 */
+	int ACC_BRIDGE = 0x0040;
+	int ACC_TRANSIENT = 0x0080;
+
+	/**
+	 * Indicates a variable arity method (added in J2SE 1.5).
+	 * @since 3.0
+	 */
+	int ACC_VARARGS = 0x0080;
+	int ACC_NATIVE = 0x0100;
+	int ACC_INTERFACE = 0x0200;
+	int ACC_ABSTRACT = 0x0400;
+	int ACC_STRICT = 0x0800;
+	/**
+	 * Indicates a synthetic member.
+	 * @since 3.0
+	 */
+	int ACC_SYNTHETIC = 0x1000;
+
+	/**
+	 * Indicates an annotation (added in J2SE 1.5).
+	 * @since 3.0
+	 */
+	int ACC_ANNOTATION = 0x2000;
+
+	/**
+	 * Indicates an enum (added in J2SE 1.5).
+	 * @since 3.0
+	 */
+	int ACC_ENUM = 0x4000;
+
+	/**
+	 * Configurable option value: {@value}.
+	 * @category OptionValue
+	 */
+	public static final String VERSION_1_1 = "1.1"; //$NON-NLS-1$
+	/**
+	 * Configurable option value: {@value}.
+	 * @category OptionValue
+	 */
+	public static final String VERSION_1_2 = "1.2"; //$NON-NLS-1$
+	/**
+	 * Configurable option value: {@value}.
+	 * @since 2.0
+	 * @category OptionValue
+	 */
+	public static final String VERSION_1_3 = "1.3"; //$NON-NLS-1$
+	/**
+	 * Configurable option value: {@value}.
+	 * @since 2.0
+	 * @category OptionValue
+	 */
+	public static final String VERSION_1_4 = "1.4"; //$NON-NLS-1$
+	/**
+	 * Configurable option value: {@value}.
+	 * @since 3.0
+	 * @category OptionValue
+	 */
+	public static final String VERSION_1_5 = "1.5"; //$NON-NLS-1$
+	/**
+	 * Configurable option value: {@value}.
+	 * @since 3.2
+	 * @category OptionValue
+	 */
+	public static final String VERSION_1_6 = "1.6"; //$NON-NLS-1$
+	/**
+	 * Configurable option value: {@value}.
+	 * @since 3.3
+	 * @category OptionValue
+	 */
+	public static final String VERSION_1_7 = "1.7"; //$NON-NLS-1$
+	/**
+	 * Configurable option value: {@value}.
+	 * @since 3.4
+	 * @category OptionValue
+	 */
+	public static final String VERSION_CLDC_1_1 = "cldc1.1"; //$NON-NLS-1$
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/IOpcodeMnemonics.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/IOpcodeMnemonics.java
new file mode 100644
index 0000000..720591e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/IOpcodeMnemonics.java
@@ -0,0 +1,220 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public interface IOpcodeMnemonics {
+
+	int NOP = 0x00;
+	int ACONST_NULL = 0x01;
+	int ICONST_M1 = 0x02;
+	int ICONST_0 = 0x03;
+	int ICONST_1 = 0x04;
+	int ICONST_2 = 0x05;
+	int ICONST_3 = 0x06;
+	int ICONST_4 = 0x07;
+	int ICONST_5 = 0x08;
+	int LCONST_0 = 0x09;
+	int LCONST_1 = 0x0A;
+	int FCONST_0 = 0x0B;
+	int FCONST_1 = 0x0C;
+	int FCONST_2 = 0x0D;
+	int DCONST_0 = 0x0E;
+	int DCONST_1 = 0x0F;
+	int BIPUSH = 0x10;
+	int SIPUSH = 0x11;
+	int LDC = 0x12;
+	int LDC_W = 0x13;
+	int LDC2_W = 0x14;
+	int ILOAD = 0x15;
+	int LLOAD = 0x16;
+	int FLOAD = 0x17;
+	int DLOAD = 0x18;
+	int ALOAD = 0x19;
+	int ILOAD_0 = 0x1A;
+	int ILOAD_1 = 0x1B;
+	int ILOAD_2 = 0x1C;
+	int ILOAD_3 = 0x1D;
+	int LLOAD_0 = 0x1E;
+	int LLOAD_1 = 0x1F;
+	int LLOAD_2 = 0x20;
+	int LLOAD_3 = 0x21;
+	int FLOAD_0 = 0x22;
+	int FLOAD_1 = 0x23;
+	int FLOAD_2 = 0x24;
+	int FLOAD_3 = 0x25;
+	int DLOAD_0 = 0x26;
+	int DLOAD_1 = 0x27;
+	int DLOAD_2 = 0x28;
+	int DLOAD_3 = 0x29;
+	int ALOAD_0 = 0x2A;
+	int ALOAD_1 = 0x2B;
+	int ALOAD_2 = 0x2C;
+	int ALOAD_3 = 0x2D;
+	int IALOAD = 0x2E;
+	int LALOAD = 0x2F;
+	int FALOAD = 0x30;
+	int DALOAD = 0x31;
+	int AALOAD = 0x32;
+	int BALOAD = 0x33;
+	int CALOAD = 0x34;
+	int SALOAD = 0x35;
+	int ISTORE = 0x36;
+	int LSTORE = 0x37;
+	int FSTORE = 0x38;
+	int DSTORE = 0x39;
+	int ASTORE = 0x3A;
+	int ISTORE_0 = 0x3B;
+	int ISTORE_1 = 0x3C;
+	int ISTORE_2 = 0x3D;
+	int ISTORE_3 = 0x3E;
+	int LSTORE_0 = 0x3F;
+	int LSTORE_1 = 0x40;
+	int LSTORE_2 = 0x41;
+	int LSTORE_3 = 0x42;
+	int FSTORE_0 = 0x43;
+	int FSTORE_1 = 0x44;
+	int FSTORE_2 = 0x45;
+	int FSTORE_3 = 0x46;
+	int DSTORE_0 = 0x47;
+	int DSTORE_1 = 0x48;
+	int DSTORE_2 = 0x49;
+	int DSTORE_3 = 0x4A;
+	int ASTORE_0 = 0x4B;
+	int ASTORE_1 = 0x4C;
+	int ASTORE_2 = 0x4D;
+	int ASTORE_3 = 0x4E;
+	int IASTORE = 0x4F;
+	int LASTORE = 0x50;
+	int FASTORE = 0x51;
+	int DASTORE = 0x52;
+	int AASTORE = 0x53;
+	int BASTORE = 0x54;
+	int CASTORE = 0x55;
+	int SASTORE = 0x56;
+	int POP = 0x57;
+	int POP2 = 0x58;
+	int DUP = 0x59;
+	int DUP_X1 = 0x5A;
+	int DUP_X2 = 0x5B;
+	int DUP2 = 0x5C;
+	int DUP2_X1 = 0x5D;
+	int DUP2_X2 = 0x5E;
+	int SWAP = 0x5F;
+	int IADD = 0x60;
+	int LADD = 0x61;
+	int FADD = 0x62;
+	int DADD = 0x63;
+	int ISUB = 0x64;
+	int LSUB = 0x65;
+	int FSUB = 0x66;
+	int DSUB = 0x67;
+	int IMUL = 0x68;
+	int LMUL = 0x69;
+	int FMUL = 0x6A;
+	int DMUL = 0x6B;
+	int IDIV = 0x6C;
+	int LDIV = 0x6D;
+	int FDIV = 0x6E;
+	int DDIV = 0x6F;
+	int IREM = 0x70;
+	int LREM = 0x71;
+	int FREM = 0x72;
+	int DREM = 0x73;
+	int INEG = 0x74;
+	int LNEG = 0x75;
+	int FNEG = 0x76;
+	int DNEG = 0x77;
+	int ISHL = 0x78;
+	int LSHL = 0x79;
+	int ISHR = 0x7A;
+	int LSHR = 0x7B;
+	int IUSHR = 0x7C;
+	int LUSHR = 0x7D;
+	int IAND = 0x7E;
+	int LAND = 0x7F;
+	int IOR = 0x80;
+	int LOR = 0x81;
+	int IXOR = 0x82;
+	int LXOR = 0x83;
+	int IINC = 0x84;
+	int I2L = 0x85;
+	int I2F = 0x86;
+	int I2D = 0x87;
+	int L2I = 0x88;
+	int L2F = 0x89;
+	int L2D = 0x8A;
+	int F2I = 0x8B;
+	int F2L = 0x8C;
+	int F2D = 0x8D;
+	int D2I = 0x8E;
+	int D2L = 0x8F;
+	int D2F = 0x90;
+	int I2B = 0x91;
+	int I2C = 0x92;
+	int I2S = 0x93;
+	int LCMP = 0x94;
+	int FCMPL = 0x95;
+	int FCMPG = 0x96;
+	int DCMPL = 0x97;
+	int DCMPG = 0x98;
+	int IFEQ = 0x99;
+	int IFNE = 0x9A;
+	int IFLT = 0x9B;
+	int IFGE = 0x9C;
+	int IFGT = 0x9D;
+	int IFLE = 0x9E;
+	int IF_ICMPEQ = 0x9F;
+	int IF_ICMPNE = 0xA0;
+	int IF_ICMPLT = 0xA1;
+	int IF_ICMPGE = 0xA2;
+	int IF_ICMPGT = 0xA3;
+	int IF_ICMPLE = 0xA4;
+	int IF_ACMPEQ = 0xA5;
+	int IF_ACMPNE = 0xA6;
+	int GOTO = 0xA7;
+	int JSR = 0xA8;
+	int RET = 0xA9;
+	int TABLESWITCH = 0xAA;
+	int LOOKUPSWITCH = 0xAB;
+	int IRETURN = 0xAC;
+	int LRETURN = 0xAD;
+	int FRETURN = 0xAE;
+	int DRETURN = 0xAF;
+	int ARETURN = 0xB0;
+	int RETURN = 0xB1;
+	int GETSTATIC = 0xB2;
+	int PUTSTATIC = 0xB3;
+	int GETFIELD = 0xB4;
+	int PUTFIELD = 0xB5;
+	int INVOKEVIRTUAL = 0xB6;
+	int INVOKESPECIAL = 0xB7;
+	int INVOKESTATIC = 0xB8;
+	int INVOKEINTERFACE = 0xB9;
+	int NEW = 0xBB;
+	int NEWARRAY = 0xBC;
+	int ANEWARRAY = 0xBD;
+	int ARRAYLENGTH = 0xBE;
+	int ATHROW = 0xBF;
+	int CHECKCAST = 0xC0;
+	int INSTANCEOF = 0xC1;
+	int MONITORENTER = 0xC2;
+	int MONITOREXIT = 0xC3;
+	int WIDE = 0xC4;
+	int MULTIANEWARRAY = 0xC5;
+	int IFNULL = 0xC6;
+	int IFNONNULL = 0xC7;
+	int GOTO_W = 0xC8;
+	int JSR_W = 0xC9;
+
+	int BREAKPOINT = 0xCA;
+	int IMPDEP1 = 0xFE;
+	int IMPDEP2 = 0xFF;
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttribute.java
new file mode 100644
index 0000000..1bc57a2
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttribute.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class InnerClassesAttribute extends ClassFileAttribute {
+	private static final InnerClassesAttributeEntry[] NO_ENTRIES = new InnerClassesAttributeEntry[0];
+
+	private int numberOfClasses;
+	private InnerClassesAttributeEntry[] entries;
+
+	/**
+	 * Constructor for InnerClassesAttribute.
+	 * @param classFileBytes
+	 * @param constantPool
+	 * @param offset
+	 * @throws ClassFormatException
+	 */
+	public InnerClassesAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		this.numberOfClasses = u2At(classFileBytes, 6, offset);
+		final int length = this.numberOfClasses;
+		if (length != 0) {
+			int readOffset = 8;
+			this.entries = new InnerClassesAttributeEntry[length];
+			for (int i = 0; i < length; i++) {
+				this.entries[i] = new InnerClassesAttributeEntry(classFileBytes, constantPool, offset + readOffset);
+				readOffset += 8;
+			}
+		} else {
+			this.entries = NO_ENTRIES;
+		}
+	}
+
+	/**
+	 * @see IInnerClassesAttribute#getInnerClassAttributesEntries()
+	 */
+	public InnerClassesAttributeEntry[] getInnerClassAttributesEntries() {
+		return this.entries;
+	}
+
+	/**
+	 * @see IInnerClassesAttribute#getNumberOfClasses()
+	 */
+	public int getNumberOfClasses() {
+		return this.numberOfClasses;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttributeEntry.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttributeEntry.java
new file mode 100644
index 0000000..7893d0b
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttributeEntry.java
@@ -0,0 +1,100 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class InnerClassesAttributeEntry extends ClassFileStruct {
+
+	private int innerClassNameIndex;
+	private int outerClassNameIndex;
+	private int innerNameIndex;
+	private char[] innerClassName;
+	private char[] outerClassName;
+	private char[] innerName;
+	private int accessFlags;
+
+	public InnerClassesAttributeEntry(byte classFileBytes[], ConstantPool constantPool, int offset) throws ClassFormatException {
+		this.innerClassNameIndex = u2At(classFileBytes, 0, offset);
+		this.outerClassNameIndex = u2At(classFileBytes, 2, offset);
+		this.innerNameIndex = u2At(classFileBytes, 4, offset);
+		this.accessFlags = u2At(classFileBytes, 6, offset);
+		ConstantPoolEntry constantPoolEntry;
+		if (this.innerClassNameIndex != 0) {
+			constantPoolEntry = constantPool.decodeEntry(this.innerClassNameIndex);
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			this.innerClassName = constantPoolEntry.getClassInfoName();
+		}
+		if (this.outerClassNameIndex != 0) {
+			constantPoolEntry = constantPool.decodeEntry(this.outerClassNameIndex);
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Class) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			this.outerClassName = constantPoolEntry.getClassInfoName();
+		}
+		if (this.innerNameIndex != 0) {
+			constantPoolEntry = constantPool.decodeEntry(this.innerNameIndex);
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			this.innerName = constantPoolEntry.getUtf8Value();
+		}
+	}
+
+	/**
+	 * @see IInnerClassesAttributeEntry#getAccessFlags()
+	 */
+	public int getAccessFlags() {
+		return this.accessFlags;
+	}
+
+	/**
+	 * @see IInnerClassesAttributeEntry#getInnerClassName()
+	 */
+	public char[] getInnerClassName() {
+		return this.innerClassName;
+	}
+
+	/**
+	 * @see IInnerClassesAttributeEntry#getInnerClassNameIndex()
+	 */
+	public int getInnerClassNameIndex() {
+		return this.innerClassNameIndex;
+	}
+
+	/**
+	 * @see IInnerClassesAttributeEntry#getInnerName()
+	 */
+	public char[] getInnerName() {
+		return this.innerName;
+	}
+
+	/**
+	 * @see IInnerClassesAttributeEntry#getInnerNameIndex()
+	 */
+	public int getInnerNameIndex() {
+		return this.innerNameIndex;
+	}
+
+	/**
+	 * @see IInnerClassesAttributeEntry#getOuterClassName()
+	 */
+	public char[] getOuterClassName() {
+		return this.outerClassName;
+	}
+
+	/**
+	 * @see IInnerClassesAttributeEntry#getOuterClassNameIndex()
+	 */
+	public int getOuterClassNameIndex() {
+		return this.outerClassNameIndex;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/JarComparator.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/JarComparator.java
new file mode 100644
index 0000000..8454fe2
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/JarComparator.java
@@ -0,0 +1,222 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+import java.io.*;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.*;
+import org.eclipse.osgi.util.NLS;
+
+public class JarComparator implements IArtifactComparator {
+
+	private static final String LINE_SEPARATOR = "\n"; //$NON-NLS-1$
+	private static final String CLASS_EXTENSION = ".class"; //$NON-NLS-1$
+	private static final String JAR_EXTENSION = ".jar"; //$NON-NLS-1$
+	private static final String PLUGIN_ID = "org.eclipse.equinox.p2.repository.tools"; //$NON-NLS-1$
+	private static final String DESTINATION_ARTIFACT_PREFIX = "destinationartifact"; //$NON-NLS-1$
+	private static final String SUFFIX_JAR = ".jar"; //$NON-NLS-1$
+	private static final String SOURCE_ARTIFACT_PREFIX = "sourceartifact"; //$NON-NLS-1$
+	private static final String OSGI_BUNDLE_CLASSIFIER = "osgi.bundle"; //$NON-NLS-1$
+
+	public IStatus compare(IArtifactRepository source, IArtifactDescriptor sourceDescriptor, IArtifactRepository destination, IArtifactDescriptor destinationDescriptor) {
+		String classifier = sourceDescriptor.getArtifactKey().getClassifier();
+		if (!OSGI_BUNDLE_CLASSIFIER.equals(classifier)) {
+			return Status.OK_STATUS;
+		}
+		classifier = destinationDescriptor.getArtifactKey().getClassifier();
+		if (!OSGI_BUNDLE_CLASSIFIER.equals(classifier)) {
+			return Status.OK_STATUS;
+		}
+		File firstTempFile = null;
+		BufferedOutputStream stream = null;
+		try {
+			firstTempFile = File.createTempFile(SOURCE_ARTIFACT_PREFIX, SUFFIX_JAR);
+			stream = new BufferedOutputStream(new FileOutputStream(firstTempFile));
+			IStatus status = source.getArtifact(sourceDescriptor, stream, new NullProgressMonitor());
+			if (!status.isOK()) {
+				return status;
+			}
+			stream.flush();
+		} catch (FileNotFoundException e) {
+			return newErrorStatus("FileNotFoundException", e); //$NON-NLS-1$
+		} catch (IOException e) {
+			return newErrorStatus("IOException", e); //$NON-NLS-1$
+		} finally {
+			try {
+				if (stream != null) {
+					stream.close();
+				}
+			} catch (IOException e) {
+				// ignore
+			}
+		}
+
+		File secondTempFile = null;
+		stream = null;
+		try {
+			secondTempFile = File.createTempFile(DESTINATION_ARTIFACT_PREFIX, SUFFIX_JAR);
+			stream = new BufferedOutputStream(new FileOutputStream(secondTempFile));
+			IStatus status = destination.getArtifact(destinationDescriptor, stream, null);
+			if (!status.isOK()) {
+				return status;
+			}
+			stream.flush();
+		} catch (FileNotFoundException e) {
+			return newErrorStatus("FileNotFoundException", e); //$NON-NLS-1$
+		} catch (IOException e) {
+			return newErrorStatus("IOException", e); //$NON-NLS-1$
+		} finally {
+			try {
+				if (stream != null) {
+					stream.close();
+				}
+			} catch (IOException e) {
+				// ignore
+			}
+		}
+
+		try {
+			return compare(firstTempFile, secondTempFile);
+		} finally {
+			if (firstTempFile != null) {
+				firstTempFile.delete();
+			}
+			secondTempFile.delete();
+		}
+	}
+
+	public IStatus compare(File sourceFile, File destinationFile) {
+		try {
+			ZipFile firstFile = new ZipFile(sourceFile);
+			ZipFile secondFile = new ZipFile(destinationFile);
+			final int firstFileSize = firstFile.size();
+			final int secondFileSize = secondFile.size();
+			if (firstFileSize != secondFileSize) {
+				return newErrorStatus(NLS.bind(Messages.differentNumberOfEntries, new String[] {sourceFile.getName(), Integer.toString(firstFileSize), destinationFile.getName(), Integer.toString(secondFileSize)}));
+			}
+			for (Enumeration enumeration = firstFile.entries(); enumeration.hasMoreElements();) {
+				ZipEntry entry = (ZipEntry) enumeration.nextElement();
+				String entryName = entry.getName();
+				final ZipEntry entry2 = secondFile.getEntry(entryName);
+				if (!entry.isDirectory() && entry2 != null) {
+					Disassembler disassembler = new Disassembler();
+					byte[] firstEntryClassFileBytes = Utility.getZipEntryByteContent(entry, firstFile);
+					byte[] secondEntryClassFileBytes = Utility.getZipEntryByteContent(entry2, secondFile);
+					String lowerCase = entryName.toLowerCase();
+					if (lowerCase.endsWith(CLASS_EXTENSION)) {
+						String contentsFile1 = null;
+						String contentsFile2 = null;
+						try {
+							contentsFile1 = disassembler.disassemble(firstEntryClassFileBytes, LINE_SEPARATOR, Disassembler.DETAILED | Disassembler.COMPACT);
+							contentsFile2 = disassembler.disassemble(secondEntryClassFileBytes, LINE_SEPARATOR, Disassembler.DETAILED | Disassembler.COMPACT);
+						} catch (ClassFormatException e) {
+							return newErrorStatus(NLS.bind(Messages.differentEntry, entryName, sourceFile.getAbsolutePath()), e);
+						}
+						if (!contentsFile1.equals(contentsFile2)) {
+							return newErrorStatus(NLS.bind(Messages.differentEntry, entryName, sourceFile.getAbsolutePath()));
+						}
+					} else if (lowerCase.endsWith(JAR_EXTENSION)) {
+						File firstTempFile = null;
+						BufferedOutputStream stream = null;
+						try {
+							firstTempFile = File.createTempFile(SOURCE_ARTIFACT_PREFIX + normalize(entryName), SUFFIX_JAR);
+							stream = new BufferedOutputStream(new FileOutputStream(firstTempFile));
+							stream.write(firstEntryClassFileBytes);
+							stream.flush();
+						} catch (FileNotFoundException e) {
+							return newErrorStatus(NLS.bind(Messages.filenotfoundexception, entryName, sourceFile.getAbsolutePath()), e);
+						} catch (IOException e) {
+							return newErrorStatus(NLS.bind(Messages.ioexceptioninentry, entryName, sourceFile.getAbsolutePath()), e);
+						} finally {
+							try {
+								if (stream != null) {
+									stream.close();
+								}
+							} catch (IOException e) {
+								// ignore
+							}
+						}
+						File secondTempFile = null;
+						stream = null;
+						try {
+							secondTempFile = File.createTempFile(DESTINATION_ARTIFACT_PREFIX + normalize(entryName), SUFFIX_JAR);
+							stream = new BufferedOutputStream(new FileOutputStream(secondTempFile));
+							stream.write(secondEntryClassFileBytes);
+							stream.flush();
+						} catch (FileNotFoundException e) {
+							return newErrorStatus(NLS.bind(Messages.filenotfoundexception, entryName, sourceFile.getAbsolutePath()), e);
+						} catch (IOException e) {
+							return newErrorStatus(NLS.bind(Messages.ioexceptioninentry, entryName, sourceFile.getAbsolutePath()), e);
+						} finally {
+							try {
+								if (stream != null) {
+									stream.close();
+								}
+							} catch (IOException e) {
+								// ignore
+							}
+						}
+
+						try {
+							IStatus status = compare(firstTempFile, secondTempFile);
+							if (!status.isOK()) {
+								return status;
+							}
+						} finally {
+							if (firstTempFile != null) {
+								firstTempFile.delete();
+							}
+							secondTempFile.delete();
+						}
+					} else if (!Arrays.equals(firstEntryClassFileBytes, secondEntryClassFileBytes)) {
+						// do a binary compare byte per byte
+						return newErrorStatus(NLS.bind(Messages.differentEntry, entryName, sourceFile.getAbsolutePath()));
+					}
+				} else if (!entry.isDirectory()) {
+					// missing entry
+					return newErrorStatus(NLS.bind(Messages.missingEntry, entryName, sourceFile.getAbsolutePath()));
+				}
+			}
+			firstFile.close();
+			secondFile.close();
+		} catch (IOException e) {
+			// missing entry
+			return newErrorStatus(NLS.bind(Messages.ioexception, new String[] {sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath()}), e);
+		}
+		return Status.OK_STATUS;
+	}
+
+	private String normalize(String entryName) {
+		StringBuffer buffer = new StringBuffer();
+		char[] chars = entryName.toCharArray();
+		for (int i = 0, max = chars.length; i < max; i++) {
+			char currentChar = chars[i];
+			if (!Character.isJavaIdentifierPart(currentChar)) {
+				buffer.append('_');
+			} else {
+				buffer.append(currentChar);
+			}
+		}
+		return String.valueOf(buffer);
+	}
+
+	private IStatus newErrorStatus(String message, Exception e) {
+		return new Status(IStatus.ERROR, PLUGIN_ID, message, e);
+	}
+
+	private IStatus newErrorStatus(String message) {
+		return newErrorStatus(message, null);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Messages.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Messages.java
new file mode 100644
index 0000000..692ebde
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Messages.java
@@ -0,0 +1,114 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+import org.eclipse.osgi.util.NLS;
+
+public class Messages extends NLS {
+	private static final String BUNDLE_NAME = "org.eclipse.equinox.p2.internal.repository.comparator.messages"; //$NON-NLS-1$
+	public static String differentNumberOfEntries;
+	public static String differentEntry;
+	public static String missingEntry;
+	public static String ioexception;
+	public static String ioexceptioninentry;
+	public static String filenotfoundexception;
+
+	public static String disassembler_description;
+	public static String disassembler_opentypedeclaration;
+	public static String disassembler_closetypedeclaration;
+	public static String disassembler_parametername;
+	public static String disassembler_localvariablename;
+	public static String disassembler_endofmethodheader;
+	public static String disassembler_begincommentline;
+	public static String disassembler_fieldhasconstant;
+	public static String disassembler_endoffieldheader;
+	public static String disassembler_sourceattributeheader;
+	public static String disassembler_enclosingmethodheader;
+	public static String disassembler_exceptiontableheader;
+	public static String disassembler_arraydimensions;
+	public static String disassembler_innerattributesheader;
+	public static String disassembler_inner_class_info_name;
+	public static String disassembler_outer_class_info_name;
+	public static String disassembler_inner_name;
+	public static String disassembler_inner_accessflags;
+	public static String disassembler_signatureattributeheader;
+	public static String disassembler_indentation;
+	public static String disassembler_space;
+	public static String disassembler_comma;
+	public static String disassembler_openinnerclassentry;
+	public static String disassembler_closeinnerclassentry;
+	public static String disassembler_deprecated;
+	public static String disassembler_annotationdefaultheader;
+	public static String disassembler_annotationdefaultvalue;
+	public static String disassembler_annotationenumvalue;
+	public static String disassembler_annotationclassvalue;
+	public static String disassembler_annotationannotationvalue;
+	public static String disassembler_annotationarrayvaluestart;
+	public static String disassembler_annotationarrayvalueend;
+	public static String disassembler_annotationentrystart;
+	public static String disassembler_annotationentryend;
+	public static String disassembler_annotationcomponent;
+	public static String disassembler_runtimevisibleannotationsattributeheader;
+	public static String disassembler_runtimeinvisibleannotationsattributeheader;
+	public static String disassembler_runtimevisibleparameterannotationsattributeheader;
+	public static String disassembler_runtimeinvisibleparameterannotationsattributeheader;
+	public static String disassembler_parameterannotationentrystart;
+	public static String classfileformat_versiondetails;
+	public static String classfileformat_methoddescriptor;
+	public static String classfileformat_fieldddescriptor;
+	public static String classfileformat_stacksAndLocals;
+	public static String classfileformat_superflagisnotset;
+	public static String classfileformat_superflagisset;
+	public static String classfileformat_clinitname;
+	public static String classformat_classformatexception;
+	public static String classformat_anewarray;
+	public static String classformat_checkcast;
+	public static String classformat_instanceof;
+	public static String classformat_ldc_w_class;
+	public static String classformat_ldc_w_float;
+	public static String classformat_ldc_w_integer;
+	public static String classformat_ldc_w_string;
+	public static String classformat_ldc2_w_long;
+	public static String classformat_ldc2_w_double;
+	public static String classformat_multianewarray;
+	public static String classformat_new;
+	public static String classformat_iinc;
+	public static String classformat_invokespecial;
+	public static String classformat_invokeinterface;
+	public static String classformat_invokestatic;
+	public static String classformat_invokevirtual;
+	public static String classformat_getfield;
+	public static String classformat_getstatic;
+	public static String classformat_putstatic;
+	public static String classformat_putfield;
+	public static String classformat_newarray_boolean;
+	public static String classformat_newarray_char;
+	public static String classformat_newarray_float;
+	public static String classformat_newarray_double;
+	public static String classformat_newarray_byte;
+	public static String classformat_newarray_short;
+	public static String classformat_newarray_int;
+	public static String classformat_newarray_long;
+	public static String classformat_store;
+	public static String classformat_load;
+	public static String classfileformat_anyexceptionhandler;
+	public static String classfileformat_exceptiontableentry;
+	public static String classfileformat_versionUnknown;
+
+	static {
+		// initialize resource bundle
+		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
+	}
+
+	private Messages() {
+		// prevent instantiation
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/MethodInfo.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/MethodInfo.java
new file mode 100644
index 0000000..cbc9a2b
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/MethodInfo.java
@@ -0,0 +1,213 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+import java.util.Arrays;
+
+public class MethodInfo extends ClassFileStruct {
+	private int accessFlags;
+	private int attributeBytes;
+	private ClassFileAttribute[] attributes;
+	private int attributesCount;
+	private CodeAttribute codeAttribute;
+	private char[] descriptor;
+	private int descriptorIndex;
+	private ExceptionAttribute exceptionAttribute;
+	private boolean isDeprecated;
+	private boolean isSynthetic;
+	private char[] name;
+	private int nameIndex;
+
+	/**
+	 * @param classFileBytes byte[]
+	 * @param constantPool IConstantPool
+	 * @param offset int
+	 * @param decodingFlags int
+	 */
+	public MethodInfo(byte classFileBytes[], ConstantPool constantPool, int offset, int decodingFlags) throws ClassFormatException {
+
+		boolean no_code_attribute = (decodingFlags & ClassFileReader.METHOD_BODIES) == 0;
+		final int flags = u2At(classFileBytes, 0, offset);
+		this.accessFlags = flags;
+		if ((flags & IModifierConstants.ACC_SYNTHETIC) != 0) {
+			this.isSynthetic = true;
+		}
+
+		this.nameIndex = u2At(classFileBytes, 2, offset);
+		ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(this.nameIndex);
+		if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+			throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+		}
+		this.name = constantPoolEntry.getUtf8Value();
+
+		this.descriptorIndex = u2At(classFileBytes, 4, offset);
+		constantPoolEntry = constantPool.decodeEntry(this.descriptorIndex);
+		if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+			throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+		}
+		this.descriptor = constantPoolEntry.getUtf8Value();
+
+		this.attributesCount = u2At(classFileBytes, 6, offset);
+		this.attributes = ClassFileAttribute.NO_ATTRIBUTES;
+		if (this.attributesCount != 0) {
+			if (no_code_attribute && !isAbstract() && !isNative()) {
+				if (this.attributesCount != 1) {
+					this.attributes = new ClassFileAttribute[this.attributesCount - 1];
+				}
+			} else {
+				this.attributes = new ClassFileAttribute[this.attributesCount];
+			}
+		}
+		int attributesIndex = 0;
+		int readOffset = 8;
+		for (int i = 0; i < this.attributesCount; i++) {
+			constantPoolEntry = constantPool.decodeEntry(u2At(classFileBytes, readOffset, offset));
+			if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+			}
+			char[] attributeName = constantPoolEntry.getUtf8Value();
+			if (Arrays.equals(attributeName, AttributeNamesConstants.DEPRECATED)) {
+				this.isDeprecated = true;
+				this.attributes[attributesIndex++] = new ClassFileAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.SYNTHETIC)) {
+				this.isSynthetic = true;
+				this.attributes[attributesIndex++] = new ClassFileAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.CODE)) {
+				if (!no_code_attribute) {
+					this.codeAttribute = new CodeAttribute(classFileBytes, constantPool, offset + readOffset);
+					this.attributes[attributesIndex++] = this.codeAttribute;
+				}
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.EXCEPTIONS)) {
+				this.exceptionAttribute = new ExceptionAttribute(classFileBytes, constantPool, offset + readOffset);
+				this.attributes[attributesIndex++] = this.exceptionAttribute;
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.SIGNATURE)) {
+				this.attributes[attributesIndex++] = new SignatureAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.RUNTIME_VISIBLE_ANNOTATIONS)) {
+				this.attributes[attributesIndex++] = new RuntimeVisibleAnnotationsAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.RUNTIME_INVISIBLE_ANNOTATIONS)) {
+				this.attributes[attributesIndex++] = new RuntimeInvisibleAnnotationsAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS)) {
+				this.attributes[attributesIndex++] = new RuntimeVisibleParameterAnnotationsAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS)) {
+				this.attributes[attributesIndex++] = new RuntimeInvisibleParameterAnnotationsAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (Arrays.equals(attributeName, AttributeNamesConstants.ANNOTATION_DEFAULT)) {
+				this.attributes[attributesIndex++] = new AnnotationDefaultAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else {
+				this.attributes[attributesIndex++] = new ClassFileAttribute(classFileBytes, constantPool, offset + readOffset);
+			}
+			readOffset += (6 + u4At(classFileBytes, readOffset + 2, offset));
+		}
+		this.attributeBytes = readOffset;
+	}
+
+	/**
+	 * @see IMethodInfo#getAccessFlags()
+	 */
+	public int getAccessFlags() {
+		return this.accessFlags;
+	}
+
+	/**
+	 * @see IMethodInfo#getAttributeCount()
+	 */
+	public int getAttributeCount() {
+		return this.attributesCount;
+	}
+
+	/**
+	 * @see IMethodInfo#getAttributes()
+	 */
+	public ClassFileAttribute[] getAttributes() {
+		return this.attributes;
+	}
+
+	/**
+	 * @see IMethodInfo#getCodeAttribute()
+	 */
+	public CodeAttribute getCodeAttribute() {
+		return this.codeAttribute;
+	}
+
+	/**
+	 * @see IMethodInfo#getDescriptor()
+	 */
+	public char[] getDescriptor() {
+		return this.descriptor;
+	}
+
+	/**
+	 * @see IMethodInfo#getDescriptorIndex()
+	 */
+	public int getDescriptorIndex() {
+		return this.descriptorIndex;
+	}
+
+	/**
+	 * @see IMethodInfo#getExceptionAttribute()
+	 */
+	public ExceptionAttribute getExceptionAttribute() {
+		return this.exceptionAttribute;
+	}
+
+	/**
+	 * @see IMethodInfo#getName()
+	 */
+	public char[] getName() {
+		return this.name;
+	}
+
+	/**
+	 * @see IMethodInfo#getNameIndex()
+	 */
+	public int getNameIndex() {
+		return this.nameIndex;
+	}
+
+	private boolean isAbstract() {
+		return (this.accessFlags & IModifierConstants.ACC_ABSTRACT) != 0;
+	}
+
+	/**
+	 * @see IMethodInfo#isClinit()
+	 */
+	public boolean isClinit() {
+		return this.name[0] == '<' && this.name.length == 8; // Can only match <clinit>
+	}
+
+	/**
+	 * @see IMethodInfo#isConstructor()
+	 */
+	public boolean isConstructor() {
+		return this.name[0] == '<' && this.name.length == 6; // Can only match <init>
+	}
+
+	/**
+	 * @see IMethodInfo#isDeprecated()
+	 */
+	public boolean isDeprecated() {
+		return this.isDeprecated;
+	}
+
+	private boolean isNative() {
+		return (this.accessFlags & IModifierConstants.ACC_NATIVE) != 0;
+	}
+
+	/**
+	 * @see IMethodInfo#isSynthetic()
+	 */
+	public boolean isSynthetic() {
+		return this.isSynthetic;
+	}
+
+	int sizeInBytes() {
+		return this.attributeBytes;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/OpcodeStringValues.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/OpcodeStringValues.java
new file mode 100644
index 0000000..76f80e9
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/OpcodeStringValues.java
@@ -0,0 +1,222 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class OpcodeStringValues implements IOpcodeMnemonics {
+
+	public static final String[] BYTECODE_NAMES = new String[256];
+	static {
+		BYTECODE_NAMES[NOP] = "nop"; //$NON-NLS-1$
+		BYTECODE_NAMES[ACONST_NULL] = "aconst_null"; //$NON-NLS-1$
+		BYTECODE_NAMES[ICONST_M1] = "iconst_m1"; //$NON-NLS-1$
+		BYTECODE_NAMES[ICONST_0] = "iconst_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[ICONST_1] = "iconst_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[ICONST_2] = "iconst_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[ICONST_3] = "iconst_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[ICONST_4] = "iconst_4"; //$NON-NLS-1$
+		BYTECODE_NAMES[ICONST_5] = "iconst_5"; //$NON-NLS-1$
+		BYTECODE_NAMES[LCONST_0] = "lconst_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[LCONST_1] = "lconst_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[FCONST_0] = "fconst_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[FCONST_1] = "fconst_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[FCONST_2] = "fconst_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[DCONST_0] = "dconst_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[DCONST_1] = "dconst_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[BIPUSH] = "bipush"; //$NON-NLS-1$
+		BYTECODE_NAMES[SIPUSH] = "sipush"; //$NON-NLS-1$
+		BYTECODE_NAMES[LDC] = "ldc"; //$NON-NLS-1$
+		BYTECODE_NAMES[LDC_W] = "ldc_w"; //$NON-NLS-1$
+		BYTECODE_NAMES[LDC2_W] = "ldc2_w"; //$NON-NLS-1$
+		BYTECODE_NAMES[ILOAD] = "iload"; //$NON-NLS-1$
+		BYTECODE_NAMES[LLOAD] = "lload"; //$NON-NLS-1$
+		BYTECODE_NAMES[FLOAD] = "fload"; //$NON-NLS-1$
+		BYTECODE_NAMES[DLOAD] = "dload"; //$NON-NLS-1$
+		BYTECODE_NAMES[ALOAD] = "aload"; //$NON-NLS-1$
+		BYTECODE_NAMES[ILOAD_0] = "iload_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[ILOAD_1] = "iload_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[ILOAD_2] = "iload_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[ILOAD_3] = "iload_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[LLOAD_0] = "lload_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[LLOAD_1] = "lload_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[LLOAD_2] = "lload_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[LLOAD_3] = "lload_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[FLOAD_0] = "fload_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[FLOAD_1] = "fload_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[FLOAD_2] = "fload_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[FLOAD_3] = "fload_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[DLOAD_0] = "dload_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[DLOAD_1] = "dload_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[DLOAD_2] = "dload_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[DLOAD_3] = "dload_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[ALOAD_0] = "aload_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[ALOAD_1] = "aload_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[ALOAD_2] = "aload_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[ALOAD_3] = "aload_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[IALOAD] = "iaload"; //$NON-NLS-1$
+		BYTECODE_NAMES[LALOAD] = "laload"; //$NON-NLS-1$
+		BYTECODE_NAMES[FALOAD] = "faload"; //$NON-NLS-1$
+		BYTECODE_NAMES[DALOAD] = "daload"; //$NON-NLS-1$
+		BYTECODE_NAMES[AALOAD] = "aaload"; //$NON-NLS-1$
+		BYTECODE_NAMES[BALOAD] = "baload"; //$NON-NLS-1$
+		BYTECODE_NAMES[CALOAD] = "caload"; //$NON-NLS-1$
+		BYTECODE_NAMES[SALOAD] = "saload"; //$NON-NLS-1$
+		BYTECODE_NAMES[ISTORE] = "istore"; //$NON-NLS-1$
+		BYTECODE_NAMES[LSTORE] = "lstore"; //$NON-NLS-1$
+		BYTECODE_NAMES[FSTORE] = "fstore"; //$NON-NLS-1$
+		BYTECODE_NAMES[DSTORE] = "dstore"; //$NON-NLS-1$
+		BYTECODE_NAMES[ASTORE] = "astore"; //$NON-NLS-1$
+		BYTECODE_NAMES[ISTORE_0] = "istore_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[ISTORE_1] = "istore_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[ISTORE_2] = "istore_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[ISTORE_3] = "istore_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[LSTORE_0] = "lstore_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[LSTORE_1] = "lstore_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[LSTORE_2] = "lstore_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[LSTORE_3] = "lstore_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[FSTORE_0] = "fstore_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[FSTORE_1] = "fstore_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[FSTORE_2] = "fstore_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[FSTORE_3] = "fstore_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[DSTORE_0] = "dstore_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[DSTORE_1] = "dstore_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[DSTORE_2] = "dstore_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[DSTORE_3] = "dstore_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[ASTORE_0] = "astore_0"; //$NON-NLS-1$
+		BYTECODE_NAMES[ASTORE_1] = "astore_1"; //$NON-NLS-1$
+		BYTECODE_NAMES[ASTORE_2] = "astore_2"; //$NON-NLS-1$
+		BYTECODE_NAMES[ASTORE_3] = "astore_3"; //$NON-NLS-1$
+		BYTECODE_NAMES[IASTORE] = "iastore"; //$NON-NLS-1$
+		BYTECODE_NAMES[LASTORE] = "lastore"; //$NON-NLS-1$
+		BYTECODE_NAMES[FASTORE] = "fastore"; //$NON-NLS-1$
+		BYTECODE_NAMES[DASTORE] = "dastore"; //$NON-NLS-1$
+		BYTECODE_NAMES[AASTORE] = "aastore"; //$NON-NLS-1$
+		BYTECODE_NAMES[BASTORE] = "bastore"; //$NON-NLS-1$
+		BYTECODE_NAMES[CASTORE] = "castore"; //$NON-NLS-1$
+		BYTECODE_NAMES[SASTORE] = "sastore"; //$NON-NLS-1$
+		BYTECODE_NAMES[POP] = "pop"; //$NON-NLS-1$
+		BYTECODE_NAMES[POP2] = "pop2"; //$NON-NLS-1$
+		BYTECODE_NAMES[DUP] = "dup"; //$NON-NLS-1$
+		BYTECODE_NAMES[DUP_X1] = "dup_x1"; //$NON-NLS-1$
+		BYTECODE_NAMES[DUP_X2] = "dup_x2"; //$NON-NLS-1$
+		BYTECODE_NAMES[DUP2] = "dup2"; //$NON-NLS-1$
+		BYTECODE_NAMES[DUP2_X1] = "dup2_x1"; //$NON-NLS-1$
+		BYTECODE_NAMES[DUP2_X2] = "dup2_x2"; //$NON-NLS-1$
+		BYTECODE_NAMES[SWAP] = "swap"; //$NON-NLS-1$
+		BYTECODE_NAMES[IADD] = "iadd"; //$NON-NLS-1$
+		BYTECODE_NAMES[LADD] = "ladd"; //$NON-NLS-1$
+		BYTECODE_NAMES[FADD] = "fadd"; //$NON-NLS-1$
+		BYTECODE_NAMES[DADD] = "dadd"; //$NON-NLS-1$
+		BYTECODE_NAMES[ISUB] = "isub"; //$NON-NLS-1$
+		BYTECODE_NAMES[LSUB] = "lsub"; //$NON-NLS-1$
+		BYTECODE_NAMES[FSUB] = "fsub"; //$NON-NLS-1$
+		BYTECODE_NAMES[DSUB] = "dsub"; //$NON-NLS-1$
+		BYTECODE_NAMES[IMUL] = "imul"; //$NON-NLS-1$
+		BYTECODE_NAMES[LMUL] = "lmul"; //$NON-NLS-1$
+		BYTECODE_NAMES[FMUL] = "fmul"; //$NON-NLS-1$
+		BYTECODE_NAMES[DMUL] = "dmul"; //$NON-NLS-1$
+		BYTECODE_NAMES[IDIV] = "idiv"; //$NON-NLS-1$
+		BYTECODE_NAMES[LDIV] = "ldiv"; //$NON-NLS-1$
+		BYTECODE_NAMES[FDIV] = "fdiv"; //$NON-NLS-1$
+		BYTECODE_NAMES[DDIV] = "ddiv"; //$NON-NLS-1$
+		BYTECODE_NAMES[IREM] = "irem"; //$NON-NLS-1$
+		BYTECODE_NAMES[LREM] = "lrem"; //$NON-NLS-1$
+		BYTECODE_NAMES[FREM] = "frem"; //$NON-NLS-1$
+		BYTECODE_NAMES[DREM] = "drem"; //$NON-NLS-1$
+		BYTECODE_NAMES[INEG] = "ineg"; //$NON-NLS-1$
+		BYTECODE_NAMES[LNEG] = "lneg"; //$NON-NLS-1$
+		BYTECODE_NAMES[FNEG] = "fneg"; //$NON-NLS-1$
+		BYTECODE_NAMES[DNEG] = "dneg"; //$NON-NLS-1$
+		BYTECODE_NAMES[ISHL] = "ishl"; //$NON-NLS-1$
+		BYTECODE_NAMES[LSHL] = "lshl"; //$NON-NLS-1$
+		BYTECODE_NAMES[ISHR] = "ishr"; //$NON-NLS-1$
+		BYTECODE_NAMES[LSHR] = "lshr"; //$NON-NLS-1$
+		BYTECODE_NAMES[IUSHR] = "iushr"; //$NON-NLS-1$
+		BYTECODE_NAMES[LUSHR] = "lushr"; //$NON-NLS-1$
+		BYTECODE_NAMES[IAND] = "iand"; //$NON-NLS-1$
+		BYTECODE_NAMES[LAND] = "land"; //$NON-NLS-1$
+		BYTECODE_NAMES[IOR] = "ior"; //$NON-NLS-1$
+		BYTECODE_NAMES[LOR] = "lor"; //$NON-NLS-1$
+		BYTECODE_NAMES[IXOR] = "ixor"; //$NON-NLS-1$
+		BYTECODE_NAMES[LXOR] = "lxor"; //$NON-NLS-1$
+		BYTECODE_NAMES[IINC] = "iinc"; //$NON-NLS-1$
+		BYTECODE_NAMES[I2L] = "i2l"; //$NON-NLS-1$
+		BYTECODE_NAMES[I2F] = "i2f"; //$NON-NLS-1$
+		BYTECODE_NAMES[I2D] = "i2d"; //$NON-NLS-1$
+		BYTECODE_NAMES[L2I] = "l2i"; //$NON-NLS-1$
+		BYTECODE_NAMES[L2F] = "l2f"; //$NON-NLS-1$
+		BYTECODE_NAMES[L2D] = "l2d"; //$NON-NLS-1$
+		BYTECODE_NAMES[F2I] = "f2i"; //$NON-NLS-1$
+		BYTECODE_NAMES[F2L] = "f2l"; //$NON-NLS-1$
+		BYTECODE_NAMES[F2D] = "f2d"; //$NON-NLS-1$
+		BYTECODE_NAMES[D2I] = "d2i"; //$NON-NLS-1$
+		BYTECODE_NAMES[D2L] = "d2l"; //$NON-NLS-1$
+		BYTECODE_NAMES[D2F] = "d2f"; //$NON-NLS-1$
+		BYTECODE_NAMES[I2B] = "i2b"; //$NON-NLS-1$
+		BYTECODE_NAMES[I2C] = "i2c"; //$NON-NLS-1$
+		BYTECODE_NAMES[I2S] = "i2s"; //$NON-NLS-1$
+		BYTECODE_NAMES[LCMP] = "lcmp"; //$NON-NLS-1$
+		BYTECODE_NAMES[FCMPL] = "fcmpl"; //$NON-NLS-1$
+		BYTECODE_NAMES[FCMPG] = "fcmpg"; //$NON-NLS-1$
+		BYTECODE_NAMES[DCMPL] = "dcmpl"; //$NON-NLS-1$
+		BYTECODE_NAMES[DCMPG] = "dcmpg"; //$NON-NLS-1$
+		BYTECODE_NAMES[IFEQ] = "ifeq"; //$NON-NLS-1$
+		BYTECODE_NAMES[IFNE] = "ifne"; //$NON-NLS-1$
+		BYTECODE_NAMES[IFLT] = "iflt"; //$NON-NLS-1$
+		BYTECODE_NAMES[IFGE] = "ifge"; //$NON-NLS-1$
+		BYTECODE_NAMES[IFGT] = "ifgt"; //$NON-NLS-1$
+		BYTECODE_NAMES[IFLE] = "ifle"; //$NON-NLS-1$
+		BYTECODE_NAMES[IF_ICMPEQ] = "if_icmpeq"; //$NON-NLS-1$
+		BYTECODE_NAMES[IF_ICMPNE] = "if_icmpne"; //$NON-NLS-1$
+		BYTECODE_NAMES[IF_ICMPLT] = "if_icmplt"; //$NON-NLS-1$
+		BYTECODE_NAMES[IF_ICMPGE] = "if_icmpge"; //$NON-NLS-1$
+		BYTECODE_NAMES[IF_ICMPGT] = "if_icmpgt"; //$NON-NLS-1$
+		BYTECODE_NAMES[IF_ICMPLE] = "if_icmple"; //$NON-NLS-1$
+		BYTECODE_NAMES[IF_ACMPEQ] = "if_acmpeq"; //$NON-NLS-1$
+		BYTECODE_NAMES[IF_ACMPNE] = "if_acmpne"; //$NON-NLS-1$
+		BYTECODE_NAMES[GOTO] = "goto"; //$NON-NLS-1$
+		BYTECODE_NAMES[JSR] = "jsr"; //$NON-NLS-1$
+		BYTECODE_NAMES[RET] = "ret"; //$NON-NLS-1$
+		BYTECODE_NAMES[TABLESWITCH] = "tableswitch"; //$NON-NLS-1$
+		BYTECODE_NAMES[LOOKUPSWITCH] = "lookupswitch"; //$NON-NLS-1$
+		BYTECODE_NAMES[IRETURN] = "ireturn"; //$NON-NLS-1$
+		BYTECODE_NAMES[LRETURN] = "lreturn"; //$NON-NLS-1$
+		BYTECODE_NAMES[FRETURN] = "freturn"; //$NON-NLS-1$
+		BYTECODE_NAMES[DRETURN] = "dreturn"; //$NON-NLS-1$
+		BYTECODE_NAMES[ARETURN] = "areturn"; //$NON-NLS-1$
+		BYTECODE_NAMES[RETURN] = "return"; //$NON-NLS-1$
+		BYTECODE_NAMES[GETSTATIC] = "getstatic"; //$NON-NLS-1$
+		BYTECODE_NAMES[PUTSTATIC] = "putstatic"; //$NON-NLS-1$
+		BYTECODE_NAMES[GETFIELD] = "getfield"; //$NON-NLS-1$
+		BYTECODE_NAMES[PUTFIELD] = "putfield"; //$NON-NLS-1$
+		BYTECODE_NAMES[INVOKEVIRTUAL] = "invokevirtual"; //$NON-NLS-1$
+		BYTECODE_NAMES[INVOKESPECIAL] = "invokespecial"; //$NON-NLS-1$
+		BYTECODE_NAMES[INVOKESTATIC] = "invokestatic"; //$NON-NLS-1$
+		BYTECODE_NAMES[INVOKEINTERFACE] = "invokeinterface"; //$NON-NLS-1$
+		BYTECODE_NAMES[NEW] = "new"; //$NON-NLS-1$
+		BYTECODE_NAMES[NEWARRAY] = "newarray"; //$NON-NLS-1$
+		BYTECODE_NAMES[ANEWARRAY] = "anewarray"; //$NON-NLS-1$
+		BYTECODE_NAMES[ARRAYLENGTH] = "arraylength"; //$NON-NLS-1$
+		BYTECODE_NAMES[ATHROW] = "athrow"; //$NON-NLS-1$
+		BYTECODE_NAMES[CHECKCAST] = "checkcast"; //$NON-NLS-1$
+		BYTECODE_NAMES[INSTANCEOF] = "instanceof"; //$NON-NLS-1$
+		BYTECODE_NAMES[MONITORENTER] = "monitorenter"; //$NON-NLS-1$
+		BYTECODE_NAMES[MONITOREXIT] = "monitorexit"; //$NON-NLS-1$
+		BYTECODE_NAMES[WIDE] = "wide"; //$NON-NLS-1$
+		BYTECODE_NAMES[MULTIANEWARRAY] = "multianewarray"; //$NON-NLS-1$
+		BYTECODE_NAMES[IFNULL] = "ifnull"; //$NON-NLS-1$
+		BYTECODE_NAMES[IFNONNULL] = "ifnonnull"; //$NON-NLS-1$
+		BYTECODE_NAMES[GOTO_W] = "goto_w"; //$NON-NLS-1$
+		BYTECODE_NAMES[JSR_W] = "jsr_w"; //$NON-NLS-1$
+		BYTECODE_NAMES[BREAKPOINT] = "breakpoint"; //$NON-NLS-1$
+		BYTECODE_NAMES[IMPDEP1] = "impdep1"; //$NON-NLS-1$
+		BYTECODE_NAMES[IMPDEP2] = "impdep2"; //$NON-NLS-1$
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ParameterAnnotation.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ParameterAnnotation.java
new file mode 100644
index 0000000..ad7c6dc
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ParameterAnnotation.java
@@ -0,0 +1,63 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class ParameterAnnotation extends ClassFileStruct {
+
+	private static final Annotation[] NO_ENTRIES = new Annotation[0];
+
+	private int annotationsNumber;
+	private Annotation[] annotations;
+	private int readOffset;
+
+	/**
+	 * Constructor for Annotation.
+	 *
+	 * @param classFileBytes
+	 * @param constantPool
+	 * @param offset
+	 * @throws ClassFormatException
+	 */
+	public ParameterAnnotation(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+
+		final int length = u2At(classFileBytes, 0, offset);
+		this.readOffset = 2;
+		this.annotationsNumber = length;
+		if (length != 0) {
+			this.annotations = new Annotation[length];
+			for (int i = 0; i < length; i++) {
+				Annotation annotation = new Annotation(classFileBytes, constantPool, offset + this.readOffset);
+				this.annotations[i] = annotation;
+				this.readOffset += annotation.sizeInBytes();
+			}
+		} else {
+			this.annotations = NO_ENTRIES;
+		}
+	}
+
+	int sizeInBytes() {
+		return this.readOffset;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IParameterAnnotation#getAnnotations()
+	 */
+	public Annotation[] getAnnotations() {
+		return this.annotations;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IParameterAnnotation#getAnnotationsNumber()
+	 */
+	public int getAnnotationsNumber() {
+		return this.annotationsNumber;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeInvisibleAnnotationsAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeInvisibleAnnotationsAttribute.java
new file mode 100644
index 0000000..f2e164c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeInvisibleAnnotationsAttribute.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class RuntimeInvisibleAnnotationsAttribute extends ClassFileAttribute {
+
+	private static final Annotation[] NO_ENTRIES = new Annotation[0];
+	private int annotationsNumber;
+	private Annotation[] annotations;
+
+	/**
+	 * Constructor for RuntimeInvisibleAnnotations.
+	 * @param classFileBytes
+	 * @param constantPool
+	 * @param offset
+	 * @throws ClassFormatException
+	 */
+	public RuntimeInvisibleAnnotationsAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		final int length = u2At(classFileBytes, 6, offset);
+		this.annotationsNumber = length;
+		if (length != 0) {
+			int readOffset = 8;
+			this.annotations = new Annotation[length];
+			for (int i = 0; i < length; i++) {
+				Annotation annotation = new Annotation(classFileBytes, constantPool, offset + readOffset);
+				this.annotations[i] = annotation;
+				readOffset += annotation.sizeInBytes();
+			}
+		} else {
+			this.annotations = NO_ENTRIES;
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IRuntimeInvisibleAnnotations#getAnnotations()
+	 */
+	public Annotation[] getAnnotations() {
+		return this.annotations;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IRuntimeInvisibleAnnotations#getAnnotationsNumber()
+	 */
+	public int getAnnotationsNumber() {
+		return this.annotationsNumber;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeInvisibleParameterAnnotationsAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeInvisibleParameterAnnotationsAttribute.java
new file mode 100644
index 0000000..3c724dd
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeInvisibleParameterAnnotationsAttribute.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class RuntimeInvisibleParameterAnnotationsAttribute extends ClassFileAttribute {
+
+	private static final ParameterAnnotation[] NO_ENTRIES = new ParameterAnnotation[0];
+	private ParameterAnnotation[] parameterAnnotations;
+	private int parametersNumber;
+
+	/**
+	 * Constructor for RuntimeVisibleParameterAnnotations.
+	 * @param classFileBytes
+	 * @param constantPool
+	 * @param offset
+	 * @throws ClassFormatException
+	 */
+	public RuntimeInvisibleParameterAnnotationsAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		final int length = u1At(classFileBytes, 6, offset);
+		this.parametersNumber = length;
+		if (length != 0) {
+			int readOffset = 7;
+			this.parameterAnnotations = new ParameterAnnotation[length];
+			for (int i = 0; i < length; i++) {
+				ParameterAnnotation parameterAnnotation = new ParameterAnnotation(classFileBytes, constantPool, offset + readOffset);
+				this.parameterAnnotations[i] = parameterAnnotation;
+				readOffset += parameterAnnotation.sizeInBytes();
+			}
+		} else {
+			this.parameterAnnotations = NO_ENTRIES;
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IRuntimeInvisibleParameterAnnotations#getAnnotations()
+	 */
+	public ParameterAnnotation[] getParameterAnnotations() {
+		return this.parameterAnnotations;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IRuntimeInvisibleParameterAnnotations#getParametersNumber()
+	 */
+	public int getParametersNumber() {
+		return this.parametersNumber;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeVisibleAnnotationsAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeVisibleAnnotationsAttribute.java
new file mode 100644
index 0000000..ff738fa
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeVisibleAnnotationsAttribute.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class RuntimeVisibleAnnotationsAttribute extends ClassFileAttribute {
+
+	private static final Annotation[] NO_ENTRIES = new Annotation[0];
+	private int annotationsNumber;
+	private Annotation[] annotations;
+
+	/**
+	 * Constructor for RuntimeVisibleAnnotations.
+	 * @param classFileBytes
+	 * @param constantPool
+	 * @param offset
+	 * @throws ClassFormatException
+	 */
+	public RuntimeVisibleAnnotationsAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		final int length = u2At(classFileBytes, 6, offset);
+		this.annotationsNumber = length;
+		if (length != 0) {
+			int readOffset = 8;
+			this.annotations = new Annotation[length];
+			for (int i = 0; i < length; i++) {
+				Annotation annotation = new Annotation(classFileBytes, constantPool, offset + readOffset);
+				this.annotations[i] = annotation;
+				readOffset += annotation.sizeInBytes();
+			}
+		} else {
+			this.annotations = NO_ENTRIES;
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IRuntimeVisibleAnnotations#getAnnotations()
+	 */
+	public Annotation[] getAnnotations() {
+		return this.annotations;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IRuntimeVisibleAnnotations#getAnnotationsNumber()
+	 */
+	public int getAnnotationsNumber() {
+		return this.annotationsNumber;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeVisibleParameterAnnotationsAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeVisibleParameterAnnotationsAttribute.java
new file mode 100644
index 0000000..71700e2
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/RuntimeVisibleParameterAnnotationsAttribute.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class RuntimeVisibleParameterAnnotationsAttribute extends ClassFileAttribute {
+
+	private static final ParameterAnnotation[] NO_ENTRIES = new ParameterAnnotation[0];
+	private int parametersNumber;
+	private ParameterAnnotation[] parameterAnnotations;
+
+	/**
+	 * Constructor for RuntimeVisibleParameterAnnotations.
+	 * @param classFileBytes
+	 * @param constantPool
+	 * @param offset
+	 * @throws ClassFormatException
+	 */
+	public RuntimeVisibleParameterAnnotationsAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		final int length = u1At(classFileBytes, 6, offset);
+		this.parametersNumber = length;
+		if (length != 0) {
+			int readOffset = 7;
+			this.parameterAnnotations = new ParameterAnnotation[length];
+			for (int i = 0; i < length; i++) {
+				ParameterAnnotation parameterAnnotation = new ParameterAnnotation(classFileBytes, constantPool, offset + readOffset);
+				this.parameterAnnotations[i] = parameterAnnotation;
+				readOffset += parameterAnnotation.sizeInBytes();
+			}
+		} else {
+			this.parameterAnnotations = NO_ENTRIES;
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IRuntimeVisibleParameterAnnotations#getAnnotations()
+	 */
+	public ParameterAnnotation[] getParameterAnnotations() {
+		return this.parameterAnnotations;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IRuntimeVisibleParameterAnnotations#getParametersNumber()
+	 */
+	public int getParametersNumber() {
+		return this.parametersNumber;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Signature.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Signature.java
new file mode 100644
index 0000000..24a1010
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Signature.java
@@ -0,0 +1,1163 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+import java.util.ArrayList;
+
+/**
+ * Provides methods for encoding and decoding type and method signature strings.
+ * <p>
+ * Signatures obtained from parsing source files (i.e. files with one of the
+ * {@link JavaCore#getJavaLikeExtensions() Java-like extensions}) differ subtly
+ * from ones obtained from pre-compiled binary (".class") files in class names are
+ * usually left unresolved in the former. For example, the normal resolved form
+ * of the type "String" embeds the class's package name ("Ljava.lang.String;"
+ * or "Ljava/lang/String;"), whereas the unresolved form contains only what is
+ * written "QString;".
+ * </p>
+ * <p>
+ * Generic types introduce to the Java language in J2SE 1.5 add three new
+ * facets to signatures: type variables, parameterized types with type arguments,
+ * and formal type parameters. <i>Rich</i> signatures containing these facets
+ * only occur when dealing with code that makes overt use of the new language
+ * features. All other code, and certainly all Java code written or compiled
+ * with J2SE 1.4 or earlier, involved only <i>simple</i> signatures.
+ * </p>
+ * <p>
+ * Note that the "Q" and "!" formats are specific to Eclipse; the remainder
+ * are specified in the JVM spec.
+ * </p>
+ * <p>
+ * The syntax for a type signature is:
+ * <pre>
+ * TypeSignature ::=
+ *     "B"  // byte
+ *   | "C"  // char
+ *   | "D"  // double
+ *   | "F"  // float
+ *   | "I"  // int
+ *   | "J"  // long
+ *   | "S"  // short
+ *   | "V"  // void
+ *   | "Z"  // boolean
+ *   | "T" + Identifier + ";" // type variable
+ *   | "[" + TypeSignature  // array X[]
+ *   | "!" + TypeSignature  // capture-of ?
+ *   | ResolvedClassTypeSignature
+ *   | UnresolvedClassTypeSignature
+ *
+ * ResolvedClassTypeSignature ::= // resolved named type (in compiled code)
+ *     "L" + Identifier + OptionalTypeArguments
+ *           ( ( "." | "/" ) + Identifier + OptionalTypeArguments )* + ";"
+ *     | OptionalTypeParameters + "L" + Identifier +
+ *           ( ( "." | "/" ) + Identifier )* + ";"
+ *
+ * UnresolvedClassTypeSignature ::= // unresolved named type (in source code)
+ *     "Q" + Identifier + OptionalTypeArguments
+ *           ( ( "." | "/" ) + Identifier + OptionalTypeArguments )* + ";"
+ *     | OptionalTypeParameters "Q" + Identifier +
+ *           ( ( "." | "/" ) + Identifier )* + ";"
+ *
+ * OptionalTypeArguments ::=
+ *     "&lt;" + TypeArgument+ + "&gt;"
+ *   |
+ *
+ * TypeArgument ::=
+ *   | TypeSignature
+ *   | "*" // wildcard ?
+ *   | "+" TypeSignature // wildcard ? extends X
+ *   | "-" TypeSignature // wildcard ? super X
+ *
+ * OptionalTypeParameters ::=
+ *     "&lt;" + FormalTypeParameterSignature+ + "&gt;"
+ *   |
+ * </pre>
+ * </p>
+ * <p>
+ * Examples:
+ * <ul>
+ *   <li><code>"[[I"</code> denotes <code>int[][]</code></li>
+ *   <li><code>"Ljava.lang.String;"</code> denotes <code>java.lang.String</code> in compiled code</li>
+ *   <li><code>"QString;"</code> denotes <code>String</code> in source code</li>
+ *   <li><code>"Qjava.lang.String;"</code> denotes <code>java.lang.String</code> in source code</li>
+ *   <li><code>"[QString;"</code> denotes <code>String[]</code> in source code</li>
+ *   <li><code>"QMap&lt;QString;*&gt;;"</code> denotes <code>Map&lt;String,?&gt;</code> in source code</li>
+ *   <li><code>"Qjava.util.List&ltTV;&gt;;"</code> denotes <code>java.util.List&lt;V&gt;</code> in source code</li>
+ *   <li><code>"&ltE;&gt;Ljava.util.List;"</code> denotes <code>&lt;E&gt;java.util.List</code> in source code</li>
+ * </ul>
+ * </p>
+ * <p>
+ * The syntax for a method signature is:
+ * <pre>
+ * MethodSignature ::= OptionalTypeParameters + "(" + ParamTypeSignature* + ")" + ReturnTypeSignature
+ * ParamTypeSignature ::= TypeSignature
+ * ReturnTypeSignature ::= TypeSignature
+ * </pre>
+ * <p>
+ * Examples:
+ * <ul>
+ *   <li><code>"()I"</code> denotes <code>int foo()</code></li>
+ *   <li><code>"([Ljava.lang.String;)V"</code> denotes <code>void foo(java.lang.String[])</code> in compiled code</li>
+ *   <li><code>"(QString;)QObject;"</code> denotes <code>Object foo(String)</code> in source code</li>
+ * </ul>
+ * </p>
+ * <p>
+ * The syntax for a formal type parameter signature is:
+ * <pre>
+ * FormalTypeParameterSignature ::=
+ *     TypeVariableName + OptionalClassBound + InterfaceBound*
+ * TypeVariableName ::= Identifier
+ * OptionalClassBound ::=
+ *     ":"
+ *   | ":" + TypeSignature
+ * InterfaceBound ::=
+ *     ":" + TypeSignature
+ * </pre>
+ * <p>
+ * Examples:
+ * <ul>
+ *   <li><code>"X:"</code> denotes <code>X</code></li>
+ *   <li><code>"X:QReader;"</code> denotes <code>X extends Reader</code> in source code</li>
+ *   <li><code>"X:QReader;:QSerializable;"</code> denotes <code>X extends Reader & Serializable</code> in source code</li>
+ * </ul>
+ * </p>
+ * <p>
+ * This class provides static methods and constants only.
+ * </p>
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+public final class Signature {
+	/**
+	 * Character constant indicating the primitive type boolean in a signature.
+	 * Value is <code>'Z'</code>.
+	 */
+	public static final char C_BOOLEAN = 'Z';
+
+	/**
+	 * Character constant indicating the primitive type byte in a signature.
+	 * Value is <code>'B'</code>.
+	 */
+	public static final char C_BYTE = 'B';
+
+	/**
+	 * Character constant indicating the primitive type char in a signature.
+	 * Value is <code>'C'</code>.
+	 */
+	public static final char C_CHAR = 'C';
+
+	/**
+	 * Character constant indicating the primitive type double in a signature.
+	 * Value is <code>'D'</code>.
+	 */
+	public static final char C_DOUBLE = 'D';
+
+	/**
+	 * Character constant indicating the primitive type float in a signature.
+	 * Value is <code>'F'</code>.
+	 */
+	public static final char C_FLOAT = 'F';
+
+	/**
+	 * Character constant indicating the primitive type int in a signature.
+	 * Value is <code>'I'</code>.
+	 */
+	public static final char C_INT = 'I';
+
+	/**
+	 * Character constant indicating the semicolon in a signature.
+	 * Value is <code>';'</code>.
+	 */
+	public static final char C_SEMICOLON = ';';
+
+	/**
+	 * Character constant indicating the colon in a signature.
+	 * Value is <code>':'</code>.
+	 * @since 3.0
+	 */
+	public static final char C_COLON = ':';
+
+	/**
+	 * Character constant indicating the primitive type long in a signature.
+	 * Value is <code>'J'</code>.
+	 */
+	public static final char C_LONG = 'J';
+
+	/**
+	 * Character constant indicating the primitive type short in a signature.
+	 * Value is <code>'S'</code>.
+	 */
+	public static final char C_SHORT = 'S';
+
+	/**
+	 * Character constant indicating result type void in a signature.
+	 * Value is <code>'V'</code>.
+	 */
+	public static final char C_VOID = 'V';
+
+	/**
+	 * Character constant indicating the start of a resolved type variable in a
+	 * signature. Value is <code>'T'</code>.
+	 * @since 3.0
+	 */
+	public static final char C_TYPE_VARIABLE = 'T';
+
+	/**
+	 * Character constant indicating an unbound wildcard type argument
+	 * in a signature.
+	 * Value is <code>'*'</code>.
+	 * @since 3.0
+	 */
+	public static final char C_STAR = '*';
+
+	/**
+	 * Character constant indicating an exception in a signature.
+	 * Value is <code>'^'</code>.
+	 * @since 3.1
+	 */
+	public static final char C_EXCEPTION_START = '^';
+
+	/**
+	 * Character constant indicating a bound wildcard type argument
+	 * in a signature with extends clause.
+	 * Value is <code>'+'</code>.
+	 * @since 3.1
+	 */
+	public static final char C_EXTENDS = '+';
+
+	/**
+	 * Character constant indicating a bound wildcard type argument
+	 * in a signature with super clause.
+	 * Value is <code>'-'</code>.
+	 * @since 3.1
+	 */
+	public static final char C_SUPER = '-';
+
+	/**
+	 * Character constant indicating the dot in a signature.
+	 * Value is <code>'.'</code>.
+	 */
+	public static final char C_DOT = '.';
+
+	/**
+	 * Character constant indicating the dollar in a signature.
+	 * Value is <code>'$'</code>.
+	 */
+	public static final char C_DOLLAR = '$';
+
+	/**
+	 * Character constant indicating an array type in a signature.
+	 * Value is <code>'['</code>.
+	 */
+	public static final char C_ARRAY = '[';
+
+	/**
+	 * Character constant indicating the start of a resolved, named type in a
+	 * signature. Value is <code>'L'</code>.
+	 */
+	public static final char C_RESOLVED = 'L';
+
+	/**
+	 * Character constant indicating the start of an unresolved, named type in a
+	 * signature. Value is <code>'Q'</code>.
+	 */
+	public static final char C_UNRESOLVED = 'Q';
+
+	/**
+	 * Character constant indicating the end of a named type in a signature.
+	 * Value is <code>';'</code>.
+	 */
+	public static final char C_NAME_END = ';';
+
+	/**
+	 * Character constant indicating the start of a parameter type list in a
+	 * signature. Value is <code>'('</code>.
+	 */
+	public static final char C_PARAM_START = '(';
+
+	/**
+	 * Character constant indicating the end of a parameter type list in a
+	 * signature. Value is <code>')'</code>.
+	 */
+	public static final char C_PARAM_END = ')';
+
+	/**
+	 * Character constant indicating the start of a formal type parameter
+	 * (or type argument) list in a signature. Value is <code>'&lt;'</code>.
+	 * @since 3.0
+	 */
+	public static final char C_GENERIC_START = '<';
+
+	/**
+	 * Character constant indicating the end of a generic type list in a
+	 * signature. Value is <code>'&gt;'</code>.
+	 * @since 3.0
+	 */
+	public static final char C_GENERIC_END = '>';
+
+	/**
+	 * Character constant indicating a capture of a wildcard type in a
+	 * signature. Value is <code>'!'</code>.
+	 * @since 3.1
+	 */
+	public static final char C_CAPTURE = '!';
+
+	/**
+	 * String constant for the signature of the primitive type boolean.
+	 * Value is <code>"Z"</code>.
+	 */
+	public static final String SIG_BOOLEAN = "Z"; //$NON-NLS-1$
+
+	/**
+	 * String constant for the signature of the primitive type byte.
+	 * Value is <code>"B"</code>.
+	 */
+	public static final String SIG_BYTE = "B"; //$NON-NLS-1$
+
+	/**
+	 * String constant for the signature of the primitive type char.
+	 * Value is <code>"C"</code>.
+	 */
+	public static final String SIG_CHAR = "C"; //$NON-NLS-1$
+
+	/**
+	 * String constant for the signature of the primitive type double.
+	 * Value is <code>"D"</code>.
+	 */
+	public static final String SIG_DOUBLE = "D"; //$NON-NLS-1$
+
+	/**
+	 * String constant for the signature of the primitive type float.
+	 * Value is <code>"F"</code>.
+	 */
+	public static final String SIG_FLOAT = "F"; //$NON-NLS-1$
+
+	/**
+	 * String constant for the signature of the primitive type int.
+	 * Value is <code>"I"</code>.
+	 */
+	public static final String SIG_INT = "I"; //$NON-NLS-1$
+
+	/**
+	 * String constant for the signature of the primitive type long.
+	 * Value is <code>"J"</code>.
+	 */
+	public static final String SIG_LONG = "J"; //$NON-NLS-1$
+
+	/**
+	 * String constant for the signature of the primitive type short.
+	 * Value is <code>"S"</code>.
+	 */
+	public static final String SIG_SHORT = "S"; //$NON-NLS-1$
+
+	/** String constant for the signature of result type void.
+	 * Value is <code>"V"</code>.
+	 */
+	public static final String SIG_VOID = "V"; //$NON-NLS-1$
+
+	/**
+	 * Kind constant for a class type signature.
+	 * @see #getTypeSignatureKind(String)
+	 * @since 3.0
+	 */
+	public static final int CLASS_TYPE_SIGNATURE = 1;
+
+	/**
+	 * Kind constant for a base (primitive or void) type signature.
+	 * @see #getTypeSignatureKind(String)
+	 * @since 3.0
+	 */
+	public static final int BASE_TYPE_SIGNATURE = 2;
+
+	/**
+	 * Kind constant for a type variable signature.
+	 * @see #getTypeSignatureKind(String)
+	 * @since 3.0
+	 */
+	public static final int TYPE_VARIABLE_SIGNATURE = 3;
+
+	/**
+	 * Kind constant for an array type signature.
+	 * @see #getTypeSignatureKind(String)
+	 * @since 3.0
+	 */
+	public static final int ARRAY_TYPE_SIGNATURE = 4;
+
+	/**
+	 * Kind constant for a wildcard type signature.
+	 * @see #getTypeSignatureKind(String)
+	 * @since 3.1
+	 */
+	public static final int WILDCARD_TYPE_SIGNATURE = 5;
+
+	/**
+	 * Kind constant for the capture of a wildcard type signature.
+	 * @see #getTypeSignatureKind(String)
+	 * @since 3.1
+	 */
+	public static final int CAPTURE_TYPE_SIGNATURE = 6;
+
+	private static final char[] BOOLEAN = "boolean".toCharArray(); //$NON-NLS-1$
+	private static final char[] BYTE = "byte".toCharArray(); //$NON-NLS-1$
+	private static final char[] CHAR = "char".toCharArray(); //$NON-NLS-1$
+	private static final char[] DOUBLE = "double".toCharArray(); //$NON-NLS-1$
+	private static final char[] FLOAT = "float".toCharArray(); //$NON-NLS-1$
+	private static final char[] INT = "int".toCharArray(); //$NON-NLS-1$
+	private static final char[] LONG = "long".toCharArray(); //$NON-NLS-1$
+	private static final char[] SHORT = "short".toCharArray(); //$NON-NLS-1$
+	private static final char[] VOID = "void".toCharArray(); //$NON-NLS-1$
+	//	private static final char[] EXTENDS = "extends".toCharArray(); //$NON-NLS-1$
+	//	private static final char[] SUPER = "super".toCharArray(); //$NON-NLS-1$
+	private static final char[] CAPTURE = "capture-of".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * Returns the number of parameter types in the given method signature.
+	 *
+	 * @param methodSignature the method signature
+	 * @return the number of parameters
+	 * @exception IllegalArgumentException if the signature is not syntactically
+	 *   correct
+	 * @since 2.0
+	 */
+	public static int getParameterCount(char[] methodSignature) throws IllegalArgumentException {
+		try {
+			int count = 0;
+			int i = CharOperation.indexOf(C_PARAM_START, methodSignature);
+			if (i < 0) {
+				throw new IllegalArgumentException();
+			}
+			i++;
+			for (;;) {
+				if (methodSignature[i] == C_PARAM_END) {
+					return count;
+				}
+				int e = Utility.scanTypeSignature(methodSignature, i);
+				if (e < 0) {
+					throw new IllegalArgumentException();
+				}
+				i = e + 1;
+				count++;
+			}
+		} catch (ArrayIndexOutOfBoundsException e) {
+			throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Extracts the parameter type signatures from the given method signature.
+	 * The method signature is expected to be dot-based.
+	 *
+	 * @param methodSignature the method signature
+	 * @return the list of parameter type signatures
+	 * @exception IllegalArgumentException if the signature is syntactically
+	 *   incorrect
+	 *
+	 * @since 2.0
+	 */
+	public static char[][] getParameterTypes(char[] methodSignature) throws IllegalArgumentException {
+		try {
+			int count = getParameterCount(methodSignature);
+			char[][] result = new char[count][];
+			if (count == 0) {
+				return result;
+			}
+			int i = CharOperation.indexOf(C_PARAM_START, methodSignature);
+			if (i < 0) {
+				throw new IllegalArgumentException();
+			}
+			i++;
+			int t = 0;
+			for (;;) {
+				if (methodSignature[i] == C_PARAM_END) {
+					return result;
+				}
+				int e = Utility.scanTypeSignature(methodSignature, i);
+				if (e < 0) {
+					throw new IllegalArgumentException();
+				}
+				result[t] = CharOperation.subarray(methodSignature, i, e + 1);
+				t++;
+				i = e + 1;
+			}
+		} catch (ArrayIndexOutOfBoundsException e) {
+			throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Extracts the return type from the given method signature. The method signature is
+	 * expected to be dot-based.
+	 *
+	 * @param methodSignature the method signature
+	 * @return the type signature of the return type
+	 * @exception IllegalArgumentException if the signature is syntactically
+	 *   incorrect
+	 *
+	 * @since 2.0
+	 */
+	public static char[] getReturnType(char[] methodSignature) throws IllegalArgumentException {
+		// skip type parameters
+		int paren = CharOperation.lastIndexOf(C_PARAM_END, methodSignature);
+		if (paren == -1) {
+			throw new IllegalArgumentException();
+		}
+		// there could be thrown exceptions behind, thus scan one type exactly
+		int last = Utility.scanTypeSignature(methodSignature, paren + 1);
+		return CharOperation.subarray(methodSignature, paren + 1, last + 1);
+	}
+
+	/**
+	 * Extracts the class and interface bounds from the given formal type
+	 * parameter signature. The class bound, if present, is listed before
+	 * the interface bounds. The signature is expected to be dot-based.
+	 *
+	 * @param formalTypeParameterSignature the formal type parameter signature
+	 * @return the (possibly empty) list of type signatures for the bounds
+	 * @exception IllegalArgumentException if the signature is syntactically
+	 *   incorrect
+	 * @since 3.0
+	 */
+	public static char[][] getTypeParameterBounds(char[] formalTypeParameterSignature) throws IllegalArgumentException {
+		int p1 = CharOperation.indexOf(C_COLON, formalTypeParameterSignature);
+		if (p1 < 0) {
+			// no ":" means can't be a formal type parameter signature
+			throw new IllegalArgumentException();
+		}
+		if (p1 == formalTypeParameterSignature.length - 1) {
+			// no class or interface bounds
+			return CharOperation.NO_CHAR_CHAR;
+		}
+		int p2 = CharOperation.indexOf(C_COLON, formalTypeParameterSignature, p1 + 1);
+		char[] classBound;
+		if (p2 < 0) {
+			// no interface bounds
+			classBound = CharOperation.subarray(formalTypeParameterSignature, p1 + 1, formalTypeParameterSignature.length);
+			return new char[][] {classBound};
+		}
+		if (p2 == p1 + 1) {
+			// no class bound, but 1 or more interface bounds
+			classBound = null;
+		} else {
+			classBound = CharOperation.subarray(formalTypeParameterSignature, p1 + 1, p2);
+		}
+		char[][] interfaceBounds = CharOperation.splitOn(C_COLON, formalTypeParameterSignature, p2 + 1, formalTypeParameterSignature.length);
+		if (classBound == null) {
+			return interfaceBounds;
+		}
+		int resultLength = interfaceBounds.length + 1;
+		char[][] result = new char[resultLength][];
+		result[0] = classBound;
+		System.arraycopy(interfaceBounds, 0, result, 1, interfaceBounds.length);
+		return result;
+	}
+
+	/**
+	 * Extracts the type parameter signatures from the given method or type signature.
+	 * The method or type signature is expected to be dot-based.
+	 *
+	 * @param methodOrTypeSignature the method or type signature
+	 * @return the list of type parameter signatures
+	 * @exception IllegalArgumentException if the signature is syntactically
+	 *   incorrect
+	 *
+	 * @since 3.1
+	 */
+	public static char[][] getTypeParameters(char[] methodOrTypeSignature) throws IllegalArgumentException {
+		try {
+			int length = methodOrTypeSignature.length;
+			if (length == 0)
+				return CharOperation.NO_CHAR_CHAR;
+			if (methodOrTypeSignature[0] != C_GENERIC_START)
+				return CharOperation.NO_CHAR_CHAR;
+
+			ArrayList paramList = new ArrayList(1);
+			int paramStart = 1, i = 1; // start after leading '<'
+			while (i < length) {
+				if (methodOrTypeSignature[i] == C_GENERIC_END) {
+					int size = paramList.size();
+					if (size == 0)
+						throw new IllegalArgumentException();
+					char[][] result;
+					paramList.toArray(result = new char[size][]);
+					return result;
+				}
+				i = CharOperation.indexOf(C_COLON, methodOrTypeSignature, i);
+				if (i < 0 || i >= length)
+					throw new IllegalArgumentException();
+				// iterate over bounds
+				while (methodOrTypeSignature[i] == ':') {
+					i++; // skip colon
+					switch (methodOrTypeSignature[i]) {
+						case ':' :
+							// no class bound
+							break;
+						case C_GENERIC_END :
+							break;
+						case C_RESOLVED :
+							try {
+								i = Utility.scanClassTypeSignature(methodOrTypeSignature, i);
+								i++; // position at start of next param if any
+							} catch (IllegalArgumentException e) {
+								// not a class type signature -> it is a new type parameter
+							}
+							break;
+						case C_ARRAY :
+							try {
+								i = Utility.scanArrayTypeSignature(methodOrTypeSignature, i);
+								i++; // position at start of next param if any
+							} catch (IllegalArgumentException e) {
+								// not an array type signature -> it is a new type parameter
+							}
+							break;
+						case C_TYPE_VARIABLE :
+							try {
+								i = Utility.scanTypeVariableSignature(methodOrTypeSignature, i);
+								i++; // position at start of next param if any
+							} catch (IllegalArgumentException e) {
+								// not a type variable signature -> it is a new type parameter
+							}
+							break;
+						// default: another type parameter is starting
+					}
+				}
+				paramList.add(CharOperation.subarray(methodOrTypeSignature, paramStart, i));
+				paramStart = i; // next param start from here
+			}
+		} catch (ArrayIndexOutOfBoundsException e) {
+			// invalid signature, fall through
+		}
+		throw new IllegalArgumentException();
+	}
+
+	/**
+	 * Converts the given type signature to a readable string. The signature is expected to
+	 * be dot-based.
+	 *
+	 * <p>
+	 * For example:
+	 * <pre>
+	 * <code>
+	 * toString({'[', 'L', 'j', 'a', 'v', 'a', '.', 'l', 'a', 'n', 'g', '.', 'S', 't', 'r', 'i', 'n', 'g', ';'}) -> {'j', 'a', 'v', 'a', '.', 'l', 'a', 'n', 'g', '.', 'S', 't', 'r', 'i', 'n', 'g', '[', ']'}
+	 * toString({'I'}) -> {'i', 'n', 't'}
+	 * toString({'+', 'L', 'O', 'b', 'j', 'e', 'c', 't', ';'}) -> {'?', ' ', 'e', 'x', 't', 'e', 'n', 'd', 's', ' ', 'O', 'b', 'j', 'e', 'c', 't'}
+	 * </code>
+	 * </pre>
+	 * </p>
+	 * <p>
+	 * Note: This method assumes that a type signature containing a <code>'$'</code>
+	 * is an inner type signature. While this is correct in most cases, someone could
+	 * define a non-inner type name containing a <code>'$'</code>. Handling this
+	 * correctly in all cases would have required resolving the signature, which
+	 * generally not feasible.
+	 * </p>
+	 *
+	 * @param signature the type signature
+	 * @return the string representation of the type
+	 * @exception IllegalArgumentException if the signature is not syntactically
+	 *   correct
+	 *
+	 * @since 2.0
+	 */
+	public static char[] toCharArray(char[] signature) throws IllegalArgumentException {
+		int sigLength = signature.length;
+		if (sigLength == 0 || signature[0] == C_PARAM_START || signature[0] == C_GENERIC_START) {
+			return toCharArray(signature, CharOperation.NO_CHAR, null, true, true);
+		}
+
+		StringBuffer buffer = new StringBuffer(signature.length + 10);
+		appendTypeSignature(signature, 0, true, buffer);
+		char[] result = new char[buffer.length()];
+		buffer.getChars(0, buffer.length(), result, 0);
+		return result;
+	}
+
+	/**
+	 * Converts the given method signature to a readable form. The method signature is expected to
+	 * be dot-based.
+	 * <p>
+	 * For example:
+	 * <pre>
+	 * <code>
+	 * toString("([Ljava.lang.String;)V", "main", new String[] {"args"}, false, true) -> "void main(String[] args)"
+	 * </code>
+	 * </pre>
+	 * </p>
+	 *
+	 * @param methodSignature the method signature to convert
+	 * @param methodName the name of the method to insert in the result, or
+	 *   <code>null</code> if no method name is to be included
+	 * @param parameterNames the parameter names to insert in the result, or
+	 *   <code>null</code> if no parameter names are to be included; if supplied,
+	 *   the number of parameter names must match that of the method signature
+	 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
+	 *   qualified, and <code>false</code> to use only simple names
+	 * @param includeReturnType <code>true</code> if the return type is to be
+	 *   included
+	 * @param isVargArgs <code>true</code> if the last argument should be displayed as a
+	 * variable argument,  <code>false</code> otherwise.
+	 * @return the char array representation of the method signature
+	 *
+	 * @since 3.1
+	 */
+	public static char[] toCharArray(char[] methodSignature, char[] methodName, char[][] parameterNames, boolean fullyQualifyTypeNames, boolean includeReturnType, boolean isVargArgs) {
+		int firstParen = CharOperation.indexOf(C_PARAM_START, methodSignature);
+		if (firstParen == -1) {
+			throw new IllegalArgumentException();
+		}
+
+		StringBuffer buffer = new StringBuffer(methodSignature.length + 10);
+
+		// return type
+		if (includeReturnType) {
+			char[] rts = getReturnType(methodSignature);
+			appendTypeSignature(rts, 0, fullyQualifyTypeNames, buffer);
+			buffer.append(' ');
+		}
+
+		// selector
+		if (methodName != null) {
+			buffer.append(methodName);
+		}
+
+		// parameters
+		buffer.append('(');
+		char[][] pts = getParameterTypes(methodSignature);
+		for (int i = 0, max = pts.length; i < max; i++) {
+			if (i == max - 1) {
+				appendTypeSignature(pts[i], 0, fullyQualifyTypeNames, buffer, isVargArgs);
+			} else {
+				appendTypeSignature(pts[i], 0, fullyQualifyTypeNames, buffer);
+			}
+			if (parameterNames != null) {
+				buffer.append(' ');
+				buffer.append(parameterNames[i]);
+			}
+			if (i != pts.length - 1) {
+				buffer.append(',');
+				buffer.append(' ');
+			}
+		}
+		buffer.append(')');
+		char[] result = new char[buffer.length()];
+		buffer.getChars(0, buffer.length(), result, 0);
+		return result;
+	}
+
+	/**
+	 * Scans the given string for a type signature starting at the given
+	 * index and appends it to the given buffer, and returns the index of the last
+	 * character.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
+	 *   qualified, and <code>false</code> to use only simple names
+	 * @param buffer the string buffer to append to
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type signature
+	 * @see Utility#scanTypeSignature(char[], int)
+	 */
+	private static int appendTypeSignature(char[] string, int start, boolean fullyQualifyTypeNames, StringBuffer buffer) {
+		return appendTypeSignature(string, start, fullyQualifyTypeNames, buffer, false);
+	}
+
+	/**
+	 * Scans the given string for a type signature starting at the given
+	 * index and appends it to the given buffer, and returns the index of the last
+	 * character.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
+	 *   qualified, and <code>false</code> to use only simple names
+	 * @param buffer the string buffer to append to
+	 * @param isVarArgs <code>true</code> if the type must be displayed as a
+	 * variable argument, <code>false</code> otherwise. In this case, the type must be an array type
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type signature, or if isVarArgs is <code>true</code>,
+	 * and the type is not an array type signature.
+	 * @see Utility#scanTypeSignature(char[], int)
+	 */
+	private static int appendTypeSignature(char[] string, int start, boolean fullyQualifyTypeNames, StringBuffer buffer, boolean isVarArgs) {
+		// need a minimum 1 char
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (isVarArgs) {
+			switch (c) {
+				case C_ARRAY :
+					return appendArrayTypeSignature(string, start, fullyQualifyTypeNames, buffer, true);
+				case C_RESOLVED :
+				case C_UNRESOLVED :
+				case C_TYPE_VARIABLE :
+				case C_BOOLEAN :
+				case C_BYTE :
+				case C_CHAR :
+				case C_DOUBLE :
+				case C_FLOAT :
+				case C_INT :
+				case C_LONG :
+				case C_SHORT :
+				case C_VOID :
+				case C_STAR :
+				case C_EXTENDS :
+				case C_SUPER :
+				case C_CAPTURE :
+				default :
+					throw new IllegalArgumentException(); // a var args is an array type
+			}
+		}
+		switch (c) {
+			case C_ARRAY :
+				return appendArrayTypeSignature(string, start, fullyQualifyTypeNames, buffer);
+			case C_RESOLVED :
+			case C_UNRESOLVED :
+				return appendClassTypeSignature(string, start, fullyQualifyTypeNames, buffer);
+			case C_TYPE_VARIABLE :
+				int e = Utility.scanTypeVariableSignature(string, start);
+				buffer.append(string, start + 1, e - start - 1);
+				return e;
+			case C_BOOLEAN :
+				buffer.append(BOOLEAN);
+				return start;
+			case C_BYTE :
+				buffer.append(BYTE);
+				return start;
+			case C_CHAR :
+				buffer.append(CHAR);
+				return start;
+			case C_DOUBLE :
+				buffer.append(DOUBLE);
+				return start;
+			case C_FLOAT :
+				buffer.append(FLOAT);
+				return start;
+			case C_INT :
+				buffer.append(INT);
+				return start;
+			case C_LONG :
+				buffer.append(LONG);
+				return start;
+			case C_SHORT :
+				buffer.append(SHORT);
+				return start;
+			case C_VOID :
+				buffer.append(VOID);
+				return start;
+			case C_CAPTURE :
+				return appendCaptureTypeSignature(string, start, fullyQualifyTypeNames, buffer);
+			case C_STAR :
+			case C_EXTENDS :
+			case C_SUPER :
+				return appendTypeArgumentSignature(string, start, fullyQualifyTypeNames, buffer);
+			default :
+				throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Scans the given string for an array type signature starting at the given
+	 * index and appends it to the given buffer, and returns the index of the last
+	 * character.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
+	 *   qualified, and <code>false</code> to use only simple names
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not an array type signature
+	 * @see Utility#scanArrayTypeSignature(char[], int)
+	 */
+	private static int appendArrayTypeSignature(char[] string, int start, boolean fullyQualifyTypeNames, StringBuffer buffer) {
+		return appendArrayTypeSignature(string, start, fullyQualifyTypeNames, buffer, false);
+	}
+
+	/**
+	 * Scans the given string for an array type signature starting at the given
+	 * index and appends it to the given buffer, and returns the index of the last
+	 * character.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
+	 *   qualified, and <code>false</code> to use only simple names
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not an array type signature
+	 * @see Utility#scanArrayTypeSignature(char[], int)
+	 */
+	private static int appendCaptureTypeSignature(char[] string, int start, boolean fullyQualifyTypeNames, StringBuffer buffer) {
+		// need a minimum 2 char
+		if (start >= string.length - 1) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (c != C_CAPTURE) {
+			throw new IllegalArgumentException();
+		}
+		buffer.append(CAPTURE).append(' ');
+		return appendTypeArgumentSignature(string, start + 1, fullyQualifyTypeNames, buffer);
+	}
+
+	/**
+	 * Scans the given string for an array type signature starting at the given
+	 * index and appends it to the given buffer, and returns the index of the last
+	 * character.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
+	 *   qualified, and <code>false</code> to use only simple names
+	 * @param isVarArgs <code>true</code> if the array type must be displayed as a
+	 * variable argument, <code>false</code> otherwise
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not an array type signature
+	 * @see Utility#scanArrayTypeSignature(char[], int)
+	 */
+	private static int appendArrayTypeSignature(char[] string, int start, boolean fullyQualifyTypeNames, StringBuffer buffer, boolean isVarArgs) {
+		int length = string.length;
+		// need a minimum 2 char
+		if (start >= length - 1) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (c != C_ARRAY) {
+			throw new IllegalArgumentException();
+		}
+
+		int index = start;
+		c = string[++index];
+		while (c == C_ARRAY) {
+			// need a minimum 2 char
+			if (index >= length - 1) {
+				throw new IllegalArgumentException();
+			}
+			c = string[++index];
+		}
+
+		int e = appendTypeSignature(string, index, fullyQualifyTypeNames, buffer);
+
+		for (int i = 1, dims = index - start; i < dims; i++) {
+			buffer.append('[').append(']');
+		}
+
+		if (isVarArgs) {
+			buffer.append('.').append('.').append('.');
+		} else {
+			buffer.append('[').append(']');
+		}
+		return e;
+	}
+
+	/**
+	 * Scans the given string for a class type signature starting at the given
+	 * index and appends it to the given buffer, and returns the index of the last
+	 * character.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
+	 *   qualified, and <code>false</code> to use only simple names
+	 * @param buffer the string buffer to append to
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a class type signature
+	 * @see Utility#scanClassTypeSignature(char[], int)
+	 */
+	private static int appendClassTypeSignature(char[] string, int start, boolean fullyQualifyTypeNames, StringBuffer buffer) {
+		// need a minimum 3 chars "Lx;"
+		if (start >= string.length - 2) {
+			throw new IllegalArgumentException();
+		}
+		// must start in "L" or "Q"
+		char c = string[start];
+		if (c != C_RESOLVED && c != C_UNRESOLVED) {
+			throw new IllegalArgumentException();
+		}
+		boolean resolved = (c == C_RESOLVED);
+		boolean removePackageQualifiers = !fullyQualifyTypeNames;
+		if (!resolved) {
+			// keep everything in an unresolved name
+			removePackageQualifiers = false;
+		}
+		int p = start + 1;
+		int checkpoint = buffer.length();
+		int innerTypeStart = -1;
+		boolean inAnonymousType = false;
+		while (true) {
+			if (p >= string.length) {
+				throw new IllegalArgumentException();
+			}
+			c = string[p];
+			switch (c) {
+				case C_SEMICOLON :
+					// all done
+					return p;
+				case C_GENERIC_START :
+					int e = appendTypeArgumentSignatures(string, p, fullyQualifyTypeNames, buffer);
+					// once we hit type arguments there are no more package prefixes
+					removePackageQualifiers = false;
+					p = e;
+					break;
+				case C_DOT :
+					if (removePackageQualifiers) {
+						// erase package prefix
+						buffer.setLength(checkpoint);
+					} else {
+						buffer.append('.');
+					}
+					break;
+				case '/' :
+					if (removePackageQualifiers) {
+						// erase package prefix
+						buffer.setLength(checkpoint);
+					} else {
+						buffer.append('/');
+					}
+					break;
+				case C_DOLLAR :
+					innerTypeStart = buffer.length();
+					inAnonymousType = false;
+					if (resolved) {
+						// once we hit "$" there are no more package prefixes
+						removePackageQualifiers = false;
+						/**
+						 * Convert '$' in resolved type signatures into '.'.
+						 * NOTE: This assumes that the type signature is an inner type
+						 * signature. This is true in most cases, but someone can define a
+						 * non-inner type name containing a '$'.
+						 */
+						buffer.append('.');
+					}
+					break;
+				default :
+					if (innerTypeStart != -1 && !inAnonymousType && Character.isDigit(c)) {
+						inAnonymousType = true;
+						buffer.setLength(innerTypeStart); // remove '.'
+						buffer.insert(checkpoint, "new "); //$NON-NLS-1$
+						buffer.append("(){}"); //$NON-NLS-1$
+					}
+					if (!inAnonymousType)
+						buffer.append(c);
+					innerTypeStart = -1;
+			}
+			p++;
+		}
+	}
+
+	/**
+	 * Scans the given string for a list of type arguments signature starting at the
+	 * given index and appends it to the given buffer, and returns the index of the
+	 * last character.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
+	 *   qualified, and <code>false</code> to use only simple names
+	 * @param buffer the string buffer to append to
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a list of type argument
+	 * signatures
+	 * @see Utility#scanTypeArgumentSignatures(char[], int)
+	 */
+	private static int appendTypeArgumentSignatures(char[] string, int start, boolean fullyQualifyTypeNames, StringBuffer buffer) {
+		// need a minimum 2 char "<>"
+		if (start >= string.length - 1) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (c != C_GENERIC_START) {
+			throw new IllegalArgumentException();
+		}
+		buffer.append('<');
+		int p = start + 1;
+		int count = 0;
+		while (true) {
+			if (p >= string.length) {
+				throw new IllegalArgumentException();
+			}
+			c = string[p];
+			if (c == C_GENERIC_END) {
+				buffer.append('>');
+				return p;
+			}
+			if (count != 0) {
+				buffer.append(',');
+			}
+			int e = appendTypeArgumentSignature(string, p, fullyQualifyTypeNames, buffer);
+			count++;
+			p = e + 1;
+		}
+	}
+
+	/**
+	 * Scans the given string for a type argument signature starting at the given
+	 * index and appends it to the given buffer, and returns the index of the last
+	 * character.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
+	 *   qualified, and <code>false</code> to use only simple names
+	 * @param buffer the string buffer to append to
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type argument signature
+	 * @see Utility#scanTypeArgumentSignature(char[], int)
+	 */
+	private static int appendTypeArgumentSignature(char[] string, int start, boolean fullyQualifyTypeNames, StringBuffer buffer) {
+		// need a minimum 1 char
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		switch (c) {
+			case C_STAR :
+				buffer.append('?');
+				return start;
+			case C_EXTENDS :
+				buffer.append("? extends "); //$NON-NLS-1$
+				return appendTypeSignature(string, start + 1, fullyQualifyTypeNames, buffer);
+			case C_SUPER :
+				buffer.append("? super "); //$NON-NLS-1$
+				return appendTypeSignature(string, start + 1, fullyQualifyTypeNames, buffer);
+			default :
+				return appendTypeSignature(string, start, fullyQualifyTypeNames, buffer);
+		}
+	}
+
+	/**
+	 * Converts the given method signature to a readable form. The method signature is expected to
+	 * be dot-based.
+	 * <p>
+	 * For example:
+	 * <pre>
+	 * <code>
+	 * toString("([Ljava.lang.String;)V", "main", new String[] {"args"}, false, true) -> "void main(String[] args)"
+	 * </code>
+	 * </pre>
+	 * </p>
+	 *
+	 * @param methodSignature the method signature to convert
+	 * @param methodName the name of the method to insert in the result, or
+	 *   <code>null</code> if no method name is to be included
+	 * @param parameterNames the parameter names to insert in the result, or
+	 *   <code>null</code> if no parameter names are to be included; if supplied,
+	 *   the number of parameter names must match that of the method signature
+	 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
+	 *   qualified, and <code>false</code> to use only simple names
+	 * @param includeReturnType <code>true</code> if the return type is to be
+	 *   included
+	 * @return the char array representation of the method signature
+	 *
+	 * @since 2.0
+	 */
+	public static char[] toCharArray(char[] methodSignature, char[] methodName, char[][] parameterNames, boolean fullyQualifyTypeNames, boolean includeReturnType) {
+		return toCharArray(methodSignature, methodName, parameterNames, fullyQualifyTypeNames, includeReturnType, false);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SignatureAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SignatureAttribute.java
new file mode 100644
index 0000000..e602410
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SignatureAttribute.java
@@ -0,0 +1,42 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class SignatureAttribute extends ClassFileAttribute {
+
+	private int signatureIndex;
+	private char[] signature;
+
+	SignatureAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		final int index = u2At(classFileBytes, 6, offset);
+		this.signatureIndex = index;
+		ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(index);
+		if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+			throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+		}
+		this.signature = constantPoolEntry.getUtf8Value();
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.ISignatureAttribute#getSignatureIndex()
+	 */
+	public int getSignatureIndex() {
+		return this.signatureIndex;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.ISignatureAttribute#getSignature()
+	 */
+	public char[] getSignature() {
+		return this.signature;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SourceFileAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SourceFileAttribute.java
new file mode 100644
index 0000000..4ea520b
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SourceFileAttribute.java
@@ -0,0 +1,49 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public class SourceFileAttribute extends ClassFileAttribute {
+
+	private int sourceFileIndex;
+	private char[] sourceFileName;
+
+	/**
+	 * Constructor for SourceFileAttribute.
+	 * @param classFileBytes
+	 * @param constantPool
+	 * @param offset
+	 * @throws ClassFormatException
+	 */
+	public SourceFileAttribute(byte[] classFileBytes, ConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		this.sourceFileIndex = u2At(classFileBytes, 6, offset);
+		ConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(this.sourceFileIndex);
+		if (constantPoolEntry.getKind() != ConstantPoolConstant.CONSTANT_Utf8) {
+			throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+		}
+		this.sourceFileName = constantPoolEntry.getUtf8Value();
+	}
+
+	/**
+	 * @see ISourceAttribute#getSourceFileIndex()
+	 */
+	public int getSourceFileIndex() {
+		return this.sourceFileIndex;
+	}
+
+	/**
+	 * @see ISourceAttribute#getSourceFileName()
+	 */
+	public char[] getSourceFileName() {
+		return this.sourceFileName;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/TypeConstants.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/TypeConstants.java
new file mode 100644
index 0000000..1e000fb
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/TypeConstants.java
@@ -0,0 +1,153 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+public interface TypeConstants {
+
+	char[] JAVA = "java".toCharArray(); //$NON-NLS-1$
+	char[] LANG = "lang".toCharArray(); //$NON-NLS-1$
+	char[] IO = "io".toCharArray(); //$NON-NLS-1$
+	char[] UTIL = "util".toCharArray(); //$NON-NLS-1$
+	char[] ANNOTATION = "annotation".toCharArray(); //$NON-NLS-1$
+	char[] REFLECT = "reflect".toCharArray(); //$NON-NLS-1$
+	char[] LENGTH = "length".toCharArray(); //$NON-NLS-1$
+	char[] CLONE = "clone".toCharArray(); //$NON-NLS-1$
+	char[] EQUALS = "equals".toCharArray(); //$NON-NLS-1$
+	char[] GETCLASS = "getClass".toCharArray(); //$NON-NLS-1$
+	char[] HASHCODE = "hashCode".toCharArray(); //$NON-NLS-1$
+	char[] OBJECT = "Object".toCharArray(); //$NON-NLS-1$
+	char[] MAIN = "main".toCharArray(); //$NON-NLS-1$
+	char[] SERIALVERSIONUID = "serialVersionUID".toCharArray(); //$NON-NLS-1$
+	char[] SERIALPERSISTENTFIELDS = "serialPersistentFields".toCharArray(); //$NON-NLS-1$
+	char[] READRESOLVE = "readResolve".toCharArray(); //$NON-NLS-1$
+	char[] WRITEREPLACE = "writeReplace".toCharArray(); //$NON-NLS-1$
+	char[] READOBJECT = "readObject".toCharArray(); //$NON-NLS-1$
+	char[] WRITEOBJECT = "writeObject".toCharArray(); //$NON-NLS-1$
+	char[] CharArray_JAVA_LANG_OBJECT = "java.lang.Object".toCharArray(); //$NON-NLS-1$
+	char[] CharArray_JAVA_LANG_ENUM = "java.lang.Enum".toCharArray(); //$NON-NLS-1$
+	char[] CharArray_JAVA_LANG_ANNOTATION_ANNOTATION = "java.lang.annotation.Annotation".toCharArray(); //$NON-NLS-1$
+	char[] CharArray_JAVA_IO_OBJECTINPUTSTREAM = "java.io.ObjectInputStream".toCharArray(); //$NON-NLS-1$
+	char[] CharArray_JAVA_IO_OBJECTOUTPUTSTREAM = "java.io.ObjectOutputStream".toCharArray(); //$NON-NLS-1$
+	char[] CharArray_JAVA_IO_OBJECTSTREAMFIELD = "java.io.ObjectStreamField".toCharArray(); //$NON-NLS-1$
+	char[] ANONYM_PREFIX = "new ".toCharArray(); //$NON-NLS-1$
+	char[] ANONYM_SUFFIX = "(){}".toCharArray(); //$NON-NLS-1$
+	char[] WILDCARD_NAME = {'?'};
+	char[] WILDCARD_SUPER = " super ".toCharArray(); //$NON-NLS-1$
+	char[] WILDCARD_EXTENDS = " extends ".toCharArray(); //$NON-NLS-1$
+	char[] WILDCARD_MINUS = {'-'};
+	char[] WILDCARD_STAR = {'*'};
+	char[] WILDCARD_PLUS = {'+'};
+	char[] WILDCARD_CAPTURE_NAME_PREFIX = "capture#".toCharArray(); //$NON-NLS-1$
+	char[] WILDCARD_CAPTURE_NAME_SUFFIX = "-of ".toCharArray(); //$NON-NLS-1$
+	char[] WILDCARD_CAPTURE = {'!'};
+	char[] BYTE = "byte".toCharArray(); //$NON-NLS-1$
+	char[] SHORT = "short".toCharArray(); //$NON-NLS-1$
+	char[] INT = "int".toCharArray(); //$NON-NLS-1$
+	char[] LONG = "long".toCharArray(); //$NON-NLS-1$
+	char[] FLOAT = "float".toCharArray(); //$NON-NLS-1$
+	char[] DOUBLE = "double".toCharArray(); //$NON-NLS-1$
+	char[] CHAR = "char".toCharArray(); //$NON-NLS-1$
+	char[] BOOLEAN = "boolean".toCharArray(); //$NON-NLS-1$
+	char[] NULL = "null".toCharArray(); //$NON-NLS-1$
+	char[] VOID = "void".toCharArray(); //$NON-NLS-1$
+	char[] VALUE = "value".toCharArray(); //$NON-NLS-1$
+	char[] VALUES = "values".toCharArray(); //$NON-NLS-1$
+	char[] VALUEOF = "valueOf".toCharArray(); //$NON-NLS-1$
+	char[] UPPER_SOURCE = "SOURCE".toCharArray(); //$NON-NLS-1$
+	char[] UPPER_CLASS = "CLASS".toCharArray(); //$NON-NLS-1$
+	char[] UPPER_RUNTIME = "RUNTIME".toCharArray(); //$NON-NLS-1$
+	char[] ANNOTATION_PREFIX = "@".toCharArray(); //$NON-NLS-1$
+	char[] ANNOTATION_SUFFIX = "()".toCharArray(); //$NON-NLS-1$
+	char[] TYPE = "TYPE".toCharArray(); //$NON-NLS-1$
+	char[] UPPER_FIELD = "FIELD".toCharArray(); //$NON-NLS-1$
+	char[] UPPER_METHOD = "METHOD".toCharArray(); //$NON-NLS-1$
+	char[] UPPER_PARAMETER = "PARAMETER".toCharArray(); //$NON-NLS-1$
+	char[] UPPER_CONSTRUCTOR = "CONSTRUCTOR".toCharArray(); //$NON-NLS-1$
+	char[] UPPER_LOCAL_VARIABLE = "LOCAL_VARIABLE".toCharArray(); //$NON-NLS-1$
+	char[] UPPER_ANNOTATION_TYPE = "ANNOTATION_TYPE".toCharArray(); //$NON-NLS-1$
+	char[] UPPER_PACKAGE = "PACKAGE".toCharArray(); //$NON-NLS-1$
+
+	// Constant compound names
+	char[][] JAVA_LANG = {JAVA, LANG};
+	char[][] JAVA_IO = {JAVA, IO};
+	char[][] JAVA_LANG_ANNOTATION_ANNOTATION = {JAVA, LANG, ANNOTATION, "Annotation".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ASSERTIONERROR = {JAVA, LANG, "AssertionError".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_CLASS = {JAVA, LANG, "Class".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_CLASSNOTFOUNDEXCEPTION = {JAVA, LANG, "ClassNotFoundException".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_CLONEABLE = {JAVA, LANG, "Cloneable".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ENUM = {JAVA, LANG, "Enum".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_EXCEPTION = {JAVA, LANG, "Exception".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ERROR = {JAVA, LANG, "Error".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ILLEGALARGUMENTEXCEPTION = {JAVA, LANG, "IllegalArgumentException".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ITERABLE = {JAVA, LANG, "Iterable".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_NOCLASSDEFERROR = {JAVA, LANG, "NoClassDefError".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_OBJECT = {JAVA, LANG, OBJECT};
+	char[][] JAVA_LANG_STRING = {JAVA, LANG, "String".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_STRINGBUFFER = {JAVA, LANG, "StringBuffer".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_STRINGBUILDER = {JAVA, LANG, "StringBuilder".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_SYSTEM = {JAVA, LANG, "System".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_RUNTIMEEXCEPTION = {JAVA, LANG, "RuntimeException".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_THROWABLE = {JAVA, LANG, "Throwable".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_REFLECT_CONSTRUCTOR = {JAVA, LANG, REFLECT, "Constructor".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_IO_PRINTSTREAM = {JAVA, IO, "PrintStream".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_IO_SERIALIZABLE = {JAVA, IO, "Serializable".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_BYTE = {JAVA, LANG, "Byte".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_SHORT = {JAVA, LANG, "Short".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_CHARACTER = {JAVA, LANG, "Character".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_INTEGER = {JAVA, LANG, "Integer".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_LONG = {JAVA, LANG, "Long".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_FLOAT = {JAVA, LANG, "Float".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_DOUBLE = {JAVA, LANG, "Double".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_BOOLEAN = {JAVA, LANG, "Boolean".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_VOID = {JAVA, LANG, "Void".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_UTIL_COLLECTION = {JAVA, UTIL, "Collection".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_UTIL_ITERATOR = {JAVA, UTIL, "Iterator".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_DEPRECATED = {JAVA, LANG, "Deprecated".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ANNOTATION_DOCUMENTED = {JAVA, LANG, ANNOTATION, "Documented".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ANNOTATION_INHERITED = {JAVA, LANG, ANNOTATION, "Inherited".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_OVERRIDE = {JAVA, LANG, "Override".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ANNOTATION_RETENTION = {JAVA, LANG, ANNOTATION, "Retention".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_SUPPRESSWARNINGS = {JAVA, LANG, "SuppressWarnings".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ANNOTATION_TARGET = {JAVA, LANG, ANNOTATION, "Target".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ANNOTATION_RETENTIONPOLICY = {JAVA, LANG, ANNOTATION, "RetentionPolicy".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_ANNOTATION_ELEMENTTYPE = {JAVA, LANG, ANNOTATION, "ElementType".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_REFLECT_FIELD = new char[][] {JAVA, LANG, REFLECT, "Field".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_LANG_REFLECT_METHOD = new char[][] {JAVA, LANG, REFLECT, "Method".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_IO_OBJECTSTREAMEXCEPTION = new char[][] {JAVA, IO, "ObjectStreamException".toCharArray()};//$NON-NLS-1$
+	char[][] JAVA_IO_EXTERNALIZABLE = {JAVA, IO, "Externalizable".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_IO_IOEXCEPTION = new char[][] {JAVA, IO, "IOException".toCharArray()};//$NON-NLS-1$
+	char[][] JAVA_IO_OBJECTOUTPUTSTREAM = new char[][] {JAVA, IO, "ObjectOutputStream".toCharArray()}; //$NON-NLS-1$
+	char[][] JAVA_IO_OBJECTINPUTSTREAM = new char[][] {JAVA, IO, "ObjectInputStream".toCharArray()}; //$NON-NLS-1$
+
+	// Constraints for generic type argument inference
+	int CONSTRAINT_EQUAL = 0; // Actual = Formal
+	int CONSTRAINT_EXTENDS = 1; // Actual << Formal
+	int CONSTRAINT_SUPER = 2; // Actual >> Formal
+
+	// Constants used to perform bound checks
+	int OK = 0;
+	int UNCHECKED = 1;
+	int MISMATCH = 2;
+
+	// Synthetics
+	char[] INIT = "<init>".toCharArray(); //$NON-NLS-1$
+	char[] CLINIT = "<clinit>".toCharArray(); //$NON-NLS-1$
+	char[] SYNTHETIC_SWITCH_ENUM_TABLE = "$SWITCH_TABLE$".toCharArray(); //$NON-NLS-1$
+	char[] SYNTHETIC_ENUM_VALUES = "ENUM$VALUES".toCharArray(); //$NON-NLS-1$
+	char[] SYNTHETIC_ASSERT_DISABLED = "$assertionsDisabled".toCharArray(); //$NON-NLS-1$
+	char[] SYNTHETIC_CLASS = "class$".toCharArray(); //$NON-NLS-1$
+	char[] SYNTHETIC_OUTER_LOCAL_PREFIX = "val$".toCharArray(); //$NON-NLS-1$
+	char[] SYNTHETIC_ENCLOSING_INSTANCE_PREFIX = "this$".toCharArray(); //$NON-NLS-1$
+	char[] SYNTHETIC_ACCESS_METHOD_PREFIX = "access$".toCharArray(); //$NON-NLS-1$
+
+	// synthetic package-info name
+	public static final char[] PACKAGE_INFO_NAME = "package-info".toCharArray(); //$NON-NLS-1$
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Utility.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Utility.java
new file mode 100644
index 0000000..a0bc46d
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Utility.java
@@ -0,0 +1,681 @@
+/*******************************************************************************
+ * Copyright (c) 2009 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.internal.repository.comparator;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+public class Utility {
+	public static final int[] EMPTY_INT_ARRAY = new int[0];
+	public static final String EMPTY_STRING = ""; //$NON-NLS-1$
+	private static final int DEFAULT_READING_SIZE = 8192;
+	private static final char[] BOOLEAN = "boolean".toCharArray(); //$NON-NLS-1$
+	private static final char[] BYTE = "byte".toCharArray(); //$NON-NLS-1$
+	private static final char[] CHAR = "char".toCharArray(); //$NON-NLS-1$
+	private static final char[] DOUBLE = "double".toCharArray(); //$NON-NLS-1$
+	private static final char[] FLOAT = "float".toCharArray(); //$NON-NLS-1$
+	private static final char[] INT = "int".toCharArray(); //$NON-NLS-1$
+	private static final char[] LONG = "long".toCharArray(); //$NON-NLS-1$
+	private static final char[] SHORT = "short".toCharArray(); //$NON-NLS-1$
+	private static final char[] VOID = "void".toCharArray(); //$NON-NLS-1$
+	private static final char[] INIT = "<init>".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * Returns the contents of the given zip entry as a byte array.
+	 * @throws IOException if a problem occured reading the zip entry.
+	 */
+	public static byte[] getZipEntryByteContent(ZipEntry ze, ZipFile zip) throws IOException {
+
+		InputStream stream = null;
+		try {
+			stream = zip.getInputStream(ze);
+			if (stream == null)
+				throw new IOException("Invalid zip entry name : " + ze.getName()); //$NON-NLS-1$
+			return getInputStreamAsByteArray(stream, (int) ze.getSize());
+		} finally {
+			if (stream != null) {
+				try {
+					stream.close();
+				} catch (IOException e) {
+					// ignore
+				}
+			}
+		}
+	}
+
+	/**
+	 * Returns the given input stream's contents as a byte array.
+	 * If a length is specified (ie. if length != -1), only length bytes
+	 * are returned. Otherwise all bytes in the stream are returned.
+	 * Note this doesn't close the stream.
+	 * @throws IOException if a problem occured reading the stream.
+	 */
+	public static byte[] getInputStreamAsByteArray(InputStream stream, int length) throws IOException {
+		byte[] contents;
+		if (length == -1) {
+			contents = new byte[0];
+			int contentsLength = 0;
+			int amountRead = -1;
+			do {
+				int amountRequested = Math.max(stream.available(), DEFAULT_READING_SIZE); // read at least 8K
+
+				// resize contents if needed
+				if (contentsLength + amountRequested > contents.length) {
+					System.arraycopy(contents, 0, contents = new byte[contentsLength + amountRequested], 0, contentsLength);
+				}
+
+				// read as many bytes as possible
+				amountRead = stream.read(contents, contentsLength, amountRequested);
+
+				if (amountRead > 0) {
+					// remember length of contents
+					contentsLength += amountRead;
+				}
+			} while (amountRead != -1);
+
+			// resize contents if necessary
+			if (contentsLength < contents.length) {
+				System.arraycopy(contents, 0, contents = new byte[contentsLength], 0, contentsLength);
+			}
+		} else {
+			contents = new byte[length];
+			int len = 0;
+			int readSize = 0;
+			while ((readSize != -1) && (len != length)) {
+				// See PR 1FMS89U
+				// We record first the read size. In this case len is the actual read size.
+				len += readSize;
+				readSize = stream.read(contents, len, length - len);
+			}
+		}
+
+		return contents;
+	}
+
+	public static ClassFileAttribute getAttribute(MethodInfo methodInfo, char[] attributeName) {
+		ClassFileAttribute[] attributes = methodInfo.getAttributes();
+		for (int i = 0, max = attributes.length; i < max; i++) {
+			if (Arrays.equals(attributes[i].getAttributeName(), attributeName)) {
+				return attributes[i];
+			}
+		}
+		return null;
+	}
+
+	public static ClassFileAttribute getAttribute(FieldInfo fieldInfo, char[] attributeName) {
+		ClassFileAttribute[] attributes = fieldInfo.getAttributes();
+		for (int i = 0, max = attributes.length; i < max; i++) {
+			if (Arrays.equals(attributes[i].getAttributeName(), attributeName)) {
+				return attributes[i];
+			}
+		}
+		return null;
+	}
+
+	public static ClassFileAttribute getAttribute(ClassFileReader classFileReader, char[] attributeName) {
+		ClassFileAttribute[] attributes = classFileReader.getAttributes();
+		for (int i = 0, max = attributes.length; i < max; i++) {
+			if (Arrays.equals(attributes[i].getAttributeName(), attributeName)) {
+				return attributes[i];
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Scans the given string for a type signature starting at the given index
+	 * and returns the index of the last character.
+	 * <pre>
+	 * TypeSignature:
+	 *  |  BaseTypeSignature
+	 *  |  ArrayTypeSignature
+	 *  |  ClassTypeSignature
+	 *  |  TypeVariableSignature
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type signature
+	 */
+	public static int scanTypeSignature(char[] string, int start) {
+		// need a minimum 1 char
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		switch (c) {
+			case Signature.C_ARRAY :
+				return scanArrayTypeSignature(string, start);
+			case Signature.C_RESOLVED :
+			case Signature.C_UNRESOLVED :
+				return scanClassTypeSignature(string, start);
+			case Signature.C_TYPE_VARIABLE :
+				return scanTypeVariableSignature(string, start);
+			case Signature.C_BOOLEAN :
+			case Signature.C_BYTE :
+			case Signature.C_CHAR :
+			case Signature.C_DOUBLE :
+			case Signature.C_FLOAT :
+			case Signature.C_INT :
+			case Signature.C_LONG :
+			case Signature.C_SHORT :
+			case Signature.C_VOID :
+				return scanBaseTypeSignature(string, start);
+			case Signature.C_CAPTURE :
+				return scanCaptureTypeSignature(string, start);
+			case Signature.C_EXTENDS :
+			case Signature.C_SUPER :
+			case Signature.C_STAR :
+				return scanTypeBoundSignature(string, start);
+			default :
+				throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Scans the given string for a base type signature starting at the given index
+	 * and returns the index of the last character.
+	 * <pre>
+	 * BaseTypeSignature:
+	 *     <b>B</b> | <b>C</b> | <b>D</b> | <b>F</b> | <b>I</b>
+	 *   | <b>J</b> | <b>S</b> | <b>V</b> | <b>Z</b>
+	 * </pre>
+	 * Note that although the base type "V" is only allowed in method return types,
+	 * there is no syntactic ambiguity. This method will accept them anywhere
+	 * without complaint.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a base type signature
+	 */
+	public static int scanBaseTypeSignature(char[] string, int start) {
+		// need a minimum 1 char
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if ("BCDFIJSVZ".indexOf(c) >= 0) { //$NON-NLS-1$
+			return start;
+		}
+		throw new IllegalArgumentException();
+	}
+
+	/**
+	 * Scans the given string for an array type signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * ArrayTypeSignature:
+	 *     <b>[</b> TypeSignature
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not an array type signature
+	 */
+	public static int scanArrayTypeSignature(char[] string, int start) {
+		int length = string.length;
+		// need a minimum 2 char
+		if (start >= length - 1) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (c != Signature.C_ARRAY) {
+			throw new IllegalArgumentException();
+		}
+
+		c = string[++start];
+		while (c == Signature.C_ARRAY) {
+			// need a minimum 2 char
+			if (start >= length - 1) {
+				throw new IllegalArgumentException();
+			}
+			c = string[++start];
+		}
+		return scanTypeSignature(string, start);
+	}
+
+	/**
+	 * Scans the given string for a capture of a wildcard type signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * CaptureTypeSignature:
+	 *     <b>!</b> TypeBoundSignature
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a capture type signature
+	 */
+	public static int scanCaptureTypeSignature(char[] string, int start) {
+		// need a minimum 2 char
+		if (start >= string.length - 1) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (c != Signature.C_CAPTURE) {
+			throw new IllegalArgumentException();
+		}
+		return scanTypeBoundSignature(string, start + 1);
+	}
+
+	/**
+	 * Scans the given string for a type variable signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * TypeVariableSignature:
+	 *     <b>T</b> Identifier <b>;</b>
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type variable signature
+	 */
+	public static int scanTypeVariableSignature(char[] string, int start) {
+		// need a minimum 3 chars "Tx;"
+		if (start >= string.length - 2) {
+			throw new IllegalArgumentException();
+		}
+		// must start in "T"
+		char c = string[start];
+		if (c != Signature.C_TYPE_VARIABLE) {
+			throw new IllegalArgumentException();
+		}
+		int id = scanIdentifier(string, start + 1);
+		c = string[id + 1];
+		if (c == Signature.C_SEMICOLON) {
+			return id + 1;
+		}
+		throw new IllegalArgumentException();
+	}
+
+	/**
+	 * Scans the given string for an identifier starting at the given
+	 * index and returns the index of the last character.
+	 * Stop characters are: ";", ":", "&lt;", "&gt;", "/", ".".
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not an identifier
+	 */
+	public static int scanIdentifier(char[] string, int start) {
+		// need a minimum 1 char
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		int p = start;
+		while (true) {
+			char c = string[p];
+			if (c == '<' || c == '>' || c == ':' || c == ';' || c == '.' || c == '/') {
+				return p - 1;
+			}
+			p++;
+			if (p == string.length) {
+				return p - 1;
+			}
+		}
+	}
+
+	/**
+	 * Scans the given string for a class type signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * ClassTypeSignature:
+	 *     { <b>L</b> | <b>Q</b> } Identifier
+	 *           { { <b>/</b> | <b>.</b> Identifier [ <b>&lt;</b> TypeArgumentSignature* <b>&gt;</b> ] }
+	 *           <b>;</b>
+	 * </pre>
+	 * Note that although all "/"-identifiers most come before "."-identifiers,
+	 * there is no syntactic ambiguity. This method will accept them without
+	 * complaint.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a class type signature
+	 */
+	public static int scanClassTypeSignature(char[] string, int start) {
+		// need a minimum 3 chars "Lx;"
+		if (start >= string.length - 2) {
+			throw new IllegalArgumentException();
+		}
+		// must start in "L" or "Q"
+		char c = string[start];
+		if (c != Signature.C_RESOLVED && c != Signature.C_UNRESOLVED) {
+			return -1;
+		}
+		int p = start + 1;
+		while (true) {
+			if (p >= string.length) {
+				throw new IllegalArgumentException();
+			}
+			c = string[p];
+			if (c == Signature.C_SEMICOLON) {
+				// all done
+				return p;
+			} else if (c == Signature.C_GENERIC_START) {
+				int e = scanTypeArgumentSignatures(string, p);
+				p = e;
+			} else if (c == Signature.C_DOT || c == '/') {
+				int id = scanIdentifier(string, p + 1);
+				p = id;
+			}
+			p++;
+		}
+	}
+
+	/**
+	 * Scans the given string for a type bound signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * TypeBoundSignature:
+	 *     <b>[-+]</b> TypeSignature <b>;</b>
+	 *     <b>*</b></b>
+	 * </pre>
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type variable signature
+	 */
+	public static int scanTypeBoundSignature(char[] string, int start) {
+		// need a minimum 1 char for wildcard
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		switch (c) {
+			case Signature.C_STAR :
+				return start;
+			case Signature.C_SUPER :
+			case Signature.C_EXTENDS :
+				// need a minimum 3 chars "+[I"
+				if (start >= string.length - 2) {
+					throw new IllegalArgumentException();
+				}
+				break;
+			default :
+				// must start in "+/-"
+				throw new IllegalArgumentException();
+
+		}
+		c = string[++start];
+		switch (c) {
+			case Signature.C_CAPTURE :
+				return scanCaptureTypeSignature(string, start);
+			case Signature.C_SUPER :
+			case Signature.C_EXTENDS :
+				return scanTypeBoundSignature(string, start);
+			case Signature.C_RESOLVED :
+			case Signature.C_UNRESOLVED :
+				return scanClassTypeSignature(string, start);
+			case Signature.C_TYPE_VARIABLE :
+				return scanTypeVariableSignature(string, start);
+			case Signature.C_ARRAY :
+				return scanArrayTypeSignature(string, start);
+			case Signature.C_STAR :
+				return start;
+			default :
+				throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Scans the given string for a list of type argument signatures starting at
+	 * the given index and returns the index of the last character.
+	 * <pre>
+	 * TypeArgumentSignatures:
+	 *     <b>&lt;</b> TypeArgumentSignature* <b>&gt;</b>
+	 * </pre>
+	 * Note that although there is supposed to be at least one type argument, there
+	 * is no syntactic ambiguity if there are none. This method will accept zero
+	 * type argument signatures without complaint.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a list of type arguments
+	 * signatures
+	 */
+	public static int scanTypeArgumentSignatures(char[] string, int start) {
+		// need a minimum 2 char "<>"
+		if (start >= string.length - 1) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (c != Signature.C_GENERIC_START) {
+			throw new IllegalArgumentException();
+		}
+		int p = start + 1;
+		while (true) {
+			if (p >= string.length) {
+				throw new IllegalArgumentException();
+			}
+			c = string[p];
+			if (c == Signature.C_GENERIC_END) {
+				return p;
+			}
+			int e = scanTypeArgumentSignature(string, p);
+			p = e + 1;
+		}
+	}
+
+	/**
+	 * Scans the given string for a type argument signature starting at the given
+	 * index and returns the index of the last character.
+	 * <pre>
+	 * TypeArgumentSignature:
+	 *     <b>&#42;</b>
+	 *  |  <b>+</b> TypeSignature
+	 *  |  <b>-</b> TypeSignature
+	 *  |  TypeSignature
+	 * </pre>
+	 * Note that although base types are not allowed in type arguments, there is
+	 * no syntactic ambiguity. This method will accept them without complaint.
+	 *
+	 * @param string the signature string
+	 * @param start the 0-based character index of the first character
+	 * @return the 0-based character index of the last character
+	 * @exception IllegalArgumentException if this is not a type argument signature
+	 */
+	public static int scanTypeArgumentSignature(char[] string, int start) {
+		// need a minimum 1 char
+		if (start >= string.length) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		switch (c) {
+			case Signature.C_STAR :
+				return start;
+			case Signature.C_EXTENDS :
+			case Signature.C_SUPER :
+				return scanTypeBoundSignature(string, start);
+			default :
+				return scanTypeSignature(string, start);
+		}
+	}
+
+	static void appendTypeSignature(char[] string, int start, StringBuffer buffer, boolean compact) {
+		char c = string[start];
+		switch (c) {
+			case Signature.C_ARRAY :
+				appendArrayTypeSignature(string, start, buffer, compact);
+				break;
+			case Signature.C_RESOLVED :
+				appendClassTypeSignature(string, start, buffer, compact);
+				break;
+			case Signature.C_TYPE_VARIABLE :
+				int e = scanTypeVariableSignature(string, start);
+				buffer.append(string, start + 1, e - start - 1);
+				break;
+			case Signature.C_BOOLEAN :
+				buffer.append(BOOLEAN);
+				break;
+			case Signature.C_BYTE :
+				buffer.append(BYTE);
+				break;
+			case Signature.C_CHAR :
+				buffer.append(CHAR);
+				break;
+			case Signature.C_DOUBLE :
+				buffer.append(DOUBLE);
+				break;
+			case Signature.C_FLOAT :
+				buffer.append(FLOAT);
+				break;
+			case Signature.C_INT :
+				buffer.append(INT);
+				break;
+			case Signature.C_LONG :
+				buffer.append(LONG);
+				break;
+			case Signature.C_SHORT :
+				buffer.append(SHORT);
+				break;
+			case Signature.C_VOID :
+				buffer.append(VOID);
+				break;
+		}
+	}
+
+	private static void appendArrayTypeSignature(char[] string, int start, StringBuffer buffer, boolean compact) {
+		int length = string.length;
+		// need a minimum 2 char
+		if (start >= length - 1) {
+			throw new IllegalArgumentException();
+		}
+		char c = string[start];
+		if (c != Signature.C_ARRAY) {
+			throw new IllegalArgumentException();
+		}
+
+		int index = start;
+		c = string[++index];
+		while (c == Signature.C_ARRAY) {
+			// need a minimum 2 char
+			if (index >= length - 1) {
+				throw new IllegalArgumentException();
+			}
+			c = string[++index];
+		}
+
+		appendTypeSignature(string, index, buffer, compact);
+
+		for (int i = 0, dims = index - start; i < dims; i++) {
+			buffer.append('[').append(']');
+		}
+	}
+
+	private static void appendClassTypeSignature(char[] string, int start, StringBuffer buffer, boolean compact) {
+		char c = string[start];
+		if (c != Signature.C_RESOLVED) {
+			return;
+		}
+		int p = start + 1;
+		int checkpoint = buffer.length();
+		while (true) {
+			c = string[p];
+			switch (c) {
+				case Signature.C_SEMICOLON :
+					// all done
+					return;
+				case Signature.C_DOT :
+				case '/' :
+					// erase package prefix
+					if (compact) {
+						buffer.setLength(checkpoint);
+					} else {
+						buffer.append('.');
+					}
+					break;
+				case Signature.C_DOLLAR :
+					/**
+					 * Convert '$' in resolved type signatures into '.'.
+					 * NOTE: This assumes that the type signature is an inner type
+					 * signature. This is true in most cases, but someone can define a
+					 * non-inner type name containing a '$'.
+					 */
+					buffer.append('.');
+					break;
+				default :
+					buffer.append(c);
+			}
+			p++;
+		}
+	}
+
+	public static String toString(char[] declaringClass, char[] methodName, char[] methodSignature, boolean includeReturnType, boolean compact) {
+		final boolean isConstructor = Arrays.equals(methodName, INIT);
+		int firstParen = CharOperation.indexOf(Signature.C_PARAM_START, methodSignature);
+		if (firstParen == -1) {
+			return ""; //$NON-NLS-1$
+		}
+
+		StringBuffer buffer = new StringBuffer(methodSignature.length + 10);
+
+		// decode declaring class name
+		// it can be either an array signature or a type signature
+		if (declaringClass.length > 0) {
+			char[] declaringClassSignature = null;
+			if (declaringClass[0] == Signature.C_ARRAY) {
+				CharOperation.replace(declaringClass, '/', '.');
+				declaringClassSignature = Signature.toCharArray(declaringClass);
+			} else {
+				CharOperation.replace(declaringClass, '/', '.');
+				declaringClassSignature = declaringClass;
+			}
+			int lastIndexOfSlash = CharOperation.lastIndexOf('.', declaringClassSignature);
+			if (compact && lastIndexOfSlash != -1) {
+				buffer.append(declaringClassSignature, lastIndexOfSlash + 1, declaringClassSignature.length - lastIndexOfSlash - 1);
+			} else {
+				buffer.append(declaringClassSignature);
+			}
+		}
+
+		// selector
+		if (!isConstructor) {
+			buffer.append('.');
+			if (methodName != null) {
+				buffer.append(methodName);
+			}
+		}
+
+		// parameters
+		buffer.append('(');
+		char[][] pts = Signature.getParameterTypes(methodSignature);
+		for (int i = 0, max = pts.length; i < max; i++) {
+			appendTypeSignature(pts[i], 0, buffer, compact);
+			if (i != pts.length - 1) {
+				buffer.append(',');
+				buffer.append(' ');
+			}
+		}
+		buffer.append(')');
+
+		if (!isConstructor) {
+			buffer.append(" : "); //$NON-NLS-1$
+			// return type
+			if (includeReturnType) {
+				char[] rts = Signature.getReturnType(methodSignature);
+				appendTypeSignature(rts, 0, buffer, compact);
+			}
+		}
+		return String.valueOf(buffer);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/messages.properties b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/messages.properties
new file mode 100644
index 0000000..25c9f6c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/messages.properties
@@ -0,0 +1,105 @@
+###############################################################################
+# Copyright (c) 2009 IBM Corporation and others.
+# All rights reserved. This program and the accompanying materials
+# are made available under the terms of the Eclipse Public License v1.0
+# which accompanies this distribution, and is available at
+# http://www.eclipse.org/legal/epl-v10.html
+#
+# Contributors:
+#     IBM Corporation - initial API and implementation
+###############################################################################
+differentNumberOfEntries=Difference: {0} contains {1} files and {2} contains {3} files
+differentEntry=Difference found for {0} within {1}
+missingEntry=Missing {0} withim {1}
+ioexception=IOException comparing {0} and {1} 
+ioexceptioninentry=IOException checking {0} within {1}
+filenotfoundexception=FileNotFoundException checking {0} within {1}
+
+### Disassembler messages
+
+### disassembler
+disassembler_description = Default classfile disassembler
+disassembler_opentypedeclaration =\ '{'
+disassembler_closetypedeclaration = }
+disassembler_parametername = arg
+disassembler_localvariablename = local_{0}
+disassembler_endofmethodheader = ;
+disassembler_begincommentline = //\ 
+disassembler_fieldhasconstant =\ =\ 
+disassembler_endoffieldheader = ;
+disassembler_sourceattributeheader = Compiled from\ 
+disassembler_enclosingmethodheader = Enclosing Method:
+disassembler_exceptiontableheader = Exception Table:
+disassembler_arraydimensions = []
+disassembler_innerattributesheader = Inner classes:
+disassembler_inner_class_info_name = inner class info:
+disassembler_outer_class_info_name = outer class info:
+disassembler_inner_name = inner name:
+disassembler_inner_accessflags = accessflags:\ 
+disassembler_signatureattributeheader = // Signature: {0}
+disassembler_indentation = \  
+disassembler_constantpoolindex =\ #
+disassembler_space = \ 
+disassembler_comma = ,
+disassembler_openinnerclassentry = [
+disassembler_closeinnerclassentry = ]
+disassembler_deprecated =\ (deprecated)
+disassembler_annotationdefaultheader = Annotation Default:\ 
+disassembler_annotationdefaultvalue= {0} (constant type)
+disassembler_annotationenumvalue = {0}.{1}(enum type)
+disassembler_annotationclassvalue = {0} (class type)
+disassembler_annotationannotationvalue = annotation value =
+disassembler_annotationarrayvaluestart = [
+disassembler_annotationarrayvalueend = ]
+disassembler_annotationentrystart = @{0}(
+disassembler_annotationentryend = )
+disassembler_annotationcomponent = {0}=
+disassembler_runtimevisibleannotationsattributeheader= RuntimeVisibleAnnotations:\ 
+disassembler_runtimeinvisibleannotationsattributeheader= RuntimeInvisibleAnnotations:\ 
+disassembler_runtimevisibleparameterannotationsattributeheader= RuntimeVisibleParameterAnnotations:\ 
+disassembler_runtimeinvisibleparameterannotationsattributeheader= RuntimeInvisibleParameterAnnotations:\ 
+disassembler_parameterannotationentrystart=Number of annotations for parameter {0}: {1}
+### classfileformat decoding
+classfileformat_versiondetails =\ (version {0} : {1}.{2}, {3})
+classfileformat_methoddescriptor = // Method descriptor {0}
+classfileformat_fieldddescriptor = // Field descriptor {0}
+classfileformat_stacksAndLocals= // Stack: {0}, Locals: {1}
+classfileformat_superflagisnotset = no super bit
+classfileformat_superflagisset = super bit
+classfileformat_clinitname = '{'}
+classformat_classformatexception = Class Format Exception
+classfileformat_versionUnknown = unknown
+
+### string displayed for each opcode
+classformat_anewarray = {0} {1}
+classformat_checkcast = {0} {1}
+classformat_instanceof = {0} {1}
+classformat_ldc_w_class = {0} <Class {1}>
+classformat_ldc_w_float = {0} <Float {1}>
+classformat_ldc_w_integer = {0} <Integer {1}>
+classformat_ldc_w_string = {0} <String "{1}">
+classformat_ldc2_w_long = {0} <Long {1}>
+classformat_ldc2_w_double = {0} <Double {1}>
+classformat_multianewarray = {0} {1}
+classformat_new = {0} {1}
+classformat_iinc = {0} {1} {2}{3}
+classformat_invokespecial ={0} {1}
+classformat_invokeinterface ={0} {2} [nargs: {1}]
+classformat_invokestatic ={0} {1}
+classformat_invokevirtual ={0} {1}
+classformat_getfield ={0} {1}.{2} : {3}
+classformat_getstatic ={0} {1}.{2} : {3}
+classformat_putstatic ={0} {1}.{2} : {3}
+classformat_putfield ={0} {1}.{2} : {3}
+classformat_newarray_boolean = {0} boolean
+classformat_newarray_char = {0} char
+classformat_newarray_float = {0} float
+classformat_newarray_double = {0} double
+classformat_newarray_byte = {0} byte
+classformat_newarray_short = {0} short
+classformat_newarray_int = {0} int
+classformat_newarray_long = {0} long
+classformat_store = {0}{1}
+classformat_load = {0}{1}
+classfileformat_anyexceptionhandler=any
+classfileformat_exceptiontableentry = [pc: {0}, pc: {1}] -> {2} when : {3}
commit 0a52aa6cbb2d88d8d557b98a73fe7b8b9eda205d
Author: Andrew Niefer <aniefer>
Date:   Thu Feb 26 22:27:19 2009 +0000

    bug 263272 - javadoc and fix false positive from method reordering

20	20	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AttributeNamesConstants.java
2	2	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileAttribute.java
30	30	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileReader.java
9	9	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CodeAttribute.java
3	3	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPool.java
42	42	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolEntry.java
2	2	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantValueAttribute.java
206	206	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/DefaultBytecodeVisitor.java
27	16	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Disassembler.java
3	3	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionAttribute.java
5	5	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionTableEntry.java
12	12	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/FieldInfo.java
2	2	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttribute.java
7	7	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttributeEntry.java
14	14	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/MethodInfo.java
60	60	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Signature.java
2	2	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SourceFileAttribute.java
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AttributeNamesConstants.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AttributeNamesConstants.java
index af9859f..3f55bfc 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AttributeNamesConstants.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/AttributeNamesConstants.java
@@ -11,7 +11,7 @@
 package org.eclipse.equinox.p2.internal.repository.comparator;
 
 public interface AttributeNamesConstants {
-	/**
+	/*
 	 * "Synthetic" attribute.
 	 * <p>Note that prior to JDK 1.5, synthetic elements were always marked
 	 * using an attribute; with 1.5, synthetic elements can also be marked
@@ -21,55 +21,55 @@ public interface AttributeNamesConstants {
 	 */
 	char[] SYNTHETIC = "Synthetic".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "ConstantValue" attribute.
 	 * @since 2.0
 	 */
 	char[] CONSTANT_VALUE = "ConstantValue".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "LineNumberTable" attribute.
 	 * @since 2.0
 	 */
 	char[] LINE_NUMBER = "LineNumberTable".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "LocalVariableTable" attribute.
 	 * @since 2.0
 	 */
 	char[] LOCAL_VARIABLE = "LocalVariableTable".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "InnerClasses" attribute.
 	 * @since 2.0
 	 */
 	char[] INNER_CLASSES = "InnerClasses".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "Code" attribute.
 	 * @since 2.0
 	 */
 	char[] CODE = "Code".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "Exceptions" attribute.
 	 * @since 2.0
 	 */
 	char[] EXCEPTIONS = "Exceptions".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "SourceFile" attribute.
 	 * @since 2.0
 	 */
 	char[] SOURCE = "SourceFile".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "Deprecated" attribute.
 	 * @since 2.0
 	 */
 	char[] DEPRECATED = "Deprecated".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "Signature" attribute (added in J2SE 1.5).
 	 * Class file readers which support J2SE 1.5 return
 	 * attributes with this name represented by objects
@@ -78,7 +78,7 @@ public interface AttributeNamesConstants {
 	 */
 	char[] SIGNATURE = "Signature".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "EnclosingMethod" attribute (added in J2SE 1.5).
 	 * Class file readers which support J2SE 1.5 return
 	 * attributes with this name represented by objects
@@ -87,55 +87,55 @@ public interface AttributeNamesConstants {
 	 */
 	char[] ENCLOSING_METHOD = "EnclosingMethod".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "LocalVariableTypeTable" attribute (added in J2SE 1.5).
 	 * @since 3.0
 	 */
 	char[] LOCAL_VARIABLE_TYPE_TABLE = "LocalVariableTypeTable".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "RuntimeVisibleAnnotations" attribute (added in J2SE 1.5).
 	 * @since 3.0
 	 */
 	char[] RUNTIME_VISIBLE_ANNOTATIONS = "RuntimeVisibleAnnotations".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "RuntimeInvisibleAnnotations" attribute (added in J2SE 1.5).
 	 * @since 3.0
 	 */
 	char[] RUNTIME_INVISIBLE_ANNOTATIONS = "RuntimeInvisibleAnnotations".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "RuntimeVisibleParameterAnnotations" attribute (added in J2SE 1.5).
 	 * @since 3.0
 	 */
 	char[] RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = "RuntimeVisibleParameterAnnotations".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "RuntimeInvisibleParameterAnnotations" attribute (added in J2SE 1.5).
 	 * @since 3.0
 	 */
 	char[] RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = "RuntimeInvisibleParameterAnnotations".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "AnnotationDefault" attribute (added in J2SE 1.5).
 	 * @since 3.0
 	 */
 	char[] ANNOTATION_DEFAULT = "AnnotationDefault".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "StackMapTable" attribute (added in J2SE 1.6).
 	 * @since 3.2
 	 */
 	char[] STACK_MAP_TABLE = "StackMapTable".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "StackMap" attribute (added in cldc1.0).
 	 * @since 3.2
 	 */
 	char[] STACK_MAP = "StackMap".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * "Varargs" attribute (unspecified).
 	 */
 	char[] VAR_ARGS = "Varargs".toCharArray(); //$NON-NLS-1$
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileAttribute.java
index 0c2ad09..0522580 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileAttribute.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileAttribute.java
@@ -30,14 +30,14 @@ public class ClassFileAttribute extends ClassFileStruct {
 		return this.attributeNameIndex;
 	}
 
-	/**
+	/*
 	 * @see IClassFileAttribute#getAttributeName()
 	 */
 	public char[] getAttributeName() {
 		return this.attributeName;
 	}
 
-	/**
+	/*
 	 * @see IClassFileAttribute#getAttributeLength()
 	 */
 	public long getAttributeLength() {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileReader.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileReader.java
index 497b552..61765ef 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileReader.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ClassFileReader.java
@@ -13,47 +13,47 @@ package org.eclipse.equinox.p2.internal.repository.comparator;
 import java.util.Arrays;
 
 public class ClassFileReader extends ClassFileStruct {
-	/**
+	/*
 	 * This value should be used to read completely each part of a .class file.
 	 */
 	public static final int ALL = 0xFFFF;
 
-	/**
+	/*
 	 * This value should be used to read only the constant pool entries of a .class file.
 	 */
 	public static final int CONSTANT_POOL = 0x0001;
 
-	/**
+	/*
 	 * This value should be used to read the constant pool entries and
 	 * the method infos of a .class file.
 	 */
 	public static final int METHOD_INFOS = 0x0002 + CONSTANT_POOL;
 
-	/**
+	/*
 	 * This value should be used to read the constant pool entries and
 	 * the field infos of a .class file.
 	 */
 	public static final int FIELD_INFOS = 0x0004 + CONSTANT_POOL;
 
-	/**
+	/*
 	 * This value should be used to read the constant pool entries and
 	 * the super interface names of a .class file.
 	 */
 	public static final int SUPER_INTERFACES = 0x0008 + CONSTANT_POOL;
 
-	/**
+	/*
 	 * This value should be used to read the constant pool entries and
 	 * the attributes of a .class file.
 	 */
 	public static final int CLASSFILE_ATTRIBUTES = 0x0010 + CONSTANT_POOL;
 
-	/**
+	/*
 	 * This value should be used to read the method bodies.
 	 * It has to be used with METHOD_INFOS.
 	 */
 	public static final int METHOD_BODIES = 0x0020;
 
-	/**
+	/*
 	 * This value should be used to read the whole contents of the .class file except the
 	 * method bodies.
 	 */
@@ -84,7 +84,7 @@ public class ClassFileReader extends ClassFileStruct {
 	private char[] superclassName;
 	private int superclassNameIndex;
 
-	/**
+	/*
 	 * Constructor for ClassFileReader.
 	 *
 	 * @param classFileBytes the raw bytes of the .class file
@@ -314,35 +314,35 @@ public class ClassFileReader extends ClassFileStruct {
 		}
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getAccessFlags()
 	 */
 	public int getAccessFlags() {
 		return this.accessFlags;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getAttributeCount()
 	 */
 	public int getAttributeCount() {
 		return this.attributesCount;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getAttributes()
 	 */
 	public ClassFileAttribute[] getAttributes() {
 		return this.attributes;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getClassIndex()
 	 */
 	public int getClassIndex() {
 		return this.classNameIndex;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getClassName()
 	 */
 	public char[] getClassName() {
@@ -354,112 +354,112 @@ public class ClassFileReader extends ClassFileStruct {
 		return utf8At(classFileBytes, utf8Offset + 3, 0, u2At(classFileBytes, utf8Offset + 1, 0));
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getConstantPool()
 	 */
 	public ConstantPool getConstantPool() {
 		return this.constantPool;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getFieldInfos()
 	 */
 	public FieldInfo[] getFieldInfos() {
 		return this.fields;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getFieldsCount()
 	 */
 	public int getFieldsCount() {
 		return this.fieldsCount;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getInnerClassesAttribute()
 	 */
 	public InnerClassesAttribute getInnerClassesAttribute() {
 		return this.innerClassesAttribute;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getInterfaceIndexes()
 	 */
 	public int[] getInterfaceIndexes() {
 		return this.interfaceIndexes;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getInterfaceNames()
 	 */
 	public char[][] getInterfaceNames() {
 		return this.interfaceNames;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getMagic()
 	 */
 	public int getMagic() {
 		return this.magicNumber;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getMajorVersion()
 	 */
 	public int getMajorVersion() {
 		return this.majorVersion;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getMethodInfos()
 	 */
 	public MethodInfo[] getMethodInfos() {
 		return this.methods;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getMethodsCount()
 	 */
 	public int getMethodsCount() {
 		return this.methodsCount;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getMinorVersion()
 	 */
 	public int getMinorVersion() {
 		return this.minorVersion;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getSourceFileAttribute()
 	 */
 	public SourceFileAttribute getSourceFileAttribute() {
 		return this.sourceFileAttribute;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getSuperclassIndex()
 	 */
 	public int getSuperclassIndex() {
 		return this.superclassNameIndex;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#getSuperclassName()
 	 */
 	public char[] getSuperclassName() {
 		return this.superclassName;
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#isClass()
 	 */
 	public boolean isClass() {
 		return !isInterface();
 	}
 
-	/**
+	/*
 	 * @see IClassFileReader#isInterface()
 	 */
 	public boolean isInterface() {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CodeAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CodeAttribute.java
index 74101cb..9788468 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CodeAttribute.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/CodeAttribute.java
@@ -58,21 +58,21 @@ public class CodeAttribute extends ClassFileAttribute {
 		}
 	}
 
-	/**
+	/*
 	 * @see ICodeAttribute#getAttributes()
 	 */
 	public ClassFileAttribute[] getAttributes() {
 		return this.attributes;
 	}
 
-	/**
+	/*
 	 * @see ICodeAttribute#getAttributesCount()
 	 */
 	public int getAttributesCount() {
 		return this.attributesCount;
 	}
 
-	/**
+	/*
 	 * @see ICodeAttribute#getBytecodes()
 	 */
 	public byte[] getBytecodes() {
@@ -82,42 +82,42 @@ public class CodeAttribute extends ClassFileAttribute {
 		return this.bytecodes;
 	}
 
-	/**
+	/*
 	 * @see ICodeAttribute#getCodeLength()
 	 */
 	public long getCodeLength() {
 		return this.codeLength;
 	}
 
-	/**
+	/*
 	 * @see ICodeAttribute#getExceptionTable()
 	 */
 	public ExceptionTableEntry[] getExceptionTable() {
 		return this.exceptionTableEntries;
 	}
 
-	/**
+	/*
 	 * @see ICodeAttribute#getExceptionTableLength()
 	 */
 	public int getExceptionTableLength() {
 		return this.exceptionTableLength;
 	}
 
-	/**
+	/*
 	 * @see ICodeAttribute#getMaxLocals()
 	 */
 	public int getMaxLocals() {
 		return this.maxLocals;
 	}
 
-	/**
+	/*
 	 * @see ICodeAttribute#getMaxStack()
 	 */
 	public int getMaxStack() {
 		return this.maxStack;
 	}
 
-	/**
+	/*
 	 * @see ICodeAttribute#traverse(IBytecodeVisitor visitor)
 	 */
 	public void traverse(DefaultBytecodeVisitor visitor) throws ClassFormatException {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPool.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPool.java
index caeaf25..3801086 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPool.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPool.java
@@ -22,7 +22,7 @@ public class ConstantPool extends ClassFileStruct {
 		this.classFileBytes = reference;
 	}
 
-	/**
+	/*
 	 * @see IConstantPool#decodeEntry(int)
 	 */
 	public ConstantPoolEntry decodeEntry(int index) {
@@ -83,14 +83,14 @@ public class ConstantPool extends ClassFileStruct {
 		return constantPoolEntry;
 	}
 
-	/**
+	/*
 	 * @see IConstantPool#getConstantPoolCount()
 	 */
 	public int getConstantPoolCount() {
 		return this.constantPoolCount;
 	}
 
-	/**
+	/*
 	 * @see IConstantPool#getEntryKind(int)
 	 */
 	public int getEntryKind(int index) {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolEntry.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolEntry.java
index 4d4d8d4..cdee2fd 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolEntry.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantPoolEntry.java
@@ -55,14 +55,14 @@ public class ConstantPoolEntry {
 		this.classInfoName = null;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getKind()
 	 */
 	public int getKind() {
 		return this.kind;
 	}
 
-	/**
+	/*
 	 * Sets the kind.
 	 * @param kind The kind to set
 	 */
@@ -70,133 +70,133 @@ public class ConstantPoolEntry {
 		this.kind = kind;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getClassInfoNameIndex()
 	 */
 	public int getClassInfoNameIndex() {
 		return this.classInfoNameIndex;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getClassIndex()
 	 */
 	public int getClassIndex() {
 		return this.classIndex;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getNameAndTypeIndex()
 	 */
 	public int getNameAndTypeIndex() {
 		return this.nameAndTypeIndex;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getStringIndex()
 	 */
 	public int getStringIndex() {
 		return this.stringIndex;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getStringValue()
 	 */
 	public String getStringValue() {
 		return new String(this.stringValue);
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getIntegerValue()
 	 */
 	public int getIntegerValue() {
 		return this.integerValue;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getFloatValue()
 	 */
 	public float getFloatValue() {
 		return this.floatValue;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getDoubleValue()
 	 */
 	public double getDoubleValue() {
 		return this.doubleValue;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getLongValue()
 	 */
 	public long getLongValue() {
 		return this.longValue;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getNameAndTypeInfoDescriptorIndex()
 	 */
 	public int getNameAndTypeInfoDescriptorIndex() {
 		return this.nameAndTypeDescriptorIndex;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getNameAndTypeInfoNameIndex()
 	 */
 	public int getNameAndTypeInfoNameIndex() {
 		return this.nameAndTypeNameIndex;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getClassName()
 	 */
 	public char[] getClassName() {
 		return this.className;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getFieldName()
 	 */
 	public char[] getFieldName() {
 		return this.fieldName;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getMethodName()
 	 */
 	public char[] getMethodName() {
 		return this.methodName;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getFieldDescriptor()
 	 */
 	public char[] getFieldDescriptor() {
 		return this.fieldDescriptor;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getMethodDescriptor()
 	 */
 	public char[] getMethodDescriptor() {
 		return this.methodDescriptor;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getUtf8Value()
 	 */
 	public char[] getUtf8Value() {
 		return this.utf8Value;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getClassInfoName()
 	 */
 	public char[] getClassInfoName() {
 		return this.classInfoName;
 	}
 
-	/**
+	/*
 	 * Sets the classInfoNameIndex.
 	 * @param classInfoNameIndex The classInfoNameIndex to set
 	 */
@@ -204,7 +204,7 @@ public class ConstantPoolEntry {
 		this.classInfoNameIndex = classInfoNameIndex;
 	}
 
-	/**
+	/*
 	 * Sets the classIndex.
 	 * @param classIndex The classIndex to set
 	 */
@@ -212,7 +212,7 @@ public class ConstantPoolEntry {
 		this.classIndex = classIndex;
 	}
 
-	/**
+	/*
 	 * Sets the nameAndTypeIndex.
 	 * @param nameAndTypeIndex The nameAndTypeIndex to set
 	 */
@@ -220,7 +220,7 @@ public class ConstantPoolEntry {
 		this.nameAndTypeIndex = nameAndTypeIndex;
 	}
 
-	/**
+	/*
 	 * Sets the stringIndex.
 	 * @param stringIndex The stringIndex to set
 	 */
@@ -228,7 +228,7 @@ public class ConstantPoolEntry {
 		this.stringIndex = stringIndex;
 	}
 
-	/**
+	/*
 	 * Sets the stringValue.
 	 * @param stringValue The stringValue to set
 	 */
@@ -236,7 +236,7 @@ public class ConstantPoolEntry {
 		this.stringValue = stringValue;
 	}
 
-	/**
+	/*
 	 * Sets the integerValue.
 	 * @param integerValue The integerValue to set
 	 */
@@ -244,7 +244,7 @@ public class ConstantPoolEntry {
 		this.integerValue = integerValue;
 	}
 
-	/**
+	/*
 	 * Sets the floatValue.
 	 * @param floatValue The floatValue to set
 	 */
@@ -252,7 +252,7 @@ public class ConstantPoolEntry {
 		this.floatValue = floatValue;
 	}
 
-	/**
+	/*
 	 * Sets the doubleValue.
 	 * @param doubleValue The doubleValue to set
 	 */
@@ -260,7 +260,7 @@ public class ConstantPoolEntry {
 		this.doubleValue = doubleValue;
 	}
 
-	/**
+	/*
 	 * Sets the longValue.
 	 * @param longValue The longValue to set
 	 */
@@ -268,7 +268,7 @@ public class ConstantPoolEntry {
 		this.longValue = longValue;
 	}
 
-	/**
+	/*
 	 * Gets the nameAndTypeDescriptorIndex.
 	 * @return Returns a int
 	 */
@@ -276,7 +276,7 @@ public class ConstantPoolEntry {
 		return this.nameAndTypeDescriptorIndex;
 	}
 
-	/**
+	/*
 	 * Sets the nameAndTypeDescriptorIndex.
 	 * @param nameAndTypeDescriptorIndex The nameAndTypeDescriptorIndex to set
 	 */
@@ -284,7 +284,7 @@ public class ConstantPoolEntry {
 		this.nameAndTypeDescriptorIndex = nameAndTypeDescriptorIndex;
 	}
 
-	/**
+	/*
 	 * Gets the nameAndTypeNameIndex.
 	 * @return Returns a int
 	 */
@@ -292,7 +292,7 @@ public class ConstantPoolEntry {
 		return this.nameAndTypeNameIndex;
 	}
 
-	/**
+	/*
 	 * Sets the nameAndTypeNameIndex.
 	 * @param nameAndTypeNameIndex The nameAndTypeNameIndex to set
 	 */
@@ -300,7 +300,7 @@ public class ConstantPoolEntry {
 		this.nameAndTypeNameIndex = nameAndTypeNameIndex;
 	}
 
-	/**
+	/*
 	 * Sets the className.
 	 * @param className The className to set
 	 */
@@ -308,7 +308,7 @@ public class ConstantPoolEntry {
 		this.className = className;
 	}
 
-	/**
+	/*
 	 * Sets the fieldName.
 	 * @param fieldName The fieldName to set
 	 */
@@ -316,7 +316,7 @@ public class ConstantPoolEntry {
 		this.fieldName = fieldName;
 	}
 
-	/**
+	/*
 	 * Sets the methodName.
 	 * @param methodName The methodName to set
 	 */
@@ -324,7 +324,7 @@ public class ConstantPoolEntry {
 		this.methodName = methodName;
 	}
 
-	/**
+	/*
 	 * Sets the fieldDescriptor.
 	 * @param fieldDescriptor The fieldDescriptor to set
 	 */
@@ -332,7 +332,7 @@ public class ConstantPoolEntry {
 		this.fieldDescriptor = fieldDescriptor;
 	}
 
-	/**
+	/*
 	 * Sets the methodDescriptor.
 	 * @param methodDescriptor The methodDescriptor to set
 	 */
@@ -340,7 +340,7 @@ public class ConstantPoolEntry {
 		this.methodDescriptor = methodDescriptor;
 	}
 
-	/**
+	/*
 	 * Sets the utf8Value.
 	 * @param utf8Value The utf8Value to set
 	 */
@@ -348,7 +348,7 @@ public class ConstantPoolEntry {
 		this.utf8Value = utf8Value;
 	}
 
-	/**
+	/*
 	 * Sets the classInfoName.
 	 * @param classInfoName The classInfoName to set
 	 */
@@ -356,14 +356,14 @@ public class ConstantPoolEntry {
 		this.classInfoName = classInfoName;
 	}
 
-	/**
+	/*
 	 * @see IConstantPoolEntry#getUtf8Length()
 	 */
 	public int getUtf8Length() {
 		return this.utf8Length;
 	}
 
-	/**
+	/*
 	 * Sets the utf8Length.
 	 * @param utf8Length The utf8Length to set
 	 */
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantValueAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantValueAttribute.java
index bab9881..75e961e 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantValueAttribute.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ConstantValueAttribute.java
@@ -21,14 +21,14 @@ public class ConstantValueAttribute extends ClassFileAttribute {
 		this.constantPoolEntry = constantPool.decodeEntry(this.constantValueIndex);
 	}
 
-	/**
+	/*
 	 * @see IConstantValueAttribute#getConstantValue()
 	 */
 	public ConstantPoolEntry getConstantValue() {
 		return this.constantPoolEntry;
 	}
 
-	/**
+	/*
 	 * @see IConstantValueAttribute#getConstantValueIndex()
 	 */
 	public int getConstantValueIndex() {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/DefaultBytecodeVisitor.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/DefaultBytecodeVisitor.java
index c27c538..aaeaf26 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/DefaultBytecodeVisitor.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/DefaultBytecodeVisitor.java
@@ -1,4 +1,4 @@
-/*******************************************************************************
+/******************************************************************************
  * Copyright (c) 2009 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
@@ -39,7 +39,7 @@ public class DefaultBytecodeVisitor {
 		this.mode = mode;
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_aaload(int)
 	 */
 	public void _aaload(int pc) {
@@ -61,7 +61,7 @@ public class DefaultBytecodeVisitor {
 		this.buffer.append(Messages.disassembler_indentation);
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_aastore(int)
 	 */
 	public void _aastore(int pc) {
@@ -70,7 +70,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_aconst_null(int)
 	 */
 	public void _aconst_null(int pc) {
@@ -79,7 +79,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_aload_0(int)
 	 */
 	public void _aload_0(int pc) {
@@ -88,7 +88,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_aload_1(int)
 	 */
 	public void _aload_1(int pc) {
@@ -97,7 +97,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_aload_2(int)
 	 */
 	public void _aload_2(int pc) {
@@ -106,7 +106,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_aload_3(int)
 	 */
 	public void _aload_3(int pc) {
@@ -115,7 +115,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_aload(int, int)
 	 */
 	public void _aload(int pc, int index) {
@@ -124,7 +124,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_anewarray(int, int, ConstantPoolEntry)
 	 */
 	public void _anewarray(int pc, int index, ConstantPoolEntry constantClass) {
@@ -133,7 +133,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_areturn(int)
 	 */
 	public void _areturn(int pc) {
@@ -142,7 +142,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_arraylength(int)
 	 */
 	public void _arraylength(int pc) {
@@ -151,7 +151,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_astore_0(int)
 	 */
 	public void _astore_0(int pc) {
@@ -160,7 +160,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_astore_1(int)
 	 */
 	public void _astore_1(int pc) {
@@ -169,7 +169,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_astore_2(int)
 	 */
 	public void _astore_2(int pc) {
@@ -178,7 +178,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_astore_3(int)
 	 */
 	public void _astore_3(int pc) {
@@ -187,7 +187,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_astore(int, int)
 	 */
 	public void _astore(int pc, int index) {
@@ -196,7 +196,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_athrow(int)
 	 */
 	public void _athrow(int pc) {
@@ -205,7 +205,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_baload(int)
 	 */
 	public void _baload(int pc) {
@@ -214,7 +214,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_bastore(int)
 	 */
 	public void _bastore(int pc) {
@@ -223,7 +223,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_bipush(int, byte)
 	 */
 	public void _bipush(int pc, byte _byte) {
@@ -232,7 +232,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_caload(int)
 	 */
 	public void _caload(int pc) {
@@ -241,7 +241,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_castore(int)
 	 */
 	public void _castore(int pc) {
@@ -250,7 +250,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_checkcast(int, int, ConstantPoolEntry)
 	 */
 	public void _checkcast(int pc, int index, ConstantPoolEntry constantClass) {
@@ -259,7 +259,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_d2f(int)
 	 */
 	public void _d2f(int pc) {
@@ -268,7 +268,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_d2i(int)
 	 */
 	public void _d2i(int pc) {
@@ -277,7 +277,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_d2l(int)
 	 */
 	public void _d2l(int pc) {
@@ -286,7 +286,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dadd(int)
 	 */
 	public void _dadd(int pc) {
@@ -295,7 +295,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_daload(int)
 	 */
 	public void _daload(int pc) {
@@ -304,7 +304,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dastore(int)
 	 */
 	public void _dastore(int pc) {
@@ -313,7 +313,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dcmpg(int)
 	 */
 	public void _dcmpg(int pc) {
@@ -322,7 +322,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dcmpl(int)
 	 */
 	public void _dcmpl(int pc) {
@@ -331,7 +331,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dconst_0(int)
 	 */
 	public void _dconst_0(int pc) {
@@ -340,7 +340,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dconst_1(int)
 	 */
 	public void _dconst_1(int pc) {
@@ -349,7 +349,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ddiv(int)
 	 */
 	public void _ddiv(int pc) {
@@ -358,7 +358,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dload_0(int)
 	 */
 	public void _dload_0(int pc) {
@@ -367,7 +367,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dload_1(int)
 	 */
 	public void _dload_1(int pc) {
@@ -376,7 +376,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dload_2(int)
 	 */
 	public void _dload_2(int pc) {
@@ -385,7 +385,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dload_3(int)
 	 */
 	public void _dload_3(int pc) {
@@ -394,7 +394,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dload(int, int)
 	 */
 	public void _dload(int pc, int index) {
@@ -403,7 +403,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dmul(int)
 	 */
 	public void _dmul(int pc) {
@@ -412,7 +412,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dneg(int)
 	 */
 	public void _dneg(int pc) {
@@ -421,7 +421,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_drem(int)
 	 */
 	public void _drem(int pc) {
@@ -430,7 +430,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dreturn(int)
 	 */
 	public void _dreturn(int pc) {
@@ -439,7 +439,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dstore_0(int)
 	 */
 	public void _dstore_0(int pc) {
@@ -448,7 +448,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dstore_1(int)
 	 */
 	public void _dstore_1(int pc) {
@@ -457,7 +457,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dstore_2(int)
 	 */
 	public void _dstore_2(int pc) {
@@ -466,7 +466,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dstore_3(int)
 	 */
 	public void _dstore_3(int pc) {
@@ -475,7 +475,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dstore(int,int)
 	 */
 	public void _dstore(int pc, int index) {
@@ -484,7 +484,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dsub(int)
 	 */
 	public void _dsub(int pc) {
@@ -493,7 +493,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dup_x1(int)
 	 */
 	public void _dup_x1(int pc) {
@@ -502,7 +502,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dup_x2(int)
 	 */
 	public void _dup_x2(int pc) {
@@ -511,7 +511,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dup(int)
 	 */
 	public void _dup(int pc) {
@@ -520,7 +520,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dup2_x1(int)
 	 */
 	public void _dup2_x1(int pc) {
@@ -529,7 +529,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dup2_x2(int)
 	 */
 	public void _dup2_x2(int pc) {
@@ -538,7 +538,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_dup2(int)
 	 */
 	public void _dup2(int pc) {
@@ -547,7 +547,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_f2d(int)
 	 */
 	public void _f2d(int pc) {
@@ -556,7 +556,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_f2i(int)
 	 */
 	public void _f2i(int pc) {
@@ -565,7 +565,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_f2l(int)
 	 */
 	public void _f2l(int pc) {
@@ -574,7 +574,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fadd(int)
 	 */
 	public void _fadd(int pc) {
@@ -583,7 +583,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_faload(int)
 	 */
 	public void _faload(int pc) {
@@ -592,7 +592,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fastore(int)
 	 */
 	public void _fastore(int pc) {
@@ -601,7 +601,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fcmpg(int)
 	 */
 	public void _fcmpg(int pc) {
@@ -610,7 +610,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fcmpl(int)
 	 */
 	public void _fcmpl(int pc) {
@@ -619,7 +619,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fconst_0(int)
 	 */
 	public void _fconst_0(int pc) {
@@ -628,7 +628,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fconst_1(int)
 	 */
 	public void _fconst_1(int pc) {
@@ -637,7 +637,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fconst_2(int)
 	 */
 	public void _fconst_2(int pc) {
@@ -646,7 +646,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fdiv(int)
 	 */
 	public void _fdiv(int pc) {
@@ -655,7 +655,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fload_0(int)
 	 */
 	public void _fload_0(int pc) {
@@ -664,7 +664,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fload_1(int)
 	 */
 	public void _fload_1(int pc) {
@@ -673,7 +673,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fload_2(int)
 	 */
 	public void _fload_2(int pc) {
@@ -682,7 +682,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fload_3(int)
 	 */
 	public void _fload_3(int pc) {
@@ -691,7 +691,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fload(int, int)
 	 */
 	public void _fload(int pc, int index) {
@@ -700,7 +700,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fmul(int)
 	 */
 	public void _fmul(int pc) {
@@ -709,7 +709,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fneg(int)
 	 */
 	public void _fneg(int pc) {
@@ -718,7 +718,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_frem(int)
 	 */
 	public void _frem(int pc) {
@@ -727,7 +727,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_freturn(int)
 	 */
 	public void _freturn(int pc) {
@@ -736,7 +736,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fstore_0(int)
 	 */
 	public void _fstore_0(int pc) {
@@ -745,7 +745,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fstore_1(int)
 	 */
 	public void _fstore_1(int pc) {
@@ -754,7 +754,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fstore_2(int)
 	 */
 	public void _fstore_2(int pc) {
@@ -763,7 +763,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fstore_3(int)
 	 */
 	public void _fstore_3(int pc) {
@@ -772,7 +772,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fstore(int, int)
 	 */
 	public void _fstore(int pc, int index) {
@@ -781,7 +781,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_fsub(int)
 	 */
 	public void _fsub(int pc) {
@@ -790,7 +790,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_getfield(int, int, ConstantPoolEntry)
 	 */
 	public void _getfield(int pc, int index, ConstantPoolEntry constantFieldref) {
@@ -799,7 +799,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_getstatic(int, int, ConstantPoolEntry)
 	 */
 	public void _getstatic(int pc, int index, ConstantPoolEntry constantFieldref) {
@@ -808,7 +808,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_goto_w(int, int)
 	 */
 	public void _goto_w(int pc, int branchOffset) {
@@ -817,7 +817,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_goto(int, int)
 	 */
 	public void _goto(int pc, int branchOffset) {
@@ -826,7 +826,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_i2b(int)
 	 */
 	public void _i2b(int pc) {
@@ -835,7 +835,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_i2c(int)
 	 */
 	public void _i2c(int pc) {
@@ -844,7 +844,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_i2d(int)
 	 */
 	public void _i2d(int pc) {
@@ -853,7 +853,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_i2f(int)
 	 */
 	public void _i2f(int pc) {
@@ -862,7 +862,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_i2l(int)
 	 */
 	public void _i2l(int pc) {
@@ -871,7 +871,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_i2s(int)
 	 */
 	public void _i2s(int pc) {
@@ -880,7 +880,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iadd(int)
 	 */
 	public void _iadd(int pc) {
@@ -889,7 +889,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iaload(int)
 	 */
 	public void _iaload(int pc) {
@@ -898,7 +898,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iand(int)
 	 */
 	public void _iand(int pc) {
@@ -907,7 +907,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iastore(int)
 	 */
 	public void _iastore(int pc) {
@@ -916,7 +916,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_if_acmpeq(int, int)
 	 */
 	public void _if_acmpeq(int pc, int branchOffset) {
@@ -925,7 +925,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_if_acmpne(int, int)
 	 */
 	public void _if_acmpne(int pc, int branchOffset) {
@@ -934,7 +934,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_if_icmpeq(int, int)
 	 */
 	public void _if_icmpeq(int pc, int branchOffset) {
@@ -943,7 +943,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_if_icmpge(int, int)
 	 */
 	public void _if_icmpge(int pc, int branchOffset) {
@@ -952,7 +952,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_if_icmpgt(int, int)
 	 */
 	public void _if_icmpgt(int pc, int branchOffset) {
@@ -961,7 +961,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_if_icmple(int, int)
 	 */
 	public void _if_icmple(int pc, int branchOffset) {
@@ -970,7 +970,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_if_icmplt(int, int)
 	 */
 	public void _if_icmplt(int pc, int branchOffset) {
@@ -979,7 +979,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_if_icmpne(int, int)
 	 */
 	public void _if_icmpne(int pc, int branchOffset) {
@@ -988,7 +988,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iconst_0(int)
 	 */
 	public void _iconst_0(int pc) {
@@ -997,7 +997,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iconst_1(int)
 	 */
 	public void _iconst_1(int pc) {
@@ -1006,7 +1006,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iconst_2(int)
 	 */
 	public void _iconst_2(int pc) {
@@ -1015,7 +1015,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iconst_3(int)
 	 */
 	public void _iconst_3(int pc) {
@@ -1024,7 +1024,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iconst_4(int)
 	 */
 	public void _iconst_4(int pc) {
@@ -1033,7 +1033,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iconst_5(int)
 	 */
 	public void _iconst_5(int pc) {
@@ -1042,7 +1042,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iconst_m1(int)
 	 */
 	public void _iconst_m1(int pc) {
@@ -1051,7 +1051,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_idiv(int)
 	 */
 	public void _idiv(int pc) {
@@ -1060,7 +1060,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ifeq(int, int)
 	 */
 	public void _ifeq(int pc, int branchOffset) {
@@ -1069,7 +1069,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ifge(int, int)
 	 */
 	public void _ifge(int pc, int branchOffset) {
@@ -1078,7 +1078,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ifgt(int, int)
 	 */
 	public void _ifgt(int pc, int branchOffset) {
@@ -1087,7 +1087,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ifle(int, int)
 	 */
 	public void _ifle(int pc, int branchOffset) {
@@ -1096,7 +1096,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iflt(int, int)
 	 */
 	public void _iflt(int pc, int branchOffset) {
@@ -1105,7 +1105,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ifne(int, int)
 	 */
 	public void _ifne(int pc, int branchOffset) {
@@ -1114,7 +1114,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ifnonnull(int, int)
 	 */
 	public void _ifnonnull(int pc, int branchOffset) {
@@ -1123,7 +1123,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ifnull(int, int)
 	 */
 	public void _ifnull(int pc, int branchOffset) {
@@ -1132,7 +1132,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iinc(int, int, int)
 	 */
 	public void _iinc(int pc, int index, int _const) {
@@ -1141,7 +1141,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iload_0(int)
 	 */
 	public void _iload_0(int pc) {
@@ -1150,7 +1150,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iload_1(int)
 	 */
 	public void _iload_1(int pc) {
@@ -1159,7 +1159,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iload_2(int)
 	 */
 	public void _iload_2(int pc) {
@@ -1168,7 +1168,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iload_3(int)
 	 */
 	public void _iload_3(int pc) {
@@ -1177,7 +1177,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iload(int, int)
 	 */
 	public void _iload(int pc, int index) {
@@ -1186,7 +1186,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_imul(int)
 	 */
 	public void _imul(int pc) {
@@ -1195,7 +1195,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ineg(int)
 	 */
 	public void _ineg(int pc) {
@@ -1204,7 +1204,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_instanceof(int, int, ConstantPoolEntry)
 	 */
 	public void _instanceof(int pc, int index, ConstantPoolEntry constantClass) {
@@ -1213,7 +1213,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_invokeinterface(int, int, byte, ConstantPoolEntry)
 	 */
 	public void _invokeinterface(int pc, int index, byte nargs, ConstantPoolEntry constantInterfaceMethodref) {
@@ -1223,7 +1223,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_invokespecial(int, int, ConstantPoolEntry)
 	 */
 	public void _invokespecial(int pc, int index, ConstantPoolEntry constantMethodref) {
@@ -1233,7 +1233,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_invokestatic(int, int, ConstantPoolEntry)
 	 */
 	public void _invokestatic(int pc, int index, ConstantPoolEntry constantMethodref) {
@@ -1243,7 +1243,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_invokevirtual(int, int, ConstantPoolEntry)
 	 */
 	public void _invokevirtual(int pc, int index, ConstantPoolEntry constantMethodref) {
@@ -1253,7 +1253,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ior(int)
 	 */
 	public void _ior(int pc) {
@@ -1262,7 +1262,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_irem(int)
 	 */
 	public void _irem(int pc) {
@@ -1271,7 +1271,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ireturn(int)
 	 */
 	public void _ireturn(int pc) {
@@ -1280,7 +1280,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ishl(int)
 	 */
 	public void _ishl(int pc) {
@@ -1289,7 +1289,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ishr(int)
 	 */
 	public void _ishr(int pc) {
@@ -1298,7 +1298,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_istore_0(int)
 	 */
 	public void _istore_0(int pc) {
@@ -1307,7 +1307,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_istore_1(int)
 	 */
 	public void _istore_1(int pc) {
@@ -1316,7 +1316,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_istore_2(int)
 	 */
 	public void _istore_2(int pc) {
@@ -1325,7 +1325,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_istore_3(int)
 	 */
 	public void _istore_3(int pc) {
@@ -1334,7 +1334,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_istore(int, int)
 	 */
 	public void _istore(int pc, int index) {
@@ -1343,7 +1343,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_isub(int)
 	 */
 	public void _isub(int pc) {
@@ -1352,7 +1352,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_iushr(int)
 	 */
 	public void _iushr(int pc) {
@@ -1361,7 +1361,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ixor(int)
 	 */
 	public void _ixor(int pc) {
@@ -1370,7 +1370,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_jsr_w(int, int)
 	 */
 	public void _jsr_w(int pc, int branchOffset) {
@@ -1379,7 +1379,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_jsr(int, int)
 	 */
 	public void _jsr(int pc, int branchOffset) {
@@ -1388,7 +1388,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_l2d(int)
 	 */
 	public void _l2d(int pc) {
@@ -1397,7 +1397,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_l2f(int)
 	 */
 	public void _l2f(int pc) {
@@ -1406,7 +1406,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_l2i(int)
 	 */
 	public void _l2i(int pc) {
@@ -1415,7 +1415,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ladd(int)
 	 */
 	public void _ladd(int pc) {
@@ -1424,7 +1424,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_laload(int)
 	 */
 	public void _laload(int pc) {
@@ -1433,7 +1433,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_land(int)
 	 */
 	public void _land(int pc) {
@@ -1442,7 +1442,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lastore(int)
 	 */
 	public void _lastore(int pc) {
@@ -1451,7 +1451,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lcmp(int)
 	 */
 	public void _lcmp(int pc) {
@@ -1460,7 +1460,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lconst_0(int)
 	 */
 	public void _lconst_0(int pc) {
@@ -1469,7 +1469,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lconst_1(int)
 	 */
 	public void _lconst_1(int pc) {
@@ -1478,7 +1478,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ldc_w(int, int, ConstantPoolEntry)
 	 */
 	public void _ldc_w(int pc, int index, ConstantPoolEntry constantPoolEntry) {
@@ -1499,7 +1499,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ldc(int, int, ConstantPoolEntry)
 	 */
 	public void _ldc(int pc, int index, ConstantPoolEntry constantPoolEntry) {
@@ -1520,7 +1520,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ldc2_w(int, int, ConstantPoolEntry)
 	 */
 	public void _ldc2_w(int pc, int index, ConstantPoolEntry constantPoolEntry) {
@@ -1535,7 +1535,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ldiv(int)
 	 */
 	public void _ldiv(int pc) {
@@ -1544,7 +1544,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lload_0(int)
 	 */
 	public void _lload_0(int pc) {
@@ -1553,7 +1553,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lload_1(int)
 	 */
 	public void _lload_1(int pc) {
@@ -1562,7 +1562,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lload_2(int)
 	 */
 	public void _lload_2(int pc) {
@@ -1571,7 +1571,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lload_3(int)
 	 */
 	public void _lload_3(int pc) {
@@ -1580,7 +1580,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lload(int, int)
 	 */
 	public void _lload(int pc, int index) {
@@ -1589,7 +1589,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lmul(int)
 	 */
 	public void _lmul(int pc) {
@@ -1598,7 +1598,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lneg(int)
 	 */
 	public void _lneg(int pc) {
@@ -1607,7 +1607,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lookupswitch(int, int, int, int[][])
 	 */
 	public void _lookupswitch(int pc, int defaultoffset, int npairs, int[][] offset_pairs) {
@@ -1624,7 +1624,7 @@ public class DefaultBytecodeVisitor {
 		}
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lor(int)
 	 */
 	public void _lor(int pc) {
@@ -1633,7 +1633,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lrem(int)
 	 */
 	public void _lrem(int pc) {
@@ -1642,7 +1642,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lreturn(int)
 	 */
 	public void _lreturn(int pc) {
@@ -1651,7 +1651,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lshl(int)
 	 */
 	public void _lshl(int pc) {
@@ -1660,7 +1660,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lshr(int)
 	 */
 	public void _lshr(int pc) {
@@ -1669,7 +1669,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lstore_0(int)
 	 */
 	public void _lstore_0(int pc) {
@@ -1678,7 +1678,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lstore_1(int)
 	 */
 	public void _lstore_1(int pc) {
@@ -1687,7 +1687,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lstore_2(int)
 	 */
 	public void _lstore_2(int pc) {
@@ -1696,7 +1696,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lstore_3(int)
 	 */
 	public void _lstore_3(int pc) {
@@ -1705,7 +1705,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lstore(int, int)
 	 */
 	public void _lstore(int pc, int index) {
@@ -1714,7 +1714,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lsub(int)
 	 */
 	public void _lsub(int pc) {
@@ -1723,7 +1723,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lushr(int)
 	 */
 	public void _lushr(int pc) {
@@ -1732,7 +1732,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_lxor(int)
 	 */
 	public void _lxor(int pc) {
@@ -1741,7 +1741,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_monitorenter(int)
 	 */
 	public void _monitorenter(int pc) {
@@ -1750,7 +1750,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_monitorexit(int)
 	 */
 	public void _monitorexit(int pc) {
@@ -1759,7 +1759,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_multianewarray(int, int, int, ConstantPoolEntry)
 	 */
 	public void _multianewarray(int pc, int index, int dimensions, ConstantPoolEntry constantClass) {
@@ -1768,7 +1768,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_new(int, int, ConstantPoolEntry)
 	 */
 	public void _new(int pc, int index, ConstantPoolEntry constantClass) {
@@ -1777,7 +1777,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_newarray(int, int)
 	 */
 	public void _newarray(int pc, int atype) {
@@ -1810,7 +1810,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_nop(int)
 	 */
 	public void _nop(int pc) {
@@ -1819,7 +1819,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_pop(int)
 	 */
 	public void _pop(int pc) {
@@ -1828,7 +1828,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_pop2(int)
 	 */
 	public void _pop2(int pc) {
@@ -1837,7 +1837,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_putfield(int, int, ConstantPoolEntry)
 	 */
 	public void _putfield(int pc, int index, ConstantPoolEntry constantFieldref) {
@@ -1846,7 +1846,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_putstatic(int, int, ConstantPoolEntry)
 	 */
 	public void _putstatic(int pc, int index, ConstantPoolEntry constantFieldref) {
@@ -1855,7 +1855,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_ret(int, int)
 	 */
 	public void _ret(int pc, int index) {
@@ -1864,7 +1864,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_return(int)
 	 */
 	public void _return(int pc) {
@@ -1873,7 +1873,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_saload(int)
 	 */
 	public void _saload(int pc) {
@@ -1882,7 +1882,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_sastore(int)
 	 */
 	public void _sastore(int pc) {
@@ -1891,7 +1891,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_sipush(int, short)
 	 */
 	public void _sipush(int pc, short value) {
@@ -1900,7 +1900,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_swap(int)
 	 */
 	public void _swap(int pc) {
@@ -1909,7 +1909,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_tableswitch(int, int, int, int, int[])
 	 */
 	public void _tableswitch(int pc, int defaultoffset, int low, int high, int[] jump_offsets) {
@@ -1927,7 +1927,7 @@ public class DefaultBytecodeVisitor {
 		}
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_wide(int, int, int)
 	 */
 	public void _wide(int pc, int iincopcode, int index, int _const) {
@@ -1937,7 +1937,7 @@ public class DefaultBytecodeVisitor {
 		_iinc(pc + 1, index, _const);
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_wide(int, int, int)
 	 */
 	public void _wide(int pc, int opcode, int index) {
@@ -1980,7 +1980,7 @@ public class DefaultBytecodeVisitor {
 		}
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_breakpoint(int)
 	 */
 	public void _breakpoint(int pc) {
@@ -1989,7 +1989,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_impdep1(int)
 	 */
 	public void _impdep1(int pc) {
@@ -1998,7 +1998,7 @@ public class DefaultBytecodeVisitor {
 		writeNewLine();
 	}
 
-	/**
+	/*
 	 * @see IBytecodeVisitor#_impdep2(int)
 	 */
 	public void _impdep2(int pc) {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Disassembler.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Disassembler.java
index 1feec44..f96d488 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Disassembler.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Disassembler.java
@@ -11,6 +11,7 @@
 package org.eclipse.equinox.p2.internal.repository.comparator;
 
 import java.util.Arrays;
+import java.util.Comparator;
 import org.eclipse.osgi.util.NLS;
 
 /**
@@ -230,7 +231,7 @@ public class Disassembler {
 		return decodeStringValue(s.toCharArray());
 	}
 
-	/**
+	/*
 	 * @see org.eclipse.jdt.core.util.ClassFileBytesDisassembler#disassemble(byte[], java.lang.String, int)
 	 */
 	public String disassemble(byte[] classFileBytes, String lineSeparator, int mode) throws ClassFormatException {
@@ -486,13 +487,6 @@ public class Disassembler {
 	}
 
 	/**
-	 * @see #disassemble(org.eclipse.jdt.core.util.ClassFileReader, java.lang.String, int)
-	 */
-	public String disassemble(ClassFileReader classFileReader, String lineSeparator) {
-		return disassemble(classFileReader, lineSeparator, Disassembler.DETAILED);
-	}
-
-	/**
 	 * Answers back the disassembled string of the ClassFileReader according to the
 	 * mode.
 	 * This is an output quite similar to the javap tool.
@@ -503,7 +497,7 @@ public class Disassembler {
 	 *
 	 * @return the disassembled string of the ClassFileReader according to the mode
 	 */
-	public String disassemble(ClassFileReader classFileReader, String lineSeparator, int mode) {
+	private String disassemble(ClassFileReader classFileReader, String lineSeparator, int mode) {
 		if (classFileReader == null)
 			return Utility.EMPTY_STRING;
 		char[] className = classFileReader.getClassName();
@@ -1045,11 +1039,35 @@ public class Disassembler {
 
 	private void disassembleTypeMembers(ClassFileReader classFileReader, char[] className, StringBuffer buffer, String lineSeparator, int tabNumber, int mode, boolean isEnum) {
 		FieldInfo[] fields = classFileReader.getFieldInfos();
+		// sort fields
+		Arrays.sort(fields, new Comparator() {
+			public int compare(Object o1, Object o2) {
+				FieldInfo fieldInfo1 = (FieldInfo) o1;
+				FieldInfo fieldInfo2 = (FieldInfo) o2;
+				int compare = new String(fieldInfo1.getName()).compareTo(new String(fieldInfo2.getName()));
+				if (compare == 0) {
+					return new String(fieldInfo1.getDescriptor()).compareTo(new String(fieldInfo2.getDescriptor()));
+				}
+				return compare;
+			}
+		});
 		for (int i = 0, max = fields.length; i < max; i++) {
 			writeNewLine(buffer, lineSeparator, tabNumber);
 			disassemble(fields[i], buffer, lineSeparator, tabNumber, mode);
 		}
 		MethodInfo[] methods = classFileReader.getMethodInfos();
+		// sort methods
+		Arrays.sort(methods, new Comparator() {
+			public int compare(Object o1, Object o2) {
+				MethodInfo methodInfo1 = (MethodInfo) o1;
+				MethodInfo methodInfo2 = (MethodInfo) o2;
+				int compare = new String(methodInfo1.getName()).compareTo(new String(methodInfo2.getName()));
+				if (compare == 0) {
+					return new String(methodInfo1.getDescriptor()).compareTo(new String(methodInfo2.getDescriptor()));
+				}
+				return compare;
+			}
+		});
 		for (int i = 0, max = methods.length; i < max; i++) {
 			writeNewLine(buffer, lineSeparator, tabNumber);
 			disassemble(classFileReader, className, methods[i], buffer, lineSeparator, tabNumber, mode);
@@ -1062,13 +1080,6 @@ public class Disassembler {
 		}
 	}
 
-	/**
-	 * @see org.eclipse.jdt.core.util.ClassFileBytesDisassembler#getDescription()
-	 */
-	public String getDescription() {
-		return Messages.disassembler_description;
-	}
-
 	private EnclosingMethodAttribute getEnclosingMethodAttribute(ClassFileReader classFileReader) {
 		ClassFileAttribute[] attributes = classFileReader.getAttributes();
 		for (int i = 0, max = attributes.length; i < max; i++) {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionAttribute.java
index cfb2534..336aae0 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionAttribute.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionAttribute.java
@@ -38,21 +38,21 @@ public class ExceptionAttribute extends ClassFileAttribute {
 		}
 	}
 
-	/**
+	/*
 	 * @see IExceptionAttribute#getExceptionIndexes()
 	 */
 	public int[] getExceptionIndexes() {
 		return this.exceptionIndexes;
 	}
 
-	/**
+	/*
 	 * @see IExceptionAttribute#getExceptionNames()
 	 */
 	public char[][] getExceptionNames() {
 		return this.exceptionNames;
 	}
 
-	/**
+	/*
 	 * @see IExceptionAttribute#getExceptionsNumber()
 	 */
 	public int getExceptionsNumber() {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionTableEntry.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionTableEntry.java
index 2faba69..6d889cd 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionTableEntry.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/ExceptionTableEntry.java
@@ -32,35 +32,35 @@ public class ExceptionTableEntry extends ClassFileStruct {
 		}
 	}
 
-	/**
+	/*
 	 * @see IExceptionTableEntry#getStartPC()
 	 */
 	public int getStartPC() {
 		return this.startPC;
 	}
 
-	/**
+	/*
 	 * @see IExceptionTableEntry#getEndPC()
 	 */
 	public int getEndPC() {
 		return this.endPC;
 	}
 
-	/**
+	/*
 	 * @see IExceptionTableEntry#getHandlerPC()
 	 */
 	public int getHandlerPC() {
 		return this.handlerPC;
 	}
 
-	/**
+	/*
 	 * @see IExceptionTableEntry#getCatchTypeIndex()
 	 */
 	public int getCatchTypeIndex() {
 		return this.catchTypeIndex;
 	}
 
-	/**
+	/*
 	 * @see IExceptionTableEntry#getCatchType()
 	 */
 	public char[] getCatchType() {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/FieldInfo.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/FieldInfo.java
index f4b0395..9ebd6a8 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/FieldInfo.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/FieldInfo.java
@@ -25,7 +25,7 @@ public class FieldInfo extends ClassFileStruct {
 	private char[] name;
 	private int nameIndex;
 
-	/**
+	/*
 	 * @param classFileBytes byte[]
 	 * @param constantPool IConstantPool
 	 * @param offset int
@@ -87,77 +87,77 @@ public class FieldInfo extends ClassFileStruct {
 		this.attributeBytes = readOffset;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#getAccessFlags()
 	 */
 	public int getAccessFlags() {
 		return this.accessFlags;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#getAttributeCount()
 	 */
 	public int getAttributeCount() {
 		return this.attributesCount;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#getAttributes()
 	 */
 	public ClassFileAttribute[] getAttributes() {
 		return this.attributes;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#getConstantValueAttribute()
 	 */
 	public ConstantValueAttribute getConstantValueAttribute() {
 		return this.constantValueAttribute;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#getDescriptor()
 	 */
 	public char[] getDescriptor() {
 		return this.descriptor;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#getDescriptorIndex()
 	 */
 	public int getDescriptorIndex() {
 		return this.descriptorIndex;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#getName()
 	 */
 	public char[] getName() {
 		return this.name;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#getNameIndex()
 	 */
 	public int getNameIndex() {
 		return this.nameIndex;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#hasConstantValueAttribute()
 	 */
 	public boolean hasConstantValueAttribute() {
 		return this.constantValueAttribute != null;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#isDeprecated()
 	 */
 	public boolean isDeprecated() {
 		return this.isDeprecated;
 	}
 
-	/**
+	/*
 	 * @see IFieldInfo#isSynthetic()
 	 */
 	public boolean isSynthetic() {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttribute.java
index 1bc57a2..4a31609 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttribute.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttribute.java
@@ -39,14 +39,14 @@ public class InnerClassesAttribute extends ClassFileAttribute {
 		}
 	}
 
-	/**
+	/*
 	 * @see IInnerClassesAttribute#getInnerClassAttributesEntries()
 	 */
 	public InnerClassesAttributeEntry[] getInnerClassAttributesEntries() {
 		return this.entries;
 	}
 
-	/**
+	/*
 	 * @see IInnerClassesAttribute#getNumberOfClasses()
 	 */
 	public int getNumberOfClasses() {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttributeEntry.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttributeEntry.java
index 7893d0b..34b267f 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttributeEntry.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/InnerClassesAttributeEntry.java
@@ -49,49 +49,49 @@ public class InnerClassesAttributeEntry extends ClassFileStruct {
 		}
 	}
 
-	/**
+	/*
 	 * @see IInnerClassesAttributeEntry#getAccessFlags()
 	 */
 	public int getAccessFlags() {
 		return this.accessFlags;
 	}
 
-	/**
+	/*
 	 * @see IInnerClassesAttributeEntry#getInnerClassName()
 	 */
 	public char[] getInnerClassName() {
 		return this.innerClassName;
 	}
 
-	/**
+	/*
 	 * @see IInnerClassesAttributeEntry#getInnerClassNameIndex()
 	 */
 	public int getInnerClassNameIndex() {
 		return this.innerClassNameIndex;
 	}
 
-	/**
+	/*
 	 * @see IInnerClassesAttributeEntry#getInnerName()
 	 */
 	public char[] getInnerName() {
 		return this.innerName;
 	}
 
-	/**
+	/*
 	 * @see IInnerClassesAttributeEntry#getInnerNameIndex()
 	 */
 	public int getInnerNameIndex() {
 		return this.innerNameIndex;
 	}
 
-	/**
+	/*
 	 * @see IInnerClassesAttributeEntry#getOuterClassName()
 	 */
 	public char[] getOuterClassName() {
 		return this.outerClassName;
 	}
 
-	/**
+	/*
 	 * @see IInnerClassesAttributeEntry#getOuterClassNameIndex()
 	 */
 	public int getOuterClassNameIndex() {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/MethodInfo.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/MethodInfo.java
index cbc9a2b..c778947 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/MethodInfo.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/MethodInfo.java
@@ -26,7 +26,7 @@ public class MethodInfo extends ClassFileStruct {
 	private char[] name;
 	private int nameIndex;
 
-	/**
+	/*
 	 * @param classFileBytes byte[]
 	 * @param constantPool IConstantPool
 	 * @param offset int
@@ -108,63 +108,63 @@ public class MethodInfo extends ClassFileStruct {
 		this.attributeBytes = readOffset;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#getAccessFlags()
 	 */
 	public int getAccessFlags() {
 		return this.accessFlags;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#getAttributeCount()
 	 */
 	public int getAttributeCount() {
 		return this.attributesCount;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#getAttributes()
 	 */
 	public ClassFileAttribute[] getAttributes() {
 		return this.attributes;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#getCodeAttribute()
 	 */
 	public CodeAttribute getCodeAttribute() {
 		return this.codeAttribute;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#getDescriptor()
 	 */
 	public char[] getDescriptor() {
 		return this.descriptor;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#getDescriptorIndex()
 	 */
 	public int getDescriptorIndex() {
 		return this.descriptorIndex;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#getExceptionAttribute()
 	 */
 	public ExceptionAttribute getExceptionAttribute() {
 		return this.exceptionAttribute;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#getName()
 	 */
 	public char[] getName() {
 		return this.name;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#getNameIndex()
 	 */
 	public int getNameIndex() {
@@ -175,21 +175,21 @@ public class MethodInfo extends ClassFileStruct {
 		return (this.accessFlags & IModifierConstants.ACC_ABSTRACT) != 0;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#isClinit()
 	 */
 	public boolean isClinit() {
 		return this.name[0] == '<' && this.name.length == 8; // Can only match <clinit>
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#isConstructor()
 	 */
 	public boolean isConstructor() {
 		return this.name[0] == '<' && this.name.length == 6; // Can only match <init>
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#isDeprecated()
 	 */
 	public boolean isDeprecated() {
@@ -200,7 +200,7 @@ public class MethodInfo extends ClassFileStruct {
 		return (this.accessFlags & IModifierConstants.ACC_NATIVE) != 0;
 	}
 
-	/**
+	/*
 	 * @see IMethodInfo#isSynthetic()
 	 */
 	public boolean isSynthetic() {
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Signature.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Signature.java
index 24a1010..e530f1e 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Signature.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/Signature.java
@@ -12,7 +12,7 @@ package org.eclipse.equinox.p2.internal.repository.comparator;
 
 import java.util.ArrayList;
 
-/**
+/*
  * Provides methods for encoding and decoding type and method signature strings.
  * <p>
  * Signatures obtained from parsing source files (i.e. files with one of the
@@ -135,81 +135,81 @@ import java.util.ArrayList;
  * @noinstantiate This class is not intended to be instantiated by clients.
  */
 public final class Signature {
-	/**
+	/*
 	 * Character constant indicating the primitive type boolean in a signature.
 	 * Value is <code>'Z'</code>.
 	 */
 	public static final char C_BOOLEAN = 'Z';
 
-	/**
+	/*
 	 * Character constant indicating the primitive type byte in a signature.
 	 * Value is <code>'B'</code>.
 	 */
 	public static final char C_BYTE = 'B';
 
-	/**
+	/*
 	 * Character constant indicating the primitive type char in a signature.
 	 * Value is <code>'C'</code>.
 	 */
 	public static final char C_CHAR = 'C';
 
-	/**
+	/*
 	 * Character constant indicating the primitive type double in a signature.
 	 * Value is <code>'D'</code>.
 	 */
 	public static final char C_DOUBLE = 'D';
 
-	/**
+	/*
 	 * Character constant indicating the primitive type float in a signature.
 	 * Value is <code>'F'</code>.
 	 */
 	public static final char C_FLOAT = 'F';
 
-	/**
+	/*
 	 * Character constant indicating the primitive type int in a signature.
 	 * Value is <code>'I'</code>.
 	 */
 	public static final char C_INT = 'I';
 
-	/**
+	/*
 	 * Character constant indicating the semicolon in a signature.
 	 * Value is <code>';'</code>.
 	 */
 	public static final char C_SEMICOLON = ';';
 
-	/**
+	/*
 	 * Character constant indicating the colon in a signature.
 	 * Value is <code>':'</code>.
 	 * @since 3.0
 	 */
 	public static final char C_COLON = ':';
 
-	/**
+	/*
 	 * Character constant indicating the primitive type long in a signature.
 	 * Value is <code>'J'</code>.
 	 */
 	public static final char C_LONG = 'J';
 
-	/**
+	/*
 	 * Character constant indicating the primitive type short in a signature.
 	 * Value is <code>'S'</code>.
 	 */
 	public static final char C_SHORT = 'S';
 
-	/**
+	/*
 	 * Character constant indicating result type void in a signature.
 	 * Value is <code>'V'</code>.
 	 */
 	public static final char C_VOID = 'V';
 
-	/**
+	/*
 	 * Character constant indicating the start of a resolved type variable in a
 	 * signature. Value is <code>'T'</code>.
 	 * @since 3.0
 	 */
 	public static final char C_TYPE_VARIABLE = 'T';
 
-	/**
+	/*
 	 * Character constant indicating an unbound wildcard type argument
 	 * in a signature.
 	 * Value is <code>'*'</code>.
@@ -217,14 +217,14 @@ public final class Signature {
 	 */
 	public static final char C_STAR = '*';
 
-	/**
+	/*
 	 * Character constant indicating an exception in a signature.
 	 * Value is <code>'^'</code>.
 	 * @since 3.1
 	 */
 	public static final char C_EXCEPTION_START = '^';
 
-	/**
+	/*
 	 * Character constant indicating a bound wildcard type argument
 	 * in a signature with extends clause.
 	 * Value is <code>'+'</code>.
@@ -232,7 +232,7 @@ public final class Signature {
 	 */
 	public static final char C_EXTENDS = '+';
 
-	/**
+	/*
 	 * Character constant indicating a bound wildcard type argument
 	 * in a signature with super clause.
 	 * Value is <code>'-'</code>.
@@ -240,164 +240,164 @@ public final class Signature {
 	 */
 	public static final char C_SUPER = '-';
 
-	/**
+	/*
 	 * Character constant indicating the dot in a signature.
 	 * Value is <code>'.'</code>.
 	 */
 	public static final char C_DOT = '.';
 
-	/**
+	/*
 	 * Character constant indicating the dollar in a signature.
 	 * Value is <code>'$'</code>.
 	 */
 	public static final char C_DOLLAR = '$';
 
-	/**
+	/*
 	 * Character constant indicating an array type in a signature.
 	 * Value is <code>'['</code>.
 	 */
 	public static final char C_ARRAY = '[';
 
-	/**
+	/*
 	 * Character constant indicating the start of a resolved, named type in a
 	 * signature. Value is <code>'L'</code>.
 	 */
 	public static final char C_RESOLVED = 'L';
 
-	/**
+	/*
 	 * Character constant indicating the start of an unresolved, named type in a
 	 * signature. Value is <code>'Q'</code>.
 	 */
 	public static final char C_UNRESOLVED = 'Q';
 
-	/**
+	/*
 	 * Character constant indicating the end of a named type in a signature.
 	 * Value is <code>';'</code>.
 	 */
 	public static final char C_NAME_END = ';';
 
-	/**
+	/*
 	 * Character constant indicating the start of a parameter type list in a
 	 * signature. Value is <code>'('</code>.
 	 */
 	public static final char C_PARAM_START = '(';
 
-	/**
+	/*
 	 * Character constant indicating the end of a parameter type list in a
 	 * signature. Value is <code>')'</code>.
 	 */
 	public static final char C_PARAM_END = ')';
 
-	/**
+	/*
 	 * Character constant indicating the start of a formal type parameter
 	 * (or type argument) list in a signature. Value is <code>'&lt;'</code>.
 	 * @since 3.0
 	 */
 	public static final char C_GENERIC_START = '<';
 
-	/**
+	/*
 	 * Character constant indicating the end of a generic type list in a
 	 * signature. Value is <code>'&gt;'</code>.
 	 * @since 3.0
 	 */
 	public static final char C_GENERIC_END = '>';
 
-	/**
+	/*
 	 * Character constant indicating a capture of a wildcard type in a
 	 * signature. Value is <code>'!'</code>.
 	 * @since 3.1
 	 */
 	public static final char C_CAPTURE = '!';
 
-	/**
+	/*
 	 * String constant for the signature of the primitive type boolean.
 	 * Value is <code>"Z"</code>.
 	 */
 	public static final String SIG_BOOLEAN = "Z"; //$NON-NLS-1$
 
-	/**
+	/*
 	 * String constant for the signature of the primitive type byte.
 	 * Value is <code>"B"</code>.
 	 */
 	public static final String SIG_BYTE = "B"; //$NON-NLS-1$
 
-	/**
+	/*
 	 * String constant for the signature of the primitive type char.
 	 * Value is <code>"C"</code>.
 	 */
 	public static final String SIG_CHAR = "C"; //$NON-NLS-1$
 
-	/**
+	/*
 	 * String constant for the signature of the primitive type double.
 	 * Value is <code>"D"</code>.
 	 */
 	public static final String SIG_DOUBLE = "D"; //$NON-NLS-1$
 
-	/**
+	/*
 	 * String constant for the signature of the primitive type float.
 	 * Value is <code>"F"</code>.
 	 */
 	public static final String SIG_FLOAT = "F"; //$NON-NLS-1$
 
-	/**
+	/*
 	 * String constant for the signature of the primitive type int.
 	 * Value is <code>"I"</code>.
 	 */
 	public static final String SIG_INT = "I"; //$NON-NLS-1$
 
-	/**
+	/*
 	 * String constant for the signature of the primitive type long.
 	 * Value is <code>"J"</code>.
 	 */
 	public static final String SIG_LONG = "J"; //$NON-NLS-1$
 
-	/**
+	/*
 	 * String constant for the signature of the primitive type short.
 	 * Value is <code>"S"</code>.
 	 */
 	public static final String SIG_SHORT = "S"; //$NON-NLS-1$
 
-	/** String constant for the signature of result type void.
+	/* String constant for the signature of result type void.
 	 * Value is <code>"V"</code>.
 	 */
 	public static final String SIG_VOID = "V"; //$NON-NLS-1$
 
-	/**
+	/*
 	 * Kind constant for a class type signature.
 	 * @see #getTypeSignatureKind(String)
 	 * @since 3.0
 	 */
 	public static final int CLASS_TYPE_SIGNATURE = 1;
 
-	/**
+	/*
 	 * Kind constant for a base (primitive or void) type signature.
 	 * @see #getTypeSignatureKind(String)
 	 * @since 3.0
 	 */
 	public static final int BASE_TYPE_SIGNATURE = 2;
 
-	/**
+	/*
 	 * Kind constant for a type variable signature.
 	 * @see #getTypeSignatureKind(String)
 	 * @since 3.0
 	 */
 	public static final int TYPE_VARIABLE_SIGNATURE = 3;
 
-	/**
+	/*
 	 * Kind constant for an array type signature.
 	 * @see #getTypeSignatureKind(String)
 	 * @since 3.0
 	 */
 	public static final int ARRAY_TYPE_SIGNATURE = 4;
 
-	/**
+	/*
 	 * Kind constant for a wildcard type signature.
 	 * @see #getTypeSignatureKind(String)
 	 * @since 3.1
 	 */
 	public static final int WILDCARD_TYPE_SIGNATURE = 5;
 
-	/**
+	/*
 	 * Kind constant for the capture of a wildcard type signature.
 	 * @see #getTypeSignatureKind(String)
 	 * @since 3.1
@@ -417,7 +417,7 @@ public final class Signature {
 	//	private static final char[] SUPER = "super".toCharArray(); //$NON-NLS-1$
 	private static final char[] CAPTURE = "capture-of".toCharArray(); //$NON-NLS-1$
 
-	/**
+	/*
 	 * Returns the number of parameter types in the given method signature.
 	 *
 	 * @param methodSignature the method signature
@@ -450,7 +450,7 @@ public final class Signature {
 		}
 	}
 
-	/**
+	/*
 	 * Extracts the parameter type signatures from the given method signature.
 	 * The method signature is expected to be dot-based.
 	 *
@@ -491,7 +491,7 @@ public final class Signature {
 		}
 	}
 
-	/**
+	/*
 	 * Extracts the return type from the given method signature. The method signature is
 	 * expected to be dot-based.
 	 *
@@ -513,7 +513,7 @@ public final class Signature {
 		return CharOperation.subarray(methodSignature, paren + 1, last + 1);
 	}
 
-	/**
+	/*
 	 * Extracts the class and interface bounds from the given formal type
 	 * parameter signature. The class bound, if present, is listed before
 	 * the interface bounds. The signature is expected to be dot-based.
@@ -558,7 +558,7 @@ public final class Signature {
 		return result;
 	}
 
-	/**
+	/*
 	 * Extracts the type parameter signatures from the given method or type signature.
 	 * The method or type signature is expected to be dot-based.
 	 *
@@ -636,7 +636,7 @@ public final class Signature {
 		throw new IllegalArgumentException();
 	}
 
-	/**
+	/*
 	 * Converts the given type signature to a readable string. The signature is expected to
 	 * be dot-based.
 	 *
@@ -678,7 +678,7 @@ public final class Signature {
 		return result;
 	}
 
-	/**
+	/*
 	 * Converts the given method signature to a readable form. The method signature is expected to
 	 * be dot-based.
 	 * <p>
@@ -750,7 +750,7 @@ public final class Signature {
 		return result;
 	}
 
-	/**
+	/*
 	 * Scans the given string for a type signature starting at the given
 	 * index and appends it to the given buffer, and returns the index of the last
 	 * character.
@@ -768,7 +768,7 @@ public final class Signature {
 		return appendTypeSignature(string, start, fullyQualifyTypeNames, buffer, false);
 	}
 
-	/**
+	/*
 	 * Scans the given string for a type signature starting at the given
 	 * index and appends it to the given buffer, and returns the index of the last
 	 * character.
@@ -863,7 +863,7 @@ public final class Signature {
 		}
 	}
 
-	/**
+	/*
 	 * Scans the given string for an array type signature starting at the given
 	 * index and appends it to the given buffer, and returns the index of the last
 	 * character.
@@ -880,7 +880,7 @@ public final class Signature {
 		return appendArrayTypeSignature(string, start, fullyQualifyTypeNames, buffer, false);
 	}
 
-	/**
+	/*
 	 * Scans the given string for an array type signature starting at the given
 	 * index and appends it to the given buffer, and returns the index of the last
 	 * character.
@@ -906,7 +906,7 @@ public final class Signature {
 		return appendTypeArgumentSignature(string, start + 1, fullyQualifyTypeNames, buffer);
 	}
 
-	/**
+	/*
 	 * Scans the given string for an array type signature starting at the given
 	 * index and appends it to the given buffer, and returns the index of the last
 	 * character.
@@ -956,7 +956,7 @@ public final class Signature {
 		return e;
 	}
 
-	/**
+	/*
 	 * Scans the given string for a class type signature starting at the given
 	 * index and appends it to the given buffer, and returns the index of the last
 	 * character.
@@ -1027,7 +1027,7 @@ public final class Signature {
 					if (resolved) {
 						// once we hit "$" there are no more package prefixes
 						removePackageQualifiers = false;
-						/**
+						/*
 						 * Convert '$' in resolved type signatures into '.'.
 						 * NOTE: This assumes that the type signature is an inner type
 						 * signature. This is true in most cases, but someone can define a
@@ -1051,7 +1051,7 @@ public final class Signature {
 		}
 	}
 
-	/**
+	/*
 	 * Scans the given string for a list of type arguments signature starting at the
 	 * given index and appends it to the given buffer, and returns the index of the
 	 * last character.
@@ -1096,7 +1096,7 @@ public final class Signature {
 		}
 	}
 
-	/**
+	/*
 	 * Scans the given string for a type argument signature starting at the given
 	 * index and appends it to the given buffer, and returns the index of the last
 	 * character.
@@ -1131,7 +1131,7 @@ public final class Signature {
 		}
 	}
 
-	/**
+	/*
 	 * Converts the given method signature to a readable form. The method signature is expected to
 	 * be dot-based.
 	 * <p>
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SourceFileAttribute.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SourceFileAttribute.java
index 4ea520b..f468e84 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SourceFileAttribute.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/comparator/SourceFileAttribute.java
@@ -32,14 +32,14 @@ public class SourceFileAttribute extends ClassFileAttribute {
 		this.sourceFileName = constantPoolEntry.getUtf8Value();
 	}
 
-	/**
+	/*
 	 * @see ISourceAttribute#getSourceFileIndex()
 	 */
 	public int getSourceFileIndex() {
 		return this.sourceFileIndex;
 	}
 
-	/**
+	/*
 	 * @see ISourceAttribute#getSourceFileName()
 	 */
 	public char[] getSourceFileName() {
