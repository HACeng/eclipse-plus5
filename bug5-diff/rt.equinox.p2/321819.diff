commit 952f0261aae1ae40b11d72fc204a37dd189e3476
Author: Pascal Rapicault <prapicau>
Date:   Sat Dec 25 04:29:47 2010 +0000

    Bug 321819 - [transport] Repository transport API is tightly coupled with the implementation

2	1	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryManager.java
5	2	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRequest.java
5	4	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/MirrorRequest.java
5	3	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/MirrorSelector.java
4	2	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/RawMirrorRequest.java
2	3	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/simple/SimpleArtifactRepository.java
2	1	bundles/org.eclipse.equinox.p2.discovery.compatibility/META-INF/MANIFEST.MF
5	4	bundles/org.eclipse.equinox.p2.discovery.compatibility/src/org/eclipse/equinox/internal/p2/discovery/compatibility/util/TransportUtil.java
2	1	bundles/org.eclipse.equinox.p2.installer/META-INF/MANIFEST.MF
1	0	bundles/org.eclipse.equinox.p2.installer/installer.product
3	3	bundles/org.eclipse.equinox.p2.installer/src/org/eclipse/equinox/internal/p2/installer/InstallDescriptionParser.java
1	0	bundles/org.eclipse.equinox.p2.reconciler.dropins/Bootstrap.product
1	0	bundles/org.eclipse.equinox.p2.repository.tools/META-INF/MANIFEST.MF
9	2	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/mirroring/Mirroring.java
2	0	bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/MirrorApplication.java
1	4	bundles/org.eclipse.equinox.p2.repository/META-INF/MANIFEST.MF
5	132	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Activator.java
7	11	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/CacheManager.java
1	1	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/CacheManagerComponent.java
18	10	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Credentials.java
0	242	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/FileInfoReader.java
0	502	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/FileReader.java
0	154	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryStatus.java
0	323	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryStatusHelper.java
0	250	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryTransport.java
55	8	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Transport.java
5	3	bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/helpers/AbstractRepositoryManager.java
2	1	bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
5	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
16	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/TestArtifactRepository.java
1	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/Bug252308.java
3	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CompositeArtifactRepositoryTest.java
1	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CorruptedJar.java
1	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/LocationTest.java
10	9	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/MirrorRequestTest.java
7	8	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/TransferExceptionsTest.java
1	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/TransferTest.java
1	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/ResumeDownloadTest.java
4	4	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/FileInfoReaderTest.java
5	5	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/FileReaderTest.java
3	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/TimeoutTest.java
27	27	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/updatesite/UpdateSiteTest.java
7	0	bundles/org.eclipse.equinox.p2.transport.ecf/.classpath
33	0	bundles/org.eclipse.equinox.p2.transport.ecf/.project
8	0	bundles/org.eclipse.equinox.p2.transport.ecf/.settings/org.eclipse.jdt.core.prefs
4	0	bundles/org.eclipse.equinox.p2.transport.ecf/.settings/org.eclipse.pde.core.prefs
19	0	bundles/org.eclipse.equinox.p2.transport.ecf/META-INF/MANIFEST.MF
8	0	bundles/org.eclipse.equinox.p2.transport.ecf/OSGI-INF/ecfTransport.xml
6	0	bundles/org.eclipse.equinox.p2.transport.ecf/build.properties
12	0	bundles/org.eclipse.equinox.p2.transport.ecf/plugin.properties
14	0	bundles/org.eclipse.equinox.p2.transport.ecf/pom.xml
169	0	bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/Activator.java
13	0	bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/ECFTransportComponent.java
247	0	bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/FileInfoReader.java
509	0	bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/FileReader.java
95	0	bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/Messages.java
155	0	bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryStatus.java
320	0	bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryStatusHelper.java
279	0	bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryTransport.java
76	0	bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/messages.properties
1	0	bundles/org.eclipse.equinox.p2.ui.admin.rcp/rcp.product
4	4	bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/CategoryXMLAction.java
14	2	bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/SiteXMLAction.java
17	23	bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/UpdateSite.java
4	2	bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/artifact/UpdateSiteArtifactRepositoryFactory.java
4	2	bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/metadata/UpdateSiteMetadataRepositoryFactory.java
7	0	features/org.eclipse.equinox.p2.sdk/feature.xml
7	0	org.eclipse.equinox.p2.releng/buildtime-features/org.eclipse.equinox.p2.user.ui/feature.xml
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryManager.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryManager.java
index 155f09f..5b74e16 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRepositoryManager.java
@@ -8,6 +8,7 @@
  *  Contributors:
  *   IBM Corporation - initial API and implementation
  *   Genuitec LLC - various bug fixes
+ *   Sonatype, Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.artifact.repository;
 
@@ -41,7 +42,7 @@ public class ArtifactRepositoryManager extends AbstractRepositoryManager<IArtifa
 	}
 
 	public IArtifactRequest createMirrorRequest(IArtifactKey key, IArtifactRepository destination, Map<String, String> destinationDescriptorProperties, Map<String, String> destinationRepositoryProperties) {
-		return new MirrorRequest(key, destination, destinationDescriptorProperties, destinationRepositoryProperties);
+		return new MirrorRequest(key, destination, destinationDescriptorProperties, destinationRepositoryProperties, getTransport());
 	}
 
 	public IArtifactRepository createRepository(URI location, String name, String type, Map<String, String> properties) throws ProvisionException {
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRequest.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRequest.java
index 2248eab..35c0b0a 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRequest.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/ArtifactRequest.java
@@ -7,10 +7,12 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Sonatype, Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.artifact.repository;
 
 import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.p2.metadata.IArtifactKey;
 import org.eclipse.equinox.p2.repository.artifact.IArtifactRepository;
 import org.eclipse.equinox.p2.repository.artifact.IArtifactRequest;
@@ -24,10 +26,11 @@ public abstract class ArtifactRequest implements IArtifactRequest {
 	protected String resolvedKey;
 	protected IArtifactRepository source;
 	protected IStatus result = DEFAULT_STATUS;
+	protected Transport transport = null;
 
-	public ArtifactRequest(IArtifactKey key) {
+	public ArtifactRequest(IArtifactKey key, Transport transport) {
 		artifact = key;
-		// TODO do we need to make this configurable? for now set default request handler to ECF
+		this.transport = transport;
 	}
 
 	public IArtifactKey getArtifactKey() {
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/MirrorRequest.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/MirrorRequest.java
index 1262780..50cd3ef 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/MirrorRequest.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/MirrorRequest.java
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *  	Compeople AG (Stefan Liebig) - various ongoing maintenance
  *   	Genuitec LLC - various bug fixes
+ *      Sonatype, Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.artifact.repository;
 
@@ -20,7 +21,7 @@ import java.util.Map;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactDescriptor;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.processing.ProcessingStepHandler;
 import org.eclipse.equinox.internal.provisional.p2.repository.IStateful;
 import org.eclipse.equinox.p2.core.ProvisionException;
@@ -54,8 +55,8 @@ public class MirrorRequest extends ArtifactRequest {
 	private final Map<String, String> targetRepositoryProperties;
 	protected IArtifactDescriptor descriptor;
 
-	public MirrorRequest(IArtifactKey key, IArtifactRepository targetRepository, Map<String, String> targetDescriptorProperties, Map<String, String> targetRepositoryProperties) {
-		super(key);
+	public MirrorRequest(IArtifactKey key, IArtifactRepository targetRepository, Map<String, String> targetDescriptorProperties, Map<String, String> targetRepositoryProperties, Transport transport) {
+		super(key, transport);
 		target = targetRepository;
 		if (targetDescriptorProperties == null || targetDescriptorProperties.isEmpty()) {
 			this.targetDescriptorProperties = null;
@@ -201,7 +202,7 @@ public class MirrorRequest extends ArtifactRequest {
 			return;
 		}
 		try {
-			RepositoryTransport.getInstance().getLastModified(statsURI, monitor);
+			transport.getLastModified(statsURI, monitor);
 		} catch (FileNotFoundException e) {
 			//ignore because it is expected that the statistics URI doesn't represent an existing file
 		} catch (Exception e) {
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/MirrorSelector.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/MirrorSelector.java
index 43eefdc..1012c9b 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/MirrorSelector.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/MirrorSelector.java
@@ -21,7 +21,7 @@ import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
 import org.eclipse.equinox.internal.p2.core.helpers.Tracing;
 import org.eclipse.equinox.internal.p2.repository.DownloadStatus;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.p2.repository.IRepository;
 import org.w3c.dom.*;
 import org.xml.sax.InputSource;
@@ -153,13 +153,16 @@ public class MirrorSelector {
 
 	private final Random random = new Random();
 
+	private final Transport transport;
+
 	/**
 	 * Constructs a mirror support class for the given repository. Mirrors are
 	 * not contacted and the mirrorsURL document is not parsed until a
 	 * mirror location request is sent.
 	 */
-	public MirrorSelector(IRepository<?> repository) {
+	public MirrorSelector(IRepository<?> repository, Transport transport) {
 		this.repository = repository;
+		this.transport = transport;
 		try {
 			String base = repository.getProperties().get(IRepository.PROP_MIRRORS_BASE_URL);
 			if (base != null) {
@@ -200,7 +203,6 @@ public class MirrorSelector {
 			DocumentBuilder builder = domFactory.newDocumentBuilder();
 			Document document = null;
 			// Use Transport to read the mirrors list (to benefit from proxy support, authentication, etc)
-			RepositoryTransport transport = RepositoryTransport.getInstance();
 			InputSource input = new InputSource(mirrorsURL);
 			input.setByteStream(transport.stream(URIUtil.fromString(mirrorsURL), monitor));
 			document = builder.parse(input);
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/RawMirrorRequest.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/RawMirrorRequest.java
index 740775e..1893e4b 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/RawMirrorRequest.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/RawMirrorRequest.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Sonatype, Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.artifact.repository;
 
@@ -14,6 +15,7 @@ import java.io.OutputStream;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.artifact.processors.md5.MD5Verifier;
 import org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.processing.ProcessingStep;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.processing.ProcessingStepHandler;
 import org.eclipse.equinox.p2.repository.artifact.IArtifactDescriptor;
@@ -23,8 +25,8 @@ import org.eclipse.osgi.util.NLS;
 public class RawMirrorRequest extends MirrorRequest {
 	protected IArtifactDescriptor sourceDescriptor, targetDescriptor;
 
-	public RawMirrorRequest(IArtifactDescriptor sourceDescriptor, IArtifactDescriptor targetDescriptor, IArtifactRepository targetRepository) {
-		super(sourceDescriptor.getArtifactKey(), targetRepository, null, null);
+	public RawMirrorRequest(IArtifactDescriptor sourceDescriptor, IArtifactDescriptor targetDescriptor, IArtifactRepository targetRepository, Transport transport) {
+		super(sourceDescriptor.getArtifactKey(), targetRepository, null, null, transport);
 		this.sourceDescriptor = sourceDescriptor;
 		this.targetDescriptor = targetDescriptor;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/simple/SimpleArtifactRepository.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/simple/SimpleArtifactRepository.java
index 5a02762..635688b 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/simple/SimpleArtifactRepository.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/simple/SimpleArtifactRepository.java
@@ -29,7 +29,6 @@ import org.eclipse.equinox.internal.p2.core.helpers.FileUtils;
 import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
 import org.eclipse.equinox.internal.p2.metadata.expression.CompoundIterator;
 import org.eclipse.equinox.internal.p2.metadata.index.IndexProvider;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
 import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.processing.*;
 import org.eclipse.equinox.internal.provisional.p2.repository.IStateful;
@@ -548,7 +547,7 @@ public class SimpleArtifactRepository extends AbstractArtifactRepository impleme
 		if (!MIRRORS_ENABLED || (!isForceThreading() && isLocal()))
 			return baseLocation;
 		if (mirrors == null)
-			mirrors = new MirrorSelector(this);
+			mirrors = new MirrorSelector(this, getTransport());
 		return mirrors.getMirrorLocation(baseLocation, monitor);
 	}
 
@@ -820,7 +819,7 @@ public class SimpleArtifactRepository extends AbstractArtifactRepository impleme
 	}
 
 	private Transport getTransport() {
-		return RepositoryTransport.getInstance();
+		return (Transport) getProvisioningAgent().getService(Transport.SERVICE_NAME);
 	}
 
 	// use this method to setup any transient fields etc after the object has been restored from a stream
diff --git a/bundles/org.eclipse.equinox.p2.discovery.compatibility/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.discovery.compatibility/META-INF/MANIFEST.MF
index 6b13c01..ae53b85 100644
--- a/bundles/org.eclipse.equinox.p2.discovery.compatibility/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.discovery.compatibility/META-INF/MANIFEST.MF
@@ -8,7 +8,8 @@ Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Require-Bundle: org.eclipse.core.runtime;bundle-version="3.3.0",
  org.eclipse.equinox.p2.core;bundle-version="2.0.0",
  org.eclipse.equinox.p2.discovery;bundle-version="1.0.0",
- org.eclipse.equinox.p2.repository;bundle-version="2.0.0"
+ org.eclipse.equinox.p2.repository;bundle-version="2.1.0",
+ org.eclipse.equinox.p2.transport.ecf;bundle-version="1.0.0"
 Export-Package: org.eclipse.equinox.internal.p2.discovery.compatibility;x-friends:="org.eclipse.equinox.p2.ui.discovery",
  org.eclipse.equinox.internal.p2.discovery.compatibility.util;x-friends:="org.eclipse.equinox.p2.ui.discovery"
 Bundle-Localization: plugin
diff --git a/bundles/org.eclipse.equinox.p2.discovery.compatibility/src/org/eclipse/equinox/internal/p2/discovery/compatibility/util/TransportUtil.java b/bundles/org.eclipse.equinox.p2.discovery.compatibility/src/org/eclipse/equinox/internal/p2/discovery/compatibility/util/TransportUtil.java
index 22d9db1..a0ccbd0 100644
--- a/bundles/org.eclipse.equinox.p2.discovery.compatibility/src/org/eclipse/equinox/internal/p2/discovery/compatibility/util/TransportUtil.java
+++ b/bundles/org.eclipse.equinox.p2.discovery.compatibility/src/org/eclipse/equinox/internal/p2/discovery/compatibility/util/TransportUtil.java
@@ -7,6 +7,7 @@
  * 
  * Contributors:
  *     Tasktop Technologies - initial API and implementation
+ *     Sonatype Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.discovery.compatibility.util;
 
@@ -16,7 +17,7 @@ import java.util.List;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.equinox.internal.p2.repository.AuthenticationFailedException;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
+import org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport;
 
 /**
  * A utility for accessing web resources
@@ -51,7 +52,7 @@ public class TransportUtil {
 	public static void downloadResource(URI location, File target, IProgressMonitor monitor) throws IOException {
 		OutputStream out = new BufferedOutputStream(new FileOutputStream(target));
 		try {
-			RepositoryTransport.getInstance().download(location, out, monitor);
+			new RepositoryTransport().download(location, out, monitor);
 		} finally {
 			out.close();
 		}
@@ -71,7 +72,7 @@ public class TransportUtil {
 	 * @throws CoreException
 	 */
 	public static void readResource(URI location, TextContentProcessor processor, IProgressMonitor monitor) throws IOException, CoreException {
-		InputStream in = RepositoryTransport.getInstance().stream(location, monitor);
+		InputStream in = new RepositoryTransport().stream(location, monitor);
 		try {
 			// FIXME how can the charset be determined?
 			BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8")); //$NON-NLS-1$
@@ -101,7 +102,7 @@ public class TransportUtil {
 		int countFound = 0;
 		for (URI location : locations) {
 			try {
-				RepositoryTransport.getInstance().getLastModified(location, monitor);
+				new RepositoryTransport().getLastModified(location, monitor);
 				if (one) {
 					return true;
 				}
diff --git a/bundles/org.eclipse.equinox.p2.installer/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.installer/META-INF/MANIFEST.MF
index 2b83836..c83f1ca 100644
--- a/bundles/org.eclipse.equinox.p2.installer/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.installer/META-INF/MANIFEST.MF
@@ -18,7 +18,8 @@ Require-Bundle: org.eclipse.osgi;bundle-version="[3.7.0,4.0.0)",
  org.eclipse.equinox.p2.artifact.repository;bundle-version="1.1.0",
  org.eclipse.swt,
  org.eclipse.core.net;bundle-version="1.1.0",
- org.eclipse.equinox.p2.repository;bundle-version="1.0.0"
+ org.eclipse.equinox.p2.repository;bundle-version="2.1.0",
+ org.eclipse.equinox.p2.transport.ecf;bundle-version="1.0.0"
 Bundle-RequiredExecutionEnvironment: J2SE-1.5,
  J2SE-1.4,
  CDC-1.1/Foundation-1.1
diff --git a/bundles/org.eclipse.equinox.p2.installer/installer.product b/bundles/org.eclipse.equinox.p2.installer/installer.product
index 7cea772..aa1cbd5 100644
--- a/bundles/org.eclipse.equinox.p2.installer/installer.product
+++ b/bundles/org.eclipse.equinox.p2.installer/installer.product
@@ -73,6 +73,7 @@
       <plugin id="org.eclipse.equinox.p2.repository"/>
       <plugin id="org.eclipse.equinox.p2.touchpoint.eclipse"/>
       <plugin id="org.eclipse.equinox.p2.touchpoint.natives"/>
+      <plugin id="org.eclipse.equinox.p2.transport.ecf"/>
       <plugin id="org.eclipse.equinox.preferences"/>
       <plugin id="org.eclipse.equinox.registry"/>
       <plugin id="org.eclipse.equinox.security"/>
diff --git a/bundles/org.eclipse.equinox.p2.installer/src/org/eclipse/equinox/internal/p2/installer/InstallDescriptionParser.java b/bundles/org.eclipse.equinox.p2.installer/src/org/eclipse/equinox/internal/p2/installer/InstallDescriptionParser.java
index ed8e946..6fd6c4e 100644
--- a/bundles/org.eclipse.equinox.p2.installer/src/org/eclipse/equinox/internal/p2/installer/InstallDescriptionParser.java
+++ b/bundles/org.eclipse.equinox.p2.installer/src/org/eclipse/equinox/internal/p2/installer/InstallDescriptionParser.java
@@ -19,10 +19,10 @@ import java.util.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.CollectionUtils;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
-import org.eclipse.equinox.p2.metadata.VersionedId;
+import org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport;
 import org.eclipse.equinox.internal.provisional.p2.installer.InstallDescription;
 import org.eclipse.equinox.p2.metadata.IVersionedId;
+import org.eclipse.equinox.p2.metadata.VersionedId;
 
 /**
  * This class is responsible for loading install descriptions from a stream.
@@ -65,7 +65,7 @@ public class InstallDescriptionParser {
 		}
 		Map<String, String> properties;
 		try {
-			in = RepositoryTransport.getInstance().stream(propsURI, monitor);
+			in = new RepositoryTransport().stream(propsURI, monitor);
 			properties = CollectionUtils.loadProperties(in);
 		} finally {
 			safeClose(in);
diff --git a/bundles/org.eclipse.equinox.p2.reconciler.dropins/Bootstrap.product b/bundles/org.eclipse.equinox.p2.reconciler.dropins/Bootstrap.product
index 2d2a9af..0fc475c 100644
--- a/bundles/org.eclipse.equinox.p2.reconciler.dropins/Bootstrap.product
+++ b/bundles/org.eclipse.equinox.p2.reconciler.dropins/Bootstrap.product
@@ -55,6 +55,7 @@
       <plugin id="org.eclipse.equinox.p2.repository"/>
       <plugin id="org.eclipse.equinox.p2.touchpoint.eclipse"/>
       <plugin id="org.eclipse.equinox.p2.touchpoint.natives"/>
+      <plugin id="org.eclipse.equinox.p2.transport.ecf"/>
       <plugin id="org.eclipse.equinox.preferences"/>
       <plugin id="org.eclipse.equinox.registry"/>
       <plugin id="org.eclipse.equinox.security"/>
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.repository.tools/META-INF/MANIFEST.MF
index 52fd05c..8ecfc1d 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/META-INF/MANIFEST.MF
@@ -28,6 +28,7 @@ Import-Package: org.eclipse.equinox.app;version="1.0.0",
  org.eclipse.equinox.internal.p2.metadata.repository,
  org.eclipse.equinox.internal.p2.persistence,
  org.eclipse.equinox.internal.p2.publisher.eclipse,
+ org.eclipse.equinox.internal.p2.repository,
  org.eclipse.equinox.internal.p2.repository.helpers,
  org.eclipse.equinox.internal.provisional.p2.director,
  org.eclipse.equinox.p2.core;version="[2.0.0,3.0.0)",
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/mirroring/Mirroring.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/mirroring/Mirroring.java
index a6a0dc5..dcc6fec 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/mirroring/Mirroring.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/mirroring/Mirroring.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- *  Copyright (c) 2007, 2009 IBM Corporation and others.
+ *  Copyright (c) 2007, 2010 IBM Corporation and others.
  *  All rights reserved. This program and the accompanying materials
  *  are made available under the terms of the Eclipse Public License v1.0
  *  which accompanies this distribution, and is available at
@@ -8,6 +8,7 @@
  *  Contributors:
  *     IBM Corporation - initial API and implementation
  *  	Compeople AG (Stefan Liebig) - various ongoing maintenance
+ *      Sonatype, Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.p2.internal.repository.mirroring;
 
@@ -15,6 +16,7 @@ import java.util.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.artifact.repository.RawMirrorRequest;
 import org.eclipse.equinox.internal.p2.core.helpers.CollectionUtils;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.internal.repository.tools.Activator;
 import org.eclipse.equinox.p2.internal.repository.tools.Messages;
@@ -43,6 +45,7 @@ public class Mirroring {
 	private String comparatorID;
 	private List<IArtifactKey> keysToMirror;
 	private IArtifactMirrorLog comparatorLog;
+	private Transport transport;
 
 	private IArtifactComparator getComparator() {
 		if (comparator == null)
@@ -192,7 +195,7 @@ public class Mirroring {
 	 * Create, and execute a MirrorRequest for a given descriptor.
 	 */
 	private IStatus downloadArtifact(IArtifactRepository sourceRepo, IArtifactDescriptor destDescriptor, IArtifactDescriptor srcDescriptor) {
-		RawMirrorRequest request = new RawMirrorRequest(srcDescriptor, destDescriptor, destination);
+		RawMirrorRequest request = new RawMirrorRequest(srcDescriptor, destDescriptor, destination, transport);
 		request.perform(sourceRepo, new NullProgressMonitor());
 
 		return request.getResult();
@@ -306,4 +309,8 @@ public class Mirroring {
 	public void setCompareExclusions(IQuery<IArtifactDescriptor> excludedKeys) {
 		compareExclusionQuery = excludedKeys;
 	}
+
+	public void setTransport(Transport transport) {
+		this.transport = transport;
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/MirrorApplication.java b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/MirrorApplication.java
index 30fca24..b748d36 100644
--- a/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/MirrorApplication.java
+++ b/bundles/org.eclipse.equinox.p2.repository.tools/src/org/eclipse/equinox/p2/internal/repository/tools/MirrorApplication.java
@@ -19,6 +19,7 @@ import org.eclipse.equinox.app.IApplication;
 import org.eclipse.equinox.app.IApplicationContext;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
 import org.eclipse.equinox.internal.p2.director.PermissiveSlicer;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.internal.p2.repository.helpers.RepositoryHelper;
 import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.internal.repository.mirroring.*;
@@ -211,6 +212,7 @@ public class MirrorApplication extends AbstractApplication implements IApplicati
 		mirror.setBaseline(initializeBaseline());
 		mirror.setValidate(validate);
 		mirror.setCompareExclusions(compareExclusions);
+		mirror.setTransport((Transport) agent.getService(Transport.SERVICE_NAME));
 
 		// If IUs have been specified then only they should be mirrored, otherwise mirror everything.
 		if (keys.size() > 0)
diff --git a/bundles/org.eclipse.equinox.p2.repository/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.repository/META-INF/MANIFEST.MF
index 166ba92..fba4b33 100644
--- a/bundles/org.eclipse.equinox.p2.repository/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.repository/META-INF/MANIFEST.MF
@@ -25,10 +25,7 @@ Export-Package: org.eclipse.equinox.internal.p2.persistence;x-friends:="org.ecli
  org.eclipse.equinox.p2.repository.metadata.spi;version="2.0.0",
  org.eclipse.equinox.p2.repository.spi;version="2.0.0"
 Require-Bundle: org.eclipse.equinox.common,
- org.eclipse.ecf.filetransfer,
- org.eclipse.ecf,
- org.eclipse.equinox.registry;bundle-version="3.3.0",
- org.eclipse.ecf.provider.filetransfer;bundle-version="3.0.1"
+ org.eclipse.equinox.registry;bundle-version="3.3.0"
 Bundle-RequiredExecutionEnvironment: J2SE-1.5,
  J2SE-1.4,
  CDC-1.1/Foundation-1.1
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Activator.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Activator.java
index f4cc471..196f09f 100644
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Activator.java
+++ b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Activator.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2009 Cloudsmith Inc and others.
+ * Copyright (c) 2009, 2010 Cloudsmith Inc and others.
  *  All rights reserved. This program and the accompanying materials
  *  are made available under the terms of the Eclipse Public License v1.0
  *  which accompanies this distribution, and is available at
@@ -9,15 +9,12 @@
  * 	Cloudsmith Inc - initial API and implementation
  * 	IBM Corporation - ongoing development
  * 	Genuitec - Bug 291926
+ *  Sonatype, Inc. - transport split
  ******************************************************************************/
 package org.eclipse.equinox.internal.p2.repository;
 
-import org.eclipse.ecf.filetransfer.service.IRetrieveFileTransferFactory;
-import org.eclipse.ecf.provider.filetransfer.IFileTransferProtocolToFactoryMapper;
-import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
-import org.osgi.framework.*;
-import org.osgi.service.packageadmin.PackageAdmin;
-import org.osgi.util.tracker.ServiceTracker;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
 
 /**
  * The activator class controls the plug-in life cycle.
@@ -27,143 +24,19 @@ import org.osgi.util.tracker.ServiceTracker;
 public class Activator implements BundleActivator {
 
 	public static final String ID = "org.eclipse.equinox.p2.repository"; //$NON-NLS-1$
-	private static final String HTTP = "http"; //$NON-NLS-1$
-	private static final String HTTPS = "https"; //$NON-NLS-1$
 
 	private static BundleContext context;
-	// tracker for ECF service
-	private ServiceTracker<IRetrieveFileTransferFactory, IRetrieveFileTransferFactory> retrievalFactoryTracker;
-
-	// tracker for protocolToFactoryMapperTracker
-	private ServiceTracker<IFileTransferProtocolToFactoryMapper, IFileTransferProtocolToFactoryMapper> protocolToFactoryMapperTracker = null;
-
-	// The shared instance
-	private static Activator plugin;
 
 	public void start(BundleContext aContext) throws Exception {
 		Activator.context = aContext;
-		Activator.plugin = this;
 	}
 
 	public void stop(BundleContext aContext) throws Exception {
-		Activator.context = null;
-		Activator.plugin = null;
-		if (retrievalFactoryTracker != null) {
-			retrievalFactoryTracker.close();
-			retrievalFactoryTracker = null;
-		}
-		if (protocolToFactoryMapperTracker != null) {
-			protocolToFactoryMapperTracker.close();
-			protocolToFactoryMapperTracker = null;
-		}
-
+		Activator.context = aContext;
 	}
 
 	public static BundleContext getContext() {
 		return Activator.context;
 	}
 
-	/**
-	 * Get singleton instance.
-	 *
-	 * @return the shared instance
-	 */
-	public static Activator getDefault() {
-		return plugin;
-	}
-
-	/**
-	 * Returns a {@link IRetrieveFileTransferFactory} using a {@link ServiceTracker} after having attempted
-	 * to start the bundle "org.eclipse.ecf.provider.filetransfer". If something is wrong with the configuration
-	 * this method returns null.
-	 * @return a factory, or null, if configuration is incorrect
-	 */
-	public IRetrieveFileTransferFactory getRetrieveFileTransferFactory() {
-		return getFileTransferServiceTracker().getService();
-	}
-
-	public synchronized void useJREHttpClient() {
-		IFileTransferProtocolToFactoryMapper mapper = getProtocolToFactoryMapper();
-		if (mapper != null) {
-			// remove http
-			// Remove browse provider
-			String providerId = mapper.getBrowseFileTransferFactoryId(HTTP);
-			if (providerId != null) {
-				mapper.removeBrowseFileTransferFactory(providerId);
-			}
-			// Remove retrieve provider
-			providerId = mapper.getRetrieveFileTransferFactoryId(HTTP);
-			if (providerId != null) {
-				mapper.removeRetrieveFileTransferFactory(providerId);
-			}
-			// Remove send provider
-			providerId = mapper.getSendFileTransferFactoryId(HTTP);
-			if (providerId != null) {
-				mapper.removeSendFileTransferFactory(providerId);
-			}
-			// remove https
-			// Remove browse provider
-			providerId = mapper.getBrowseFileTransferFactoryId(HTTPS);
-			if (providerId != null) {
-				mapper.removeBrowseFileTransferFactory(providerId);
-			}
-			// Remove retrieve provider
-			providerId = mapper.getRetrieveFileTransferFactoryId(HTTPS);
-			if (providerId != null) {
-				mapper.removeRetrieveFileTransferFactory(providerId);
-			}
-			// Remove send provider
-			providerId = mapper.getSendFileTransferFactoryId(HTTPS);
-			if (providerId != null) {
-				mapper.removeSendFileTransferFactory(providerId);
-			}
-		}
-	}
-
-	/**
-	 * Gets the singleton ServiceTracker for the IRetrieveFileTransferFactory and starts the bundles
-	 * "org.eclipse.ecf" and
-	 * "org.eclipse.ecf.provider.filetransfer" on first call.
-	 * @return  ServiceTracker
-	 */
-	private synchronized ServiceTracker<IRetrieveFileTransferFactory, IRetrieveFileTransferFactory> getFileTransferServiceTracker() {
-		if (retrievalFactoryTracker == null) {
-			retrievalFactoryTracker = new ServiceTracker<IRetrieveFileTransferFactory, IRetrieveFileTransferFactory>(Activator.getContext(), IRetrieveFileTransferFactory.class, null);
-			retrievalFactoryTracker.open();
-			startBundle("org.eclipse.ecf"); //$NON-NLS-1$
-			startBundle("org.eclipse.ecf.provider.filetransfer"); //$NON-NLS-1$
-		}
-		return retrievalFactoryTracker;
-	}
-
-	private IFileTransferProtocolToFactoryMapper getProtocolToFactoryMapper() {
-		if (protocolToFactoryMapperTracker == null) {
-			protocolToFactoryMapperTracker = new ServiceTracker<IFileTransferProtocolToFactoryMapper, IFileTransferProtocolToFactoryMapper>(context, IFileTransferProtocolToFactoryMapper.class, null);
-			protocolToFactoryMapperTracker.open();
-		}
-		return protocolToFactoryMapperTracker.getService();
-	}
-
-	private boolean startBundle(String bundleId) {
-		PackageAdmin packageAdmin = (PackageAdmin) ServiceHelper.getService(Activator.getContext(), PackageAdmin.class.getName());
-		if (packageAdmin == null)
-			return false;
-
-		Bundle[] bundles = packageAdmin.getBundles(bundleId, null);
-		if (bundles != null && bundles.length > 0) {
-			for (int i = 0; i < bundles.length; i++) {
-				try {
-					if ((bundles[i].getState() & Bundle.INSTALLED) == 0) {
-						bundles[i].start(Bundle.START_ACTIVATION_POLICY);
-						bundles[i].start(Bundle.START_TRANSIENT);
-						return true;
-					}
-				} catch (BundleException e) {
-					// failed, try next bundle
-				}
-			}
-		}
-		return false;
-	}
-
 }
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/CacheManager.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/CacheManager.java
index 802cd6d..2f05d37 100644
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/CacheManager.java
+++ b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/CacheManager.java
@@ -17,7 +17,6 @@ import java.net.URI;
 import java.util.EventObject;
 import java.util.HashSet;
 import org.eclipse.core.runtime.*;
-import org.eclipse.ecf.filetransfer.UserCancelledException;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
 import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
 import org.eclipse.equinox.internal.provisional.p2.core.eventbus.SynchronousProvisioningListener;
@@ -44,6 +43,8 @@ public class CacheManager {
 
 	private final IAgentLocation agentLocation;
 
+	private final Transport transport;
+
 	/**
 	 * IStateful implementation of BufferedOutputStream. Class is used to get the status from
 	 * a download operation.
@@ -66,8 +67,9 @@ public class CacheManager {
 
 	}
 
-	public CacheManager(IAgentLocation agentLocation) {
+	public CacheManager(IAgentLocation agentLocation, Transport transport) {
 		this.agentLocation = agentLocation;
+		this.transport = transport;
 	}
 
 	private static SynchronousProvisioningListener busListener;
@@ -129,7 +131,7 @@ public class CacheManager {
 			// bug 269588 - server may return 0 when file exists, so extra flag is needed
 			boolean useJar = true;
 			try {
-				lastModifiedRemote = getTransport().getLastModified(jarLocation, submonitor.newChild(1));
+				lastModifiedRemote = transport.getLastModified(jarLocation, submonitor.newChild(1));
 				if (lastModifiedRemote <= 0)
 					LogHelper.log(new Status(IStatus.WARNING, Activator.ID, "Server returned lastModified <= 0 for " + jarLocation)); //$NON-NLS-1$
 			} catch (AuthenticationFailedException e) {
@@ -166,15 +168,13 @@ public class CacheManager {
 				// (Status is reported based on finding the XML file as giving up on certain errors
 				// when checking for the jar may not be correct).
 				try {
-					lastModifiedRemote = getTransport().getLastModified(xmlLocation, submonitor.newChild(1));
+					lastModifiedRemote = transport.getLastModified(xmlLocation, submonitor.newChild(1));
 					// if lastModifiedRemote is 0 - something is wrong in the communication stack, as 
 					// a FileNotFound exception should have been thrown.
 					// bug 269588 - server may return 0 when file exists - site is not correctly configured
 					if (lastModifiedRemote <= 0)
 						LogHelper.log(new Status(IStatus.WARNING, Activator.ID, "Server returned lastModified <= 0 for " + xmlLocation)); //$NON-NLS-1$
 
-				} catch (UserCancelledException e) {
-					throw new OperationCanceledException();
 				} catch (FileNotFoundException e) {
 					throw new FileNotFoundException(NLS.bind(Messages.CacheManager_Neither_0_nor_1_found, jarLocation, xmlLocation));
 				} catch (AuthenticationFailedException e) {
@@ -261,10 +261,6 @@ public class CacheManager {
 		return files;
 	}
 
-	private RepositoryTransport getTransport() {
-		return RepositoryTransport.getInstance();
-	}
-
 	/**
 	 * Adds a {@link SynchronousProvisioningListener} to the event bus for
 	 * deleting cache files when the corresponding repository is deleted.
@@ -334,7 +330,7 @@ public class CacheManager {
 		IStatus result = null;
 		try {
 			submonitor.setWorkRemaining(1000);
-			result = getTransport().download(remoteFile, stream, submonitor.newChild(1000));
+			result = transport.download(remoteFile, stream, submonitor.newChild(1000));
 		} catch (OperationCanceledException e) {
 			// need to pick up the status - a new operation canceled exception is thrown at the end
 			// as status will be CANCEL.
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/CacheManagerComponent.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/CacheManagerComponent.java
index 26d5851..5c617e4 100644
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/CacheManagerComponent.java
+++ b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/CacheManagerComponent.java
@@ -19,7 +19,7 @@ public class CacheManagerComponent implements IAgentServiceFactory {
 
 	public Object createService(IProvisioningAgent agent) {
 		final IProvisioningEventBus eventBus = (IProvisioningEventBus) agent.getService(IProvisioningEventBus.SERVICE_NAME);
-		CacheManager cache = new CacheManager((IAgentLocation) agent.getService(IAgentLocation.SERVICE_NAME));
+		CacheManager cache = new CacheManager((IAgentLocation) agent.getService(IAgentLocation.SERVICE_NAME), (Transport) agent.getService(Transport.SERVICE_NAME));
 		cache.setEventBus(eventBus);
 		return cache;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Credentials.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Credentials.java
index 0a9bb7e..19f5481 100644
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Credentials.java
+++ b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Credentials.java
@@ -18,11 +18,9 @@ import java.net.URI;
 import java.net.URLEncoder;
 import java.util.*;
 import org.eclipse.core.runtime.*;
-import org.eclipse.ecf.filetransfer.UserCancelledException;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.internal.p2.repository.helpers.DebugHelper;
-import org.eclipse.equinox.p2.core.IProvisioningAgent;
-import org.eclipse.equinox.p2.core.UIServices;
+import org.eclipse.equinox.p2.core.*;
 import org.eclipse.equinox.p2.repository.IRepository;
 import org.eclipse.equinox.security.storage.*;
 
@@ -106,7 +104,7 @@ public class Credentials {
 					throw new UnsupportedEncodingException("No UTF-8 encoding and missing system property: file.encoding"); //$NON-NLS-1$
 				nodeKey = URLEncoder.encode(host, enc);
 			} catch (UnsupportedEncodingException e) {
-				throw RepositoryStatusHelper.internalError(e);
+				throw internalError(e);
 			}
 		}
 		if (DebugHelper.DEBUG_REPOSITORY_CREDENTIALS) {
@@ -148,10 +146,10 @@ public class Credentials {
 						prefNode = securePreferences.node(nodeName);
 				} catch (IllegalArgumentException e) {
 					// if the node name is illegal/malformed (should not happen).
-					throw RepositoryStatusHelper.internalError(e);
+					throw internalError(e);
 				} catch (IllegalStateException e) {
 					// thrown if preference store has been tampered with
-					throw RepositoryStatusHelper.internalError(e);
+					throw internalError(e);
 				}
 				if (!prompt) {
 					try {
@@ -175,7 +173,7 @@ public class Credentials {
 						}
 						return restoreFromMemory(nodeName);
 					} catch (StorageException e) {
-						throw RepositoryStatusHelper.internalError(e);
+						throw internalError(e);
 					}
 				}
 				// need to prompt user for user name and password
@@ -258,9 +256,9 @@ public class Credentials {
 									prefNode.put(IRepository.PROP_PASSWORD, loginDetails.getPassword(), true);
 									prefNode.flush();
 								} catch (StorageException e1) {
-									throw RepositoryStatusHelper.internalError(e1);
+									throw internalError(e1);
 								} catch (IOException e) {
-									throw RepositoryStatusHelper.internalError(e);
+									throw internalError(e);
 								}
 							} else {
 								// if persisted earlier - the preference should be removed
@@ -275,7 +273,7 @@ public class Credentials {
 									try {
 										prefNode.flush();
 									} catch (IOException e) {
-										throw RepositoryStatusHelper.internalError(e);
+										throw internalError(e);
 									}
 								}
 							}
@@ -481,4 +479,14 @@ public class Credentials {
 			timestamp = System.currentTimeMillis();
 		}
 	}
+
+	/**
+	 * Get default "InternalError" ProvisionException.
+	 * @param t
+	 * @return a default "InternalError"
+	 */
+	public static ProvisionException internalError(Throwable t) {
+		return new ProvisionException(new Status(IStatus.ERROR, Activator.ID, //
+				ProvisionException.INTERNAL_ERROR, Messages.repoMan_internalError, t));
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/FileInfoReader.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/FileInfoReader.java
deleted file mode 100644
index c84d4e2..0000000
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/FileInfoReader.java
+++ /dev/null
@@ -1,242 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2009, IBM Corporation, and others.
- * The code, documentation and other materials contained herein have been
- * licensed under the Eclipse Public License - v 1.0 by the copyright holder
- * listed above, as the Initial Contributor under such license. The text of
- * such license is available at www.eclipse.org.
- * Contributors:
- * 	IBM Corporation - initial implementation
- * 	Cloudsmith Inc - modified API, and implementation
- ******************************************************************************/
-package org.eclipse.equinox.internal.p2.repository;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.URI;
-import org.eclipse.core.runtime.*;
-import org.eclipse.core.runtime.jobs.Job;
-import org.eclipse.ecf.core.*;
-import org.eclipse.ecf.core.security.IConnectContext;
-import org.eclipse.ecf.filetransfer.*;
-import org.eclipse.ecf.filetransfer.events.IRemoteFileSystemBrowseEvent;
-import org.eclipse.ecf.filetransfer.events.IRemoteFileSystemEvent;
-import org.eclipse.ecf.filetransfer.identity.*;
-import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
-import org.eclipse.osgi.util.NLS;
-
-/**
- * The FileInfoReader is a {@link Job} similar to {@link FileReader}, but without the support
- * from ECF (there is currently no way to wait on a BrowseRequest job, as this is internal to
- * ECF). If such support is added, this class is easily modified.
- * 
- */
-public class FileInfoReader extends Job implements IRemoteFileSystemListener {
-	private Exception exception;
-	private IProgressMonitor theMonitor;
-	private final int connectionRetryCount;
-	private final long connectionRetryDelay;
-	private final IConnectContext connectContext;
-	final Boolean[] barrier = new Boolean[1];
-	private IRemoteFile[] remoteFiles;
-	private IRemoteFileSystemRequest browseRequest;
-
-	/* (non-Javadoc)
-	 * @see org.eclipse.core.runtime.jobs.Job#run(org.eclipse.core.runtime.IProgressMonitor)
-	 */
-	protected IStatus run(IProgressMonitor monitor) {
-		synchronized (barrier) {
-			while (barrier[0] == null) {
-				try {
-					barrier.wait(1000);
-					if (theMonitor.isCanceled() && browseRequest != null)
-						browseRequest.cancel();
-				} catch (InterruptedException e) {
-					//ignore
-				}
-			}
-		}
-		return Status.OK_STATUS;
-	}
-
-	/**
-	 * Waits until request is processed (barrier[0] is non null).
-	 * This is a bit of a hack, as it would be better if the ECFBrowser worked in similar fashion to
-	 * file transfer were a custom job can be supplied.
-	 * TODO: log an issue for ECF.
-	 */
-	private void waitOnSelf() {
-		schedule();
-		while (barrier[0] == null) {
-			boolean logged = false;
-			try {
-				join();
-			} catch (InterruptedException e) {
-				if (!logged)
-					LogHelper.log(new Status(IStatus.WARNING, Activator.ID, "Unexpected interrupt while waiting on ECF browse request", e)); //$NON-NLS-1$
-			}
-		}
-	}
-
-	/**
-	 * Create a new FileInfoReader that will retry failed connection attempts and sleep some amount of time between each
-	 * attempt.
-	 */
-	public FileInfoReader(IConnectContext aConnectContext) {
-		super(Messages.repo_loading); // job label - TODO: this is a bad label
-		barrier[0] = null;
-		// Hide this job.
-		setSystem(true);
-		setUser(false);
-		connectionRetryCount = RepositoryPreferences.getConnectionRetryCount();
-		connectionRetryDelay = RepositoryPreferences.getConnectionMsRetryDelay();
-		connectContext = aConnectContext;
-	}
-
-	/**
-	 * Get the requested information.
-	 * @return IRemoteFile[] or null if there was an error.
-	 * @throws CoreException 
-	 * @throws FileNotFoundException 
-	 * @throws AuthenticationFailedException 
-	 * @throws JREHttpClientRequiredException 
-	 */
-	public IRemoteFile[] getRemoteFiles(URI location, IProgressMonitor monitor) throws AuthenticationFailedException, FileNotFoundException, CoreException, JREHttpClientRequiredException {
-		if (monitor != null)
-			monitor.beginTask(location.toString(), 1);
-		try {
-			sendBrowseRequest(location, monitor);
-			waitOnSelf();
-			// throw any exception received in a callback
-			checkException(location, connectionRetryCount);
-
-			return remoteFiles;
-		} finally {
-			if (monitor != null) {
-				monitor.done();
-			}
-		}
-
-	}
-
-	public IRemoteFile getRemoteFile(URI location, IProgressMonitor monitor) throws AuthenticationFailedException, FileNotFoundException, CoreException, JREHttpClientRequiredException {
-
-		getRemoteFiles(location, monitor);
-		return remoteFiles != null && remoteFiles.length > 0 ? remoteFiles[0] : null;
-	}
-
-	public long getLastModified(URI location, IProgressMonitor monitor) throws AuthenticationFailedException, FileNotFoundException, CoreException, JREHttpClientRequiredException {
-		IRemoteFile file = getRemoteFile(location, monitor);
-		if (file == null)
-			throw new FileNotFoundException(location.toString());
-		return file.getInfo().getLastModified();
-	}
-
-	public void handleRemoteFileEvent(IRemoteFileSystemEvent event) {
-		exception = event.getException();
-		if (exception != null) {
-			synchronized (barrier) {
-				barrier[0] = Boolean.TRUE;
-				barrier.notify();
-			}
-		} else if (event instanceof IRemoteFileSystemBrowseEvent) {
-			IRemoteFileSystemBrowseEvent fsbe = (IRemoteFileSystemBrowseEvent) event;
-			remoteFiles = fsbe.getRemoteFiles();
-			if (theMonitor != null)
-				theMonitor.worked(1);
-			synchronized (barrier) {
-				barrier[0] = Boolean.TRUE;
-				barrier.notify();
-			}
-		} else {
-			synchronized (barrier) {
-				barrier[0] = Boolean.FALSE; // ended by unknown reason
-				barrier.notify();
-			}
-		}
-	}
-
-	protected void sendBrowseRequest(URI uri, IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
-		IContainer container;
-		try {
-			container = ContainerFactory.getDefault().createContainer();
-		} catch (ContainerCreateException e) {
-			throw RepositoryStatusHelper.fromMessage(Messages.ecf_configuration_error);
-		}
-
-		IRemoteFileSystemBrowserContainerAdapter adapter = (IRemoteFileSystemBrowserContainerAdapter) container.getAdapter(IRemoteFileSystemBrowserContainerAdapter.class);
-		if (adapter == null) {
-			throw RepositoryStatusHelper.fromMessage(Messages.ecf_configuration_error);
-		}
-
-		adapter.setConnectContextForAuthentication(connectContext);
-
-		this.exception = null;
-		this.theMonitor = monitor;
-		for (int retryCount = 0;; retryCount++) {
-			if (monitor != null && monitor.isCanceled())
-				throw new OperationCanceledException();
-
-			try {
-				IFileID fileID = FileIDFactory.getDefault().createFileID(adapter.getBrowseNamespace(), uri.toString());
-				browseRequest = adapter.sendBrowseRequest(fileID, this);
-			} catch (RemoteFileSystemException e) {
-				exception = e;
-			} catch (FileCreateException e) {
-				exception = e;
-			}
-			if (checkException(uri, retryCount))
-				break;
-		}
-	}
-
-	protected Exception getException() {
-		return exception;
-	}
-
-	/**
-	 * Utility method to check exception condition and determine if retry should be done.
-	 * If there was an exception it is translated into one of the specified exceptions and thrown.
-	 * 
-	 * @param uri the URI being read - used for logging purposes
-	 * @param attemptCounter - the current attempt number (start with 0)
-	 * @return true if the exception is an IOException and attemptCounter < connectionRetryCount, false otherwise
-	 * @throws CoreException
-	 * @throws FileNotFoundException
-	 * @throws AuthenticationFailedException
-	 * @throws JREHttpClientRequiredException 
-	 */
-	private boolean checkException(URI uri, int attemptCounter) throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
-		// note that 'exception' could have been captured in a callback
-		if (exception != null) {
-			// check if HTTP client needs to be changed
-			RepositoryStatusHelper.checkJREHttpClientRequired(exception);
-
-			// if this is a authentication failure - it is not meaningful to continue
-			RepositoryStatusHelper.checkPermissionDenied(exception);
-
-			// if this is a file not found - it is not meaningful to continue
-			RepositoryStatusHelper.checkFileNotFound(exception, uri);
-
-			Throwable t = RepositoryStatusHelper.unwind(exception);
-			if (t instanceof CoreException)
-				throw RepositoryStatusHelper.unwindCoreException((CoreException) t);
-
-			if (t instanceof IOException && attemptCounter < connectionRetryCount) {
-				// TODO: Retry only certain exceptions or filter out
-				// some exceptions not worth retrying
-				//
-				exception = null;
-				try {
-					LogHelper.log(new Status(IStatus.WARNING, Activator.ID, NLS.bind(Messages.connection_to_0_failed_on_1_retry_attempt_2, new String[] {uri.toString(), t.getMessage(), String.valueOf(attemptCounter)}), t));
-
-					Thread.sleep(connectionRetryDelay);
-					return false;
-				} catch (InterruptedException e) {
-					/* ignore */
-				}
-			}
-			throw RepositoryStatusHelper.wrap(exception);
-		}
-		return true;
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/FileReader.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/FileReader.java
deleted file mode 100644
index fcc92c2..0000000
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/FileReader.java
+++ /dev/null
@@ -1,502 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2006, 2010 Cloudsmith Inc.
- *  All rights reserved. This program and the accompanying materials
- *  are made available under the terms of the Eclipse Public License v1.0
- *  which accompanies this distribution, and is available at
- *  http://www.eclipse.org/legal/epl-v10.html
- * 
- *  Contributors:
- * 	Cloudsmith Inc - initial API and implementation
- * 	IBM Corporation - ongoing development
- *  Sonatype Inc - ongoing development
- ******************************************************************************/
-package org.eclipse.equinox.internal.p2.repository;
-
-import java.io.*;
-import java.net.SocketTimeoutException;
-import java.net.URI;
-import java.util.Date;
-import org.eclipse.core.runtime.*;
-import org.eclipse.core.runtime.jobs.Job;
-import org.eclipse.ecf.core.security.IConnectContext;
-import org.eclipse.ecf.filetransfer.*;
-import org.eclipse.ecf.filetransfer.events.*;
-import org.eclipse.ecf.filetransfer.identity.*;
-import org.eclipse.ecf.filetransfer.service.IRetrieveFileTransferFactory;
-import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
-import org.eclipse.osgi.util.NLS;
-
-/**
- * FileReader is an ECF FileTransferJob implementation.
- */
-public final class FileReader extends FileTransferJob implements IFileTransferListener {
-	/**
-	 * Class used to suppress warnings about a job being blocked by another job.
-	 * Since we are running a job that will always be blocked by another job that
-	 * is actually performing the transfer, these messages are unnecessary and ugly.
-	 */
-	static class SuppressBlockedMonitor extends SubProgressMonitor {
-		public SuppressBlockedMonitor(IProgressMonitor monitor, int ticks) {
-			super(monitor, ticks);
-		}
-
-		public void setBlocked(IStatus reason) {
-			//do nothing
-		}
-
-		public void clearBlocked() {
-			//do nothing
-		}
-	}
-
-	private static IFileReaderProbe testProbe;
-	private boolean closeStreamWhenFinished = false;
-	private Exception exception;
-	private FileInfo fileInfo;
-	private long lastProgressCount;
-	private long lastStatsCount;
-	protected IProgressMonitor theMonitor;
-	private OutputStream theOutputStream;
-	private ProgressStatistics statistics;
-	private final int connectionRetryCount;
-	private final long connectionRetryDelay;
-	private final IConnectContext connectContext;
-	private URI requestUri;
-	protected IFileTransferConnectStartEvent connectEvent;
-	private Job cancelJob;
-	private boolean monitorStarted;
-
-	/**
-	 * Create a new FileReader that will retry failed connection attempts and sleep some amount of time between each
-	 * attempt.
-	 */
-	public FileReader(IConnectContext aConnectContext) {
-		super(Messages.FileTransport_reader); // job label
-
-		// Hide this job.
-		setSystem(true);
-		setUser(false);
-		connectionRetryCount = RepositoryPreferences.getConnectionRetryCount();
-		connectionRetryDelay = RepositoryPreferences.getConnectionMsRetryDelay();
-		connectContext = aConnectContext;
-	}
-
-	public FileInfo getLastFileInfo() {
-		return fileInfo;
-	}
-
-	/**
-	 * A job to handle cancelation when trying to establish a socket connection.
-	 * At this point we don't have a transfer job running yet, so we need a separate
-	 * job to monitor for cancelation.
-	 */
-	protected class CancelHandler extends Job {
-		private boolean done = false;
-
-		protected CancelHandler() {
-			super(Messages.FileTransport_cancelCheck);
-			setSystem(true);
-		}
-
-		public IStatus run(IProgressMonitor jobMonitor) {
-			while (!done && !jobMonitor.isCanceled()) {
-				try {
-					Thread.sleep(1000);
-				} catch (InterruptedException e) {
-					return Status.CANCEL_STATUS;
-				}
-				if (theMonitor != null && theMonitor.isCanceled())
-					if (connectEvent != null)
-						connectEvent.cancel();
-			}
-			return Status.OK_STATUS;
-		}
-
-		protected void canceling() {
-			//wake up from sleep in run method
-			Thread t = getThread();
-			if (t != null)
-				t.interrupt();
-		}
-
-	}
-
-	public synchronized void handleTransferEvent(IFileTransferEvent event) {
-		if (event instanceof IFileTransferConnectStartEvent) {
-			// keep the connect event to be able to cancel the transfer
-			connectEvent = (IFileTransferConnectStartEvent) event;
-			cancelJob = new CancelHandler();
-			//schedule with a delay to avoid the overhead of an extra job on a fast connection
-			cancelJob.schedule(500);
-		} else if (event instanceof IIncomingFileTransferReceiveStartEvent) {
-			//we no longer need the cancel handler because we are about to fork the transfer job
-			if (cancelJob != null)
-				cancelJob.cancel();
-			IIncomingFileTransfer source = ((IIncomingFileTransferEvent) event).getSource();
-			try {
-				FileInfo fi = new FileInfo();
-				Date lastModified = source.getRemoteLastModified();
-				if (lastModified != null)
-					fi.setLastModified(lastModified.getTime());
-				fi.setName(source.getRemoteFileName());
-				fi.setSize(source.getFileLength());
-				fileInfo = fi;
-
-				((IIncomingFileTransferReceiveStartEvent) event).receive(theOutputStream, this);
-			} catch (IOException e) {
-				exception = e;
-				return;
-			}
-			long fileLength = source.getFileLength();
-			ProgressStatistics stats = new ProgressStatistics(requestUri, source.getRemoteFileName(), fileLength);
-			setStatistics(stats);
-
-			if (theMonitor != null) {
-				theMonitor.beginTask(null, 1000);
-				monitorStarted = true;
-				theMonitor.subTask(stats.report());
-				lastStatsCount = 0;
-				lastProgressCount = 0;
-			}
-			onStart(source);
-		} else if (event instanceof IIncomingFileTransferReceiveDataEvent) {
-			IIncomingFileTransfer source = ((IIncomingFileTransferEvent) event).getSource();
-			if (theMonitor != null) {
-				if (theMonitor.isCanceled()) {
-					source.cancel();
-					return;
-				}
-
-				long br = source.getBytesReceived();
-				long count = br - lastStatsCount;
-				lastStatsCount = br;
-				ProgressStatistics stats = getStatistics();
-				if (stats != null) {
-					stats.increase(count);
-					fileInfo.setAverageSpeed(stats.getAverageSpeed());
-					if (stats.shouldReport()) {
-						count = br - lastProgressCount;
-						lastProgressCount = br;
-						theMonitor.subTask(stats.report());
-						theMonitor.worked((int) (1000 * count / stats.getTotal()));
-					}
-				}
-			}
-			onData(source);
-		} else if (event instanceof IIncomingFileTransferReceiveDoneEvent) {
-			if (closeStreamWhenFinished)
-				hardClose(theOutputStream);
-
-			if (exception == null)
-				exception = ((IIncomingFileTransferReceiveDoneEvent) event).getException();
-			onDone(((IIncomingFileTransferReceiveDoneEvent) event).getSource());
-		}
-	}
-
-	public InputStream read(URI url, final IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
-		final PipedInputStream input = new PipedInputStream();
-		PipedOutputStream output;
-		try {
-			output = new PipedOutputStream(input);
-		} catch (IOException e) {
-			throw RepositoryStatusHelper.wrap(e);
-		}
-		RepositoryTracing.debug("Downloading {0}", url); //$NON-NLS-1$
-
-		sendRetrieveRequest(url, output, null, true, monitor);
-
-		return new InputStream() {
-			public int available() throws IOException {
-				checkException();
-				return input.available();
-			}
-
-			public void close() throws IOException {
-				hardClose(input);
-				checkException();
-			}
-
-			public void mark(int readlimit) {
-				input.mark(readlimit);
-			}
-
-			public boolean markSupported() {
-				return input.markSupported();
-			}
-
-			public int read() throws IOException {
-				checkException();
-				return input.read();
-			}
-
-			public int read(byte b[]) throws IOException {
-				checkException();
-				return input.read(b);
-			}
-
-			public int read(byte b[], int off, int len) throws IOException {
-				checkException();
-				return input.read(b, off, len);
-			}
-
-			public void reset() throws IOException {
-				checkException();
-				input.reset();
-			}
-
-			public long skip(long n) throws IOException {
-				checkException();
-				return input.skip(n);
-			}
-
-			private void checkException() throws IOException {
-				if (getException() == null)
-					return;
-
-				IOException e;
-				Throwable t = RepositoryStatusHelper.unwind(getException());
-				if (t instanceof IOException)
-					e = (IOException) t;
-				else {
-					if (t instanceof UserCancelledException) {
-						Throwable cause = t;
-						t = new OperationCanceledException(t.getMessage());
-						t.initCause(cause);
-					}
-					e = new IOException(t.getMessage());
-					e.initCause(t);
-				}
-				throw e;
-			}
-		};
-	}
-
-	public void readInto(URI uri, OutputStream anOutputStream, IProgressMonitor monitor) //
-			throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
-		readInto(uri, anOutputStream, -1, monitor);
-	}
-
-	public boolean belongsTo(Object family) {
-		return family == this;
-	}
-
-	public void readInto(URI uri, OutputStream anOutputStream, long startPos, IProgressMonitor monitor) //
-			throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
-		if (monitor == null)
-			monitor = new NullProgressMonitor();
-		try {
-			sendRetrieveRequest(uri, anOutputStream, (startPos != -1 ? new DownloadRange(startPos) : null), false, monitor);
-			Job.getJobManager().join(this, new SuppressBlockedMonitor(monitor, 0));
-			if (monitor.isCanceled() && connectEvent != null)
-				connectEvent.cancel();
-			// check and throw exception if received in callback
-			checkException(uri, connectionRetryCount);
-		} catch (InterruptedException e) {
-			monitor.setCanceled(true);
-			throw new OperationCanceledException();
-		} finally {
-			// kill the cancelJob, if there is one
-			if (cancelJob != null) {
-				cancelJob.cancel();
-				cancelJob = null;
-			}
-			// If monitor was never started, make sure it is balanced
-			if (!monitorStarted)
-				monitor.beginTask(null, 1);
-			monitorStarted = false;
-			monitor.done();
-		}
-	}
-
-	protected void sendRetrieveRequest(URI uri, OutputStream outputStream, DownloadRange range, boolean closeStreamOnFinish, //
-			IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
-
-		IRetrieveFileTransferFactory factory = Activator.getDefault().getRetrieveFileTransferFactory();
-		if (factory == null) {
-			throw RepositoryStatusHelper.fromMessage(Messages.ecf_configuration_error);
-		}
-		IRetrieveFileTransferContainerAdapter adapter = factory.newInstance();
-
-		adapter.setConnectContextForAuthentication(connectContext);
-
-		this.exception = null;
-		this.closeStreamWhenFinished = closeStreamOnFinish;
-		this.fileInfo = null;
-		this.statistics = null;
-		this.lastProgressCount = 0L;
-		this.lastStatsCount = 0L;
-		this.theMonitor = monitor;
-		this.monitorStarted = false;
-		this.theOutputStream = outputStream;
-		this.requestUri = uri;
-
-		for (int retryCount = 0;; retryCount++) {
-			if (monitor != null && monitor.isCanceled())
-				throw new OperationCanceledException();
-
-			try {
-				IFileID fileID = FileIDFactory.getDefault().createFileID(adapter.getRetrieveNamespace(), uri.toString());
-				if (range != null)
-					adapter.sendRetrieveRequest(fileID, range, this, null);
-				else
-					adapter.sendRetrieveRequest(fileID, this, null);
-			} catch (IncomingFileTransferException e) {
-				exception = e;
-			} catch (FileCreateException e) {
-				exception = e;
-			} catch (Throwable t) {
-				if (exception != null)
-					exception.printStackTrace();
-			}
-			if (checkException(uri, retryCount))
-				break;
-		}
-	}
-
-	/**
-	 * Utility method to check exception condition and determine if retry should be done.
-	 * If there was an exception it is translated into one of the specified exceptions and thrown.
-	 * 
-	 * @param uri the URI being read - used for logging purposes
-	 * @param attemptCounter - the current attempt number (start with 0)
-	 * @return true if the exception is an IOException and attemptCounter < connectionRetryCount, false otherwise
-	 * @throws CoreException
-	 * @throws FileNotFoundException
-	 * @throws AuthenticationFailedException
-	 */
-	private boolean checkException(URI uri, int attemptCounter) throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
-		// note that 'exception' could have been captured in a callback
-		if (exception != null) {
-			// check if HTTP client needs to be changed
-			RepositoryStatusHelper.checkJREHttpClientRequired(exception);
-
-			// if this is an 'authentication failure' - it is not meaningful to continue
-			RepositoryStatusHelper.checkPermissionDenied(exception);
-
-			// if this is a 'file not found' - it is not meaningful to continue
-			RepositoryStatusHelper.checkFileNotFound(exception, uri);
-
-			Throwable t = RepositoryStatusHelper.unwind(exception);
-			if (t instanceof CoreException)
-				throw RepositoryStatusHelper.unwindCoreException((CoreException) t);
-
-			// not meaningful to try 'timeout again' - if a server is that busy, we
-			// need to wait for quite some time before retrying- it is not likely it is
-			// just a temporary network thing.
-			if (t instanceof SocketTimeoutException)
-				throw RepositoryStatusHelper.wrap(t);
-
-			if (t instanceof IOException && attemptCounter < connectionRetryCount) {
-				// TODO: Retry only certain exceptions or filter out
-				// some exceptions not worth retrying
-				//
-				exception = null;
-				try {
-					LogHelper.log(new Status(IStatus.WARNING, Activator.ID, NLS.bind(Messages.connection_to_0_failed_on_1_retry_attempt_2, new String[] {uri.toString(), t.getMessage(), String.valueOf(attemptCounter)}), t));
-
-					Thread.sleep(connectionRetryDelay);
-					return false;
-				} catch (InterruptedException e) {
-					/* ignore */
-				}
-			}
-			throw RepositoryStatusHelper.wrap(exception);
-		}
-		return true;
-	}
-
-	protected Exception getException() {
-		return exception;
-	}
-
-	/**
-	 * Closes input and output streams
-	 * @param aStream
-	 */
-	public static void hardClose(Object aStream) {
-		if (aStream != null) {
-			try {
-				if (aStream instanceof OutputStream)
-					((OutputStream) aStream).close();
-				else if (aStream instanceof InputStream)
-					((InputStream) aStream).close();
-			} catch (IOException e) { /* ignore */
-			}
-		}
-	}
-
-	private static class DownloadRange implements IFileRangeSpecification {
-
-		private long startPosition;
-
-		public DownloadRange(long startPos) {
-			startPosition = startPos;
-		}
-
-		public long getEndPosition() {
-			return -1;
-		}
-
-		public long getStartPosition() {
-			return startPosition;
-		}
-
-	}
-
-	private void onDone(IIncomingFileTransfer source) {
-		if (testProbe != null)
-			testProbe.onDone(this, source, theMonitor);
-	}
-
-	private void onStart(IIncomingFileTransfer source) {
-		if (testProbe != null)
-			testProbe.onStart(this, source, theMonitor);
-	}
-
-	private void onData(IIncomingFileTransfer source) {
-		if (testProbe != null)
-			testProbe.onData(this, source, theMonitor);
-	}
-
-	/**
-	 * Sets a testing probe that can intercept events on the file reader for testing purposes.
-	 * This method should only ever be called from automated test suites.
-	 */
-	public static void setTestProbe(IFileReaderProbe probe) {
-		testProbe = probe;
-	}
-
-	/**
-	 * Sets the progress statistics. This method is synchronized because the field
-	 * is accessed from both the transfer thread and the thread initiating the transfer
-	 * and we need to ensure field values are consistent across threads.
-	 * 
-	 * @param statistics the statistics to set, or <code>null</code>
-	 */
-	private synchronized void setStatistics(ProgressStatistics statistics) {
-		this.statistics = statistics;
-	}
-
-	/**
-	 * Returns the progress statistics. This method is synchronized because the field
-	 * is accessed from both the transfer thread and the thread initiating the transfer
-	 * and we need to ensure field values are consistent across threads.
-	 * 
-	 * @return the statistics, or <code>null</code>
-	 */
-	private synchronized ProgressStatistics getStatistics() {
-		return statistics;
-	}
-
-	/**
-	 * An interface to allow automated tests to hook into file reader events
-	 * @see #setTestProbe
-	 */
-	public interface IFileReaderProbe {
-		public void onStart(FileReader reader, IIncomingFileTransfer source, IProgressMonitor monitor);
-
-		public void onData(FileReader reader, IIncomingFileTransfer source, IProgressMonitor monitor);
-
-		public void onDone(FileReader reader, IIncomingFileTransfer source, IProgressMonitor monitor);
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryStatus.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryStatus.java
deleted file mode 100644
index aae393d..0000000
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryStatus.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2009 Cloudsmith Inc. and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     Cloudsmith Inc. - initial API and implementation
- *******************************************************************************/
-
-package org.eclipse.equinox.internal.p2.repository;
-
-import org.eclipse.equinox.p2.core.ProvisionException;
-
-import java.io.FileNotFoundException;
-import java.net.*;
-import org.eclipse.core.runtime.IStatus;
-import org.eclipse.ecf.core.identity.IDCreateException;
-import org.eclipse.ecf.filetransfer.BrowseFileTransferException;
-import org.eclipse.ecf.filetransfer.IncomingFileTransferException;
-import org.eclipse.osgi.util.NLS;
-
-/**
- * Utility class to transform transport errors into error messages.
- *
- */
-public class RepositoryStatus {
-
-	public static String codeToMessage(int code, String toDownload) {
-		switch (code) {
-			case 400 :
-				return NLS.bind(Messages.TransportErrorTranslator_400, toDownload);
-			case 401 :
-				return NLS.bind(Messages.TransportErrorTranslator_401, toDownload);
-			case 402 :
-				return NLS.bind(Messages.TransportErrorTranslator_402, toDownload);
-			case 403 :
-				return NLS.bind(Messages.TransportErrorTranslator_403, toDownload);
-			case 404 :
-				return NLS.bind(Messages.TransportErrorTranslator_404, toDownload);
-			case 405 :
-				return NLS.bind(Messages.TransportErrorTranslator_405, toDownload);
-			case 406 :
-				return NLS.bind(Messages.TransportErrorTranslator_406, toDownload);
-			case 407 :
-				return NLS.bind(Messages.TransportErrorTranslator_407, toDownload);
-			case 408 :
-				return NLS.bind(Messages.TransportErrorTranslator_408, toDownload);
-			case 409 :
-				return NLS.bind(Messages.TransportErrorTranslator_409, toDownload);
-			case 410 :
-				return NLS.bind(Messages.TransportErrorTranslator_410, toDownload);
-			case 411 :
-				return NLS.bind(Messages.TransportErrorTranslator_411, toDownload);
-			case 412 :
-				return NLS.bind(Messages.TransportErrorTranslator_412, toDownload);
-			case 413 :
-				return NLS.bind(Messages.TransportErrorTranslator_413, toDownload);
-			case 414 :
-				return NLS.bind(Messages.TransportErrorTranslator_414, toDownload);
-			case 415 :
-				return NLS.bind(Messages.TransportErrorTranslator_415, toDownload);
-			case 416 :
-				return NLS.bind(Messages.TransportErrorTranslator_416, toDownload);
-			case 417 :
-				return NLS.bind(Messages.TransportErrorTranslator_417, toDownload);
-			case 418 :
-				return NLS.bind(Messages.TransportErrorTranslator_418, toDownload);
-			case 422 :
-				return NLS.bind(Messages.TransportErrorTranslator_422, toDownload);
-			case 423 :
-				return NLS.bind(Messages.TransportErrorTranslator_423, toDownload);
-			case 424 :
-				return NLS.bind(Messages.TransportErrorTranslator_424, toDownload);
-			case 425 :
-				return NLS.bind(Messages.TransportErrorTranslator_425, toDownload);
-			case 426 :
-				return NLS.bind(Messages.TransportErrorTranslator_426, toDownload);
-			case 449 :
-				return NLS.bind(Messages.TransportErrorTranslator_449, toDownload);
-			case 450 :
-				return NLS.bind(Messages.TransportErrorTranslator_450, toDownload);
-
-			case 500 :
-				return NLS.bind(Messages.TransportErrorTranslator_500, toDownload);
-			case 501 :
-				return NLS.bind(Messages.TransportErrorTranslator_501, toDownload);
-			case 502 :
-				return NLS.bind(Messages.TransportErrorTranslator_502, toDownload);
-			case 503 :
-				return NLS.bind(Messages.TransportErrorTranslator_503, toDownload);
-			case 504 :
-				return NLS.bind(Messages.TransportErrorTranslator_504, toDownload);
-			case 505 :
-				return NLS.bind(Messages.TransportErrorTranslator_505, toDownload);
-			case 506 :
-				return NLS.bind(Messages.TransportErrorTranslator_506, toDownload);
-			case 507 :
-				return NLS.bind(Messages.TransportErrorTranslator_507, toDownload);
-			case 508 :
-				return NLS.bind(Messages.TransportErrorTranslator_508, toDownload);
-			case 510 :
-				return NLS.bind(Messages.TransportErrorTranslator_510, toDownload);
-
-			default :
-				return NLS.bind(Messages.TransportErrorTranslator_UnknownErrorCode, Integer.toString(code), toDownload);
-		}
-	}
-
-	public static DownloadStatus forStatus(IStatus original, URI toDownload) {
-		Throwable t = original.getException();
-		return forException(t, toDownload);
-	}
-
-	public static DownloadStatus forException(Throwable t, URI toDownload) {
-		if (t instanceof FileNotFoundException || (t instanceof IncomingFileTransferException && ((IncomingFileTransferException) t).getErrorCode() == 404))
-			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.ARTIFACT_NOT_FOUND, NLS.bind(Messages.artifact_not_found, toDownload), t);
-		if (t instanceof ConnectException)
-			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_READ, NLS.bind(Messages.TransportErrorTranslator_UnableToConnectToRepository_0, toDownload), t);
-		if (t instanceof UnknownHostException)
-			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_INVALID_LOCATION, NLS.bind(Messages.TransportErrorTranslator_UnknownHost, toDownload), t);
-		if (t instanceof IDCreateException) {
-			IStatus status = ((IDCreateException) t).getStatus();
-			if (status != null && status.getException() != null)
-				t = status.getException();
-
-			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_INVALID_LOCATION, NLS.bind(Messages.TransportErrorTranslator_MalformedRemoteFileReference, toDownload), t);
-		}
-		int code = 0;
-
-		// default to report as read repository error
-		int provisionCode = ProvisionException.REPOSITORY_FAILED_READ;
-
-		if (t instanceof IncomingFileTransferException)
-			code = ((IncomingFileTransferException) t).getErrorCode();
-		else if (t instanceof BrowseFileTransferException)
-			code = ((BrowseFileTransferException) t).getErrorCode();
-
-		// Switch on error codes in the HTTP error code range. 
-		// Note that 404 uses ARTIFACT_NOT_FOUND (as opposed to REPOSITORY_NOT_FOUND, which
-		// is determined higher up in the calling chain).
-		if (code == 401)
-			provisionCode = ProvisionException.REPOSITORY_FAILED_AUTHENTICATION;
-		else if (code == 404)
-			provisionCode = ProvisionException.ARTIFACT_NOT_FOUND;
-
-		// Add more specific translation here
-
-		return new DownloadStatus(IStatus.ERROR, Activator.ID, provisionCode, //
-				code == 0 ? NLS.bind(Messages.io_failedRead, toDownload) //
-						: codeToMessage(code, toDownload.toString()), t);
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryStatusHelper.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryStatusHelper.java
deleted file mode 100644
index ac3d66b..0000000
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryStatusHelper.java
+++ /dev/null
@@ -1,323 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2009 Cloudsmith Inc, and other.
- * The code, documentation and other materials contained herein have been
- * licensed under the Eclipse Public License - v 1.0 by the individual
- * copyright holders listed above, as Initial Contributors under such license.
- * The text of such license is available at www.eclipse.org.
- * Contributors:
- * 	Cloudsmith Inc. - Initial API and implementation
- *  IBM Corporation - Original Implementation of checkPermissionDenied
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.repository;
-
-import org.eclipse.equinox.p2.core.ProvisionException;
-
-import java.io.*;
-import java.lang.reflect.InvocationTargetException;
-import java.net.URI;
-import org.eclipse.core.runtime.*;
-import org.eclipse.ecf.filetransfer.BrowseFileTransferException;
-import org.eclipse.ecf.filetransfer.IncomingFileTransferException;
-import org.eclipse.osgi.util.NLS;
-
-/**
- * RepositoryStatusHelper is a utility class for processing of exceptions and status.
- */
-public abstract class RepositoryStatusHelper {
-
-	private static final long serialVersionUID = 1L;
-	protected static final String SERVER_REDIRECT = "Server redirected too many times"; //$NON-NLS-1$
-
-	public static IStatus createStatus(String nlsMessage, Object arg) {
-		return createExceptionStatus(null, nlsMessage, new Object[] {arg});
-	}
-
-	public static IStatus createStatus(String nlsMessage, Object arg1, Object arg2) {
-		return createExceptionStatus(null, nlsMessage, new Object[] {arg1, arg2});
-	}
-
-	public static IStatus createStatus(String nlsMessage, Object arg1, Object arg2, Object arg3) {
-		return createExceptionStatus(null, nlsMessage, new Object[] {arg1, arg2, arg3});
-	}
-
-	public static IStatus createStatus(String nlsMessage, Object[] args) {
-		return createExceptionStatus(null, nlsMessage, args);
-	}
-
-	public static IStatus createStatus(String nlsMessage) {
-		return createExceptionStatus(null, nlsMessage, new Object[] {});
-	}
-
-	public static IStatus createExceptionStatus(Throwable cause) {
-		return (cause instanceof CoreException) ? ((CoreException) cause).getStatus() : new Status(IStatus.ERROR, Activator.ID, IStatus.OK, cause.getMessage(), cause);
-	}
-
-	public static IStatus createExceptionStatus(Throwable cause, String nlsMessage, Object[] args) {
-		if (args != null && args.length > 0)
-			nlsMessage = NLS.bind(nlsMessage, args);
-		return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, nlsMessage, cause);
-	}
-
-	public static IStatus createExceptionStatus(Throwable cause, String nlsMessage, Object arg1, Object arg2, Object arg3) {
-		return createExceptionStatus(cause, nlsMessage, new Object[] {arg1, arg2, arg3});
-	}
-
-	public static IStatus createExceptionStatus(Throwable cause, String nlsMessage, Object arg1, Object arg2) {
-		return createExceptionStatus(cause, nlsMessage, new Object[] {arg1, arg2});
-	}
-
-	public static IStatus createExceptionStatus(Throwable cause, String nlsMessage, Object arg1) {
-		return createExceptionStatus(cause, nlsMessage, new Object[] {arg1});
-	}
-
-	public static IStatus createExceptionStatus(Throwable cause, String nlsMessage) {
-		return createExceptionStatus(cause, nlsMessage, new Object[] {});
-	}
-
-	public static void deeplyPrint(Throwable e, PrintStream strm, boolean stackTrace) {
-		deeplyPrint(e, strm, stackTrace, 0);
-	}
-
-	public static CoreException fromMessage(String nlsMessage, Object[] args) {
-		return fromExceptionMessage(null, nlsMessage, args);
-	}
-
-	public static CoreException fromMessage(String nlsMessage, Object arg1) {
-		return fromExceptionMessage(null, nlsMessage, new Object[] {arg1});
-	}
-
-	public static CoreException fromMessage(String nlsMessage, Object arg1, Object arg2) {
-		return fromExceptionMessage(null, nlsMessage, new Object[] {arg1, arg2});
-	}
-
-	public static CoreException fromMessage(String nlsMessage, Object arg1, Object arg2, Object arg3) {
-		return fromExceptionMessage(null, nlsMessage, new Object[] {arg1, arg2, arg3});
-	}
-
-	public static CoreException fromMessage(String nlsMessage) {
-		return fromExceptionMessage(null, nlsMessage, new Object[] {});
-	}
-
-	public static CoreException fromExceptionMessage(Throwable cause, String nlsMessage, Object[] args) {
-		CoreException ce = new CoreException(createExceptionStatus(cause, nlsMessage, args));
-		if (cause != null)
-			ce.initCause(cause);
-		return ce;
-	}
-
-	public static CoreException fromExceptionMessage(Throwable cause, String nlsMessage, Object arg1, Object arg2, Object arg3) {
-		return fromExceptionMessage(cause, nlsMessage, new Object[] {arg1, arg2, arg3});
-	}
-
-	public static CoreException fromExceptionMessage(Throwable cause, String nlsMessage, Object arg1, Object arg2) {
-		return fromExceptionMessage(cause, nlsMessage, new Object[] {arg1, arg2});
-	}
-
-	public static CoreException fromExceptionMessage(Throwable cause, String nlsMessage, Object arg1) {
-		return fromExceptionMessage(cause, nlsMessage, new Object[] {arg1});
-	}
-
-	public static CoreException fromExceptionMessage(Throwable cause, String nlsMessage) {
-		return fromExceptionMessage(cause, nlsMessage, new Object[] {});
-	}
-
-	public static Throwable unwind(Throwable t) {
-		for (;;) {
-			Class<? extends Throwable> tc = t.getClass();
-
-			// We don't use instanceof operator since we want
-			// the explicit class, not subclasses.
-			//
-			if (tc != RuntimeException.class && tc != InvocationTargetException.class && tc != IOException.class)
-				break;
-
-			Throwable cause = t.getCause();
-			if (cause == null)
-				break;
-
-			String msg = t.getMessage();
-			if (msg != null && !msg.equals(cause.toString()))
-				break;
-
-			t = cause;
-		}
-		return t;
-	}
-
-	public static CoreException unwindCoreException(CoreException exception) {
-		IStatus status = exception.getStatus();
-		while (status != null && status.getException() instanceof CoreException) {
-			exception = (CoreException) status.getException();
-			status = exception.getStatus();
-		}
-		return exception;
-	}
-
-	public static CoreException wrap(IStatus status) {
-		CoreException e = new CoreException(status);
-		Throwable t = status.getException();
-		if (t != null)
-			e.initCause(t);
-		return e;
-	}
-
-	public static CoreException wrap(Throwable t) {
-		t = unwind(t);
-		if (t instanceof CoreException)
-			return unwindCoreException((CoreException) t);
-
-		if (t instanceof OperationCanceledException || t instanceof InterruptedException)
-			return new CoreException(Status.CANCEL_STATUS);
-
-		String msg = t.toString();
-		return fromExceptionMessage(t, msg);
-	}
-
-	private static void appendLevelString(PrintStream strm, int level) {
-		if (level > 0) {
-			strm.print("[0"); //$NON-NLS-1$
-			for (int idx = 1; idx < level; ++idx) {
-				strm.print('.');
-				strm.print(level);
-			}
-			strm.print(']');
-		}
-	}
-
-	private static void deeplyPrint(CoreException ce, PrintStream strm, boolean stackTrace, int level) {
-		appendLevelString(strm, level);
-		if (stackTrace)
-			ce.printStackTrace(strm);
-		deeplyPrint(ce.getStatus(), strm, stackTrace, level);
-	}
-
-	private static void deeplyPrint(IStatus status, PrintStream strm, boolean stackTrace, int level) {
-		appendLevelString(strm, level);
-		String msg = status.getMessage();
-		strm.println(msg);
-		Throwable cause = status.getException();
-		if (cause != null) {
-			strm.print("Caused by: "); //$NON-NLS-1$
-			if (stackTrace || !(msg.equals(cause.getMessage()) || msg.equals(cause.toString())))
-				deeplyPrint(cause, strm, stackTrace, level);
-		}
-
-		if (status.isMultiStatus()) {
-			IStatus[] children = status.getChildren();
-			for (int i = 0; i < children.length; i++)
-				deeplyPrint(children[i], strm, stackTrace, level + 1);
-		}
-	}
-
-	private static void deeplyPrint(Throwable t, PrintStream strm, boolean stackTrace, int level) {
-		if (t instanceof CoreException)
-			deeplyPrint((CoreException) t, strm, stackTrace, level);
-		else {
-			appendLevelString(strm, level);
-			if (stackTrace)
-				t.printStackTrace(strm);
-			else {
-				strm.println(t.toString());
-				Throwable cause = t.getCause();
-				if (cause != null) {
-					strm.print("Caused by: "); //$NON-NLS-1$
-					deeplyPrint(cause, strm, stackTrace, level);
-				}
-			}
-		}
-	}
-
-	/**
-	 * Check if the given exception represents that a switch to the JRE HTTP Client 
-	 * is required. ECF sets the HTTP status code 477 to indicate this.
-	 * If the JRE HTTP client is required a JREHttpClientRequiredException is thrown.
-	 */
-	public static void checkJREHttpClientRequired(Throwable t) throws JREHttpClientRequiredException {
-		if (t instanceof IncomingFileTransferException) {
-			if (((IncomingFileTransferException) t).getErrorCode() == 477)
-				throw new JREHttpClientRequiredException();
-		} else if (t instanceof BrowseFileTransferException) {
-			if (((BrowseFileTransferException) t).getErrorCode() == 477)
-				throw new JREHttpClientRequiredException();
-		}
-
-	}
-
-	/**
-	 * Check if the given exception represents a permission failure (401 for HTTP),
-	 * and throw a AuthenticationFailedException if a permission failure was encountered.
-	 */
-	public static void checkPermissionDenied(Throwable t) throws AuthenticationFailedException {
-		// From Use of File Transfer
-		if (t instanceof IncomingFileTransferException) {
-			if (((IncomingFileTransferException) t).getErrorCode() == 401)
-				throw new AuthenticationFailedException();
-			IStatus status = ((IncomingFileTransferException) t).getStatus();
-			t = status == null ? t : status.getException();
-			// From Use of Browse
-		} else if (t instanceof BrowseFileTransferException) {
-			if (((BrowseFileTransferException) t).getErrorCode() == 401)
-				throw new AuthenticationFailedException();
-			IStatus status = ((BrowseFileTransferException) t).getStatus();
-			t = status == null ? t : status.getException();
-		}
-
-		if (t == null || !(t instanceof IOException))
-			return;
-
-		// TODO: is this needed (for 401) now that ECF throws exceptions with codes?
-		// try to figure out if we have a 401 by parsing the exception message
-		// There is unfortunately no specific (general) exception for "redirected too many times" - which is commonly
-		// caused by a failed login. The message and exception are different in different implementations
-		// of http client.
-		String m = t.getMessage();
-		if (m != null && (m.indexOf(" 401 ") != -1 || m.indexOf(SERVER_REDIRECT) != -1)) //$NON-NLS-1$
-			throw new AuthenticationFailedException();
-		if ("org.apache.commons.httpclient.RedirectException".equals(t.getClass().getName())) //$NON-NLS-1$
-			throw new AuthenticationFailedException();
-	}
-
-	/**
-	 * Translates exceptions representing "FileNotFound" into FileNotFoundException.
-	 * @param t the throwable to check
-	 * @param toDownload the URI the exception was thrown for
-	 * @throws FileNotFoundException if 't' represents a file not found
-	 */
-	public static void checkFileNotFound(Throwable t, URI toDownload) throws FileNotFoundException {
-		if (t instanceof IncomingFileTransferException) {
-			IncomingFileTransferException e = (IncomingFileTransferException) t;
-			if (e.getErrorCode() == 404 || e.getErrorCode() == 403 || e.getErrorCode() == 300)
-				throw new FileNotFoundException(toDownload.toString());
-		}
-		if (t instanceof BrowseFileTransferException) {
-			BrowseFileTransferException e = (BrowseFileTransferException) t;
-			if (e.getErrorCode() == 404 || e.getErrorCode() == 403 || e.getErrorCode() == 300)
-				throw new FileNotFoundException(toDownload.toString());
-		}
-
-		if (t instanceof FileNotFoundException)
-			throw (FileNotFoundException) t;
-		if (t instanceof CoreException) {
-			IStatus status = ((CoreException) t).getStatus();
-			Throwable e = status == null ? null : status.getException();
-			if (e instanceof FileNotFoundException)
-				throw (FileNotFoundException) e;
-		}
-	}
-
-	/**
-	 * Get default "InternalError" ProvisionException.
-	 * @param t
-	 * @return a default "InternalError"
-	 */
-	public static ProvisionException internalError(Throwable t) {
-		return new ProvisionException(new Status(IStatus.ERROR, Activator.ID, //
-				ProvisionException.INTERNAL_ERROR, Messages.repoMan_internalError, t));
-	}
-
-	public static IStatus malformedAddressStatus(String address, Throwable t) {
-		return new Status(IStatus.ERROR, Activator.ID, //
-				ProvisionException.REPOSITORY_INVALID_LOCATION, NLS.bind(Messages.exception_malformedRepoURI, address), t);
-
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryTransport.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryTransport.java
deleted file mode 100644
index f965d83..0000000
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/RepositoryTransport.java
+++ /dev/null
@@ -1,250 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2006, 2010, IBM Corporation and other.
- * The code, documentation and other materials contained herein have been
- * licensed under the Eclipse Public License - v 1.0 by the copyright holder
- * listed above, as the Initial Contributor under such license. The text of
- * such license is available at www.eclipse.org.
- * 
- * Contributors
- * 	IBM Corporation - Initial API and implementation.
- *  Cloudsmith Inc - Implementation
- ******************************************************************************/
-
-package org.eclipse.equinox.internal.p2.repository;
-
-import java.io.*;
-import java.net.URI;
-import org.eclipse.core.runtime.*;
-import org.eclipse.ecf.core.security.ConnectContextFactory;
-import org.eclipse.ecf.core.security.IConnectContext;
-import org.eclipse.ecf.filetransfer.UserCancelledException;
-import org.eclipse.equinox.internal.p2.repository.Credentials.LoginCanceledException;
-import org.eclipse.equinox.internal.provisional.p2.repository.IStateful;
-import org.eclipse.equinox.p2.core.ProvisionException;
-import org.eclipse.equinox.p2.core.UIServices.AuthenticationInfo;
-import org.eclipse.osgi.util.NLS;
-
-/**
- * RepositoryTransport adapts p2 to ECF file download and file browsing.
- * Download is performed by {@link FileReader}, and file browsing is performed by
- * {@link FileInfoReader}.
- */
-public class RepositoryTransport extends Transport {
-	private static RepositoryTransport instance;
-
-	/**
-	 * Returns an shared instance of Generic Transport
-	 */
-	public static synchronized RepositoryTransport getInstance() {
-		if (instance == null) {
-			instance = new RepositoryTransport();
-		}
-		return instance;
-	}
-
-	/**
-	 * Perform a download, writing into the target output stream. Progress is reported on the
-	 * monitor. If the <code>target</code> is an instance of {@link IStateful} the resulting status
-	 * is also set on the target. An IStateful target is updated with status even if this methods
-	 * throws {@link OperationCanceledException}.
-	 * 
-	 * @returns IStatus, that is a {@link DownloadStatus} on success.
-	 * @param toDownload URI of file to download
-	 * @param target OutputStream where result is written
-	 * @param startPos the starting position of the download, or -1 for from start
-	 * @param monitor where progress should be reported
-	 * @throws OperationCanceledException if the operation was canceled.
-	 */
-	public IStatus download(URI toDownload, OutputStream target, long startPos, IProgressMonitor monitor) {
-
-		boolean promptUser = false;
-		boolean useJREHttp = false;
-		AuthenticationInfo loginDetails = null;
-		for (int i = RepositoryPreferences.getLoginRetryCount(); i > 0; i--) {
-			FileReader reader = null;
-			try {
-				loginDetails = Credentials.forLocation(toDownload, promptUser, loginDetails);
-				IConnectContext context = (loginDetails == null) ? null : ConnectContextFactory.createUsernamePasswordConnectContext(loginDetails.getUserName(), loginDetails.getPassword());
-
-				// perform the download
-				reader = new FileReader(context);
-				reader.readInto(toDownload, target, startPos, monitor);
-
-				// check that job ended ok - throw exceptions otherwise
-				IStatus result = reader.getResult();
-				if (result == null) {
-					String msg = NLS.bind(Messages.RepositoryTransport_failedReadRepo, toDownload);
-					DownloadStatus ds = new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_READ, msg, null);
-					return statusOn(target, ds, reader);
-				}
-				if (result.getSeverity() == IStatus.CANCEL)
-					throw new UserCancelledException();
-				if (!result.isOK())
-					throw new CoreException(result);
-
-				// Download status is expected on success
-				DownloadStatus status = new DownloadStatus(IStatus.OK, Activator.ID, Status.OK_STATUS.getMessage());
-				return statusOn(target, status, reader);
-			} catch (UserCancelledException e) {
-				statusOn(target, new DownloadStatus(IStatus.CANCEL, Activator.ID, 1, "", null), reader); //$NON-NLS-1$
-				throw new OperationCanceledException();
-			} catch (OperationCanceledException e) {
-				statusOn(target, new DownloadStatus(IStatus.CANCEL, Activator.ID, 1, "", null), reader); //$NON-NLS-1$
-				throw e;
-			} catch (CoreException e) {
-				if (e.getStatus().getException() == null)
-					return statusOn(target, RepositoryStatus.forException(e, toDownload), reader);
-				return statusOn(target, RepositoryStatus.forStatus(e.getStatus(), toDownload), reader);
-			} catch (FileNotFoundException e) {
-				return statusOn(target, RepositoryStatus.forException(e, toDownload), reader);
-			} catch (AuthenticationFailedException e) {
-				promptUser = true;
-			} catch (Credentials.LoginCanceledException e) {
-				DownloadStatus status = new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_AUTHENTICATION, //
-						NLS.bind(Messages.UnableToRead_0_UserCanceled, toDownload), null);
-				return statusOn(target, status, null);
-			} catch (JREHttpClientRequiredException e) {
-				if (!useJREHttp) {
-					useJREHttp = true; // only do this once
-					i++; // need an extra retry
-					Activator.getDefault().useJREHttpClient();
-				}
-			}
-		}
-		// reached maximum number of retries without success
-		DownloadStatus status = new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_AUTHENTICATION, //
-				NLS.bind(Messages.UnableToRead_0_TooManyAttempts, toDownload), null);
-		return statusOn(target, status, null);
-	}
-
-	/**
-	 * Perform a download, writing into the target output stream. Progress is reported on the
-	 * monitor. If the <code>target</code> is an instance of {@link IStateful} the resulting status
-	 * is also set on the target.
-	 * 
-	 * @returns IStatus, that is a {@link DownloadStatus} on success.
-	 * @param toDownload URI of file to download
-	 * @param target OutputStream where result is written
-	 * @param monitor where progress should be reported
-	 * @throws OperationCanceledException if the operation was canceled.
-	 */
-	public IStatus download(URI toDownload, OutputStream target, IProgressMonitor monitor) {
-		return download(toDownload, target, -1, monitor);
-	}
-
-	/**
-	 * Perform a stream download, writing into an InputStream that is returned. Performs authentication if needed.
-	 * 
-	 * @returns InputStream a stream with the content from the toDownload URI, or null
-	 * @param toDownload URI of file to download
-	 * @param monitor monitor checked for cancellation
-	 * @throws OperationCanceledException if the operation was canceled.
-	 * @throws AuthenticationFailedException if authentication failed, or too many attempt were made
-	 * @throws FileNotFoundException if the toDownload was reported as non existing
-	 * @throws CoreException on errors
-	 */
-	public InputStream stream(URI toDownload, IProgressMonitor monitor) throws FileNotFoundException, CoreException, AuthenticationFailedException {
-
-		boolean promptUser = false;
-		boolean useJREHttp = false;
-		AuthenticationInfo loginDetails = null;
-		for (int i = RepositoryPreferences.getLoginRetryCount(); i > 0; i--) {
-			FileReader reader = null;
-			try {
-				loginDetails = Credentials.forLocation(toDownload, promptUser, loginDetails);
-				IConnectContext context = (loginDetails == null) ? null : ConnectContextFactory.createUsernamePasswordConnectContext(loginDetails.getUserName(), loginDetails.getPassword());
-
-				// perform the streamed download
-				reader = new FileReader(context);
-				return reader.read(toDownload, monitor);
-			} catch (UserCancelledException e) {
-				throw new OperationCanceledException();
-			} catch (AuthenticationFailedException e) {
-				promptUser = true;
-			} catch (CoreException e) {
-				// must translate this core exception as it is most likely not informative to a user
-				if (e.getStatus().getException() == null)
-					throw new CoreException(RepositoryStatus.forException(e, toDownload));
-				throw new CoreException(RepositoryStatus.forStatus(e.getStatus(), toDownload));
-			} catch (LoginCanceledException e) {
-				// i.e. same behavior when user cancels as when failing n attempts.
-				throw new AuthenticationFailedException();
-			} catch (JREHttpClientRequiredException e) {
-				if (!useJREHttp) {
-					useJREHttp = true; // only do this once
-					i++; // need an extra retry
-					Activator.getDefault().useJREHttpClient();
-				}
-			}
-		}
-		throw new AuthenticationFailedException();
-	}
-
-	/**
-	 * Set the status on the output stream if it implements IStateful. 
-	 * Update the DownloadStatus with information from FileReader.
-	 * @param target an OutputStream possibly implementing IStateful
-	 * @param status a DownloadStatus configured with status message, code, etc
-	 * @param reader a FileReade that was used to download (or null if not known).
-	 * @throws OperationCanceledException if the operation was canceled by the user.
-	 * @return the configured DownloadStatus status.
-	 */
-	private static DownloadStatus statusOn(OutputStream target, DownloadStatus status, FileReader reader) {
-		if (reader != null) {
-			FileInfo fi = reader.getLastFileInfo();
-			if (fi != null) {
-				status.setFileSize(fi.getSize());
-				status.setLastModified(fi.getLastModified());
-				status.setTransferRate(fi.getAverageSpeed());
-			}
-		}
-		if (target instanceof IStateful)
-			((IStateful) target).setStatus(status);
-		return status;
-	}
-
-	/**
-	 * Returns the last modified date for a URI. A last modified of 0 typically indicates that
-	 * the server response is wrong, but should not be interpreted as a file not found.
-	 * @param toDownload
-	 * @param monitor
-	 * @throws OperationCanceledException if the operation was canceled by the user.
-	 * @return last modified date (possibly 0)
-	 */
-	public long getLastModified(URI toDownload, IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException {
-		boolean promptUser = false;
-		boolean useJREHttp = false;
-		AuthenticationInfo loginDetails = null;
-		for (int i = RepositoryPreferences.getLoginRetryCount(); i > 0; i--) {
-			try {
-				loginDetails = Credentials.forLocation(toDownload, promptUser, loginDetails);
-				IConnectContext context = (loginDetails == null) ? null : ConnectContextFactory.createUsernamePasswordConnectContext(loginDetails.getUserName(), loginDetails.getPassword());
-				// get the remote info
-				FileInfoReader reader = new FileInfoReader(context);
-				return reader.getLastModified(toDownload, monitor);
-			} catch (UserCancelledException e) {
-				throw new OperationCanceledException();
-			} catch (CoreException e) {
-				// must translate this core exception as it is most likely not informative to a user
-				if (e.getStatus().getException() == null)
-					throw new CoreException(RepositoryStatus.forException(e, toDownload));
-				throw new CoreException(RepositoryStatus.forStatus(e.getStatus(), toDownload));
-			} catch (AuthenticationFailedException e) {
-				promptUser = true;
-			} catch (LoginCanceledException e) {
-				// same behavior as if user failed n attempts.
-				throw new AuthenticationFailedException();
-			} catch (JREHttpClientRequiredException e) {
-				if (!useJREHttp) {
-					useJREHttp = true; // only do this once
-					i++; // need an extra retry
-					Activator.getDefault().useJREHttpClient();
-				}
-			}
-
-		}
-		// reached maximum number of authentication retries without success
-		throw new AuthenticationFailedException();
-	}
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Transport.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Transport.java
index 6eba11a..e57216c 100644
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Transport.java
+++ b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/Transport.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- *  Copyright (c) 2007, 2009 IBM Corporation and others.
+ *  Copyright (c) 2007, 2010 IBM Corporation and others.
  *  All rights reserved. This program and the accompanying materials
  *  are made available under the terms of the Eclipse Public License v1.0
  *  which accompanies this distribution, and is available at
@@ -7,21 +7,68 @@
  * 
  *  Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Sonatype, Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.repository;
 
-import java.io.OutputStream;
+import java.io.*;
 import java.net.URI;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.provisional.p2.repository.IStateful;
 
 public abstract class Transport {
 
+	public static final String SERVICE_NAME = Transport.class.getName();
+
+	/**
+	 * Perform a download, writing into the target output stream. Progress is reported on the
+	 * monitor. If the <code>target</code> is an instance of {@link IStateful} the resulting status
+	 * is also set on the target. An IStateful target is updated with status even if this methods
+	 * throws {@link OperationCanceledException}.
+	 * 
+	 * @returns IStatus, that is a {@link DownloadStatus} on success.
+	 * @param toDownload URI of file to download
+	 * @param target OutputStream where result is written
+	 * @param startPos the starting position of the download, or -1 for from start
+	 * @param monitor where progress should be reported
+	 * @throws OperationCanceledException if the operation was canceled.
+	 */
+	public abstract IStatus download(URI toDownload, OutputStream target, long startPos, IProgressMonitor monitor);
+
 	/**
+	 * Perform a download, writing into the target output stream. Progress is reported on the
+	 * monitor. If the <code>target</code> is an instance of {@link IStateful} the resulting status
+	 * is also set on the target.
+	 * 
+	 * @returns IStatus, that is a {@link DownloadStatus} on success.
+	 * @param toDownload URI of file to download
+	 * @param target OutputStream where result is written
+	 * @param monitor where progress should be reported
+	 * @throws OperationCanceledException if the operation was canceled.
+	 */
+	public abstract IStatus download(URI toDownload, OutputStream target, IProgressMonitor monitor);
+
+	/**
+	 * Perform a stream download, writing into an InputStream that is returned. Performs authentication if needed.
+	 * 
+	 * @returns InputStream a stream with the content from the toDownload URI, or null
+	 * @param toDownload URI of file to download
+	 * @param monitor monitor checked for cancellation
+	 * @throws OperationCanceledException if the operation was canceled.
+	 * @throws AuthenticationFailedException if authentication failed, or too many attempt were made
+	 * @throws FileNotFoundException if the toDownload was reported as non existing
+	 * @throws CoreException on errors
+	 */
+	public abstract InputStream stream(URI toDownload, IProgressMonitor monitor) throws FileNotFoundException, CoreException, AuthenticationFailedException;
+
+	/**
+	 * Returns the last modified date for a URI. A last modified of 0 typically indicates that
+	 * the server response is wrong, but should not be interpreted as a file not found.
 	 * @param toDownload
-	 * @param target
-	 * @param pm
-	 * @return IStatus describing outcome of the download
+	 * @param monitor
+	 * @throws OperationCanceledException if the operation was canceled by the user.
+	 * @return last modified date (possibly 0)
 	 */
-	public abstract IStatus download(URI toDownload, OutputStream target, IProgressMonitor pm);
+	public abstract long getLastModified(URI toDownload, IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException;
+
 }
diff --git a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/helpers/AbstractRepositoryManager.java b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/helpers/AbstractRepositoryManager.java
index 9e7d3e4..b8b17e0 100644
--- a/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/helpers/AbstractRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.repository/src/org/eclipse/equinox/internal/p2/repository/helpers/AbstractRepositoryManager.java
@@ -8,6 +8,7 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Wind River - fix for bug 299227
+ *     Sonatype, Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.repository.helpers;
 
@@ -18,7 +19,8 @@ import java.util.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.core.runtime.preferences.IPreferencesService;
 import org.eclipse.equinox.internal.p2.core.helpers.*;
-import org.eclipse.equinox.internal.p2.repository.*;
+import org.eclipse.equinox.internal.p2.repository.Activator;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
 import org.eclipse.equinox.internal.provisional.p2.core.eventbus.ProvisioningListener;
 import org.eclipse.equinox.internal.provisional.p2.repository.RepositoryEvent;
@@ -1165,8 +1167,8 @@ public abstract class AbstractRepositoryManager<T> implements IRepositoryManager
 		return new URI(spec);
 	}
 
-	private Transport getTransport() {
-		return RepositoryTransport.getInstance();
+	protected Transport getTransport() {
+		return (Transport) agent.getService(Transport.SERVICE_NAME);
 	}
 
 	public void flushCache() {
diff --git a/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
index d138dfd..4068428 100644
--- a/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.tests/META-INF/MANIFEST.MF
@@ -51,7 +51,8 @@ Require-Bundle: org.eclipse.equinox.p2.metadata.generator,
  org.eclipse.ecf.provider.filetransfer.httpclient;bundle-version="4.0.0",
  org.eclipse.equinox.p2.reconciler.dropins;bundle-version="1.1.0",
  org.eclipse.ant.core;bundle-version="3.2.200",
- org.apache.ant;bundle-version="1.7.1"
+ org.apache.ant;bundle-version="1.7.1",
+ org.eclipse.equinox.p2.transport.ecf;bundle-version="1.0.0"
 Eclipse-RegisterBuddy: org.eclipse.equinox.p2.artifact.repository
 Bundle-RequiredExecutionEnvironment: J2SE-1.5,
  J2SE-1.4
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
index deccc2b..74f4c09 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
@@ -23,6 +23,7 @@ import org.eclipse.equinox.internal.p2.engine.SimpleProfileRegistry;
 import org.eclipse.equinox.internal.p2.metadata.IRequiredCapability;
 import org.eclipse.equinox.internal.p2.metadata.InstallableUnit;
 import org.eclipse.equinox.internal.p2.metadata.repository.MetadataRepositoryManager;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
 import org.eclipse.equinox.internal.provisional.p2.director.IDirector;
 import org.eclipse.equinox.p2.core.*;
@@ -856,6 +857,10 @@ public abstract class AbstractProvisioningTest extends TestCase {
 		return (IProfileRegistry) getAgent().getService(IProfileRegistry.SERVICE_NAME);
 	}
 
+	protected Transport getTransport() {
+		return (Transport) getAgent().getService(Transport.SERVICE_NAME);
+	}
+
 	protected IMetadataRepository createMetadataRepository(URI location, Map properties) throws ProvisionException {
 		IMetadataRepositoryManager metadataRepositoryManager = getMetadataRepositoryManager();
 		IMetadataRepository repo = metadataRepositoryManager.createRepository(location, "metadata", IMetadataRepositoryManager.TYPE_SIMPLE_REPOSITORY, properties);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/TestArtifactRepository.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/TestArtifactRepository.java
index 0d2cd95..f00cd1e 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/TestArtifactRepository.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/TestArtifactRepository.java
@@ -18,6 +18,7 @@ import java.util.*;
 import junit.framework.Assert;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.artifact.repository.ArtifactRequest;
+import org.eclipse.equinox.internal.p2.repository.AuthenticationFailedException;
 import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.internal.p2.repository.helpers.AbstractRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.processing.ProcessingStepHandler;
@@ -69,6 +70,21 @@ public class TestArtifactRepository extends AbstractArtifactRepository {
 			}
 			return Status.OK_STATUS;
 		}
+
+		@Override
+		public IStatus download(URI toDownload, OutputStream target, long startPos, IProgressMonitor monitor) {
+			throw new IllegalStateException("Method should not be called");
+		}
+
+		@Override
+		public InputStream stream(URI toDownload, IProgressMonitor monitor) throws FileNotFoundException, CoreException, AuthenticationFailedException {
+			throw new IllegalStateException("Method should not be called");
+		}
+
+		@Override
+		public long getLastModified(URI toDownload, IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException {
+			throw new IllegalStateException("Method should not be called");
+		}
 	};
 
 	public TestArtifactRepository(IProvisioningAgent agent, URI location) {
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/Bug252308.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/Bug252308.java
index dbafd27..4158ed7 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/Bug252308.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/Bug252308.java
@@ -127,7 +127,7 @@ public class Bug252308 extends AbstractProvisioningTest {
 		targetDescriptor.setRepositoryProperty("artifact.folder", "true");
 		class TestRequest extends MirrorRequest {
 			public TestRequest(IArtifactKey key, IArtifactRepository targetRepository, Map<String, String> targetDescriptorProperties, Map<String, String> targetRepositoryProperties) {
-				super(key, targetRepository, targetDescriptorProperties, targetRepositoryProperties);
+				super(key, targetRepository, targetDescriptorProperties, targetRepositoryProperties, getTransport());
 			}
 
 			public void setSource(IArtifactRepository source) {
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CompositeArtifactRepositoryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CompositeArtifactRepositoryTest.java
index dd143b2..30018d2 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CompositeArtifactRepositoryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CompositeArtifactRepositoryTest.java
@@ -21,6 +21,7 @@ import org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifact
 import org.eclipse.equinox.internal.p2.core.helpers.OrderedProperties;
 import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
 import org.eclipse.equinox.internal.p2.persistence.CompositeRepositoryState;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.internal.repository.comparator.MD5ArtifactComparator;
 import org.eclipse.equinox.p2.internal.repository.tools.ArtifactRepositoryValidator;
@@ -1028,7 +1029,7 @@ public class CompositeArtifactRepositoryTest extends AbstractProvisioningTest {
 			source.addChild(child.getLocation());
 
 			// Create mirror request
-			MirrorRequest request = new MirrorRequest(descriptor.getArtifactKey(), destination, null, null);
+			MirrorRequest request = new MirrorRequest(descriptor.getArtifactKey(), destination, null, null, (Transport) getAgent().getService(Transport.SERVICE_NAME));
 			request.perform(source, new NullProgressMonitor());
 			IStatus status = request.getResult();
 			// The download should have completed 'successfully'
@@ -1115,7 +1116,7 @@ public class CompositeArtifactRepositoryTest extends AbstractProvisioningTest {
 			dest = new BadSite(new URI("memory:/in/memory/dest"));
 
 			// Create mirror request
-			MirrorRequest request = new MirrorRequest(descriptor.getArtifactKey(), dest, null, null);
+			MirrorRequest request = new MirrorRequest(descriptor.getArtifactKey(), dest, null, null, getTransport());
 			request.perform(source, new NullProgressMonitor());
 			IStatus status = request.getResult();
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CorruptedJar.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CorruptedJar.java
index f026990..35fb85a 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CorruptedJar.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CorruptedJar.java
@@ -47,7 +47,7 @@ public class CorruptedJar extends AbstractProvisioningTest {
 		ctx.setArtifactRepositories(new URI[] {getTestData("CorruptedJar repo", testDataLocation).toURI()});
 		DownloadManager mgr = new DownloadManager(ctx, getAgent());
 		IArtifactKey key = (IArtifactKey) source.query(ArtifactKeyQuery.ALL_KEYS, null).iterator().next();
-		mgr.add(new MirrorRequest(key, target, null, null));
+		mgr.add(new MirrorRequest(key, target, null, null, getTransport()));
 		IStatus s = mgr.start(new NullProgressMonitor());
 		assertNotOK(s);
 	}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/LocationTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/LocationTest.java
index bf42d42..0fd31ed 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/LocationTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/LocationTest.java
@@ -39,7 +39,7 @@ public class LocationTest extends AbstractProvisioningTest {
 	public void testLocation() throws Exception {
 		IArtifactKey key = new ArtifactKey("osgi.bundle", "org.springframework.ide.eclipse", Version.parseVersion("2.3.2.201003220227-RELEASE"));
 		assertTrue(sourceRepository.contains(key));
-		MirrorRequest req = new MirrorRequest(key, targetRepository, null, null);
+		MirrorRequest req = new MirrorRequest(key, targetRepository, null, null, getTransport());
 		req.perform(sourceRepository, new NullProgressMonitor());
 		IStatus status = req.getResult();
 		assertTrue(status.getMessage(), status.isOK());
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/MirrorRequestTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/MirrorRequestTest.java
index 2f45216..f26ad6c 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/MirrorRequestTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/MirrorRequestTest.java
@@ -22,6 +22,7 @@ import org.eclipse.equinox.internal.p2.artifact.repository.MirrorRequest;
 import org.eclipse.equinox.internal.p2.artifact.repository.MirrorSelector;
 import org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository;
 import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.metadata.IArtifactKey;
 import org.eclipse.equinox.p2.metadata.Version;
@@ -68,7 +69,7 @@ public class MirrorRequestTest extends AbstractProvisioningTest {
 		IArtifactKey key = new ArtifactKey("org.eclipse.update.feature", "HelloWorldFeature", Version.createOSGi(1, 0, 0));
 		Map<String, String> targetProperties = new HashMap<String, String>();
 		targetProperties.put("artifact.folder", "true");
-		MirrorRequest request = new MirrorRequest(key, targetRepository, null, targetProperties);
+		MirrorRequest request = new MirrorRequest(key, targetRepository, null, targetProperties, (Transport) getAgent().getService(Transport.SERVICE_NAME));
 		request.perform(sourceRepository, new NullProgressMonitor());
 
 		assertTrue(request.getResult().matches(IStatus.ERROR));
@@ -79,7 +80,7 @@ public class MirrorRequestTest extends AbstractProvisioningTest {
 		IArtifactKey key = new ArtifactKey("org.eclipse.update.feature", "Missing", Version.createOSGi(1, 0, 0));
 		Map<String, String> targetProperties = new HashMap<String, String>();
 		targetProperties.put("artifact.folder", "true");
-		MirrorRequest request = new MirrorRequest(key, targetRepository, null, targetProperties);
+		MirrorRequest request = new MirrorRequest(key, targetRepository, null, targetProperties, getTransport());
 		request.perform(sourceRepository, new NullProgressMonitor());
 
 		assertTrue(request.getResult().matches(IStatus.ERROR));
@@ -90,7 +91,7 @@ public class MirrorRequestTest extends AbstractProvisioningTest {
 		RemoteRepo src = new RemoteRepo((SimpleArtifactRepository) sourceRepository);
 
 		IArtifactKey key = new ArtifactKey("test.txt", "fail_to_canonical", Version.parseVersion("1.0.0"));
-		MirrorRequest request = new MirrorRequest(key, targetRepository, null, null);
+		MirrorRequest request = new MirrorRequest(key, targetRepository, null, null, getTransport());
 		request.perform(src, new NullProgressMonitor());
 
 		assertTrue(request.getResult().toString(), request.getResult().isOK());
@@ -104,7 +105,7 @@ public class MirrorRequestTest extends AbstractProvisioningTest {
 
 		// call test
 		IArtifactKey key = new ArtifactKey("test.txt", "HelloWorldText", Version.parseVersion("1.0.0"));
-		MirrorRequest request = new MirrorRequest(key, targetRepository, null, null);
+		MirrorRequest request = new MirrorRequest(key, targetRepository, null, null, getTransport());
 		request.perform(sourceRepository, new NullProgressMonitor());
 
 		// The download succeeded
@@ -132,7 +133,7 @@ public class MirrorRequestTest extends AbstractProvisioningTest {
 		assertTrue("Unable to obtain artifact keys", keys != null && !keys.isEmpty());
 
 		IArtifactKey key = (IArtifactKey) keys.iterator().next();
-		MirrorRequest req = new MirrorRequest(key, targetRepository, null, null);
+		MirrorRequest req = new MirrorRequest(key, targetRepository, null, null, getTransport());
 
 		// Set Status sequence 
 		seq.add(new Status(IStatus.ERROR, "Activator", "Message"));
@@ -144,7 +145,7 @@ public class MirrorRequestTest extends AbstractProvisioningTest {
 		// Remove key from repo so the same one can be used
 		targetRepository.removeDescriptor(key);
 		// Set Status sequence 
-		req = new MirrorRequest(key, targetRepository, null, null);
+		req = new MirrorRequest(key, targetRepository, null, null, getTransport());
 
 		seq.add(new Status(IStatus.WARNING, "Activator", "Message"));
 		seq.add(new Status(IStatus.INFO, "Activator", "Message"));
@@ -155,7 +156,7 @@ public class MirrorRequestTest extends AbstractProvisioningTest {
 		// Remove key from repo so the same one can be used
 		targetRepository.removeDescriptor(key);
 		// Set Status sequence 
-		req = new MirrorRequest(key, targetRepository, null, null);
+		req = new MirrorRequest(key, targetRepository, null, null, getTransport());
 
 		seq.add(new Status(IStatus.INFO, "Activator", "Message"));
 		req.perform(source, new NullProgressMonitor());
@@ -182,7 +183,7 @@ public class MirrorRequestTest extends AbstractProvisioningTest {
 			IArtifactRepository target = getArtifactRepositoryManager().createRepository(destination, "Destination", IArtifactRepositoryManager.TYPE_SIMPLE_REPOSITORY, null);
 
 			IArtifactKey key = new ArtifactKey("osgi.bundle", "org.eclipse.ve.jfc", Version.parseVersion("1.4.0.HEAD"));
-			MirrorRequest req = new MirrorRequest(key, target, null, null);
+			MirrorRequest req = new MirrorRequest(key, target, null, null, getTransport());
 
 			req.perform(source, new NullProgressMonitor());
 			IStatus result = req.getResult();
@@ -314,7 +315,7 @@ public class MirrorRequestTest extends AbstractProvisioningTest {
 		IArtifactRepository repo;
 
 		OrderedMirrorSelector(IArtifactRepository repo) {
-			super(repo);
+			super(repo, getTransport());
 			this.repo = repo;
 			// Setting this property forces SimpleArtifactRepository to use mirrors despite being a local repo
 			// Alternatively we could use reflect to change "location" of the repo
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/TransferExceptionsTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/TransferExceptionsTest.java
index 777a3a5..270dda1 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/TransferExceptionsTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/TransferExceptionsTest.java
@@ -14,7 +14,6 @@ import java.io.*;
 import java.net.URI;
 import java.net.URISyntaxException;
 import org.eclipse.core.runtime.*;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
 import org.osgi.framework.BundleException;
 
@@ -37,25 +36,25 @@ public class TransferExceptionsTest extends AbstractProvisioningTest {
 			fail("1.5", e);
 		}
 		try {
-			IStatus s = RepositoryTransport.getInstance().download(new URI("bogus!bogus"), fos, new NullProgressMonitor());
+			IStatus s = getTransport().download(new URI("bogus!bogus"), fos, new NullProgressMonitor());
 			assertNotOK(s);
 			printStatus("1", s);
-			s = RepositoryTransport.getInstance().download(new URI("bogus://somewhere.else"), fos, new NullProgressMonitor());
+			s = getTransport().download(new URI("bogus://somewhere.else"), fos, new NullProgressMonitor());
 			assertNotOK(s);
 			printStatus("2", s);
-			s = RepositoryTransport.getInstance().download(new URI("http:bogusURL"), fos, new NullProgressMonitor());
+			s = getTransport().download(new URI("http:bogusURL"), fos, new NullProgressMonitor());
 			assertNotOK(s);
 			printStatus("3", s);
-			s = RepositoryTransport.getInstance().download(new URI("http://bogusURL:80/"), fos, new NullProgressMonitor());
+			s = getTransport().download(new URI("http://bogusURL:80/"), fos, new NullProgressMonitor());
 			assertNotOK(s);
 			printStatus("4", s);
-			s = RepositoryTransport.getInstance().download(new URI("http:/bogusURL:999999999999/"), fos, new NullProgressMonitor());
+			s = getTransport().download(new URI("http:/bogusURL:999999999999/"), fos, new NullProgressMonitor());
 			assertNotOK(s);
 			printStatus("5", s);
-			s = RepositoryTransport.getInstance().download(new URI("http://bogus.nowhere"), fos, new NullProgressMonitor());
+			s = getTransport().download(new URI("http://bogus.nowhere"), fos, new NullProgressMonitor());
 			assertNotOK(s);
 			printStatus("6", s);
-			s = RepositoryTransport.getInstance().download(new URI("http://www.eclipse.org/AFileThatDoesNotExist.foo"), fos, new NullProgressMonitor());
+			s = getTransport().download(new URI("http://www.eclipse.org/AFileThatDoesNotExist.foo"), fos, new NullProgressMonitor());
 			assertNotOK(s);
 			printStatus("7", s);
 		} catch (URISyntaxException e) {
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/TransferTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/TransferTest.java
index 6c3983a..4b62c8a 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/TransferTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/TransferTest.java
@@ -13,7 +13,6 @@ package org.eclipse.equinox.p2.tests.artifact.repository;
 import java.io.*;
 import java.net.*;
 import org.eclipse.core.runtime.*;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleException;
@@ -33,7 +32,7 @@ public class TransferTest extends AbstractProvisioningTest {
 			fail("1.5", e);
 		}
 		final URI toDownload = new URI("http://download.eclipse.org/eclipse/updates/3.4/plugins/javax.servlet.jsp_2.0.0.v200806031607.jar.pack.gz");
-		IStatus s = RepositoryTransport.getInstance().download(toDownload, fos, new NullProgressMonitor());
+		IStatus s = getTransport().download(toDownload, fos, new NullProgressMonitor());
 		assertOK("2.0", s);
 		int httpSize = -1;
 		URL u;
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/ResumeDownloadTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/ResumeDownloadTest.java
index e0b8d9b..fed8ccc 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/ResumeDownloadTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/ResumeDownloadTest.java
@@ -13,7 +13,7 @@ import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.OperationCanceledException;
 import org.eclipse.ecf.filetransfer.IFileRangeSpecification;
 import org.eclipse.ecf.filetransfer.IIncomingFileTransfer;
-import org.eclipse.equinox.internal.p2.repository.FileReader;
+import org.eclipse.equinox.internal.p2.transport.ecf.FileReader;
 import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.repository.metadata.IMetadataRepositoryManager;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/FileInfoReaderTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/FileInfoReaderTest.java
index cbaeb7f..c755b5d 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/FileInfoReaderTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/FileInfoReaderTest.java
@@ -15,7 +15,7 @@ import java.net.ConnectException;
 import java.net.URI;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.repository.AuthenticationFailedException;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
+import org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport;
 import org.eclipse.equinox.p2.tests.testserver.helper.AbstractTestServerClientCase;
 
 /**
@@ -24,7 +24,7 @@ import org.eclipse.equinox.p2.tests.testserver.helper.AbstractTestServerClientCa
 public class FileInfoReaderTest extends AbstractTestServerClientCase {
 
 	public void testUnknownHost() throws Exception {
-		RepositoryTransport transport = RepositoryTransport.getInstance();
+		RepositoryTransport transport = new RepositoryTransport();
 		URI toDownload = new URI("http://bogus.nowhere/nothing.xml");
 		IStatus status = null;
 		try {
@@ -37,7 +37,7 @@ public class FileInfoReaderTest extends AbstractTestServerClientCase {
 	}
 
 	public void testBadPort() throws Exception {
-		RepositoryTransport transport = RepositoryTransport.getInstance();
+		RepositoryTransport transport = new RepositoryTransport();
 		URI toDownload = new URI("http://localhost:1/nothing.xml");
 		IStatus status = null;
 		try {
@@ -53,7 +53,7 @@ public class FileInfoReaderTest extends AbstractTestServerClientCase {
 
 	public void testRedirect() throws Exception {
 		this.setAladdinLoginService();
-		RepositoryTransport transport = RepositoryTransport.getInstance();
+		RepositoryTransport transport = new RepositoryTransport();
 		// apache http client accepts 100 redirects
 		URI toDownload = new URI(getBaseURL() + "/redirect/101/public/index.html");
 		boolean caught = false;
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/FileReaderTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/FileReaderTest.java
index b0d2080..d0fa836 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/FileReaderTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/FileReaderTest.java
@@ -14,7 +14,7 @@ package org.eclipse.equinox.p2.tests.repository;
 import java.io.*;
 import java.net.*;
 import org.eclipse.core.runtime.*;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
+import org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport;
 import org.eclipse.equinox.p2.tests.testserver.helper.AbstractTestServerClientCase;
 
 /**
@@ -23,7 +23,7 @@ import org.eclipse.equinox.p2.tests.testserver.helper.AbstractTestServerClientCa
 public class FileReaderTest extends AbstractTestServerClientCase {
 
 	public void testUnknownHost() throws URISyntaxException {
-		RepositoryTransport transport = RepositoryTransport.getInstance();
+		RepositoryTransport transport = new RepositoryTransport();
 		URI toDownload = new URI("http://bogus.nowhere/nothing.xml");
 		OutputStream target = new ByteArrayOutputStream();
 		IStatus status = transport.download(toDownload, target, new NullProgressMonitor());
@@ -33,7 +33,7 @@ public class FileReaderTest extends AbstractTestServerClientCase {
 	}
 
 	public void testBadPort() throws URISyntaxException {
-		RepositoryTransport transport = RepositoryTransport.getInstance();
+		RepositoryTransport transport = new RepositoryTransport();
 		URI toDownload = new URI("http://localhost:1/nothing.xml");
 		OutputStream target = new ByteArrayOutputStream();
 		IStatus status = transport.download(toDownload, target, new NullProgressMonitor());
@@ -47,7 +47,7 @@ public class FileReaderTest extends AbstractTestServerClientCase {
 	 * Tests a successful read.
 	 */
 	public void testReadStream() throws URISyntaxException, CoreException, IOException {
-		RepositoryTransport transport = RepositoryTransport.getInstance();
+		RepositoryTransport transport = new RepositoryTransport();
 		URI toDownload = new URI("http://localhost:8080/public/index.html");
 		final NullProgressMonitor monitor = new NullProgressMonitor();
 		InputStream stream = transport.stream(toDownload, monitor);
@@ -59,7 +59,7 @@ public class FileReaderTest extends AbstractTestServerClientCase {
 	 * Tests a successful read.
 	 */
 	public void testRead() throws URISyntaxException, CoreException, IOException {
-		RepositoryTransport transport = RepositoryTransport.getInstance();
+		RepositoryTransport transport = new RepositoryTransport();
 		URI toDownload = new URI("http://localhost:8080/public/index.html");
 		OutputStream target = new ByteArrayOutputStream();
 		final NullProgressMonitor monitor = new NullProgressMonitor();
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/TimeoutTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/TimeoutTest.java
index c583346..033303f 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/TimeoutTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/repository/TimeoutTest.java
@@ -12,7 +12,7 @@ import java.io.ByteArrayOutputStream;
 import java.net.URI;
 import java.security.cert.Certificate;
 import org.eclipse.core.runtime.*;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
+import org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport;
 import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.core.UIServices;
 import org.eclipse.equinox.p2.tests.metadata.repository.AllServerTests;
@@ -48,7 +48,7 @@ public class TimeoutTest extends AbstractTestServerClientCase {
 	public void doTimeout(int type) throws Exception {
 		System.out.print("Note that test takes at least 120 seconds before timing out\n");
 		AllServerTests.setServiceUI(new AladdinNotSavedService());
-		RepositoryTransport transport = RepositoryTransport.getInstance();
+		RepositoryTransport transport = new RepositoryTransport();
 		URI toDownload = new URI(getBaseURL() + "/timeout/whatever.txt");
 		long startTime = System.currentTimeMillis();
 		boolean caught = false;
@@ -136,7 +136,7 @@ public class TimeoutTest extends AbstractTestServerClientCase {
 		System.out.print("Note that test takes at least 10 seconds before timing out (and >120 if it fails)\n");
 
 		AllServerTests.setServiceUI(new AladdinNotSavedService());
-		RepositoryTransport transport = RepositoryTransport.getInstance();
+		RepositoryTransport transport = new RepositoryTransport();
 		URI toDownload = new URI(getBaseURL() + "/timeout/whatever.txt");
 
 		IProgressMonitor monitor = new NullProgressMonitor();
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/updatesite/UpdateSiteTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/updatesite/UpdateSiteTest.java
index 2f0fdc7..e489d22 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/updatesite/UpdateSiteTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/updatesite/UpdateSiteTest.java
@@ -64,7 +64,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/siteurl");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -82,7 +82,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File siteDirectory = getTestData("0.1", "/testData/updatesite/siteurl2/siteurl/");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 			updatesite.getSite().setLocationURIString(siteDirectory.toURI().toString());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
@@ -100,7 +100,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/digest");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -118,7 +118,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		URI siteURI = new URI("jar:" + site.toURI() + "!/");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(siteURI, getMonitor());
+			updatesite = UpdateSite.load(siteURI, getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -135,7 +135,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/digesturl");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -153,7 +153,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File digestDirectory = getTestData("0.1", "/testData/updatesite/digesturl2/digesturl/");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 			updatesite.getSite().setDigestURIString(digestDirectory.toURI().toString());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
@@ -175,7 +175,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/site");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -192,7 +192,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		UpdateSite updatesite = null;
 		try {
 			URI siteURL = base.toURI().resolve("site");
-			updatesite = UpdateSite.load(siteURL, getMonitor());
+			updatesite = UpdateSite.load(siteURL, getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -208,7 +208,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/site/site.xml");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -224,7 +224,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/site with spaces/");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -240,7 +240,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/xxxsitexxx/xxxsitexxx.xml");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -256,7 +256,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File siteDir = getTestData("0.1", "/testData/updatesite/xxxsitexxx");
 		File site = new File(siteDir, "site.xml");
 		try {
-			UpdateSite.load(site.toURI(), getMonitor());
+			UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 			fail("0.2");
 		} catch (ProvisionException e) {
 			// expected
@@ -267,7 +267,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/baddigestgoodsite");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -282,7 +282,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/corruptdigestgoodsite");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -302,7 +302,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 	public void testBadDigestBadSite() {
 		File site = getTestData("0.1", "/testData/updatesite/baddigestbadsite");
 		try {
-			UpdateSite.load(site.toURI(), getMonitor());
+			UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 			fail("0.2");
 		} catch (ProvisionException e) {
 			// expected
@@ -313,7 +313,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		// handle the case where the site.xml doesn't parse correctly
 		File site = getTestData("0.1", "/testData/updatesite/badSiteXML");
 		try {
-			UpdateSite.load(site.toURI(), getMonitor());
+			UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 			fail("0.2");
 		} catch (ProvisionException e) {
 			// expected exception
@@ -328,7 +328,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File temp = getTempFolder();
 		temp.mkdirs();
 		try {
-			UpdateSite.load(temp.toURI(), getMonitor());
+			UpdateSite.load(temp.toURI(), getTransport(), getMonitor());
 			fail("0.2");
 		} catch (ProvisionException e) {
 			// we expect an exception
@@ -337,7 +337,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 
 	public void testNullSite() {
 		try {
-			assertNull("1.0", UpdateSite.load(null, getMonitor()));
+			assertNull("1.0", UpdateSite.load(null, getTransport(), getMonitor()));
 		} catch (ProvisionException e) {
 			fail("1.99", e);
 		}
@@ -347,7 +347,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/badfeatureurl");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -370,7 +370,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/goodfeatureurl");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -388,7 +388,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		URI siteURI = new URI("jar:" + site.toURI() + "!/");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(siteURI, getMonitor());
+			updatesite = UpdateSite.load(siteURI, getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -405,7 +405,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/includedfeature");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -421,7 +421,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/includedfeaturearchive");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -437,7 +437,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/badincludedfeaturearchive");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -459,7 +459,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		File site = getTestData("0.1", "/testData/updatesite/nofeatureidandversion");
 		UpdateSite updatesite = null;
 		try {
-			updatesite = UpdateSite.load(site.toURI(), getMonitor());
+			updatesite = UpdateSite.load(site.toURI(), getTransport(), getMonitor());
 		} catch (ProvisionException e) {
 			fail("0.2", e);
 		}
@@ -827,7 +827,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 			if (descriptor == null)
 				fail("0.3");
 
-			RawMirrorRequest mirror = new RawMirrorRequest(descriptor, new ArtifactDescriptor(descriptor), targetRepository);
+			RawMirrorRequest mirror = new RawMirrorRequest(descriptor, new ArtifactDescriptor(descriptor), targetRepository, getTransport());
 			mirror.perform(sourceRepo, getMonitor());
 
 			assertTrue(mirror.getResult().isOK());
@@ -851,7 +851,7 @@ public class UpdateSiteTest extends AbstractProvisioningTest {
 		IArtifactRepository repo;
 
 		OrderedMirrorSelector(IArtifactRepository repo, String testDataLocation) throws Exception {
-			super(repo);
+			super(repo, getTransport());
 			this.repo = repo;
 			// Alternatively we could use reflect to change "location" of the repo
 			setRepoSelector();
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/.classpath b/bundles/org.eclipse.equinox.p2.transport.ecf/.classpath
new file mode 100644
index 0000000..ad32c83
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/.classpath
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/.project b/bundles/org.eclipse.equinox.p2.transport.ecf/.project
new file mode 100644
index 0000000..fb4698e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.eclipse.equinox.p2.transport.ecf</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ds.core.builder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/.settings/org.eclipse.jdt.core.prefs b/bundles/org.eclipse.equinox.p2.transport.ecf/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..3a159d8
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,8 @@
+#Fri Dec 24 16:24:53 EST 2010
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.6
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/.settings/org.eclipse.pde.core.prefs b/bundles/org.eclipse.equinox.p2.transport.ecf/.settings/org.eclipse.pde.core.prefs
new file mode 100644
index 0000000..0f5d304
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/.settings/org.eclipse.pde.core.prefs
@@ -0,0 +1,4 @@
+#Fri Dec 24 16:24:53 EST 2010
+eclipse.preferences.version=1
+pluginProject.extensions=false
+resolve.requirebundle=false
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.transport.ecf/META-INF/MANIFEST.MF
new file mode 100644
index 0000000..e8aa003
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/META-INF/MANIFEST.MF
@@ -0,0 +1,19 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: %pluginName
+Bundle-SymbolicName: org.eclipse.equinox.p2.transport.ecf
+Bundle-Version: 1.0.0.qualifier
+Bundle-RequiredExecutionEnvironment: J2SE-1.5,
+ J2SE-1.4
+Require-Bundle: org.eclipse.ecf;bundle-version="3.1.0",
+ org.eclipse.ecf.filetransfer;bundle-version="4.0.0",
+ org.eclipse.ecf.provider.filetransfer;bundle-version="3.1.0",
+ org.eclipse.core.runtime;bundle-version="3.6.100",
+ org.eclipse.equinox.p2.core;bundle-version="2.0.100",
+ org.eclipse.equinox.p2.repository;bundle-version="2.1.0"
+Service-Component: OSGI-INF/ecfTransport.xml
+Bundle-Activator: org.eclipse.equinox.internal.p2.transport.ecf.Activator
+Bundle-ActivationPolicy: lazy
+Export-Package: org.eclipse.equinox.internal.p2.transport.ecf
+Bundle-Vendor: %providerName
+Bundle-Localization: plugin
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/OSGI-INF/ecfTransport.xml b/bundles/org.eclipse.equinox.p2.transport.ecf/OSGI-INF/ecfTransport.xml
new file mode 100644
index 0000000..d83b000
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/OSGI-INF/ecfTransport.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<scr:component xmlns:scr="http://www.osgi.org/xmlns/scr/v1.1.0" name="org.eclipse.equinox.p2.transport.ecf">
+   <implementation class="org.eclipse.equinox.internal.p2.transport.ecf.ECFTransportComponent"/>
+   <service>
+      <provide interface="org.eclipse.equinox.p2.core.spi.IAgentServiceFactory"/>
+   </service>
+   <property name="p2.agent.servicename" type="String" value="org.eclipse.equinox.internal.p2.repository.Transport"/>
+</scr:component>
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/build.properties b/bundles/org.eclipse.equinox.p2.transport.ecf/build.properties
new file mode 100644
index 0000000..cfa3528
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/build.properties
@@ -0,0 +1,6 @@
+source.. = src/
+output.. = bin/
+bin.includes = META-INF/,\
+               .,\
+               OSGI-INF/,\
+               plugin.properties
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/plugin.properties b/bundles/org.eclipse.equinox.p2.transport.ecf/plugin.properties
new file mode 100644
index 0000000..4b7e42c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/plugin.properties
@@ -0,0 +1,12 @@
+###############################################################################
+#  Copyright (c) 2010 Sonatype, Inc. and others.
+#  All rights reserved. This program and the accompanying materials
+#  are made available under the terms of the Eclipse Public License v1.0
+#  which accompanies this distribution, and is available at
+#  http://www.eclipse.org/legal/epl-v10.html
+# 
+#  Contributors:
+#     Sonatype, Inc. - initial API and implementation
+###############################################################################
+pluginName = Equinox ECF based transport for p2
+providerName = Eclipse.org - Equinox
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/pom.xml b/bundles/org.eclipse.equinox.p2.transport.ecf/pom.xml
new file mode 100644
index 0000000..8325c35
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/pom.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <artifactId>org.eclipse.equinox.p2-parent</artifactId>
+    <groupId>org.eclipse</groupId>
+    <version>0.0.1-SNAPSHOT</version><relativePath>../org.eclipse.equinox.p2-parent</relativePath>
+  </parent>
+  <groupId>org.eclipse</groupId>
+  <artifactId>org.eclipse.equinox.p2.transport.ecf</artifactId>
+  <version>1.0.0.qualifier</version>
+  <packaging>eclipse-plugin</packaging>
+</project>
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/Activator.java b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/Activator.java
new file mode 100644
index 0000000..b21c52c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/Activator.java
@@ -0,0 +1,169 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc and others.
+ *  All rights reserved. This program and the accompanying materials
+ *  are made available under the terms of the Eclipse Public License v1.0
+ *  which accompanies this distribution, and is available at
+ *  http://www.eclipse.org/legal/epl-v10.html
+ * 
+ *  Contributors:
+ * 	Cloudsmith Inc - initial API and implementation
+ * 	IBM Corporation - ongoing development
+ * 	Genuitec - Bug 291926
+ ******************************************************************************/
+package org.eclipse.equinox.internal.p2.transport.ecf;
+
+import org.eclipse.ecf.filetransfer.service.IRetrieveFileTransferFactory;
+import org.eclipse.ecf.provider.filetransfer.IFileTransferProtocolToFactoryMapper;
+import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
+import org.osgi.framework.*;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.util.tracker.ServiceTracker;
+
+/**
+ * The activator class controls the plug-in life cycle.
+ * This activator has helper methods to get file transfer service tracker, and
+ * for making sure required ECF bundles are started.
+ */
+public class Activator implements BundleActivator {
+
+	public static final String ID = "org.eclipse.equinox.p2.transport.ecf"; //$NON-NLS-1$
+	private static final String HTTP = "http"; //$NON-NLS-1$
+	private static final String HTTPS = "https"; //$NON-NLS-1$
+
+	private static BundleContext context;
+	// tracker for ECF service
+	private ServiceTracker<IRetrieveFileTransferFactory, IRetrieveFileTransferFactory> retrievalFactoryTracker;
+
+	// tracker for protocolToFactoryMapperTracker
+	private ServiceTracker<IFileTransferProtocolToFactoryMapper, IFileTransferProtocolToFactoryMapper> protocolToFactoryMapperTracker = null;
+
+	// The shared instance
+	private static Activator plugin;
+
+	public void start(BundleContext aContext) throws Exception {
+		Activator.context = aContext;
+		Activator.plugin = this;
+	}
+
+	public void stop(BundleContext aContext) throws Exception {
+		Activator.context = null;
+		Activator.plugin = null;
+		if (retrievalFactoryTracker != null) {
+			retrievalFactoryTracker.close();
+			retrievalFactoryTracker = null;
+		}
+		if (protocolToFactoryMapperTracker != null) {
+			protocolToFactoryMapperTracker.close();
+			protocolToFactoryMapperTracker = null;
+		}
+
+	}
+
+	public static BundleContext getContext() {
+		return Activator.context;
+	}
+
+	/**
+	 * Get singleton instance.
+	 *
+	 * @return the shared instance
+	 */
+	public static Activator getDefault() {
+		return plugin;
+	}
+
+	/**
+	 * Returns a {@link IRetrieveFileTransferFactory} using a {@link ServiceTracker} after having attempted
+	 * to start the bundle "org.eclipse.ecf.provider.filetransfer". If something is wrong with the configuration
+	 * this method returns null.
+	 * @return a factory, or null, if configuration is incorrect
+	 */
+	public IRetrieveFileTransferFactory getRetrieveFileTransferFactory() {
+		return getFileTransferServiceTracker().getService();
+	}
+
+	public synchronized void useJREHttpClient() {
+		IFileTransferProtocolToFactoryMapper mapper = getProtocolToFactoryMapper();
+		if (mapper != null) {
+			// remove http
+			// Remove browse provider
+			String providerId = mapper.getBrowseFileTransferFactoryId(HTTP);
+			if (providerId != null) {
+				mapper.removeBrowseFileTransferFactory(providerId);
+			}
+			// Remove retrieve provider
+			providerId = mapper.getRetrieveFileTransferFactoryId(HTTP);
+			if (providerId != null) {
+				mapper.removeRetrieveFileTransferFactory(providerId);
+			}
+			// Remove send provider
+			providerId = mapper.getSendFileTransferFactoryId(HTTP);
+			if (providerId != null) {
+				mapper.removeSendFileTransferFactory(providerId);
+			}
+			// remove https
+			// Remove browse provider
+			providerId = mapper.getBrowseFileTransferFactoryId(HTTPS);
+			if (providerId != null) {
+				mapper.removeBrowseFileTransferFactory(providerId);
+			}
+			// Remove retrieve provider
+			providerId = mapper.getRetrieveFileTransferFactoryId(HTTPS);
+			if (providerId != null) {
+				mapper.removeRetrieveFileTransferFactory(providerId);
+			}
+			// Remove send provider
+			providerId = mapper.getSendFileTransferFactoryId(HTTPS);
+			if (providerId != null) {
+				mapper.removeSendFileTransferFactory(providerId);
+			}
+		}
+	}
+
+	/**
+	 * Gets the singleton ServiceTracker for the IRetrieveFileTransferFactory and starts the bundles
+	 * "org.eclipse.ecf" and
+	 * "org.eclipse.ecf.provider.filetransfer" on first call.
+	 * @return  ServiceTracker
+	 */
+	private synchronized ServiceTracker<IRetrieveFileTransferFactory, IRetrieveFileTransferFactory> getFileTransferServiceTracker() {
+		if (retrievalFactoryTracker == null) {
+			retrievalFactoryTracker = new ServiceTracker<IRetrieveFileTransferFactory, IRetrieveFileTransferFactory>(Activator.getContext(), IRetrieveFileTransferFactory.class, null);
+			retrievalFactoryTracker.open();
+			startBundle("org.eclipse.ecf"); //$NON-NLS-1$
+			startBundle("org.eclipse.ecf.provider.filetransfer"); //$NON-NLS-1$
+		}
+		return retrievalFactoryTracker;
+	}
+
+	private IFileTransferProtocolToFactoryMapper getProtocolToFactoryMapper() {
+		if (protocolToFactoryMapperTracker == null) {
+			protocolToFactoryMapperTracker = new ServiceTracker<IFileTransferProtocolToFactoryMapper, IFileTransferProtocolToFactoryMapper>(context, IFileTransferProtocolToFactoryMapper.class, null);
+			protocolToFactoryMapperTracker.open();
+		}
+		return protocolToFactoryMapperTracker.getService();
+	}
+
+	private boolean startBundle(String bundleId) {
+		PackageAdmin packageAdmin = (PackageAdmin) ServiceHelper.getService(Activator.getContext(), PackageAdmin.class.getName());
+		if (packageAdmin == null)
+			return false;
+
+		Bundle[] bundles = packageAdmin.getBundles(bundleId, null);
+		if (bundles != null && bundles.length > 0) {
+			for (int i = 0; i < bundles.length; i++) {
+				try {
+					if ((bundles[i].getState() & Bundle.INSTALLED) == 0) {
+						bundles[i].start(Bundle.START_ACTIVATION_POLICY);
+						bundles[i].start(Bundle.START_TRANSIENT);
+						return true;
+					}
+				} catch (BundleException e) {
+					// failed, try next bundle
+				}
+			}
+		}
+		return false;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/ECFTransportComponent.java b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/ECFTransportComponent.java
new file mode 100644
index 0000000..18a3914
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/ECFTransportComponent.java
@@ -0,0 +1,13 @@
+package org.eclipse.equinox.internal.p2.transport.ecf;
+
+import org.eclipse.equinox.p2.core.IProvisioningAgent;
+import org.eclipse.equinox.p2.core.spi.IAgentServiceFactory;
+
+public class ECFTransportComponent implements IAgentServiceFactory {
+
+	@Override
+	public Object createService(IProvisioningAgent agent) {
+		return new RepositoryTransport();
+	}
+	
+}
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/FileInfoReader.java b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/FileInfoReader.java
new file mode 100644
index 0000000..2fc0afb
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/FileInfoReader.java
@@ -0,0 +1,247 @@
+/*******************************************************************************
+ * Copyright (c) 2009, IBM Corporation, and others.
+ * The code, documentation and other materials contained herein have been
+ * licensed under the Eclipse Public License - v 1.0 by the copyright holder
+ * listed above, as the Initial Contributor under such license. The text of
+ * such license is available at www.eclipse.org.
+ * Contributors:
+ * 	IBM Corporation - initial implementation
+ * 	Cloudsmith Inc - modified API, and implementation
+ ******************************************************************************/
+package org.eclipse.equinox.internal.p2.transport.ecf;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.net.URI;
+import org.eclipse.core.runtime.*;
+import org.eclipse.core.runtime.jobs.Job;
+import org.eclipse.ecf.core.*;
+import org.eclipse.ecf.core.security.IConnectContext;
+import org.eclipse.ecf.filetransfer.*;
+import org.eclipse.ecf.filetransfer.events.IRemoteFileSystemBrowseEvent;
+import org.eclipse.ecf.filetransfer.events.IRemoteFileSystemEvent;
+import org.eclipse.ecf.filetransfer.identity.*;
+import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
+import org.eclipse.equinox.internal.p2.repository.Activator;
+import org.eclipse.equinox.internal.p2.repository.AuthenticationFailedException;
+import org.eclipse.equinox.internal.p2.repository.JREHttpClientRequiredException;
+import org.eclipse.equinox.internal.p2.repository.Messages;
+import org.eclipse.equinox.internal.p2.repository.RepositoryPreferences;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * The FileInfoReader is a {@link Job} similar to {@link FileReader}, but without the support
+ * from ECF (there is currently no way to wait on a BrowseRequest job, as this is internal to
+ * ECF). If such support is added, this class is easily modified.
+ * 
+ */
+public class FileInfoReader extends Job implements IRemoteFileSystemListener {
+	private Exception exception;
+	private IProgressMonitor theMonitor;
+	private final int connectionRetryCount;
+	private final long connectionRetryDelay;
+	private final IConnectContext connectContext;
+	final Boolean[] barrier = new Boolean[1];
+	private IRemoteFile[] remoteFiles;
+	private IRemoteFileSystemRequest browseRequest;
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.core.runtime.jobs.Job#run(org.eclipse.core.runtime.IProgressMonitor)
+	 */
+	protected IStatus run(IProgressMonitor monitor) {
+		synchronized (barrier) {
+			while (barrier[0] == null) {
+				try {
+					barrier.wait(1000);
+					if (theMonitor.isCanceled() && browseRequest != null)
+						browseRequest.cancel();
+				} catch (InterruptedException e) {
+					//ignore
+				}
+			}
+		}
+		return Status.OK_STATUS;
+	}
+
+	/**
+	 * Waits until request is processed (barrier[0] is non null).
+	 * This is a bit of a hack, as it would be better if the ECFBrowser worked in similar fashion to
+	 * file transfer were a custom job can be supplied.
+	 * TODO: log an issue for ECF.
+	 */
+	private void waitOnSelf() {
+		schedule();
+		while (barrier[0] == null) {
+			boolean logged = false;
+			try {
+				join();
+			} catch (InterruptedException e) {
+				if (!logged)
+					LogHelper.log(new Status(IStatus.WARNING, Activator.ID, "Unexpected interrupt while waiting on ECF browse request", e)); //$NON-NLS-1$
+			}
+		}
+	}
+
+	/**
+	 * Create a new FileInfoReader that will retry failed connection attempts and sleep some amount of time between each
+	 * attempt.
+	 */
+	public FileInfoReader(IConnectContext aConnectContext) {
+		super(Messages.repo_loading); // job label - TODO: this is a bad label
+		barrier[0] = null;
+		// Hide this job.
+		setSystem(true);
+		setUser(false);
+		connectionRetryCount = RepositoryPreferences.getConnectionRetryCount();
+		connectionRetryDelay = RepositoryPreferences.getConnectionMsRetryDelay();
+		connectContext = aConnectContext;
+	}
+
+	/**
+	 * Get the requested information.
+	 * @return IRemoteFile[] or null if there was an error.
+	 * @throws CoreException 
+	 * @throws FileNotFoundException 
+	 * @throws AuthenticationFailedException 
+	 * @throws JREHttpClientRequiredException 
+	 */
+	public IRemoteFile[] getRemoteFiles(URI location, IProgressMonitor monitor) throws AuthenticationFailedException, FileNotFoundException, CoreException, JREHttpClientRequiredException {
+		if (monitor != null)
+			monitor.beginTask(location.toString(), 1);
+		try {
+			sendBrowseRequest(location, monitor);
+			waitOnSelf();
+			// throw any exception received in a callback
+			checkException(location, connectionRetryCount);
+
+			return remoteFiles;
+		} finally {
+			if (monitor != null) {
+				monitor.done();
+			}
+		}
+
+	}
+
+	public IRemoteFile getRemoteFile(URI location, IProgressMonitor monitor) throws AuthenticationFailedException, FileNotFoundException, CoreException, JREHttpClientRequiredException {
+
+		getRemoteFiles(location, monitor);
+		return remoteFiles != null && remoteFiles.length > 0 ? remoteFiles[0] : null;
+	}
+
+	public long getLastModified(URI location, IProgressMonitor monitor) throws AuthenticationFailedException, FileNotFoundException, CoreException, JREHttpClientRequiredException {
+		IRemoteFile file = getRemoteFile(location, monitor);
+		if (file == null)
+			throw new FileNotFoundException(location.toString());
+		return file.getInfo().getLastModified();
+	}
+
+	public void handleRemoteFileEvent(IRemoteFileSystemEvent event) {
+		exception = event.getException();
+		if (exception != null) {
+			synchronized (barrier) {
+				barrier[0] = Boolean.TRUE;
+				barrier.notify();
+			}
+		} else if (event instanceof IRemoteFileSystemBrowseEvent) {
+			IRemoteFileSystemBrowseEvent fsbe = (IRemoteFileSystemBrowseEvent) event;
+			remoteFiles = fsbe.getRemoteFiles();
+			if (theMonitor != null)
+				theMonitor.worked(1);
+			synchronized (barrier) {
+				barrier[0] = Boolean.TRUE;
+				barrier.notify();
+			}
+		} else {
+			synchronized (barrier) {
+				barrier[0] = Boolean.FALSE; // ended by unknown reason
+				barrier.notify();
+			}
+		}
+	}
+
+	protected void sendBrowseRequest(URI uri, IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
+		IContainer container;
+		try {
+			container = ContainerFactory.getDefault().createContainer();
+		} catch (ContainerCreateException e) {
+			throw RepositoryStatusHelper.fromMessage(Messages.ecf_configuration_error);
+		}
+
+		IRemoteFileSystemBrowserContainerAdapter adapter = (IRemoteFileSystemBrowserContainerAdapter) container.getAdapter(IRemoteFileSystemBrowserContainerAdapter.class);
+		if (adapter == null) {
+			throw RepositoryStatusHelper.fromMessage(Messages.ecf_configuration_error);
+		}
+
+		adapter.setConnectContextForAuthentication(connectContext);
+
+		this.exception = null;
+		this.theMonitor = monitor;
+		for (int retryCount = 0;; retryCount++) {
+			if (monitor != null && monitor.isCanceled())
+				throw new OperationCanceledException();
+
+			try {
+				IFileID fileID = FileIDFactory.getDefault().createFileID(adapter.getBrowseNamespace(), uri.toString());
+				browseRequest = adapter.sendBrowseRequest(fileID, this);
+			} catch (RemoteFileSystemException e) {
+				exception = e;
+			} catch (FileCreateException e) {
+				exception = e;
+			}
+			if (checkException(uri, retryCount))
+				break;
+		}
+	}
+
+	protected Exception getException() {
+		return exception;
+	}
+
+	/**
+	 * Utility method to check exception condition and determine if retry should be done.
+	 * If there was an exception it is translated into one of the specified exceptions and thrown.
+	 * 
+	 * @param uri the URI being read - used for logging purposes
+	 * @param attemptCounter - the current attempt number (start with 0)
+	 * @return true if the exception is an IOException and attemptCounter < connectionRetryCount, false otherwise
+	 * @throws CoreException
+	 * @throws FileNotFoundException
+	 * @throws AuthenticationFailedException
+	 * @throws JREHttpClientRequiredException 
+	 */
+	private boolean checkException(URI uri, int attemptCounter) throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
+		// note that 'exception' could have been captured in a callback
+		if (exception != null) {
+			// check if HTTP client needs to be changed
+			RepositoryStatusHelper.checkJREHttpClientRequired(exception);
+
+			// if this is a authentication failure - it is not meaningful to continue
+			RepositoryStatusHelper.checkPermissionDenied(exception);
+
+			// if this is a file not found - it is not meaningful to continue
+			RepositoryStatusHelper.checkFileNotFound(exception, uri);
+
+			Throwable t = RepositoryStatusHelper.unwind(exception);
+			if (t instanceof CoreException)
+				throw RepositoryStatusHelper.unwindCoreException((CoreException) t);
+
+			if (t instanceof IOException && attemptCounter < connectionRetryCount) {
+				// TODO: Retry only certain exceptions or filter out
+				// some exceptions not worth retrying
+				//
+				exception = null;
+				try {
+					LogHelper.log(new Status(IStatus.WARNING, Activator.ID, NLS.bind(Messages.connection_to_0_failed_on_1_retry_attempt_2, new String[] {uri.toString(), t.getMessage(), String.valueOf(attemptCounter)}), t));
+
+					Thread.sleep(connectionRetryDelay);
+					return false;
+				} catch (InterruptedException e) {
+					/* ignore */
+				}
+			}
+			throw RepositoryStatusHelper.wrap(exception);
+		}
+		return true;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/FileReader.java b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/FileReader.java
new file mode 100644
index 0000000..d1760c6
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/FileReader.java
@@ -0,0 +1,509 @@
+/*******************************************************************************
+ * Copyright (c) 2006, 2010 Cloudsmith Inc.
+ *  All rights reserved. This program and the accompanying materials
+ *  are made available under the terms of the Eclipse Public License v1.0
+ *  which accompanies this distribution, and is available at
+ *  http://www.eclipse.org/legal/epl-v10.html
+ * 
+ *  Contributors:
+ * 	Cloudsmith Inc - initial API and implementation
+ * 	IBM Corporation - ongoing development
+ *  Sonatype Inc - ongoing development
+ ******************************************************************************/
+package org.eclipse.equinox.internal.p2.transport.ecf;
+
+import java.io.*;
+import java.net.SocketTimeoutException;
+import java.net.URI;
+import java.util.Date;
+import org.eclipse.core.runtime.*;
+import org.eclipse.core.runtime.jobs.Job;
+import org.eclipse.ecf.core.security.IConnectContext;
+import org.eclipse.ecf.filetransfer.*;
+import org.eclipse.ecf.filetransfer.events.*;
+import org.eclipse.ecf.filetransfer.identity.*;
+import org.eclipse.ecf.filetransfer.service.IRetrieveFileTransferFactory;
+import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
+import org.eclipse.equinox.internal.p2.repository.AuthenticationFailedException;
+import org.eclipse.equinox.internal.p2.repository.FileInfo;
+import org.eclipse.equinox.internal.p2.repository.JREHttpClientRequiredException;
+import org.eclipse.equinox.internal.p2.repository.Messages;
+import org.eclipse.equinox.internal.p2.repository.ProgressStatistics;
+import org.eclipse.equinox.internal.p2.repository.RepositoryPreferences;
+import org.eclipse.equinox.internal.p2.repository.RepositoryTracing;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * FileReader is an ECF FileTransferJob implementation.
+ */
+public final class FileReader extends FileTransferJob implements IFileTransferListener {
+	/**
+	 * Class used to suppress warnings about a job being blocked by another job.
+	 * Since we are running a job that will always be blocked by another job that
+	 * is actually performing the transfer, these messages are unnecessary and ugly.
+	 */
+	static class SuppressBlockedMonitor extends SubProgressMonitor {
+		public SuppressBlockedMonitor(IProgressMonitor monitor, int ticks) {
+			super(monitor, ticks);
+		}
+
+		public void setBlocked(IStatus reason) {
+			//do nothing
+		}
+
+		public void clearBlocked() {
+			//do nothing
+		}
+	}
+
+	private static IFileReaderProbe testProbe;
+	private boolean closeStreamWhenFinished = false;
+	private Exception exception;
+	private FileInfo fileInfo;
+	private long lastProgressCount;
+	private long lastStatsCount;
+	protected IProgressMonitor theMonitor;
+	private OutputStream theOutputStream;
+	private ProgressStatistics statistics;
+	private final int connectionRetryCount;
+	private final long connectionRetryDelay;
+	private final IConnectContext connectContext;
+	private URI requestUri;
+	protected IFileTransferConnectStartEvent connectEvent;
+	private Job cancelJob;
+	private boolean monitorStarted;
+
+	/**
+	 * Create a new FileReader that will retry failed connection attempts and sleep some amount of time between each
+	 * attempt.
+	 */
+	public FileReader(IConnectContext aConnectContext) {
+		super(Messages.FileTransport_reader); // job label
+
+		// Hide this job.
+		setSystem(true);
+		setUser(false);
+		connectionRetryCount = RepositoryPreferences.getConnectionRetryCount();
+		connectionRetryDelay = RepositoryPreferences.getConnectionMsRetryDelay();
+		connectContext = aConnectContext;
+	}
+
+	public FileInfo getLastFileInfo() {
+		return fileInfo;
+	}
+
+	/**
+	 * A job to handle cancelation when trying to establish a socket connection.
+	 * At this point we don't have a transfer job running yet, so we need a separate
+	 * job to monitor for cancelation.
+	 */
+	protected class CancelHandler extends Job {
+		private boolean done = false;
+
+		protected CancelHandler() {
+			super(Messages.FileTransport_cancelCheck);
+			setSystem(true);
+		}
+
+		public IStatus run(IProgressMonitor jobMonitor) {
+			while (!done && !jobMonitor.isCanceled()) {
+				try {
+					Thread.sleep(1000);
+				} catch (InterruptedException e) {
+					return Status.CANCEL_STATUS;
+				}
+				if (theMonitor != null && theMonitor.isCanceled())
+					if (connectEvent != null)
+						connectEvent.cancel();
+			}
+			return Status.OK_STATUS;
+		}
+
+		protected void canceling() {
+			//wake up from sleep in run method
+			Thread t = getThread();
+			if (t != null)
+				t.interrupt();
+		}
+
+	}
+
+	public synchronized void handleTransferEvent(IFileTransferEvent event) {
+		if (event instanceof IFileTransferConnectStartEvent) {
+			// keep the connect event to be able to cancel the transfer
+			connectEvent = (IFileTransferConnectStartEvent) event;
+			cancelJob = new CancelHandler();
+			//schedule with a delay to avoid the overhead of an extra job on a fast connection
+			cancelJob.schedule(500);
+		} else if (event instanceof IIncomingFileTransferReceiveStartEvent) {
+			//we no longer need the cancel handler because we are about to fork the transfer job
+			if (cancelJob != null)
+				cancelJob.cancel();
+			IIncomingFileTransfer source = ((IIncomingFileTransferEvent) event).getSource();
+			try {
+				FileInfo fi = new FileInfo();
+				Date lastModified = source.getRemoteLastModified();
+				if (lastModified != null)
+					fi.setLastModified(lastModified.getTime());
+				fi.setName(source.getRemoteFileName());
+				fi.setSize(source.getFileLength());
+				fileInfo = fi;
+
+				((IIncomingFileTransferReceiveStartEvent) event).receive(theOutputStream, this);
+			} catch (IOException e) {
+				exception = e;
+				return;
+			}
+			long fileLength = source.getFileLength();
+			ProgressStatistics stats = new ProgressStatistics(requestUri, source.getRemoteFileName(), fileLength);
+			setStatistics(stats);
+
+			if (theMonitor != null) {
+				theMonitor.beginTask(null, 1000);
+				monitorStarted = true;
+				theMonitor.subTask(stats.report());
+				lastStatsCount = 0;
+				lastProgressCount = 0;
+			}
+			onStart(source);
+		} else if (event instanceof IIncomingFileTransferReceiveDataEvent) {
+			IIncomingFileTransfer source = ((IIncomingFileTransferEvent) event).getSource();
+			if (theMonitor != null) {
+				if (theMonitor.isCanceled()) {
+					source.cancel();
+					return;
+				}
+
+				long br = source.getBytesReceived();
+				long count = br - lastStatsCount;
+				lastStatsCount = br;
+				ProgressStatistics stats = getStatistics();
+				if (stats != null) {
+					stats.increase(count);
+					fileInfo.setAverageSpeed(stats.getAverageSpeed());
+					if (stats.shouldReport()) {
+						count = br - lastProgressCount;
+						lastProgressCount = br;
+						theMonitor.subTask(stats.report());
+						theMonitor.worked((int) (1000 * count / stats.getTotal()));
+					}
+				}
+			}
+			onData(source);
+		} else if (event instanceof IIncomingFileTransferReceiveDoneEvent) {
+			if (closeStreamWhenFinished)
+				hardClose(theOutputStream);
+
+			if (exception == null)
+				exception = ((IIncomingFileTransferReceiveDoneEvent) event).getException();
+			onDone(((IIncomingFileTransferReceiveDoneEvent) event).getSource());
+		}
+	}
+
+	public InputStream read(URI url, final IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
+		final PipedInputStream input = new PipedInputStream();
+		PipedOutputStream output;
+		try {
+			output = new PipedOutputStream(input);
+		} catch (IOException e) {
+			throw RepositoryStatusHelper.wrap(e);
+		}
+		RepositoryTracing.debug("Downloading {0}", url); //$NON-NLS-1$
+
+		sendRetrieveRequest(url, output, null, true, monitor);
+
+		return new InputStream() {
+			public int available() throws IOException {
+				checkException();
+				return input.available();
+			}
+
+			public void close() throws IOException {
+				hardClose(input);
+				checkException();
+			}
+
+			public void mark(int readlimit) {
+				input.mark(readlimit);
+			}
+
+			public boolean markSupported() {
+				return input.markSupported();
+			}
+
+			public int read() throws IOException {
+				checkException();
+				return input.read();
+			}
+
+			public int read(byte b[]) throws IOException {
+				checkException();
+				return input.read(b);
+			}
+
+			public int read(byte b[], int off, int len) throws IOException {
+				checkException();
+				return input.read(b, off, len);
+			}
+
+			public void reset() throws IOException {
+				checkException();
+				input.reset();
+			}
+
+			public long skip(long n) throws IOException {
+				checkException();
+				return input.skip(n);
+			}
+
+			private void checkException() throws IOException {
+				if (getException() == null)
+					return;
+
+				IOException e;
+				Throwable t = RepositoryStatusHelper.unwind(getException());
+				if (t instanceof IOException)
+					e = (IOException) t;
+				else {
+					if (t instanceof UserCancelledException) {
+						Throwable cause = t;
+						t = new OperationCanceledException(t.getMessage());
+						t.initCause(cause);
+					}
+					e = new IOException(t.getMessage());
+					e.initCause(t);
+				}
+				throw e;
+			}
+		};
+	}
+
+	public void readInto(URI uri, OutputStream anOutputStream, IProgressMonitor monitor) //
+			throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
+		readInto(uri, anOutputStream, -1, monitor);
+	}
+
+	public boolean belongsTo(Object family) {
+		return family == this;
+	}
+
+	public void readInto(URI uri, OutputStream anOutputStream, long startPos, IProgressMonitor monitor) //
+			throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
+		if (monitor == null)
+			monitor = new NullProgressMonitor();
+		try {
+			sendRetrieveRequest(uri, anOutputStream, (startPos != -1 ? new DownloadRange(startPos) : null), false, monitor);
+			Job.getJobManager().join(this, new SuppressBlockedMonitor(monitor, 0));
+			if (monitor.isCanceled() && connectEvent != null)
+				connectEvent.cancel();
+			// check and throw exception if received in callback
+			checkException(uri, connectionRetryCount);
+		} catch (InterruptedException e) {
+			monitor.setCanceled(true);
+			throw new OperationCanceledException();
+		} finally {
+			// kill the cancelJob, if there is one
+			if (cancelJob != null) {
+				cancelJob.cancel();
+				cancelJob = null;
+			}
+			// If monitor was never started, make sure it is balanced
+			if (!monitorStarted)
+				monitor.beginTask(null, 1);
+			monitorStarted = false;
+			monitor.done();
+		}
+	}
+
+	protected void sendRetrieveRequest(URI uri, OutputStream outputStream, DownloadRange range, boolean closeStreamOnFinish, //
+			IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
+
+		IRetrieveFileTransferFactory factory = Activator.getDefault().getRetrieveFileTransferFactory();
+		if (factory == null) {
+			throw RepositoryStatusHelper.fromMessage(Messages.ecf_configuration_error);
+		}
+		IRetrieveFileTransferContainerAdapter adapter = factory.newInstance();
+
+		adapter.setConnectContextForAuthentication(connectContext);
+
+		this.exception = null;
+		this.closeStreamWhenFinished = closeStreamOnFinish;
+		this.fileInfo = null;
+		this.statistics = null;
+		this.lastProgressCount = 0L;
+		this.lastStatsCount = 0L;
+		this.theMonitor = monitor;
+		this.monitorStarted = false;
+		this.theOutputStream = outputStream;
+		this.requestUri = uri;
+
+		for (int retryCount = 0;; retryCount++) {
+			if (monitor != null && monitor.isCanceled())
+				throw new OperationCanceledException();
+
+			try {
+				IFileID fileID = FileIDFactory.getDefault().createFileID(adapter.getRetrieveNamespace(), uri.toString());
+				if (range != null)
+					adapter.sendRetrieveRequest(fileID, range, this, null);
+				else
+					adapter.sendRetrieveRequest(fileID, this, null);
+			} catch (IncomingFileTransferException e) {
+				exception = e;
+			} catch (FileCreateException e) {
+				exception = e;
+			} catch (Throwable t) {
+				if (exception != null)
+					exception.printStackTrace();
+			}
+			if (checkException(uri, retryCount))
+				break;
+		}
+	}
+
+	/**
+	 * Utility method to check exception condition and determine if retry should be done.
+	 * If there was an exception it is translated into one of the specified exceptions and thrown.
+	 * 
+	 * @param uri the URI being read - used for logging purposes
+	 * @param attemptCounter - the current attempt number (start with 0)
+	 * @return true if the exception is an IOException and attemptCounter < connectionRetryCount, false otherwise
+	 * @throws CoreException
+	 * @throws FileNotFoundException
+	 * @throws AuthenticationFailedException
+	 */
+	private boolean checkException(URI uri, int attemptCounter) throws CoreException, FileNotFoundException, AuthenticationFailedException, JREHttpClientRequiredException {
+		// note that 'exception' could have been captured in a callback
+		if (exception != null) {
+			// check if HTTP client needs to be changed
+			RepositoryStatusHelper.checkJREHttpClientRequired(exception);
+
+			// if this is an 'authentication failure' - it is not meaningful to continue
+			RepositoryStatusHelper.checkPermissionDenied(exception);
+
+			// if this is a 'file not found' - it is not meaningful to continue
+			RepositoryStatusHelper.checkFileNotFound(exception, uri);
+
+			Throwable t = RepositoryStatusHelper.unwind(exception);
+			if (t instanceof CoreException)
+				throw RepositoryStatusHelper.unwindCoreException((CoreException) t);
+
+			// not meaningful to try 'timeout again' - if a server is that busy, we
+			// need to wait for quite some time before retrying- it is not likely it is
+			// just a temporary network thing.
+			if (t instanceof SocketTimeoutException)
+				throw RepositoryStatusHelper.wrap(t);
+
+			if (t instanceof IOException && attemptCounter < connectionRetryCount) {
+				// TODO: Retry only certain exceptions or filter out
+				// some exceptions not worth retrying
+				//
+				exception = null;
+				try {
+					LogHelper.log(new Status(IStatus.WARNING, Activator.ID, NLS.bind(Messages.connection_to_0_failed_on_1_retry_attempt_2, new String[] {uri.toString(), t.getMessage(), String.valueOf(attemptCounter)}), t));
+
+					Thread.sleep(connectionRetryDelay);
+					return false;
+				} catch (InterruptedException e) {
+					/* ignore */
+				}
+			}
+			throw RepositoryStatusHelper.wrap(exception);
+		}
+		return true;
+	}
+
+	protected Exception getException() {
+		return exception;
+	}
+
+	/**
+	 * Closes input and output streams
+	 * @param aStream
+	 */
+	public static void hardClose(Object aStream) {
+		if (aStream != null) {
+			try {
+				if (aStream instanceof OutputStream)
+					((OutputStream) aStream).close();
+				else if (aStream instanceof InputStream)
+					((InputStream) aStream).close();
+			} catch (IOException e) { /* ignore */
+			}
+		}
+	}
+
+	private static class DownloadRange implements IFileRangeSpecification {
+
+		private long startPosition;
+
+		public DownloadRange(long startPos) {
+			startPosition = startPos;
+		}
+
+		public long getEndPosition() {
+			return -1;
+		}
+
+		public long getStartPosition() {
+			return startPosition;
+		}
+
+	}
+
+	private void onDone(IIncomingFileTransfer source) {
+		if (testProbe != null)
+			testProbe.onDone(this, source, theMonitor);
+	}
+
+	private void onStart(IIncomingFileTransfer source) {
+		if (testProbe != null)
+			testProbe.onStart(this, source, theMonitor);
+	}
+
+	private void onData(IIncomingFileTransfer source) {
+		if (testProbe != null)
+			testProbe.onData(this, source, theMonitor);
+	}
+
+	/**
+	 * Sets a testing probe that can intercept events on the file reader for testing purposes.
+	 * This method should only ever be called from automated test suites.
+	 */
+	public static void setTestProbe(IFileReaderProbe probe) {
+		testProbe = probe;
+	}
+
+	/**
+	 * Sets the progress statistics. This method is synchronized because the field
+	 * is accessed from both the transfer thread and the thread initiating the transfer
+	 * and we need to ensure field values are consistent across threads.
+	 * 
+	 * @param statistics the statistics to set, or <code>null</code>
+	 */
+	private synchronized void setStatistics(ProgressStatistics statistics) {
+		this.statistics = statistics;
+	}
+
+	/**
+	 * Returns the progress statistics. This method is synchronized because the field
+	 * is accessed from both the transfer thread and the thread initiating the transfer
+	 * and we need to ensure field values are consistent across threads.
+	 * 
+	 * @return the statistics, or <code>null</code>
+	 */
+	private synchronized ProgressStatistics getStatistics() {
+		return statistics;
+	}
+
+	/**
+	 * An interface to allow automated tests to hook into file reader events
+	 * @see #setTestProbe
+	 */
+	public interface IFileReaderProbe {
+		public void onStart(FileReader reader, IIncomingFileTransfer source, IProgressMonitor monitor);
+
+		public void onData(FileReader reader, IIncomingFileTransfer source, IProgressMonitor monitor);
+
+		public void onDone(FileReader reader, IIncomingFileTransfer source, IProgressMonitor monitor);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/Messages.java b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/Messages.java
new file mode 100644
index 0000000..8d51aaa
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/Messages.java
@@ -0,0 +1,95 @@
+/*******************************************************************************
+ *  Copyright (c) 2007, 2010 IBM Corporation and others.
+ *  All rights reserved. This program and the accompanying materials
+ *  are made available under the terms of the Eclipse Public License v1.0
+ *  which accompanies this distribution, and is available at
+ *  http://www.eclipse.org/legal/epl-v10.html
+ * 
+ *  Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     Cloudsmith Inc - additional messages
+ *     Sonatype Inc - ongoing development
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.transport.ecf;
+
+import org.eclipse.osgi.util.NLS;
+
+public class Messages extends NLS {
+	private static final String BUNDLE_NAME = "org.eclipse.equinox.internal.p2.repository.messages"; //$NON-NLS-1$
+
+	public static String CacheManager_AuthenticationFaileFor_0;
+	public static String CacheManager_FailedCommunicationWithRepo_0;
+	public static String CacheManager_Neither_0_nor_1_found;
+	public static String CacheManage_ErrorRenamingCache;
+
+	public static String artifact_not_found;
+	public static String io_failedRead;
+	public static String ecf_configuration_error;
+	public static String repoMan_internalError;
+	public static String repo_loading;
+
+	public static String exception_malformedRepoURI;
+	public static String TransportErrorTranslator_400;
+	public static String TransportErrorTranslator_401;
+	public static String TransportErrorTranslator_402;
+	public static String TransportErrorTranslator_403;
+	public static String TransportErrorTranslator_404;
+	public static String TransportErrorTranslator_405;
+	public static String TransportErrorTranslator_406;
+	public static String TransportErrorTranslator_407;
+	public static String TransportErrorTranslator_408;
+	public static String TransportErrorTranslator_409;
+	public static String TransportErrorTranslator_410;
+	public static String TransportErrorTranslator_411;
+	public static String TransportErrorTranslator_412;
+	public static String TransportErrorTranslator_413;
+	public static String TransportErrorTranslator_414;
+	public static String TransportErrorTranslator_415;
+	public static String TransportErrorTranslator_416;
+	public static String TransportErrorTranslator_417;
+	public static String TransportErrorTranslator_418;
+	public static String TransportErrorTranslator_422;
+	public static String TransportErrorTranslator_423;
+	public static String TransportErrorTranslator_424;
+	public static String TransportErrorTranslator_425;
+	public static String TransportErrorTranslator_426;
+	public static String TransportErrorTranslator_449;
+	public static String TransportErrorTranslator_450;
+	public static String TransportErrorTranslator_500;
+	public static String TransportErrorTranslator_501;
+	public static String TransportErrorTranslator_502;
+	public static String TransportErrorTranslator_503;
+	public static String TransportErrorTranslator_504;
+	public static String TransportErrorTranslator_505;
+	public static String TransportErrorTranslator_506;
+	public static String TransportErrorTranslator_507;
+	public static String TransportErrorTranslator_508;
+	public static String TransportErrorTranslator_510;
+	public static String TransportErrorTranslator_MalformedRemoteFileReference;
+	public static String TransportErrorTranslator_UnableToConnectToRepository_0;
+
+	public static String TransportErrorTranslator_UnknownErrorCode;
+	public static String TransportErrorTranslator_UnknownHost;
+
+	public static String fetching_0_from_1_2_at_3;
+	public static String fetching_0_from_1_2_of_3_at_4;
+	public static String connection_to_0_failed_on_1_retry_attempt_2;
+
+	public static String FileTransport_reader;
+	public static String FileTransport_cancelCheck;
+
+	public static String UnableToRead_0_TooManyAttempts;
+	public static String UnableToRead_0_UserCanceled;
+
+	public static String RepositoryTransport_failedReadRepo;
+
+	static {
+		// initialize resource bundles
+		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
+	}
+
+	private Messages() {
+		// Do not instantiate
+	}
+
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryStatus.java b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryStatus.java
new file mode 100644
index 0000000..ccc4659
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryStatus.java
@@ -0,0 +1,155 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc. and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Cloudsmith Inc. - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.internal.p2.transport.ecf;
+
+import org.eclipse.equinox.internal.p2.repository.DownloadStatus;
+import org.eclipse.equinox.p2.core.ProvisionException;
+
+import java.io.FileNotFoundException;
+import java.net.*;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.ecf.core.identity.IDCreateException;
+import org.eclipse.ecf.filetransfer.BrowseFileTransferException;
+import org.eclipse.ecf.filetransfer.IncomingFileTransferException;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * Utility class to transform transport errors into error messages.
+ *
+ */
+public class RepositoryStatus {
+
+	public static String codeToMessage(int code, String toDownload) {
+		switch (code) {
+			case 400 :
+				return NLS.bind(Messages.TransportErrorTranslator_400, toDownload);
+			case 401 :
+				return NLS.bind(Messages.TransportErrorTranslator_401, toDownload);
+			case 402 :
+				return NLS.bind(Messages.TransportErrorTranslator_402, toDownload);
+			case 403 :
+				return NLS.bind(Messages.TransportErrorTranslator_403, toDownload);
+			case 404 :
+				return NLS.bind(Messages.TransportErrorTranslator_404, toDownload);
+			case 405 :
+				return NLS.bind(Messages.TransportErrorTranslator_405, toDownload);
+			case 406 :
+				return NLS.bind(Messages.TransportErrorTranslator_406, toDownload);
+			case 407 :
+				return NLS.bind(Messages.TransportErrorTranslator_407, toDownload);
+			case 408 :
+				return NLS.bind(Messages.TransportErrorTranslator_408, toDownload);
+			case 409 :
+				return NLS.bind(Messages.TransportErrorTranslator_409, toDownload);
+			case 410 :
+				return NLS.bind(Messages.TransportErrorTranslator_410, toDownload);
+			case 411 :
+				return NLS.bind(Messages.TransportErrorTranslator_411, toDownload);
+			case 412 :
+				return NLS.bind(Messages.TransportErrorTranslator_412, toDownload);
+			case 413 :
+				return NLS.bind(Messages.TransportErrorTranslator_413, toDownload);
+			case 414 :
+				return NLS.bind(Messages.TransportErrorTranslator_414, toDownload);
+			case 415 :
+				return NLS.bind(Messages.TransportErrorTranslator_415, toDownload);
+			case 416 :
+				return NLS.bind(Messages.TransportErrorTranslator_416, toDownload);
+			case 417 :
+				return NLS.bind(Messages.TransportErrorTranslator_417, toDownload);
+			case 418 :
+				return NLS.bind(Messages.TransportErrorTranslator_418, toDownload);
+			case 422 :
+				return NLS.bind(Messages.TransportErrorTranslator_422, toDownload);
+			case 423 :
+				return NLS.bind(Messages.TransportErrorTranslator_423, toDownload);
+			case 424 :
+				return NLS.bind(Messages.TransportErrorTranslator_424, toDownload);
+			case 425 :
+				return NLS.bind(Messages.TransportErrorTranslator_425, toDownload);
+			case 426 :
+				return NLS.bind(Messages.TransportErrorTranslator_426, toDownload);
+			case 449 :
+				return NLS.bind(Messages.TransportErrorTranslator_449, toDownload);
+			case 450 :
+				return NLS.bind(Messages.TransportErrorTranslator_450, toDownload);
+
+			case 500 :
+				return NLS.bind(Messages.TransportErrorTranslator_500, toDownload);
+			case 501 :
+				return NLS.bind(Messages.TransportErrorTranslator_501, toDownload);
+			case 502 :
+				return NLS.bind(Messages.TransportErrorTranslator_502, toDownload);
+			case 503 :
+				return NLS.bind(Messages.TransportErrorTranslator_503, toDownload);
+			case 504 :
+				return NLS.bind(Messages.TransportErrorTranslator_504, toDownload);
+			case 505 :
+				return NLS.bind(Messages.TransportErrorTranslator_505, toDownload);
+			case 506 :
+				return NLS.bind(Messages.TransportErrorTranslator_506, toDownload);
+			case 507 :
+				return NLS.bind(Messages.TransportErrorTranslator_507, toDownload);
+			case 508 :
+				return NLS.bind(Messages.TransportErrorTranslator_508, toDownload);
+			case 510 :
+				return NLS.bind(Messages.TransportErrorTranslator_510, toDownload);
+
+			default :
+				return NLS.bind(Messages.TransportErrorTranslator_UnknownErrorCode, Integer.toString(code), toDownload);
+		}
+	}
+
+	public static DownloadStatus forStatus(IStatus original, URI toDownload) {
+		Throwable t = original.getException();
+		return forException(t, toDownload);
+	}
+
+	public static DownloadStatus forException(Throwable t, URI toDownload) {
+		if (t instanceof FileNotFoundException || (t instanceof IncomingFileTransferException && ((IncomingFileTransferException) t).getErrorCode() == 404))
+			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.ARTIFACT_NOT_FOUND, NLS.bind(Messages.artifact_not_found, toDownload), t);
+		if (t instanceof ConnectException)
+			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_READ, NLS.bind(Messages.TransportErrorTranslator_UnableToConnectToRepository_0, toDownload), t);
+		if (t instanceof UnknownHostException)
+			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_INVALID_LOCATION, NLS.bind(Messages.TransportErrorTranslator_UnknownHost, toDownload), t);
+		if (t instanceof IDCreateException) {
+			IStatus status = ((IDCreateException) t).getStatus();
+			if (status != null && status.getException() != null)
+				t = status.getException();
+
+			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_INVALID_LOCATION, NLS.bind(Messages.TransportErrorTranslator_MalformedRemoteFileReference, toDownload), t);
+		}
+		int code = 0;
+
+		// default to report as read repository error
+		int provisionCode = ProvisionException.REPOSITORY_FAILED_READ;
+
+		if (t instanceof IncomingFileTransferException)
+			code = ((IncomingFileTransferException) t).getErrorCode();
+		else if (t instanceof BrowseFileTransferException)
+			code = ((BrowseFileTransferException) t).getErrorCode();
+
+		// Switch on error codes in the HTTP error code range. 
+		// Note that 404 uses ARTIFACT_NOT_FOUND (as opposed to REPOSITORY_NOT_FOUND, which
+		// is determined higher up in the calling chain).
+		if (code == 401)
+			provisionCode = ProvisionException.REPOSITORY_FAILED_AUTHENTICATION;
+		else if (code == 404)
+			provisionCode = ProvisionException.ARTIFACT_NOT_FOUND;
+
+		// Add more specific translation here
+
+		return new DownloadStatus(IStatus.ERROR, Activator.ID, provisionCode, //
+				code == 0 ? NLS.bind(Messages.io_failedRead, toDownload) //
+						: codeToMessage(code, toDownload.toString()), t);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryStatusHelper.java b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryStatusHelper.java
new file mode 100644
index 0000000..f2fb848
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryStatusHelper.java
@@ -0,0 +1,320 @@
+/*******************************************************************************
+ * Copyright (c) 2009 Cloudsmith Inc, and other.
+ * The code, documentation and other materials contained herein have been
+ * licensed under the Eclipse Public License - v 1.0 by the individual
+ * copyright holders listed above, as Initial Contributors under such license.
+ * The text of such license is available at www.eclipse.org.
+ * Contributors:
+ * 	Cloudsmith Inc. - Initial API and implementation
+ *  IBM Corporation - Original Implementation of checkPermissionDenied
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.transport.ecf;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.lang.reflect.InvocationTargetException;
+import java.net.URI;
+
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.OperationCanceledException;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.ecf.filetransfer.BrowseFileTransferException;
+import org.eclipse.ecf.filetransfer.IncomingFileTransferException;
+import org.eclipse.equinox.internal.p2.repository.AuthenticationFailedException;
+import org.eclipse.equinox.internal.p2.repository.JREHttpClientRequiredException;
+import org.eclipse.equinox.p2.core.ProvisionException;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * RepositoryStatusHelper is a utility class for processing of exceptions and status.
+ */
+public abstract class RepositoryStatusHelper {
+
+	private static final long serialVersionUID = 1L;
+	protected static final String SERVER_REDIRECT = "Server redirected too many times"; //$NON-NLS-1$
+
+	public static IStatus createStatus(String nlsMessage, Object arg) {
+		return createExceptionStatus(null, nlsMessage, new Object[] {arg});
+	}
+
+	public static IStatus createStatus(String nlsMessage, Object arg1, Object arg2) {
+		return createExceptionStatus(null, nlsMessage, new Object[] {arg1, arg2});
+	}
+
+	public static IStatus createStatus(String nlsMessage, Object arg1, Object arg2, Object arg3) {
+		return createExceptionStatus(null, nlsMessage, new Object[] {arg1, arg2, arg3});
+	}
+
+	public static IStatus createStatus(String nlsMessage, Object[] args) {
+		return createExceptionStatus(null, nlsMessage, args);
+	}
+
+	public static IStatus createStatus(String nlsMessage) {
+		return createExceptionStatus(null, nlsMessage, new Object[] {});
+	}
+
+	public static IStatus createExceptionStatus(Throwable cause) {
+		return (cause instanceof CoreException) ? ((CoreException) cause).getStatus() : new Status(IStatus.ERROR, Activator.ID, IStatus.OK, cause.getMessage(), cause);
+	}
+
+	public static IStatus createExceptionStatus(Throwable cause, String nlsMessage, Object[] args) {
+		if (args != null && args.length > 0)
+			nlsMessage = NLS.bind(nlsMessage, args);
+		return new Status(IStatus.ERROR, Activator.ID, IStatus.OK, nlsMessage, cause);
+	}
+
+	public static IStatus createExceptionStatus(Throwable cause, String nlsMessage, Object arg1, Object arg2, Object arg3) {
+		return createExceptionStatus(cause, nlsMessage, new Object[] {arg1, arg2, arg3});
+	}
+
+	public static IStatus createExceptionStatus(Throwable cause, String nlsMessage, Object arg1, Object arg2) {
+		return createExceptionStatus(cause, nlsMessage, new Object[] {arg1, arg2});
+	}
+
+	public static IStatus createExceptionStatus(Throwable cause, String nlsMessage, Object arg1) {
+		return createExceptionStatus(cause, nlsMessage, new Object[] {arg1});
+	}
+
+	public static IStatus createExceptionStatus(Throwable cause, String nlsMessage) {
+		return createExceptionStatus(cause, nlsMessage, new Object[] {});
+	}
+
+	public static void deeplyPrint(Throwable e, PrintStream strm, boolean stackTrace) {
+		deeplyPrint(e, strm, stackTrace, 0);
+	}
+
+	public static CoreException fromMessage(String nlsMessage, Object[] args) {
+		return fromExceptionMessage(null, nlsMessage, args);
+	}
+
+	public static CoreException fromMessage(String nlsMessage, Object arg1) {
+		return fromExceptionMessage(null, nlsMessage, new Object[] {arg1});
+	}
+
+	public static CoreException fromMessage(String nlsMessage, Object arg1, Object arg2) {
+		return fromExceptionMessage(null, nlsMessage, new Object[] {arg1, arg2});
+	}
+
+	public static CoreException fromMessage(String nlsMessage, Object arg1, Object arg2, Object arg3) {
+		return fromExceptionMessage(null, nlsMessage, new Object[] {arg1, arg2, arg3});
+	}
+
+	public static CoreException fromMessage(String nlsMessage) {
+		return fromExceptionMessage(null, nlsMessage, new Object[] {});
+	}
+
+	public static CoreException fromExceptionMessage(Throwable cause, String nlsMessage, Object[] args) {
+		CoreException ce = new CoreException(createExceptionStatus(cause, nlsMessage, args));
+		if (cause != null)
+			ce.initCause(cause);
+		return ce;
+	}
+
+	public static CoreException fromExceptionMessage(Throwable cause, String nlsMessage, Object arg1, Object arg2, Object arg3) {
+		return fromExceptionMessage(cause, nlsMessage, new Object[] {arg1, arg2, arg3});
+	}
+
+	public static CoreException fromExceptionMessage(Throwable cause, String nlsMessage, Object arg1, Object arg2) {
+		return fromExceptionMessage(cause, nlsMessage, new Object[] {arg1, arg2});
+	}
+
+	public static CoreException fromExceptionMessage(Throwable cause, String nlsMessage, Object arg1) {
+		return fromExceptionMessage(cause, nlsMessage, new Object[] {arg1});
+	}
+
+	public static CoreException fromExceptionMessage(Throwable cause, String nlsMessage) {
+		return fromExceptionMessage(cause, nlsMessage, new Object[] {});
+	}
+
+	public static Throwable unwind(Throwable t) {
+		for (;;) {
+			Class<? extends Throwable> tc = t.getClass();
+
+			// We don't use instanceof operator since we want
+			// the explicit class, not subclasses.
+			//
+			if (tc != RuntimeException.class && tc != InvocationTargetException.class && tc != IOException.class)
+				break;
+
+			Throwable cause = t.getCause();
+			if (cause == null)
+				break;
+
+			String msg = t.getMessage();
+			if (msg != null && !msg.equals(cause.toString()))
+				break;
+
+			t = cause;
+		}
+		return t;
+	}
+
+	public static CoreException unwindCoreException(CoreException exception) {
+		IStatus status = exception.getStatus();
+		while (status != null && status.getException() instanceof CoreException) {
+			exception = (CoreException) status.getException();
+			status = exception.getStatus();
+		}
+		return exception;
+	}
+
+	public static CoreException wrap(IStatus status) {
+		CoreException e = new CoreException(status);
+		Throwable t = status.getException();
+		if (t != null)
+			e.initCause(t);
+		return e;
+	}
+
+	public static CoreException wrap(Throwable t) {
+		t = unwind(t);
+		if (t instanceof CoreException)
+			return unwindCoreException((CoreException) t);
+
+		if (t instanceof OperationCanceledException || t instanceof InterruptedException)
+			return new CoreException(Status.CANCEL_STATUS);
+
+		String msg = t.toString();
+		return fromExceptionMessage(t, msg);
+	}
+
+	private static void appendLevelString(PrintStream strm, int level) {
+		if (level > 0) {
+			strm.print("[0"); //$NON-NLS-1$
+			for (int idx = 1; idx < level; ++idx) {
+				strm.print('.');
+				strm.print(level);
+			}
+			strm.print(']');
+		}
+	}
+
+	private static void deeplyPrint(CoreException ce, PrintStream strm, boolean stackTrace, int level) {
+		appendLevelString(strm, level);
+		if (stackTrace)
+			ce.printStackTrace(strm);
+		deeplyPrint(ce.getStatus(), strm, stackTrace, level);
+	}
+
+	private static void deeplyPrint(IStatus status, PrintStream strm, boolean stackTrace, int level) {
+		appendLevelString(strm, level);
+		String msg = status.getMessage();
+		strm.println(msg);
+		Throwable cause = status.getException();
+		if (cause != null) {
+			strm.print("Caused by: "); //$NON-NLS-1$
+			if (stackTrace || !(msg.equals(cause.getMessage()) || msg.equals(cause.toString())))
+				deeplyPrint(cause, strm, stackTrace, level);
+		}
+
+		if (status.isMultiStatus()) {
+			IStatus[] children = status.getChildren();
+			for (int i = 0; i < children.length; i++)
+				deeplyPrint(children[i], strm, stackTrace, level + 1);
+		}
+	}
+
+	private static void deeplyPrint(Throwable t, PrintStream strm, boolean stackTrace, int level) {
+		if (t instanceof CoreException)
+			deeplyPrint((CoreException) t, strm, stackTrace, level);
+		else {
+			appendLevelString(strm, level);
+			if (stackTrace)
+				t.printStackTrace(strm);
+			else {
+				strm.println(t.toString());
+				Throwable cause = t.getCause();
+				if (cause != null) {
+					strm.print("Caused by: "); //$NON-NLS-1$
+					deeplyPrint(cause, strm, stackTrace, level);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Check if the given exception represents that a switch to the JRE HTTP Client 
+	 * is required. ECF sets the HTTP status code 477 to indicate this.
+	 * If the JRE HTTP client is required a JREHttpClientRequiredException is thrown.
+	 */
+	public static void checkJREHttpClientRequired(Throwable t) throws JREHttpClientRequiredException {
+		if (t instanceof IncomingFileTransferException) {
+			if (((IncomingFileTransferException) t).getErrorCode() == 477)
+				throw new JREHttpClientRequiredException();
+		} else if (t instanceof BrowseFileTransferException) {
+			if (((BrowseFileTransferException) t).getErrorCode() == 477)
+				throw new JREHttpClientRequiredException();
+		}
+
+	}
+
+	/**
+	 * Check if the given exception represents a permission failure (401 for HTTP),
+	 * and throw a AuthenticationFailedException if a permission failure was encountered.
+	 */
+	public static void checkPermissionDenied(Throwable t) throws AuthenticationFailedException {
+		// From Use of File Transfer
+		if (t instanceof IncomingFileTransferException) {
+			if (((IncomingFileTransferException) t).getErrorCode() == 401)
+				throw new AuthenticationFailedException();
+			IStatus status = ((IncomingFileTransferException) t).getStatus();
+			t = status == null ? t : status.getException();
+			// From Use of Browse
+		} else if (t instanceof BrowseFileTransferException) {
+			if (((BrowseFileTransferException) t).getErrorCode() == 401)
+				throw new AuthenticationFailedException();
+			IStatus status = ((BrowseFileTransferException) t).getStatus();
+			t = status == null ? t : status.getException();
+		}
+
+		if (t == null || !(t instanceof IOException))
+			return;
+
+		// TODO: is this needed (for 401) now that ECF throws exceptions with codes?
+		// try to figure out if we have a 401 by parsing the exception message
+		// There is unfortunately no specific (general) exception for "redirected too many times" - which is commonly
+		// caused by a failed login. The message and exception are different in different implementations
+		// of http client.
+		String m = t.getMessage();
+		if (m != null && (m.indexOf(" 401 ") != -1 || m.indexOf(SERVER_REDIRECT) != -1)) //$NON-NLS-1$
+			throw new AuthenticationFailedException();
+		if ("org.apache.commons.httpclient.RedirectException".equals(t.getClass().getName())) //$NON-NLS-1$
+			throw new AuthenticationFailedException();
+	}
+
+	/**
+	 * Translates exceptions representing "FileNotFound" into FileNotFoundException.
+	 * @param t the throwable to check
+	 * @param toDownload the URI the exception was thrown for
+	 * @throws FileNotFoundException if 't' represents a file not found
+	 */
+	public static void checkFileNotFound(Throwable t, URI toDownload) throws FileNotFoundException {
+		if (t instanceof IncomingFileTransferException) {
+			IncomingFileTransferException e = (IncomingFileTransferException) t;
+			if (e.getErrorCode() == 404 || e.getErrorCode() == 403 || e.getErrorCode() == 300)
+				throw new FileNotFoundException(toDownload.toString());
+		}
+		if (t instanceof BrowseFileTransferException) {
+			BrowseFileTransferException e = (BrowseFileTransferException) t;
+			if (e.getErrorCode() == 404 || e.getErrorCode() == 403 || e.getErrorCode() == 300)
+				throw new FileNotFoundException(toDownload.toString());
+		}
+
+		if (t instanceof FileNotFoundException)
+			throw (FileNotFoundException) t;
+		if (t instanceof CoreException) {
+			IStatus status = ((CoreException) t).getStatus();
+			Throwable e = status == null ? null : status.getException();
+			if (e instanceof FileNotFoundException)
+				throw (FileNotFoundException) e;
+		}
+	}
+
+	public static IStatus malformedAddressStatus(String address, Throwable t) {
+		return new Status(IStatus.ERROR, Activator.ID, //
+				ProvisionException.REPOSITORY_INVALID_LOCATION, NLS.bind(Messages.exception_malformedRepoURI, address), t);
+
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryTransport.java b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryTransport.java
new file mode 100644
index 0000000..b7d0b26
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/RepositoryTransport.java
@@ -0,0 +1,279 @@
+/*******************************************************************************
+ * Copyright (c) 2006, 2010, IBM Corporation and other.
+ * The code, documentation and other materials contained herein have been
+ * licensed under the Eclipse Public License - v 1.0 by the copyright holder
+ * listed above, as the Initial Contributor under such license. The text of
+ * such license is available at www.eclipse.org.
+ * 
+ * Contributors
+ * 	IBM Corporation - Initial API and implementation.
+ *  Cloudsmith Inc - Implementation
+ ******************************************************************************/
+
+package org.eclipse.equinox.internal.p2.transport.ecf;
+
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.ConnectException;
+import java.net.URI;
+import java.net.UnknownHostException;
+
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.OperationCanceledException;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.ecf.core.identity.IDCreateException;
+import org.eclipse.ecf.core.security.ConnectContextFactory;
+import org.eclipse.ecf.core.security.IConnectContext;
+import org.eclipse.ecf.filetransfer.BrowseFileTransferException;
+import org.eclipse.ecf.filetransfer.IncomingFileTransferException;
+import org.eclipse.ecf.filetransfer.UserCancelledException;
+import org.eclipse.equinox.internal.p2.repository.AuthenticationFailedException;
+import org.eclipse.equinox.internal.p2.repository.Credentials;
+import org.eclipse.equinox.internal.p2.repository.Credentials.LoginCanceledException;
+import org.eclipse.equinox.internal.p2.repository.DownloadStatus;
+import org.eclipse.equinox.internal.p2.repository.FileInfo;
+import org.eclipse.equinox.internal.p2.repository.JREHttpClientRequiredException;
+import org.eclipse.equinox.internal.p2.repository.Messages;
+import org.eclipse.equinox.internal.p2.repository.RepositoryPreferences;
+import org.eclipse.equinox.internal.p2.repository.Transport;
+import org.eclipse.equinox.internal.provisional.p2.repository.IStateful;
+import org.eclipse.equinox.p2.core.IProvisioningAgent;
+import org.eclipse.equinox.p2.core.ProvisionException;
+import org.eclipse.equinox.p2.core.UIServices.AuthenticationInfo;
+import org.eclipse.equinox.p2.core.spi.IAgentServiceFactory;
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * RepositoryTransport adapts p2 to ECF file download and file browsing.
+ * Download is performed by {@link FileReader}, and file browsing is performed by
+ * {@link FileInfoReader}.
+ */
+public class RepositoryTransport extends Transport implements IAgentServiceFactory {
+	private static RepositoryTransport instance;
+
+	/**
+	 * Returns an shared instance of Generic Transport
+	 */
+	//	public static synchronized RepositoryTransport getInstance() {
+	//		if (instance == null) {
+	//			instance = new RepositoryTransport();
+	//		}
+	//		return instance;
+	//	}
+
+	public IStatus download(URI toDownload, OutputStream target, long startPos, IProgressMonitor monitor) {
+
+		boolean promptUser = false;
+		boolean useJREHttp = false;
+		AuthenticationInfo loginDetails = null;
+		for (int i = RepositoryPreferences.getLoginRetryCount(); i > 0; i--) {
+			FileReader reader = null;
+			try {
+				loginDetails = Credentials.forLocation(toDownload, promptUser, loginDetails);
+				IConnectContext context = (loginDetails == null) ? null : ConnectContextFactory.createUsernamePasswordConnectContext(loginDetails.getUserName(), loginDetails.getPassword());
+
+				// perform the download
+				reader = new FileReader(context);
+				reader.readInto(toDownload, target, startPos, monitor);
+
+				// check that job ended ok - throw exceptions otherwise
+				IStatus result = reader.getResult();
+				if (result == null) {
+					String msg = NLS.bind(Messages.RepositoryTransport_failedReadRepo, toDownload);
+					DownloadStatus ds = new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_READ, msg, null);
+					return statusOn(target, ds, reader);
+				}
+				if (result.getSeverity() == IStatus.CANCEL)
+					throw new OperationCanceledException();
+				if (!result.isOK())
+					throw new CoreException(result);
+
+				// Download status is expected on success
+				DownloadStatus status = new DownloadStatus(IStatus.OK, Activator.ID, Status.OK_STATUS.getMessage());
+				return statusOn(target, status, reader);
+			} catch (UserCancelledException e) {
+				statusOn(target, new DownloadStatus(IStatus.CANCEL, Activator.ID, 1, "", null), reader); //$NON-NLS-1$
+				throw new OperationCanceledException();
+			} catch (OperationCanceledException e) {
+				statusOn(target, new DownloadStatus(IStatus.CANCEL, Activator.ID, 1, "", null), reader); //$NON-NLS-1$
+				throw e;
+			} catch (CoreException e) {
+				if (e.getStatus().getException() == null)
+					return statusOn(target, forException(e, toDownload), reader);
+				return statusOn(target, forStatus(e.getStatus(), toDownload), reader);
+			} catch (FileNotFoundException e) {
+				return statusOn(target, forException(e, toDownload), reader);
+			} catch (AuthenticationFailedException e) {
+				promptUser = true;
+			} catch (Credentials.LoginCanceledException e) {
+				DownloadStatus status = new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_AUTHENTICATION, //
+						NLS.bind(Messages.UnableToRead_0_UserCanceled, toDownload), null);
+				return statusOn(target, status, null);
+			} catch (JREHttpClientRequiredException e) {
+				if (!useJREHttp) {
+					useJREHttp = true; // only do this once
+					i++; // need an extra retry
+					Activator.getDefault().useJREHttpClient();
+				}
+			}
+		}
+		// reached maximum number of retries without success
+		DownloadStatus status = new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_AUTHENTICATION, //
+				NLS.bind(Messages.UnableToRead_0_TooManyAttempts, toDownload), null);
+		return statusOn(target, status, null);
+	}
+
+	public IStatus download(URI toDownload, OutputStream target, IProgressMonitor monitor) {
+		return download(toDownload, target, -1, monitor);
+	}
+
+	public InputStream stream(URI toDownload, IProgressMonitor monitor) throws FileNotFoundException, CoreException, AuthenticationFailedException {
+
+		boolean promptUser = false;
+		boolean useJREHttp = false;
+		AuthenticationInfo loginDetails = null;
+		for (int i = RepositoryPreferences.getLoginRetryCount(); i > 0; i--) {
+			FileReader reader = null;
+			try {
+				loginDetails = Credentials.forLocation(toDownload, promptUser, loginDetails);
+				IConnectContext context = (loginDetails == null) ? null : ConnectContextFactory.createUsernamePasswordConnectContext(loginDetails.getUserName(), loginDetails.getPassword());
+
+				// perform the streamed download
+				reader = new FileReader(context);
+				return reader.read(toDownload, monitor);
+			} catch (UserCancelledException e) {
+				throw new OperationCanceledException();
+			} catch (AuthenticationFailedException e) {
+				promptUser = true;
+			} catch (CoreException e) {
+				// must translate this core exception as it is most likely not informative to a user
+				if (e.getStatus().getException() == null)
+					throw new CoreException(RepositoryStatus.forException(e, toDownload));
+				throw new CoreException(RepositoryStatus.forStatus(e.getStatus(), toDownload));
+			} catch (LoginCanceledException e) {	
+				// i.e. same behavior when user cancels as when failing n attempts.
+				throw new AuthenticationFailedException();
+			} catch (JREHttpClientRequiredException e) {
+				if (!useJREHttp) {
+					useJREHttp = true; // only do this once
+					i++; // need an extra retry
+					Activator.getDefault().useJREHttpClient();
+				}
+			}
+		}
+		throw new AuthenticationFailedException();
+	}
+
+	/**
+	 * Set the status on the output stream if it implements IStateful. 
+	 * Update the DownloadStatus with information from FileReader.
+	 * @param target an OutputStream possibly implementing IStateful
+	 * @param status a DownloadStatus configured with status message, code, etc
+	 * @param reader a FileReade that was used to download (or null if not known).
+	 * @throws OperationCanceledException if the operation was canceled by the user.
+	 * @return the configured DownloadStatus status.
+	 */
+	private static DownloadStatus statusOn(OutputStream target, DownloadStatus status, FileReader reader) {
+		if (reader != null) {
+			FileInfo fi = reader.getLastFileInfo();
+			if (fi != null) {
+				status.setFileSize(fi.getSize());
+				status.setLastModified(fi.getLastModified());
+				status.setTransferRate(fi.getAverageSpeed());
+			}
+		}
+		if (target instanceof IStateful)
+			((IStateful) target).setStatus(status);
+		return status;
+	}
+
+	public long getLastModified(URI toDownload, IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException {
+		boolean promptUser = false;
+		boolean useJREHttp = false;
+		AuthenticationInfo loginDetails = null;
+		for (int i = RepositoryPreferences.getLoginRetryCount(); i > 0; i--) {
+			try {
+				loginDetails = Credentials.forLocation(toDownload, promptUser, loginDetails);
+				IConnectContext context = (loginDetails == null) ? null : ConnectContextFactory.createUsernamePasswordConnectContext(loginDetails.getUserName(), loginDetails.getPassword());
+				// get the remote info
+				FileInfoReader reader = new FileInfoReader(context);
+				return reader.getLastModified(toDownload, monitor);
+			} catch (UserCancelledException e) {
+				throw new OperationCanceledException();
+			} catch (CoreException e) {
+				// must translate this core exception as it is most likely not informative to a user
+				if (e.getStatus().getException() == null)
+					throw new CoreException(RepositoryStatus.forException(e, toDownload));
+				throw new CoreException(RepositoryStatus.forStatus(e.getStatus(), toDownload));
+			} catch (AuthenticationFailedException e) {
+				promptUser = true;
+			} catch (LoginCanceledException e) {
+				// same behavior as if user failed n attempts.
+				throw new AuthenticationFailedException();
+			} catch (JREHttpClientRequiredException e) {
+				if (!useJREHttp) {
+					useJREHttp = true; // only do this once
+					i++; // need an extra retry
+					Activator.getDefault().useJREHttpClient();
+				}
+			}
+
+		}
+		// reached maximum number of authentication retries without success
+		throw new AuthenticationFailedException();
+	}
+
+	public static DownloadStatus forStatus(IStatus original, URI toDownload) {
+		Throwable t = original.getException();
+		return forException(t, toDownload);
+	}
+
+	public static DownloadStatus forException(Throwable t, URI toDownload) {
+		if (t instanceof FileNotFoundException || (t instanceof IncomingFileTransferException && ((IncomingFileTransferException) t).getErrorCode() == 404))
+			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.ARTIFACT_NOT_FOUND, NLS.bind(Messages.artifact_not_found, toDownload), t);
+		if (t instanceof ConnectException)
+			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_READ, NLS.bind(Messages.TransportErrorTranslator_UnableToConnectToRepository_0, toDownload), t);
+		if (t instanceof UnknownHostException)
+			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_INVALID_LOCATION, NLS.bind(Messages.TransportErrorTranslator_UnknownHost, toDownload), t);
+		if (t instanceof IDCreateException) {
+			IStatus status = ((IDCreateException) t).getStatus();
+			if (status != null && status.getException() != null)
+				t = status.getException();
+
+			return new DownloadStatus(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_INVALID_LOCATION, NLS.bind(Messages.TransportErrorTranslator_MalformedRemoteFileReference, toDownload), t);
+		}
+		int code = 0;
+
+		// default to report as read repository error
+		int provisionCode = ProvisionException.REPOSITORY_FAILED_READ;
+
+		if (t instanceof IncomingFileTransferException)
+			code = ((IncomingFileTransferException) t).getErrorCode();
+		else if (t instanceof BrowseFileTransferException)
+			code = ((BrowseFileTransferException) t).getErrorCode();
+
+		// Switch on error codes in the HTTP error code range. 
+		// Note that 404 uses ARTIFACT_NOT_FOUND (as opposed to REPOSITORY_NOT_FOUND, which
+		// is determined higher up in the calling chain).
+		if (code == 401)
+			provisionCode = ProvisionException.REPOSITORY_FAILED_AUTHENTICATION;
+		else if (code == 404)
+			provisionCode = ProvisionException.ARTIFACT_NOT_FOUND;
+
+		// Add more specific translation here
+
+		return new DownloadStatus(IStatus.ERROR, Activator.ID, provisionCode, //
+				code == 0 ? NLS.bind(Messages.io_failedRead, toDownload) //
+						: RepositoryStatus.codeToMessage(code, toDownload.toString()), t);
+	}
+
+	@Override
+	public Object createService(IProvisioningAgent agent) {
+		if (instance ==  null)
+			return instance;
+		return instance;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/messages.properties b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/messages.properties
new file mode 100644
index 0000000..4e59267
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.transport.ecf/src/org/eclipse/equinox/internal/p2/transport/ecf/messages.properties
@@ -0,0 +1,76 @@
+###############################################################################
+#  Copyright (c) 2007, 2010 IBM Corporation and others.
+#  All rights reserved. This program and the accompanying materials
+#  are made available under the terms of the Eclipse Public License v1.0
+#  which accompanies this distribution, and is available at
+#  http://www.eclipse.org/legal/epl-v10.html
+# 
+#  Contributors:
+#     IBM Corporation - initial API and implementation
+#     Cloudsmith Inc - additional messages
+#     Sonatype Inc - ongoing implementation
+###############################################################################
+artifact_not_found=Artifact not found: {0}.
+
+io_failedRead=Unable to read repository at {0}.
+ecf_configuration_error=Transport initialization error.
+
+
+repoMan_internalError=Internal error.
+repo_loading = Loading the repository {0}
+
+CacheManager_Neither_0_nor_1_found=Neither {0} nor {1} found.
+CacheManager_AuthenticationFaileFor_0=Authentication failed for {0}.
+CacheManager_FailedCommunicationWithRepo_0=Communication with repository at {0} failed.
+CacheManage_ErrorRenamingCache=An error occurred while downloading {0}. The cache file {1} could not be renamed to {1}.
+
+exception_malformedRepoURI = The repository location ({0}) must be a URI.
+
+TransportErrorTranslator_400=Bad HTTP Request: {0}
+TransportErrorTranslator_401=Authentication Failed - Unauthorized: {0}
+TransportErrorTranslator_402=HTTP Payment Required: {0}
+TransportErrorTranslator_403=HTTP Access Forbidden: {0}
+TransportErrorTranslator_404=HTTP Remote File Not Found: {0}
+TransportErrorTranslator_405=HTTP Method Not Allowed: {0}
+TransportErrorTranslator_406=HTTP Request Not Acceptable: {0}
+TransportErrorTranslator_407=HTTP Proxy Authentication Required: {0}
+TransportErrorTranslator_408=HTTP Request Timeout: {0}
+TransportErrorTranslator_409=HTTP Conflict In Request: {0}
+TransportErrorTranslator_410=HTTP Remote File Permanently Removed: {0}
+TransportErrorTranslator_411=HTTP Length Required: {0}
+TransportErrorTranslator_412=HTTP Precondition Failed: {0}
+TransportErrorTranslator_413=HTTP Requested Entity Too Large: {0}
+TransportErrorTranslator_414=HTTP Request URI Too Long: {0}
+TransportErrorTranslator_415=HTTP Unsupported Media Type: {0}
+TransportErrorTranslator_416=HTTP Requested Range Not Satisfiable: {0}
+TransportErrorTranslator_417=HTTP Expectation Failed: {0}
+TransportErrorTranslator_418=HTTP Cannot provision coffee from a tea pot: {0}
+TransportErrorTranslator_422=HTTP (WebDav) Unprocessable Entity: {0}
+TransportErrorTranslator_423=HTTP (WebDAV) Locked: {0}
+TransportErrorTranslator_424=HTTP (WebDAV) Failed Dependency: {0}
+TransportErrorTranslator_425=HTTP Unordered Collection: {0}
+TransportErrorTranslator_426=HTTP Upgrade Required: {0}
+TransportErrorTranslator_449=HTTP Retry With Response: {0}
+TransportErrorTranslator_450=HTTP Blocked By Parental Control: {0}
+TransportErrorTranslator_500=HTTP Server ''Internal Error'': {0}
+TransportErrorTranslator_501=HTTP Server ''Not Implemented'': {0}
+TransportErrorTranslator_502=HTTP Server ''Bad Gateway'' : {0}
+TransportErrorTranslator_503=HTTP Server ''Service Unavailable'': {0}
+TransportErrorTranslator_504=HTTP Server ''Gateway Timeout'': {0}
+TransportErrorTranslator_505=HTTP Server ''HTTP Version Not Supported'': {0}
+TransportErrorTranslator_506=HTTP Server ''Variant Also Negotiates'': {0}
+TransportErrorTranslator_507=HTTP (WebDAV) ''Insufficient Storage'': {0}
+TransportErrorTranslator_508=HTTP Server ''Bandwidth Limit Exceeded'': {0}
+TransportErrorTranslator_510=HTTP Server ''Not Extended'': {0}
+TransportErrorTranslator_MalformedRemoteFileReference=Malformed reference to remote file: {0}
+TransportErrorTranslator_UnableToConnectToRepository_0=Unable to connect to repository {0}
+TransportErrorTranslator_UnknownErrorCode=HTTP Server Unknown HTTP Response Code ({0}):{1}
+TransportErrorTranslator_UnknownHost=Unknown Host: {0}
+fetching_0_from_1_2_at_3=Fetching {0} ({2} at {3}/s) from {1}
+fetching_0_from_1_2_of_3_at_4=Fetching {0} ({2} of {3} at {4}/s) from {1}
+FileTransport_reader=File Transport Reader
+FileTransport_cancelCheck=File Transport Cancel Handler
+connection_to_0_failed_on_1_retry_attempt_2=Connection to {0} failed on {1}. Retry attempt {2} started
+UnableToRead_0_TooManyAttempts=Unable to read repository at: {0}. Too many failed login attempts.
+UnableToRead_0_UserCanceled=Unable to read repository at: {0}. Login canceled by user.
+RepositoryTransport_failedReadRepo=Error while reading from repository: {0}.
diff --git a/bundles/org.eclipse.equinox.p2.ui.admin.rcp/rcp.product b/bundles/org.eclipse.equinox.p2.ui.admin.rcp/rcp.product
index 369053a..3c0b299 100644
--- a/bundles/org.eclipse.equinox.p2.ui.admin.rcp/rcp.product
+++ b/bundles/org.eclipse.equinox.p2.ui.admin.rcp/rcp.product
@@ -185,6 +185,7 @@ Java and all Java-based trademarks are trademarks of Sun Microsystems, Inc. in t
       <plugin id="org.eclipse.equinox.p2.repository.tools"/>
       <plugin id="org.eclipse.equinox.p2.touchpoint.eclipse"/>
       <plugin id="org.eclipse.equinox.p2.touchpoint.natives"/>
+      <plugin id="org.eclipse.equinox.p2.transport.ecf"/>
       <plugin id="org.eclipse.equinox.p2.ui"/>
       <plugin id="org.eclipse.equinox.p2.ui.admin"/>
       <plugin id="org.eclipse.equinox.p2.ui.admin.rcp"/>
diff --git a/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/CategoryXMLAction.java b/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/CategoryXMLAction.java
index 8a48a09..2f6eaa2 100644
--- a/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/CategoryXMLAction.java
+++ b/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/CategoryXMLAction.java
@@ -1,18 +1,18 @@
 /******************************************************************************* 
-* Copyright (c) 2009 EclipseSource and others. All rights reserved. This
+* Copyright (c) 2009, 2010 EclipseSource and others. All rights reserved. This
 * program and the accompanying materials are made available under the terms of
 * the Eclipse Public License v1.0 which accompanies this distribution, and is
 * available at http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   EclipseSource - initial API and implementation
+*   Sonatype, Inc. - transport split
 ******************************************************************************/
 package org.eclipse.equinox.internal.p2.updatesite;
 
-import org.eclipse.equinox.p2.core.ProvisionException;
-
 import java.net.URI;
 import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.publisher.IPublisherInfo;
 import org.eclipse.equinox.p2.publisher.IPublisherResult;
 
@@ -28,7 +28,7 @@ public class CategoryXMLAction extends SiteXMLAction {
 
 	public IStatus perform(IPublisherInfo publisherInfo, IPublisherResult results, IProgressMonitor monitor) {
 		try {
-			updateSite = UpdateSite.loadCategoryFile(location, monitor);
+			updateSite = UpdateSite.loadCategoryFile(location, getTransport(publisherInfo), monitor);
 		} catch (ProvisionException e) {
 			return new Status(IStatus.ERROR, Activator.ID, Messages.Error_generating_category, e);
 		}
diff --git a/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/SiteXMLAction.java b/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/SiteXMLAction.java
index 4d5bd40..c11ac07 100644
--- a/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/SiteXMLAction.java
+++ b/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/SiteXMLAction.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2009 Code 9 and others. All rights reserved. This
+ * Copyright (c) 2008, 2010 Code 9 and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -7,6 +7,7 @@
  * Contributors: 
  *   Code 9 - initial API and implementation
  *   IBM - ongoing development
+ *   Sonatype, Inc. - transport split
  ******************************************************************************/
 package org.eclipse.equinox.internal.p2.updatesite;
 
@@ -18,6 +19,7 @@ import java.util.Map.Entry;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.CollectionUtils;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.metadata.MetadataFactory.InstallableUnitDescription;
@@ -88,7 +90,7 @@ public class SiteXMLAction extends AbstractPublisherAction {
 	public IStatus perform(IPublisherInfo publisherInfo, IPublisherResult results, IProgressMonitor monitor) {
 		if (updateSite == null) {
 			try {
-				updateSite = UpdateSite.load(location, monitor);
+				updateSite = UpdateSite.load(location, (Transport) publisherInfo.getMetadataRepository().getProvisioningAgent().getService(Transport.SERVICE_NAME), monitor);
 			} catch (ProvisionException e) {
 				return new Status(IStatus.ERROR, Activator.ID, Messages.Error_generating_siteXML, e);
 			} catch (OperationCanceledException e) {
@@ -408,4 +410,14 @@ public class SiteXMLAction extends AbstractPublisherAction {
 			return URIUtil.toUnencodedString(updateSite.getLocation()) + "." + categoryName; //$NON-NLS-1$
 		return categoryName;
 	}
+
+	protected Transport getTransport(IPublisherInfo info) {
+		@SuppressWarnings("rawtypes")
+		IRepository repo = info.getMetadataRepository();
+		if (repo == null)
+			repo = info.getArtifactRepository();
+		if (repo == null)
+			throw new IllegalStateException("The transport service can not be found."); //$NON-NLS-1$
+		return (Transport) repo.getProvisioningAgent().getService(Transport.SERVICE_NAME);
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/UpdateSite.java b/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/UpdateSite.java
index 6c09b54..00a37b5 100644
--- a/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/UpdateSite.java
+++ b/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/UpdateSite.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- *  Copyright (c) 2008, 2009 IBM Corporation and others.
+ *  Copyright (c) 2008, 2010 IBM Corporation and others.
  *  All rights reserved. This program and the accompanying materials
  *  are made available under the terms of the Eclipse Public License v1.0
  *  which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  * 
  *  Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Sonatype, Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.updatesite;
 
@@ -19,7 +20,7 @@ import java.util.zip.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
 import org.eclipse.equinox.internal.p2.publisher.eclipse.FeatureParser;
-import org.eclipse.equinox.internal.p2.repository.RepositoryTransport;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.publisher.eclipse.*;
 import org.eclipse.osgi.util.NLS;
@@ -54,6 +55,7 @@ public class UpdateSite {
 	private static Map<String, SoftReference<UpdateSite>> categoryCache = new HashMap<String, SoftReference<UpdateSite>>();
 	// map of String (featureID_featureVersion) to Feature
 	private Map<String, Feature> featureCache = new HashMap<String, Feature>();
+	private Transport transport;
 
 	/*
 	 * Return a URI based on the given URI, which points to a site.xml file.
@@ -79,7 +81,7 @@ public class UpdateSite {
 	 * @return A CategoryFile
 	 * @throws ProvisionException
 	 */
-	public static synchronized UpdateSite loadCategoryFile(URI location, IProgressMonitor monitor) throws ProvisionException {
+	public static synchronized UpdateSite loadCategoryFile(URI location, Transport transport, IProgressMonitor monitor) throws ProvisionException {
 		if (location == null)
 			return null;
 		UpdateSite result = null;
@@ -92,14 +94,14 @@ public class UpdateSite {
 		}
 
 		InputStream input = null;
-		File siteFile = loadActualSiteFile(location, location, monitor);
+		File siteFile = loadActualSiteFile(location, location, transport, monitor);
 		try {
 			CategoryParser siteParser = new CategoryParser(location);
 			Checksum checksum = new CRC32();
 			input = new CheckedInputStream(new BufferedInputStream(new FileInputStream(siteFile)), checksum);
 			SiteModel siteModel = siteParser.parse(input);
 			String checksumString = Long.toString(checksum.getValue());
-			result = new UpdateSite(siteModel, location, checksumString);
+			result = new UpdateSite(siteModel, location, transport, checksumString);
 			if (!PROTOCOL_FILE.equals(location.getScheme()))
 				categoryCache.put(location.toString(), new SoftReference<UpdateSite>(result));
 			return result;
@@ -124,7 +126,7 @@ public class UpdateSite {
 	/*
 	 * Load and return an update site object from the given location.
 	 */
-	public static synchronized UpdateSite load(URI location, IProgressMonitor monitor) throws ProvisionException {
+	public static synchronized UpdateSite load(URI location, Transport transport, IProgressMonitor monitor) throws ProvisionException {
 		if (location == null)
 			return null;
 
@@ -139,14 +141,14 @@ public class UpdateSite {
 		}
 
 		InputStream input = null;
-		File siteFile = loadSiteFile(location, monitor);
+		File siteFile = loadActualSiteFile(location, getSiteURI(location), transport, monitor);
 		try {
 			DefaultSiteParser siteParser = new DefaultSiteParser(location);
 			Checksum checksum = new CRC32();
 			input = new CheckedInputStream(new BufferedInputStream(new FileInputStream(siteFile)), checksum);
 			SiteModel siteModel = siteParser.parse(input);
 			String checksumString = Long.toString(checksum.getValue());
-			result = new UpdateSite(siteModel, getSiteURI(location), checksumString);
+			result = new UpdateSite(siteModel, getSiteURI(location), transport, checksumString);
 			if (!PROTOCOL_FILE.equals(location.getScheme()))
 				siteCache.put(location.toString(), new SoftReference<UpdateSite>(result));
 			return result;
@@ -168,14 +170,10 @@ public class UpdateSite {
 		}
 	}
 
-	private static File loadSiteFile(URI location, IProgressMonitor monitor) throws ProvisionException {
-		return loadActualSiteFile(location, getSiteURI(location), monitor);
-	}
-
 	/**
 	 * Returns a local file containing the contents of the update site at the given location.
 	 */
-	private static File loadActualSiteFile(URI location, URI actualLocation, IProgressMonitor monitor) throws ProvisionException {
+	private static File loadActualSiteFile(URI location, URI actualLocation, Transport transport, IProgressMonitor monitor) throws ProvisionException {
 		SubMonitor submonitor = SubMonitor.convert(monitor, 1000);
 		try {
 			File siteFile = null;
@@ -201,7 +199,7 @@ public class UpdateSite {
 						throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, ProvisionException.INTERNAL_ERROR, "Can not create tempfile for site.xml", e)); //$NON-NLS-1$
 					}
 					try {
-						transferResult = getTransport().download(actualLocation, destination, submonitor.newChild(999));
+						transferResult = transport.download(actualLocation, destination, submonitor.newChild(999));
 					} finally {
 						try {
 							destination.close();
@@ -248,7 +246,7 @@ public class UpdateSite {
 	 * Parse the feature.xml specified by the given input stream and return the feature object.
 	 * In case of failure, the failure is logged and null is returned
 	 */
-	private static Feature parseFeature(FeatureParser featureParser, URI featureURI, IProgressMonitor monitor) {
+	private Feature parseFeature(FeatureParser featureParser, URI featureURI, IProgressMonitor monitor) {
 		File featureFile = null;
 		if (PROTOCOL_FILE.equals(featureURI.getScheme())) {
 			featureFile = URIUtil.toFile(featureURI);
@@ -263,7 +261,7 @@ public class UpdateSite {
 					throw new OperationCanceledException();
 				OutputStream destination = new BufferedOutputStream(new FileOutputStream(featureFile));
 				try {
-					transferResult = getTransport().download(featureURI, destination, monitor);
+					transferResult = transport.download(featureURI, destination, monitor);
 				} finally {
 					try {
 						destination.close();
@@ -294,13 +292,13 @@ public class UpdateSite {
 	/*
 	 * Constructor for the class.
 	 */
-	private UpdateSite(SiteModel site, URI location, String checksum) {
+	private UpdateSite(SiteModel site, URI location, Transport transport, String checksum) {
 		super();
 		this.site = site;
 		this.location = location;
 		this.checksum = checksum;
 		this.rootLocation = getRootLocation();
-
+		this.transport = transport;
 	}
 
 	private URI getRootLocation() {
@@ -458,7 +456,7 @@ public class UpdateSite {
 				BufferedOutputStream destination = new BufferedOutputStream(new FileOutputStream(digestFile));
 				IStatus result = null;
 				try {
-					result = getTransport().download(digestURI, destination, monitor);
+					result = transport.download(digestURI, destination, monitor);
 				} finally {
 					try {
 						destination.close();
@@ -572,8 +570,4 @@ public class UpdateSite {
 			}
 		}
 	}
-
-	private static RepositoryTransport getTransport() {
-		return RepositoryTransport.getInstance();
-	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/artifact/UpdateSiteArtifactRepositoryFactory.java b/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/artifact/UpdateSiteArtifactRepositoryFactory.java
index 8a65d2d..ca6343a 100644
--- a/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/artifact/UpdateSiteArtifactRepositoryFactory.java
+++ b/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/artifact/UpdateSiteArtifactRepositoryFactory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2009 IBM Corporation and others.
+ * Copyright (c) 2008, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,6 +8,7 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Code 9 - ongoing development
+ *     Sonatype, Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.updatesite.artifact;
 
@@ -16,6 +17,7 @@ import java.util.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactDescriptor;
 import org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepositoryFactory;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.internal.p2.updatesite.*;
 import org.eclipse.equinox.internal.p2.updatesite.metadata.UpdateSiteMetadataRepositoryFactory;
 import org.eclipse.equinox.p2.core.ProvisionException;
@@ -83,7 +85,7 @@ public class UpdateSiteArtifactRepositoryFactory extends ArtifactRepositoryFacto
 	}
 
 	public void initializeRepository(IArtifactRepository repository, URI location, IProgressMonitor monitor) throws ProvisionException {
-		UpdateSite updateSite = UpdateSite.load(location, monitor);
+		UpdateSite updateSite = UpdateSite.load(location, (Transport) getAgent().getService(Transport.SERVICE_NAME), monitor);
 		String savedChecksum = repository.getProperties().get(PROP_SITE_CHECKSUM);
 		if (savedChecksum != null && savedChecksum.equals(updateSite.getChecksum()))
 			return;
diff --git a/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/metadata/UpdateSiteMetadataRepositoryFactory.java b/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/metadata/UpdateSiteMetadataRepositoryFactory.java
index 7a91126..d92c82f 100644
--- a/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/metadata/UpdateSiteMetadataRepositoryFactory.java
+++ b/bundles/org.eclipse.equinox.p2.updatesite/src/org/eclipse/equinox/internal/p2/updatesite/metadata/UpdateSiteMetadataRepositoryFactory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2009 IBM Corporation and others.
+ * Copyright (c) 2008, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Ray Braithwood (ray@genuitec.com) - fix for bug 220605
  *     Code 9 - ongoing development
+ *     Sonatype, Inc. - transport split
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.updatesite.metadata;
 
@@ -18,6 +19,7 @@ import java.util.Map;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.metadata.repository.LocalMetadataRepository;
 import org.eclipse.equinox.internal.p2.metadata.repository.SimpleMetadataRepositoryFactory;
+import org.eclipse.equinox.internal.p2.repository.Transport;
 import org.eclipse.equinox.internal.p2.updatesite.*;
 import org.eclipse.equinox.p2.core.ProvisionException;
 import org.eclipse.equinox.p2.publisher.*;
@@ -82,7 +84,7 @@ public class UpdateSiteMetadataRepositoryFactory extends MetadataRepositoryFacto
 	}
 
 	public void initializeRepository(IMetadataRepository repository, URI location, IProgressMonitor monitor) throws ProvisionException {
-		UpdateSite updateSite = UpdateSite.load(location, monitor);
+		UpdateSite updateSite = UpdateSite.load(location, (Transport) getAgent().getService(Transport.SERVICE_NAME), monitor);
 		String savedChecksum = repository.getProperties().get(PROP_SITE_CHECKSUM);
 		if (savedChecksum != null && savedChecksum.equals(updateSite.getChecksum()))
 			return;
diff --git a/features/org.eclipse.equinox.p2.sdk/feature.xml b/features/org.eclipse.equinox.p2.sdk/feature.xml
index 2cf7bab..32f7268 100644
--- a/features/org.eclipse.equinox.p2.sdk/feature.xml
+++ b/features/org.eclipse.equinox.p2.sdk/feature.xml
@@ -654,4 +654,11 @@
          version="0.0.0"
          unpack="false"/>
 
+   <plugin
+         id="org.eclipse.equinox.p2.transport.ecf"
+         download-size="0"
+         install-size="0"
+         version="0.0.0"
+         unpack="false"/>
+
 </feature>
diff --git a/org.eclipse.equinox.p2.releng/buildtime-features/org.eclipse.equinox.p2.user.ui/feature.xml b/org.eclipse.equinox.p2.releng/buildtime-features/org.eclipse.equinox.p2.user.ui/feature.xml
index 54ac680..99be41f 100644
--- a/org.eclipse.equinox.p2.releng/buildtime-features/org.eclipse.equinox.p2.user.ui/feature.xml
+++ b/org.eclipse.equinox.p2.releng/buildtime-features/org.eclipse.equinox.p2.user.ui/feature.xml
@@ -329,4 +329,11 @@
          version="0.0.0"
          unpack="false"/>
 
+   <plugin
+         id="org.eclipse.equinox.p2.transport.ecf"
+         download-size="0"
+         install-size="0"
+         version="0.0.0"
+         unpack="false"/>
+
 </feature>
