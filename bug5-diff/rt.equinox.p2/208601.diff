commit 2d89b637160ea46a111578a346c955734dabcd69
Author: John Arthorne <johna>
Date:   Thu Nov 13 20:42:50 2008 +0000

    Bug 208601 Composite repositories

5	0	bundles/org.eclipse.equinox.p2.artifact.repository/plugin.xml
404	0	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/CompositeArtifactRepository.java
120	0	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/CompositeArtifactRepositoryFactory.java
1	0	bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/provisional/p2/artifact/repository/IArtifactRepositoryManager.java
81	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeParser.java
283	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeRepositoryIO.java
45	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeWriter.java
4	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/Messages.java
4	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/XMLConstants.java
11	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/XMLParser.java
6	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/messages.properties
41	0	bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/repository/ICompositeRepository.java
4	0	bundles/org.eclipse.equinox.p2.metadata.repository/plugin.xml
215	0	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/CompositeMetadataRepository.java
158	0	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/CompositeMetadataRepositoryFactory.java
1	0	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/provisional/p2/metadata/repository/IMetadataRepositoryManager.java
1	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/AllTests.java
408	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CompositeArtifactRepositoryTest.java
1	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/AllTests.java
387	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/CompositeMetadataRepositoryTest.java
35	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/mirror/ArtifactMirrorApplicationTest.java
35	0	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/mirror/MetadataMirrorApplicationTest.java
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/plugin.xml b/bundles/org.eclipse.equinox.p2.artifact.repository/plugin.xml
index f90876e..28429af 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/plugin.xml
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/plugin.xml
@@ -14,6 +14,11 @@
 		<filter suffix="artifacts.xml"/>
 		<factory class="org.eclipse.equinox.internal.provisional.spi.p2.artifact.repository.SimpleArtifactRepositoryFactory"/>
    </extension>
+   
+   <extension id="compositeRepository"  point="org.eclipse.equinox.p2.artifact.repository.artifactRepositories">
+        <filter suffix="compositeArtifacts.xml"/>
+        <factory class="org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepositoryFactory"/>
+   </extension>
 
 	<extension
 			point="org.eclipse.equinox.p2.artifact.repository.processingSteps"
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/CompositeArtifactRepository.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/CompositeArtifactRepository.java
new file mode 100644
index 0000000..84abdc0
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/CompositeArtifactRepository.java
@@ -0,0 +1,404 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.artifact.repository;
+
+import java.io.*;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.*;
+import java.util.jar.JarEntry;
+import java.util.jar.JarOutputStream;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.core.helpers.*;
+import org.eclipse.equinox.internal.p2.persistence.CompositeRepositoryIO;
+import org.eclipse.equinox.internal.p2.persistence.CompositeRepositoryIO.CompositeRepositoryState;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.*;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.ICompositeRepository;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IArtifactKey;
+import org.eclipse.equinox.internal.provisional.spi.p2.artifact.repository.AbstractArtifactRepository;
+
+public class CompositeArtifactRepository extends AbstractArtifactRepository implements IArtifactRepository, ICompositeRepository {
+
+	static final public String REPOSITORY_TYPE = CompositeArtifactRepository.class.getName();
+	static final private Integer REPOSITORY_VERSION = new Integer(1);
+	static final public String XML_EXTENSION = ".xml"; //$NON-NLS-1$
+	static final public String JAR_EXTENSION = ".jar"; //$NON-NLS-1$
+	static final public String CONTENT_FILENAME = "compositeArtifacts"; //$NON-NLS-1$
+
+	private ArrayList childrenURIs = new ArrayList();
+
+	private IArtifactRepositoryManager getManager() {
+		return (IArtifactRepositoryManager) ServiceHelper.getService(Activator.getContext(), IArtifactRepositoryManager.class.getName());
+	}
+
+	/*
+	 * This is only called by the parser when loading a repository.
+	 */
+	public CompositeArtifactRepository(CompositeRepositoryState state) {
+		super(state.Name, state.Type, state.Version, null, state.Description, state.Provider, state.Properties);
+		for (int i = 0; i < state.Children.length; i++) {
+			//duplicate checking
+			if (!childrenURIs.contains(state.Children[i]))
+				childrenURIs.add(state.Children[i]);
+		}
+	}
+
+	public CompositeArtifactRepository(String repositoryName, URI location, Map properties) {
+		super(repositoryName, REPOSITORY_TYPE, REPOSITORY_VERSION.toString(), location, null, null, properties);
+		initializeAfterLoad(location);
+		save();
+	}
+
+	public CompositeArtifactRepository(URI location, String name, Map properties) {
+		super(name == null ? (location != null ? location.toString() : "") : name, REPOSITORY_TYPE, REPOSITORY_VERSION.toString(), location, null, null, properties); //$NON-NLS-1$
+		save();
+	}
+
+	public static URI getActualLocation(URI base, boolean compress) {
+		return getActualLocation(base, compress ? JAR_EXTENSION : XML_EXTENSION);
+	}
+
+	private static URI getActualLocation(URI base, String extension) {
+		final String name = CONTENT_FILENAME + extension;
+		String spec = base.toString();
+		if (spec.endsWith(name))
+			return base;
+		if (spec.endsWith("/")) //$NON-NLS-1$
+			spec += name;
+		else
+			spec += "/" + name; //$NON-NLS-1$
+		try {
+			return new URI(spec);
+		} catch (URISyntaxException e) {
+			return null;
+		}
+	}
+
+	private boolean isLocal() {
+		return "file".equalsIgnoreCase(location.getScheme()); //$NON-NLS-1$
+	}
+
+	public boolean isModifiable() {
+		return isLocal();
+	}
+
+	// use this method to setup any transient fields etc after the object has been restored from a stream
+	public synchronized void initializeAfterLoad(URI location) {
+		this.location = location;
+	}
+
+	public void addChild(URI childURI) {
+		if (!childrenURIs.contains(childURI)) {
+			childrenURIs.add(childURI);
+			save();
+		}
+	}
+
+	public void removeChild(URI childURI) {
+		childrenURIs.remove(childURI);
+		save();
+	}
+
+	public void removeAllChildren() {
+		childrenURIs.clear();
+		save();
+	}
+
+	public ArrayList getChildren() {
+		return childrenURIs;
+	}
+
+	/**
+	 * Composite repositories should be unable to directly modify their sub repositories
+	 */
+	public synchronized void addDescriptor(IArtifactDescriptor descriptor) {
+		throw new UnsupportedOperationException("Cannot add descriptors to a composite repository");
+	}
+
+	/**
+	 * Composite repositories should be unable to directly modify their sub repositories
+	 */
+	public void addDescriptors(IArtifactDescriptor[] descriptors) {
+		throw new UnsupportedOperationException("Cannot add descriptors to a composite repository");
+	}
+
+	/**
+	 * Composite repositories should be unable to directly modify their sub repositories
+	 */
+	public void removeDescriptor(IArtifactKey key) {
+		throw new UnsupportedOperationException("Cannot remove descriptors from a composite repository");
+	}
+
+	/**
+	 * Composite repositories should be unable to directly modify their sub repositories
+	 */
+	public void removeDescriptor(IArtifactDescriptor descriptor) {
+		throw new UnsupportedOperationException("Cannot remove descriptors from a composite repository");
+	}
+
+	/**
+	 * Composite repositories should be unable to directly modify their sub repositories
+	 */
+	public synchronized void removeAll() {
+		throw new UnsupportedOperationException("Cannot remove descriptors from a composite repository");
+	}
+
+	public boolean contains(IArtifactKey key) {
+		boolean contains = false;
+		for (Iterator repositoryIterator = childrenURIs.iterator(); repositoryIterator.hasNext() && !contains;) {
+			try {
+				URI currentURI = (URI) repositoryIterator.next();
+				boolean currentLoaded = getManager().contains(currentURI);
+				IArtifactRepository current = getManager().loadRepository(currentURI, null);
+				if (!currentLoaded) {
+					//set enabled to false so repositories do not polled twice
+					getManager().setEnabled(currentURI, false);
+					//set repository to system to hide from users
+					current.setProperty(IRepository.PROP_SYSTEM, "true");
+				}
+				contains = current.contains(key);
+			} catch (ProvisionException e) {
+				//repository failed to load. fall through
+				LogHelper.log(e);
+			}
+		}
+		return contains;
+	}
+
+	public boolean contains(IArtifactDescriptor descriptor) {
+		boolean contains = false;
+		for (Iterator repositoryIterator = childrenURIs.iterator(); repositoryIterator.hasNext() && !contains;) {
+			try {
+				URI currentURI = (URI) repositoryIterator.next();
+				boolean currentLoaded = getManager().contains(currentURI);
+				IArtifactRepository current = getManager().loadRepository(currentURI, null);
+				if (!currentLoaded) {
+					//set enabled to false so repositories do not polled twice
+					getManager().setEnabled(currentURI, false);
+					//set repository to system to hide from users
+					current.setProperty(IRepository.PROP_SYSTEM, "true");
+				}
+				contains = current.contains(descriptor);
+			} catch (ProvisionException e) {
+				//repository failed to load. fall through
+				LogHelper.log(e);
+			}
+		}
+		return contains;
+	}
+
+	public IArtifactDescriptor[] getArtifactDescriptors(IArtifactKey key) {
+		ArrayList result = new ArrayList();
+		for (Iterator repositoryIterator = childrenURIs.iterator(); repositoryIterator.hasNext();) {
+			try {
+				URI currentURI = (URI) repositoryIterator.next();
+				boolean currentLoaded = getManager().contains(currentURI);
+				IArtifactRepository current = getManager().loadRepository(currentURI, null);
+				if (!currentLoaded) {
+					//set enabled to false so repositories do not polled twice
+					getManager().setEnabled(currentURI, false);
+					//set repository to system to hide from users
+					current.setProperty(IRepository.PROP_SYSTEM, "true");
+				}
+				IArtifactDescriptor[] tempResult = current.getArtifactDescriptors(key);
+				for (int i = 0; i < tempResult.length; i++)
+					//duplicate checking
+					if (!result.contains(tempResult[i]))
+						result.add(tempResult[i]);
+			} catch (ProvisionException e) {
+				//repository failed to load. fall through
+				LogHelper.log(e);
+			}
+		}
+		return (IArtifactDescriptor[]) result.toArray(new IArtifactDescriptor[result.size()]);
+	}
+
+	public IArtifactKey[] getArtifactKeys() {
+		ArrayList result = new ArrayList();
+		for (Iterator repositoryIterator = childrenURIs.iterator(); repositoryIterator.hasNext();) {
+			try {
+				URI currentURI = (URI) repositoryIterator.next();
+				boolean currentLoaded = getManager().contains(currentURI);
+				IArtifactRepository current = getManager().loadRepository(currentURI, null);
+				if (!currentLoaded) {
+					//set enabled to false so repositories do not polled twice
+					getManager().setEnabled(currentURI, false);
+					//set repository to system to hide from users
+					current.setProperty(IRepository.PROP_SYSTEM, "true");
+				}
+				IArtifactKey[] tempResult = current.getArtifactKeys();
+				for (int i = 0; i < tempResult.length; i++)
+					//duplicate checking
+					if (!result.contains(tempResult[i]))
+						result.add(tempResult[i]);
+			} catch (ProvisionException e) {
+				//repository failed to load. fall through
+				LogHelper.log(e);
+			}
+		}
+		return (IArtifactKey[]) result.toArray(new IArtifactKey[result.size()]);
+	}
+
+	public IStatus getArtifacts(IArtifactRequest[] requests, IProgressMonitor monitor) {
+		SubMonitor subMonitor = SubMonitor.convert(monitor, requests.length);
+		MultiStatus multiStatus = new MultiStatus(Activator.ID, IStatus.OK, "Messages while trying children repositories.", null);
+		for (Iterator repositoryIterator = childrenURIs.iterator(); repositoryIterator.hasNext() && requests.length > 0;) {
+			try {
+				URI currentURI = (URI) repositoryIterator.next();
+				boolean currentLoaded = getManager().contains(currentURI);
+				IArtifactRepository current = getManager().loadRepository(currentURI, null);
+				if (!currentLoaded) {
+					//set enabled to false so repositories do not polled twice
+					getManager().setEnabled(currentURI, false);
+					//set repository to system to hide from users
+					current.setProperty(IRepository.PROP_SYSTEM, "true");
+				}
+				IArtifactRequest[] applicable = getRequestsForRepository(current, requests);
+				IStatus dlStatus = current.getArtifacts(applicable, subMonitor.newChild(requests.length));
+				multiStatus.add(dlStatus);
+				if (dlStatus.getSeverity() == IStatus.CANCEL)
+					return multiStatus;
+				requests = filterUnfetched(requests);
+				subMonitor.setWorkRemaining(requests.length);
+			} catch (ProvisionException e) {
+				//repository failed the load. Fall through.
+				LogHelper.log(e);
+			}
+		}
+		return multiStatus;
+	}
+
+	public IStatus getArtifact(IArtifactDescriptor descriptor, OutputStream destination, IProgressMonitor monitor) {
+		SubMonitor subMonitor = SubMonitor.convert(monitor, childrenURIs.size());
+		Iterator repositoryIterator = childrenURIs.iterator();
+		MultiStatus multiStatus = new MultiStatus(Activator.ID, IStatus.OK, "Messages while trying children repositories.", null);
+		while (repositoryIterator.hasNext()) {
+			try {
+				URI currentURI = (URI) repositoryIterator.next();
+				boolean currentLoaded = getManager().contains(currentURI);
+				IArtifactRepository current = getManager().loadRepository(currentURI, null);
+				if (!currentLoaded) {
+					//set enabled to false so repositories do not polled twice
+					getManager().setEnabled(currentURI, false);
+					//set repository to system to hide from users
+					current.setProperty(IRepository.PROP_SYSTEM, "true");
+				}
+				IStatus status = current.getArtifact(descriptor, destination, subMonitor.newChild(1));
+				if (status.isOK())
+					return status;
+				//getArtifact failed
+				multiStatus.add(status);
+			} catch (ProvisionException e) {
+				//repository failed the load. Fall through.
+				LogHelper.log(e);
+			}
+		}
+		return multiStatus;
+	}
+
+	public IStatus getRawArtifact(IArtifactDescriptor descriptor, OutputStream destination, IProgressMonitor monitor) {
+		SubMonitor subMonitor = SubMonitor.convert(monitor, childrenURIs.size());
+		Iterator repositoryIterator = childrenURIs.iterator();
+		MultiStatus multiStatus = new MultiStatus(Activator.ID, IStatus.OK, "Messages while trying children repositories.", null);
+		while (repositoryIterator.hasNext()) {
+			try {
+				URI currentURI = (URI) repositoryIterator.next();
+				boolean currentLoaded = getManager().contains(currentURI);
+				IArtifactRepository current = getManager().loadRepository(currentURI, null);
+				if (!currentLoaded) {
+					//set enabled to false so repositories do not polled twice
+					getManager().setEnabled(currentURI, false);
+					//set repository to system to hide from users
+					current.setProperty(IRepository.PROP_SYSTEM, "true");
+				}
+				IStatus status = current.getRawArtifact(descriptor, destination, subMonitor.newChild(1));
+				if (status.isOK())
+					return status;
+				//getRawArtifact failed
+				multiStatus.add(status);
+			} catch (ProvisionException e) {
+				//repository failed the load. Fall through.
+				LogHelper.log(e);
+			}
+		}
+		return multiStatus;
+	}
+
+	private IArtifactRequest[] filterUnfetched(IArtifactRequest[] requests) {
+		ArrayList filteredRequests = new ArrayList();
+		for (int i = 0; i < requests.length; i++) {
+			if (requests[i].getResult() == null || !requests[i].getResult().isOK()) {
+				filteredRequests.add(requests[i]);
+			}
+		}
+		return (IArtifactRequest[]) filteredRequests.toArray();
+	}
+
+	private IArtifactRequest[] getRequestsForRepository(IArtifactRepository repository, IArtifactRequest[] requests) {
+		ArrayList applicable = new ArrayList();
+		for (int i = 0; i < requests.length; i++) {
+			if (repository.contains(requests[i].getArtifactKey()))
+				applicable.add(requests[i]);
+		}
+		return (IArtifactRequest[]) applicable.toArray(new IArtifactRequest[applicable.size()]);
+	}
+
+	public void save() {
+		boolean compress = "true".equalsIgnoreCase((String) properties.get(PROP_COMPRESSED)); //$NON-NLS-1$
+		save(compress);
+	}
+
+	public void save(boolean compress) {
+		assertModifiable();
+		OutputStream os = null;
+		try {
+			try {
+				URI actualLocation = getActualLocation(location, false);
+				File artifactsFile = URIUtil.toFile(actualLocation);
+				File jarFile = URIUtil.toFile(getActualLocation(location, true));
+				if (!compress) {
+					if (jarFile.exists()) {
+						jarFile.delete();
+					}
+					if (!artifactsFile.exists()) {
+						// create parent folders
+						artifactsFile.getParentFile().mkdirs();
+					}
+					os = new FileOutputStream(artifactsFile);
+				} else {
+					if (artifactsFile.exists()) {
+						artifactsFile.delete();
+					}
+					if (!jarFile.exists()) {
+						if (!jarFile.getParentFile().exists())
+							jarFile.getParentFile().mkdirs();
+						jarFile.createNewFile();
+					}
+					JarOutputStream jOs = new JarOutputStream(new FileOutputStream(jarFile));
+					jOs.putNextEntry(new JarEntry(new Path(artifactsFile.getAbsolutePath()).lastSegment()));
+					os = jOs;
+				}
+				super.setProperty(IRepository.PROP_TIMESTAMP, Long.toString(System.currentTimeMillis()));
+				new CompositeRepositoryIO().write(this, os);
+			} catch (IOException e) {
+				// TODO proper exception handling
+				e.printStackTrace();
+			} finally {
+				if (os != null)
+					os.close();
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/CompositeArtifactRepositoryFactory.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/CompositeArtifactRepositoryFactory.java
new file mode 100644
index 0000000..c68e6e3
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/p2/artifact/repository/CompositeArtifactRepositoryFactory.java
@@ -0,0 +1,120 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.artifact.repository;
+
+import java.io.*;
+import java.net.URI;
+import java.util.Map;
+import java.util.jar.JarEntry;
+import java.util.jar.JarInputStream;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.core.helpers.Tracing;
+import org.eclipse.equinox.internal.p2.core.helpers.URIUtil;
+import org.eclipse.equinox.internal.p2.persistence.CompositeRepositoryIO;
+import org.eclipse.equinox.internal.p2.persistence.CompositeRepositoryIO.CompositeRepositoryState;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepository;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.spi.p2.artifact.repository.ArtifactRepositoryFactory;
+import org.eclipse.osgi.util.NLS;
+
+public class CompositeArtifactRepositoryFactory extends ArtifactRepositoryFactory {
+
+	public IArtifactRepository load(URI location, IProgressMonitor monitor) throws ProvisionException {
+		final String PROTOCOL_FILE = "file"; //$NON-NLS-1$
+		long time = 0;
+		final String debugMsg = "Restoring artifact repository "; //$NON-NLS-1$
+		if (Tracing.DEBUG_METADATA_PARSING) {
+			Tracing.debug(debugMsg + location);
+			time = -System.currentTimeMillis();
+		}
+		File localFile = null;
+		boolean local = false;
+		try {
+			SubMonitor sub = SubMonitor.convert(monitor, 300);
+			OutputStream artifacts = null;
+			// try with compressed
+			boolean compress = true;
+			if (PROTOCOL_FILE.equals(location.getScheme())) {
+				local = true;
+				localFile = new File(CompositeArtifactRepository.getActualLocation(location, true).getPath());
+				if (!localFile.exists()) {
+					localFile = new File(CompositeArtifactRepository.getActualLocation(location, false).getPath());
+					compress = false;
+				}
+			} else {
+				//download to local temp file
+				localFile = File.createTempFile(CompositeArtifactRepository.CONTENT_FILENAME, CompositeArtifactRepository.XML_EXTENSION); //$NON-NLS-1$ //$NON-NLS-2$
+				try {
+					artifacts = new BufferedOutputStream(new FileOutputStream(localFile));
+					IStatus status = getTransport().download(CompositeArtifactRepository.getActualLocation(location, compress).toString(), artifacts, sub.newChild(100));
+					if (!status.isOK()) {
+						// retry uncompressed
+						compress = false;
+						status = getTransport().download(CompositeArtifactRepository.getActualLocation(location, compress).toString(), artifacts, sub.newChild(100));
+						if (!status.isOK())
+							throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_NOT_FOUND, status.getMessage(), null));
+					}
+				} finally {
+					if (artifacts != null)
+						artifacts.close();
+				}
+			}
+			InputStream descriptorStream = null;
+			try {
+				descriptorStream = new BufferedInputStream(new FileInputStream(localFile));
+				if (compress) {
+					URI actualLocation = CompositeArtifactRepository.getActualLocation(location, false);
+					JarInputStream jInStream = new JarInputStream(descriptorStream);
+					JarEntry jarEntry = jInStream.getNextJarEntry();
+					String filename = URIUtil.lastSegment(actualLocation);
+					while (jarEntry != null && filename != null && !(filename.equals(jarEntry.getName()))) {
+						jarEntry = jInStream.getNextJarEntry();
+					}
+					if (jarEntry == null) {
+						throw new FileNotFoundException("Repository not found in " + actualLocation.getPath()); //$NON-NLS-1$
+					}
+					descriptorStream = jInStream;
+				}
+				CompositeRepositoryIO io = new CompositeRepositoryIO();
+				CompositeRepositoryState resultState = io.read(localFile.toURL(), descriptorStream, sub.newChild(100));
+
+				CompositeArtifactRepository result = new CompositeArtifactRepository(resultState);
+
+				result.initializeAfterLoad(location);
+				if (Tracing.DEBUG_METADATA_PARSING) {
+					time += System.currentTimeMillis();
+					Tracing.debug(debugMsg + "time (ms): " + time); //$NON-NLS-1$ 
+				}
+				return result;
+			} finally {
+				if (descriptorStream != null)
+					descriptorStream.close();
+			}
+		} catch (FileNotFoundException e) {
+			String msg = NLS.bind(Messages.io_failedRead, location);
+			throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_NOT_FOUND, msg, e));
+		} catch (IOException e) {
+			String msg = NLS.bind(Messages.io_failedRead, location);
+			throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_READ, msg, e));
+		} finally {
+			if (!local && localFile != null && !localFile.delete())
+				localFile.deleteOnExit();
+		}
+	}
+
+	public IArtifactRepository create(URI location, String name, String type, Map properties) {
+		return new CompositeArtifactRepository(name, location, properties);
+	}
+
+	private Transport getTransport() {
+		return ECFTransport.getInstance();
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/provisional/p2/artifact/repository/IArtifactRepositoryManager.java b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/provisional/p2/artifact/repository/IArtifactRepositoryManager.java
index 31ee6ac..7551214 100644
--- a/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/provisional/p2/artifact/repository/IArtifactRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.artifact.repository/src/org/eclipse/equinox/internal/provisional/p2/artifact/repository/IArtifactRepositoryManager.java
@@ -37,6 +37,7 @@ public interface IArtifactRepositoryManager extends IRepositoryManager {
 	 * Repository type for a simple repository based on a URL or local file system location.
 	 */
 	public static final String TYPE_SIMPLE_REPOSITORY = "org.eclipse.equinox.p2.artifact.repository.simpleRepository"; //$NON-NLS-1$
+	public static final String TYPE_COMPOSITE_REPOSITORY = "org.eclipse.equinox.p2.artifact.repository.compositeRepository"; //$NON-NLS-1$
 
 	/**
 	 * Return a new request to mirror the given artifact into the destination repository.
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeParser.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeParser.java
new file mode 100644
index 0000000..c62027c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeParser.java
@@ -0,0 +1,81 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.persistence;
+
+import java.net.URI;
+import java.util.*;
+import org.osgi.framework.BundleContext;
+import org.xml.sax.Attributes;
+
+public abstract class CompositeParser extends XMLParser implements XMLConstants {
+
+	public static final String REQUIRED_CAPABILITY_ELEMENT = "required"; //$NON-NLS-1$
+
+	public CompositeParser(BundleContext context, String bundleId) {
+		super(context, bundleId);
+	}
+
+	protected class ChildrenHandler extends AbstractHandler {
+		private ArrayList children;
+
+		public ChildrenHandler(AbstractHandler parentHandler, Attributes attributes) {
+			super(parentHandler, CHILDREN_ELEMENT);
+			String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
+			children = (size != null ? new ArrayList(new Integer(size).intValue()) : new ArrayList(4));
+		}
+
+		public URI[] getChildren() {
+			int size = children.size();
+			URI[] result = new URI[size];
+			int i = 0;
+			for (Iterator it = children.iterator(); it.hasNext(); i++) {
+				result[i] = (URI) it.next();
+			}
+			return result;
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			if (name.equals(CHILD_ELEMENT)) {
+				new ChildHandler(this, attributes, children);
+			} else {
+				invalidElement(name, attributes);
+			}
+		}
+	}
+
+	protected class ChildHandler extends AbstractHandler {
+		private final String[] required = new String[] {LOCATION_ELEMENT};
+		private final String[] optional = new String[] {};
+
+		URI currentRepo = null;
+
+		private List repos;
+
+		public ChildHandler(AbstractHandler parentHandler, Attributes attributes, List repos) {
+			super(parentHandler, CHILD_ELEMENT);
+			String[] values = parseAttributes(attributes, required, optional);
+			this.repos = repos;
+			//skip entire subrepository if the location is missing
+			if (values[0] == null)
+				return;
+			currentRepo = checkURI(REQUIRED_CAPABILITY_ELEMENT, URI_ATTRIBUTE, values[0]);
+
+		}
+
+		public void startElement(String name, Attributes attributes) {
+			checkCancel();
+		}
+
+		protected void finished() {
+			repos.add(currentRepo);
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeRepositoryIO.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeRepositoryIO.java
new file mode 100644
index 0000000..5be32d5
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeRepositoryIO.java
@@ -0,0 +1,283 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.persistence;
+
+import java.io.*;
+import java.net.URI;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Map;
+import javax.xml.parsers.ParserConfigurationException;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.core.Activator;
+import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
+import org.eclipse.equinox.internal.p2.core.helpers.OrderedProperties;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.ICompositeRepository;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
+import org.eclipse.osgi.service.resolver.VersionRange;
+import org.eclipse.osgi.util.NLS;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Version;
+import org.xml.sax.*;
+
+/**
+ * This class reads and writes composite repository metadata
+ * (e.g. table of contents files);
+ * 
+ * This class is not used for reading or writing the actual composite repositories.
+ */
+public class CompositeRepositoryIO {
+
+	public static class CompositeRepositoryState {
+		public String Name;
+		public String Type;
+		public String Version;
+		public String Provider;
+		public String Description;
+		public URI Location;
+		public Map Properties;
+		public URI[] Children;
+	}
+
+	/**
+	 * Writes the given repository to the stream.
+	 * This method performs buffering, and closes the stream when finished.
+	 */
+	public void write(ICompositeRepository repository, OutputStream output) {
+		OutputStream bufferedOutput = null;
+		try {
+			try {
+				bufferedOutput = new BufferedOutputStream(output);
+				Writer repositoryWriter = new Writer(bufferedOutput);
+				repositoryWriter.write(repository);
+			} finally {
+				if (bufferedOutput != null) {
+					bufferedOutput.close();
+				}
+			}
+		} catch (IOException ioe) {
+			// TODO shouldn't this throw a core exception?
+			ioe.printStackTrace();
+		}
+	}
+
+	/**
+	 * Reads the composite repository from the given stream,
+	 * and returns the contained array of abstract composite repositories.
+	 * 
+	 * This method performs buffering, and closes the stream when finished.
+	 */
+	public CompositeRepositoryState read(URL location, InputStream input, IProgressMonitor monitor) throws ProvisionException {
+		BufferedInputStream bufferedInput = null;
+		try {
+			try {
+				bufferedInput = new BufferedInputStream(input);
+				Parser repositoryParser = new Parser(Activator.getContext(), Activator.ID);
+				repositoryParser.parse(input);
+				IStatus result = repositoryParser.getStatus();
+				switch (result.getSeverity()) {
+					case IStatus.CANCEL :
+						throw new OperationCanceledException();
+					case IStatus.ERROR :
+						throw new ProvisionException(result);
+					case IStatus.WARNING :
+					case IStatus.INFO :
+						LogHelper.log(result);
+				}
+				CompositeRepositoryState repositoryState = repositoryParser.getRepositoryState();
+				if (repositoryState == null)
+					throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_READ, Messages.io_parseError, null));
+				return repositoryState;
+			} finally {
+				if (bufferedInput != null)
+					bufferedInput.close();
+			}
+		} catch (IOException ioe) {
+			String msg = NLS.bind(Messages.io_failedRead, location);
+			throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_READ, msg, ioe));
+		}
+	}
+
+	private interface XMLConstants extends org.eclipse.equinox.internal.p2.persistence.XMLConstants {
+
+		// Constants defining the structure of the XML for a ICompositeRepository
+
+		// A format version number for composite repository XML.
+		public static final Version CURRENT_VERSION = new Version(1, 0, 0);
+		public static final VersionRange XML_TOLERANCE = new VersionRange(CURRENT_VERSION, true, new Version(2, 0, 0), false);
+
+		// Constants for processing instructions
+		public static final String PI_REPOSITORY_TARGET = "artifactRepository"; //$NON-NLS-1$
+		public static XMLWriter.ProcessingInstruction[] PI_DEFAULTS = new XMLWriter.ProcessingInstruction[] {XMLWriter.ProcessingInstruction.makeClassVersionInstruction(PI_REPOSITORY_TARGET, ICompositeRepository.class, CURRENT_VERSION)};
+
+		// Constants for artifact repository elements
+		public static final String REPOSITORY_ELEMENT = "repository"; //$NON-NLS-1$
+	}
+
+	// XML writer for a ICompositeRepository
+	protected class Writer extends CompositeWriter implements XMLConstants {
+
+		public Writer(OutputStream output) throws IOException {
+			super(output, PI_DEFAULTS);
+		}
+
+		/**
+		 * Write the given composite repository to the output stream.
+		 */
+		public void write(IRepository repository) {
+			start(REPOSITORY_ELEMENT);
+			attribute(NAME_ATTRIBUTE, repository.getName());
+			attribute(TYPE_ATTRIBUTE, repository.getType());
+			attribute(VERSION_ATTRIBUTE, repository.getVersion());
+			attributeOptional(PROVIDER_ATTRIBUTE, repository.getProvider());
+			attributeOptional(DESCRIPTION_ATTRIBUTE, repository.getDescription()); // TODO: could be cdata?
+
+			writeProperties(repository.getProperties());
+
+			ArrayList children = ((ICompositeRepository) repository).getChildren();
+			writeChildren(children.iterator(), children.size());
+
+			end(REPOSITORY_ELEMENT);
+			flush();
+		}
+	}
+
+	/*
+	 * Parser for the contents of a ICompositeRepository,
+	 * as written by the Writer class.
+	 */
+	private class Parser extends CompositeParser implements XMLConstants {
+
+		private CompositeRepositoryState theState;
+
+		public Parser(BundleContext context, String bundleId) {
+			super(context, bundleId);
+		}
+
+		public void parse(File file) throws IOException {
+			parse(new FileInputStream(file));
+		}
+
+		public synchronized void parse(InputStream stream) throws IOException {
+			this.status = null;
+			try {
+				// TODO: currently not caching the parser since we make no assumptions
+				//		 or restrictions on concurrent parsing
+				getParser();
+				RepositoryHandler repositoryHandler = new RepositoryHandler();
+				xmlReader.setContentHandler(new RepositoryDocHandler(REPOSITORY_ELEMENT, repositoryHandler));
+				xmlReader.parse(new InputSource(stream));
+				if (isValidXML()) {
+					theState = repositoryHandler.getRepository();
+				}
+			} catch (SAXException e) {
+				throw new IOException(e.getMessage());
+			} catch (ParserConfigurationException e) {
+				throw new IOException(e.getMessage());
+			} finally {
+				stream.close();
+			}
+		}
+
+		public CompositeRepositoryState getRepositoryState() {
+			return theState;
+		}
+
+		//TODO what?
+		protected Object getRootObject() {
+			return null;
+		}
+
+		protected String getErrorMessage() {
+			return Messages.io_parseError;
+		}
+
+		private final class RepositoryDocHandler extends DocHandler {
+
+			public RepositoryDocHandler(String rootName, RootHandler rootHandler) {
+				super(rootName, rootHandler);
+			}
+
+			public void processingInstruction(String target, String data) throws SAXException {
+				if (PI_REPOSITORY_TARGET.equals(target)) {
+					// TODO: should the root handler be constructed based on class
+					// 		 via an extension registry mechanism?
+					// String clazz = extractPIClass(data);
+					// TODO: version tolerance by extension
+					Version repositoryVersion = extractPIVersion(target, data);
+					if (!XML_TOLERANCE.isIncluded(repositoryVersion)) {
+						throw new SAXException(NLS.bind(Messages.io_IncompatibleVersion, repositoryVersion, XML_TOLERANCE));
+					}
+				}
+			}
+		}
+
+		private final class RepositoryHandler extends RootHandler {
+
+			private final String[] required = new String[] {NAME_ATTRIBUTE, TYPE_ATTRIBUTE, VERSION_ATTRIBUTE};
+			private final String[] optional = new String[] {DESCRIPTION_ATTRIBUTE, PROVIDER_ATTRIBUTE};
+
+			private PropertiesHandler propertiesHandler = null;
+			private ChildrenHandler childrenHandler = null;
+
+			private CompositeRepositoryState state;
+
+			private String[] attrValues = new String[required.length + optional.length];
+
+			public RepositoryHandler() {
+				super();
+			}
+
+			public CompositeRepositoryState getRepository() {
+				return state;
+			}
+
+			protected void handleRootAttributes(Attributes attributes) {
+				attrValues = parseAttributes(attributes, required, optional);
+				attrValues[2] = checkVersion(REPOSITORY_ELEMENT, VERSION_ATTRIBUTE, attrValues[2]).toString();
+			}
+
+			public void startElement(String name, Attributes attributes) {
+				if (PROPERTIES_ELEMENT.equals(name)) {
+					if (propertiesHandler == null) {
+						propertiesHandler = new PropertiesHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else if (CHILDREN_ELEMENT.equals(name)) {
+					if (childrenHandler == null) {
+						childrenHandler = new ChildrenHandler(this, attributes);
+					} else {
+						duplicateElement(this, name, attributes);
+					}
+				} else {
+					invalidElement(name, attributes);
+				}
+			}
+
+			protected void finished() {
+				if (isValidXML()) {
+					state = new CompositeRepositoryState();
+					state.Name = attrValues[0];
+					state.Type = attrValues[1];
+					state.Version = attrValues[2];
+					state.Description = attrValues[3];
+					state.Provider = attrValues[4];
+					state.Properties = (propertiesHandler == null ? new OrderedProperties(0) //
+							: propertiesHandler.getProperties());
+					state.Children = (childrenHandler == null ? new URI[0] //
+							: childrenHandler.getChildren());
+				}
+			}
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeWriter.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeWriter.java
new file mode 100644
index 0000000..a9993e2
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/CompositeWriter.java
@@ -0,0 +1,45 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.persistence;
+
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.util.Iterator;
+import org.eclipse.equinox.internal.p2.core.helpers.URIUtil;
+
+public abstract class CompositeWriter extends XMLWriter implements XMLConstants {
+
+	public CompositeWriter(OutputStream output, ProcessingInstruction[] piElements) throws UnsupportedEncodingException {
+		super(output, piElements);
+		// TODO: add a processing instruction for the metadata version
+	}
+
+	/**
+	 * Writes a list of URIs referring to sub repositories
+	 */
+	protected void writeChildren(Iterator children, int size) {
+		if (size == 0)
+			return;
+		start(CHILDREN_ELEMENT);
+		attribute(COLLECTION_SIZE_ATTRIBUTE, size);
+		while (children.hasNext())
+			writeChild((URI) children.next());
+		end(CHILDREN_ELEMENT);
+	}
+
+	protected void writeChild(URI encodedURI) {
+		String unencodedString = URIUtil.toUnencodedString(encodedURI);
+		start(CHILD_ELEMENT);
+		attribute(LOCATION_ELEMENT, unencodedString);
+		end(CHILD_ELEMENT);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/Messages.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/Messages.java
index 853e03b..35e1230 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/Messages.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/Messages.java
@@ -34,4 +34,8 @@ public class Messages extends NLS {
 	public static String XMLParser_Unexpected_Character_Data;
 	public static String XMLParser_Element_Not_Allowed;
 
+	public static String io_failedRead;
+	public static String io_IncompatibleVersion;
+	public static String io_parseError;
+
 }
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/XMLConstants.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/XMLConstants.java
index 1db53d9..f7d63c5 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/XMLConstants.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/XMLConstants.java
@@ -56,4 +56,8 @@ public interface XMLConstants {
 	// A constant for an empty array of attribute names
 	public static String[] noAttributes = new String[0];
 
+	//Constants for attributes of a composite repository
+	public static final String CHILDREN_ELEMENT = "children"; //$NON-NLS-1$
+	public static final String CHILD_ELEMENT = "child"; //$NON-NLS-1$
+	public static final String LOCATION_ELEMENT = "location"; //$NON-NLS-1$
 }
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/XMLParser.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/XMLParser.java
index 4c1c055..73032b9 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/XMLParser.java
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/XMLParser.java
@@ -665,6 +665,17 @@ public abstract class XMLParser extends DefaultHandler implements XMLConstants {
 		return 0;
 	}
 
+	// Check the format of a required URI attribute
+	public URI checkURI(String element, String attribute, String value) {
+		try {
+			return URIUtil.fromString(value);
+		} catch (URISyntaxException e) {
+			invalidAttributeValue(element, attribute, value);
+		}
+		//TODO ok to return null?
+		return null;
+	}
+
 	public void checkCancel() {
 		if (monitor != null && monitor.isCanceled())
 			throw new OperationCanceledException();
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/messages.properties b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/messages.properties
index 4928c08..00931dc 100644
--- a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/messages.properties
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/p2/persistence/messages.properties
@@ -23,3 +23,9 @@ XMLParser_Unexpected_Element=Unexpected element in element "{0}": <{1}{2}>
 XMLParser_Duplicate_Element=Duplicate singleton element in element "{0}": <{1}{2}>
 XMLParser_Unexpected_Character_Data=Unexpected character data in element "{0}": {1}
 XMLParser_Element_Not_Allowed=Element "{0}" is not allowed within element "{1}"
+
+io_failedRead=Unable to read repository at {0}
+io_IncompatibleVersion=\
+Metadata repository has incompatible version {0}; expected {1}
+io_parseError=\
+Error parsing composite repository
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/repository/ICompositeRepository.java b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/repository/ICompositeRepository.java
new file mode 100644
index 0000000..881e157
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.core/src/org/eclipse/equinox/internal/provisional/p2/core/repository/ICompositeRepository.java
@@ -0,0 +1,41 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.core.repository;
+
+import java.net.URI;
+import java.util.ArrayList;
+
+public interface ICompositeRepository extends IRepository {
+	/**
+	 * 
+	 * @return an ArrayList of URIs containing the locations of the children repositories
+	 */
+	public abstract ArrayList getChildren();
+
+	/**
+	 * Removes all child repositories
+	 */
+	public abstract void removeAllChildren();
+
+	/**
+	 * Removes specified URI from list of child repositories.
+	 * Does nothing if specified URI is not a child repository
+	 * @param child
+	 */
+	public abstract void removeChild(URI child);
+
+	/**
+	 * Adds a specified URI to list of child repositories.
+	 * Does nothing if URI is a duplicate of an existing child repository.
+	 * @param child
+	 */
+	public abstract void addChild(URI child);
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/plugin.xml b/bundles/org.eclipse.equinox.p2.metadata.repository/plugin.xml
index 5c9da58..c323540 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/plugin.xml
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/plugin.xml
@@ -18,4 +18,8 @@
          </run>
       </application>
    </extension>
+   <extension id="compositeRepository"  point="org.eclipse.equinox.p2.metadata.repository.metadataRepositories">
+        <filter suffix="compositeContent.xml"/>
+        <factory class="org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepositoryFactory"/>
+   </extension>
 </plugin>
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/CompositeMetadataRepository.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/CompositeMetadataRepository.java
new file mode 100644
index 0000000..1135bca
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/CompositeMetadataRepository.java
@@ -0,0 +1,215 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata.repository;
+
+import java.io.*;
+import java.net.URI;
+import java.util.*;
+import java.util.jar.JarEntry;
+import java.util.jar.JarOutputStream;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.core.helpers.*;
+import org.eclipse.equinox.internal.p2.persistence.CompositeRepositoryIO;
+import org.eclipse.equinox.internal.p2.persistence.CompositeRepositoryIO.CompositeRepositoryState;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.ICompositeRepository;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
+import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
+import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.spi.p2.metadata.repository.AbstractMetadataRepository;
+
+public class CompositeMetadataRepository extends AbstractMetadataRepository implements IMetadataRepository, ICompositeRepository {
+
+	static final public String REPOSITORY_TYPE = CompositeMetadataRepository.class.getName();
+	static final private Integer REPOSITORY_VERSION = new Integer(1);
+	static final public String XML_EXTENSION = ".xml"; //$NON-NLS-1$
+	static final private String JAR_EXTENSION = ".jar"; //$NON-NLS-1$
+	static final public String CONTENT_FILENAME = "compositeContent"; //$NON-NLS-1$
+
+	private ArrayList childrenURIs = new ArrayList();
+
+	private IMetadataRepositoryManager getManager() {
+		return (IMetadataRepositoryManager) ServiceHelper.getService(Activator.getContext(), IMetadataRepositoryManager.class.getName());
+	}
+
+	private boolean isLocal() {
+		return "file".equalsIgnoreCase(location.getScheme()); //$NON-NLS-1$
+	}
+
+	public boolean isModifiable() {
+		return isLocal();
+	}
+
+	public CompositeMetadataRepository() {
+		super();
+	}
+
+	public CompositeMetadataRepository(URI location, String name, Map properties) {
+		super(name == null ? (location != null ? location.toString() : "") : name, REPOSITORY_TYPE, REPOSITORY_VERSION.toString(), location, null, null, properties); //$NON-NLS-1$
+		//when creating a repository, we must ensure it exists on disk so a subsequent load will succeed
+		save();
+	}
+
+	/*
+	 * This is only called by the parser when loading a repository.
+	 */
+	public CompositeMetadataRepository(CompositeRepositoryState state) {
+		super(state.Name, state.Type, state.Version, null, state.Description, state.Provider, state.Properties);
+		for (int i = 0; i < state.Children.length; i++) {
+			if (!childrenURIs.contains(state.Children[i]))
+				childrenURIs.add(state.Children[i]);
+		}
+	}
+
+	// use this method to setup any transient fields etc after the object has been restored from a stream
+	public synchronized void initializeAfterLoad(URI aLocation) {
+		this.location = aLocation;
+	}
+
+	public Collector query(Query query, Collector collector, IProgressMonitor monitor) {
+		Iterator repositoryIterator = childrenURIs.iterator();
+		while (repositoryIterator.hasNext()) {
+			try {
+				//Try to load the repositories one by one
+				URI currentURI = (URI) repositoryIterator.next();
+				boolean currentLoaded = getManager().contains(currentURI);
+				IMetadataRepository currentRepo = getManager().loadRepository(currentURI, null);
+				if (!currentLoaded) {
+					//set enabled to false so repositories do not polled twice
+					getManager().setEnabled(currentURI, false);
+					//set repository to system to hide from users
+					currentRepo.setProperty(IRepository.PROP_SYSTEM, "true");
+				}
+				//get the query results. Collector should take care of duplicates
+				currentRepo.query(query, collector, monitor);
+			} catch (ProvisionException e) {
+				//repository failed to load. fall through
+				LogHelper.log(e);
+			}
+		}
+		return collector;
+	}
+
+	public void addChild(URI childURI) {
+		if (!childrenURIs.contains(childURI)) {
+			childrenURIs.add(childURI);
+			save();
+		}
+	}
+
+	public void removeChild(URI childURI) {
+		childrenURIs.remove(childURI);
+		save();
+	}
+
+	public void removeAllChildren() {
+		childrenURIs.clear();
+		save();
+	}
+
+	public synchronized void addInstallableUnits(IInstallableUnit[] installableUnits) {
+		throw new UnsupportedOperationException("Cannot add IUs to a composite repository");
+	}
+
+	public synchronized void removeAll() {
+		throw new UnsupportedOperationException("Cannot remove IUs to a composite repository");
+	}
+
+	public synchronized boolean removeInstallableUnits(Query query, IProgressMonitor monitor) {
+		throw new UnsupportedOperationException("Cannot remove IUs to a composite repository");
+	}
+
+	private static File getActualLocation(URI location, String extension) {
+		File spec = URIUtil.toFile(location);
+		String path = spec.getAbsolutePath();
+		if (path.endsWith(CONTENT_FILENAME + extension)) {
+			//todo this is the old code that doesn't look right
+			//			return new File(spec + extension);
+			return spec;
+		}
+		if (path.endsWith("/")) //$NON-NLS-1$
+			path += CONTENT_FILENAME;
+		else
+			path += "/" + CONTENT_FILENAME; //$NON-NLS-1$
+		return new File(path + extension);
+	}
+
+	public static File getActualLocation(URI location) {
+		return getActualLocation(location, XML_EXTENSION);
+	}
+
+	public synchronized void addReference(URI repositoryLocation, int repositoryType, int options) {
+		throw new UnsupportedOperationException("Cannot add References to a composite repository");
+	}
+
+	// caller should be synchronized
+	private void save() {
+		assertModifiable();
+		File file = getActualLocation(location);
+		File jarFile = getActualLocation(location, JAR_EXTENSION);
+		boolean compress = "true".equalsIgnoreCase((String) properties.get(PROP_COMPRESSED)); //$NON-NLS-1$
+		try {
+			OutputStream output = null;
+			if (!compress) {
+				if (jarFile.exists()) {
+					jarFile.delete();
+				}
+				if (!file.exists()) {
+					if (!file.getParentFile().exists())
+						file.getParentFile().mkdirs();
+					file.createNewFile();
+				}
+				output = new FileOutputStream(file);
+			} else {
+				if (file.exists()) {
+					file.delete();
+				}
+				if (!jarFile.exists()) {
+					if (!jarFile.getParentFile().exists())
+						jarFile.getParentFile().mkdirs();
+					jarFile.createNewFile();
+				}
+				JarEntry jarEntry = new JarEntry(file.getName());
+				JarOutputStream jOutput = new JarOutputStream(new FileOutputStream(jarFile));
+				jOutput.putNextEntry(jarEntry);
+				output = jOutput;
+			}
+			super.setProperty(IRepository.PROP_TIMESTAMP, Long.toString(System.currentTimeMillis()));
+			new CompositeRepositoryIO().write(this, output);
+		} catch (IOException e) {
+			LogHelper.log(new Status(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_WRITE, "Error saving metadata repository: " + location, e)); //$NON-NLS-1$
+		}
+	}
+
+	public ArrayList getChildren() {
+		return childrenURIs;
+	}
+
+	public static URI getActualLocationURI(URI base, String extension) {
+		if (extension == null)
+			extension = XML_EXTENSION;
+		return URIUtil.append(base, CONTENT_FILENAME + extension);
+	}
+
+	//TODO this should never be called. What do we do?
+	public void initialize(RepositoryState state) {
+		this.name = state.Name;
+		this.type = state.Type;
+		this.version = state.Version.toString();
+		this.provider = state.Provider;
+		this.description = state.Description;
+		this.location = state.Location;
+		this.properties = state.Properties;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/CompositeMetadataRepositoryFactory.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/CompositeMetadataRepositoryFactory.java
new file mode 100644
index 0000000..1f13ebb
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/CompositeMetadataRepositoryFactory.java
@@ -0,0 +1,158 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata.repository;
+
+import java.io.*;
+import java.net.URI;
+import java.util.Map;
+import java.util.jar.JarEntry;
+import java.util.jar.JarInputStream;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.core.helpers.Tracing;
+import org.eclipse.equinox.internal.p2.core.helpers.URIUtil;
+import org.eclipse.equinox.internal.p2.persistence.CompositeRepositoryIO;
+import org.eclipse.equinox.internal.p2.persistence.CompositeRepositoryIO.CompositeRepositoryState;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
+import org.eclipse.equinox.internal.provisional.spi.p2.metadata.repository.MetadataRepositoryFactory;
+import org.eclipse.osgi.util.NLS;
+
+public class CompositeMetadataRepositoryFactory extends MetadataRepositoryFactory {
+
+	private static final String JAR_EXTENSION = ".jar"; //$NON-NLS-1$
+	private static final String XML_EXTENSION = ".xml"; //$NON-NLS-1$
+	private static final String PROTOCOL_FILE = "file"; //$NON-NLS-1$
+
+	public IMetadataRepository create(URI location, String name, String type, Map properties) {
+		return new CompositeMetadataRepository(location, name, properties);
+	}
+
+	/**
+	 * Returns a file in the local file system that contains the contents of the
+	 * metadata repository at the given location.
+	 */
+	private File getLocalFile(URI location, IProgressMonitor monitor) throws IOException, ProvisionException {
+		File localFile = null;
+		URI jarLocation = CompositeMetadataRepository.getActualLocationURI(location, JAR_EXTENSION);
+		URI xmlLocation = CompositeMetadataRepository.getActualLocationURI(location, XML_EXTENSION);
+		// If the repository is local, we can return the repository file directly
+		if (PROTOCOL_FILE.equals(xmlLocation.getScheme())) {
+			//look for a compressed local file
+			localFile = URIUtil.toFile(jarLocation);
+			if (localFile.exists())
+				return localFile;
+			//look for an uncompressed local file
+			localFile = URIUtil.toFile(xmlLocation);
+			if (localFile.exists())
+				return localFile;
+			String msg = NLS.bind(Messages.io_failedRead, location);
+			throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_NOT_FOUND, msg, null));
+		}
+		//file is not local, create a cache of the repository metadata
+		localFile = Activator.getCacheManager().createCache(location, monitor);
+		if (localFile == null) {
+			//there is no remote file in either form
+			String msg = NLS.bind(Messages.io_failedRead, location);
+			throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_NOT_FOUND, msg, null));
+		}
+		return localFile;
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.spi.p2.metadata.repository.MetadataRepositoryFactory#validate(java.net.URL, org.eclipse.core.runtime.IProgressMonitor)
+	 */
+	public IStatus validate(URI location, IProgressMonitor monitor) {
+		try {
+			validateAndLoad(location, false, monitor);
+		} catch (ProvisionException e) {
+			return e.getStatus();
+		}
+		return Status.OK_STATUS;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.spi.p2.metadata.repository.MetadataRepositoryFactory#load(java.net.URL, org.eclipse.core.runtime.IProgressMonitor)
+	 */
+	public IMetadataRepository load(URI location, IProgressMonitor monitor) throws ProvisionException {
+		return validateAndLoad(location, true, monitor);
+	}
+
+	protected IMetadataRepository validateAndLoad(URI location, boolean doLoad, IProgressMonitor monitor) throws ProvisionException {
+		long time = 0;
+		final String debugMsg = "Validating and loading metadata repository "; //$NON-NLS-1$
+		if (Tracing.DEBUG_METADATA_PARSING) {
+			Tracing.debug(debugMsg + location);
+			time = -System.currentTimeMillis();
+		}
+		SubMonitor sub = SubMonitor.convert(monitor, 400);
+		try {
+			File localFile = getLocalFile(location, sub.newChild(300));
+			InputStream inStream = new BufferedInputStream(new FileInputStream(localFile));
+			JarInputStream jarStream = null;
+			try {
+				//if reading from a jar, obtain a stream on the entry with the actual contents
+				if (localFile.getAbsolutePath().endsWith(JAR_EXTENSION)) {
+					jarStream = new JarInputStream(inStream);
+					JarEntry jarEntry = jarStream.getNextJarEntry();
+					String entryName = CompositeMetadataRepository.CONTENT_FILENAME + CompositeMetadataRepository.XML_EXTENSION;
+					while (jarEntry != null && (!entryName.equals(jarEntry.getName()))) {
+						jarEntry = jarStream.getNextJarEntry();
+					}
+					if (jarEntry == null)
+						throw new FileNotFoundException(NLS.bind(Messages.repoMan_invalidLocation, location));
+				}
+				//parse the repository descriptor file
+				sub.setWorkRemaining(100);
+				if (doLoad) {
+					InputStream descriptorStream = jarStream != null ? jarStream : inStream;
+					CompositeRepositoryIO io = new CompositeRepositoryIO();
+					CompositeRepositoryState resultState = io.read(localFile.toURL(), descriptorStream, sub.newChild(100));
+
+					CompositeMetadataRepository result = new CompositeMetadataRepository(resultState);
+
+					result.initializeAfterLoad(location);
+					if (Tracing.DEBUG_METADATA_PARSING) {
+						time += System.currentTimeMillis();
+						Tracing.debug(debugMsg + "time (ms): " + time); //$NON-NLS-1$ 
+					}
+					return result;
+				}
+			} finally {
+				safeClose(jarStream);
+				safeClose(inStream);
+			}
+		} catch (FileNotFoundException e) {
+			String msg = NLS.bind(Messages.io_failedRead, location);
+			throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_NOT_FOUND, msg, e));
+		} catch (IOException e) {
+			String msg = NLS.bind(Messages.io_failedRead, location);
+			throw new ProvisionException(new Status(IStatus.ERROR, Activator.ID, ProvisionException.REPOSITORY_FAILED_READ, msg, e));
+		} finally {
+			if (monitor != null)
+				monitor.done();
+		}
+		return null;
+	}
+
+	/**
+	 * Closes a stream, ignoring any secondary exceptions
+	 */
+	private void safeClose(InputStream stream) {
+		if (stream == null)
+			return;
+		try {
+			stream.close();
+		} catch (IOException e) {
+			//ignore
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/provisional/p2/metadata/repository/IMetadataRepositoryManager.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/provisional/p2/metadata/repository/IMetadataRepositoryManager.java
index a5095a8..aaef4e5 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/provisional/p2/metadata/repository/IMetadataRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/provisional/p2/metadata/repository/IMetadataRepositoryManager.java
@@ -35,6 +35,7 @@ public interface IMetadataRepositoryManager extends IRepositoryManager, IQueryab
 	 * Repository type for a simple repository based on a URL or local file system location.
 	 */
 	public static final String TYPE_SIMPLE_REPOSITORY = "org.eclipse.equinox.p2.metadata.repository.simpleRepository"; //$NON-NLS-1$
+	public static final String TYPE_COMPOSITE_REPOSITORY = "org.eclipse.equinox.p2.metadata.repository.compositeRepository"; //$NON-NLS-1$
 
 	/**
 	 * Creates and returns a new empty metadata repository of the given type at 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/AllTests.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/AllTests.java
index 7f2183c..670b336 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/AllTests.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/AllTests.java
@@ -28,6 +28,7 @@ public class AllTests extends TestCase {
 		suite.addTestSuite(MD5Tests.class);
 		suite.addTestSuite(MirrorSelectorTest.class);
 		suite.addTestSuite(SimpleArtifactRepositoryTest.class);
+		suite.addTestSuite(CompositeArtifactRepositoryTest.class);
 		return suite;
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CompositeArtifactRepositoryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CompositeArtifactRepositoryTest.java
new file mode 100644
index 0000000..536ee0c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/artifact/repository/CompositeArtifactRepositoryTest.java
@@ -0,0 +1,408 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.p2.tests.artifact.repository;
+
+import java.io.File;
+import java.net.URI;
+import java.util.HashMap;
+import java.util.Map;
+import org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository;
+import org.eclipse.equinox.internal.provisional.p2.artifact.repository.*;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IArtifactKey;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
+import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;
+import org.osgi.framework.Version;
+
+public class CompositeArtifactRepositoryTest extends AbstractProvisioningTest {
+	private static final String TEST_KEY = "TestKey";
+	private static final String TEST_VALUE = "TestValue";
+	//artifact repository to remove on tear down
+	private File repositoryFile = null;
+	private URI repositoryURI = null;
+
+	protected void tearDown() throws Exception {
+		super.tearDown();
+		//repository location is not used by all tests
+		if (repositoryURI != null) {
+			getArtifactRepositoryManager().removeRepository(repositoryURI);
+			repositoryURI = null;
+		}
+		if (repositoryFile != null) {
+			delete(repositoryFile);
+			repositoryFile = null;
+		}
+	}
+
+	public void testCompressedRepositoryCreation() {
+		//create a compressed repo
+		createRepo(true);
+
+		File files[] = repositoryFile.listFiles();
+		boolean jarFilePresent = false;
+		boolean artifactFilePresent = false;
+		for (int i = 0; i < files.length; i++) {
+			if ("compositeArtifacts.jar".equalsIgnoreCase(files[i].getName())) {
+				jarFilePresent = true;
+			}
+			if ("compositeArtifacts.xml".equalsIgnoreCase(files[i].getName())) {
+				artifactFilePresent = false;
+			}
+		}
+		if (!jarFilePresent)
+			fail("Repository should create JAR for compositeArtifacts.xml");
+		if (artifactFilePresent)
+			fail("Repository should not create compositeArtifacts.xml");
+	}
+
+	public void testVerifyUncompressedRepositoryCreation() {
+		//Setup: create an uncompressed repository
+		createRepo(false);
+
+		File files[] = repositoryFile.listFiles();
+		boolean jarFilePresent = false;
+		boolean artifactFilePresent = false;
+		for (int i = 0; i < files.length; i++) {
+			if ("compositeArtifacts.jar".equalsIgnoreCase(files[i].getName())) {
+				jarFilePresent = true;
+			}
+			if ("compositeArtifacts.xml".equalsIgnoreCase(files[i].getName())) {
+				artifactFilePresent = true;
+			}
+		}
+		if (jarFilePresent)
+			fail("Repository should not create JAR for compositeArtifacts.xml");
+		if (!artifactFilePresent)
+			fail("Repository should create compositeArtifacts.xml");
+	}
+
+	public void testAddDescriptor() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		//Setup create a descriptor
+		IArtifactKey key = PublisherHelper.createBinaryArtifactKey("testKeyId", new Version("1.2.3"));
+		IArtifactDescriptor descriptor = PublisherHelper.createArtifactDescriptor(key, null);
+
+		try {
+			compRepo.addDescriptor(descriptor);
+			fail("Should not be able to add Artifact Descriptor");
+		} catch (UnsupportedOperationException e) {
+			//expected. fall through
+		}
+	}
+
+	public void testAddDescriptors() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		//Setup create a descriptor
+		IArtifactKey key = PublisherHelper.createBinaryArtifactKey("testKeyId", new Version("1.2.3"));
+		IArtifactDescriptor descriptor = PublisherHelper.createArtifactDescriptor(key, null);
+
+		//Setup: create an array of descriptors
+		IArtifactDescriptor[] descriptors = new IArtifactDescriptor[1];
+		descriptors[0] = descriptor;
+
+		try {
+			compRepo.addDescriptors(descriptors);
+			fail("Should not be able to add Artifact Descriptors using an array");
+		} catch (UnsupportedOperationException e) {
+			//expected. fall through
+		}
+	}
+
+	public void testRemoveDescriptorUsingDescriptor() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		//Setup create a descriptor
+		IArtifactKey key = PublisherHelper.createBinaryArtifactKey("testKeyId", new Version("1.2.3"));
+		IArtifactDescriptor descriptor = PublisherHelper.createArtifactDescriptor(key, null);
+
+		try {
+			compRepo.removeDescriptor(descriptor);
+			fail("Should not be able to remove Artifact Descriptor using a Artifact Descriptor");
+		} catch (UnsupportedOperationException e) {
+			//expected. fall through
+		}
+	}
+
+	public void testRemoveDescriptorUsingKey() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		//Setup create a key
+		IArtifactKey key = PublisherHelper.createBinaryArtifactKey("testKeyId", new Version("1.2.3"));
+
+		try {
+			compRepo.removeDescriptor(key);
+			fail("Should not be able to remove Artifact Descriptor using an Artifact Key");
+		} catch (UnsupportedOperationException e) {
+			//expected. fall through
+		}
+	}
+
+	public void testRemoveAll() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		try {
+			compRepo.removeAll();
+			fail("Should not be able to Remove All");
+		} catch (UnsupportedOperationException e) {
+			//expected. fall through
+		}
+	}
+
+	public void testGetProperties() {
+		IArtifactRepositoryManager manager = getArtifactRepositoryManager();
+		repositoryFile = new File(getTempFolder(), "CompositeArtifactRepositoryTest");
+		IArtifactRepository repo = null;
+		try {
+			repo = manager.createRepository(repositoryFile.toURI(), "TestRepo", IArtifactRepositoryManager.TYPE_COMPOSITE_REPOSITORY, null);
+		} catch (ProvisionException e) {
+			fail("Cannot create repository: ", e);
+		}
+		Map properties = repo.getProperties();
+		//attempting to modify the properties should fail
+		try {
+			properties.put(TEST_KEY, TEST_VALUE);
+			fail("Should not allow setting property");
+		} catch (RuntimeException e) {
+			//expected
+		}
+	}
+
+	public void testSetProperty() {
+		IArtifactRepositoryManager manager = getArtifactRepositoryManager();
+		repositoryFile = new File(getTempFolder(), "CompositeArtifactRepositoryTest");
+		IArtifactRepository repo = null;
+		try {
+			repo = manager.createRepository(repositoryFile.toURI(), "TestRepo", IArtifactRepositoryManager.TYPE_COMPOSITE_REPOSITORY, null);
+		} catch (ProvisionException e) {
+			fail("Cannot create repository: ", e);;
+		}
+		Map properties = repo.getProperties();
+		assertTrue("1.0", !properties.containsKey(TEST_KEY));
+		repo.setProperty(TEST_KEY, TEST_VALUE);
+
+		//the previously obtained properties should not be affected by subsequent changes
+		assertTrue("1.1", !properties.containsKey(TEST_KEY));
+		properties = repo.getProperties();
+		assertTrue("1.2", properties.containsKey(TEST_KEY));
+
+		//going back to repo manager, should still get the new property
+		try {
+			repo = manager.loadRepository(repositoryFile.toURI(), null);
+		} catch (ProvisionException e) {
+			fail("Cannot load repository: ", e);
+		}
+		properties = repo.getProperties();
+		assertTrue("1.3", properties.containsKey(TEST_KEY));
+
+		//setting a null value should remove the key
+		repo.setProperty(TEST_KEY, null);
+		properties = repo.getProperties();
+		assertTrue("1.4", !properties.containsKey(TEST_KEY));
+	}
+
+	public void testAddChild() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		File child = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		IArtifactRepositoryManager artifactRepositoryManager = getArtifactRepositoryManager();
+		IArtifactRepository repo = null;
+		try {
+			repo = artifactRepositoryManager.loadRepository(child.toURI(), null);
+		} catch (ProvisionException e) {
+			fail("Unable to load repository for verification", e);
+		}
+
+		assertContentEquals("Verifying contents", compRepo, repo);
+	}
+
+	public void testRemoveChild() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		//Setup, populate the children
+		File child = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		compRepo.removeChild(child.toURI());
+		assertEquals("Children size after remove", 0, compRepo.getChildren().size());
+	}
+
+	public void testAddRepeatChild() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		File child = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		//Add the same repo again
+		compRepo.addChild(child.toURI());
+		//size should not change
+		assertEquals("Children size after repeat entry", 1, compRepo.getChildren().size());
+	}
+
+	public void testAddMultipleChildren() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		File child1 = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child1.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		File child2 = getTestData("2", "/testData/mirror/mirrorSourceRepo2");
+		compRepo.addChild(child2.toURI());
+		assertEquals("Children size with 2 children", 2, compRepo.getChildren().size());
+
+		IArtifactRepositoryManager artifactRepositoryManager = getArtifactRepositoryManager();
+		IArtifactRepository repo1 = null;
+		IArtifactRepository repo2 = null;
+		try {
+			repo1 = artifactRepositoryManager.loadRepository(child1.toURI(), null);
+			repo2 = artifactRepositoryManager.loadRepository(child2.toURI(), null);
+		} catch (ProvisionException e) {
+			fail("Unable to load repositories for verification", e);
+		}
+
+		assertContains("Assert child1's content is in composite repo", repo1, compRepo);
+		assertContains("Assert child2's content is in composite repo", repo2, compRepo);
+		//checks that the destination has the correct number of keys (no extras)
+		//FIXME will this work?
+		assertEquals("Assert Correct Number of Keys", repo1.getArtifactKeys().length + repo2.getArtifactKeys().length, compRepo.getArtifactKeys().length);
+	}
+
+	public void testRemoveNonexistantChild() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		//Setup, populate the children
+		File child = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		File invalidChild = getTestData("2", "/testData/mirror/mirrorSourceRepo2");
+		compRepo.removeChild(invalidChild.toURI());
+		//Should not affect the size of children
+		assertEquals("Children size after remove", 1, compRepo.getChildren().size());
+	}
+
+	public void testRemoveAllChildren() {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		File child1 = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child1.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		File child2 = getTestData("2", "/testData/mirror/mirrorSourceRepo2");
+		compRepo.addChild(child2.toURI());
+		assertEquals("Children size with 2 children", 2, compRepo.getChildren().size());
+
+		compRepo.removeAllChildren();
+		assertEquals("Children size after removeAllChildren", 0, compRepo.getChildren().size());
+	}
+
+	public void testCompressedPersistence() {
+		persistenceTest(true);
+	}
+
+	public void testUncompressedPersistence() {
+		persistenceTest(false);
+	}
+
+	private void persistenceTest(boolean compressed) {
+		//Setup: create an uncompressed repository
+		CompositeArtifactRepository compRepo = createRepo(compressed);
+
+		//Add data. forces write to disk.
+		File child1 = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child1.toURI());
+		File child2 = getTestData("2", "/testData/mirror/mirrorSourceRepo2");
+		compRepo.addChild(child2.toURI());
+		//Assume success (covered by other tests)
+
+		//Remove repo from memory
+		IArtifactRepositoryManager artifactRepositoryManager = getArtifactRepositoryManager();
+		artifactRepositoryManager.removeRepository(repositoryURI);
+		compRepo = null;
+
+		//load repository off disk
+		IArtifactRepository repo = null;
+		try {
+			repo = artifactRepositoryManager.loadRepository(repositoryURI, null);
+		} catch (ProvisionException e) {
+			fail("Could not load repository after removal", e);
+		}
+		assertTrue("loaded repository was of type CompositeArtifactRepository", repo instanceof CompositeArtifactRepository);
+
+		compRepo = (CompositeArtifactRepository) repo;
+
+		IArtifactRepository repo1 = null;
+		IArtifactRepository repo2 = null;
+		try {
+			repo1 = artifactRepositoryManager.loadRepository(child1.toURI(), null);
+			repo2 = artifactRepositoryManager.loadRepository(child2.toURI(), null);
+		} catch (ProvisionException e) {
+			fail("Unable to load repositories for verification", e);
+		}
+
+		assertContains("Assert child1's content is in composite repo", repo1, compRepo);
+		assertContains("Assert child2's content is in composite repo", repo2, compRepo);
+		//checks that the destination has the correct number of keys (no extras)
+		//FIXME will this work?
+		assertEquals("Assert Correct Number of Keys", repo1.getArtifactKeys().length + repo2.getArtifactKeys().length, compRepo.getArtifactKeys().length);
+	}
+
+	private CompositeArtifactRepository createRepo(boolean compressed) {
+		IArtifactRepositoryManager artifactRepositoryManager = getArtifactRepositoryManager();
+		repositoryFile = new File(getTempFolder(), "CompositeArtifactRepositoryTest");
+		delete(repositoryFile);
+		repositoryURI = repositoryFile.toURI();
+		Map properties = new HashMap();
+		properties.put(IRepository.PROP_COMPRESSED, compressed ? "true" : "false");
+		IArtifactRepository repo = null;
+		try {
+			repo = artifactRepositoryManager.createRepository(repositoryURI, "artifact name", IArtifactRepositoryManager.TYPE_COMPOSITE_REPOSITORY, properties);
+		} catch (ProvisionException e) {
+			fail("Could not create repository");
+		}
+
+		//ensure proper type of repository has been created
+		if (!(repo instanceof CompositeArtifactRepository))
+			fail("Repository is not a CompositeArtifactRepository");
+
+		return (CompositeArtifactRepository) repo;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/AllTests.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/AllTests.java
index 37775b2..3126a85 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/AllTests.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/AllTests.java
@@ -22,6 +22,7 @@ public class AllTests extends TestCase {
 		suite.addTestSuite(JarURLRepositoryTest.class);
 		suite.addTestSuite(LocalMetadataRepositoryTest.class);
 		suite.addTestSuite(MetadataRepositoryManagerTest.class);
+		suite.addTestSuite(CompositeMetadataRepositoryTest.class);
 		return suite;
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/CompositeMetadataRepositoryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/CompositeMetadataRepositoryTest.java
new file mode 100644
index 0000000..139e2b1
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/repository/CompositeMetadataRepositoryTest.java
@@ -0,0 +1,387 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     Code 9 - ongoing development
+ *******************************************************************************/
+package org.eclipse.equinox.p2.tests.metadata.repository;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.Map;
+import org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory;
+import org.eclipse.equinox.internal.provisional.p2.metadata.MetadataFactory.InstallableUnitDescription;
+import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
+import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
+import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
+import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
+import org.osgi.framework.Version;
+
+/**
+ * Test API of the local metadata repository implementation.
+ */
+public class CompositeMetadataRepositoryTest extends AbstractProvisioningTest {
+	private static final String TEST_KEY = "TestKey";
+	private static final String TEST_VALUE = "TestValue";
+	protected File repoLocation;
+
+	protected void setUp() throws Exception {
+		super.setUp();
+		repoLocation = new File(getTempFolder(), "CompositeMetadataRepositoryTest");
+		AbstractProvisioningTest.delete(repoLocation);
+	}
+
+	protected void tearDown() throws Exception {
+		getMetadataRepositoryManager().removeRepository(repoLocation.toURI());
+		delete(repoLocation);
+		super.tearDown();
+	}
+
+	public void testCompressedRepositoryCreation() {
+		createRepo(true);
+
+		File[] files = repoLocation.listFiles();
+		boolean jarFilePresent = false;
+		boolean xmlFilePresent = false;
+		// one of the files in the repository should be the content.xml.jar
+		for (int i = 0; i < files.length; i++) {
+			if ("compositeContent.jar".equalsIgnoreCase(files[i].getName())) {
+				jarFilePresent = true;
+			}
+			if ("compositeContent.xml".equalsIgnoreCase(files[i].getName())) {
+				xmlFilePresent = true;
+			}
+		}
+		if (!jarFilePresent) {
+			fail("Repository did not create JAR for compositeContent.xml");
+		}
+		if (xmlFilePresent) {
+			fail("Repository should not create compositeContent.xml");
+		}
+	}
+
+	public void testUncompressedRepositoryCreation() {
+		createRepo(false);
+
+		File[] files = repoLocation.listFiles();
+		boolean jarFilePresent = false;
+		// none of the files in the repository should be the content.xml.jar
+		for (int i = 0; i < files.length; i++) {
+			if ("compositeContent.jar".equalsIgnoreCase(files[i].getName())) {
+				jarFilePresent = true;
+			}
+		}
+		if (jarFilePresent) {
+			fail("Repository should not create JAR for compositeContent.xml");
+		}
+	}
+
+	public void testAddInstallableUnits() {
+		//create uncommpressed repo
+		CompositeMetadataRepository compRepo = createRepo(false);
+
+		//Try to add a new InstallableUnit.
+		try {
+			InstallableUnitDescription descriptor = new MetadataFactory.InstallableUnitDescription();
+			descriptor.setId("testIuId");
+			descriptor.setVersion(new Version("3.2.1"));
+			IInstallableUnit iu = MetadataFactory.createInstallableUnit(descriptor);
+			compRepo.addInstallableUnits(new IInstallableUnit[] {iu});
+			fail("Should not be able to insert InstallableUnit");
+		} catch (UnsupportedOperationException e) {
+			//expected. fall through
+		}
+	}
+
+	public void testRemoveInstallableUnits() {
+		//create uncommpressed repo
+		CompositeMetadataRepository compRepo = createRepo(false);
+
+		//Try to remove an InstallableUnit.
+		try {
+			compRepo.removeInstallableUnits(InstallableUnitQuery.ANY, null);
+			fail("Should not be able to remove InstallableUnit");
+		} catch (UnsupportedOperationException e) {
+			//expected. fall through
+		}
+	}
+
+	public void testRemoveAll() {
+		//create uncommpressed repo
+		CompositeMetadataRepository compRepo = createRepo(false);
+
+		//Try to removeAll.
+		try {
+			compRepo.removeAll();
+			fail("Should not be able to removeAll()");
+		} catch (UnsupportedOperationException e) {
+			//expected. fall through
+		}
+	}
+
+	public void testGetProperties() {
+		IMetadataRepositoryManager manager = getMetadataRepositoryManager();
+		IMetadataRepository repo = null;
+		try {
+			repo = manager.createRepository(repoLocation.toURI(), "TestRepo", IMetadataRepositoryManager.TYPE_COMPOSITE_REPOSITORY, null);
+		} catch (ProvisionException e) {
+			fail("Cannot create repository: ", e);
+		}
+		Map properties = repo.getProperties();
+		//attempting to modify the properties should fail
+		try {
+			properties.put(TEST_KEY, TEST_VALUE);
+			fail("Should not allow setting property");
+		} catch (RuntimeException e) {
+			//expected
+		}
+	}
+
+	public void testSetProperty() {
+		IMetadataRepositoryManager manager = getMetadataRepositoryManager();
+		IMetadataRepository repo = null;
+		try {
+			repo = manager.createRepository(repoLocation.toURI(), "TestRepo", IMetadataRepositoryManager.TYPE_COMPOSITE_REPOSITORY, null);
+		} catch (ProvisionException e) {
+			fail("Cannot create repository: ", e);;
+		}
+		Map properties = repo.getProperties();
+		assertTrue("1.0", !properties.containsKey(TEST_KEY));
+		repo.setProperty(TEST_KEY, TEST_VALUE);
+
+		//the previously obtained properties should not be affected by subsequent changes
+		assertTrue("1.1", !properties.containsKey(TEST_KEY));
+		properties = repo.getProperties();
+		assertTrue("1.2", properties.containsKey(TEST_KEY));
+
+		//going back to repo manager, should still get the new property
+		try {
+			repo = manager.loadRepository(repoLocation.toURI(), null);
+		} catch (ProvisionException e) {
+			fail("Cannot load repository: ", e);
+		}
+		properties = repo.getProperties();
+		assertTrue("1.3", properties.containsKey(TEST_KEY));
+
+		//setting a null value should remove the key
+		repo.setProperty(TEST_KEY, null);
+		properties = repo.getProperties();
+		assertTrue("1.4", !properties.containsKey(TEST_KEY));
+	}
+
+	public void testAddChild() {
+		//Setup: create an uncompressed repository
+		CompositeMetadataRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		File child = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		IMetadataRepositoryManager metadataRepositoryManager = getMetadataRepositoryManager();
+		IMetadataRepository repo = null;
+		try {
+			repo = metadataRepositoryManager.loadRepository(child.toURI(), null);
+		} catch (ProvisionException e) {
+			fail("Unable to load repository for verification", e);
+		}
+
+		assertContentEquals("Verifying contents", compRepo, repo);
+	}
+
+	public void testRemoveChild() {
+		//Setup: create an uncompressed repository
+		CompositeMetadataRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		//Setup, populate the children
+		File child = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		compRepo.removeChild(child.toURI());
+		assertEquals("Children size after remove", 0, compRepo.getChildren().size());
+	}
+
+	public void testAddRepeatChild() {
+		//Setup: create an uncompressed repository
+		CompositeMetadataRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		File child = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		//Add the same repo again
+		compRepo.addChild(child.toURI());
+		//size should not change
+		assertEquals("Children size after repeat entry", 1, compRepo.getChildren().size());
+	}
+
+	public void testAddMultipleChildren() {
+		//Setup: create an uncompressed repository
+		CompositeMetadataRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		File child1 = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child1.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		File child2 = getTestData("2", "/testData/mirror/mirrorSourceRepo2");
+		compRepo.addChild(child2.toURI());
+		assertEquals("Children size with 2 children", 2, compRepo.getChildren().size());
+
+		IMetadataRepositoryManager metadataRepositoryManager = getMetadataRepositoryManager();
+		IMetadataRepository repo1 = null;
+		IMetadataRepository repo2 = null;
+		try {
+			repo1 = metadataRepositoryManager.loadRepository(child1.toURI(), null);
+			repo2 = metadataRepositoryManager.loadRepository(child2.toURI(), null);
+		} catch (ProvisionException e) {
+			fail("Unable to load repositories for verification", e);
+		}
+
+		assertContains("Assert child1's content is in composite repo", repo1, compRepo);
+		assertContains("Assert child2's content is in composite repo", repo2, compRepo);
+		//checks that the destination has the correct number of keys (no extras)
+		assertEquals("Assert correct number of IUs", getNumUnique(repo1.query(InstallableUnitQuery.ANY, new Collector(), null), repo2.query(InstallableUnitQuery.ANY, new Collector(), null)), compRepo.query(InstallableUnitQuery.ANY, new Collector(), null).size());
+	}
+
+	public void testRemoveNonexistantChild() {
+		//Setup: create an uncompressed repository
+		CompositeMetadataRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		//Setup, populate the children
+		File child = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		File invalidChild = getTestData("2", "/testData/mirror/mirrorSourceRepo2");
+		compRepo.removeChild(invalidChild.toURI());
+		//Should not affect the size of children
+		assertEquals("Children size after remove", 1, compRepo.getChildren().size());
+	}
+
+	public void testRemoveAllChildren() {
+		//Setup: create an uncompressed repository
+		CompositeMetadataRepository compRepo = createRepo(false);
+
+		assertEquals("Initial Children size", 0, compRepo.getChildren().size());
+
+		File child1 = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child1.toURI());
+		assertEquals("Children size with 1 child", 1, compRepo.getChildren().size());
+
+		File child2 = getTestData("2", "/testData/mirror/mirrorSourceRepo2");
+		compRepo.addChild(child2.toURI());
+		assertEquals("Children size with 2 children", 2, compRepo.getChildren().size());
+
+		compRepo.removeAllChildren();
+		assertEquals("Children size after removeAllChildren", 0, compRepo.getChildren().size());
+	}
+
+	public void testCompressedPersistence() {
+		persistenceTest(true);
+	}
+
+	public void testUncompressedPersistence() {
+		persistenceTest(false);
+	}
+
+	private void persistenceTest(boolean compressed) {
+		//Setup: create an uncompressed repository
+		CompositeMetadataRepository compRepo = createRepo(compressed);
+
+		//Add data. forces write to disk.
+		File child1 = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		compRepo.addChild(child1.toURI());
+		File child2 = getTestData("2", "/testData/mirror/mirrorSourceRepo2");
+		compRepo.addChild(child2.toURI());
+		//Assume success (covered by other tests)
+
+		//Remove repo from memory
+		IMetadataRepositoryManager metadataRepositoryManager = getMetadataRepositoryManager();
+		metadataRepositoryManager.removeRepository(repoLocation.toURI());
+		compRepo = null;
+
+		//load repository off disk
+		IMetadataRepository repo = null;
+		try {
+			repo = metadataRepositoryManager.loadRepository(repoLocation.toURI(), null);
+		} catch (ProvisionException e) {
+			fail("Could not load repository after removal", e);
+		}
+		assertTrue("loaded repository was of type CompositeMetadataRepository", repo instanceof CompositeMetadataRepository);
+
+		compRepo = (CompositeMetadataRepository) repo;
+
+		IMetadataRepository repo1 = null;
+		IMetadataRepository repo2 = null;
+		try {
+			repo1 = metadataRepositoryManager.loadRepository(child1.toURI(), null);
+			repo2 = metadataRepositoryManager.loadRepository(child2.toURI(), null);
+		} catch (ProvisionException e) {
+			fail("Unable to load repositories for verification", e);
+		}
+
+		assertContains("Assert child1's content is in composite repo", repo1, compRepo);
+		assertContains("Assert child2's content is in composite repo", repo2, compRepo);
+		//checks that the destination has the correct number of keys (no extras)
+		assertEquals("Assert correct number of IUs", getNumUnique(repo1.query(InstallableUnitQuery.ANY, new Collector(), null), repo2.query(InstallableUnitQuery.ANY, new Collector(), null)), compRepo.query(InstallableUnitQuery.ANY, new Collector(), null).size());
+	}
+
+	private CompositeMetadataRepository createRepo(boolean compressed) {
+		IMetadataRepositoryManager metadataRepositoryManager = getMetadataRepositoryManager();
+		Map properties = new HashMap();
+		properties.put(IRepository.PROP_COMPRESSED, compressed ? "true" : "false");
+		IMetadataRepository repo = null;
+		try {
+			repo = metadataRepositoryManager.createRepository(repoLocation.toURI(), "metadata name", IMetadataRepositoryManager.TYPE_COMPOSITE_REPOSITORY, properties);
+		} catch (ProvisionException e) {
+			fail("Could not create repository");
+		}
+
+		//esnure proper type of repository has been created
+		if (!(repo instanceof CompositeMetadataRepository))
+			fail("Repository is not a CompositeMetadataRepository");
+
+		return (CompositeMetadataRepository) repo;
+	}
+
+	/**
+	 * Takes 2 collectors, compares them, and returns the number of unique keys
+	 * Needed to verify that only the appropriate number of files have been transfered by the mirror application
+	 */
+	private int getNumUnique(Collector c1, Collector c2) {
+		Object[] repo1 = c1.toCollection().toArray();
+		Object[] repo2 = c2.toCollection().toArray();
+
+		//initialize to the size of both collectors
+		int numKeys = repo1.length + repo2.length;
+
+		for (int i = 0; i < repo1.length; i++) {
+			for (int j = 0; j < repo2.length; j++) {
+				if (isEqual((IInstallableUnit) repo1[i], (IInstallableUnit) repo2[j]))
+					numKeys--;
+				//identical keys has bee found, therefore the number of unique keys is one less than previously thought
+			}
+		}
+		return numKeys;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/mirror/ArtifactMirrorApplicationTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/mirror/ArtifactMirrorApplicationTest.java
index 35266dd..fdc734f 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/mirror/ArtifactMirrorApplicationTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/mirror/ArtifactMirrorApplicationTest.java
@@ -16,6 +16,7 @@ import java.util.*;
 import org.eclipse.core.runtime.NullProgressMonitor;
 import org.eclipse.equinox.app.IApplicationContext;
 import org.eclipse.equinox.internal.p2.artifact.mirror.MirrorApplication;
+import org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository;
 import org.eclipse.equinox.internal.p2.artifact.repository.simple.SimpleArtifactRepository;
 import org.eclipse.equinox.internal.p2.core.helpers.OrderedProperties;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
@@ -996,4 +997,38 @@ public class ArtifactMirrorApplicationTest extends AbstractProvisioningTest {
 		//make sure artifacts.xml does not exist
 		assertFalse("7", destArtifactsXML.exists());
 	}
+
+	public void testMirrorApplicationWithCompositeSource() {
+		//Setup Make composite repository
+		File repoLocation = new File(getTempFolder(), "CompositeArtifactMirrorTest");
+		AbstractProvisioningTest.delete(repoLocation);
+		IArtifactRepository repo = null;
+		try {
+			repo = getArtifactRepositoryManager().createRepository(repoLocation.toURI(), "artifact name", IArtifactRepositoryManager.TYPE_COMPOSITE_REPOSITORY, null);
+		} catch (ProvisionException e) {
+			fail("Could not create repository");
+		}
+		//ensure proper type of repository has been created
+		if (!(repo instanceof CompositeArtifactRepository))
+			fail("Repository is not a CompositeArtifactRepository");
+		//Populate source
+		File child1 = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		File child2 = getTestData("2", "/testData/mirror/mirrorSourceRepo2");
+		((CompositeArtifactRepository) repo).addChild(child1.toURI());
+		((CompositeArtifactRepository) repo).addChild(child2.toURI());
+
+		runMirrorApplication("Mirroring from Composite Source", repoLocation, destRepoLocation, false);
+
+		try {
+			assertContentEquals("Verifying contents", repo, getArtifactRepositoryManager().loadRepository(destRepoLocation.toURI(), null));
+
+			//Verify that result is the same as mirroring from the 2 repositories separately
+			assertContains("3", getManager().loadRepository(sourceRepoLocation.toURI(), null), getManager().loadRepository(destRepoLocation.toURI(), null));
+			assertContains("4", getManager().loadRepository(sourceRepo2Location.toURI(), null), getManager().loadRepository(destRepoLocation.toURI(), null));
+			//checks that the destination has the correct number of keys (no extras)
+			assertEquals("5", getManager().loadRepository(sourceRepoLocation.toURI(), null).getArtifactKeys().length + getManager().loadRepository(sourceRepo2Location.toURI(), null).getArtifactKeys().length, getManager().loadRepository(destRepoLocation.toURI(), null).getArtifactKeys().length);
+		} catch (ProvisionException e) {
+			fail("Could not load destination", e);
+		}
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/mirror/MetadataMirrorApplicationTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/mirror/MetadataMirrorApplicationTest.java
index fc3d3a2..47efce9 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/mirror/MetadataMirrorApplicationTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/mirror/MetadataMirrorApplicationTest.java
@@ -17,6 +17,7 @@ import java.util.Map;
 import org.eclipse.equinox.app.IApplicationContext;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.internal.p2.metadata.mirror.MirrorApplication;
+import org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
 import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepository;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
@@ -890,4 +891,38 @@ public class MetadataMirrorApplicationTest extends AbstractProvisioningTest {
 		//make sure content.xml exists
 		assertFalse("7", destMetadataXML.exists());
 	}
+
+	public void testMirrorApplicationWithCompositeSource() {
+		//Setup Make composite repository
+		File repoLocation = new File(getTempFolder(), "CompositeMetadataMirrorTest");
+		AbstractProvisioningTest.delete(repoLocation);
+		IMetadataRepository repo = null;
+		try {
+			repo = getMetadataRepositoryManager().createRepository(repoLocation.toURI(), "metadata name", IMetadataRepositoryManager.TYPE_COMPOSITE_REPOSITORY, null);
+		} catch (ProvisionException e) {
+			fail("Could not create repository");
+		}
+		//ensure proper type of repository has been created
+		if (!(repo instanceof CompositeMetadataRepository))
+			fail("Repository is not a CompositeMetadataRepository");
+		//Populate source
+		File child1 = getTestData("1", "/testData/mirror/mirrorSourceRepo1 with space");
+		File child2 = getTestData("2", "/testData/mirror/mirrorSourceRepo2");
+		((CompositeMetadataRepository) repo).addChild(child1.toURI());
+		((CompositeMetadataRepository) repo).addChild(child2.toURI());
+
+		runMirrorApplication("Mirroring from Composite Source", repoLocation, destRepoLocation, false);
+
+		try {
+			assertContentEquals("Verifying contents", repo, getMetadataRepositoryManager().loadRepository(destRepoLocation.toURI(), null));
+
+			//Verify that result is the same as mirroring from the 2 repositories seperately
+			assertContains("3", getManager().loadRepository(sourceRepoLocation.toURI(), null), getManager().loadRepository(destRepoLocation.toURI(), null));
+			assertContains("4", getManager().loadRepository(sourceRepo2Location.toURI(), null), getManager().loadRepository(destRepoLocation.toURI(), null));
+			//checks that the destination has the correct number of keys (no extras)
+			assertEquals("5", getNumUnique(getManager().loadRepository(sourceRepoLocation.toURI(), null).query(InstallableUnitQuery.ANY, new Collector(), null), getManager().loadRepository(sourceRepo2Location.toURI(), null).query(InstallableUnitQuery.ANY, new Collector(), null)), getManager().loadRepository(destRepoLocation.toURI(), null).query(InstallableUnitQuery.ANY, new Collector(), null).size());
+		} catch (ProvisionException e) {
+			fail("Could not load destination", e);
+		}
+	}
 }
