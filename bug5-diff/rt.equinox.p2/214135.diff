commit 5a0e8a37d4c61d4aedda8e2c6f8420890edddff5
Author: John Arthorne <johna>
Date:   Wed Jan 2 17:27:33 2008 +0000

    Bug 214135 - factory method for TouchpointData

2	2	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
8	8	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
9	3	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
2	1	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/InstallableUnit.java
17	0	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
2	3	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/TouchpointData.java
2	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
2	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentTest.java
1	1	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
index 59ba598..0760bb5 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
@@ -144,7 +144,7 @@ public class Generator {
 		}
 		touchpointData.put("configure", configurationData);
 		touchpointData.put("unconfigure", unconfigurationData);
-		root.addTouchpointData(new TouchpointData(touchpointData));
+		root.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		return MetadataFactory.createInstallableUnit(root);
 	}
 
@@ -376,7 +376,7 @@ public class Generator {
 		touchpointData.put("install", configurationData); //$NON-NLS-1$
 		String unConfigurationData = "cleanupzip(source:@artifact, target:${installFolder});"; //$NON-NLS-1$
 		touchpointData.put("uninstall", unConfigurationData); //$NON-NLS-1$
-		cu.addTouchpointData(new TouchpointData(touchpointData));
+		cu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		resultantIUs.add(MetadataFactory.createInstallableUnit(cu));
 
 		//Create the artifact descriptor
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
index 72e86ed..ebc3071 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
@@ -96,7 +96,7 @@ public class MetadataGeneratorHelper {
 		touchpointData.put("uninstall", "uninstallBundle(bundle:${artifact})");
 		touchpointData.put("configure", createConfigScript(configInfo, isBundleFragment));
 		touchpointData.put("unconfigure", createUnconfigScript(configInfo, isBundleFragment));
-		cu.addTouchpointData(new TouchpointData(touchpointData));
+		cu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		cu.setFilter(filter);
 		return MetadataFactory.createInstallableUnit(cu);
 	}
@@ -185,7 +185,7 @@ public class MetadataGeneratorHelper {
 		if (isFolderPlugin)
 			touchpointData.put("zipped", "true");
 		touchpointData.put("manifest", toManifestString(manifest));
-		iu.addTouchpointData(new TouchpointData(touchpointData));
+		iu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		return MetadataFactory.createInstallableUnit(iu);
 	}
 
@@ -265,7 +265,7 @@ public class MetadataGeneratorHelper {
 		touchpointData.put("configure", createDefaultBundleConfigScript(configInfo)); //$NON-NLS-1$
 		touchpointData.put("unconfigure", createDefaultBundleUnconfigScript(unconfigInfo)); //$NON-NLS-1$
 
-		cu.addTouchpointData(new TouchpointData(touchpointData));
+		cu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		return MetadataFactory.createInstallableUnit(cu);
 	}
 
@@ -294,7 +294,7 @@ public class MetadataGeneratorHelper {
 		Map touchpointData = new HashMap();
 		touchpointData.put("install", "installFeature(feature:${artifact},featureId:default,featureVersion:default)"); //$NON-NLS-1$//$NON-NLS-2$
 		touchpointData.put("uninstall", "uninstallFeature(feature:${artifact},featureId:default,featureVersion:default)"); //$NON-NLS-1$//$NON-NLS-2$
-		cu.addTouchpointData(new TouchpointData(touchpointData));
+		cu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 
 		return MetadataFactory.createInstallableUnit(cu);
 	}
@@ -338,7 +338,7 @@ public class MetadataGeneratorHelper {
 			// that this is something that will not impact the configuration.
 			Map touchpointData = new HashMap();
 			touchpointData.put("zipped", "true");
-			iu.addTouchpointData(new TouchpointData(touchpointData));
+			iu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		}
 		return MetadataFactory.createInstallableUnit(iu);
 	}
@@ -400,7 +400,7 @@ public class MetadataGeneratorHelper {
 			resultantIUs.add(MetadataFactory.createInstallableUnit(iu));
 
 			touchpointData.put("install", "");
-			cu.addTouchpointData(new TouchpointData(touchpointData));
+			cu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 			resultantIUs.add(MetadataFactory.createInstallableUnit(cu));
 			return null;
 		}
@@ -416,7 +416,7 @@ public class MetadataGeneratorHelper {
 		touchpointData.put("install", configurationData);
 		String unConfigurationData = "cleanupzip(source:@artifact, target:${installFolder});"; //$NON-NLS-1$
 		touchpointData.put("uninstall", unConfigurationData); //$NON-NLS-1$
-		cu.addTouchpointData(new TouchpointData(touchpointData));
+		cu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		resultantIUs.add(MetadataFactory.createInstallableUnit(cu));
 
 		//Create the artifact descriptor
@@ -465,7 +465,7 @@ public class MetadataGeneratorHelper {
 		touchpointData.put("install", configurationData);
 		String unConfigurationData = "cleanupzip(source:@artifact, target:${installFolder});"; //$NON-NLS-1$
 		touchpointData.put("uninstall", unConfigurationData); //$NON-NLS-1$
-		cu.addTouchpointData(new TouchpointData(touchpointData));
+		cu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		resultantIUs.add(MetadataFactory.createInstallableUnitFragment(cu));
 
 		//Create the artifact descriptor
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
index 6e6e81d..53a0458 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
@@ -407,12 +407,15 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 		}
 
 		public TouchpointData[] getTouchpointData() {
-			return (TouchpointData[]) data.toArray(new TouchpointData[data.size()]);
+			TouchpointData[] result = new TouchpointData[data.size()];
+			for (int i = 0; i < result.length; i++)
+				result[i] = ((TouchpointInstructionsHandler) data.get(i)).getTouchpointData();
+			return result;
 		}
 
 		public void startElement(String name, Attributes attributes) {
 			if (name.equals(TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT)) {
-				new TouchpointInstructionsHandler(this, attributes, data);
+				data.add(new TouchpointInstructionsHandler(this, attributes, data));
 			} else {
 				invalidElement(name, attributes);
 			}
@@ -427,7 +430,10 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 			super(parentHandler, TOUCHPOINT_DATA_INSTRUCTIONS_ELEMENT);
 			String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);
 			instructions = (size != null ? new LinkedHashMap(new Integer(size).intValue()) : new LinkedHashMap(4));
-			data.add(new TouchpointData(instructions));
+		}
+
+		public TouchpointData getTouchpointData() {
+			return MetadataFactory.createTouchpointData(instructions);
 		}
 
 		public void startElement(String name, Attributes attributes) {
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/InstallableUnit.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/InstallableUnit.java
index 63b4a42..98f4200 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/InstallableUnit.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/InstallableUnit.java
@@ -19,6 +19,7 @@ public class InstallableUnit implements IInstallableUnit {
 	private static final OrderedProperties NO_PROPERTIES = new OrderedProperties();
 	private static final ProvidedCapability[] NO_PROVIDES = new ProvidedCapability[0];
 	private static final RequiredCapability[] NO_REQUIRES = new RequiredCapability[0];
+	private static final TouchpointData[] NO_TOUCHPOINT_DATA = new TouchpointData[0];
 
 	String applicabilityFilter;
 	private IArtifactKey[] artifacts;
@@ -147,7 +148,7 @@ public class InstallableUnit implements IInstallableUnit {
 	}
 
 	public TouchpointData[] getTouchpointData() {
-		return (touchpointData == null ? TouchpointData.NO_TOUCHPOINT_DATA //
+		return (touchpointData == null ? NO_TOUCHPOINT_DATA //
 				: (TouchpointData[]) touchpointData.toArray(new TouchpointData[touchpointData.size()]));
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
index 7c68f2f..726e4ed 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
@@ -10,6 +10,7 @@
  *******************************************************************************/
 package org.eclipse.equinox.p2.metadata;
 
+import java.util.*;
 import org.eclipse.core.runtime.Assert;
 import org.eclipse.equinox.internal.p2.metadata.*;
 import org.eclipse.osgi.service.resolver.VersionRange;
@@ -97,6 +98,11 @@ public class MetadataFactory {
 	}
 
 	/**
+	 * Singleton touchpoint data for a touchpoint with no instructions.
+	 */
+	private static final TouchpointData EMPTY_TOUCHPOINT_DATA = new TouchpointData(Collections.EMPTY_MAP);
+
+	/**
 	 * Creates and returns an {@link IInstallableUnit} based on the given 
 	 * description.  Once the installable unit has been created, the information is 
 	 * discarded from the description object.
@@ -139,4 +145,15 @@ public class MetadataFactory {
 		return new ResolvedInstallableUnit(unit, fragments);
 
 	}
+
+	/**
+	 * Creates an instance of {@link TouchpointData} with the given instructions.
+	 * @param instructions The instructions for the touchpoint data.
+	 * @return The created touchpoint data
+	 */
+	public static TouchpointData createTouchpointData(Map instructions) {
+		Assert.isNotNull(instructions);
+		//copy the map to protect against subsequent change by caller
+		return instructions.isEmpty() ? EMPTY_TOUCHPOINT_DATA : new TouchpointData(new LinkedHashMap(instructions));
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/TouchpointData.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/TouchpointData.java
index 58c0f85..e1b91bf 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/TouchpointData.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/TouchpointData.java
@@ -14,12 +14,11 @@ import java.util.Collections;
 import java.util.Map;
 
 public class TouchpointData {
-	public static TouchpointData[] NO_TOUCHPOINT_DATA = new TouchpointData[0];
 
 	/**
 	 * Map of (String->String). The values represent the instructions. The set 
 	 * of keys supported is up to the touchpoint that will process these 
-	 * instructions
+	 * instructions. This map is never null.
 	 */
 	private Map instructions;
 
@@ -46,7 +45,7 @@ public class TouchpointData {
 		return true;
 	}
 
-	public TouchpointData(Map instructions) {
+	TouchpointData(Map instructions) {
 		this.instructions = instructions;
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
index d0c2cf0..2ff3d1f 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
@@ -216,7 +216,7 @@ public class EngineTest extends AbstractProvisioningTest {
 
 		IInstallableUnitFragment[] cus = new IInstallableUnitFragment[1];
 		InstallableUnitFragmentDescription desc = new InstallableUnitFragmentDescription();
-		desc.addTouchpointData(new TouchpointData(touchpointData));
+		desc.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		IInstallableUnitFragment fragment = MetadataFactory.createInstallableUnitFragment(desc);
 		cus[0] = fragment;
 
@@ -243,7 +243,7 @@ public class EngineTest extends AbstractProvisioningTest {
 
 		IInstallableUnitFragment[] cus = new IInstallableUnitFragment[1];
 		InstallableUnitFragmentDescription desc = new InstallableUnitFragmentDescription();
-		desc.addTouchpointData(new TouchpointData(touchpointData));
+		desc.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		cus[0] = MetadataFactory.createInstallableUnitFragment(desc);
 
 		//IArtifactKey key = new ArtifactKey("eclipse", "plugin", "org.eclipse.osgi", new Version("3.3.1.R33x_v20070828"));
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentTest.java
index 98832a7..9ae5fa4 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentTest.java
@@ -112,12 +112,12 @@ public class FragmentTest extends AbstractProvisioningTest {
 	}
 
 	private IInstallableUnit createIUWithTouchpointData() {
-		TouchpointData data = new TouchpointData(new HashMap());
+		TouchpointData data = MetadataFactory.createTouchpointData(new HashMap());
 		return createEclipseIU("ui.test1", DEFAULT_VERSION, NO_REQUIRES, data);
 	}
 
 	private IInstallableUnit createIUFragmentWithTouchpointData() {
-		TouchpointData data = new TouchpointData(new HashMap());
+		TouchpointData data = MetadataFactory.createTouchpointData(new HashMap());
 		IInstallableUnitFragment unit = createBundleFragment("iuFragment.test1", DEFAULT_VERSION, data);
 		return unit;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
index 21f226c..1272fb0 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
@@ -107,7 +107,7 @@ public class IUPersistenceTest extends AbstractProvisioningTest {
 			String[] nextInstruction = instructionData[i];
 			map.put(nextInstruction[0], nextInstruction[1]);
 		}
-		return new TouchpointData(map);
+		return MetadataFactory.createTouchpointData(map);
 	}
 
 	private static String IU_TEST_TARGET = "installableUnitTest";
commit 246249f3b180473bdf40ade3b519aeddd75e2e00
Author: John Arthorne <johna>
Date:   Wed Jan 2 18:43:00 2008 +0000

    Bug 214135 - add factory method for TouchpointType

3	3	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
2	2	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
38	1	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
3	3	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/TouchpointType.java
2	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
3	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
4	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/InstallRegistryTest.java
3	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/TouchpointTest.java
3	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentMethodTest.java
2	2	bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
2	2	bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
2	2	bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/dialogs/IUImplementationGroup.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
index ebc3071..935ced9 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -54,8 +54,8 @@ public class MetadataGeneratorHelper {
 
 	private static final Version versionMax = new Version(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);
 
-	public static final TouchpointType TOUCHPOINT_NATIVE = new TouchpointType("native", new Version(1, 0, 0)); //$NON-NLS-1$
-	public static final TouchpointType TOUCHPOINT_ECLIPSE = new TouchpointType("eclipse", new Version(1, 0, 0)); //$NON-NLS-1$
+	public static final TouchpointType TOUCHPOINT_NATIVE = MetadataFactory.createTouchpointType("native", new Version(1, 0, 0)); //$NON-NLS-1$
+	public static final TouchpointType TOUCHPOINT_ECLIPSE = MetadataFactory.createTouchpointType("eclipse", new Version(1, 0, 0)); //$NON-NLS-1$
 
 	public static final ProvidedCapability BUNDLE_CAPABILITY = new ProvidedCapability(IInstallableUnit.CAPABILITY_ECLIPSE_TYPES, IInstallableUnit.CAPABILITY_ECLIPSE_BUNDLE, new Version(1, 0, 0));
 	public static final ProvidedCapability FEATURE_CAPABILITY = new ProvidedCapability(IInstallableUnit.CAPABILITY_ECLIPSE_TYPES, IInstallableUnit.CAPABILITY_ECLIPSE_FEATURE, new Version(1, 0, 0));
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
index 53a0458..3ce5831 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -382,7 +382,7 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 			super(parentHandler, TOUCHPOINT_TYPE_ELEMENT);
 			String[] values = parseRequiredAttributes(attributes, required);
 			Version version = checkVersion(TOUCHPOINT_TYPE_ELEMENT, VERSION_ATTRIBUTE, values[1]);
-			touchpointType = new TouchpointType(values[0], version);
+			touchpointType = MetadataFactory.createTouchpointType(values[0], version);
 		}
 
 		public TouchpointType getTouchpointType() {
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
index 726e4ed..a4f9a66 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -102,6 +102,10 @@ public class MetadataFactory {
 	 */
 	private static final TouchpointData EMPTY_TOUCHPOINT_DATA = new TouchpointData(Collections.EMPTY_MAP);
 
+	private static TouchpointType[] typeCache = new TouchpointType[5];
+
+	private static int typeCacheOffset;
+
 	/**
 	 * Creates and returns an {@link IInstallableUnit} based on the given 
 	 * description.  Once the installable unit has been created, the information is 
@@ -148,6 +152,7 @@ public class MetadataFactory {
 
 	/**
 	 * Creates an instance of {@link TouchpointData} with the given instructions.
+	 * 
 	 * @param instructions The instructions for the touchpoint data.
 	 * @return The created touchpoint data
 	 */
@@ -156,4 +161,36 @@ public class MetadataFactory {
 		//copy the map to protect against subsequent change by caller
 		return instructions.isEmpty() ? EMPTY_TOUCHPOINT_DATA : new TouchpointData(new LinkedHashMap(instructions));
 	}
+
+	/**
+	 * Creates a touchpoint type with the given id and version.
+	 * 
+	 * @param id The touchpoint id
+	 * @param version The touchpoint version
+	 * @return A touchpoint type instance with the given id and version
+	 */
+	public static TouchpointType createTouchpointType(String id, Version version) {
+		TouchpointType result = getCachedTouchpointType(id, version);
+		if (result != null)
+			return result;
+		result = new TouchpointType(id, version);
+		putCachedTouchpointType(result);
+		return result;
+	}
+
+	private static TouchpointType getCachedTouchpointType(String id, Version version) {
+		synchronized (typeCache) {
+			for (int i = 0; i < typeCache.length; i++) {
+				if (typeCache[i] != null && typeCache[i].getId().equals(id) && typeCache[i].getVersion().equals(version))
+					return typeCache[i];
+			}
+		}
+		return null;
+	}
+
+	private static void putCachedTouchpointType(TouchpointType result) {
+		//simple rotating buffer
+		typeCache[typeCacheOffset] = result;
+		typeCacheOffset = (typeCacheOffset + 1) % typeCache.length;
+	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/TouchpointType.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/TouchpointType.java
index 867a8a6..d2a6d38 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/TouchpointType.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/TouchpointType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -21,11 +21,11 @@ public class TouchpointType {
 	 * A touchpoint type indicating that the "null" touchpoint should be used.
 	 * The null touchpoint does not participate in any install phase.
 	 */
-	public static final TouchpointType NONE = new TouchpointType("null", new Version("0")); //$NON-NLS-1$//$NON-NLS-2$
+	public static final TouchpointType NONE = MetadataFactory.createTouchpointType("null", Version.emptyVersion); //$NON-NLS-1$
 	private String id;
 	private Version versionObject;
 
-	public TouchpointType(String id, Version aVersion) {
+	TouchpointType(String id, Version aVersion) {
 		this.id = id;
 		this.versionObject = aVersion;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
index 2001a81..8fdf299 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -38,7 +38,7 @@ public class AbstractProvisioningTest extends TestCase {
 	private static final RequiredCapability[] BUNDLE_REQUIREMENT = new RequiredCapability[] {new RequiredCapability("eclipse.touchpoint", "bundle", VersionRange.emptyRange, null, false, true)};
 
 	protected static final Version DEFAULT_VERSION = new Version(1, 0, 0);
-	protected static final TouchpointType ECLIPSE_TOUCHPOINT = new TouchpointType("eclipse", new Version(1, 0, 0));
+	protected static final TouchpointType ECLIPSE_TOUCHPOINT = MetadataFactory.createTouchpointType("eclipse", new Version(1, 0, 0));
 
 	protected static final Map NO_PROPERTIES = Collections.EMPTY_MAP;
 	protected static final ProvidedCapability[] NO_PROVIDES = new ProvidedCapability[0];
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
index 2ff3d1f..254df74 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/EngineTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -203,7 +203,7 @@ public class EngineTest extends AbstractProvisioningTest {
 		InstallableUnitDescription description = new MetadataFactory.InstallableUnitDescription();
 		description.setId("org.eclipse.osgi");
 		description.setVersion(new Version("3.3.1.R33x_v20070828"));
-		description.setTouchpointType(new TouchpointType("eclipse", new Version("1.0.0")));
+		description.setTouchpointType(MetadataFactory.createTouchpointType("eclipse", new Version("1.0.0")));
 		Map touchpointData = new HashMap();
 		String manifest = "Manifest-Version: 1.0\r\n" + "Bundle-Activator: org.eclipse.osgi.framework.internal.core.SystemBundl\r\n" + " eActivator\r\n" + "Bundle-RequiredExecutionEnvironment: J2SE-1.4,OSGi/Minimum-1.0\r\n" + "Export-Package: org.eclipse.osgi.event;version=\"1.0\",org.eclipse.osgi.\r\n" + " framework.console;version=\"1.0\",org.eclipse.osgi.framework.eventmgr;v\r\n" + " ersion=\"1.0\",org.eclipse.osgi.framework.log;version=\"1.0\",org.eclipse\r\n" + " .osgi.service.datalocation;version=\"1.0\",org.eclipse.osgi.service.deb\r\n" + " ug;version=\"1.0\",org.eclipse.osgi.service.environment;version=\"1.0\",o\r\n" + " rg.eclipse.osgi.service.localization;version=\"1.0\",org.eclipse.osgi.s\r\n" + " ervice.pluginconversion;version=\"1.0\",org.eclipse.osgi.service.resolv\r\n"
 				+ " er;version=\"1.1\",org.eclipse.osgi.service.runnable;version=\"1.0\",org.\r\n" + " eclipse.osgi.service.urlconversion;version=\"1.0\",org.eclipse.osgi.sto\r\n" + " ragemanager;version=\"1.0\",org.eclipse.osgi.util;version=\"1.0\",org.osg\r\n" + " i.framework;version=\"1.3\",org.osgi.service.condpermadmin;version=\"1.0\r\n" + " \",org.osgi.service.packageadmin;version=\"1.2\",org.osgi.service.permis\r\n" + " sionadmin;version=\"1.2\",org.osgi.service.startlevel;version=\"1.0\",org\r\n" + " .osgi.service.url;version=\"1.0\",org.osgi.util.tracker;version=\"1.3.2\"\r\n" + " ,org.eclipse.core.runtime.adaptor;x-friends:=\"org.eclipse.core.runtim\r\n" + " e\",org.eclipse.core.runtime.internal.adaptor;x-internal:=true,org.ecl\r\n"
@@ -231,7 +231,7 @@ public class EngineTest extends AbstractProvisioningTest {
 		InstallableUnitDescription description = new MetadataFactory.InstallableUnitDescription();
 		description.setId("org.eclipse.osgi.bad");
 		description.setVersion(new Version("3.3.1.R33x_v20070828"));
-		description.setTouchpointType(new TouchpointType("eclipse", new Version("1.0.0")));
+		description.setTouchpointType(MetadataFactory.createTouchpointType("eclipse", new Version("1.0.0")));
 		Map touchpointData = new HashMap();
 		String manifest = "Manifest-Version: 1.0\r\n" + "Bundle-Activator: org.eclipse.osgi.framework.internal.core.SystemBundl\r\n" + " eActivator\r\n" + "Bundle-RequiredExecutionEnvironment: J2SE-1.4,OSGi/Minimum-1.0\r\n" + "Export-Package: org.eclipse.osgi.event;version=\"1.0\",org.eclipse.osgi.\r\n" + " framework.console;version=\"1.0\",org.eclipse.osgi.framework.eventmgr;v\r\n" + " ersion=\"1.0\",org.eclipse.osgi.framework.log;version=\"1.0\",org.eclipse\r\n" + " .osgi.service.datalocation;version=\"1.0\",org.eclipse.osgi.service.deb\r\n" + " ug;version=\"1.0\",org.eclipse.osgi.service.environment;version=\"1.0\",o\r\n" + " rg.eclipse.osgi.service.localization;version=\"1.0\",org.eclipse.osgi.s\r\n" + " ervice.pluginconversion;version=\"1.0\",org.eclipse.osgi.service.resolv\r\n"
 				+ " er;version=\"1.1\",org.eclipse.osgi.service.runnable;version=\"1.0\",org.\r\n" + " eclipse.osgi.service.urlconversion;version=\"1.0\",org.eclipse.osgi.sto\r\n" + " ragemanager;version=\"1.0\",org.eclipse.osgi.util;version=\"1.0\",org.osg\r\n" + " i.framework;version=\"1.3\",org.osgi.service.condpermadmin;version=\"1.0\r\n" + " \",org.osgi.service.packageadmin;version=\"1.2\",org.osgi.service.permis\r\n" + " sionadmin;version=\"1.2\",org.osgi.service.startlevel;version=\"1.0\",org\r\n" + " .osgi.service.url;version=\"1.0\",org.osgi.util.tracker;version=\"1.3.2\"\r\n" + " ,org.eclipse.core.runtime.adaptor;x-friends:=\"org.eclipse.core.runtim\r\n" + " e\",org.eclipse.core.runtime.internal.adaptor;x-internal:=true,org.ecl\r\n"
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/InstallRegistryTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/InstallRegistryTest.java
index 61cf516..ed78462 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/InstallRegistryTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/InstallRegistryTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -13,7 +13,8 @@ package org.eclipse.equinox.p2.tests.engine;
 import org.eclipse.core.runtime.NullProgressMonitor;
 import org.eclipse.equinox.internal.p2.installregistry.IInstallRegistry;
 import org.eclipse.equinox.p2.engine.*;
-import org.eclipse.equinox.p2.metadata.*;
+import org.eclipse.equinox.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.p2.metadata.MetadataFactory;
 import org.eclipse.equinox.p2.metadata.MetadataFactory.InstallableUnitDescription;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
 import org.eclipse.equinox.p2.tests.TestActivator;
@@ -94,7 +95,7 @@ public class InstallRegistryTest extends AbstractProvisioningTest {
 		InstallableUnitDescription description = new MetadataFactory.InstallableUnitDescription();
 		description.setId("org.eclipse.test");
 		description.setVersion(new Version("1.0.0"));
-		description.setTouchpointType(new TouchpointType("null", new Version("1.0.0")));
+		description.setTouchpointType(MetadataFactory.createTouchpointType("null", new Version("1.0.0")));
 		IInstallableUnit unit = MetadataFactory.createInstallableUnit(description);
 		return createResolvedIU(unit);
 	}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/TouchpointTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/TouchpointTest.java
index 17e3d58..73e1b52 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/TouchpointTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/engine/TouchpointTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -63,7 +63,7 @@ public class TouchpointTest extends AbstractProvisioningTest {
 		}
 
 		public TouchpointType getTouchpointType() {
-			return new TouchpointType("test", new Version("1.0.0"));
+			return MetadataFactory.createTouchpointType("test", new Version("1.0.0"));
 		}
 	}
 
@@ -148,7 +148,7 @@ public class TouchpointTest extends AbstractProvisioningTest {
 		InstallableUnitDescription description = new MetadataFactory.InstallableUnitDescription();
 		description.setId("org.eclipse.test");
 		description.setVersion(new Version("1.0.0"));
-		description.setTouchpointType(new TouchpointType(touchpointName, new Version("1.0.0")));
+		description.setTouchpointType(MetadataFactory.createTouchpointType(touchpointName, new Version("1.0.0")));
 		IInstallableUnit unit = MetadataFactory.createInstallableUnit(description);
 		return createResolvedIU(unit);
 	}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentMethodTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentMethodTest.java
index 49f941d..fec2f7d 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentMethodTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentMethodTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -154,7 +154,7 @@ public class FragmentMethodTest extends TestCase {
 		InstallableUnitFragmentDescription iu = new InstallableUnitFragmentDescription();
 		iu.setId(name);
 		iu.setVersion(new Version(1, 0, 0));
-		iu.setTouchpointType(new TouchpointType("eclipse", new Version(1, 0, 0)));
+		iu.setTouchpointType(MetadataFactory.createTouchpointType("eclipse", new Version(1, 0, 0)));
 		iu.setProperty(PROP_FRAG, "value");
 		RequiredCapability[] reqs = new RequiredCapability[] {new RequiredCapability("eclipse.touchpoint", "bundle", VersionRange.emptyRange, null, false, true), new RequiredCapability(TEST_REQUIRED, TEST_REQUIRED, VersionRange.emptyRange, null, true, false)};
 		iu.setRequiredCapabilities(reqs);
@@ -167,7 +167,7 @@ public class FragmentMethodTest extends TestCase {
 		InstallableUnitDescription iu = new MetadataFactory.InstallableUnitDescription();
 		iu.setId(name);
 		iu.setVersion(new Version(1, 0, 0));
-		iu.setTouchpointType(new TouchpointType("eclipse", new Version(1, 0, 0)));
+		iu.setTouchpointType(MetadataFactory.createTouchpointType("eclipse", new Version(1, 0, 0)));
 		iu.setProperty(PROP_IU, "valueIU");
 		ProvidedCapability[] cap = new ProvidedCapability[] {new ProvidedCapability("eclipse.touchpoint", "bundle", new Version(1, 0, 0)), new ProvidedCapability("testCapability", "testCapability", new Version(1, 0, 0))};
 		iu.setCapabilities(cap);
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java b/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
index 8f5cf3b..2ebdb8d 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.eclipse/src/org/eclipse/equinox/internal/p2/touchpoint/eclipse/EclipseTouchpoint.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -23,7 +23,7 @@ import org.osgi.framework.Version;
 
 public class EclipseTouchpoint extends Touchpoint {
 
-	private static final TouchpointType TOUCHPOINT_TYPE = new TouchpointType("eclipse", new Version("1.0")); //$NON-NLS-1$ //$NON-NLS-2$
+	private static final TouchpointType TOUCHPOINT_TYPE = MetadataFactory.createTouchpointType("eclipse", new Version("1.0")); //$NON-NLS-1$ //$NON-NLS-2$
 
 	private static final String ARTIFACT_FOLDER = "artifact.folder"; //$NON-NLS-1$
 	private static final String ACTION_ADD_JVM_ARG = "addJvmArg"; //$NON-NLS-1$
diff --git a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
index b32176c..4ce6067 100644
--- a/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
+++ b/bundles/org.eclipse.equinox.p2.touchpoint.natives/src/org/eclipse/equinox/internal/p2/touchpoint/natives/NativeTouchpoint.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -98,7 +98,7 @@ public class NativeTouchpoint extends Touchpoint {
 	}
 
 	public TouchpointType getTouchpointType() {
-		return new TouchpointType("native", new Version(1, 0, 0));
+		return MetadataFactory.createTouchpointType("native", new Version(1, 0, 0));
 	}
 
 	private IArtifactRequest[] collect(IInstallableUnit installableUnit, Profile profile) {
diff --git a/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/dialogs/IUImplementationGroup.java b/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/dialogs/IUImplementationGroup.java
index 3b9f2e6..4abeaa5 100644
--- a/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/dialogs/IUImplementationGroup.java
+++ b/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/dialogs/IUImplementationGroup.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -183,7 +183,7 @@ public class IUImplementationGroup extends IUGroup {
 			unit.setVersion(new Version(version.getText().trim()));
 			unit.setProperty(IInstallableUnit.NAMESPACE_IU, namespace.getText().trim());
 			// TODO this is bogus because we don't let user provide a touchpoint type version
-			unit.setTouchpointType(new TouchpointType(touchpointType.getText().trim(), new Version("1.0.0"))); //$NON-NLS-1$
+			unit.setTouchpointType(MetadataFactory.createTouchpointType(touchpointType.getText().trim(), new Version("1.0.0"))); //$NON-NLS-1$
 			iuElement = MetadataFactory.createInstallableUnit(unit);
 		}
 	}
commit 5250a5bee18a499d2560e36f2de4e3fca6d13b59
Author: John Arthorne <johna>
Date:   Wed Jan 2 19:13:33 2008 +0000

    Bug 214135 - added factory methods for RequiredCapability and ProvidedCapability

2	2	bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvCommandProvider.java
4	5	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/IUTransformationHelper.java
6	6	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
3	2	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Recommendation.java
3	2	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/RecommendationDescriptor.java
15	15	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
22	22	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
2	2	bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
2	2	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/InstallableUnitFragment.java
2	2	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IInstallableUnitFragment.java
33	5	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
2	2	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/ProvidedCapability.java
4	26	bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/RequiredCapability.java
4	4	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
9	9	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/AutomatedDirectorTest.java
2	2	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/PickerTest.java
26	26	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/RecommendationTest.java
10	10	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/ResolutionHelperTest.java
3	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentMethodTest.java
3	3	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
3	4	bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/MultipleIUAndFragmentTest.java
3	3	bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/ProvAdminQueryProvider.java
3	3	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKQueryProvider.java
diff --git a/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvCommandProvider.java b/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvCommandProvider.java
index 5d28d64..9b6f726 100644
--- a/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvCommandProvider.java
+++ b/bundles/org.eclipse.equinox.p2.console/src/org/eclipse/equinox/internal/p2/console/ProvCommandProvider.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -194,7 +194,7 @@ public class ProvCommandProvider implements CommandProvider {
 			if (queryable == null)
 				return;
 		}
-		RequiredCapability requirement = new RequiredCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", null, null, false, false); //$NON-NLS-1$
+		RequiredCapability requirement = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", null, null, false, false); //$NON-NLS-1$
 		Query query = new CapabilityQuery(requirement);
 		IInstallableUnit[] units = sort(queryable.query(query, new Collector(), null));
 		for (int i = 0; i < units.length; i++)
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/IUTransformationHelper.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/IUTransformationHelper.java
index 3a2cf7f..10ea9c3 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/IUTransformationHelper.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/IUTransformationHelper.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -10,8 +10,7 @@ package org.eclipse.equinox.internal.p2.director;
 
 import java.util.ArrayList;
 import java.util.Iterator;
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
+import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.osgi.service.resolver.VersionRange;
 
 public class IUTransformationHelper {
@@ -19,7 +18,7 @@ public class IUTransformationHelper {
 		ArrayList result = new ArrayList();
 		while (ius.hasNext()) {
 			IInstallableUnit current = (IInstallableUnit) ius.next();
-			result.add(new RequiredCapability(IInstallableUnit.NAMESPACE_IU, current.getId(), new VersionRange(current.getVersion(), true, current.getVersion(), true), null, optional, false));
+			result.add(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, current.getId(), new VersionRange(current.getVersion(), true, current.getVersion(), true), null, optional, false));
 		}
 		return (RequiredCapability[]) result.toArray(new RequiredCapability[result.size()]);
 	}
@@ -28,7 +27,7 @@ public class IUTransformationHelper {
 		RequiredCapability[] result = new RequiredCapability[ius.length];
 		for (int i = 0; i < result.length; i++) {
 			IInstallableUnit current = ius[i];
-			result[i] = new RequiredCapability(IInstallableUnit.NAMESPACE_IU, current.getId(), new VersionRange(current.getVersion(), true, current.getVersion(), true), null, optional, false);
+			result[i] = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, current.getId(), new VersionRange(current.getVersion(), true, current.getVersion(), true), null, optional, false);
 		}
 		return result;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
index 24d2056..41b0c36 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/NewDependencyExpander.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -146,7 +146,7 @@ public class NewDependencyExpander {
 			ArrayList result = new ArrayList();
 			ProvidedCapability[] caps = wrapped.getProvidedCapabilities();
 			for (int i = 0; i < caps.length; i++) {
-				result.add(new RequiredCapability(caps[i].getNamespace(), caps[i].getName(), new VersionRange(caps[i].getVersion(), true, caps[i].getVersion(), true), wrapped.getFilter(), optionalReqs, false));
+				result.add(MetadataFactory.createRequiredCapability(caps[i].getNamespace(), caps[i].getName(), new VersionRange(caps[i].getVersion(), true, caps[i].getVersion(), true), wrapped.getFilter(), optionalReqs, false));
 			}
 			result.addAll(Arrays.asList(wrapped.getRequiredCapabilities()));
 			return (RequiredCapability[]) result.toArray(new RequiredCapability[result.size()]);
@@ -316,7 +316,7 @@ public class NewDependencyExpander {
 		String flavor = profile.getValue(Profile.PROP_FLAVOR);
 		if (flavor == null)
 			return new HashSet();
-		IInstallableUnit[][] picked = picker.findInstallableUnit(null, null, new RequiredCapability[] {new RequiredCapability(IInstallableUnit.NAMESPACE_FLAVOR, flavor, VersionRange.emptyRange, null, false, false)}, true /* fragmentsOnly */);
+		IInstallableUnit[][] picked = picker.findInstallableUnit(null, null, new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_FLAVOR, flavor, VersionRange.emptyRange, null, false, false)}, true /* fragmentsOnly */);
 		IInstallableUnit[] ius;
 		if (picked[0].length > 0)
 			ius = picked[0];
@@ -335,7 +335,7 @@ public class NewDependencyExpander {
 		Set picked = new HashSet();
 		for (Iterator iterator = ius.iterator(); iterator.hasNext();) {
 			IInstallableUnit current = (IInstallableUnit) iterator.next();
-			IInstallableUnit[][] candidates = picker.findInstallableUnit(null, null, new RequiredCapability[] {new RequiredCapability("fragment", current.getId(), VersionRange.emptyRange, null, true, false)}, false /* not fragmentsOnly */); //$NON-NLS-1$
+			IInstallableUnit[][] candidates = picker.findInstallableUnit(null, null, new RequiredCapability[] {MetadataFactory.createRequiredCapability("fragment", current.getId(), VersionRange.emptyRange, null, true, false)}, false /* not fragmentsOnly */); //$NON-NLS-1$
 			IInstallableUnit[] matches = candidates[0].length > 0 ? candidates[0] : candidates[1];
 			if (matches.length > 0) { //TODO Here we need to check the filter of the found iu
 				if (matches.length == 1) {
@@ -343,7 +343,7 @@ public class NewDependencyExpander {
 					continue;
 				}
 				//verify that each IU requires the current iu
-				ProvidedCapability capForCurrent = new ProvidedCapability(IInstallableUnit.NAMESPACE_IU, current.getId(), current.getVersion());
+				ProvidedCapability capForCurrent = MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_IU, current.getId(), current.getVersion());
 				Map toAdd = new HashMap();
 				for (int i = 0; i < matches.length; i++) {
 					RequiredCapability[] reqs = matches[i].getRequiredCapabilities();
@@ -481,7 +481,7 @@ public class NewDependencyExpander {
 							VersionRange newRange = intersect(currentMatch.req.getRange(), current.getRange());
 							if (newRange != null) {
 								//merge version range and environment with existing match
-								currentMatch.req = new RequiredCapability(current.getNamespace(), current.getName(), newRange, current.getFilter(), currentMatch.req.isOptional() && current.isOptional(), false);
+								currentMatch.req = MetadataFactory.createRequiredCapability(current.getNamespace(), current.getName(), newRange, current.getFilter(), currentMatch.req.isOptional() && current.isOptional(), false);
 								currentMatch.env = mergeEnvironments(currentMatch.env, current);
 								continue outer;
 							}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Recommendation.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Recommendation.java
index 3298307..4e6172f 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Recommendation.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Recommendation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -8,6 +8,7 @@
  ******************************************************************************/
 package org.eclipse.equinox.internal.p2.director;
 
+import org.eclipse.equinox.p2.metadata.MetadataFactory;
 import org.eclipse.equinox.p2.metadata.RequiredCapability;
 import org.eclipse.osgi.service.resolver.VersionRange;
 import org.osgi.framework.Version;
@@ -49,7 +50,7 @@ public class Recommendation {
 		VersionRange result = intersect(newValue().getRange(), r2.newValue().getRange());
 		if (result == null)
 			return null;
-		return new Recommendation(applyOn, new RequiredCapability(applyOn.getNamespace(), applyOn.getName(), result));
+		return new Recommendation(applyOn, MetadataFactory.createRequiredCapability(applyOn.getNamespace(), applyOn.getName(), result, null, false, false));
 	}
 
 	private VersionRange intersect(VersionRange r1, VersionRange r2) {
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/RecommendationDescriptor.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/RecommendationDescriptor.java
index acbe9ba..dad73be 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/RecommendationDescriptor.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/RecommendationDescriptor.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -10,6 +10,7 @@ package org.eclipse.equinox.internal.p2.director;
 
 import java.util.*;
 import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.p2.metadata.MetadataFactory;
 import org.eclipse.equinox.p2.metadata.RequiredCapability;
 import org.eclipse.osgi.service.resolver.VersionRange;
 
@@ -86,7 +87,7 @@ public class RecommendationDescriptor {
 			String name = oneRec.nextToken().trim();
 			String oldRange = oneRec.nextToken().trim();
 			String newRange = oneRec.nextToken().trim();
-			recommendations.add(new Recommendation(new RequiredCapability(ns, name, new VersionRange(oldRange)), new RequiredCapability(ns, name, new VersionRange(newRange))));
+			recommendations.add(new Recommendation(MetadataFactory.createRequiredCapability(ns, name, new VersionRange(oldRange), null, false, false), MetadataFactory.createRequiredCapability(ns, name, new VersionRange(newRange), null, false, false)));
 		}
 		return new RecommendationDescriptor(recommendations);
 	}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
index 0760bb5..5266669 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/Generator.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -32,6 +32,16 @@ public class Generator {
 
 	//	private static String[][] defaultMappingRules = new String[][] { {"(& (namespace=eclipse) (classifier=feature))", "${repoUrl}/feature/${id}_${version}"}, {"(& (namespace=eclipse) (classifier=plugin))", "${repoUrl}/plugin/${id}_${version}"}, {"(& (namespace=eclipse) (classifier=native))", "${repoUrl}/native/${id}_${version}"}};
 
+	private final IGeneratorInfo info;
+
+	/**
+	 * Short term fix to ensure IUs that have no corresponding category are not lost.
+	 * See https://bugs.eclipse.org/bugs/show_bug.cgi?id=211521.
+	 */
+	protected final Set rootCategory = new HashSet();
+
+	private StateObjectFactory stateObjectFactory;
+
 	/**
 	 * Convert a list of tokens into an array. The list separator has to be
 	 * specified.
@@ -48,16 +58,6 @@ public class Generator {
 		return (String[]) result.toArray(new String[result.size()]);
 	}
 
-	private final IGeneratorInfo info;
-
-	/**
-	 * Short term fix to ensure IUs that have no corresponding category are not lost.
-	 * See https://bugs.eclipse.org/bugs/show_bug.cgi?id=211521.
-	 */
-	protected final Set rootCategory = new HashSet();
-
-	private StateObjectFactory stateObjectFactory;
-
 	public Generator(IGeneratorInfo infoProvider) {
 		this.info = infoProvider;
 		// TODO need to figure a better way of configuring the generator...
@@ -88,7 +88,7 @@ public class Generator {
 			IInstallableUnit iu = (IInstallableUnit) iterator.next();
 			VersionRange range = new VersionRange(iu.getVersion(), true, iu.getVersion(), true);
 			boolean isOptional = checkOptionalRootDependency(iu);
-			reqsConfigurationUnits.add(new RequiredCapability(IInstallableUnit.NAMESPACE_IU, iu.getId(), range, iu.getFilter(), isOptional, false));
+			reqsConfigurationUnits.add(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, iu.getId(), range, iu.getFilter(), isOptional, false));
 		}
 		root.setRequiredCapabilities((RequiredCapability[]) reqsConfigurationUnits.toArray(new RequiredCapability[reqsConfigurationUnits.size()]));
 		root.setApplicabilityFilter(""); //$NON-NLS-1$
@@ -97,7 +97,7 @@ public class Generator {
 		root.setProperty("lineUp", "true"); //$NON-NLS-1$ //$NON-NLS-2$
 		root.setProperty(IInstallableUnit.PROP_UPDATE_FROM, configurationIdentification);
 		root.setProperty(IInstallableUnit.PROP_UPDATE_RANGE, VersionRange.emptyRange.toString());
-		ProvidedCapability groupCapability = new ProvidedCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", new Version("1.0.0"));
+		ProvidedCapability groupCapability = MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", new Version("1.0.0"));
 		root.setCapabilities(new ProvidedCapability[] {MetadataGeneratorHelper.createSelfCapability(configurationIdentification, new Version(configurationVersion)), groupCapability});
 		root.setTouchpointType(MetadataGeneratorHelper.TOUCHPOINT_ECLIPSE);
 		Map touchpointData = new HashMap();
@@ -262,10 +262,10 @@ public class Generator {
 		ArrayList required = new ArrayList(rootCategory.size());
 		for (Iterator iterator = rootCategory.iterator(); iterator.hasNext();) {
 			IInstallableUnit iu = (IInstallableUnit) iterator.next();
-			required.add(new RequiredCapability(IInstallableUnit.NAMESPACE_IU, iu.getId(), VersionRange.emptyRange, iu.getFilter(), false, false));
+			required.add(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, iu.getId(), VersionRange.emptyRange, iu.getFilter(), false, false));
 		}
 		cat.setRequiredCapabilities((RequiredCapability[]) required.toArray(new RequiredCapability[required.size()]));
-		cat.setCapabilities(new ProvidedCapability[] {new ProvidedCapability(IInstallableUnit.NAMESPACE_IU, categoryId, Version.emptyVersion)});
+		cat.setCapabilities(new ProvidedCapability[] {MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_IU, categoryId, Version.emptyVersion)});
 		cat.setApplicabilityFilter(""); //$NON-NLS-1$
 		cat.setArtifacts(new IArtifactKey[0]);
 		cat.setProperty(IInstallableUnit.PROP_CATEGORY_IU, "true"); //$NON-NLS-1$
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
index 935ced9..d5e99a0 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/p2/metadata/generator/MetadataGeneratorHelper.java
@@ -57,8 +57,8 @@ public class MetadataGeneratorHelper {
 	public static final TouchpointType TOUCHPOINT_NATIVE = MetadataFactory.createTouchpointType("native", new Version(1, 0, 0)); //$NON-NLS-1$
 	public static final TouchpointType TOUCHPOINT_ECLIPSE = MetadataFactory.createTouchpointType("eclipse", new Version(1, 0, 0)); //$NON-NLS-1$
 
-	public static final ProvidedCapability BUNDLE_CAPABILITY = new ProvidedCapability(IInstallableUnit.CAPABILITY_ECLIPSE_TYPES, IInstallableUnit.CAPABILITY_ECLIPSE_BUNDLE, new Version(1, 0, 0));
-	public static final ProvidedCapability FEATURE_CAPABILITY = new ProvidedCapability(IInstallableUnit.CAPABILITY_ECLIPSE_TYPES, IInstallableUnit.CAPABILITY_ECLIPSE_FEATURE, new Version(1, 0, 0));
+	public static final ProvidedCapability BUNDLE_CAPABILITY = MetadataFactory.createProvidedCapability(IInstallableUnit.CAPABILITY_ECLIPSE_TYPES, IInstallableUnit.CAPABILITY_ECLIPSE_BUNDLE, new Version(1, 0, 0));
+	public static final ProvidedCapability FEATURE_CAPABILITY = MetadataFactory.createProvidedCapability(IInstallableUnit.CAPABILITY_ECLIPSE_TYPES, IInstallableUnit.CAPABILITY_ECLIPSE_FEATURE, new Version(1, 0, 0));
 	public static final ProvidedCapability FRAGMENT_CAPABILITY = IInstallableUnitFragment.FRAGMENT_CAPABILITY;
 
 	public static IArtifactDescriptor createArtifactDescriptor(IArtifactKey key, File pathOnDisk, boolean asIs, boolean recur) {
@@ -89,7 +89,7 @@ public class MetadataGeneratorHelper {
 		cu.setHost(iuId, new VersionRange(iuVersion, true, versionMax, true));
 
 		//Adds capabilities for fragment, self, and describing the flavor supported
-		cu.setCapabilities(new ProvidedCapability[] {FRAGMENT_CAPABILITY, createSelfCapability(configUnitId, iuVersion), new ProvidedCapability(IInstallableUnit.NAMESPACE_FLAVOR, configurationFlavor, Version.emptyVersion)});
+		cu.setCapabilities(new ProvidedCapability[] {FRAGMENT_CAPABILITY, createSelfCapability(configUnitId, iuVersion), MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_FLAVOR, configurationFlavor, Version.emptyVersion)});
 
 		Map touchpointData = new HashMap();
 		touchpointData.put("install", "installBundle(bundle:${artifact})");
@@ -117,11 +117,11 @@ public class MetadataGeneratorHelper {
 		BundleSpecification requiredBundles[] = bd.getRequiredBundles();
 		ArrayList reqsDeps = new ArrayList();
 		if (requiresAFragment)
-			reqsDeps.add(new RequiredCapability(CAPABILITY_TYPE_OSGI_FRAGMENTS, bd.getSymbolicName(), VersionRange.emptyRange, null, false, false));
+			reqsDeps.add(MetadataFactory.createRequiredCapability(CAPABILITY_TYPE_OSGI_FRAGMENTS, bd.getSymbolicName(), VersionRange.emptyRange, null, false, false));
 		if (isFragment)
-			reqsDeps.add(new RequiredCapability(CAPABILITY_TYPE_OSGI_BUNDLES, bd.getHost().getName(), bd.getHost().getVersionRange(), null, false, false));
+			reqsDeps.add(MetadataFactory.createRequiredCapability(CAPABILITY_TYPE_OSGI_BUNDLES, bd.getHost().getName(), bd.getHost().getVersionRange(), null, false, false));
 		for (int j = 0; j < requiredBundles.length; j++)
-			reqsDeps.add(new RequiredCapability(CAPABILITY_TYPE_OSGI_BUNDLES, requiredBundles[j].getName(), requiredBundles[j].getVersionRange() == VersionRange.emptyRange ? null : requiredBundles[j].getVersionRange(), null, requiredBundles[j].isOptional(), false));
+			reqsDeps.add(MetadataFactory.createRequiredCapability(CAPABILITY_TYPE_OSGI_BUNDLES, requiredBundles[j].getName(), requiredBundles[j].getVersionRange() == VersionRange.emptyRange ? null : requiredBundles[j].getVersionRange(), null, requiredBundles[j].isOptional(), false));
 
 		//Process the import package
 		ImportPackageSpecification osgiImports[] = bd.getImportPackages();
@@ -135,7 +135,7 @@ public class MetadataGeneratorHelper {
 			VersionRange versionRange = importSpec.getVersionRange() == VersionRange.emptyRange ? null : importSpec.getVersionRange();
 
 			//TODO this needs to be refined to take into account all the attribute handled by imports
-			reqsDeps.add(new RequiredCapability(CAPABILITY_TYPE_OSGI_PACKAGES, importPackageName, versionRange, null, isOptional(importSpec), false));
+			reqsDeps.add(MetadataFactory.createRequiredCapability(CAPABILITY_TYPE_OSGI_PACKAGES, importPackageName, versionRange, null, isOptional(importSpec), false));
 		}
 		iu.setRequiredCapabilities((RequiredCapability[]) reqsDeps.toArray(new RequiredCapability[reqsDeps.size()]));
 
@@ -143,18 +143,18 @@ public class MetadataGeneratorHelper {
 		ArrayList providedCapabilities = new ArrayList();
 
 		providedCapabilities.add(createSelfCapability(bd.getSymbolicName(), bd.getVersion()));
-		providedCapabilities.add(new ProvidedCapability(CAPABILITY_TYPE_OSGI_BUNDLES, bd.getSymbolicName(), bd.getVersion()));
+		providedCapabilities.add(MetadataFactory.createProvidedCapability(CAPABILITY_TYPE_OSGI_BUNDLES, bd.getSymbolicName(), bd.getVersion()));
 
 		//Process the export package
 		ExportPackageDescription exports[] = bd.getExportPackages();
 		for (int i = 0; i < exports.length; i++) {
 			//TODO make sure that we support all the refinement on the exports
-			providedCapabilities.add(new ProvidedCapability(CAPABILITY_TYPE_OSGI_PACKAGES, exports[i].getName(), exports[i].getVersion() == Version.emptyVersion ? null : exports[i].getVersion()));
+			providedCapabilities.add(MetadataFactory.createProvidedCapability(CAPABILITY_TYPE_OSGI_PACKAGES, exports[i].getName(), exports[i].getVersion() == Version.emptyVersion ? null : exports[i].getVersion()));
 		}
 		// Here we add a bundle capability to identify bundles
 		providedCapabilities.add(BUNDLE_CAPABILITY);
 		if (isFragment)
-			providedCapabilities.add(new ProvidedCapability(CAPABILITY_TYPE_OSGI_FRAGMENTS, bd.getHost().getName(), bd.getVersion()));
+			providedCapabilities.add(MetadataFactory.createProvidedCapability(CAPABILITY_TYPE_OSGI_FRAGMENTS, bd.getHost().getName(), bd.getVersion()));
 		iu.setCapabilities((ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]));
 		iu.setApplicabilityFilter("");
 
@@ -208,14 +208,14 @@ public class MetadataGeneratorHelper {
 		for (Iterator iterator = featureIUs.iterator(); iterator.hasNext();) {
 			IInstallableUnit iu = (IInstallableUnit) iterator.next();
 			VersionRange range = new VersionRange(iu.getVersion(), true, iu.getVersion(), true);
-			reqsConfigurationUnits.add(new RequiredCapability(IInstallableUnit.NAMESPACE_IU, iu.getId(), range, iu.getFilter(), false, false));
+			reqsConfigurationUnits.add(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, iu.getId(), range, iu.getFilter(), false, false));
 		}
 		//note that update sites don't currently support nested categories, but it may be useful to add in the future
 		if (parentCategory != null) {
-			reqsConfigurationUnits.add(new RequiredCapability(IInstallableUnit.NAMESPACE_IU, parentCategory.getId(), VersionRange.emptyRange, parentCategory.getFilter(), false, false));
+			reqsConfigurationUnits.add(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, parentCategory.getId(), VersionRange.emptyRange, parentCategory.getFilter(), false, false));
 		}
 		cat.setRequiredCapabilities((RequiredCapability[]) reqsConfigurationUnits.toArray(new RequiredCapability[reqsConfigurationUnits.size()]));
-		cat.setCapabilities(new ProvidedCapability[] {new ProvidedCapability(IInstallableUnit.NAMESPACE_IU, category.getName(), Version.emptyVersion)});
+		cat.setCapabilities(new ProvidedCapability[] {MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_IU, category.getName(), Version.emptyVersion)});
 		cat.setApplicabilityFilter(""); //$NON-NLS-1$
 		cat.setArtifacts(new IArtifactKey[0]);
 		cat.setProperty(IInstallableUnit.PROP_CATEGORY_IU, "true"); //$NON-NLS-1$
@@ -253,10 +253,10 @@ public class MetadataGeneratorHelper {
 		cu.setVersion(configUnitVersion);
 
 		// Add capabilities for fragment, self, and describing the flavor supported
-		cu.setCapabilities(new ProvidedCapability[] {FRAGMENT_CAPABILITY, createSelfCapability(configUnitId, configUnitVersion), new ProvidedCapability(IInstallableUnit.NAMESPACE_FLAVOR, configurationFlavor, Version.emptyVersion)});
+		cu.setCapabilities(new ProvidedCapability[] {FRAGMENT_CAPABILITY, createSelfCapability(configUnitId, configUnitVersion), MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_FLAVOR, configurationFlavor, Version.emptyVersion)});
 
 		// Create a required capability on bundles
-		RequiredCapability[] reqs = new RequiredCapability[] {new RequiredCapability(IInstallableUnit.CAPABILITY_ECLIPSE_TYPES, IInstallableUnit.CAPABILITY_ECLIPSE_BUNDLE, VersionRange.emptyRange, null, false, true)};
+		RequiredCapability[] reqs = new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.CAPABILITY_ECLIPSE_TYPES, IInstallableUnit.CAPABILITY_ECLIPSE_BUNDLE, VersionRange.emptyRange, null, false, true)};
 		cu.setRequiredCapabilities(reqs);
 		Map touchpointData = new HashMap();
 
@@ -285,10 +285,10 @@ public class MetadataGeneratorHelper {
 		cu.setVersion(configUnitVersion);
 
 		// Add capabilities for fragment, self, and describing the flavor supported
-		cu.setCapabilities(new ProvidedCapability[] {FRAGMENT_CAPABILITY, createSelfCapability(configUnitId, configUnitVersion), new ProvidedCapability(IInstallableUnit.NAMESPACE_FLAVOR, configurationFlavor, Version.emptyVersion)});
+		cu.setCapabilities(new ProvidedCapability[] {FRAGMENT_CAPABILITY, createSelfCapability(configUnitId, configUnitVersion), MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_FLAVOR, configurationFlavor, Version.emptyVersion)});
 
 		// Create a required capability on features
-		RequiredCapability[] reqs = new RequiredCapability[] {new RequiredCapability(IInstallableUnit.CAPABILITY_ECLIPSE_TYPES, IInstallableUnit.CAPABILITY_ECLIPSE_FEATURE, VersionRange.emptyRange, null, false, true)};
+		RequiredCapability[] reqs = new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.CAPABILITY_ECLIPSE_TYPES, IInstallableUnit.CAPABILITY_ECLIPSE_FEATURE, VersionRange.emptyRange, null, false, true)};
 		cu.setRequiredCapabilities(reqs);
 
 		Map touchpointData = new HashMap();
@@ -357,15 +357,15 @@ public class MetadataGeneratorHelper {
 		RequiredCapability[] required = new RequiredCapability[entries.length + 1];
 		for (int i = 0; i < entries.length; i++) {
 			VersionRange range = getVersionRange(entries[i]);
-			required[i] = new RequiredCapability(IU_NAMESPACE, getTransformedId(entries[i].getId(), entries[i].isPlugin(), /*isGroup*/true), range, getFilter(entries[i]), entries[i].isOptional(), false);
+			required[i] = MetadataFactory.createRequiredCapability(IU_NAMESPACE, getTransformedId(entries[i].getId(), entries[i].isPlugin(), /*isGroup*/true), range, getFilter(entries[i]), entries[i].isOptional(), false);
 		}
-		required[entries.length] = new RequiredCapability(IU_NAMESPACE, featureIU.getId(), new VersionRange(featureIU.getVersion(), true, featureIU.getVersion(), true), INSTALL_FEATURES_FILTER, false, false);
+		required[entries.length] = MetadataFactory.createRequiredCapability(IU_NAMESPACE, featureIU.getId(), new VersionRange(featureIU.getVersion(), true, featureIU.getVersion(), true), INSTALL_FEATURES_FILTER, false, false);
 		iu.setRequiredCapabilities(required);
 		iu.setTouchpointType(TouchpointType.NONE);
 		// TODO: shouldn't the filter for the group be constructed from os, ws, arch, nl
 		// 		 of the feature?
 		// iu.setFilter(filter);
-		ProvidedCapability groupCapability = new ProvidedCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", new Version("1.0.0"));
+		ProvidedCapability groupCapability = MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", new Version("1.0.0"));
 		iu.setCapabilities(new ProvidedCapability[] {createSelfCapability(id, version), groupCapability});
 		return MetadataFactory.createInstallableUnit(iu);
 	}
@@ -473,7 +473,7 @@ public class MetadataGeneratorHelper {
 	}
 
 	public static ProvidedCapability createSelfCapability(String installableUnitId, Version installableUnitVersion) {
-		return new ProvidedCapability(IU_NAMESPACE, installableUnitId, installableUnitVersion);
+		return MetadataFactory.createProvidedCapability(IU_NAMESPACE, installableUnitId, installableUnitVersion);
 	}
 
 	private static String createUnconfigScript(GeneratorBundleInfo unconfigInfo, boolean isBundleFragment) {
@@ -510,7 +510,7 @@ public class MetadataGeneratorHelper {
 			ProvidedCapability[] exportedPackageAsCapabilities = new ProvidedCapability[jrePackages.length + 1];
 			exportedPackageAsCapabilities[0] = createSelfCapability(installableUnitId, installableUnitVersion);
 			for (int i = 1; i <= jrePackages.length; i++) {
-				exportedPackageAsCapabilities[i] = new ProvidedCapability("osgi.packages", jrePackages[i - 1].getValue(), null);
+				exportedPackageAsCapabilities[i] = MetadataFactory.createProvidedCapability("osgi.packages", jrePackages[i - 1].getValue(), null);
 			}
 			return exportedPackageAsCapabilities;
 		} catch (IOException e) {
diff --git a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
index 3ce5831..079ff62 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.repository/src/org/eclipse/equinox/internal/p2/metadata/repository/io/MetadataParser.java
@@ -235,7 +235,7 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 			super(parentHandler, PROVIDED_CAPABILITY_ELEMENT);
 			String[] values = parseRequiredAttributes(attributes, required);
 			Version version = checkVersion(PROVIDED_CAPABILITY_ELEMENT, VERSION_ATTRIBUTE, values[2]);
-			capabilities.add(new ProvidedCapability(values[0], values[1], version));
+			capabilities.add(MetadataFactory.createProvidedCapability(values[0], values[1], version));
 		}
 
 		public void startElement(String name, Attributes attributes) {
@@ -282,7 +282,7 @@ public abstract class MetadataParser extends XMLParser implements XMLConstants {
 			VersionRange range = checkVersionRange(REQUIRED_CAPABILITY_ELEMENT, VERSION_RANGE_ATTRIBUTE, values[2]);
 			boolean isOptional = checkBoolean(REQUIRED_CAPABILITY_ELEMENT, CAPABILITY_OPTIONAL_ATTRIBUTE, values[3], false).booleanValue();
 			boolean isMultiple = checkBoolean(REQUIRED_CAPABILITY_ELEMENT, CAPABILITY_MULTIPLE_ATTRIBUTE, values[4], false).booleanValue();
-			currentCapability = new RequiredCapability(values[0], values[1], range, null, isOptional, isMultiple);
+			currentCapability = MetadataFactory.createRequiredCapability(values[0], values[1], range, null, isOptional, isMultiple);
 			capabilities.add(currentCapability);
 		}
 
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/InstallableUnitFragment.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/InstallableUnitFragment.java
index 83c6470..bbf330d 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/InstallableUnitFragment.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/internal/p2/metadata/InstallableUnitFragment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -29,7 +29,7 @@ public class InstallableUnitFragment extends InstallableUnit implements IInstall
 		hostId = iuId;
 		hostRange = versionRange;
 		if (hostId != null)
-			addRequiredCapability(RequiredCapability.createRequiredCapabilityForName(iuId, versionRange, false));
+			addRequiredCapability(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, iuId, versionRange, null, false, false));
 	}
 
 	public String getHostId() {
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IInstallableUnitFragment.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IInstallableUnitFragment.java
index 7e065bc..b9868e1 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IInstallableUnitFragment.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/IInstallableUnitFragment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -13,7 +13,7 @@ import org.osgi.framework.Version;
 
 public interface IInstallableUnitFragment extends IInstallableUnit {
 
-	public static final ProvidedCapability FRAGMENT_CAPABILITY = new ProvidedCapability(NAMESPACE_IU_KIND, "iu.fragment", new Version(1, 0, 0)); //$NON-NLS-1$
+	public static final ProvidedCapability FRAGMENT_CAPABILITY = MetadataFactory.createProvidedCapability(NAMESPACE_IU_KIND, "iu.fragment", new Version(1, 0, 0)); //$NON-NLS-1$
 
 	public abstract String getHostId();
 
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
index 7218b1d..cd0c5d8 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/MetadataFactory.java
@@ -107,7 +107,7 @@ public class MetadataFactory {
 	private static int typeCacheOffset;
 
 	/**
-	 * Creates and returns an {@link IInstallableUnit} based on the given 
+	 * Returns an {@link IInstallableUnit} based on the given 
 	 * description.  Once the installable unit has been created, the information is 
 	 * discarded from the description object.
 	 * 
@@ -120,7 +120,7 @@ public class MetadataFactory {
 	}
 
 	/**
-	 * Creates and returns an {@link IInstallableUnitFragment} based on the given 
+	 * Returns an {@link IInstallableUnitFragment} based on the given 
 	 * description.  Once the fragment has been created, the information is 
 	 * discarded from the description object.
 	 * 
@@ -133,7 +133,35 @@ public class MetadataFactory {
 	}
 
 	/**
-	 * Creates and returns an {@link IInstallableUnit} that represents the given
+	 * Returns a {@link ProvidedCapability} with the given values.
+	 * 
+	 * @param namespace The capability namespace
+	 * @param name The capability name
+	 * @param version The capability version
+	 */
+	public static ProvidedCapability createProvidedCapability(String namespace, String name, Version version) {
+		return new ProvidedCapability(namespace, name, version);
+	}
+
+	/**
+	 * Returns a {@link RequiredCapability} with the given values.
+	 * 
+	 * @param namespace The capability namespace
+	 * @param name The required capability name
+	 * @param range The range of versions that are required, or <code>null</code>
+	 * to indicate that any version will do.
+	 * @param filter The filter used to evaluate whether this capability is applicable in the
+	 * current environment, or <code>null</code> to indicate this capability is always applicable
+	 * @param optional <code>true</code> if this required capability is optional,
+	 * and <code>false</code> otherwise.
+	 * @param multiple <code>true</code> if this capability can be satisfied by multiple provided capabilities, or it requires exactly one match
+	 */
+	public static RequiredCapability createRequiredCapability(String namespace, String name, VersionRange range, String filter, boolean optional, boolean multiple) {
+		return new RequiredCapability(namespace, name, range, filter, optional, multiple);
+	}
+
+	/**
+	 * Returns an {@link IInstallableUnit} that represents the given
 	 * unit bound to the given fragments.
 	 * 
 	 * @see IInstallableUnit#isResolved()
@@ -151,7 +179,7 @@ public class MetadataFactory {
 	}
 
 	/**
-	 * Creates an instance of {@link TouchpointData} with the given instructions.
+	 * Returns an instance of {@link TouchpointData} with the given instructions.
 	 * 
 	 * @param instructions The instructions for the touchpoint data.
 	 * @return The created touchpoint data
@@ -163,7 +191,7 @@ public class MetadataFactory {
 	}
 
 	/**
-	 * Creates a touchpoint type with the given id and version.
+	 * Returns a {@link TouchpointType} with the given id and version.
 	 * 
 	 * @param id The touchpoint id
 	 * @param version The touchpoint version
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/ProvidedCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/ProvidedCapability.java
index bdfa815..989b64f 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/ProvidedCapability.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/ProvidedCapability.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -21,7 +21,7 @@ public class ProvidedCapability {
 	private final String namespace;
 	private final Version version;
 
-	public ProvidedCapability(String namespace, String name, Version version) {
+	ProvidedCapability(String namespace, String name, Version version) {
 		Assert.isNotNull(namespace);
 		Assert.isNotNull(name);
 		this.namespace = namespace;
diff --git a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/RequiredCapability.java b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/RequiredCapability.java
index 9746529..f1b366b 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/RequiredCapability.java
+++ b/bundles/org.eclipse.equinox.p2.metadata/src/org/eclipse/equinox/p2/metadata/RequiredCapability.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -26,6 +26,7 @@ import org.eclipse.osgi.service.resolver.VersionRange;
  * @see IInstallableUnit#NAMESPACE_IU
  */
 public class RequiredCapability {
+	private static final String[] NO_SELECTORS = new String[0];
 
 	private String filter;
 	private final boolean multiple;
@@ -33,37 +34,14 @@ public class RequiredCapability {
 	private final String namespace;//never null
 	private boolean optional;
 	private final VersionRange range;//never null
-	private String[] selectors;
+	private String[] selectors = NO_SELECTORS;//never null
 
-	/**
-	 * Returns a {@link RequiredCapability} on the installable unit with the given name
-	 * and version range.
-	 * 
-	 * @param name The name of the {@link IInstallableUnit} that is required.
-	 * @param versionRange The range of versions that are required, or <code>null</code>
-	 * to indicate that any version will do.
-	 * @param optional <code>true</code> if this required capability is optional,
-	 * and <code>false</code> otherwise.
-	 */
-	public static RequiredCapability createRequiredCapabilityForName(String name, VersionRange versionRange, boolean optional) {
-		return new RequiredCapability(IInstallableUnit.NAMESPACE_IU, name, versionRange, null, optional, false);
-	}
-
-	public RequiredCapability(String namespace, String name, VersionRange range) {
-		this(namespace, name, range, null, false, false);
-	}
-
-	public RequiredCapability(String namespace, String name, VersionRange range, String filter, boolean optional, boolean multiple) {
-		this(namespace, name, range, null, filter, optional, multiple);
-	}
-
-	public RequiredCapability(String namespace, String name, VersionRange range, String[] selectors, String filter, boolean optional, boolean multiple) {
+	RequiredCapability(String namespace, String name, VersionRange range, String filter, boolean optional, boolean multiple) {
 		Assert.isNotNull(namespace);
 		Assert.isNotNull(name);
 		this.namespace = namespace;
 		this.name = name;
 		this.range = range == null ? VersionRange.emptyRange : range;
-		this.selectors = selectors == null ? new String[0] : selectors;
 		this.optional = optional;
 		this.filter = filter;
 		this.multiple = multiple;
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
index 8fdf299..6bfb32c 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/AbstractProvisioningTest.java
@@ -33,9 +33,9 @@ import org.osgi.framework.Version;
 public class AbstractProvisioningTest extends TestCase {
 
 	protected static final VersionRange ANY_VERSION = new VersionRange(Version.emptyVersion, true, new Version(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE), true);
-	private static final ProvidedCapability[] BUNDLE_CAPABILITY = new ProvidedCapability[] {new ProvidedCapability("eclipse.touchpoint", "bundle", new Version(1, 0, 0))};
+	private static final ProvidedCapability[] BUNDLE_CAPABILITY = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("eclipse.touchpoint", "bundle", new Version(1, 0, 0))};
 
-	private static final RequiredCapability[] BUNDLE_REQUIREMENT = new RequiredCapability[] {new RequiredCapability("eclipse.touchpoint", "bundle", VersionRange.emptyRange, null, false, true)};
+	private static final RequiredCapability[] BUNDLE_REQUIREMENT = new RequiredCapability[] {MetadataFactory.createRequiredCapability("eclipse.touchpoint", "bundle", VersionRange.emptyRange, null, false, true)};
 
 	protected static final Version DEFAULT_VERSION = new Version(1, 0, 0);
 	protected static final TouchpointType ECLIPSE_TOUCHPOINT = MetadataFactory.createTouchpointType("eclipse", new Version(1, 0, 0));
@@ -411,7 +411,7 @@ public class AbstractProvisioningTest extends TestCase {
 	 * Creates and returns a required capability with the provided attributes.
 	 */
 	protected static RequiredCapability[] createRequiredCapabilities(String namespace, String name, VersionRange range, String filter) {
-		return new RequiredCapability[] {new RequiredCapability(namespace, name, range, filter, false, false)};
+		return new RequiredCapability[] {MetadataFactory.createRequiredCapability(namespace, name, range, filter, false, false)};
 	}
 
 	public static boolean delete(File file) {
@@ -472,7 +472,7 @@ public class AbstractProvisioningTest extends TestCase {
 	 * 	Get the 'self' capability for an installable unit with the give id and version.
 	 */
 	private static ProvidedCapability getSelfCapability(String installableUnitId, Version installableUnitVersion) {
-		return new ProvidedCapability(IInstallableUnit.NAMESPACE_IU, installableUnitId, installableUnitVersion);
+		return MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_IU, installableUnitId, installableUnitVersion);
 	}
 
 	private static void indent(OutputStream output, int indent) {
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/AutomatedDirectorTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/AutomatedDirectorTest.java
index 22b6fd1..cf50c13 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/AutomatedDirectorTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/AutomatedDirectorTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -47,7 +47,7 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 
 		// The IU to be installed
 		String filter = createFilter("FilterKey", "true");
-		RequiredCapability capability = new RequiredCapability(IInstallableUnit.NAMESPACE_IU, requiredIU.getId(), ANY_VERSION, filter, false, false);
+		RequiredCapability capability = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, requiredIU.getId(), ANY_VERSION, filter, false, false);
 		IInstallableUnit toInstallIU = createIU("toInstall." + getName(), new RequiredCapability[] {capability});
 
 		IInstallableUnit[] allUnits = new IInstallableUnit[] {requiredIU, toInstallIU};
@@ -69,10 +69,10 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	public void testInstallOptionalAvailable() {
 		String capabilityId = "test." + getName();
 		//The IU that exports the capability
-		IInstallableUnit requiredIU = createIU("required." + getName(), new ProvidedCapability[] {new ProvidedCapability("test.capability", capabilityId, DEFAULT_VERSION)});
+		IInstallableUnit requiredIU = createIU("required." + getName(), new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", capabilityId, DEFAULT_VERSION)});
 
 		//The IU that optionally requires the capability
-		RequiredCapability required = new RequiredCapability("test.capability", capabilityId, ANY_VERSION, null, /* optional=> */true, /* multiple=> */false);
+		RequiredCapability required = MetadataFactory.createRequiredCapability("test.capability", capabilityId, ANY_VERSION, null, /* optional=> */true, /* multiple=> */false);
 		IInstallableUnit toInstallIU = createIU("toInstall." + getName(), new RequiredCapability[] {required});
 
 		IInstallableUnit[] allUnits = new IInstallableUnit[] {toInstallIU, requiredIU};
@@ -94,7 +94,7 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	public void testInstallOptionalUnavailable() {
 		String capabilityId = "test." + getName();
 		//no IU will be available that exports this capability
-		RequiredCapability required = new RequiredCapability("test.capability", capabilityId, ANY_VERSION, null, true, false);
+		RequiredCapability required = MetadataFactory.createRequiredCapability("test.capability", capabilityId, ANY_VERSION, null, true, false);
 		IInstallableUnit toInstallIU = createIU("toInstall." + getName(), new RequiredCapability[] {required});
 
 		IInstallableUnit[] allUnits = new IInstallableUnit[] {toInstallIU};
@@ -116,7 +116,7 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	public void testInstallPlatformFilter() {
 		//The IU that exports the capability
 		String capabilityId = "test." + getName();
-		ProvidedCapability[] provides = new ProvidedCapability[] {new ProvidedCapability("test.capability", capabilityId, DEFAULT_VERSION)};
+		ProvidedCapability[] provides = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", capabilityId, DEFAULT_VERSION)};
 		IInstallableUnit requiredIU = createIU("required." + getName(), createFilter("osgi.os", "blort"), provides);
 
 		IInstallableUnit toInstallIU = createIU("toInstall." + getName(), createRequiredCapabilities("test.capability", capabilityId, ANY_VERSION, null));
@@ -143,7 +143,7 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 	public void testSimpleInstallRequired() {
 		String capabilityId = "test." + getName();
 		//The IU that exports the capability
-		IInstallableUnit requiredIU = createIU("required." + getName(), new ProvidedCapability[] {new ProvidedCapability("test.capability", capabilityId, DEFAULT_VERSION)});
+		IInstallableUnit requiredIU = createIU("required." + getName(), new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", capabilityId, DEFAULT_VERSION)});
 
 		IInstallableUnit toInstallIU = createIU("toInstall." + getName(), createRequiredCapabilities("test.capability", capabilityId, ANY_VERSION, null));
 
@@ -169,7 +169,7 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 		//The IU that is needed
 		IInstallableUnit requiredIU = createIU("required." + getName());
 
-		RequiredCapability capability = new RequiredCapability(IInstallableUnit.NAMESPACE_IU, requiredIU.getId(), null, null, false, false);
+		RequiredCapability capability = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, requiredIU.getId(), null, null, false, false);
 		IInstallableUnit toInstallIU = createIU("toInstall." + getName(), new RequiredCapability[] {capability});
 
 		IInstallableUnit[] allUnits = new IInstallableUnit[] {requiredIU, toInstallIU};
@@ -195,7 +195,7 @@ public class AutomatedDirectorTest extends AbstractProvisioningTest {
 		//The IU that exports the capability
 		IInstallableUnit requiredIU = createIU("required." + getName());
 
-		RequiredCapability capability = new RequiredCapability(IInstallableUnit.NAMESPACE_IU, requiredIU.getId(), ANY_VERSION, null, false, false);
+		RequiredCapability capability = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, requiredIU.getId(), ANY_VERSION, null, false, false);
 		IInstallableUnit toInstallIU = createIU("toInstall." + getName(), new RequiredCapability[] {capability});
 
 		IInstallableUnit[] allUnits = new IInstallableUnit[] {requiredIU, toInstallIU};
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/PickerTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/PickerTest.java
index b41a006..c51c14b 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/PickerTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/PickerTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -36,7 +36,7 @@ public class PickerTest extends AbstractProvisioningTest {
 		Version version = new Version(5, 0, 0);
 
 		//create some sample IUs to be available for the picker
-		ProvidedCapability[] provides = new ProvidedCapability[] {new ProvidedCapability("test.capability", "test", version)};
+		ProvidedCapability[] provides = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", "test", version)};
 		unitVersion5 = createIU("required", version, provides);
 
 		IInstallableUnit[] units = new IInstallableUnit[] {unitVersion5};
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/RecommendationTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/RecommendationTest.java
index 9cd6372..4db0bd7 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/RecommendationTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/RecommendationTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -26,17 +26,17 @@ public class RecommendationTest extends AbstractProvisioningTest {
 	//check that the picker is returning something in the range
 	public void testRecommendation() {
 		RequiredCapability applyOn, newValue;
-		applyOn = new RequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
-		newValue = new RequiredCapability("namespace", "name", new VersionRange("[1.1, 2.0)"), null, false, false);
+		applyOn = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
+		newValue = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.1, 2.0)"), null, false, false);
 		Recommendation r1 = new Recommendation(applyOn, newValue);
 
-		RequiredCapability goodMatch = new RequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
+		RequiredCapability goodMatch = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
 		assertEquals(true, r1.matches(goodMatch));
 
-		RequiredCapability badNamespace = new RequiredCapability("badNamespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
+		RequiredCapability badNamespace = MetadataFactory.createRequiredCapability("badNamespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
 		assertEquals(false, r1.matches(badNamespace));
 
-		RequiredCapability badName = new RequiredCapability("namespace", "badName", new VersionRange("[1.0, 2.0)"), null, false, false);
+		RequiredCapability badName = MetadataFactory.createRequiredCapability("namespace", "badName", new VersionRange("[1.0, 2.0)"), null, false, false);
 		assertEquals(false, r1.matches(badName));
 	}
 
@@ -47,28 +47,28 @@ public class RecommendationTest extends AbstractProvisioningTest {
 
 		//The recommendations to be used
 		RequiredCapability applyOn, newValue;
-		applyOn = new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[1.0, 2.0)"), null, false, false);
-		newValue = new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[1.1, 2.0)"), null, false, false);
+		applyOn = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[1.0, 2.0)"), null, false, false);
+		newValue = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[1.1, 2.0)"), null, false, false);
 		Recommendation r1 = new Recommendation(applyOn, newValue);
 
 		RequiredCapability applyOn2, newValue2;
-		applyOn2 = new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu2", new VersionRange("[4.2, 5.0)"), null, false, false);
-		newValue2 = new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu2", new VersionRange("[4.0, 5.0)"), null, false, false);
+		applyOn2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu2", new VersionRange("[4.2, 5.0)"), null, false, false);
+		newValue2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu2", new VersionRange("[4.0, 5.0)"), null, false, false);
 		Recommendation r2 = new Recommendation(applyOn2, newValue2);
 		Set recommendations = new HashSet();
 		recommendations.add(r1);
 		recommendations.add(r2);
 
 		Picker p = new Picker(new IInstallableUnit[] {iu1, iu2}, null);
-		IInstallableUnit[][] matches = p.findInstallableUnit(null, null, new RequiredCapability[] {new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", null, null, false, false)}, false);
+		IInstallableUnit[][] matches = p.findInstallableUnit(null, null, new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", null, null, false, false)}, false);
 		assertEquals(matches[1][0], iu1);
 
 		Picker p1 = new Picker(new IInstallableUnit[] {iu1, iu2}, new RecommendationDescriptor(recommendations));
-		matches = p1.findInstallableUnit(null, null, new RequiredCapability[] {new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[1.0, 2.0)"), null, false, false)}, false);
+		matches = p1.findInstallableUnit(null, null, new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[1.0, 2.0)"), null, false, false)}, false);
 		assertEquals(matches[0].length, 0);
 		assertEquals(matches[1].length, 0);
 
-		matches = p1.findInstallableUnit(null, null, new RequiredCapability[] {new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[4.2, 5.0)"), null, false, false)}, false);
+		matches = p1.findInstallableUnit(null, null, new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[4.2, 5.0)"), null, false, false)}, false);
 		assertEquals(matches[0].length, 0);
 		assertEquals(matches[1].length, 0);
 	}
@@ -79,36 +79,36 @@ public class RecommendationTest extends AbstractProvisioningTest {
 
 		//Here we add recommendation that widen the range of the bundle we are looking for
 		RequiredCapability applyOn2, newValue2;
-		applyOn2 = new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[4.2, 5.0)"), null, false, false);
-		newValue2 = new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[4.0, 5.0)"), null, false, false);
+		applyOn2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[4.2, 5.0)"), null, false, false);
+		newValue2 = MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[4.0, 5.0)"), null, false, false);
 		Recommendation r2 = new Recommendation(applyOn2, newValue2);
 		Set recommendations = new HashSet();
 		recommendations.add(r2);
 
 		//Check without the recommendations
 		Picker p2 = new Picker(new IInstallableUnit[] {iu1}, null);
-		IInstallableUnit[][] matches = p2.findInstallableUnit(null, null, new RequiredCapability[] {new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[4.0, 5.0)"), null, false, false)}, false);
+		IInstallableUnit[][] matches = p2.findInstallableUnit(null, null, new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[4.0, 5.0)"), null, false, false)}, false);
 		assertEquals(matches[1].length, 1);
 
 		//Check the widening works
 		Picker p1 = new Picker(new IInstallableUnit[] {iu1}, new RecommendationDescriptor(recommendations));
-		matches = p1.findInstallableUnit(null, null, new RequiredCapability[] {new RequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[4.2, 5.0)"), null, false, false)}, false);
+		matches = p1.findInstallableUnit(null, null, new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, "iu1", new VersionRange("[4.2, 5.0)"), null, false, false)}, false);
 		assertEquals(matches[1].length, 1);
 
 	}
 
 	public void testRecommendationDescriptorMerge() {
 		RequiredCapability applyOn1, newValue1;
-		applyOn1 = new RequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
-		newValue1 = new RequiredCapability("namespace", "name", new VersionRange("[1.1, 2.0)"), null, false, false);
+		applyOn1 = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
+		newValue1 = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.1, 2.0)"), null, false, false);
 		Recommendation r1 = new Recommendation(applyOn1, newValue1);
 		Set list1 = new HashSet();
 		list1.add(r1);
 		RecommendationDescriptor desc1 = new RecommendationDescriptor(list1);
 
 		RequiredCapability applyOn2, newValue2;
-		applyOn2 = new RequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
-		newValue2 = new RequiredCapability("namespace", "name", new VersionRange("[1.3, 2.0)"), null, false, false);
+		applyOn2 = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
+		newValue2 = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.3, 2.0)"), null, false, false);
 		Recommendation r2 = new Recommendation(applyOn2, newValue2);
 		Set list2 = new HashSet();
 		list2.add(r2);
@@ -116,21 +116,21 @@ public class RecommendationTest extends AbstractProvisioningTest {
 
 		//We test that the result of the merge worked.
 		assertEquals(Status.OK_STATUS, desc1.merge(desc2));
-		assertEquals(r2, desc1.findRecommendation(new RequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false)));
+		assertEquals(r2, desc1.findRecommendation(MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false)));
 	}
 
 	public void testRecommendationDescriptorMergeConflict() {
 		RequiredCapability applyOn1, newValue1;
-		applyOn1 = new RequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
-		newValue1 = new RequiredCapability("namespace", "name", new VersionRange("[1.1, 2.0)"), null, false, false);
+		applyOn1 = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
+		newValue1 = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.1, 2.0)"), null, false, false);
 		Recommendation r1 = new Recommendation(applyOn1, newValue1);
 		Set list1 = new HashSet();
 		list1.add(r1);
 		RecommendationDescriptor desc1 = new RecommendationDescriptor(list1);
 
 		RequiredCapability applyOn2, newValue2;
-		applyOn2 = new RequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
-		newValue2 = new RequiredCapability("namespace", "name", new VersionRange("[2.1, 3.0)"), null, false, false);
+		applyOn2 = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[1.0, 2.0)"), null, false, false);
+		newValue2 = MetadataFactory.createRequiredCapability("namespace", "name", new VersionRange("[2.1, 3.0)"), null, false, false);
 		Recommendation r2 = new Recommendation(applyOn2, newValue2);
 		Set list2 = new HashSet();
 		list2.add(r2);
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/ResolutionHelperTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/ResolutionHelperTest.java
index d44d966..c011b60 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/ResolutionHelperTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/director/ResolutionHelperTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2008 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -44,7 +44,7 @@ public class ResolutionHelperTest extends AbstractProvisioningTest {
 		Version version = new Version(5, 0, 0);
 
 		//The IU that exports the capability
-		ProvidedCapability[] provides = new ProvidedCapability[] {new ProvidedCapability("test.capability", "test", version)};
+		ProvidedCapability[] provides = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", "test", version)};
 		IInstallableUnit required = createIU("required", version, provides);
 
 		//an IU whose required capability falls outside available range
@@ -73,7 +73,7 @@ public class ResolutionHelperTest extends AbstractProvisioningTest {
 		Version version = new Version(2, 0, 0);
 
 		//The IU that exports the capability
-		ProvidedCapability[] provides = new ProvidedCapability[] {new ProvidedCapability("test.capability", "test", version)};
+		ProvidedCapability[] provides = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", "test", version)};
 		IInstallableUnit required = createIU("required", version, provides);
 
 		//an IU whose required capability falls outside available range
@@ -98,7 +98,7 @@ public class ResolutionHelperTest extends AbstractProvisioningTest {
 		Version version = new Version(1, 0, 0);
 
 		//The IU that exports the capability
-		ProvidedCapability[] provides = new ProvidedCapability[] {new ProvidedCapability("test.capability", "test", version)};
+		ProvidedCapability[] provides = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", "test", version)};
 		IInstallableUnit required = createIU("required", version, createFilter(FILTER_KEY, "win32"), provides);
 
 		RequiredCapability[] requires = createRequiredCapabilities("test.capability", "test", ANY_VERSION, null);
@@ -144,7 +144,7 @@ public class ResolutionHelperTest extends AbstractProvisioningTest {
 		Version version = new Version(1, 0, 0);
 
 		//The IU that exports the capability
-		ProvidedCapability[] provides = new ProvidedCapability[] {new ProvidedCapability("test.capability", "test", version)};
+		ProvidedCapability[] provides = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", "test", version)};
 		IInstallableUnit required = createIU("required", version, provides);
 
 		//an IU whose filter will match the environment
@@ -172,7 +172,7 @@ public class ResolutionHelperTest extends AbstractProvisioningTest {
 		Version version = new Version(1, 0, 0);
 
 		//The IU that exports the capability
-		ProvidedCapability[] provides = new ProvidedCapability[] {new ProvidedCapability("test.capability", "test", version)};
+		ProvidedCapability[] provides = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", "test", version)};
 		IInstallableUnit required = createIU("required", version, provides);
 
 		//an IU whose filter will not match the environment
@@ -192,10 +192,10 @@ public class ResolutionHelperTest extends AbstractProvisioningTest {
 	}
 
 	public void testSimpleDependency() {
-		RequiredCapability[] requires = new RequiredCapability[] {new RequiredCapability("java.runtime", "JRE", null, null, false, false)};
+		RequiredCapability[] requires = new RequiredCapability[] {MetadataFactory.createRequiredCapability("java.runtime", "JRE", null, null, false, false)};
 		IInstallableUnit osgi = createIU("org.eclipse.osgi", new Version(3, 2, 0, null), requires, NO_PROPERTIES, false);
 
-		ProvidedCapability[] provides = new ProvidedCapability[] {new ProvidedCapability("java.runtime", "JRE", new Version(1, 4, 2, "sr2"))};
+		ProvidedCapability[] provides = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("java.runtime", "JRE", new Version(1, 4, 2, "sr2"))};
 		IInstallableUnit jre = createIU("com.ibm.jre", new Version(1, 4, 2, "sr2"), provides);
 
 		ResolutionHelper rh = new ResolutionHelper(null, null);
@@ -215,7 +215,7 @@ public class ResolutionHelperTest extends AbstractProvisioningTest {
 		Version version = new Version(1, 0, 0);
 
 		//The IU that exports the capability
-		ProvidedCapability[] provides = new ProvidedCapability[] {new ProvidedCapability("test.capability", "test", version)};
+		ProvidedCapability[] provides = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", "test", version)};
 		IInstallableUnit required = createIU("required", version, provides);
 
 		//an IU whose filter will match the environment
@@ -248,7 +248,7 @@ public class ResolutionHelperTest extends AbstractProvisioningTest {
 		Version version = new Version(1, 0, 0);
 
 		//The IU that exports the capability
-		ProvidedCapability[] provides = new ProvidedCapability[] {new ProvidedCapability("test.capability", "test", version)};
+		ProvidedCapability[] provides = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("test.capability", "test", version)};
 		IInstallableUnit required = createIU("required", version, provides);
 
 		//an IU whose filter will not match the environment
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentMethodTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentMethodTest.java
index fec2f7d..91d6f18 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentMethodTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/FragmentMethodTest.java
@@ -156,9 +156,9 @@ public class FragmentMethodTest extends TestCase {
 		iu.setVersion(new Version(1, 0, 0));
 		iu.setTouchpointType(MetadataFactory.createTouchpointType("eclipse", new Version(1, 0, 0)));
 		iu.setProperty(PROP_FRAG, "value");
-		RequiredCapability[] reqs = new RequiredCapability[] {new RequiredCapability("eclipse.touchpoint", "bundle", VersionRange.emptyRange, null, false, true), new RequiredCapability(TEST_REQUIRED, TEST_REQUIRED, VersionRange.emptyRange, null, true, false)};
+		RequiredCapability[] reqs = new RequiredCapability[] {MetadataFactory.createRequiredCapability("eclipse.touchpoint", "bundle", VersionRange.emptyRange, null, false, true), MetadataFactory.createRequiredCapability(TEST_REQUIRED, TEST_REQUIRED, VersionRange.emptyRange, null, true, false)};
 		iu.setRequiredCapabilities(reqs);
-		ProvidedCapability[] cap = new ProvidedCapability[] {new ProvidedCapability("testCapabilityInFragment", "testCapabilityInFragment", new Version(1, 0, 0))};
+		ProvidedCapability[] cap = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("testCapabilityInFragment", "testCapabilityInFragment", new Version(1, 0, 0))};
 		iu.setCapabilities(cap);
 		return MetadataFactory.createInstallableUnitFragment(iu);
 	}
@@ -169,7 +169,7 @@ public class FragmentMethodTest extends TestCase {
 		iu.setVersion(new Version(1, 0, 0));
 		iu.setTouchpointType(MetadataFactory.createTouchpointType("eclipse", new Version(1, 0, 0)));
 		iu.setProperty(PROP_IU, "valueIU");
-		ProvidedCapability[] cap = new ProvidedCapability[] {new ProvidedCapability("eclipse.touchpoint", "bundle", new Version(1, 0, 0)), new ProvidedCapability("testCapability", "testCapability", new Version(1, 0, 0))};
+		ProvidedCapability[] cap = new ProvidedCapability[] {MetadataFactory.createProvidedCapability("eclipse.touchpoint", "bundle", new Version(1, 0, 0)), MetadataFactory.createProvidedCapability("testCapability", "testCapability", new Version(1, 0, 0))};
 		iu.setCapabilities(cap);
 		return MetadataFactory.createInstallableUnit(iu);
 	}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
index 1272fb0..08a3057 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/IUPersistenceTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -86,7 +86,7 @@ public class IUPersistenceTest extends AbstractProvisioningTest {
 		ProvidedCapability[] provided = new ProvidedCapability[provideTuples.length];
 		for (int i = 0; i < provideTuples.length; i++) {
 			String[] nextTuple = provideTuples[i];
-			provided[i] = new ProvidedCapability(nextTuple[0], nextTuple[1], new Version(nextTuple[2]));
+			provided[i] = MetadataFactory.createProvidedCapability(nextTuple[0], nextTuple[1], new Version(nextTuple[2]));
 		}
 		// provided[provideTuples.length] = BUNDLE_CAPABILITY;
 		return provided;
@@ -96,7 +96,7 @@ public class IUPersistenceTest extends AbstractProvisioningTest {
 		RequiredCapability[] required = new RequiredCapability[requireTuples.length];
 		for (int i = 0; i < requireTuples.length; i++) {
 			String[] nextTuple = requireTuples[i];
-			required[i] = new RequiredCapability(nextTuple[0], nextTuple[1], new VersionRange(nextTuple[2]), null, Boolean.valueOf(nextTuple[3]).booleanValue(), false);
+			required[i] = MetadataFactory.createRequiredCapability(nextTuple[0], nextTuple[1], new VersionRange(nextTuple[2]), null, Boolean.valueOf(nextTuple[3]).booleanValue(), false);
 		}
 		return required;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/MultipleIUAndFragmentTest.java b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/MultipleIUAndFragmentTest.java
index 41d7b44..b3c343b 100644
--- a/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/MultipleIUAndFragmentTest.java
+++ b/bundles/org.eclipse.equinox.p2.tests/src/org/eclipse/equinox/p2/tests/metadata/MultipleIUAndFragmentTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,8 +12,7 @@ package org.eclipse.equinox.p2.tests.metadata;
 
 import java.util.*;
 import org.eclipse.equinox.internal.p2.resolution.ResolutionHelper;
-import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
+import org.eclipse.equinox.p2.metadata.*;
 import org.eclipse.equinox.p2.tests.AbstractProvisioningTest;
 import org.eclipse.osgi.service.resolver.VersionRange;
 
@@ -62,7 +61,7 @@ public class MultipleIUAndFragmentTest extends AbstractProvisioningTest {
 	}
 
 	private static IInstallableUnit createIUWithDependencyOn(String iuName, String dependencyOn) {
-		RequiredCapability[] requires = new RequiredCapability[] {new RequiredCapability(IInstallableUnit.NAMESPACE_IU, dependencyOn, VersionRange.emptyRange, null, false, true)};
+		RequiredCapability[] requires = new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU, dependencyOn, VersionRange.emptyRange, null, false, true)};
 		return createEclipseIU(iuName, DEFAULT_VERSION, requires, NO_TP_DATA);
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/ProvAdminQueryProvider.java b/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/ProvAdminQueryProvider.java
index 2baff89..0280109 100644
--- a/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/ProvAdminQueryProvider.java
+++ b/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/ProvAdminQueryProvider.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,7 +14,7 @@ import org.eclipse.equinox.internal.p2.ui.admin.preferences.PreferenceConstants;
 import org.eclipse.equinox.p2.core.repository.IRepository;
 import org.eclipse.equinox.p2.engine.Profile;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
+import org.eclipse.equinox.p2.metadata.MetadataFactory;
 import org.eclipse.equinox.p2.metadata.query.CapabilityQuery;
 import org.eclipse.equinox.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.p2.query.*;
@@ -47,7 +47,7 @@ public class ProvAdminQueryProvider implements IProvElementQueryProvider {
 		boolean showLatest = store.getBoolean(PreferenceConstants.PREF_COLLAPSE_IU_VERSIONS);
 		boolean useCategories = store.getBoolean(PreferenceConstants.PREF_USE_CATEGORIES);
 		boolean showRootsOnly = store.getBoolean(PreferenceConstants.PREF_SHOW_INSTALL_ROOTS_ONLY);
-		Query groupQuery = new CapabilityQuery(new RequiredCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", null, null, false, false)); //$NON-NLS-1$
+		Query groupQuery = new CapabilityQuery(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", null, null, false, false)); //$NON-NLS-1$
 		Query categoryQuery = new IUPropertyQuery(IInstallableUnit.PROP_CATEGORY_IU, Boolean.toString(true));
 		Query query;
 		Profile profile;
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKQueryProvider.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKQueryProvider.java
index b07bb5b..31f2d29 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKQueryProvider.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKQueryProvider.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,7 +14,7 @@ import org.eclipse.equinox.internal.p2.ui.sdk.prefs.PreferenceConstants;
 import org.eclipse.equinox.p2.core.repository.IRepository;
 import org.eclipse.equinox.p2.engine.Profile;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.metadata.RequiredCapability;
+import org.eclipse.equinox.p2.metadata.MetadataFactory;
 import org.eclipse.equinox.p2.metadata.query.CapabilityQuery;
 import org.eclipse.equinox.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.p2.query.*;
@@ -43,7 +43,7 @@ public class ProvSDKQueryProvider implements IProvElementQueryProvider {
 					Query rollbackIUQuery = new IUPropertyQuery(IInstallableUnit.PROP_PROFILE_IU_KEY, Boolean.toString(true));
 					return new ElementQueryDescriptor(element.getQueryable(), new CompoundQuery(new Query[] {profileIdQuery, rollbackIUQuery}, true), new RollbackIUCollector(this, element.getQueryable()));
 				}
-				CapabilityQuery groupQuery = new CapabilityQuery(new RequiredCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", null, null, false, false)); //$NON-NLS-1$
+				CapabilityQuery groupQuery = new CapabilityQuery(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", null, null, false, false)); //$NON-NLS-1$
 				Query categoryQuery = new IUPropertyQuery(IInstallableUnit.PROP_CATEGORY_IU, Boolean.toString(true));
 				if (element instanceof MetadataRepositoryElement) {
 					return new ElementQueryDescriptor(element.getQueryable(), categoryQuery, new CategoryElementCollector(this, element.getQueryable(), false));
