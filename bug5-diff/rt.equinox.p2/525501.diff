commit a63c010a240447de49001ff7adaa4eafddd4194e
Author: Alexander Kurtakov <akurtako@redhat.com>
Date:   Tue Oct 3 16:00:44 2017 +0300

    Bug 525501 - Move director to Java 8
    
    * Bump BREE
    * Bump minor version
    * Enable warnings for newer Java versions
    * Add missing override annotations.
    * Remove redundant type arguments.
    * Lambda conversion.
    
    Change-Id: I4e20b1320bb36215b0e0e2f14ed2c87598293f67
    Signed-off-by: Alexander Kurtakov <akurtako@redhat.com>

1	1	bundles/org.eclipse.equinox.p2.director/.classpath
19	8	bundles/org.eclipse.equinox.p2.director/.settings/org.eclipse.jdt.core.prefs
2	2	bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
1	1	bundles/org.eclipse.equinox.p2.director/pom.xml
7	7	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/AttachmentHelper.java
3	1	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/DirectorActivator.java
3	3	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/DirectorComponent.java
31	1	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Explanation.java
3	1	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/InfiniteProgress.java
9	9	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OperationGenerator.java
5	4	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OptimizationFunction.java
4	1	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PermissiveSlicer.java
2	1	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PlannerComponent.java
27	45	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/ProfileChangeRequest.java
43	39	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
4	1	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/QueryableArray.java
3	1	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimpleDirector.java
32	19	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
7	7	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Slicer.java
6	4	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/UserDefinedOptimizationFunction.java
7	7	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/rollback/FormerState.java
13	8	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/PlannerStatus.java
4	3	bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/RequestStatus.java
diff --git a/bundles/org.eclipse.equinox.p2.director/.classpath b/bundles/org.eclipse.equinox.p2.director/.classpath
index 64c5e31..eca7bdb 100644
--- a/bundles/org.eclipse.equinox.p2.director/.classpath
+++ b/bundles/org.eclipse.equinox.p2.director/.classpath
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="output" path="bin"/>
diff --git a/bundles/org.eclipse.equinox.p2.director/.settings/org.eclipse.jdt.core.prefs b/bundles/org.eclipse.equinox.p2.director/.settings/org.eclipse.jdt.core.prefs
index 06fa52e..0d5a932 100644
--- a/bundles/org.eclipse.equinox.p2.director/.settings/org.eclipse.jdt.core.prefs
+++ b/bundles/org.eclipse.equinox.p2.director/.settings/org.eclipse.jdt.core.prefs
@@ -9,18 +9,22 @@ org.eclipse.jdt.core.classpath.multipleOutputLocations=enabled
 org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations=disabled
 org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation=ignore
 org.eclipse.jdt.core.compiler.annotation.nonnull=org.eclipse.jdt.annotation.NonNull
+org.eclipse.jdt.core.compiler.annotation.nonnull.secondary=
 org.eclipse.jdt.core.compiler.annotation.nonnullbydefault=org.eclipse.jdt.annotation.NonNullByDefault
+org.eclipse.jdt.core.compiler.annotation.nonnullbydefault.secondary=
 org.eclipse.jdt.core.compiler.annotation.nullable=org.eclipse.jdt.annotation.Nullable
+org.eclipse.jdt.core.compiler.annotation.nullable.secondary=
 org.eclipse.jdt.core.compiler.annotation.nullanalysis=disabled
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
 org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.compliance=1.8
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
 org.eclipse.jdt.core.compiler.doc.comment.support=enabled
 org.eclipse.jdt.core.compiler.maxProblemPerUnit=1000
+org.eclipse.jdt.core.compiler.problem.APILeak=warning
 org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
 org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
@@ -32,7 +36,7 @@ org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=
 org.eclipse.jdt.core.compiler.problem.discouragedReference=error
 org.eclipse.jdt.core.compiler.problem.emptyStatement=warning
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable=ignore
+org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable=warning
 org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
 org.eclipse.jdt.core.compiler.problem.fatalOptionalError=disabled
 org.eclipse.jdt.core.compiler.problem.fieldHiding=warning
@@ -49,7 +53,7 @@ org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=private
 org.eclipse.jdt.core.compiler.problem.localVariableHiding=warning
 org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
 org.eclipse.jdt.core.compiler.problem.missingDefaultCase=ignore
-org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=warning
 org.eclipse.jdt.core.compiler.problem.missingEnumCaseDespiteDefault=disabled
 org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
 org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
@@ -58,7 +62,7 @@ org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
 org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
 org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=enabled
 org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=public
-org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=warning
 org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
 org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
 org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
@@ -66,20 +70,22 @@ org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
 org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
 org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=warning
 org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped=warning
+org.eclipse.jdt.core.compiler.problem.nonnullTypeVariableFromLegacyInvocation=warning
 org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict=error
 org.eclipse.jdt.core.compiler.problem.nullReference=warning
 org.eclipse.jdt.core.compiler.problem.nullSpecViolation=error
 org.eclipse.jdt.core.compiler.problem.nullUncheckedConversion=warning
 org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
 org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.pessimisticNullAnalysisForFreeTypeVariables=warning
 org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=warning
 org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
 org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable=ignore
 org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
 org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation=warning
 org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
-org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=ignore
-org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=warning
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=warning
 org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic=ignore
 org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic=ignore
 org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
@@ -88,12 +94,16 @@ org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
 org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
 org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields=disabled
 org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=warning
+org.eclipse.jdt.core.compiler.problem.terminalDeprecation=warning
 org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
 org.eclipse.jdt.core.compiler.problem.unavoidableGenericTypeProblems=enabled
 org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
 org.eclipse.jdt.core.compiler.problem.unclosedCloseable=warning
 org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=warning
 org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentType=warning
+org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentTypeStrict=disabled
+org.eclipse.jdt.core.compiler.problem.unlikelyEqualsArgumentType=info
 org.eclipse.jdt.core.compiler.problem.unnecessaryElse=warning
 org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=warning
 org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
@@ -101,6 +111,7 @@ org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=warning
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.unusedExceptionParameter=ignore
 org.eclipse.jdt.core.compiler.problem.unusedImport=error
 org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
 org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
@@ -113,7 +124,7 @@ org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=error
 org.eclipse.jdt.core.compiler.problem.unusedTypeParameter=ignore
 org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
-org.eclipse.jdt.core.compiler.source=1.5
+org.eclipse.jdt.core.compiler.source=1.8
 org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
diff --git a/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
index 609acd0..232a4e1 100644
--- a/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
@@ -2,7 +2,7 @@ Manifest-Version: 1.0
 Bundle-ManifestVersion: 2
 Bundle-Name: %pluginName
 Bundle-SymbolicName: org.eclipse.equinox.p2.director;singleton:=true
-Bundle-Version: 2.3.300.qualifier
+Bundle-Version: 2.4.0.qualifier
 Bundle-ClassPath: .
 Bundle-Activator: org.eclipse.equinox.internal.p2.director.DirectorActivator
 Bundle-Vendor: %providerName
@@ -27,7 +27,7 @@ Require-Bundle: org.eclipse.equinox.common;bundle-version="[3.3.0,4.0.0)",
  org.eclipse.equinox.p2.metadata;bundle-version="[2.0.0,3.0.0)",
  org.sat4j.core;bundle-version="[2.3.5,3.0.0)",
  org.sat4j.pb;bundle-version="[2.3.5,3.0.0)"
-Bundle-RequiredExecutionEnvironment: J2SE-1.5
+Bundle-RequiredExecutionEnvironment: JavaSE-1.8
 Bundle-ActivationPolicy: lazy
 Service-Component: OSGI-INF/director.xml, OSGI-INF/planner.xml
 Import-Package: org.eclipse.equinox.internal.p2.core.helpers,
diff --git a/bundles/org.eclipse.equinox.p2.director/pom.xml b/bundles/org.eclipse.equinox.p2.director/pom.xml
index 0ba3fa8..64de3a2 100644
--- a/bundles/org.eclipse.equinox.p2.director/pom.xml
+++ b/bundles/org.eclipse.equinox.p2.director/pom.xml
@@ -9,6 +9,6 @@
   </parent>
   <groupId>org.eclipse.equinox</groupId>
   <artifactId>org.eclipse.equinox.p2.director</artifactId>
-  <version>2.3.300-SNAPSHOT</version>
+  <version>2.4.0-SNAPSHOT</version>
   <packaging>eclipse-plugin</packaging>
 </project>
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/AttachmentHelper.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/AttachmentHelper.java
index 71e6612..6df0547 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/AttachmentHelper.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/AttachmentHelper.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- *  Copyright (c) 2009, 2010 IBM Corporation and others.
+ *  Copyright (c) 2009, 2017 IBM Corporation and others.
  *  All rights reserved. This program and the accompanying materials
  *  are made available under the terms of the Eclipse Public License v1.0
  *  which accompanies this distribution, and is available at
@@ -18,9 +18,9 @@ public class AttachmentHelper {
 	private static final IInstallableUnitFragment[] NO_FRAGMENTS = new IInstallableUnitFragment[0];
 
 	public static Collection<IInstallableUnit> attachFragments(Iterator<IInstallableUnit> toAttach, Map<IInstallableUnitFragment, List<IInstallableUnit>> fragmentsToIUs) {
-		Map<IInstallableUnit, IInstallableUnitFragment[]> fragmentBindings = new HashMap<IInstallableUnit, IInstallableUnitFragment[]>();
+		Map<IInstallableUnit, IInstallableUnitFragment[]> fragmentBindings = new HashMap<>();
 		//Build a map inverse of the one provided in input (host --> List of fragments)
-		Map<IInstallableUnit, List<IInstallableUnitFragment>> iusToFragment = new HashMap<IInstallableUnit, List<IInstallableUnitFragment>>(fragmentsToIUs.size());
+		Map<IInstallableUnit, List<IInstallableUnitFragment>> iusToFragment = new HashMap<>(fragmentsToIUs.size());
 		for (Map.Entry<IInstallableUnitFragment, List<IInstallableUnit>> mapping : fragmentsToIUs.entrySet()) {
 			IInstallableUnitFragment fragment = mapping.getKey();
 			List<IInstallableUnit> existingMatches = mapping.getValue();
@@ -28,7 +28,7 @@ public class AttachmentHelper {
 			for (IInstallableUnit host : existingMatches) {
 				List<IInstallableUnitFragment> potentialFragments = iusToFragment.get(host);
 				if (potentialFragments == null) {
-					potentialFragments = new ArrayList<IInstallableUnitFragment>();
+					potentialFragments = new ArrayList<>();
 					iusToFragment.put(host, potentialFragments);
 				}
 				potentialFragments.add(fragment);
@@ -38,7 +38,7 @@ public class AttachmentHelper {
 		for (Map.Entry<IInstallableUnit, List<IInstallableUnitFragment>> entry : iusToFragment.entrySet()) {
 			IInstallableUnit hostIU = entry.getKey();
 			List<IInstallableUnitFragment> potentialIUFragments = entry.getValue();
-			ArrayList<IInstallableUnitFragment> applicableFragments = new ArrayList<IInstallableUnitFragment>();
+			ArrayList<IInstallableUnitFragment> applicableFragments = new ArrayList<>();
 			for (IInstallableUnitFragment potentialFragment : potentialIUFragments) {
 				if (hostIU.equals(potentialFragment))
 					continue;
@@ -65,7 +65,7 @@ public class AttachmentHelper {
 
 			IInstallableUnitFragment theFragment = null;
 			int specificityLevel = 0;
-			LinkedList<IInstallableUnitFragment> fragments = new LinkedList<IInstallableUnitFragment>();
+			LinkedList<IInstallableUnitFragment> fragments = new LinkedList<>();
 			for (IInstallableUnitFragment fragment : applicableFragments) {
 				if (isTranslation(fragment)) {
 					fragments.add(fragment);
@@ -82,7 +82,7 @@ public class AttachmentHelper {
 				fragmentBindings.put(hostIU, fragments.toArray(new IInstallableUnitFragment[fragments.size()]));
 		}
 		//build the collection of resolved IUs
-		Collection<IInstallableUnit> result = new HashSet<IInstallableUnit>();
+		Collection<IInstallableUnit> result = new HashSet<>();
 		while (toAttach.hasNext()) {
 			IInstallableUnit iu = toAttach.next();
 			if (iu == null)
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/DirectorActivator.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/DirectorActivator.java
index d3d20b6..27f00da 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/DirectorActivator.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/DirectorActivator.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,10 +17,12 @@ public class DirectorActivator implements BundleActivator {
 	public static final String PI_DIRECTOR = "org.eclipse.equinox.p2.director"; //$NON-NLS-1$
 	public static BundleContext context;
 
+	@Override
 	public void start(BundleContext ctx) throws Exception {
 		context = ctx;
 	}
 
+	@Override
 	public void stop(BundleContext ctx) throws Exception {
 		DirectorActivator.context = null;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/DirectorComponent.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/DirectorComponent.java
index 08935c4..765c18f 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/DirectorComponent.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/DirectorComponent.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2009-2010 IBM Corporation and others.
+ * Copyright (c) 2009, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,14 +11,14 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.director;
 
-import org.eclipse.equinox.p2.planner.IPlanner;
-
 import org.eclipse.equinox.p2.core.IProvisioningAgent;
 import org.eclipse.equinox.p2.core.spi.IAgentServiceFactory;
 import org.eclipse.equinox.p2.engine.IEngine;
+import org.eclipse.equinox.p2.planner.IPlanner;
 
 public class DirectorComponent implements IAgentServiceFactory {
 
+	@Override
 	public Object createService(IProvisioningAgent agent) {
 		IEngine engine = (IEngine) agent.getService(IEngine.SERVICE_NAME);
 		IPlanner planner = (IPlanner) agent.getService(IPlanner.SERVICE_NAME);
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Explanation.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Explanation.java
index 21116df..3e6a0de 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Explanation.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Explanation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2009, 2010 Daniel Le Berre and others. All rights reserved. This
+ * Copyright (c) 2009, 2017 Daniel Le Berre and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -34,10 +34,12 @@ public abstract class Explanation implements Comparable<Explanation> {
 			this.patch = patch;
 		}
 
+		@Override
 		public int orderValue() {
 			return 6;
 		}
 
+		@Override
 		public IStatus toStatus() {
 			MultiStatus result = new MultiStatus(DirectorActivator.PI_DIRECTOR, 1, Messages.Explanation_unsatisfied, null);
 			final String fromString = patch.toString() + ' ' + getUserReadableName(iu);
@@ -46,6 +48,7 @@ public abstract class Explanation implements Comparable<Explanation> {
 			return result;
 		}
 
+		@Override
 		public String toString() {
 			return NLS.bind(Messages.Explanation_patchedHardDependency, new Object[] {patch, iu, req});
 		}
@@ -66,10 +69,12 @@ public abstract class Explanation implements Comparable<Explanation> {
 			this.req = req;
 		}
 
+		@Override
 		public int orderValue() {
 			return 5;
 		}
 
+		@Override
 		public IStatus toStatus() {
 			MultiStatus result = new MultiStatus(DirectorActivator.PI_DIRECTOR, 1, Messages.Explanation_unsatisfied, null);
 			result.add(new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Explanation_from, getUserReadableName(iu))));
@@ -77,6 +82,7 @@ public abstract class Explanation implements Comparable<Explanation> {
 			return result;
 		}
 
+		@Override
 		public String toString() {
 			return NLS.bind(Messages.Explanation_hardDependency, iu, req);
 		}
@@ -94,14 +100,17 @@ public abstract class Explanation implements Comparable<Explanation> {
 			this.iu = iu;
 		}
 
+		@Override
 		public int orderValue() {
 			return 2;
 		}
 
+		@Override
 		public String toString() {
 			return NLS.bind(Messages.Explanation_alreadyInstalled, iu);
 		}
 
+		@Override
 		public IStatus toStatus() {
 			return new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Explanation_alreadyInstalled, getUserReadableName(iu)));
 		}
@@ -119,14 +128,17 @@ public abstract class Explanation implements Comparable<Explanation> {
 			this.iu = iu;
 		}
 
+		@Override
 		public int orderValue() {
 			return 1;
 		}
 
+		@Override
 		public String toString() {
 			return NLS.bind(Messages.Explanation_toInstall, iu);
 		}
 
+		@Override
 		public IStatus toStatus() {
 			return new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Explanation_toInstall, getUserReadableName(iu)));
 		}
@@ -144,14 +156,17 @@ public abstract class Explanation implements Comparable<Explanation> {
 			this.req = req;
 		}
 
+		@Override
 		public String toString() {
 			return NLS.bind(Messages.Explanation_missingRootFilter, req);
 		}
 
+		@Override
 		public IStatus toStatus() {
 			return new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Explanation_missingRootFilter, req));
 		}
 
+		@Override
 		protected int orderValue() {
 			return 2;
 		}
@@ -173,14 +188,17 @@ public abstract class Explanation implements Comparable<Explanation> {
 			this.isEntryPoint = isEntryPoint;
 		}
 
+		@Override
 		public int orderValue() {
 			return 3;
 		}
 
+		@Override
 		public int shortAnswer() {
 			return MISSING_REQUIREMENT;
 		}
 
+		@Override
 		public String toString() {
 			if (isEntryPoint) {
 				return NLS.bind(Messages.Explanation_missingRootRequired, req);
@@ -191,6 +209,7 @@ public abstract class Explanation implements Comparable<Explanation> {
 			return NLS.bind(Messages.Explanation_missingRequiredFilter, new Object[] {req.getFilter(), iu, req});
 		}
 
+		@Override
 		public IStatus toStatus() {
 			if (isEntryPoint) {
 				return new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Explanation_missingRootRequired, req));
@@ -209,18 +228,22 @@ public abstract class Explanation implements Comparable<Explanation> {
 			this.iu = iu;
 		}
 
+		@Override
 		public int orderValue() {
 			return 3;
 		}
 
+		@Override
 		public int shortAnswer() {
 			return MISSING_REQUIREMENT;
 		}
 
+		@Override
 		public String toString() {
 			return NLS.bind(Messages.Explanation_missingNonGreedyRequired, iu);
 		}
 
+		@Override
 		public IStatus toStatus() {
 			return new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, NLS.bind(Messages.Explanation_missingNonGreedyRequired, getUserReadableName(iu)));
 		}
@@ -233,14 +256,17 @@ public abstract class Explanation implements Comparable<Explanation> {
 			this.ius = ius;
 		}
 
+		@Override
 		public int orderValue() {
 			return 4;
 		}
 
+		@Override
 		public int shortAnswer() {
 			return VIOLATED_SINGLETON_CONSTRAINT;
 		}
 
+		@Override
 		public IStatus toStatus() {
 			MultiStatus result = new MultiStatus(DirectorActivator.PI_DIRECTOR, 1, NLS.bind(Messages.Explanation_singleton, ""), null); //$NON-NLS-1$
 			for (int i = 0; i < ius.length; i++)
@@ -248,6 +274,7 @@ public abstract class Explanation implements Comparable<Explanation> {
 			return result;
 		}
 
+		@Override
 		public String toString() {
 			return NLS.bind(Messages.Explanation_singleton, Arrays.asList(ius));
 		}
@@ -256,10 +283,12 @@ public abstract class Explanation implements Comparable<Explanation> {
 
 	public static final Explanation OPTIONAL_REQUIREMENT = new Explanation() {
 
+		@Override
 		public int orderValue() {
 			return 6;
 		}
 
+		@Override
 		public String toString() {
 			return Messages.Explanation_optionalDependency;
 		}
@@ -283,6 +312,7 @@ public abstract class Explanation implements Comparable<Explanation> {
 		super();
 	}
 
+	@Override
 	public int compareTo(Explanation exp) {
 		if (this.orderValue() == exp.orderValue()) {
 			return this.toString().compareTo(exp.toString());
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/InfiniteProgress.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/InfiniteProgress.java
index db6f653..e625520 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/InfiniteProgress.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/InfiniteProgress.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2009 IBM Corporation and others.
+ * Copyright (c) 2006, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -39,12 +39,14 @@ class InfiniteProgress extends ProgressMonitorWrapper {
 		super(monitor);
 	}
 
+	@Override
 	public void beginTask(String name, int work) {
 		super.beginTask(name, work);
 		this.totalWork = work;
 		this.halfWay = totalWork / 2;
 	}
 
+	@Override
 	public void worked(int work) {
 		if (--nextProgress <= 0) {
 			//we have exhausted the current increment, so report progress
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OperationGenerator.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OperationGenerator.java
index eb5e64d..2230225 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OperationGenerator.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OperationGenerator.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- *  Copyright (c) 2007, 2010 IBM Corporation and others.
+ *  Copyright (c) 2007, 2017 IBM Corporation and others.
  *  All rights reserved. This program and the accompanying materials
  *  are made available under the terms of the Eclipse Public License v1.0
  *  which accompanies this distribution, and is available at
@@ -24,18 +24,18 @@ public class OperationGenerator {
 	}
 
 	public void generateOperation(Collection<IInstallableUnit> from_, Collection<IInstallableUnit> to_) {
-		Collection<IInstallableUnit> intersection = new HashSet<IInstallableUnit>(from_);
+		Collection<IInstallableUnit> intersection = new HashSet<>(from_);
 		intersection.retainAll(to_);
 
-		HashSet<IInstallableUnit> tmpFrom = new HashSet<IInstallableUnit>(from_);
-		HashSet<IInstallableUnit> tmpTo = new HashSet<IInstallableUnit>(to_);
+		HashSet<IInstallableUnit> tmpFrom = new HashSet<>(from_);
+		HashSet<IInstallableUnit> tmpTo = new HashSet<>(to_);
 		tmpFrom.removeAll(intersection);
 		tmpTo.removeAll(intersection);
 
-		List<IInstallableUnit> from = new ArrayList<IInstallableUnit>(tmpFrom);
+		List<IInstallableUnit> from = new ArrayList<>(tmpFrom);
 		Collections.sort(from);
 
-		List<IInstallableUnit> to = new ArrayList<IInstallableUnit>(tmpTo);
+		List<IInstallableUnit> to = new ArrayList<>(tmpTo);
 		Collections.sort(to);
 
 		generateUpdates(from, to);
@@ -50,7 +50,7 @@ public class OperationGenerator {
 		//We retain from each set the things that are the same.
 		//Note that despite the fact that they are the same, a different CU can be attached.
 		//The objects contained in the intersection are the one that were originally in the from collection.
-		TreeSet<IInstallableUnit> to = new TreeSet<IInstallableUnit>(to_);
+		TreeSet<IInstallableUnit> to = new TreeSet<>(to_);
 		for (IInstallableUnit fromIU : intersection) {
 			IInstallableUnit toIU = to.tailSet(fromIU).first();
 			generateConfigurationOperation(fromIU, toIU);
@@ -104,8 +104,8 @@ public class OperationGenerator {
 		if (to.isEmpty() || from.isEmpty())
 			return;
 
-		Set<IInstallableUnit> processed = new HashSet<IInstallableUnit>();
-		Set<IInstallableUnit> removedFromTo = new HashSet<IInstallableUnit>();
+		Set<IInstallableUnit> processed = new HashSet<>();
+		Set<IInstallableUnit> removedFromTo = new HashSet<>();
 
 		QueryableArray indexedFromElements = new QueryableArray(from.toArray(new IInstallableUnit[from.size()]));
 		for (int toIdx = 0; toIdx < to.size(); toIdx++) {
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OptimizationFunction.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OptimizationFunction.java
index 215c737..7a425bc 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OptimizationFunction.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/OptimizationFunction.java
@@ -1,5 +1,6 @@
 /*******************************************************************************
- * Copyright (c) 2013 Rapicorp Inc. and others. All rights reserved. This
+ * Copyright (c) 2013, 2017 Rapicorp Inc. and others. 
+ * All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -38,7 +39,7 @@ public class OptimizationFunction {
 	//Create an optimization function favoring the highest version of each IU
 	public List<WeightedObject<? extends Object>> createOptimizationFunction(IInstallableUnit metaIu, Collection<IInstallableUnit> newRoots) {
 		numberOfInstalledIUs = sizeOf(lastState);
-		List<WeightedObject<? extends Object>> weightedObjects = new ArrayList<WeightedObject<? extends Object>>();
+		List<WeightedObject<? extends Object>> weightedObjects = new ArrayList<>();
 
 		Set<IInstallableUnit> transitiveClosure; //The transitive closure of the IUs we are adding (this also means updating)
 		if (newRoots.isEmpty()) {
@@ -57,7 +58,7 @@ public class OptimizationFunction {
 
 		BigInteger maxWeight = POWER;
 		for (Entry<String, Map<Version, IInstallableUnit>> entry : s) {
-			List<IInstallableUnit> conflictingEntries = new ArrayList<IInstallableUnit>(entry.getValue().values());
+			List<IInstallableUnit> conflictingEntries = new ArrayList<>(entry.getValue().values());
 			if (conflictingEntries.size() == 1) {
 				//Only one IU exists with the namespace.
 				IInstallableUnit iu = conflictingEntries.get(0);
@@ -104,7 +105,7 @@ public class OptimizationFunction {
 
 		//Now we deal the optional IUs,
 		long countOptional = 1;
-		List<IInstallableUnit> requestedPatches = new ArrayList<IInstallableUnit>();
+		List<IInstallableUnit> requestedPatches = new ArrayList<>();
 		Collection<IRequirement> reqs = metaIu.getRequirements();
 		for (IRequirement req : reqs) {
 			if (req.getMin() > 0 || !req.isGreedy())
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PermissiveSlicer.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PermissiveSlicer.java
index 44e7973..b5e7985 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PermissiveSlicer.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PermissiveSlicer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2009, 2010 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2009, 2017 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -32,6 +32,7 @@ public class PermissiveSlicer extends Slicer {
 		this.onlyFilteredRequirements = onlyFilteredRequirements;
 	}
 
+	@Override
 	protected boolean isApplicable(IInstallableUnit iu) {
 		if (considerFilter)
 			return super.isApplicable(iu);
@@ -40,6 +41,7 @@ public class PermissiveSlicer extends Slicer {
 		return evalFilterTo;
 	}
 
+	@Override
 	protected boolean isApplicable(IRequirement req) {
 		//Every filter in this method needs to continue except when the filter does not pass
 		if (!includeOptionalDependencies)
@@ -66,6 +68,7 @@ public class PermissiveSlicer extends Slicer {
 		return evalFilterTo;
 	}
 
+	@Override
 	protected boolean isGreedy(IRequirement req) {
 		if (everythingGreedy) {
 			return true;
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PlannerComponent.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PlannerComponent.java
index e42eb0f..f68a4a9 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PlannerComponent.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/PlannerComponent.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2009, 2010 IBM Corporation and others.
+ * Copyright (c) 2009, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -18,6 +18,7 @@ import org.eclipse.equinox.p2.core.spi.IAgentServiceFactory;
  */
 public class PlannerComponent implements IAgentServiceFactory {
 
+	@Override
 	public Object createService(IProvisioningAgent agent) {
 		return new SimplePlanner(agent);
 	}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/ProfileChangeRequest.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/ProfileChangeRequest.java
index 00410f5..31e62a9 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/ProfileChangeRequest.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/ProfileChangeRequest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- *  Copyright (c) 2008, 2010 IBM Corporation and others.
+ *  Copyright (c) 2008, 2017 IBM Corporation and others.
  *  All rights reserved. This program and the accompanying materials
  *  are made available under the terms of the Eclipse Public License v1.0
  *  which accompanies this distribution, and is available at
@@ -61,7 +61,7 @@ public class ProfileChangeRequest implements Cloneable, IProfileChangeRequest {
 	}
 
 	public Map<String, String> getProfileProperties() {
-		Map<String, String> result = new HashMap<String, String>(profile.getProperties());
+		Map<String, String> result = new HashMap<>(profile.getProperties());
 		if (propertiesToRemove != null) {
 			for (String key : propertiesToRemove) {
 				result.remove(key);
@@ -73,19 +73,14 @@ public class ProfileChangeRequest implements Cloneable, IProfileChangeRequest {
 		return result;
 	}
 
-	//done
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#addInstallableUnit(org.eclipse.equinox.p2.metadata.IInstallableUnit)
-	 */
+	@Override
 	public void add(IInstallableUnit toInstall) {
 		if (iusToAdd == null)
-			iusToAdd = new ArrayList<IInstallableUnit>();
+			iusToAdd = new ArrayList<>();
 		iusToAdd.add(toInstall.unresolved());
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#addInstallableUnits(java.util.Collection)
-	 */
+	@Override
 	public void addAll(Collection<IInstallableUnit> toInstall) {
 		for (IInstallableUnit iu : toInstall)
 			add(iu);
@@ -96,12 +91,10 @@ public class ProfileChangeRequest implements Cloneable, IProfileChangeRequest {
 			add(toInstall[i]);
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#removeInstallableUnit(org.eclipse.equinox.p2.metadata.IInstallableUnit)
-	 */
+	@Override
 	public void remove(IInstallableUnit toUninstall) {
 		if (iusToRemove == null)
-			iusToRemove = new ArrayList<IInstallableUnit>();
+			iusToRemove = new ArrayList<>();
 		iusToRemove.add(toUninstall.unresolved());
 	}
 
@@ -110,72 +103,61 @@ public class ProfileChangeRequest implements Cloneable, IProfileChangeRequest {
 			remove(toUninstall[i]);
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#removeInstallableUnits(java.util.Collection)
-	 */
+	@Override
 	public void removeAll(Collection<IInstallableUnit> toUninstall) {
 		for (IInstallableUnit iu : toUninstall)
 			remove(iu);
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#setProfileProperty(java.lang.String, java.lang.String)
-	 */
+	@Override
 	public void setProfileProperty(String key, String value) {
 		if (propertiesToAdd == null)
-			propertiesToAdd = new HashMap<String, String>();
+			propertiesToAdd = new HashMap<>();
 		propertiesToAdd.put(key, value);
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#removeProfileProperty(java.lang.String)
-	 */
+	@Override
 	public void removeProfileProperty(String key) {
 		if (propertiesToRemove == null)
-			propertiesToRemove = new ArrayList<String>(1);
+			propertiesToRemove = new ArrayList<>(1);
 		propertiesToRemove.add(key);
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#setInstallableUnitProfileProperty(org.eclipse.equinox.p2.metadata.IInstallableUnit, java.lang.String, java.lang.String)
-	 */
+	@Override
 	public void setInstallableUnitProfileProperty(IInstallableUnit iu, String key, String value) {
 		if (iuPropertiesToAdd == null)
-			iuPropertiesToAdd = new HashMap<IInstallableUnit, Map<String, String>>();
+			iuPropertiesToAdd = new HashMap<>();
 		iu = iu.unresolved();
 		Map<String, String> properties = iuPropertiesToAdd.get(iu);
 		if (properties == null) {
-			properties = new HashMap<String, String>();
+			properties = new HashMap<>();
 			iuPropertiesToAdd.put(iu, properties);
 		}
 		properties.put(key, value);
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#removeInstallableUnitProfileProperty(org.eclipse.equinox.p2.metadata.IInstallableUnit, java.lang.String)
-	 */
+	@Override
 	public void removeInstallableUnitProfileProperty(IInstallableUnit iu, String key) {
 		if (iuPropertiesToRemove == null)
-			iuPropertiesToRemove = new HashMap<IInstallableUnit, List<String>>();
+			iuPropertiesToRemove = new HashMap<>();
 		iu = iu.unresolved();
 		List<String> keys = iuPropertiesToRemove.get(iu);
 		if (keys == null) {
-			keys = new ArrayList<String>();
+			keys = new ArrayList<>();
 			iuPropertiesToRemove.put(iu, keys);
 		}
 		if (!keys.contains(key))
 			keys.add(key);
 	}
 
+	@Override
 	public Collection<IInstallableUnit> getRemovals() {
 		if (iusToRemove == null)
 			return Collections.<IInstallableUnit> emptyList();
 		return Collections.unmodifiableList(iusToRemove);
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#getAddedInstallableUnits()
-	 */
+	@Override
 	public Collection<IInstallableUnit> getAdditions() {
 		if (iusToAdd == null)
 			return Collections.<IInstallableUnit> emptyList();
@@ -211,20 +193,17 @@ public class ProfileChangeRequest implements Cloneable, IProfileChangeRequest {
 		return iuPropertiesToAdd;
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#setInstallableUnitInclusionRules(org.eclipse.equinox.p2.metadata.IInstallableUnit, java.lang.String)
-	 */
+	@Override
 	public void setInstallableUnitInclusionRules(IInstallableUnit iu, String value) {
 		setInstallableUnitProfileProperty(iu.unresolved(), SimplePlanner.INCLUSION_RULES, value);
 	}
 
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.director.IPCR#removeInstallableUnitInclusionRules(org.eclipse.equinox.p2.metadata.IInstallableUnit)
-	 */
+	@Override
 	public void removeInstallableUnitInclusionRules(IInstallableUnit iu) {
 		removeInstallableUnitProfileProperty(iu.unresolved(), SimplePlanner.INCLUSION_RULES);
 	}
 
+	@Override
 	@SuppressWarnings("unchecked")
 	public Object clone() {
 		ProfileChangeRequest result = new ProfileChangeRequest(profile);
@@ -238,6 +217,7 @@ public class ProfileChangeRequest implements Cloneable, IProfileChangeRequest {
 		return result;
 	}
 
+	@Override
 	public String toString() {
 		StringBuffer result = new StringBuffer(1000);
 		result.append("==Profile change request for "); //$NON-NLS-1$
@@ -264,12 +244,14 @@ public class ProfileChangeRequest implements Cloneable, IProfileChangeRequest {
 		return result.toString();
 	}
 
+	@Override
 	public void addExtraRequirements(Collection<IRequirement> requirements) {
 		if (additionalRequirements == null)
-			additionalRequirements = new ArrayList<IRequirement>(requirements.size());
+			additionalRequirements = new ArrayList<>(requirements.size());
 		additionalRequirements.addAll(requirements);
 	}
 
+	@Override
 	public Collection<IRequirement> getExtraRequirements() {
 		return additionalRequirements;
 	}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
index a52c57e..914c06d 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Projector.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2013 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2017 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -72,12 +72,12 @@ public class Projector {
 
 	private boolean considerMetaRequirements;
 	private IInstallableUnit entryPoint;
-	private Map<IInstallableUnitFragment, Set<IInstallableUnit>> fragments = new HashMap<IInstallableUnitFragment, Set<IInstallableUnit>>();
+	private Map<IInstallableUnitFragment, Set<IInstallableUnit>> fragments = new HashMap<>();
 
 	//Non greedy things
 	private Set<IInstallableUnit> nonGreedyIUs; //All the IUs that would satisfy non greedy dependencies
-	private Map<IInstallableUnit, AbstractVariable> nonGreedyVariables = new HashMap<IInstallableUnit, AbstractVariable>();
-	private Map<AbstractVariable, List<Object>> nonGreedyProvider = new HashMap<AbstractVariable, List<Object>>(); //Keeps track of all the "object" that provide an IU that is non greedly requested  
+	private Map<IInstallableUnit, AbstractVariable> nonGreedyVariables = new HashMap<>();
+	private Map<AbstractVariable, List<Object>> nonGreedyProvider = new HashMap<>(); //Keeps track of all the "object" that provide an IU that is non greedly requested  
 
 	private boolean emptyBecauseFiltered;
 	private boolean userDefinedFunction;
@@ -93,6 +93,7 @@ public class Projector {
 			// TODO Auto-generated constructor stub
 		}
 
+		@Override
 		public String toString() {
 			return "AbstractVariable: " + hashCode(); //$NON-NLS-1$
 			//			return name == null ? "AbstractVariable: " + hashCode() : name; //$NON-NLS-1$
@@ -111,10 +112,12 @@ public class Projector {
 			setSystem(true);
 		}
 
+		@Override
 		public boolean belongsTo(Object family) {
 			return family == ExplanationJob.this;
 		}
 
+		@Override
 		protected void canceling() {
 			super.canceling();
 			dependencyHelper.stopExplanation();
@@ -124,6 +127,7 @@ public class Projector {
 			return explanation;
 		}
 
+		@Override
 		protected IStatus run(IProgressMonitor monitor) {
 			long start = 0;
 			if (DEBUG) {
@@ -158,12 +162,12 @@ public class Projector {
 
 	public Projector(IQueryable<IInstallableUnit> q, Map<String, String> context, Set<IInstallableUnit> nonGreedyIUs, boolean considerMetaRequirements) {
 		picker = q;
-		slice = new HashMap<String, Map<Version, IInstallableUnit>>();
+		slice = new HashMap<>();
 		selectionContext = InstallableUnit.contextIU(context);
-		abstractVariables = new ArrayList<AbstractVariable>();
-		allOptionalAbstractRequirements = new ArrayList<AbstractVariable>();
+		abstractVariables = new ArrayList<>();
+		allOptionalAbstractRequirements = new ArrayList<>();
 		result = new MultiStatus(DirectorActivator.PI_DIRECTOR, IStatus.OK, Messages.Planner_Problems_resolving_plan, null);
-		assumptions = new ArrayList<Object>();
+		assumptions = new ArrayList<>();
 		this.nonGreedyIUs = nonGreedyIUs;
 		this.considerMetaRequirements = considerMetaRequirements;
 	}
@@ -181,7 +185,7 @@ public class Projector {
 			}
 			IPBSolver solver;
 			if (DEBUG_ENCODING) {
-				solver = new UserFriendlyPBStringSolver<Object>();
+				solver = new UserFriendlyPBStringSolver<>();
 			} else {
 				if (userDefinedFunction) {
 					PBSolverResolution mysolver = SolverFactory.newCompetPBResLongWLMixedConstraintsObjectiveExpSimp();
@@ -214,15 +218,15 @@ public class Projector {
 
 			IQueryResult<IInstallableUnit> queryResult = picker.query(QueryUtil.createIUAnyQuery(), null);
 			if (DEBUG_ENCODING) {
-				dependencyHelper = new LexicoHelper<Object, Explanation>(solver, false);
+				dependencyHelper = new LexicoHelper<>(solver, false);
 				((UserFriendlyPBStringSolver<Object>) solver).setMapping(dependencyHelper.getMappingToDomain());
 			} else {
 				if (userDefinedFunction)
-					dependencyHelper = new SteppedTimeoutLexicoHelper<Object, Explanation>(solver);
+					dependencyHelper = new SteppedTimeoutLexicoHelper<>(solver);
 				else
-					dependencyHelper = new DependencyHelper<Object, Explanation>(solver);
+					dependencyHelper = new DependencyHelper<>(solver);
 			}
-			List<IInstallableUnit> iusToOrder = new ArrayList<IInstallableUnit>(queryResult.toSet());
+			List<IInstallableUnit> iusToOrder = new ArrayList<>(queryResult.toSet());
 			Collections.sort(iusToOrder);
 			for (Iterator<IInstallableUnit> iusToEncode = iusToOrder.iterator(); iusToEncode.hasNext();) {
 				if (monitor.isCanceled()) {
@@ -405,7 +409,7 @@ public class Projector {
 						}
 					}
 				} else {
-					List<Object> newConstraint = new ArrayList<Object>(matches.size());
+					List<Object> newConstraint = new ArrayList<>(matches.size());
 					IInstallableUnit current;
 					for (Iterator<IInstallableUnit> it = matches.iterator(); it.hasNext();) {
 						current = it.next();
@@ -430,7 +434,7 @@ public class Projector {
 					optionalAbstractRequirements.add(abs);
 				} else {
 					abs = getAbstractVariable(req, false);
-					List<Object> newConstraint = new ArrayList<Object>();
+					List<Object> newConstraint = new ArrayList<>();
 					for (Iterator<IInstallableUnit> it = matches.iterator(); it.hasNext();) {
 						current = it.next();
 						newConstraint.add(getNonGreedyVariable(current));
@@ -444,7 +448,7 @@ public class Projector {
 	private void addNonGreedyProvider(AbstractVariable nonGreedyVariable, Object o) {
 		List<Object> providers = nonGreedyProvider.get(nonGreedyVariable);
 		if (providers == null) {
-			providers = new ArrayList<Object>();
+			providers = new ArrayList<>();
 			nonGreedyProvider.put(nonGreedyVariable, providers);
 		}
 		providers.add(o);
@@ -462,7 +466,7 @@ public class Projector {
 		iu = iu.unresolved();
 		Map<Version, IInstallableUnit> iuSlice = slice.get(iu.getId());
 		if (iuSlice == null) {
-			iuSlice = new HashMap<Version, IInstallableUnit>();
+			iuSlice = new HashMap<>();
 			slice.put(iu.getId(), iuSlice);
 		}
 		iuSlice.put(iu.getVersion(), iu);
@@ -488,7 +492,7 @@ public class Projector {
 		if ((!isFragment) && iu.getMetaRequirements().size() == 0)
 			return iu.getRequirements();
 
-		ArrayList<IRequirement> aggregatedRequirements = new ArrayList<IRequirement>(iu.getRequirements().size() + iu.getMetaRequirements().size() + (isFragment ? ((IInstallableUnitFragment) iu).getHost().size() : 0));
+		ArrayList<IRequirement> aggregatedRequirements = new ArrayList<>(iu.getRequirements().size() + iu.getMetaRequirements().size() + (isFragment ? ((IInstallableUnitFragment) iu).getHost().size() : 0));
 		aggregatedRequirements.addAll(iu.getRequirements());
 
 		if (iu instanceof IInstallableUnitFragment) {
@@ -509,8 +513,8 @@ public class Projector {
 	private void expandRequirementsWithPatches(IInstallableUnit iu, IQueryResult<IInstallableUnit> applicablePatches, List<AbstractVariable> optionalAbstractRequirements, boolean isRootIu) throws ContradictionException {
 		//Unmodified dependencies
 		Collection<IRequirement> iuRequirements = getRequiredCapabilities(iu);
-		Map<IRequirement, List<IInstallableUnitPatch>> unchangedRequirements = new HashMap<IRequirement, List<IInstallableUnitPatch>>(iuRequirements.size());
-		Map<IRequirement, Pending> nonPatchedRequirements = new HashMap<IRequirement, Pending>(iuRequirements.size());
+		Map<IRequirement, List<IInstallableUnitPatch>> unchangedRequirements = new HashMap<>(iuRequirements.size());
+		Map<IRequirement, Pending> nonPatchedRequirements = new HashMap<>(iuRequirements.size());
 		for (Iterator<IInstallableUnit> iterator = applicablePatches.iterator(); iterator.hasNext();) {
 			IInstallableUnitPatch patch = (IInstallableUnitPatch) iterator.next();
 			IRequirement[][] reqs = mergeRequirements(iu, patch);
@@ -534,7 +538,7 @@ public class Projector {
 
 					List<IInstallableUnitPatch> patchesAppliedElseWhere = unchangedRequirements.get(reqs[i][0]);
 					if (patchesAppliedElseWhere == null) {
-						patchesAppliedElseWhere = new ArrayList<IInstallableUnitPatch>();
+						patchesAppliedElseWhere = new ArrayList<>();
 						unchangedRequirements.put(reqs[i][0], patchesAppliedElseWhere);
 					}
 					patchesAppliedElseWhere.add(patch);
@@ -572,7 +576,7 @@ public class Projector {
 									}
 								}
 							} else {
-								List<Object> newConstraint = new ArrayList<Object>();
+								List<Object> newConstraint = new ArrayList<>();
 								for (Iterator<IInstallableUnit> it = matches.iterator(); it.hasNext();) {
 									current = it.next();
 									newConstraint.add(getNonGreedyVariable(current));
@@ -596,7 +600,7 @@ public class Projector {
 								optionalAbstractRequirements.add(abs);
 							} else {
 								abs = getAbstractVariable(req, false);
-								List<Object> newConstraint = new ArrayList<Object>(matches.size());
+								List<Object> newConstraint = new ArrayList<>(matches.size());
 								for (Iterator<IInstallableUnit> it = matches.iterator(); it.hasNext();) {
 									current = it.next();
 									newConstraint.add(getNonGreedyVariable(current));
@@ -630,7 +634,7 @@ public class Projector {
 						} else {
 							// manage non greedy IUs
 							IInstallableUnit current;
-							List<Object> nonGreedys = new ArrayList<Object>();
+							List<Object> nonGreedys = new ArrayList<>();
 							for (Iterator<IInstallableUnit> it = matches.iterator(); it.hasNext();) {
 								current = it.next();
 								if (nonGreedyIUs.contains(current)) {
@@ -661,7 +665,7 @@ public class Projector {
 									}
 								}
 							} else {
-								List<Object> newConstraint = new ArrayList<Object>(matches.size());
+								List<Object> newConstraint = new ArrayList<>(matches.size());
 								for (Iterator<IInstallableUnit> it = matches.iterator(); it.hasNext();) {
 									current = it.next();
 									newConstraint.add(getNonGreedyVariable(current));
@@ -693,7 +697,7 @@ public class Projector {
 								}
 							} else {
 								abs = getAbstractVariable(req, false);
-								List<Object> newConstraint = new ArrayList<Object>(matches.size());
+								List<Object> newConstraint = new ArrayList<>(matches.size());
 								for (Iterator<IInstallableUnit> it = matches.iterator(); it.hasNext();) {
 									current = it.next();
 									newConstraint.add(getNonGreedyVariable(current));
@@ -718,7 +722,7 @@ public class Projector {
 		for (Entry<IRequirement, List<IInstallableUnitPatch>> entry : unchangedRequirements.entrySet()) {
 			List<IInstallableUnitPatch> patchesApplied = entry.getValue();
 			Iterator<IInstallableUnit> allPatches = applicablePatches.iterator();
-			List<IInstallableUnitPatch> requiredPatches = new ArrayList<IInstallableUnitPatch>();
+			List<IInstallableUnitPatch> requiredPatches = new ArrayList<>();
 			while (allPatches.hasNext()) {
 				IInstallableUnitPatch patch = (IInstallableUnitPatch) allPatches.next();
 				if (!patchesApplied.contains(patch))
@@ -737,7 +741,7 @@ public class Projector {
 				} else {
 					// manage non greedy IUs
 					IInstallableUnit current;
-					List<Object> nonGreedys = new ArrayList<Object>(matches.size());
+					List<Object> nonGreedys = new ArrayList<>(matches.size());
 					for (Iterator<IInstallableUnit> it = matches.iterator(); it.hasNext();) {
 						current = it.next();
 						if (nonGreedyIUs.contains(current)) {
@@ -766,7 +770,7 @@ public class Projector {
 							}
 						}
 					} else {
-						List<Object> newConstraint = new ArrayList<Object>(matches.size());
+						List<Object> newConstraint = new ArrayList<>(matches.size());
 						for (Iterator<IInstallableUnit> it = matches.iterator(); it.hasNext();) {
 							current = it.next();
 							newConstraint.add(getNonGreedyVariable(current));
@@ -791,7 +795,7 @@ public class Projector {
 						}
 					} else {
 						abs = getAbstractVariable(req, false);
-						List<Object> newConstraint = new ArrayList<Object>(matches.size());
+						List<Object> newConstraint = new ArrayList<>(matches.size());
 						for (Iterator<IInstallableUnit> it = matches.iterator(); it.hasNext();) {
 							current = it.next();
 							newConstraint.add(getNonGreedyVariable(current));
@@ -824,7 +828,7 @@ public class Projector {
 	 * @return a list of mandatory requirements if any, an empty list if req.isOptional().
 	 */
 	private List<IInstallableUnit> getApplicableMatches(IRequirement req) {
-		List<IInstallableUnit> target = new ArrayList<IInstallableUnit>();
+		List<IInstallableUnit> target = new ArrayList<>();
 		IQueryResult<IInstallableUnit> matches = picker.query(QueryUtil.createMatchQuery(req.getMatches()), null);
 		for (Iterator<IInstallableUnit> iterator = matches.iterator(); iterator.hasNext();) {
 			IInstallableUnit match = iterator.next();
@@ -843,7 +847,7 @@ public class Projector {
 		List<IRequirementChange> changes = patch.getRequirementsChange();
 		Collection<IRequirement> iuRequirements = iu.getRequirements();
 		IRequirement[] originalRequirements = iuRequirements.toArray(new IRequirement[iuRequirements.size()]);
-		List<IRequirement[]> rrr = new ArrayList<IRequirement[]>();
+		List<IRequirement[]> rrr = new ArrayList<>();
 		boolean found = false;
 		for (int i = 0; i < changes.size(); i++) {
 			IRequirementChange change = changes.get(i);
@@ -919,8 +923,8 @@ public class Projector {
 				continue;
 
 			Collection<IInstallableUnit> conflictingVersions = conflictingEntries.values();
-			List<IInstallableUnit> singletons = new ArrayList<IInstallableUnit>();
-			List<IInstallableUnit> nonSingletons = new ArrayList<IInstallableUnit>();
+			List<IInstallableUnit> singletons = new ArrayList<>();
+			List<IInstallableUnit> nonSingletons = new ArrayList<>();
 			for (IInstallableUnit iu : conflictingVersions) {
 				if (iu.isSingleton()) {
 					singletons.add(iu);
@@ -1015,7 +1019,7 @@ public class Projector {
 	}
 
 	private void backToIU() {
-		solution = new ArrayList<IInstallableUnit>();
+		solution = new ArrayList<>();
 		IVec<Object> sat4jSolution = dependencyHelper.getSolution();
 		for (Iterator<Object> iter = sat4jSolution.iterator(); iter.hasNext();) {
 			Object var = iter.next();
@@ -1029,7 +1033,7 @@ public class Projector {
 	}
 
 	private void printSolution(Collection<IInstallableUnit> state) {
-		ArrayList<IInstallableUnit> l = new ArrayList<IInstallableUnit>(state);
+		ArrayList<IInstallableUnit> l = new ArrayList<>(state);
 		Collections.sort(l);
 		Tracing.debug("Solution:"); //$NON-NLS-1$
 		Tracing.debug("Numbers of IUs selected: " + l.size()); //$NON-NLS-1$
@@ -1073,12 +1077,12 @@ public class Projector {
 	}
 
 	public Map<IInstallableUnitFragment, List<IInstallableUnit>> getFragmentAssociation() {
-		Map<IInstallableUnitFragment, List<IInstallableUnit>> resolvedFragments = new HashMap<IInstallableUnitFragment, List<IInstallableUnit>>(fragments.size());
+		Map<IInstallableUnitFragment, List<IInstallableUnit>> resolvedFragments = new HashMap<>(fragments.size());
 		for (Entry<IInstallableUnitFragment, Set<IInstallableUnit>> fragment : fragments.entrySet()) {
 			if (!dependencyHelper.getBooleanValueFor(fragment.getKey()))
 				continue;
 			Set<IInstallableUnit> potentialHosts = fragment.getValue();
-			List<IInstallableUnit> resolvedHost = new ArrayList<IInstallableUnit>(potentialHosts.size());
+			List<IInstallableUnit> resolvedHost = new ArrayList<>(potentialHosts.size());
 			for (IInstallableUnit host : potentialHosts) {
 				if (dependencyHelper.getBooleanValueFor(host))
 					resolvedHost.add(host);
@@ -1092,7 +1096,7 @@ public class Projector {
 	private void rememberHostMatches(IInstallableUnitFragment fragment, List<IInstallableUnit> matches) {
 		Set<IInstallableUnit> existingMatches = fragments.get(fragment);
 		if (existingMatches == null) {
-			existingMatches = new HashSet<IInstallableUnit>();
+			existingMatches = new HashSet<>();
 			fragments.put(fragment, existingMatches);
 			existingMatches.addAll(matches);
 		}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/QueryableArray.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/QueryableArray.java
index 575496d..08359b3 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/QueryableArray.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/QueryableArray.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2010 IBM Corporation and others.
+ * Copyright (c) 2008, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -31,10 +31,12 @@ public class QueryableArray extends IndexProvider<IInstallableUnit> {
 		dataSet = CollectionUtils.unmodifiableList(ius);
 	}
 
+	@Override
 	public Iterator<IInstallableUnit> everything() {
 		return dataSet.iterator();
 	}
 
+	@Override
 	public synchronized IIndex<IInstallableUnit> getIndex(String memberName) {
 		if (InstallableUnit.MEMBER_PROVIDED_CAPABILITIES.equals(memberName)) {
 			if (capabilityIndex == null)
@@ -49,6 +51,7 @@ public class QueryableArray extends IndexProvider<IInstallableUnit> {
 		return null;
 	}
 
+	@Override
 	public synchronized Object getManagedProperty(Object client, String memberName, Object key) {
 		if (!(client instanceof IInstallableUnit))
 			return null;
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimpleDirector.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimpleDirector.java
index adf0fd4..f717d90 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimpleDirector.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimpleDirector.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2010 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2017 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -35,6 +35,7 @@ public class SimpleDirector implements IDirector {
 		this.planner = planner;
 	}
 
+	@Override
 	public IStatus revert(IProfile currentProfile, IProfile revertProfile, ProvisioningContext context, IProgressMonitor monitor) {
 		SubMonitor sub = SubMonitor.convert(monitor, Messages.Director_Task_Updating, PlanWork + EngineWork);
 		try {
@@ -45,6 +46,7 @@ public class SimpleDirector implements IDirector {
 		}
 	}
 
+	@Override
 	public IStatus provision(IProfileChangeRequest request, ProvisioningContext context, IProgressMonitor monitor) {
 		String taskName = NLS.bind(Messages.Director_Task_Installing, ((ProfileChangeRequest) request).getProfile().getProperty(IProfile.PROP_INSTALL_FOLDER));
 		SubMonitor sub = SubMonitor.convert(monitor, taskName, PlanWork + EngineWork);
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
index 34566b0..7b1238e 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/SimplePlanner.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2015 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2007, 2017 IBM Corporation and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -52,7 +52,7 @@ public class SimplePlanner implements IPlanner {
 
 	private IProvisioningPlan generateProvisioningPlan(Collection<IInstallableUnit> fromState, Collection<IInstallableUnit> toState, ProfileChangeRequest changeRequest, IProvisioningPlan installerPlan, ProvisioningContext context) {
 		IProvisioningPlan plan = engine.createPlan(changeRequest.getProfile(), context);
-		plan.setFuturePlan(new CollectionResult<IInstallableUnit>(toState));
+		plan.setFuturePlan(new CollectionResult<>(toState));
 		planIUOperations(plan, fromState, toState);
 		planPropertyOperations(plan, changeRequest, toState);
 
@@ -82,7 +82,7 @@ public class SimplePlanner implements IPlanner {
 	private Map<IInstallableUnit, RequestStatus>[] buildDetailedErrors(ProfileChangeRequest changeRequest) {
 		Collection<IInstallableUnit> requestedAdditions = changeRequest.getAdditions();
 		Collection<IInstallableUnit> requestedRemovals = changeRequest.getRemovals();
-		Map<IInstallableUnit, RequestStatus> requestStatus = new HashMap<IInstallableUnit, RequestStatus>(requestedAdditions.size() + requestedAdditions.size());
+		Map<IInstallableUnit, RequestStatus> requestStatus = new HashMap<>(requestedAdditions.size() + requestedAdditions.size());
 		for (IInstallableUnit added : requestedAdditions) {
 			requestStatus.put(added, new RequestStatus(added, RequestStatus.ADDED, IStatus.ERROR, null));
 		}
@@ -96,10 +96,10 @@ public class SimplePlanner implements IPlanner {
 
 	private Map<IInstallableUnit, RequestStatus>[] computeActualChangeRequest(Collection<IInstallableUnit> toState, ProfileChangeRequest changeRequest) {
 		Collection<IInstallableUnit> requestedAdditions = changeRequest.getAdditions();
-		Collection<IInstallableUnit> requestedRemovals = new ArrayList<IInstallableUnit>(changeRequest.getRemovals());
+		Collection<IInstallableUnit> requestedRemovals = new ArrayList<>(changeRequest.getRemovals());
 		requestedRemovals.removeAll(requestedAdditions);
 
-		Map<IInstallableUnit, RequestStatus> requestStatus = new HashMap<IInstallableUnit, RequestStatus>(requestedAdditions.size() + requestedRemovals.size());
+		Map<IInstallableUnit, RequestStatus> requestStatus = new HashMap<>(requestedAdditions.size() + requestedRemovals.size());
 		for (IInstallableUnit added : requestedAdditions) {
 			if (toState.contains(added))
 				requestStatus.put(added, new RequestStatus(added, RequestStatus.ADDED, IStatus.OK, null));
@@ -116,7 +116,7 @@ public class SimplePlanner implements IPlanner {
 
 		//Compute the side effect changes (e.g. things installed optionally going away)
 		Iterator<IInstallableUnit> includedIUs = changeRequest.getProfile().query(new IUProfilePropertyQuery(INCLUSION_RULES, IUProfilePropertyQuery.ANY), null).iterator();
-		Map<IInstallableUnit, RequestStatus> sideEffectStatus = new HashMap<IInstallableUnit, RequestStatus>();
+		Map<IInstallableUnit, RequestStatus> sideEffectStatus = new HashMap<>();
 		while (includedIUs.hasNext()) {
 			IInstallableUnit removal = includedIUs.next();
 			if (!toState.contains(removal) && !requestStatus.containsKey(removal)) {
@@ -136,7 +136,7 @@ public class SimplePlanner implements IPlanner {
 			return new Status(IStatus.ERROR, DirectorActivator.PI_DIRECTOR, Messages.Director_Unsatisfied_Dependencies);
 
 		// hack to create a useful message when a user installs something intended for a target platform into the IDE
-		ArrayList<IStatus> forTargets = new ArrayList<IStatus>(0);
+		ArrayList<IStatus> forTargets = new ArrayList<>(0);
 		for (Explanation next : explanations) {
 			if (next instanceof Explanation.MissingIU) {
 				Explanation.MissingIU missingIU = (MissingIU) next;
@@ -212,6 +212,7 @@ public class SimplePlanner implements IPlanner {
 		new OperationGenerator(plan).generateOperation(fromState, toState);
 	}
 
+	@Override
 	public IProvisioningPlan getDiffPlan(IProfile currentProfile, IProfile targetProfile, IProgressMonitor monitor) {
 		SubMonitor sub = SubMonitor.convert(monitor, ExpandWork);
 		sub.setTaskName(Messages.Director_Task_Resolving_Dependencies);
@@ -233,7 +234,7 @@ public class SimplePlanner implements IPlanner {
 	}
 
 	public static Map<String, String> createSelectionContext(Map<String, String> properties) {
-		HashMap<String, String> result = new HashMap<String, String>(properties);
+		HashMap<String, String> result = new HashMap<>(properties);
 		String environments = properties.get(IProfile.PROP_ENVIRONMENTS);
 		if (environments == null)
 			return result;
@@ -248,7 +249,7 @@ public class SimplePlanner implements IPlanner {
 	}
 
 	private IInstallableUnit[] gatherAvailableInstallableUnits(IInstallableUnit[] additionalSource, ProvisioningContext context, IProgressMonitor monitor) {
-		Map<String, IInstallableUnit> resultsMap = new HashMap<String, IInstallableUnit>();
+		Map<String, IInstallableUnit> resultsMap = new HashMap<>();
 		if (additionalSource != null) {
 			for (int i = 0; i < additionalSource.length; i++) {
 				String key = additionalSource[i].getId() + "_" + additionalSource[i].getVersion().toString(); //$NON-NLS-1$
@@ -317,7 +318,7 @@ public class SimplePlanner implements IPlanner {
 
 			Map<String, String> newSelectionContext = createSelectionContext(profileChangeRequest.getProfileProperties());
 
-			List<IInstallableUnit> extraIUs = new ArrayList<IInstallableUnit>(profileChangeRequest.getAdditions());
+			List<IInstallableUnit> extraIUs = new ArrayList<>(profileChangeRequest.getAdditions());
 			extraIUs.addAll(profileChangeRequest.getRemovals());
 			if (context == null || context.getProperty(INCLUDE_PROFILE_IUS) == null || context.getProperty(INCLUDE_PROFILE_IUS).equalsIgnoreCase(Boolean.TRUE.toString())) {
 				Iterator<IInstallableUnit> itor = profile.available(QueryUtil.createIUAnyQuery(), null).iterator();
@@ -336,7 +337,7 @@ public class SimplePlanner implements IPlanner {
 			}
 			@SuppressWarnings("unchecked")
 			final IQueryable<IInstallableUnit>[] queryables = new IQueryable[] {slice, new QueryableArray(profileChangeRequest.getAdditions().toArray(new IInstallableUnit[profileChangeRequest.getAdditions().size()]))};
-			slice = new CompoundQueryable<IInstallableUnit>(queryables);
+			slice = new CompoundQueryable<>(queryables);
 			Projector projector = new Projector(slice, newSelectionContext, slicer.getNonGreedyIUs(), satisfyMetaRequirements(profileChangeRequest.getProfileProperties()));
 			projector.setUserDefined(profileChangeRequest.getPropertiesToAdd().containsKey("_internal_user_defined_"));
 			projector.encode((IInstallableUnit) updatedPlan[0], (IInstallableUnit[]) updatedPlan[1], profile, profileChangeRequest.getAdditions(), sub.newChild(ExpandWork / 4));
@@ -378,6 +379,7 @@ public class SimplePlanner implements IPlanner {
 		}
 	}
 
+	@Override
 	public IProvisioningPlan getProvisioningPlan(IProfileChangeRequest request, ProvisioningContext context, IProgressMonitor monitor) {
 		ProfileChangeRequest pcr = (ProfileChangeRequest) request;
 		SubMonitor sub = SubMonitor.convert(monitor, ExpandWork);
@@ -390,7 +392,7 @@ public class SimplePlanner implements IPlanner {
 				return (IProvisioningPlan) resolutionResult;
 
 			Collection<IInstallableUnit> newState = ((Projector) resolutionResult).extractSolution();
-			Collection<IInstallableUnit> fullState = new ArrayList<IInstallableUnit>();
+			Collection<IInstallableUnit> fullState = new ArrayList<>();
 			fullState.addAll(newState);
 			newState = AttachmentHelper.attachFragments(newState.iterator(), ((Projector) resolutionResult).getFragmentAssociation());
 
@@ -450,7 +452,7 @@ public class SimplePlanner implements IPlanner {
 
 	//Return all the meta requirements for the list of IU specified and all the meta requirements listed necessary to satisfy the uninstallation 
 	private Collection<IRequirement> extractMetaRequirements(Collection<IInstallableUnit> ius, IProvisioningPlan plan) {
-		Set<IRequirement> allMetaRequirements = new HashSet<IRequirement>();
+		Set<IRequirement> allMetaRequirements = new HashSet<>();
 		for (IInstallableUnit iu : ius) {
 			allMetaRequirements.addAll(iu.getMetaRequirements());
 		}
@@ -589,7 +591,7 @@ public class SimplePlanner implements IPlanner {
 
 		ProvisioningContext agentCtx = new ProvisioningContext(agent);
 		agentCtx.setMetadataRepositories(new URI[0]);
-		ArrayList<IInstallableUnit> extraIUs = new ArrayList<IInstallableUnit>(unattachedState);
+		ArrayList<IInstallableUnit> extraIUs = new ArrayList<>(unattachedState);
 		agentCtx.setExtraInstallableUnits(extraIUs);
 		Object agentSolution = getSolutionFor(agentRequest, agentCtx, monitor.newChild(3));
 		if (agentSolution instanceof IProvisioningPlan && ((IProvisioningPlan) agentSolution).getStatus().getSeverity() == IStatus.ERROR) {
@@ -651,7 +653,7 @@ public class SimplePlanner implements IPlanner {
 		noRepoContext.setMetadataRepositories(new URI[0]);
 		noRepoContext.setArtifactRepositories(new URI[0]);
 		noRepoContext.setProperty(INCLUDE_PROFILE_IUS, Boolean.FALSE.toString());
-		noRepoContext.setExtraInstallableUnits(new ArrayList<IInstallableUnit>(request.getProfile().query(QueryUtil.createIUAnyQuery(), new NullProgressMonitor()).toUnmodifiableSet()));
+		noRepoContext.setExtraInstallableUnits(new ArrayList<>(request.getProfile().query(QueryUtil.createIUAnyQuery(), new NullProgressMonitor()).toUnmodifiableSet()));
 		return noRepoContext;
 	}
 
@@ -674,7 +676,7 @@ public class SimplePlanner implements IPlanner {
 		description.setVersion(version);
 		description.addRequirements(metaRequirements);
 
-		ArrayList<IProvidedCapability> providedCapabilities = new ArrayList<IProvidedCapability>();
+		ArrayList<IProvidedCapability> providedCapabilities = new ArrayList<>();
 		IProvidedCapability providedCapability = MetadataFactory.createProvidedCapability(IInstallableUnit.NAMESPACE_IU_ID, id, version);
 		providedCapabilities.add(providedCapability);
 		description.addProvidedCapabilities(providedCapabilities);
@@ -718,7 +720,7 @@ public class SimplePlanner implements IPlanner {
 				}
 			}
 		}
-		Set<IRequirement> gatheredRequirements = new HashSet<IRequirement>();
+		Set<IRequirement> gatheredRequirements = new HashSet<>();
 
 		//Process all the IUs being added
 		Map<IInstallableUnit, Map<String, String>> iuPropertiesToAdd = profileChangeRequest.getInstallableUnitProfilePropertiesToAdd();
@@ -777,8 +779,9 @@ public class SimplePlanner implements IPlanner {
 		return MetadataFactory.createRequirement(IInstallableUnit.NAMESPACE_IU_ID, iu.getId(), new VersionRange(iu.getVersion(), true, iu.getVersion(), true), null, false, false, true);
 	}
 
+	@Override
 	public IQueryResult<IInstallableUnit> updatesFor(IInstallableUnit toUpdate, ProvisioningContext context, IProgressMonitor monitor) {
-		Map<String, IInstallableUnit> resultsMap = new HashMap<String, IInstallableUnit>();
+		Map<String, IInstallableUnit> resultsMap = new HashMap<>();
 
 		SubMonitor sub = SubMonitor.convert(monitor, 1000);
 		IQueryable<IInstallableUnit> queryable = context.getMetadata(sub.newChild(500));
@@ -791,7 +794,7 @@ public class SimplePlanner implements IPlanner {
 				resultsMap.put(key, iu);
 		}
 		sub.done();
-		return new CollectionResult<IInstallableUnit>(resultsMap.values());
+		return new CollectionResult<>(resultsMap.values());
 	}
 
 	//helper class to trick the resolver to believe that everything is optional
@@ -802,45 +805,55 @@ public class SimplePlanner implements IPlanner {
 			profile = p;
 		}
 
+		@Override
 		public IQueryResult<IInstallableUnit> available(IQuery<IInstallableUnit> query, IProgressMonitor monitor) {
 			return profile.available(query, monitor);
 		}
 
+		@Override
 		public Map<String, String> getInstallableUnitProperties(IInstallableUnit iu) {
 			return profile.getInstallableUnitProperties(iu);
 		}
 
+		@Override
 		public String getInstallableUnitProperty(IInstallableUnit iu, String key) {
 			if (INCLUSION_RULES.equals(key))
 				return ProfileInclusionRules.createOptionalInclusionRule(iu);
 			return profile.getInstallableUnitProperty(iu, key);
 		}
 
+		@Override
 		public String getProfileId() {
 			return profile.getProfileId();
 		}
 
+		@Override
 		public Map<String, String> getProperties() {
 			return profile.getProperties();
 		}
 
+		@Override
 		public String getProperty(String key) {
 			return profile.getProperty(key);
 		}
 
+		@Override
 		public IProvisioningAgent getProvisioningAgent() {
 			return profile.getProvisioningAgent();
 		}
 
+		@Override
 		public long getTimestamp() {
 			return profile.getTimestamp();
 		}
 
+		@Override
 		public IQueryResult<IInstallableUnit> query(IQuery<IInstallableUnit> query, IProgressMonitor monitor) {
 			return profile.query(query, monitor);
 		}
 	}
 
+	@Override
 	public IProfileChangeRequest createChangeRequest(IProfile profileToChange) {
 		return new ProfileChangeRequest(profileToChange);
 	}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Slicer.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Slicer.java
index b9544ac..1bce837 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Slicer.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/Slicer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- *  Copyright (c) 2007, 2010 IBM Corporation and others.
+ *  Copyright (c) 2007, 2017 IBM Corporation and others.
  *  All rights reserved. This program and the accompanying materials
  *  are made available under the terms of the Eclipse Public License v1.0
  *  which accompanies this distribution, and is available at
@@ -32,7 +32,7 @@ public class Slicer {
 
 	private LinkedList<IInstallableUnit> toProcess;
 	private Set<IInstallableUnit> considered; //IUs to add to the slice
-	private Set<IInstallableUnit> nonGreedyIUs = new HashSet<IInstallableUnit>(); //IUs that are brought in by non greedy dependencies
+	private Set<IInstallableUnit> nonGreedyIUs = new HashSet<>(); //IUs that are brought in by non greedy dependencies
 
 	public Slicer(IQueryable<IInstallableUnit> input, Map<String, String> context, boolean considerMetaRequirements) {
 		this(input, InstallableUnit.contextIU(context), considerMetaRequirements);
@@ -42,7 +42,7 @@ public class Slicer {
 		this.possibilites = possibilites;
 		this.selectionContext = selectionContext;
 		this.considerMetaRequirements = considerMetaRequirements;
-		slice = new HashMap<String, Map<Version, IInstallableUnit>>();
+		slice = new HashMap<>();
 		result = new MultiStatus(DirectorActivator.PI_DIRECTOR, IStatus.OK, Messages.Planner_Problems_resolving_plan, null);
 	}
 
@@ -55,8 +55,8 @@ public class Slicer {
 			}
 
 			validateInput(ius);
-			considered = new HashSet<IInstallableUnit>(Arrays.asList(ius));
-			toProcess = new LinkedList<IInstallableUnit>(considered);
+			considered = new HashSet<>(Arrays.asList(ius));
+			toProcess = new LinkedList<>(considered);
 			while (!toProcess.isEmpty()) {
 				if (monitor.isCanceled()) {
 					result.merge(Status.CANCEL_STATUS);
@@ -124,7 +124,7 @@ public class Slicer {
 		Map<Version, IInstallableUnit> iuSlice = slice.get(iu.getId());
 		if (iuSlice == null) {
 
-			iuSlice = new HashMap<Version, IInstallableUnit>();
+			iuSlice = new HashMap<>();
 			slice.put(iu.getId(), iuSlice);
 		}
 		iuSlice.put(iu.getVersion(), iu);
@@ -158,7 +158,7 @@ public class Slicer {
 		if ((!isFragment) && (!isPatch) && iu.getMetaRequirements().size() == 0)
 			return iu.getRequirements();
 
-		ArrayList<IRequirement> aggregatedRequirements = new ArrayList<IRequirement>(iu.getRequirements().size() + iu.getMetaRequirements().size() + (isFragment ? ((IInstallableUnitFragment) iu).getHost().size() : 0) + (isPatch ? ((IInstallableUnitPatch) iu).getRequirementsChange().size() : 0));
+		ArrayList<IRequirement> aggregatedRequirements = new ArrayList<>(iu.getRequirements().size() + iu.getMetaRequirements().size() + (isFragment ? ((IInstallableUnitFragment) iu).getHost().size() : 0) + (isPatch ? ((IInstallableUnitPatch) iu).getRequirementsChange().size() : 0));
 		aggregatedRequirements.addAll(iu.getRequirements());
 
 		if (iu instanceof IInstallableUnitFragment) {
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/UserDefinedOptimizationFunction.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/UserDefinedOptimizationFunction.java
index 65625c4..08cdd82 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/UserDefinedOptimizationFunction.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/director/UserDefinedOptimizationFunction.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2009, 2013 Daniel Le Berre and others. All rights reserved. This
+ * Copyright (c) 2009, 2017 Daniel Le Berre and others. All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -31,9 +31,10 @@ public class UserDefinedOptimizationFunction extends OptimizationFunction {
 		this.alreadyExistingRoots = alreadyInstalledIUs;
 	}
 
+	@Override
 	public List<WeightedObject<? extends Object>> createOptimizationFunction(IInstallableUnit metaIu, Collection<IInstallableUnit> newRoots) {
-		List<WeightedObject<?>> weightedObjects = new ArrayList<WeightedObject<?>>();
-		List<Object> objects = new ArrayList<Object>();
+		List<WeightedObject<?>> weightedObjects = new ArrayList<>();
+		List<Object> objects = new ArrayList<>();
 		BigInteger weight = BigInteger.valueOf(slice.size() + 1);
 		String[] criteria = new String[] {"+new", "-notuptodate", "-changed", "-removed"}; //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$
 		BigInteger currentWeight = weight.pow(criteria.length - 1);
@@ -145,7 +146,7 @@ public class UserDefinedOptimizationFunction extends OptimizationFunction {
 		for (IRequirement req : requirements) {
 			IQuery<IInstallableUnit> query = QueryUtil.createMatchQuery(req.getMatches());
 			IQueryResult<IInstallableUnit> matches = picker.query(query, null);
-			List<IInstallableUnit> toSort = new ArrayList<IInstallableUnit>(matches.toUnmodifiableSet());
+			List<IInstallableUnit> toSort = new ArrayList<>(matches.toUnmodifiableSet());
 			Collections.sort(toSort, Collections.reverseOrder());
 			if (toSort.size() == 0)
 				continue;
@@ -178,6 +179,7 @@ public class UserDefinedOptimizationFunction extends OptimizationFunction {
 			return singleton;
 		}
 
+		@Override
 		protected int orderValue() {
 			return Explanation.OTHER_REASON;
 		}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/rollback/FormerState.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/rollback/FormerState.java
index 72c86da..0696fdc 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/rollback/FormerState.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/p2/rollback/FormerState.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- *  Copyright (c) 2007, 2010 IBM Corporation and others.
+ *  Copyright (c) 2007, 2017 IBM Corporation and others.
  *  All rights reserved. This program and the accompanying materials
  *  are made available under the terms of the Eclipse Public License v1.0
  *  which accompanies this distribution, and is available at
@@ -35,8 +35,8 @@ public class FormerState {
 	private static void synchronizeAllIUProperties(IProfileChangeRequest request, IProfile current, IProfile target) {
 		Set<IInstallableUnit> currentIUset = current.query(QueryUtil.createIUAnyQuery(), null).toUnmodifiableSet();
 		Iterator<IInstallableUnit> targetIUs = target.query(QueryUtil.createIUAnyQuery(), null).iterator();
-		List<IInstallableUnit> iusToAdd = new ArrayList<IInstallableUnit>();
-		List<IInstallableUnit> iusToUpdate = new ArrayList<IInstallableUnit>();
+		List<IInstallableUnit> iusToAdd = new ArrayList<>();
+		List<IInstallableUnit> iusToUpdate = new ArrayList<>();
 		while (targetIUs.hasNext()) {
 			IInstallableUnit nxt = targetIUs.next();
 			if (currentIUset.contains(nxt))
@@ -54,7 +54,7 @@ public class FormerState {
 
 		// updates
 		for (IInstallableUnit iu : iusToUpdate) {
-			Map<String, String> propertiesToSet = new HashMap<String, String>(target.getInstallableUnitProperties(iu));
+			Map<String, String> propertiesToSet = new HashMap<>(target.getInstallableUnitProperties(iu));
 			for (Entry<String, String> entry : current.getInstallableUnitProperties(iu).entrySet()) {
 				String key = entry.getKey();
 				String newValue = propertiesToSet.get(key);
@@ -75,18 +75,18 @@ public class FormerState {
 		Collection<IInstallableUnit> targetPlannerMarkedIUs = SimplePlanner.findPlannerMarkedIUs(target);
 
 		//additions
-		Collection<IInstallableUnit> markedIUsToAdd = new HashSet<IInstallableUnit>(targetPlannerMarkedIUs);
+		Collection<IInstallableUnit> markedIUsToAdd = new HashSet<>(targetPlannerMarkedIUs);
 		markedIUsToAdd.removeAll(currentPlannerMarkedIUs);
 		request.addAll(markedIUsToAdd);
 
 		// removes
-		Collection<IInstallableUnit> markedIUsToRemove = new HashSet<IInstallableUnit>(currentPlannerMarkedIUs);
+		Collection<IInstallableUnit> markedIUsToRemove = new HashSet<>(currentPlannerMarkedIUs);
 		markedIUsToRemove.removeAll(targetPlannerMarkedIUs);
 		request.removeAll(markedIUsToRemove);
 	}
 
 	private static void synchronizeProfileProperties(IProfileChangeRequest request, IProfile current, IProfile target) {
-		Map<String, String> profilePropertiesToSet = new HashMap<String, String>(target.getProperties());
+		Map<String, String> profilePropertiesToSet = new HashMap<>(target.getProperties());
 		for (Entry<String, String> entry : current.getProperties().entrySet()) {
 			String key = entry.getKey();
 
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/PlannerStatus.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/PlannerStatus.java
index 79a481d..0c14040 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/PlannerStatus.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/PlannerStatus.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011 IBM Corporation and others.
+ * Copyright (c) 2011, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,10 +11,10 @@
 package org.eclipse.equinox.internal.provisional.p2.director;
 
 import java.util.Map;
-import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.equinox.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.p2.query.*;
+import org.eclipse.equinox.p2.query.Collector;
+import org.eclipse.equinox.p2.query.IQueryable;
 
 public class PlannerStatus implements IStatus {
 
@@ -24,11 +24,7 @@ public class PlannerStatus implements IStatus {
 	private final Map<IInstallableUnit, RequestStatus> requestSideEffects;
 	private final IQueryable<IInstallableUnit> plannedState;
 
-	private static final IQueryable<IInstallableUnit> EMPTY_IU_QUERYABLE = new IQueryable<IInstallableUnit>() {
-		public IQueryResult<IInstallableUnit> query(IQuery<IInstallableUnit> query, IProgressMonitor monitor) {
-			return Collector.emptyCollector();
-		}
-	};
+	private static final IQueryable<IInstallableUnit> EMPTY_IU_QUERYABLE = (query, monitor) -> Collector.emptyCollector();
 
 	public PlannerStatus(IStatus status, RequestStatus globalRequestStatus, Map<IInstallableUnit, RequestStatus> requestChanges, Map<IInstallableUnit, RequestStatus> requestSideEffects, IQueryable<IInstallableUnit> plannedState) {
 		this.status = status;
@@ -88,38 +84,47 @@ public class PlannerStatus implements IStatus {
 	}
 
 	// Remaining Methods Delegate to wrapped Status 
+	@Override
 	public IStatus[] getChildren() {
 		return status.getChildren();
 	}
 
+	@Override
 	public int getCode() {
 		return status.getCode();
 	}
 
+	@Override
 	public Throwable getException() {
 		return status.getException();
 	}
 
+	@Override
 	public String getMessage() {
 		return status.getMessage();
 	}
 
+	@Override
 	public String getPlugin() {
 		return status.getPlugin();
 	}
 
+	@Override
 	public int getSeverity() {
 		return status.getSeverity();
 	}
 
+	@Override
 	public boolean isMultiStatus() {
 		return status.isMultiStatus();
 	}
 
+	@Override
 	public boolean isOK() {
 		return status.isOK();
 	}
 
+	@Override
 	public boolean matches(int severityMask) {
 		return status.matches(severityMask);
 	}
diff --git a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/RequestStatus.java b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/RequestStatus.java
index 55dd3c6..2bc3d68 100644
--- a/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/RequestStatus.java
+++ b/bundles/org.eclipse.equinox.p2.director/src/org/eclipse/equinox/internal/provisional/p2/director/RequestStatus.java
@@ -1,5 +1,6 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2010 IBM Corporation and others. All rights reserved. This
+ * Copyright (c) 2008, 2017 IBM Corporation and others. 
+ * All rights reserved. This
  * program and the accompanying materials are made available under the terms of
  * the Eclipse Public License v1.0 which accompanies this distribution, and is
  * available at http://www.eclipse.org/legal/epl-v10.html
@@ -33,8 +34,8 @@ public class RequestStatus extends Status {
 		this.iu = iu;
 		this.initialRequestType = initialRequesType;
 		this.explanation = explanation;
-		conflictingRootIUs = new HashSet<IInstallableUnit>();
-		conflictingInstalledIUs = new HashSet<IInstallableUnit>();
+		conflictingRootIUs = new HashSet<>();
+		conflictingInstalledIUs = new HashSet<>();
 		if (explanation != null) {
 			Iterator<Explanation> iterator = explanation.iterator();
 			Explanation o = null;
