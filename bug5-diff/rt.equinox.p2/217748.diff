commit 6d4c92ff530f1c50cf75011ddb4a85ab469f02e3
Author: Susan Franklin <sfranklin>
Date:   Tue Feb 5 19:24:14 2008 +0000

    Bug 217748 - [prov] [ui] Duplicate Categories in User UI

28	14	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/viewers/AvailableIUContentProvider.java
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/viewers/AvailableIUContentProvider.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/viewers/AvailableIUContentProvider.java
index d07f737..ad166de 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/viewers/AvailableIUContentProvider.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/viewers/AvailableIUContentProvider.java
@@ -11,8 +11,8 @@
 
 package org.eclipse.equinox.internal.p2.ui.viewers;
 
-import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.Hashtable;
 import org.eclipse.core.runtime.*;
 import org.eclipse.core.runtime.jobs.*;
 import org.eclipse.equinox.internal.p2.ui.ProvUIMessages;
@@ -88,7 +88,7 @@ public class AvailableIUContentProvider extends RepositoryContentProvider {
 
 	AbstractTreeViewer treeViewer;
 	HashSet allChildren = new HashSet();
-	ArrayList runningJobs = new ArrayList();
+	Hashtable runningJobs = new Hashtable();
 
 	public AvailableIUContentProvider(IQueryProvider queryProvider) {
 		super(queryProvider);
@@ -103,8 +103,8 @@ public class AvailableIUContentProvider extends RepositoryContentProvider {
 				}
 			});
 		}
-		allChildren = new HashSet();
 		cancelJobs();
+		allChildren = new HashSet();
 		super.inputChanged(v, oldInput, newInput);
 	}
 
@@ -118,8 +118,8 @@ public class AvailableIUContentProvider extends RepositoryContentProvider {
 					placeholder = new RepositoryPlaceholder(((ProvElement) elements[i]).getLabel(elements[i]));
 				else
 					placeholder = new RepositoryPlaceholder(elements[i].toString());
-				startFetchingElements(elements[i], placeholder);
 				allChildren.add(placeholder);
+				startFetchingElements(elements[i], placeholder);
 			}
 		}
 		return allChildren.toArray();
@@ -133,14 +133,15 @@ public class AvailableIUContentProvider extends RepositoryContentProvider {
 			 * @see org.eclipse.core.jobs.Job#run(org.eclipse.core.runtime.IProgressMonitor)
 			 */
 			public IStatus run(IProgressMonitor monitor) {
+				if (monitor.isCanceled())
+					return Status.CANCEL_STATUS;
 				if (element instanceof ProvElement) {
 					if (element instanceof RemoteQueriedElement) {
 						IElementCollector collector = new IElementCollector() {
-							boolean added = false;
+							HashSet fetchedChildren = new HashSet();
 
 							public void add(Object o, IProgressMonitor pm) {
-								allChildren.add(o);
-								added = true;
+								fetchedChildren.add(o);
 							}
 
 							public void add(Object[] objs, IProgressMonitor pm) {
@@ -150,16 +151,25 @@ public class AvailableIUContentProvider extends RepositoryContentProvider {
 							}
 
 							public void done() {
-								if (added)
+								if (fetchedChildren.size() > 0) {
+									allChildren.addAll(fetchedChildren);
 									allChildren.remove(placeholder);
-								else
+								} else
 									placeholder.failed = true;
 							}
 						};
 						((RemoteQueriedElement) element).fetchDeferredChildren(element, collector, SubMonitor.convert(monitor));
+						// Check whether we were cancelled during fetch.  If so, remove the placeholder without adding the
+						// fetched children.
+						if (monitor.isCanceled()) {
+							allChildren.remove(placeholder);
+							return Status.CANCEL_STATUS;
+						}
 						collector.done();
 					} else {
 						Object[] children = ((ProvElement) element).getChildren(element);
+						if (monitor.isCanceled())
+							return Status.CANCEL_STATUS;
 						for (int i = 0; i < children.length; i++)
 							allChildren.add(children[i]);
 						if (children.length == 0)
@@ -171,6 +181,8 @@ public class AvailableIUContentProvider extends RepositoryContentProvider {
 				if (!treeViewer.getControl().isDisposed()) {
 					treeViewer.getControl().getDisplay().asyncExec(new Runnable() {
 						public void run() {
+							if (treeViewer.getControl().isDisposed())
+								return;
 							treeViewer.refresh();
 						}
 					});
@@ -180,7 +192,7 @@ public class AvailableIUContentProvider extends RepositoryContentProvider {
 		};
 		job.setPriority(Job.LONG);
 		job.setSystem(true);
-		runningJobs.add(job);
+		runningJobs.put(placeholder.identifier, job);
 		job.addJobChangeListener(new JobChangeAdapter() {
 			public void done(IJobChangeEvent event) {
 				runningJobs.remove(job);
@@ -190,9 +202,11 @@ public class AvailableIUContentProvider extends RepositoryContentProvider {
 	}
 
 	void cancelJobs() {
-		// copy to array since we delete as we go
-		Job[] jobs = (Job[]) runningJobs.toArray(new Job[runningJobs.size()]);
-		for (int i = 0; i < jobs.length; i++)
-			jobs[i].cancel();
+		// copy to keys to an array since we delete as we go
+		String[] identifiers = (String[]) runningJobs.keySet().toArray(new String[runningJobs.size()]);
+		for (int i = 0; i < identifiers.length; i++) {
+			((Job) runningJobs.get(identifiers[i])).cancel();
+			runningJobs.remove(identifiers[i]);
+		}
 	}
 }
\ No newline at end of file
commit dbb6c95ad0561abcac5a85f307ee6e33233dd0be
Author: Susan Franklin <sfranklin>
Date:   Wed Feb 20 23:30:06 2008 +0000

    Bug 217748 - [prov] [ui] Duplicate Categories in User UI

37	9	bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/ProvAdminQueryProvider.java
26	7	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKQueryProvider.java
0	220	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/viewers/AvailableIUContentProvider.java
11	5	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/model/MetadataRepositories.java
11	4	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/CategoryElementCollector.java
0	48	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/FilteredRepositoryQuery.java
43	0	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/MetadataRepositoryElementCollector.java
30	10	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/QueryableArtifactRepositoryManager.java
48	22	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/QueryableMetadataRepositoryManager.java
diff --git a/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/ProvAdminQueryProvider.java b/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/ProvAdminQueryProvider.java
index 5c01eb2..a863c34 100644
--- a/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/ProvAdminQueryProvider.java
+++ b/bundles/org.eclipse.equinox.p2.ui.admin/src/org/eclipse/equinox/internal/p2/ui/admin/ProvAdminQueryProvider.java
@@ -10,6 +10,7 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.ui.admin;
 
+import java.net.URL;
 import org.eclipse.equinox.internal.p2.ui.admin.preferences.PreferenceConstants;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
@@ -57,9 +58,15 @@ public class ProvAdminQueryProvider implements IQueryProvider {
 		IProfile profile;
 		switch (queryType) {
 			case IQueryProvider.ARTIFACT_REPOS :
-				queryable = new QueryableArtifactRepositoryManager();
-				query = hideSystem ? new FilteredRepositoryQuery(IArtifactRepositoryManager.REPOSITORIES_NON_SYSTEM) : allQuery;
-				return new ElementQueryDescriptor(queryable, query, new QueriedElementCollector(this, queryable));
+				int flags = hideSystem ? IArtifactRepositoryManager.REPOSITORIES_NON_SYSTEM : IArtifactRepositoryManager.REPOSITORIES_ALL;
+				queryable = new QueryableArtifactRepositoryManager(flags);
+				return new ElementQueryDescriptor(queryable, null, new Collector() {
+					public boolean accept(Object object) {
+						if (object instanceof URL)
+							return super.accept(new ArtifactRepositoryElement((URL) object));
+						return true;
+					}
+				});
 			case IQueryProvider.AVAILABLE_IUS :
 				// Is it a rollback repository?
 				if (element instanceof RollbackRepositoryElement) {
@@ -81,6 +88,24 @@ public class ProvAdminQueryProvider implements IQueryProvider {
 					// Show 'em all!
 					return new ElementQueryDescriptor(((MetadataRepositoryElement) element).getQueryable(), allQuery, new AvailableIUCollector(this, ((MetadataRepositoryElement) element).getQueryable(), false));
 				}
+				if (element instanceof MetadataRepositories) {
+					MetadataRepositories metaRepos = (MetadataRepositories) element;
+					if (metaRepos.getMetadataRepositories() != null)
+						queryable = new QueryableMetadataRepositoryManager(((MetadataRepositories) element).getMetadataRepositories());
+					else
+						queryable = new QueryableMetadataRepositoryManager(IMetadataRepositoryManager.REPOSITORIES_NON_SYSTEM);
+					if (useCategories)
+						// We are using categories, group into categories first.
+						return new ElementQueryDescriptor(queryable, categoryQuery, new CategoryElementCollector(this, queryable, false));
+					if (showGroupsOnly)
+						// Query all groups and use the query result to optionally select the latest version only
+						return new ElementQueryDescriptor(queryable, groupQuery, showLatest ? new LatestIUVersionElementCollector(this, queryable, false) : new AvailableIUCollector(this, queryable, false));
+					if (showLatest)
+						// We are not querying groups, but we are showing the latest version only
+						return new ElementQueryDescriptor(queryable, allQuery, new LatestIUVersionElementCollector(this, queryable, false));
+					// Show 'em all!
+					return new ElementQueryDescriptor(queryable, allQuery, new AvailableIUCollector(this, queryable, false));
+				}
 				// Things have been grouped by category, now what?
 				if (element instanceof CategoryElement) {
 					Query membersOfCategoryQuery;
@@ -136,12 +161,15 @@ public class ProvAdminQueryProvider implements IQueryProvider {
 					return new ElementQueryDescriptor(profile, new CompoundQuery(new Query[] {groupQuery, query}, true), new InstalledIUCollector(this, profile));
 				return new ElementQueryDescriptor(profile, query, new InstalledIUCollector(this, profile));
 			case IQueryProvider.METADATA_REPOS :
-				if (element instanceof MetadataRepositories)
-					queryable = new QueryableMetadataRepositoryManager(((MetadataRepositories) element).getMetadataRepositories());
-				else
-					queryable = new QueryableMetadataRepositoryManager();
-				query = hideSystem ? new FilteredRepositoryQuery(IMetadataRepositoryManager.REPOSITORIES_NON_SYSTEM) : allQuery;
-				return new ElementQueryDescriptor(queryable, query, new QueriedElementCollector(this, queryable));
+				if (element instanceof MetadataRepositories) {
+					MetadataRepositories metaRepos = (MetadataRepositories) element;
+					if (metaRepos.getMetadataRepositories() != null)
+						queryable = new QueryableMetadataRepositoryManager(((MetadataRepositories) element).getMetadataRepositories());
+					else
+						queryable = new QueryableMetadataRepositoryManager(hideSystem ? IMetadataRepositoryManager.REPOSITORIES_NON_SYSTEM : IMetadataRepositoryManager.REPOSITORIES_ALL);
+				} else
+					queryable = new QueryableMetadataRepositoryManager(hideSystem ? IMetadataRepositoryManager.REPOSITORIES_NON_SYSTEM : IMetadataRepositoryManager.REPOSITORIES_ALL);
+				return new ElementQueryDescriptor(queryable, null, new MetadataRepositoryElementCollector(this));
 			case IQueryProvider.PROFILES :
 				queryable = new QueryableProfileRegistry();
 				return new ElementQueryDescriptor(queryable, new Query() {
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKQueryProvider.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKQueryProvider.java
index 4c1b0f7..b0a6a20 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKQueryProvider.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKQueryProvider.java
@@ -10,6 +10,7 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.ui.sdk;
 
+import java.net.URL;
 import org.eclipse.equinox.internal.p2.ui.sdk.prefs.PreferenceConstants;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
@@ -48,8 +49,14 @@ public class ProvSDKQueryProvider implements IQueryProvider {
 		boolean showLatest = ProvSDKUIActivator.getDefault().getPreferenceStore().getBoolean(PreferenceConstants.PREF_SHOW_LATEST_VERSION);
 		switch (queryType) {
 			case IQueryProvider.ARTIFACT_REPOS :
-				queryable = new QueryableArtifactRepositoryManager();
-				return new ElementQueryDescriptor(queryable, new FilteredRepositoryQuery(IArtifactRepositoryManager.REPOSITORIES_NON_SYSTEM), new QueriedElementCollector(this, queryable));
+				queryable = new QueryableArtifactRepositoryManager(IArtifactRepositoryManager.REPOSITORIES_NON_SYSTEM);
+				return new ElementQueryDescriptor(queryable, null, new Collector() {
+					public boolean accept(Object object) {
+						if (object instanceof URL)
+							return super.accept(new ArtifactRepositoryElement((URL) object));
+						return true;
+					}
+				});
 			case IQueryProvider.AVAILABLE_IUS :
 				if (element instanceof RollbackRepositoryElement) {
 					Query profileIdQuery = new InstallableUnitQuery(((RollbackRepositoryElement) element).getProfileId());
@@ -58,6 +65,14 @@ public class ProvSDKQueryProvider implements IQueryProvider {
 				}
 				CapabilityQuery groupQuery = new CapabilityQuery(MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_KIND, "group", null, null, false, false)); //$NON-NLS-1$
 				Query categoryQuery = new IUPropertyQuery(IInstallableUnit.PROP_CATEGORY_IU, Boolean.toString(true));
+				if (element instanceof MetadataRepositories) {
+					MetadataRepositories metaRepos = (MetadataRepositories) element;
+					if (metaRepos.getMetadataRepositories() != null)
+						queryable = new QueryableMetadataRepositoryManager(((MetadataRepositories) element).getMetadataRepositories());
+					else
+						queryable = new QueryableMetadataRepositoryManager(IMetadataRepositoryManager.REPOSITORIES_NON_SYSTEM);
+					return new ElementQueryDescriptor(queryable, categoryQuery, new CategoryElementCollector(this, queryable, false));
+				}
 				if (element instanceof MetadataRepositoryElement) {
 					return new ElementQueryDescriptor(((MetadataRepositoryElement) element).getQueryable(), categoryQuery, new CategoryElementCollector(this, ((MetadataRepositoryElement) element).getQueryable(), false));
 				}
@@ -105,11 +120,15 @@ public class ProvSDKQueryProvider implements IQueryProvider {
 				profile = (IProfile) ProvUI.getAdapter(element, IProfile.class);
 				return new ElementQueryDescriptor(profile, new IUProfilePropertyQuery(profile, IInstallableUnit.PROP_PROFILE_ROOT_IU, Boolean.toString(true)), new InstalledIUCollector(this, profile));
 			case IQueryProvider.METADATA_REPOS :
-				if (element instanceof MetadataRepositories)
-					queryable = new QueryableMetadataRepositoryManager(((MetadataRepositories) element).getMetadataRepositories());
-				else
-					queryable = new QueryableMetadataRepositoryManager();
-				return new ElementQueryDescriptor(queryable, new FilteredRepositoryQuery(IMetadataRepositoryManager.REPOSITORIES_NON_SYSTEM), new QueriedElementCollector(this, queryable));
+				if (element instanceof MetadataRepositories) {
+					MetadataRepositories metaRepos = (MetadataRepositories) element;
+					if (metaRepos.getMetadataRepositories() != null)
+						queryable = new QueryableMetadataRepositoryManager(((MetadataRepositories) element).getMetadataRepositories());
+					else
+						queryable = new QueryableMetadataRepositoryManager(IMetadataRepositoryManager.REPOSITORIES_NON_SYSTEM);
+				} else
+					queryable = new QueryableMetadataRepositoryManager(IMetadataRepositoryManager.REPOSITORIES_NON_SYSTEM);
+				return new ElementQueryDescriptor(queryable, null, new MetadataRepositoryElementCollector(this));
 			case IQueryProvider.PROFILES :
 				queryable = new QueryableProfileRegistry();
 				return new ElementQueryDescriptor(queryable, new Query() {
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/viewers/AvailableIUContentProvider.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/viewers/AvailableIUContentProvider.java
deleted file mode 100644
index 43d9871..0000000
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/viewers/AvailableIUContentProvider.java
+++ /dev/null
@@ -1,220 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-
-package org.eclipse.equinox.internal.p2.ui.viewers;
-
-import java.util.HashSet;
-import java.util.Hashtable;
-import org.eclipse.core.runtime.*;
-import org.eclipse.core.runtime.jobs.*;
-import org.eclipse.equinox.internal.p2.ui.ProvUIMessages;
-import org.eclipse.equinox.internal.p2.ui.model.ProvElement;
-import org.eclipse.equinox.internal.p2.ui.model.RemoteQueriedElement;
-import org.eclipse.equinox.internal.provisional.p2.ui.ProvUIImages;
-import org.eclipse.equinox.internal.provisional.p2.ui.policy.IQueryProvider;
-import org.eclipse.equinox.internal.provisional.p2.ui.viewers.RepositoryContentProvider;
-import org.eclipse.jface.viewers.AbstractTreeViewer;
-import org.eclipse.jface.viewers.Viewer;
-import org.eclipse.osgi.util.NLS;
-import org.eclipse.swt.events.DisposeEvent;
-import org.eclipse.swt.events.DisposeListener;
-import org.eclipse.ui.model.IWorkbenchAdapter;
-import org.eclipse.ui.progress.IElementCollector;
-
-/**
- * Content provider for available software in any number of repos.
- * 
- * @since 3.4
- * 
- */
-public class AvailableIUContentProvider extends RepositoryContentProvider {
-
-	class RepositoryPlaceholder extends ProvElement {
-		String identifier;
-		boolean failed = false;
-
-		RepositoryPlaceholder(String identifier) {
-			this.identifier = identifier;
-		}
-
-		/* (non-Javadoc)
-		 * @see org.eclipse.ui.model.IWorkbenchAdapter#getChildren(java.lang.Object)
-		 */
-		public Object[] getChildren(Object o) {
-			return new Object[0];
-		}
-
-		/*
-		 * (non-Javadoc)
-		 * @see org.eclipse.equinox.internal.p2.ui.model.ProvElement#isBusy()
-		 */
-		public boolean isBusy() {
-			return true;
-		}
-
-		/*
-		 * 
-		 */
-		public String getImageId(Object o) {
-			return ProvUIImages.IMG_METADATA_REPOSITORY;
-		}
-
-		/* (non-Javadoc)
-		 * @see org.eclipse.ui.model.IWorkbenchAdapter#getLabel(java.lang.Object)
-		 */
-		public String getLabel(Object o) {
-			if (failed)
-				return NLS.bind(ProvUIMessages.AvailableIUContentProvider_FailureRetrievingContents, identifier);
-			return NLS.bind(ProvUIMessages.AvailableIUContentProvider_PlaceholderLabel, identifier);
-		}
-
-		/* (non-Javadoc)
-		 * @see org.eclipse.ui.model.IWorkbenchAdapter#getParent(java.lang.Object)
-		 */
-		public Object getParent(Object o) {
-			return null;
-		}
-
-		/* (non-Javadoc)
-		 * @see org.eclipse.core.runtime.IAdaptable#getAdapter(java.lang.Class)
-		 */
-		public Object getAdapter(Class adapter) {
-			if (adapter == IWorkbenchAdapter.class) {
-				return this;
-			}
-			return null;
-		}
-	}
-
-	AbstractTreeViewer treeViewer;
-	HashSet allChildren = new HashSet();
-	Hashtable runningJobs = new Hashtable();
-
-	public AvailableIUContentProvider(IQueryProvider queryProvider) {
-		super(queryProvider);
-	}
-
-	public void inputChanged(Viewer v, Object oldInput, Object newInput) {
-		if (v instanceof AbstractTreeViewer) {
-			treeViewer = (AbstractTreeViewer) v;
-			treeViewer.getControl().addDisposeListener(new DisposeListener() {
-				public void widgetDisposed(DisposeEvent e) {
-					cancelJobs();
-				}
-			});
-		}
-		cancelJobs();
-		allChildren = new HashSet();
-		super.inputChanged(v, oldInput, newInput);
-	}
-
-	public Object[] getElements(Object input) {
-		if (allChildren.isEmpty()) {
-			// Overridden to get the children of each element as the elements.
-			Object[] elements = super.getElements(input);
-			RepositoryPlaceholder placeholder;
-			for (int i = 0; i < elements.length; i++) {
-				if (elements[i] instanceof ProvElement)
-					placeholder = new RepositoryPlaceholder(((ProvElement) elements[i]).getLabel(elements[i]));
-				else
-					placeholder = new RepositoryPlaceholder(elements[i].toString());
-				allChildren.add(placeholder);
-				startFetchingElements(elements[i], placeholder);
-			}
-		}
-		return allChildren.toArray();
-	}
-
-	private void startFetchingElements(final Object element, final RepositoryPlaceholder placeholder) {
-		final Job job = new Job(NLS.bind(ProvUIMessages.AvailableIUContentProvider_JobName, placeholder.identifier)) {
-			/*
-			 * (non-Javadoc)
-			 * 
-			 * @see org.eclipse.core.jobs.Job#run(org.eclipse.core.runtime.IProgressMonitor)
-			 */
-			public IStatus run(IProgressMonitor monitor) {
-				if (monitor.isCanceled())
-					return Status.CANCEL_STATUS;
-				if (element instanceof ProvElement) {
-					if (element instanceof RemoteQueriedElement) {
-						IElementCollector collector = new IElementCollector() {
-							HashSet fetchedChildren = new HashSet();
-
-							public void add(Object o, IProgressMonitor pm) {
-								fetchedChildren.add(o);
-							}
-
-							public void add(Object[] objs, IProgressMonitor pm) {
-								for (int i = 0; i < objs.length; i++) {
-									add(objs[i], pm);
-								}
-							}
-
-							public void done() {
-								if (fetchedChildren.size() > 0) {
-									allChildren.addAll(fetchedChildren);
-									allChildren.remove(placeholder);
-								} else
-									placeholder.failed = true;
-							}
-						};
-						((RemoteQueriedElement) element).fetchDeferredChildren(element, collector, SubMonitor.convert(monitor));
-						// Check whether we were cancelled during fetch.  If so, remove the placeholder without adding the
-						// fetched children.
-						if (monitor.isCanceled()) {
-							allChildren.remove(placeholder);
-							return Status.CANCEL_STATUS;
-						}
-						collector.done();
-					} else {
-						Object[] children = ((ProvElement) element).getChildren(element);
-						if (monitor.isCanceled())
-							return Status.CANCEL_STATUS;
-						for (int i = 0; i < children.length; i++)
-							allChildren.add(children[i]);
-						if (children.length == 0)
-							placeholder.failed = true;
-						else
-							allChildren.remove(placeholder);
-					}
-				}
-				if (!treeViewer.getControl().isDisposed()) {
-					treeViewer.getControl().getDisplay().asyncExec(new Runnable() {
-						public void run() {
-							if (treeViewer.getControl().isDisposed())
-								return;
-							treeViewer.refresh();
-						}
-					});
-				}
-				return Status.OK_STATUS;
-			}
-		};
-		job.setPriority(Job.LONG);
-		job.setSystem(true);
-		runningJobs.put(placeholder.identifier, job);
-		job.addJobChangeListener(new JobChangeAdapter() {
-			public void done(IJobChangeEvent event) {
-				runningJobs.remove(job);
-			}
-		});
-		job.schedule();
-	}
-
-	void cancelJobs() {
-		// copy to keys to an array since we delete as we go
-		String[] identifiers = (String[]) runningJobs.keySet().toArray(new String[runningJobs.size()]);
-		for (int i = 0; i < identifiers.length; i++) {
-			((Job) runningJobs.get(identifiers[i])).cancel();
-			runningJobs.remove(identifiers[i]);
-		}
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/model/MetadataRepositories.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/model/MetadataRepositories.java
index 97ad10b..9c16cbd 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/model/MetadataRepositories.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/model/MetadataRepositories.java
@@ -15,10 +15,11 @@ import org.eclipse.equinox.internal.provisional.p2.ui.policy.IQueryProvider;
 import org.eclipse.equinox.internal.provisional.p2.ui.query.QueriedElement;
 
 /**
- * Element class that represents the root of a metadata
- * repository viewer.  Its children are obtained using the
- * metadata repository query specified by the client in the
- * content provider.
+ * Element class that represents some collection of metadata repositories.
+ * It can be configured so that it retrieves its children in different ways.
+ * The default query type will return the metadata repositories specified in
+ * this element.  Other query types can be used to query each repository and
+ * aggregate the children.
  * 
  * @since 3.4
  *
@@ -26,6 +27,7 @@ import org.eclipse.equinox.internal.provisional.p2.ui.query.QueriedElement;
 public class MetadataRepositories extends QueriedElement {
 
 	private URL[] metadataRepositories = null;
+	private int queryType = IQueryProvider.METADATA_REPOS;
 
 	public MetadataRepositories() {
 		super();
@@ -40,7 +42,11 @@ public class MetadataRepositories extends QueriedElement {
 	 * @see org.eclipse.equinox.internal.provisional.p2.ui.query.QueriedElement#getQueryType()
 	 */
 	protected int getQueryType() {
-		return IQueryProvider.METADATA_REPOS;
+		return queryType;
+	}
+
+	public void setQueryType(int queryType) {
+		this.queryType = queryType;
 	}
 
 	/**
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/CategoryElementCollector.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/CategoryElementCollector.java
index d73cad2..644302d 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/CategoryElementCollector.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/CategoryElementCollector.java
@@ -53,6 +53,13 @@ public class CategoryElementCollector extends QueriedElementCollector {
 				referredIUs.add(requirements[i].getName());
 			}
 		}
+		Iterator iter = super.iterator();
+		// Don't add the same category IU twice
+		while (iter.hasNext()) {
+			CategoryElement element = (CategoryElement) iter.next();
+			if (element.getIU().getId().equals(iu.getId()))
+				return true;
+		}
 		return super.accept(new CategoryElement(iu));
 	}
 
@@ -92,11 +99,11 @@ public class CategoryElementCollector extends QueriedElementCollector {
 	}
 
 	private void removeNestedCategories() {
-		CategoryElement[] ius = (CategoryElement[]) getList().toArray(new CategoryElement[getList().size()]);
+		CategoryElement[] categoryIUs = (CategoryElement[]) getList().toArray(new CategoryElement[getList().size()]);
 		// If any other element refers to a category element, remove it from the list
-		for (int i = 0; i < ius.length; i++) {
-			if (referredIUs.contains(ius[i].getIU().getId())) {
-				getList().remove(ius[i]);
+		for (int i = 0; i < categoryIUs.length; i++) {
+			if (referredIUs.contains(categoryIUs[i].getIU().getId())) {
+				getList().remove(categoryIUs[i]);
 			}
 		}
 	}
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/FilteredRepositoryQuery.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/FilteredRepositoryQuery.java
deleted file mode 100644
index 2d649a0..0000000
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/FilteredRepositoryQuery.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.provisional.p2.ui.query;
-
-import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
-
-/**
- * A query that provides flags for filtering out which repositories
- * are of interest.  This query is used for optimizations so that only
- * those repository URLs that meet the filter flags will be iterated
- * in the query.  This can prevent unnecessary loading a repositories when
- * only a subset of repositories is desired for running a query.
- * <p>
- * This query may be used alone, or in conjunction with
- * other queries that actually load the repository and further refine
- * the repositories of interest.
- */
-public class FilteredRepositoryQuery extends Query {
-	private int flags = IMetadataRepositoryManager.REPOSITORIES_ALL;
-
-	/**
-	 * Creates a new query which uses the provided flags to filter out
-	 * repositories before loading and querying them. 
-	 */
-	public FilteredRepositoryQuery(int flags) {
-		this.flags = flags;
-	}
-
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.p2.query2.Query#isMatch(java.lang.Object)
-	 */
-	public boolean isMatch(Object object) {
-		return true;
-	}
-
-	public int getFlags() {
-		return flags;
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/MetadataRepositoryElementCollector.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/MetadataRepositoryElementCollector.java
new file mode 100644
index 0000000..7101339
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/MetadataRepositoryElementCollector.java
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.ui.query;
+
+import java.net.URL;
+import org.eclipse.equinox.internal.provisional.p2.ui.model.MetadataRepositoryElement;
+import org.eclipse.equinox.internal.provisional.p2.ui.model.QueriedElementCollector;
+import org.eclipse.equinox.internal.provisional.p2.ui.policy.IQueryProvider;
+
+/**
+ * Collector that accepts the matched repo URLs and
+ * wraps them in a MetadataRepositoryElement.
+ * 
+ * @since 3.4
+ */
+public class MetadataRepositoryElementCollector extends QueriedElementCollector {
+
+	public MetadataRepositoryElementCollector(IQueryProvider queryProvider) {
+		super(queryProvider, null);
+	}
+
+	/**
+	 * Accepts a result that matches the query criteria.
+	 * 
+	 * @param match an object matching the query
+	 * @return <code>true</code> if the query should continue,
+	 * or <code>false</code> to indicate the query should stop.
+	 */
+	public boolean accept(Object match) {
+		if (!(match instanceof URL))
+			return true;
+		return super.accept(new MetadataRepositoryElement((URL) match));
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/QueryableArtifactRepositoryManager.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/QueryableArtifactRepositoryManager.java
index 8153f48..e8ba85b 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/QueryableArtifactRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/QueryableArtifactRepositoryManager.java
@@ -18,33 +18,53 @@ import org.eclipse.equinox.internal.p2.ui.ProvUIMessages;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.query.*;
 import org.eclipse.equinox.internal.provisional.p2.ui.ProvUI;
-import org.eclipse.equinox.internal.provisional.p2.ui.model.ArtifactRepositoryElement;
 import org.eclipse.ui.statushandlers.StatusManager;
 
 /**
  * An object that adds queryable support to an artifact repository 
- * manager.  The object being queried is the repositry URL, not the 
- * repository instance itself.  Callers should load the repository
- * if necessary to complete the query.
+ * manager.  It can be constructed to filter the repositories according to repository filter
+ * flags.  When a query is provided, the object being queried is repository URL.
+ * Callers interested in only the resulting repository URL's can specify a null query, 
+ * in which case the collector will be accepting all iterated URL's.
  */
 public class QueryableArtifactRepositoryManager implements IQueryable {
 
+	int flags = IArtifactRepositoryManager.REPOSITORIES_ALL;
+
+	public QueryableArtifactRepositoryManager(int flags) {
+		this.flags = flags;
+	}
+
+	/**
+	 * Iterates over the artifact repositories configured in this queryable.
+	 * If a query is specified, the query is run on each URL, passing any URLs that satisfy the
+	 * query to the provided collector.  If no query is specified, all repository URLs iterated are passed
+	 * to the collector.
+	 * <p>
+	 * This method is long-running; progress and cancellation are provided
+	 * by the given progress monitor. 
+	 * </p>
+	 * 
+	 * @param query The query to perform on the URLs, or <code>null</code> if all URLs should
+	 * be accepted.
+	 * @param collector Collects the repository URLs
+	 * @param monitor a progress monitor, or <code>null</code> if progress
+	 *    reporting is not desired
+	 * @return The collector argument
+	 */
 	public Collector query(Query query, Collector result, IProgressMonitor monitor) {
 		IArtifactRepositoryManager manager = (IArtifactRepositoryManager) ServiceHelper.getService(ProvUIActivator.getContext(), IArtifactRepositoryManager.class.getName());
 		if (manager == null) {
 			ProvUI.reportStatus(new Status(IStatus.ERROR, ProvUIActivator.PLUGIN_ID, ProvUIMessages.ProvisioningUtil_NoRepositoryManager), StatusManager.SHOW | StatusManager.LOG);
 			return result;
 		}
-		int flags = IArtifactRepositoryManager.REPOSITORIES_ALL;
-		if (query instanceof FilteredRepositoryQuery)
-			flags = ((FilteredRepositoryQuery) query).getFlags();
 		URL[] repoURLs = manager.getKnownRepositories(flags);
 		if (monitor == null)
 			monitor = new NullProgressMonitor();
-		monitor.beginTask(ProvUIMessages.QueryableArtifactRepositoryManager_RepositoryQueryProgress, repoURLs.length * 2);
+		monitor.beginTask(ProvUIMessages.QueryableArtifactRepositoryManager_RepositoryQueryProgress, repoURLs.length);
 		for (int i = 0; i < repoURLs.length; i++) {
-			if (query.isMatch(repoURLs[i]))
-				result.accept(new ArtifactRepositoryElement(repoURLs[i]));
+			if (query == null || query.isMatch(repoURLs[i]))
+				result.accept(repoURLs[i]);
 			monitor.worked(1);
 		}
 		monitor.done();
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/QueryableMetadataRepositoryManager.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/QueryableMetadataRepositoryManager.java
index 1dfcf10..fdb34fb 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/QueryableMetadataRepositoryManager.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/QueryableMetadataRepositoryManager.java
@@ -15,54 +15,80 @@ import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.internal.p2.ui.ProvUIActivator;
 import org.eclipse.equinox.internal.p2.ui.ProvUIMessages;
-import org.eclipse.equinox.internal.provisional.p2.artifact.repository.IArtifactRepositoryManager;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepository;
 import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
 import org.eclipse.equinox.internal.provisional.p2.query.*;
 import org.eclipse.equinox.internal.provisional.p2.ui.ProvUI;
-import org.eclipse.equinox.internal.provisional.p2.ui.model.MetadataRepositoryElement;
+import org.eclipse.osgi.util.NLS;
 import org.eclipse.ui.statushandlers.StatusManager;
 
 /**
  * An object that adds queryable support to a metadata repository 
  * manager.  It can be constructed to iterate over a specific array
- * or URL's.  Otherwise, it will iterate over all known repositories.
- * The object being queried is the repository URL, not the 
- * repository instance itself.  Callers should load the repository
- * if necessary to complete the query.
+ * of repositories named by URL, or filtered according to repository filter
+ * flags.  When a query is provided, the object being queried is the loaded
+ * repository, and collectors should be prepared to accept IInstallableUnits that
+ * meet the query criteria.  Callers interested in only the resulting repository URL's 
+ * should specify a null query, in which case the collector will be accepting the URL's.
  */
 public class QueryableMetadataRepositoryManager implements IQueryable {
 	private URL[] metadataRepositories;
-
-	public QueryableMetadataRepositoryManager() {
-		super();
-	}
+	private int flags = IMetadataRepositoryManager.REPOSITORIES_ALL;
 
 	public QueryableMetadataRepositoryManager(URL[] metadataRepositories) {
 		this.metadataRepositories = metadataRepositories;
 	}
 
+	public QueryableMetadataRepositoryManager(int flags) {
+		this.flags = flags;
+	}
+
+	/**
+	 * Iterates over the metadata repositories configured in this queryable.
+	 * If a query is specified, the query is run on each repository, passing any objects that satisfy the
+	 * query to the provided collector.  If no query is specified, the repository URLs iterated are passed
+	 * to the collector.
+	 * <p>
+	 * This method is long-running; progress and cancellation are provided
+	 * by the given progress monitor. 
+	 * </p>
+	 * 
+	 * @param query The query to perform, or <code>null</code> if the repositories
+	 * should not be loaded and queried.
+	 * @param collector Collects either the repository URLs (when the query is null), or the results 
+	 *    of the query on each repository
+	 * @param monitor a progress monitor, or <code>null</code> if progress
+	 *    reporting is not desired
+	 * @return The collector argument
+	 */
 	public Collector query(Query query, Collector result, IProgressMonitor monitor) {
 		URL[] repoURLs;
+		IMetadataRepositoryManager manager = (IMetadataRepositoryManager) ServiceHelper.getService(ProvUIActivator.getContext(), IMetadataRepositoryManager.class.getName());
+		if (manager == null) {
+			ProvUI.reportStatus(new Status(IStatus.ERROR, ProvUIActivator.PLUGIN_ID, ProvUIMessages.ProvisioningUtil_NoRepositoryManager), StatusManager.SHOW | StatusManager.LOG);
+			return result;
+		}
+
 		if (metadataRepositories != null) {
 			repoURLs = metadataRepositories;
 		} else {
-			IMetadataRepositoryManager manager = (IMetadataRepositoryManager) ServiceHelper.getService(ProvUIActivator.getContext(), IMetadataRepositoryManager.class.getName());
-			if (manager == null) {
-				ProvUI.reportStatus(new Status(IStatus.ERROR, ProvUIActivator.PLUGIN_ID, ProvUIMessages.ProvisioningUtil_NoRepositoryManager), StatusManager.SHOW | StatusManager.LOG);
-				return result;
-			}
-			int flags = IArtifactRepositoryManager.REPOSITORIES_ALL;
-			if (query instanceof FilteredRepositoryQuery)
-				flags = ((FilteredRepositoryQuery) query).getFlags();
 			repoURLs = manager.getKnownRepositories(flags);
 		}
 		SubMonitor sub = SubMonitor.convert(monitor, ProvUIMessages.QueryableMetadataRepositoryManager_RepositoryQueryProgress, repoURLs.length * 2);
 		for (int i = 0; i < repoURLs.length; i++) {
-			if (query.isMatch(repoURLs[i]))
-				result.accept(new MetadataRepositoryElement(repoURLs[i]));
-			sub.worked(1);
+			if (query == null) {
+				result.accept(repoURLs[i]);
+				sub.worked(2);
+			} else {
+				try {
+					IMetadataRepository repo = manager.loadRepository(repoURLs[i], sub.newChild(1));
+					repo.query(query, result, sub.newChild(1));
+				} catch (ProvisionException e) {
+					ProvUI.handleException(e, NLS.bind(ProvUIMessages.ProvisioningUtil_LoadRepositoryFailure, repoURLs[i]), StatusManager.LOG);
+				}
+			}
 		}
-		sub.done();
 		return result;
 	}
 }
