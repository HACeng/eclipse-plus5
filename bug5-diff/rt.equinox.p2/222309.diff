commit e0253163b5d782c0a7491ac8830fa7a17d649069
Author: Pascal Rapicault <prapicau>
Date:   Fri Mar 28 00:05:31 2008 +0000

    Bug 222309 - Review of the metadata translation support

2	2	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/Generator.java
90	102	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
11	5	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/IUPropertyUtils.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/Generator.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/Generator.java
index 9d7915a..7856bc5 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/Generator.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/Generator.java
@@ -355,7 +355,7 @@ public class Generator {
 							}
 						}
 
-						IInstallableUnit bundleIU = MetadataGeneratorHelper.createBundleIU(bd, bundleManifest, isDir, key, localizationIUs);
+						IInstallableUnit bundleIU = MetadataGeneratorHelper.createBundleIU(bd, bundleManifest, isDir, key);
 
 						if (isFragment(bd)) {
 							// TODO: Can NL fragments be multi-host?  What special handling
@@ -365,7 +365,7 @@ public class Generator {
 							String[] cachedValues = (String[]) bundleLocalizationMap.get(hostKey);
 
 							if (cachedValues != null) {
-								MetadataGeneratorHelper.createHostLocalizationFragments(bd, hostId, cachedValues, localizationIUs);
+								MetadataGeneratorHelper.createHostLocalizationFragment(bundleIU, bd, hostId, cachedValues, localizationIUs);
 							}
 						}
 
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
index 8aa4f3c..cf13229 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
@@ -39,6 +39,7 @@ public class MetadataGeneratorHelper {
 	/**
 	 * A capability namespace representing the type of Eclipse resource (bundle, feature, source bundle, etc)
 	 * @see RequiredCapability#getNamespace()
+	 * @see ProvidedCapability#getNamespace()
 	 */
 	public static final String NAMESPACE_ECLIPSE_TYPE = "org.eclipse.equinox.p2.eclipse.type"; //$NON-NLS-1$
 
@@ -46,6 +47,7 @@ public class MetadataGeneratorHelper {
 	 * A capability name in the {@link #NAMESPACE_ECLIPSE_TYPE} namespace 
 	 * representing and OSGi bundle resource
 	 * @see RequiredCapability#getName()
+	 * @see ProvidedCapability#getName()
 	 */
 	public static final String TYPE_ECLIPSE_BUNDLE = "bundle"; //$NON-NLS-1$
 	/**
@@ -63,11 +65,12 @@ public class MetadataGeneratorHelper {
 	public static final String TYPE_ECLIPSE_SOURCE = "source"; //$NON-NLS-1$
 
 	/**
-	 * A capability name in the {@link #NAMESPACE_ECLIPSE_TYPE} namespace 
-	 * representing localized manifest properties
-	 * @see RequiredCapability#getName()
+	 * A capability namespace representing the localization (translation)
+	 * of strings from a specified IU in a specified locale
+	 * @see RequiredCapability#getNamespace()
+	 * @see ProvidedCapability#getNamespace()
 	 */
-	public static final String TYPE_ECLIPSE_MANIFEST_LOCALIZATION = "manifest.localization"; //$NON-NLS-1$
+	public static final String NAMESPACE_IU_LOCALIZATION = "org.eclipse.equinox.p2.localization"; //$NON-NLS-1$
 
 	// Only certain properties in the bundle manifest are assumed to be localized.
 	public static final String[] BUNDLE_LOCALIZED_PROPERTIES = {Constants.BUNDLE_NAME, Constants.BUNDLE_DESCRIPTION, Constants.BUNDLE_VENDOR, Constants.BUNDLE_CONTACTADDRESS, Constants.BUNDLE_DOCURL, Constants.BUNDLE_UPDATELOCATION};
@@ -106,7 +109,6 @@ public class MetadataGeneratorHelper {
 	public static final ProvidedCapability BUNDLE_CAPABILITY = MetadataFactory.createProvidedCapability(NAMESPACE_ECLIPSE_TYPE, TYPE_ECLIPSE_BUNDLE, new Version(1, 0, 0));
 	public static final ProvidedCapability FEATURE_CAPABILITY = MetadataFactory.createProvidedCapability(NAMESPACE_ECLIPSE_TYPE, TYPE_ECLIPSE_FEATURE, new Version(1, 0, 0));
 	public static final ProvidedCapability SOURCE_BUNDLE_CAPABILITY = MetadataFactory.createProvidedCapability(NAMESPACE_ECLIPSE_TYPE, TYPE_ECLIPSE_SOURCE, new Version(1, 0, 0));
-	public static final ProvidedCapability MANIFEST_LOCALIZATION_CAPABILITY = MetadataFactory.createProvidedCapability(NAMESPACE_ECLIPSE_TYPE, TYPE_ECLIPSE_MANIFEST_LOCALIZATION, new Version(1, 0, 0));
 
 	static final String DEFAULT_BUNDLE_LOCALIZATION = "plugin"; //$NON-NLS-1$	
 	static final String PROPERTIES_FILE_EXTENSION = ".properties"; //$NON-NLS-1$
@@ -173,23 +175,16 @@ public class MetadataGeneratorHelper {
 		return MetadataFactory.createInstallableUnit(cu);
 	}
 
-	public static IInstallableUnit createBundleIU(BundleDescription bd, Map manifest, boolean isFolderPlugin, IArtifactKey key, Set localizationIUs) {
-		IInstallableUnit bundleIU = createBundleIU(bd, manifest, isFolderPlugin, key);
-
+	public static IInstallableUnit createBundleIU(BundleDescription bd, Map manifest, boolean isFolderPlugin, IArtifactKey key) {
+		Map manifestLocalizations = null;
 		if (manifest != null && bd.getLocation() != null) {
-			String bundleLocalization = (String) manifest.get(Constants.BUNDLE_LOCALIZATION);
-			if (bundleLocalization == null) {
-				bundleLocalization = DEFAULT_BUNDLE_LOCALIZATION;
-			}
-			Map manifestLocalizations = getManifestLocalizations(manifest, new File(bd.getLocation()));
-			if (manifestLocalizations != null) {
-				localizationIUs.addAll(createLocalizationFragmentsForBundle(bd, manifestLocalizations));
-			}
+			manifestLocalizations = getManifestLocalizations(manifest, new File(bd.getLocation()));
 		}
-		return bundleIU;
+
+		return createBundleIU(bd, manifest, isFolderPlugin, key, manifestLocalizations);
 	}
 
-	public static IInstallableUnit createBundleIU(BundleDescription bd, Map manifest, boolean isFolderPlugin, IArtifactKey key) {
+	public static IInstallableUnit createBundleIU(BundleDescription bd, Map manifest, boolean isFolderPlugin, IArtifactKey key, Map manifestLocalizations) {
 		boolean isBinaryBundle = true;
 		if (manifest != null && manifest.containsKey("Eclipse-SourceBundle")) { //$NON-NLS-1$
 			isBinaryBundle = false;
@@ -250,6 +245,20 @@ public class MetadataGeneratorHelper {
 
 		if (isFragment)
 			providedCapabilities.add(MetadataFactory.createProvidedCapability(CAPABILITY_NS_OSGI_FRAGMENT, bd.getHost().getName(), bd.getVersion()));
+
+		if (manifestLocalizations != null) {
+			for (Iterator iter = manifestLocalizations.keySet().iterator(); iter.hasNext();) {
+				Locale locale = (Locale) iter.next();
+				Properties translatedStrings = (Properties) manifestLocalizations.get(locale);
+				Enumeration propertyKeys = translatedStrings.propertyNames();
+				while (propertyKeys.hasMoreElements()) {
+					String nextKey = (String) propertyKeys.nextElement();
+					iu.setProperty(locale.toString() + '.' + nextKey, translatedStrings.getProperty(nextKey));
+				}
+				providedCapabilities.add(makeTranslationCapability(bd.getSymbolicName(), locale));
+			}
+		}
+
 		iu.setCapabilities((ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]));
 
 		iu.setArtifacts(new IArtifactKey[] {key});
@@ -284,57 +293,42 @@ public class MetadataGeneratorHelper {
 		return MetadataFactory.createInstallableUnit(iu);
 	}
 
-	private static List createLocalizationFragmentsForBundle(BundleDescription bd, Map manifestLocalizations) {
-		List localizationFragments = new ArrayList(manifestLocalizations.size());
-		for (Iterator iter = manifestLocalizations.keySet().iterator(); iter.hasNext();) {
-			Locale locale = (Locale) iter.next();
-			Properties localizedStrings = (Properties) manifestLocalizations.get(locale);
-			IInstallableUnitFragment nextLocaleFragment = createLocalizationFragmentOfBundle(bd, locale, localizedStrings);
-			localizationFragments.add(nextLocaleFragment);
-		}
-		return localizationFragments;
-	}
-
 	/*
 	 * @param bd
-	 * @param locale
-	 * @param localizedStrings
+	 * @param manifestLocalizations	map from locale to translated properties
 	 * @return installableUnitFragment
 	 */
-	private static IInstallableUnitFragment createLocalizationFragmentOfBundle(BundleDescription bd, Locale locale, Properties localizedStrings) {
-		InstallableUnitFragmentDescription fragment = new MetadataFactory.InstallableUnitFragmentDescription();
-		String fragmentId = makeLocalizationFragmentId(bd.getSymbolicName(), locale);
-		fragment.setId(fragmentId);
-		fragment.setVersion(bd.getVersion());
-
-		RequiredCapability[] hostReqs = new RequiredCapability[] {MetadataFactory.createRequiredCapability(NAMESPACE_ECLIPSE_TYPE, bd.getSymbolicName(), new VersionRange(bd.getVersion(), true, bd.getVersion(), true), null, false, false)};
-		fragment.setHost(hostReqs);
-
-		fragment.setSingleton(true);
-
-		Enumeration propertyKeys = localizedStrings.propertyNames();
-		while (propertyKeys.hasMoreElements()) {
-			String nextKey = (String) propertyKeys.nextElement();
-			fragment.setProperty(nextKey, localizedStrings.getProperty(nextKey));
-		}
-		// TODO: do we need any capabilities?
-		// Create set of provided capabilities It's just a tag indicating a localization fragment.
-		ArrayList providedCapabilities = new ArrayList(1);
-		providedCapabilities.add(MANIFEST_LOCALIZATION_CAPABILITY);
-		fragment.setCapabilities((ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]));
-
-		return MetadataFactory.createInstallableUnitFragment(fragment);
-	}
-
-	public static void createHostLocalizationFragments(BundleDescription bd, String hostId, String[] hostBundleManifestValues, Set localizationIUs) {
+	//	private static IInstallableUnitFragment createLocalizationFragmentOfBundle(BundleDescription bd, Map manifestLocalizations) {
+	//		InstallableUnitFragmentDescription fragment = new MetadataFactory.InstallableUnitFragmentDescription();
+	//		String fragmentId = makeBundleLocalizationFragmentId(bd.getSymbolicName());
+	//		fragment.setId(fragmentId);
+	//		fragment.setVersion(bd.getVersion());
+	//
+	//		RequiredCapability[] hostReqs = new RequiredCapability[] {MetadataFactory.createRequiredCapability(NAMESPACE_ECLIPSE_TYPE, bd.getSymbolicName(), new VersionRange(bd.getVersion(), true, bd.getVersion(), true), null, false, false, false)};
+	//		fragment.setHost(hostReqs);
+	//
+	//		fragment.setSingleton(true);
+	//
+	//		ArrayList providedCapabilities = new ArrayList(manifestLocalizations.size());
+	//		for (Iterator iter = manifestLocalizations.keySet().iterator(); iter.hasNext();) {
+	//			Locale locale = (Locale) iter.next();
+	//			Properties translatedStrings = (Properties) manifestLocalizations.get(locale);
+	//			Enumeration propertyKeys = translatedStrings.propertyNames();
+	//			while (propertyKeys.hasMoreElements()) {
+	//				String nextKey = (String) propertyKeys.nextElement();
+	//				fragment.setProperty(locale.toString() + '.' + nextKey, translatedStrings.getProperty(nextKey));
+	//			}
+	//			providedCapabilities.add(makeTranslationCapability(bd.getSymbolicName(), locale));
+	//		}
+	//		fragment.setCapabilities((ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]));
+	//
+	//		return MetadataFactory.createInstallableUnitFragment(fragment);
+	//	}
+	public static void createHostLocalizationFragment(IInstallableUnit bundleIU, BundleDescription bd, String hostId, String[] hostBundleManifestValues, Set localizationIUs) {
 		Map hostLocalizations = getHostLocalizations(new File(bd.getLocation()), hostBundleManifestValues);
 		if (hostLocalizations != null) {
-			for (Iterator iter = hostLocalizations.keySet().iterator(); iter.hasNext();) {
-				Locale locale = (Locale) iter.next();
-				Properties localizedStrings = (Properties) hostLocalizations.get(locale);
-				IInstallableUnitFragment nextLocaleFragment = createLocalizationFragmentOfHost(hostId, hostBundleManifestValues, bd, locale, localizedStrings);
-				localizationIUs.add(nextLocaleFragment);
-			}
+			IInstallableUnitFragment localizationFragment = createLocalizationFragmentOfHost(bd, hostId, hostBundleManifestValues, hostLocalizations);
+			localizationIUs.add(localizationFragment);
 		}
 	}
 
@@ -345,29 +339,32 @@ public class MetadataGeneratorHelper {
 	 * @param localizedStrings
 	 * @return installableUnitFragment
 	 */
-	private static IInstallableUnitFragment createLocalizationFragmentOfHost(String hostId, String[] hostManifestValues, BundleDescription bd, Locale locale, Properties localizedStrings) {
+	private static IInstallableUnitFragment createLocalizationFragmentOfHost(BundleDescription bd, String hostId, String[] hostManifestValues, Map hostLocalizations) {
 		InstallableUnitFragmentDescription fragment = new MetadataFactory.InstallableUnitFragmentDescription();
-		HostSpecification hostSpec = bd.getHost();
-		String fragmentId = makeLocalizationFragmentId(hostId, locale);
+		String fragmentId = makeHostLocalizationFragmentId(bd.getSymbolicName());
 		fragment.setId(fragmentId);
 		fragment.setVersion(bd.getVersion()); // TODO: is this a meaningful version?
 
-		RequiredCapability[] hostReqs = new RequiredCapability[] {MetadataFactory.createRequiredCapability(NAMESPACE_ECLIPSE_TYPE, hostSpec.getName(), hostSpec.getVersionRange(), null, false, false)};
+		HostSpecification hostSpec = bd.getHost();
+		RequiredCapability[] hostReqs = new RequiredCapability[] {MetadataFactory.createRequiredCapability(IInstallableUnit.NAMESPACE_IU_ID, hostSpec.getName(), hostSpec.getVersionRange(), null, false, false, false)};
 		fragment.setHost(hostReqs);
 
 		fragment.setSingleton(true);
+		fragment.setProperty(IInstallableUnit.PROP_TYPE_FRAGMENT, Boolean.TRUE.toString());
 
-		for (int i = 0; i < BUNDLE_LOCALIZED_PROPERTIES.length; i++) {
-			String nextKey = hostManifestValues[i];
-			String localizedValue = null;
-			if (nextKey != null && (localizedValue = localizedStrings.getProperty(nextKey)) != null) {
-				fragment.setProperty(nextKey, localizedValue);
+		// Create a provided capability for each locale and add the translated properties.
+		ArrayList providedCapabilities = new ArrayList(hostLocalizations.keySet().size());
+		for (Iterator iter = hostLocalizations.keySet().iterator(); iter.hasNext();) {
+			Locale locale = (Locale) iter.next();
+			Properties translatedStrings = (Properties) hostLocalizations.get(locale);
+
+			Enumeration propertyKeys = translatedStrings.propertyNames();
+			while (propertyKeys.hasMoreElements()) {
+				String nextKey = (String) propertyKeys.nextElement();
+				fragment.setProperty(locale.toString() + '.' + nextKey, translatedStrings.getProperty(nextKey));
 			}
+			providedCapabilities.add(makeTranslationCapability(hostId, locale));
 		}
-		// TODO: do we need any capabilities? It's just a tag indicating a localization fragment.
-		// Create set of provided capabilities
-		ArrayList providedCapabilities = new ArrayList(1);
-		providedCapabilities.add(MANIFEST_LOCALIZATION_CAPABILITY);
 		fragment.setCapabilities((ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]));
 
 		return MetadataFactory.createInstallableUnitFragment(fragment);
@@ -375,14 +372,23 @@ public class MetadataGeneratorHelper {
 
 	/**
 	 * @param id
-	 * @param locale
-	 * @return the id for the fragment contain the localized properties
-	 * 		   for the manifest of the bundle with the given id
-	 * 		   in the given locale.
+	 * @return the id for the iu fragment containing the localized properties
+	 * 		   for the bundle with the given id
 	 */
-	private static String makeLocalizationFragmentId(String id, Locale locale) {
-		String localeString = (!DEFAULT_LOCALE.equals(locale) ? '_' + locale.toString() : ""); //$NON-NLS-1$
-		return id + "_manifest" + localeString + "_properties"; //$NON-NLS-1$ //$NON-NLS-2$
+	//	private static String makeBundleLocalizationFragmentId(String id) {
+	//		return id + ".translated_properties"; //$NON-NLS-1$
+	//	}
+	/**
+	 * @param id
+	 * @return the id for the iu fragment containing localized properties
+	 * 		   for the fragment with the given id.
+	 */
+	private static String makeHostLocalizationFragmentId(String id) {
+		return id + ".translated_host_properties"; //$NON-NLS-1$
+	}
+
+	private static ProvidedCapability makeTranslationCapability(String hostId, Locale locale) {
+		return MetadataFactory.createProvidedCapability(NAMESPACE_IU_LOCALIZATION, locale.toString(), new Version(1, 0, 0));
 	}
 
 	/**
@@ -531,30 +537,12 @@ public class MetadataGeneratorHelper {
 	}
 
 	public static IInstallableUnit[] createEclipseIU(BundleDescription bd, Map manifest, boolean isFolderPlugin, IArtifactKey key, Properties extraProperties) {
-		ArrayList iusCreated = new ArrayList(4);
+		ArrayList iusCreated = new ArrayList(1);
 
 		IInstallableUnit iu = createBundleIU(bd, manifest, isFolderPlugin, key);
 		addExtraProperties(iu, extraProperties);
 		iusCreated.add(iu);
 
-		if (manifest != null) {
-			String bundleLocalization = null;
-			if (bd.getHost() == null) // not a fragment
-				bundleLocalization = (String) manifest.get(Constants.BUNDLE_LOCALIZATION);
-			if (bundleLocalization == null)
-				bundleLocalization = DEFAULT_BUNDLE_LOCALIZATION;
-
-			Map manifestLocalizations = getManifestLocalizations(manifest, new File(bd.getLocation()));
-
-			if (manifestLocalizations != null) {
-				List localizationFragments = createLocalizationFragmentsForBundle(bd, manifestLocalizations);
-				for (Iterator iter = localizationFragments.iterator(); iter.hasNext();) {
-					addExtraProperties((IInstallableUnit) iter.next(), extraProperties);
-				}
-				iusCreated.addAll(localizationFragments);
-			}
-		}
-
 		return (IInstallableUnit[]) (iusCreated.toArray(new IInstallableUnit[iusCreated.size()]));
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/IUPropertyUtils.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/IUPropertyUtils.java
index 3b9b87f..54387fe 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/IUPropertyUtils.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/provisional/p2/ui/query/IUPropertyUtils.java
@@ -20,6 +20,8 @@ import org.eclipse.equinox.internal.provisional.p2.query.Collector;
 
 public class IUPropertyUtils {
 
+	static final Locale DEFAULT_LOCALE = new Locale("df", "LT"); //$NON-NLS-1$//$NON-NLS-2$
+
 	public static String getIUProperty(IInstallableUnit iu, String propertyKey, Locale locale) {
 		String value = iu.getProperty(propertyKey);
 		if (value == null || value.length() <= 1 || value.charAt(0) != '%')
@@ -43,11 +45,15 @@ public class IUPropertyUtils {
 			}
 		}
 
+		String defaultKey = DEFAULT_LOCALE.toString() + '.' + actualKey;
+		String defaultValue = iu.getProperty(defaultKey);
+		if (defaultValue != null)
+			return defaultValue;
+
 		return value;
 	}
 
-	private static final String MANIFEST_NAME = "_manifest"; //$NON-NLS-1$
-	private static final String PROPERTIES_NAME = "_properties"; //$NON-NLS-1$
+	private static final String TRANSLATED_PROPERTIES_NAME = "_translated_properties"; //$NON-NLS-1$
 
 	/**
 	 */
@@ -57,14 +63,14 @@ public class IUPropertyUtils {
 		ArrayList result = new ArrayList(4);
 		int lastSeparator;
 		while (true) {
-			result.add(id + MANIFEST_NAME + '_' + nl + PROPERTIES_NAME);
+			result.add(id + '_' + nl + TRANSLATED_PROPERTIES_NAME);
 			lastSeparator = nl.lastIndexOf('_');
 			if (lastSeparator == -1)
 				break;
 			nl = nl.substring(0, lastSeparator);
 		}
-		//add the empty suffix last (most general)
-		result.add(id + MANIFEST_NAME + PROPERTIES_NAME);
+		// Add the empty suffix last (most general)
+		result.add(id + TRANSLATED_PROPERTIES_NAME);
 		return (String[]) result.toArray(new String[result.size()]);
 	}
 
commit daaba9ce474d341d7d04b3cee9d5dc35531e6838
Author: Pascal Rapicault <prapicau>
Date:   Fri May 9 01:28:57 2008 +0000

    Bug 222309 - Review of the metadata translation support

82	163	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
index 348d8ed..01762c6 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/MetadataGeneratorHelper.java
@@ -12,8 +12,6 @@
 package org.eclipse.equinox.internal.provisional.p2.metadata.generator;
 
 import java.io.*;
-import java.net.URL;
-import java.net.URLConnection;
 import java.util.*;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
@@ -22,6 +20,7 @@ import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
 import org.eclipse.equinox.internal.p2.metadata.ArtifactKey;
 import org.eclipse.equinox.internal.p2.metadata.InstallableUnit;
 import org.eclipse.equinox.internal.p2.metadata.generator.Activator;
+import org.eclipse.equinox.internal.p2.metadata.generator.LocalizationHelper;
 import org.eclipse.equinox.internal.p2.metadata.generator.features.SiteCategory;
 import org.eclipse.equinox.internal.provisional.frameworkadmin.BundleInfo;
 import org.eclipse.equinox.internal.provisional.p2.artifact.repository.ArtifactDescriptor;
@@ -112,7 +111,6 @@ public class MetadataGeneratorHelper {
 
 	static final String DEFAULT_BUNDLE_LOCALIZATION = "plugin"; //$NON-NLS-1$	
 	static final String PROPERTIES_FILE_EXTENSION = ".properties"; //$NON-NLS-1$
-	static final String MANIFEST_LOCALIZATIONS = "eclipse.p2.manifest.localizations"; //$NON-NLS-1$
 
 	static final String BUNDLE_ADVICE_FILE = "META-INF/p2.inf"; //$NON-NLS-1$
 	static final String ADVICE_INSTRUCTIONS_PREFIX = "instructions."; //$NON-NLS-1$
@@ -562,6 +560,13 @@ public class MetadataGeneratorHelper {
 		Version version = new Version(feature.getVersion());
 		iu.setVersion(version);
 		iu.setUpdateDescriptor(MetadataFactory.createUpdateDescriptor(id, new VersionRange(new Version(0, 0, 0), true, new Version(feature.getVersion()), false), IUpdateDescriptor.NORMAL, null));
+		iu.setProperty(IInstallableUnit.PROP_NAME, feature.getLabel());
+		if (feature.getDescription() != null)
+			iu.setProperty(IInstallableUnit.PROP_DESCRIPTION, feature.getDescription());
+		if (feature.getDescriptionURL() != null)
+			iu.setProperty(IInstallableUnit.PROP_DESCRIPTION_URL, feature.getDescriptionURL());
+		if (feature.getProviderName() != null)
+			iu.setProperty(IInstallableUnit.PROP_PROVIDER, feature.getProviderName());
 		if (feature.getLicense() != null)
 			iu.setLicense(new License(feature.getLicenseURL(), feature.getLicense()));
 		if (feature.getCopyright() != null)
@@ -585,7 +590,12 @@ public class MetadataGeneratorHelper {
 			iu.setProperty(ECLIPSE_INSTALL_HANDLER_PROP, installHandlerProperty);
 		}
 
-		iu.setCapabilities(new ProvidedCapability[] {createSelfCapability(id, version), FEATURE_CAPABILITY, MetadataFactory.createProvidedCapability(CAPABILITY_NS_UPDATE_FEATURE, feature.getId(), version)});
+		// Create set of provided capabilities
+		ArrayList providedCapabilities = new ArrayList();
+		providedCapabilities.add(createSelfCapability(id, version));
+		providedCapabilities.add(FEATURE_CAPABILITY);
+		providedCapabilities.add(MetadataFactory.createProvidedCapability(CAPABILITY_NS_UPDATE_FEATURE, feature.getId(), version));
+
 		iu.setArtifacts(new IArtifactKey[] {createFeatureArtifactKey(feature.getId(), version.toString())});
 
 		if (isExploded) {
@@ -596,6 +606,22 @@ public class MetadataGeneratorHelper {
 			iu.addTouchpointData(MetadataFactory.createTouchpointData(touchpointData));
 		}
 
+		Map localizations = feature.getLocalizations();
+		if (localizations != null) {
+			for (Iterator iter = localizations.keySet().iterator(); iter.hasNext();) {
+				Locale locale = (Locale) iter.next();
+				Properties translatedStrings = (Properties) localizations.get(locale);
+				Enumeration propertyKeys = translatedStrings.propertyNames();
+				while (propertyKeys.hasMoreElements()) {
+					String nextKey = (String) propertyKeys.nextElement();
+					iu.setProperty(locale.toString() + '.' + nextKey, translatedStrings.getProperty(nextKey));
+				}
+				providedCapabilities.add(makeTranslationCapability(id, locale));
+			}
+		}
+
+		iu.setCapabilities((ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]));
+
 		if (extraProperties != null) {
 			Enumeration e = extraProperties.propertyNames();
 			while (e.hasMoreElements()) {
@@ -624,6 +650,8 @@ public class MetadataGeneratorHelper {
 			iu.setProperty(IInstallableUnit.PROP_DESCRIPTION, feature.getDescription());
 		if (feature.getDescriptionURL() != null)
 			iu.setProperty(IInstallableUnit.PROP_DESCRIPTION_URL, feature.getDescriptionURL());
+		if (feature.getProviderName() != null)
+			iu.setProperty(IInstallableUnit.PROP_PROVIDER, feature.getProviderName());
 		if (feature.getLicense() != null)
 			iu.setLicense(new License(feature.getLicenseURL(), feature.getLicense()));
 		if (feature.getCopyright() != null)
@@ -643,7 +671,26 @@ public class MetadataGeneratorHelper {
 		// TODO: shouldn't the filter for the group be constructed from os, ws, arch, nl
 		// 		 of the feature?
 		// iu.setFilter(filter);
-		iu.setCapabilities(new ProvidedCapability[] {createSelfCapability(id, version)});
+
+		// Create set of provided capabilities
+		ArrayList providedCapabilities = new ArrayList();
+		providedCapabilities.add(createSelfCapability(id, version));
+
+		Map localizations = feature.getLocalizations();
+		if (localizations != null) {
+			for (Iterator iter = localizations.keySet().iterator(); iter.hasNext();) {
+				Locale locale = (Locale) iter.next();
+				Properties translatedStrings = (Properties) localizations.get(locale);
+				Enumeration propertyKeys = translatedStrings.propertyNames();
+				while (propertyKeys.hasMoreElements()) {
+					String nextKey = (String) propertyKeys.nextElement();
+					iu.setProperty(locale.toString() + '.' + nextKey, translatedStrings.getProperty(nextKey));
+				}
+				providedCapabilities.add(makeTranslationCapability(id, locale));
+			}
+		}
+
+		iu.setCapabilities((ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]));
 
 		if (extraProperties != null) {
 			Enumeration e = extraProperties.propertyNames();
@@ -667,6 +714,8 @@ public class MetadataGeneratorHelper {
 			iu.setProperty(IInstallableUnit.PROP_DESCRIPTION, feature.getDescription());
 		if (feature.getDescriptionURL() != null)
 			iu.setProperty(IInstallableUnit.PROP_DESCRIPTION_URL, feature.getDescriptionURL());
+		if (feature.getProviderName() != null)
+			iu.setProperty(IInstallableUnit.PROP_PROVIDER, feature.getProviderName());
 		if (feature.getLicense() != null)
 			iu.setLicense(new License(feature.getLicenseURL(), feature.getLicense()));
 		if (feature.getCopyright() != null)
@@ -711,7 +760,26 @@ public class MetadataGeneratorHelper {
 		// TODO: shouldn't the filter for the group be constructed from os, ws, arch, nl
 		// 		 of the feature?
 		// iu.setFilter(filter);
-		iu.setCapabilities(new ProvidedCapability[] {createSelfCapability(id, version)});
+		
+		// Create set of provided capabilities
+		ArrayList providedCapabilities = new ArrayList();
+		providedCapabilities.add(createSelfCapability(id, version));
+
+		Map localizations = feature.getLocalizations();
+		if (localizations != null) {
+			for (Iterator iter = localizations.keySet().iterator(); iter.hasNext();) {
+				Locale locale = (Locale) iter.next();
+				Properties translatedStrings = (Properties) localizations.get(locale);
+				Enumeration propertyKeys = translatedStrings.propertyNames();
+				while (propertyKeys.hasMoreElements()) {
+					String nextKey = (String) propertyKeys.nextElement();
+					iu.setProperty(locale.toString() + '.' + nextKey, translatedStrings.getProperty(nextKey));
+				}
+				providedCapabilities.add(makeTranslationCapability(id, locale));
+			}
+		}
+
+		iu.setCapabilities((ProvidedCapability[]) providedCapabilities.toArray(new ProvidedCapability[providedCapabilities.size()]));
 
 		if (extraProperties != null) {
 			Enumeration e = extraProperties.propertyNames();
@@ -1098,9 +1166,11 @@ public class MetadataGeneratorHelper {
 
 		if ("jar".equalsIgnoreCase(new Path(bundleLocation.getName()).getFileExtension()) && //$NON-NLS-1$
 				bundleLocation.isFile()) {
-			localizations = getJarManifestLocalization(bundleLocation, bundleLocalization, defaultLocale, bundleManifestValues);
+			localizations = LocalizationHelper.getJarPropertyLocalizations(bundleLocation, bundleLocalization, defaultLocale, bundleManifestValues);
+			//localizations = getJarManifestLocalization(bundleLocation, bundleLocalization, defaultLocale, bundleManifestValues);
 		} else {
-			localizations = getDirManifestLocalization(bundleLocation, bundleLocalization, defaultLocale, bundleManifestValues);
+			localizations = LocalizationHelper.getDirPropertyLocalizations(bundleLocation, bundleLocalization, defaultLocale, bundleManifestValues);
+			// localizations = getDirManifestLocalization(bundleLocation, bundleLocalization, defaultLocale, bundleManifestValues);
 		}
 
 		return localizations;
@@ -1129,165 +1199,14 @@ public class MetadataGeneratorHelper {
 
 		if ("jar".equalsIgnoreCase(new Path(bundleLocation.getName()).getFileExtension()) && //$NON-NLS-1$
 				bundleLocation.isFile()) {
-			localizations = getJarManifestLocalization(bundleLocation, hostBundleLocalization, defaultLocale, hostBundleManifestValues);
+			localizations = LocalizationHelper.getJarPropertyLocalizations(bundleLocation, hostBundleLocalization, defaultLocale, hostBundleManifestValues);
+			//localizations = getJarManifestLocalization(bundleLocation, hostBundleLocalization, defaultLocale, hostBundleManifestValues);
 		} else {
-			localizations = getDirManifestLocalization(bundleLocation, hostBundleLocalization, defaultLocale, hostBundleManifestValues);
+			localizations = LocalizationHelper.getDirPropertyLocalizations(bundleLocation, hostBundleLocalization, defaultLocale, hostBundleManifestValues);
+			// localizations = getDirManifestLocalization(bundleLocation, hostBundleLocalization, defaultLocale, hostBundleManifestValues);
 		}
 
 		return localizations;
 	}
 
-	private static Map getJarManifestLocalization(File bundleLocation, String bundleLocalization, Locale defaultLocale, String[] bundleManifestValues) {
-		ZipFile jarFile = null;
-		Map localizations = new HashMap(4);
-		try {
-			jarFile = new ZipFile(bundleLocation, ZipFile.OPEN_READ);
-			for (Enumeration entries = jarFile.entries(); entries.hasMoreElements();) {
-				ZipEntry nextEntry = (ZipEntry) entries.nextElement();
-				String nextName = nextEntry.getName();
-				String localeString = getLocaleString(nextName, bundleLocalization);
-
-				if (!nextEntry.isDirectory() && localeString != null) {
-					Locale nextLocale = getLocale(localeString);
-					InputStream stream = null;
-					try {
-						stream = jarFile.getInputStream(nextEntry);
-						Properties properties = new Properties();
-						properties.load(stream);
-						Properties localizedStrings = getLocalizedProperties(bundleManifestValues, properties);
-						if (localizedStrings.size() > 0) {
-							localizations.put(nextLocale, localizedStrings);
-							if (DEFAULT_LOCALE.equals(nextLocale) && defaultLocale != null) {
-								localizations.put(nextLocale, localizedStrings);
-							}
-						}
-					} finally {
-						if (stream != null)
-							stream.close();
-					}
-				}
-			}
-		} catch (IOException ioe) {
-			ioe.printStackTrace();
-		} finally {
-			if (jarFile != null) {
-				try {
-					jarFile.close();
-				} catch (IOException ioe) {
-					// do nothing
-				}
-			}
-		}
-
-		return localizations;
-	}
-
-	private static Map getDirManifestLocalization(File bundleLocation, String bundleLocalization, Locale defaultLocale, String[] hostBundleManifestValues) {
-		File localizationPath = new File(bundleLocation, bundleLocalization);
-		File localizationDir = localizationPath.getParentFile();
-		final String localizationFile = localizationPath.getName();
-		MetadataGeneratorHelper foo = new MetadataGeneratorHelper();
-		String[] localizationFiles = localizationDir.list(foo.new LocalizationFileFilter() {
-			public boolean accept(File directory, String filename) {
-				return (getLocaleString(filename, localizationFile) != null ? true : false);
-			}
-		});
-
-		HashMap localizations = null;
-
-		if (localizationFiles != null) {
-			localizations = new HashMap(localizationFiles.length);
-			for (int i = 0; i < localizationFiles.length; i++) {
-				String nextFile = localizationFiles[i];
-				Locale nextLocale = getLocale(getLocaleString(nextFile, localizationFile));
-
-				try {
-					Properties properties = loadProperties(bundleLocation, nextFile);
-					Properties localizedStrings = getLocalizedProperties(hostBundleManifestValues, properties);
-					if (localizedStrings.size() > 0) {
-						localizations.put(nextLocale, localizedStrings);
-						if (DEFAULT_LOCALE.equals(nextLocale) && defaultLocale != null) {
-							localizations.put(nextLocale, localizedStrings);
-						}
-					}
-				} catch (IOException ioe) {
-					ioe.printStackTrace();
-				}
-			}
-		}
-
-		return localizations;
-	}
-
-	private abstract class LocalizationFileFilter implements FilenameFilter {
-
-		public LocalizationFileFilter() {
-			// Nothing to do
-		}
-
-		/* (non-Javadoc)
-		 * @see java.io.FilenameFilter#accept(java.io.File, java.lang.String)
-		 */
-		public abstract boolean accept(File directory, String filename);
-	}
-
-	static public String getLocaleString(String filename, String filenamePrefix) {
-		String localeString = null;
-		if (filename.startsWith(filenamePrefix) && filename.endsWith(PROPERTIES_FILE_EXTENSION)) {
-			if (filename.length() > filenamePrefix.length() + PROPERTIES_FILE_EXTENSION.length()) {
-				localeString = filename.substring(filenamePrefix.length() + 1, filename.length() - PROPERTIES_FILE_EXTENSION.length());
-			} else {
-				localeString = ""; //$NON-NLS-1$
-			}
-		}
-		return localeString;
-	}
-
-	private static Properties loadProperties(File bundleLocation, String localizationFile) throws IOException {
-		Properties result = new Properties();
-		InputStream propertyStream = null;
-		try {
-			try {
-				if (bundleLocation.isDirectory())
-					propertyStream = new FileInputStream(new File(bundleLocation, localizationFile));
-				else {
-					URLConnection connection = new URL("jar:" + bundleLocation.toURL().toExternalForm() + "!/" + localizationFile).openConnection(); //$NON-NLS-1$ //$NON-NLS-2$
-					connection.setUseCaches(false);
-					propertyStream = connection.getInputStream();
-				}
-			} catch (FileNotFoundException e) {
-				// if there is no messages file then just return;
-				return result;
-			}
-			result.load(propertyStream);
-		} finally {
-			if (propertyStream != null)
-				propertyStream.close();
-		}
-		return result;
-	}
-
-	static private Locale getLocale(String localeString) {
-		Locale locale = DEFAULT_LOCALE;
-		if (localeString.length() == 5 && localeString.indexOf('_') == 2) {
-			locale = new Locale(localeString.substring(0, 2), localeString.substring(3, 5));
-		} else if (localeString.length() == 2) {
-			locale = new Locale(localeString.substring(0, 2));
-		}
-		return locale;
-	}
-
-	static private Properties getLocalizedProperties(String[] bundleManifestKeys, Properties properties) {
-		Properties localizedProperties = new Properties();
-		for (int i = 0; i < BUNDLE_LOCALIZED_PROPERTIES.length; i++) {
-			String key = bundleManifestKeys[i];
-			if (key != null) {
-				String localizedValue = properties.getProperty(key);
-				if (localizedValue != null)
-					localizedProperties.put(key, localizedValue);
-			}
-		}
-		return localizedProperties;
-	}
-
 }
commit 5394393c112252b367582da12817e18b3b272dfc
Author: Pascal Rapicault <prapicau>
Date:   Fri May 9 01:37:01 2008 +0000

    Bug 222309 - Review of the metadata translation support

200	0	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/LocalizationHelper.java
30	19	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/features/FeatureParser.java
15	3	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/Feature.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/LocalizationHelper.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/LocalizationHelper.java
new file mode 100644
index 0000000..deeae27
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/LocalizationHelper.java
@@ -0,0 +1,200 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.metadata.generator;
+
+import java.io.*;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.*;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+/**
+ * 	Helper functions supporting the processing of localized
+ * 	property files.
+ *
+ */
+public final class LocalizationHelper {
+
+	private static final String PROPERTIES_FILE_EXTENSION = ".properties"; //$NON-NLS-1$
+	private static final Locale DEFAULT_LOCALE = new Locale("df", "LT"); //$NON-NLS-1$//$NON-NLS-2$
+	private static LocalizationHelper instance = new LocalizationHelper();
+
+	// Extract the locale string from the properties file with the given filename
+	// where the locale string follows the given prefix. For example, return "zh_HK"
+	// from filename == "plugin_zh_HK.properties" and prefix == "plugin". 
+	static public String getLocaleString(String filename, String prefix) {
+		String localeString = null;
+		if (filename.startsWith(prefix) && filename.endsWith(PROPERTIES_FILE_EXTENSION)) {
+			if (filename.length() > prefix.length() + PROPERTIES_FILE_EXTENSION.length()) {
+				localeString = filename.substring(prefix.length() + 1, filename.length() - PROPERTIES_FILE_EXTENSION.length());
+			} else {
+				localeString = ""; //$NON-NLS-1$
+			}
+		}
+		return localeString;
+	}
+
+	// Get the locale corresponding to the given locale string
+	static public Locale getLocale(String localeString) {
+		Locale locale = DEFAULT_LOCALE;
+		if (localeString.length() == 5 && localeString.indexOf('_') == 2) {
+			locale = new Locale(localeString.substring(0, 2), localeString.substring(3, 5));
+		} else if (localeString.length() == 2) {
+			locale = new Locale(localeString.substring(0, 2));
+		}
+		return locale;
+	}
+
+	// For the given root directory and path to localization files within that directory
+	// get a map from locale to property set for the localization property files.
+	public static Map getDirPropertyLocalizations(File root, String localizationPath, Locale defaultLocale, String[] propertyKeys) {
+		File fullPath = new File(root, localizationPath);
+		File localizationDir = fullPath.getParentFile();
+		final String localizationFile = fullPath.getName();
+		String[] localizationFiles = LocalizationHelper.getLocalizationFiles(localizationDir, localizationFile);
+
+		HashMap localizations = null;
+
+		if (localizationFiles != null) {
+			localizations = new HashMap(localizationFiles.length);
+			for (int i = 0; i < localizationFiles.length; i++) {
+				String nextFile = localizationFiles[i];
+				Locale nextLocale = getLocale(LocalizationHelper.getLocaleString(nextFile, localizationFile));
+
+				try {
+					Properties properties = loadProperties(root, nextFile);
+					Properties localizedStrings = getLocalizedProperties(propertyKeys, properties);
+					if (localizedStrings.size() > 0) {
+						localizations.put(nextLocale, localizedStrings);
+						if (DEFAULT_LOCALE.equals(nextLocale) && defaultLocale != null) {
+							localizations.put(nextLocale, localizedStrings);
+						}
+					}
+				} catch (IOException ioe) {
+					ioe.printStackTrace();
+				}
+			}
+		}
+
+		return localizations;
+	}
+
+	public static Map getJarPropertyLocalizations(File root, String localizationPath, Locale defaultLocale, String[] propertyKeys) {
+		ZipFile jarFile = null;
+		Map localizations = new HashMap(4);
+		try {
+			jarFile = new ZipFile(root, ZipFile.OPEN_READ);
+			for (Enumeration entries = jarFile.entries(); entries.hasMoreElements();) {
+				ZipEntry nextEntry = (ZipEntry) entries.nextElement();
+				String nextName = nextEntry.getName();
+				String localeString = LocalizationHelper.getLocaleString(nextName, localizationPath);
+
+				if (!nextEntry.isDirectory() && localeString != null) {
+					Locale nextLocale = LocalizationHelper.getLocale(localeString);
+					InputStream stream = null;
+					try {
+						stream = jarFile.getInputStream(nextEntry);
+						Properties properties = new Properties();
+						properties.load(stream);
+						Properties localizedStrings = LocalizationHelper.getLocalizedProperties(propertyKeys, properties);
+						if (localizedStrings.size() > 0) {
+							localizations.put(nextLocale, localizedStrings);
+							if (DEFAULT_LOCALE.equals(nextLocale) && defaultLocale != null) {
+								localizations.put(nextLocale, localizedStrings);
+							}
+						}
+					} finally {
+						if (stream != null)
+							stream.close();
+					}
+				}
+			}
+		} catch (IOException ioe) {
+			ioe.printStackTrace();
+		} finally {
+			if (jarFile != null) {
+				try {
+					jarFile.close();
+				} catch (IOException ioe) {
+					// do nothing
+				}
+			}
+		}
+
+		return localizations;
+	}
+
+	// Load a property set from given root and file with the given name
+	private static Properties loadProperties(File root, String propertyFilename) throws IOException {
+		Properties result = new Properties();
+		InputStream propertyStream = null;
+		try {
+			try {
+				if (root.isDirectory())
+					propertyStream = new FileInputStream(new File(root, propertyFilename));
+				else {
+					URLConnection connection = new URL("jar:" + root.toURL().toExternalForm() + "!/" + propertyFilename).openConnection(); //$NON-NLS-1$ //$NON-NLS-2$
+					connection.setUseCaches(false);
+					propertyStream = connection.getInputStream();
+				}
+			} catch (FileNotFoundException e) {
+				// if there is no messages file then just return;
+				return result;
+			}
+			result.load(propertyStream);
+		} finally {
+			if (propertyStream != null)
+				propertyStream.close();
+		}
+		return result;
+	}
+
+	// Given a list of keys and the corresponding localized property set,
+	// return a new property set with those keys and the localized values. 
+	static public Properties getLocalizedProperties(String[] propertyKeys, Properties properties) {
+		Properties localizedProperties = new Properties();
+		for (int i = 0; i < propertyKeys.length; i++) {
+			String key = propertyKeys[i];
+			if (key != null) {
+				String localizedValue = properties.getProperty(key);
+				if (localizedValue != null)
+					localizedProperties.put(key, localizedValue);
+			}
+		}
+		return localizedProperties;
+	}
+
+	public static String[] getLocalizationFiles(File localizationDir, final String filenamePrefix) {
+		return localizationDir.list(instance.new FileFilter() {
+			public boolean accept(File directory, String filename) {
+				return (getLocaleString(filename, filenamePrefix) != null ? true : false);
+			}
+		});
+	}
+
+	private abstract class FileFilter implements FilenameFilter {
+
+		public FileFilter() {
+			// Nothing to do
+		}
+
+		/* (non-Javadoc)
+		 * @see java.io.FilenameFilter#accept(java.io.File, java.lang.String)
+		 */
+		public abstract boolean accept(File directory, String filename);
+	}
+
+	private LocalizationHelper() {
+		//
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/features/FeatureParser.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/features/FeatureParser.java
index 999603d..0ee9a23 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/features/FeatureParser.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/features/FeatureParser.java
@@ -12,7 +12,7 @@ package org.eclipse.equinox.internal.p2.metadata.generator.features;
 
 import java.io.*;
 import java.net.URL;
-import java.util.Properties;
+import java.util.*;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import javax.xml.parsers.*;
@@ -20,6 +20,7 @@ import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Status;
 import org.eclipse.equinox.internal.p2.core.helpers.LogHelper;
 import org.eclipse.equinox.internal.p2.metadata.generator.Activator;
+import org.eclipse.equinox.internal.p2.metadata.generator.LocalizationHelper;
 import org.eclipse.equinox.internal.provisional.p2.metadata.generator.Feature;
 import org.eclipse.equinox.internal.provisional.p2.metadata.generator.FeatureEntry;
 import org.eclipse.osgi.util.NLS;
@@ -41,6 +42,7 @@ public class FeatureParser extends DefaultHandler {
 	private StringBuffer characters = null;
 
 	private Properties messages = null;
+	private List messageKeys = null;
 
 	public FeatureParser() {
 		this(true);
@@ -87,17 +89,15 @@ public class FeatureParser extends DefaultHandler {
 		return result;
 	}
 
-	private Properties loadProperties(File directory) {
+	private void loadProperties(File directory, Properties properties) {
 		//skip directories that don't contain a feature.properties file
 		File file = new File(directory, "feature.properties"); //$NON-NLS-1$
 		if (!file.exists())
-			return null;
+			return;
 		try {
 			InputStream input = new BufferedInputStream(new FileInputStream(file));
 			try {
-				Properties result = new Properties();
-				result.load(input);
-				return result;
+				properties.load(input);
 			} finally {
 				if (input != null)
 					input.close();
@@ -105,19 +105,16 @@ public class FeatureParser extends DefaultHandler {
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
-		return null;
 	}
 
-	private Properties loadProperties(JarFile jar) {
+	private void loadProperties(JarFile jar, Properties properties) {
 		JarEntry entry = jar.getJarEntry("feature.properties"); //$NON-NLS-1$
 		if (entry == null)
-			return null;
+			return;
 		try {
 			InputStream input = new BufferedInputStream(jar.getInputStream(entry));
 			try {
-				Properties result = new Properties();
-				result.load(input);
-				return result;
+				properties.load(input);
 			} finally {
 				if (input != null)
 					input.close();
@@ -125,7 +122,6 @@ public class FeatureParser extends DefaultHandler {
 		} catch (IOException e) {
 			e.printStackTrace();
 		}
-		return null;
 	}
 
 	private String localize(String value) {
@@ -133,7 +129,9 @@ public class FeatureParser extends DefaultHandler {
 			return value;
 		if (!value.startsWith("%")) //$NON-NLS-1$
 			return value;
-		return messages.getProperty(value.substring(1), value);
+		String key = value.substring(1);
+		messageKeys.add(key);
+		return value;
 	}
 
 	/**
@@ -146,15 +144,23 @@ public class FeatureParser extends DefaultHandler {
 	public Feature parse(File location) {
 		if (!location.exists())
 			return null;
+
+		Feature feature = null;
+		Properties properties = new Properties();
+
 		if (location.isDirectory()) {
 			//skip directories that don't contain a feature.xml file
 			File file = new File(location, "feature.xml"); //$NON-NLS-1$
 			if (!file.exists())
 				return null;
-			Properties properties = loadProperties(location);
+			loadProperties(location, properties);
 			try {
 				InputStream input = new BufferedInputStream(new FileInputStream(file));
-				return parse(input, properties);
+				feature = parse(input, properties);
+				if (feature != null) {
+					String[] keyStrings = (String[]) messageKeys.toArray(new String[messageKeys.size()]);
+					feature.setLocalizations(LocalizationHelper.getDirPropertyLocalizations(location, "feature", null, keyStrings)); //$NON-NLS-1$
+				}
 			} catch (FileNotFoundException e) {
 				e.printStackTrace();
 			}
@@ -162,12 +168,16 @@ public class FeatureParser extends DefaultHandler {
 			JarFile jar = null;
 			try {
 				jar = new JarFile(location);
-				Properties properties = loadProperties(jar);
+				loadProperties(jar, properties);
 				JarEntry entry = jar.getJarEntry("feature.xml"); //$NON-NLS-1$
 				if (entry == null)
 					return null;
 				InputStream input = new BufferedInputStream(jar.getInputStream(entry));
-				return parse(input, properties);
+				feature = parse(input, properties);
+				if (feature != null) {
+					String[] keyStrings = (String[]) messageKeys.toArray(new String[messageKeys.size()]);
+					feature.setLocalizations(LocalizationHelper.getDirPropertyLocalizations(location, "feature", null, keyStrings)); //$NON-NLS-1$
+				}
 			} catch (IOException e) {
 				e.printStackTrace();
 			} catch (SecurityException e) {
@@ -181,7 +191,7 @@ public class FeatureParser extends DefaultHandler {
 				}
 			}
 		}
-		return null;
+		return feature;
 	}
 
 	/**
@@ -190,6 +200,7 @@ public class FeatureParser extends DefaultHandler {
 	 */
 	public Feature parse(InputStream in, Properties messages) {
 		this.messages = messages;
+		this.messageKeys = new ArrayList(messages.size());
 		result = null;
 		try {
 			parser.parse(new InputSource(in), this);
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/Feature.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/Feature.java
index b999d23..3db144d 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/Feature.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/provisional/p2/metadata/generator/Feature.java
@@ -11,6 +11,7 @@
 package org.eclipse.equinox.internal.provisional.p2.metadata.generator;
 
 import java.util.ArrayList;
+import java.util.Map;
 
 /**
  * 
@@ -43,6 +44,8 @@ public class Feature {
 
 	private String location;
 
+	private Map localizations;
+
 	public Feature(String id, String version) {
 		if (id == null)
 			throw new IllegalArgumentException();
@@ -50,14 +53,14 @@ public class Feature {
 		this.version = version;
 	}
 
-	public void addDiscoverySite(String label, String url) {
-		if (label == null && url == null)
+	public void addDiscoverySite(String siteLabel, String url) {
+		if (siteLabel == null && url == null)
 			return;
 
 		if (this.discoverySites == null)
 			this.discoverySites = new ArrayList();
 
-		URLEntry entry = new URLEntry(url, label);
+		URLEntry entry = new URLEntry(url, siteLabel);
 		this.discoverySites.add(entry);
 	}
 
@@ -143,6 +146,10 @@ public class Feature {
 		return null;
 	}
 
+	public Map getLocalizations() {
+		return this.localizations;
+	}
+
 	public String getLocation() {
 		return this.location;
 	}
@@ -242,6 +249,10 @@ public class Feature {
 		this.license.setURL(licenseURL);
 	}
 
+	public void setLocalizations(Map localizations) {
+		this.localizations = localizations;
+	}
+
 	public void setLocation(String location) {
 		this.location = location;
 	}
@@ -263,6 +274,7 @@ public class Feature {
 	}
 
 	public void setURL(String value) {
+		//
 	}
 
 	public void setVersion(String version) {
commit 10af984a6d6e9aa9025822dff8e7ba68209aed42
Author: Pascal Rapicault <prapicau>
Date:   Wed May 14 19:31:28 2008 +0000

    Bug 222309 - Fix copy/paste error

1	1	bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/features/FeatureParser.java
diff --git a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/features/FeatureParser.java b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/features/FeatureParser.java
index e8475ef..5cbe1a3 100644
--- a/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/features/FeatureParser.java
+++ b/bundles/org.eclipse.equinox.p2.metadata.generator/src/org/eclipse/equinox/internal/p2/metadata/generator/features/FeatureParser.java
@@ -176,7 +176,7 @@ public class FeatureParser extends DefaultHandler {
 				feature = parse(input, properties);
 				if (feature != null) {
 					String[] keyStrings = (String[]) messageKeys.toArray(new String[messageKeys.size()]);
-					feature.setLocalizations(LocalizationHelper.getDirPropertyLocalizations(location, "feature", null, keyStrings)); //$NON-NLS-1$
+					feature.setLocalizations(LocalizationHelper.getJarPropertyLocalizations(location, "feature", null, keyStrings)); //$NON-NLS-1$
 				}
 			} catch (IOException e) {
 				e.printStackTrace();
