commit a18ba6aadc9df69a0ad14f4cfb15e140212f123a
Author: Susan Franklin <sfranklin>
Date:   Thu Nov 13 17:33:39 2008 +0000

    Bug 227582 - [ui] Should the early startup extension be separated from the rest of the UI plugin?

7	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.classpath
1	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.cvsignore
28	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.project
35	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/META-INF/MANIFEST.MF
28	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/about.html
17	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/build.properties
20	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.properties
29	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.xml
79	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateAction.java
84	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateMessages.java
94	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
253	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
422	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdater.java
294	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPopup.java
301	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPreferencePage.java
51	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/ClassicUpdateInitializer.java
26	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/IAutomaticUpdaterHelpContextIds.java
26	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceConstants.java
34	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
133	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/StatusLineCLabelContribution.java
69	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/messages.properties
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.classpath b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.classpath
new file mode 100644
index 0000000..ce73933
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.classpath
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.4"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.cvsignore b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.cvsignore
new file mode 100644
index 0000000..c5e82d7
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.cvsignore
@@ -0,0 +1 @@
+bin
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.project b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.project
new file mode 100644
index 0000000..fe1fe0f
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/.project
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.eclipse.equinox.p2.ui.sdk.scheduler</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/META-INF/MANIFEST.MF
new file mode 100644
index 0000000..51a523a
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/META-INF/MANIFEST.MF
@@ -0,0 +1,35 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: %bundleName
+Bundle-Vendor: %providerName
+Bundle-Localization: plugin
+Bundle-SymbolicName: org.eclipse.equinox.p2.ui.sdk.scheduler;singleton:=true
+Bundle-Version: 1.0.0.qualifier
+Bundle-Activator: org.eclipse.equinox.internal.p2.ui.sdk.scheduler.AutomaticUpdatePlugin
+Import-Package: org.eclipse.equinox.internal.p2.core.helpers,
+ org.eclipse.equinox.internal.p2.ui.query,
+ org.eclipse.equinox.internal.provisional.p2.core,
+ org.eclipse.equinox.internal.provisional.p2.core.eventbus,
+ org.eclipse.equinox.internal.provisional.p2.core.repository,
+ org.eclipse.equinox.internal.provisional.p2.director,
+ org.eclipse.equinox.internal.provisional.p2.engine,
+ org.eclipse.equinox.internal.provisional.p2.metadata,
+ org.eclipse.equinox.internal.provisional.p2.metadata.query,
+ org.eclipse.equinox.internal.provisional.p2.metadata.repository,
+ org.eclipse.equinox.internal.provisional.p2.query,
+ org.eclipse.equinox.internal.provisional.p2.ui,
+ org.eclipse.equinox.internal.provisional.p2.ui.actions,
+ org.eclipse.equinox.internal.provisional.p2.ui.model,
+ org.eclipse.equinox.internal.provisional.p2.ui.operations,
+ org.eclipse.equinox.internal.provisional.p2.ui.policy,
+ org.eclipse.equinox.internal.provisional.p2.updatechecker,
+ org.eclipse.osgi.service.resolver;version="1.1.0",
+ org.eclipse.osgi.util;version="1.1.0",
+ org.osgi.framework;version="1.3.0",
+ org.osgi.service.packageadmin;version="1.2.0"
+Export-Package: org.eclipse.equinox.internal.p2.ui.sdk.scheduler;x-internal:=true
+Require-Bundle: org.eclipse.ui,
+ org.eclipse.core.runtime
+Eclipse-LazyStart: true
+Bundle-RequiredExecutionEnvironment: J2SE-1.4,
+ CDC-1.1/Foundation-1.1
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/about.html b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/about.html
new file mode 100644
index 0000000..4602330
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/about.html
@@ -0,0 +1,28 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
+<title>About</title>
+</head>
+<body lang="EN-US">
+<h2>About This Content</h2>
+ 
+<p>June 2, 2006</p>	
+<h3>License</h3>
+
+<p>The Eclipse Foundation makes available all content in this plug-in (&quot;Content&quot;).  Unless otherwise 
+indicated below, the Content is provided to you under the terms and conditions of the
+Eclipse Public License Version 1.0 (&quot;EPL&quot;).  A copy of the EPL is available 
+at <a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>.
+For purposes of the EPL, &quot;Program&quot; will mean the Content.</p>
+
+<p>If you did not receive this Content directly from the Eclipse Foundation, the Content is 
+being redistributed by another party (&quot;Redistributor&quot;) and different terms and conditions may
+apply to your use of any object code in the Content.  Check the Redistributor's license that was 
+provided with the Content.  If no such license exists, contact the Redistributor.  Unless otherwise
+indicated below, the terms and conditions of the EPL still apply to any source code in the Content
+and such source code may be obtained at <a href="http://www.eclipse.org">http://www.eclipse.org</a>.</p>
+
+</body>
+</html>
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/build.properties b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/build.properties
new file mode 100644
index 0000000..2d0f953
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/build.properties
@@ -0,0 +1,17 @@
+###############################################################################
+# Copyright (c) 2007 IBM Corporation and others.
+# All rights reserved. This program and the accompanying materials
+# are made available under the terms of the Eclipse Public License v1.0
+# which accompanies this distribution, and is available at
+# http://www.eclipse.org/legal/epl-v10.html
+#
+# Contributors:
+#     IBM Corporation - initial API and implementation
+###############################################################################
+bin.includes = plugin.properties,\
+               .,\
+               about.html,\
+               META-INF/,\
+               plugin.xml
+src.includes = about.html
+source.. = src/
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.properties b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.properties
new file mode 100644
index 0000000..8b8378d
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.properties
@@ -0,0 +1,20 @@
+###############################################################################
+# Copyright (c) 2007, 2008 IBM Corporation and others.
+# All rights reserved. This program and the accompanying materials
+# are made available under the terms of the Eclipse Public License v1.0
+# which accompanies this distribution, and is available at
+# http://www.eclipse.org/legal/epl-v10.html
+#
+# Contributors:
+#     IBM Corporation - initial API and implementation
+###############################################################################
+#
+# Provisioning Automatic Update plugin resources
+#
+providerName=Eclipse.org
+bundleName=Equinox Provisioning Platform Automatic Update Support
+IU.general=General Information
+IU.license=License Agreement
+IU.copyright=Copyright
+automaticUpdatesPrefPage = Automatic Updates
+preferenceKeywords.general=automatic update schedule download software install import bundle
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.xml b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.xml
new file mode 100644
index 0000000..526296e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/plugin.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<?eclipse version="3.2"?>
+<plugin>
+   	<extension 
+   		id="preferences" point="org.eclipse.core.runtime.preferences" name="%preferences">
+		<initializer class="org.eclipse.equinox.internal.p2.ui.sdk.scheduler.PreferenceInitializer"/>
+	</extension>
+   <extension
+         point="org.eclipse.ui.startup">
+      <startup class="org.eclipse.equinox.internal.p2.ui.sdk.scheduler.AutomaticUpdateScheduler">
+      </startup>
+   </extension>
+  <extension
+         point="org.eclipse.core.runtime.preferences">
+      <initializer
+            class="org.eclipse.equinox.internal.p2.ui.sdk.scheduler.ClassicUpdateInitializer">
+      </initializer>
+   </extension>
+      <extension
+         point="org.eclipse.ui.preferencePages">
+          <page
+            name="%automaticUpdatesPrefPage"
+            category="org.eclipse.equinox.internal.p2.ui.sdk.ProvisioningPreferencePage"
+            class="org.eclipse.equinox.internal.p2.ui.sdk.scheduler.AutomaticUpdatesPreferencePage"
+            id="org.eclipse.equinox.internal.p2.ui.sdk.scheduler.AutomaticUpdatesPreferencePage">
+            <keywordReference id="org.eclipse.equinox.p2.ui.sdk.updates.general"/>
+      </page>
+   </extension>
+</plugin>
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateAction.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateAction.java
new file mode 100644
index 0000000..19918df
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateAction.java
@@ -0,0 +1,79 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.equinox.internal.provisional.p2.director.ProvisioningPlan;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.ui.actions.UpdateAction;
+import org.eclipse.equinox.internal.provisional.p2.ui.policy.PlanValidator;
+import org.eclipse.equinox.internal.provisional.p2.ui.policy.Policy;
+import org.eclipse.jface.viewers.ISelectionProvider;
+import org.eclipse.jface.window.Window;
+import org.eclipse.swt.widgets.Shell;
+
+/**
+ * Overridden so that we can use the profile change request computations,
+ * but we hide the resolution from the user and optionally suppress the
+ * wizard if we are resolving for reasons other than user request.
+ * 
+ * @since 3.5
+ *
+ */
+final class AutomaticUpdateAction extends UpdateAction {
+
+	/**
+	 * 
+	 */
+	final AutomaticUpdater automaticUpdater;
+	private boolean suppressWizard = false;
+
+	AutomaticUpdateAction(AutomaticUpdater automaticUpdater, ISelectionProvider selectionProvider, String profileId) {
+		super(Policy.getDefault(), selectionProvider, profileId, false);
+		this.automaticUpdater = automaticUpdater;
+	}
+
+	void suppressWizard(boolean suppress) {
+		suppressWizard = suppress;
+	}
+
+	protected int performAction(IInstallableUnit[] ius, String targetProfileId, ProvisioningPlan plan) {
+		if (suppressWizard) {
+			automaticUpdater.setUpdateAffordanceState(plan != null && plan.getStatus().isOK());
+			return Window.OK;
+		}
+		return super.performAction(ius, targetProfileId, plan);
+	}
+
+	protected PlanValidator getPlanValidator() {
+		return new PlanValidator() {
+			public boolean continueWorkingWithPlan(ProvisioningPlan plan, Shell shell) {
+				if (automaticUpdater.alreadyValidated)
+					return true;
+				// In all other cases we return false, because clicking the popup will actually run the action.
+				// We are just determining whether to show the popup or not.
+				if (plan != null) {
+					// If the user cancelled the operation, don't continue
+					if (plan.getStatus().getSeverity() == IStatus.CANCEL)
+						return false;
+					boolean noError = plan.getStatus().getSeverity() != IStatus.ERROR;
+					// Show the affordance regardless of the status since updates were found.
+					if (automaticUpdater.updateAffordance == null)
+						automaticUpdater.createUpdateAffordance();
+					automaticUpdater.setUpdateAffordanceState(noError);
+					if (noError && automaticUpdater.popup == null)
+						automaticUpdater.createUpdatePopup();
+				}
+				return false;
+			}
+		};
+	}
+}
\ No newline at end of file
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateMessages.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateMessages.java
new file mode 100644
index 0000000..d8d601b
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateMessages.java
@@ -0,0 +1,84 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+import org.eclipse.osgi.util.NLS;
+
+/**
+ * Message class for provisioning UI messages.  
+ * 
+ * @since 3.5
+ */
+public class AutomaticUpdateMessages extends NLS {
+	private static final String BUNDLE_NAME = "org.eclipse.equinox.internal.p2.ui.sdk.scheduler.messages"; //$NON-NLS-1$
+	static {
+		// load message values from bundle file
+		NLS.initializeMessages(BUNDLE_NAME, AutomaticUpdateMessages.class);
+	}
+	public static String SchedulerStartup_day;
+	public static String SchedulerStartup_Monday;
+	public static String SchedulerStartup_Tuesday;
+	public static String SchedulerStartup_Wednesday;
+	public static String SchedulerStartup_Thursday;
+	public static String SchedulerStartup_Friday;
+	public static String SchedulerStartup_Saturday;
+	public static String SchedulerStartup_Sunday;
+	public static String SchedulerStartup_1AM;
+	public static String SchedulerStartup_2AM;
+	public static String SchedulerStartup_3AM;
+	public static String SchedulerStartup_4AM;
+	public static String SchedulerStartup_5AM;
+	public static String SchedulerStartup_6AM;
+	public static String SchedulerStartup_7AM;
+	public static String SchedulerStartup_8AM;
+	public static String SchedulerStartup_9AM;
+	public static String SchedulerStartup_10AM;
+	public static String SchedulerStartup_11AM;
+	public static String SchedulerStartup_12PM;
+	public static String SchedulerStartup_1PM;
+	public static String SchedulerStartup_2PM;
+	public static String SchedulerStartup_3PM;
+	public static String SchedulerStartup_4PM;
+	public static String SchedulerStartup_5PM;
+	public static String SchedulerStartup_6PM;
+	public static String SchedulerStartup_7PM;
+	public static String SchedulerStartup_8PM;
+	public static String SchedulerStartup_9PM;
+	public static String SchedulerStartup_10PM;
+	public static String SchedulerStartup_11PM;
+	public static String SchedulerStartup_12AM;
+	public static String AutomaticUpdatesPopup_PrefLinkOnly;
+	public static String AutomaticUpdatesPopup_RemindAndPrefLink;
+	public static String AutomaticUpdatesPopup_ReminderJobTitle;
+	public static String AutomaticUpdatesPreferencePage_findUpdates;
+	public static String AutomaticUpdateScheduler_30Minutes;
+	public static String AutomaticUpdateScheduler_60Minutes;
+	public static String AutomaticUpdateScheduler_240Minutes;
+	public static String AutomaticUpdateScheduler_UpdateNotInitialized;
+	public static String AutomaticUpdatesPopup_UpdatesAvailableTitle;
+	public static String AutomaticUpdater_AutomaticDownloadOperationName;
+	public static String AutomaticUpdater_ClickToReviewUpdates;
+	public static String AutomaticUpdater_ClickToReviewUpdatesWithProblems;
+	public static String AutomaticUpdater_ErrorCheckingUpdates;
+	public static String AutomaticUpdatesPreferencePage_UpdateSchedule;
+	public static String AutomaticUpdatesPreferencePage_findOnStart;
+	public static String AutomaticUpdatesPreferencePage_findOnSchedule;
+	public static String AutomaticUpdatesPreferencePage_downloadOptions;
+	public static String AutomaticUpdatesPreferencePage_searchAndNotify;
+	public static String AutomaticUpdatesPreferencePage_downloadAndNotify;
+	public static String AutomaticUpdatesPreferencePage_at;
+	public static String AutomaticUpdatesPreferencePage_RemindGroup;
+	public static String AutomaticUpdatesPreferencePage_RemindSchedule;
+	public static String AutomaticUpdatesPreferencePage_RemindOnce;
+	public static String AutomaticUpdatesPopup_ClickToReviewDownloaded;
+	public static String AutomaticUpdatesPopup_ClickToReviewNotDownloaded;
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
new file mode 100644
index 0000000..c78d69f
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
@@ -0,0 +1,94 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
+import org.eclipse.ui.plugin.AbstractUIPlugin;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+
+/**
+ * Activator class for the automatic updates plugin
+ */
+public class AutomaticUpdatePlugin extends AbstractUIPlugin {
+
+	private static AutomaticUpdatePlugin plugin;
+	private static BundleContext context;
+	private AutomaticUpdateScheduler scheduler;
+	private AutomaticUpdater updater;
+
+	public static final String PLUGIN_ID = "org.eclipse.equinox.p2.ui.sdk.scheduler"; //$NON-NLS-1$
+
+	public static BundleContext getContext() {
+		return context;
+	}
+
+	/**
+	 * Returns the singleton plugin instance
+	 * 
+	 * @return the instance
+	 */
+	public static AutomaticUpdatePlugin getDefault() {
+		return plugin;
+	}
+
+	public AutomaticUpdatePlugin() {
+		// constructor
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.eclipse.ui.plugin.AbstractUIPlugin#start(org.osgi.framework.BundleContext)
+	 */
+	public void start(BundleContext bundleContext) throws Exception {
+		super.start(bundleContext);
+		plugin = this;
+		AutomaticUpdatePlugin.context = bundleContext;
+	}
+
+	public void stop(BundleContext bundleContext) throws Exception {
+		if (scheduler != null) {
+			scheduler.shutdown();
+			scheduler = null;
+		}
+		if (updater != null) {
+			updater.shutdown();
+			updater = null;
+		}
+		plugin = null;
+		super.stop(bundleContext);
+	}
+
+	public AutomaticUpdateScheduler getScheduler() {
+		// If the scheduler was disabled, it does not get initialized
+		if (scheduler == null)
+			scheduler = new AutomaticUpdateScheduler();
+		return scheduler;
+	}
+
+	public AutomaticUpdater getAutomaticUpdater() {
+		if (updater == null)
+			updater = new AutomaticUpdater();
+		return updater;
+	}
+
+	void setScheduler(AutomaticUpdateScheduler scheduler) {
+		this.scheduler = scheduler;
+	}
+
+	public IProvisioningEventBus getProvisioningEventBus() {
+		ServiceReference busReference = context.getServiceReference(IProvisioningEventBus.SERVICE_NAME);
+		if (busReference == null)
+			return null;
+		return (IProvisioningEventBus) context.getService(busReference);
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
new file mode 100644
index 0000000..77724bc
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
@@ -0,0 +1,253 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+import java.util.Calendar;
+import java.util.Iterator;
+import org.eclipse.core.runtime.*;
+import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
+import org.eclipse.equinox.internal.provisional.p2.engine.IProfile;
+import org.eclipse.equinox.internal.provisional.p2.engine.IProfileRegistry;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.query.IUPropertyQuery;
+import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import org.eclipse.equinox.internal.provisional.p2.query.Query;
+import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker;
+import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener;
+import org.eclipse.ui.IStartup;
+import org.eclipse.ui.statushandlers.StatusManager;
+
+/**
+ * This plug-in is loaded on startup to register with the update checker.
+ * 
+ * @since 3.5
+ */
+public class AutomaticUpdateScheduler implements IStartup {
+	// values are to be picked up from the arrays DAYS and HOURS
+	public static final String P_DAY = "day"; //$NON-NLS-1$
+
+	public static final String P_HOUR = "hour"; //$NON-NLS-1$
+
+	public static final String[] DAYS = {AutomaticUpdateMessages.SchedulerStartup_day, AutomaticUpdateMessages.SchedulerStartup_Monday, AutomaticUpdateMessages.SchedulerStartup_Tuesday, AutomaticUpdateMessages.SchedulerStartup_Wednesday, AutomaticUpdateMessages.SchedulerStartup_Thursday, AutomaticUpdateMessages.SchedulerStartup_Friday, AutomaticUpdateMessages.SchedulerStartup_Saturday, AutomaticUpdateMessages.SchedulerStartup_Sunday};
+
+	public static final String[] HOURS = {AutomaticUpdateMessages.SchedulerStartup_1AM, AutomaticUpdateMessages.SchedulerStartup_2AM, AutomaticUpdateMessages.SchedulerStartup_3AM, AutomaticUpdateMessages.SchedulerStartup_4AM, AutomaticUpdateMessages.SchedulerStartup_5AM, AutomaticUpdateMessages.SchedulerStartup_6AM, AutomaticUpdateMessages.SchedulerStartup_7AM, AutomaticUpdateMessages.SchedulerStartup_8AM, AutomaticUpdateMessages.SchedulerStartup_9AM, AutomaticUpdateMessages.SchedulerStartup_10AM, AutomaticUpdateMessages.SchedulerStartup_11AM, AutomaticUpdateMessages.SchedulerStartup_12PM, AutomaticUpdateMessages.SchedulerStartup_1PM, AutomaticUpdateMessages.SchedulerStartup_2PM, AutomaticUpdateMessages.SchedulerStartup_3PM, AutomaticUpdateMessages.SchedulerStartup_4PM,
+			AutomaticUpdateMessages.SchedulerStartup_5PM, AutomaticUpdateMessages.SchedulerStartup_6PM, AutomaticUpdateMessages.SchedulerStartup_7PM, AutomaticUpdateMessages.SchedulerStartup_8PM, AutomaticUpdateMessages.SchedulerStartup_9PM, AutomaticUpdateMessages.SchedulerStartup_10PM, AutomaticUpdateMessages.SchedulerStartup_11PM, AutomaticUpdateMessages.SchedulerStartup_12AM,};
+
+	private IUpdateListener listener = null;
+	private IUpdateChecker checker = null;
+	String profileId;
+
+	/**
+	 * A query that searches for {@link IInstallableUnit} instances that have
+	 * a property associated with the specified profile, whose value matches the provided value.
+	 * Uses the profile id instead of the profile to reference the profile.
+	 * The profile instance is cached only during the duration of the query.
+	 * This query is used instead of IUProfilePropertyQuery because we pass
+	 * this query to the automatic update checker and it will be referenced during
+	 * the life of the platform.  
+	 */
+	private class IUProfilePropertyByIdQuery extends IUPropertyQuery {
+		private IProfile cachedProfile;
+
+		/**
+		 * Creates a new query on the given property name and value.
+		 */
+		public IUProfilePropertyByIdQuery(String propertyName, String propertyValue) {
+			super(propertyName, propertyValue);
+		}
+
+		protected String getProperty(IInstallableUnit iu, String name) {
+			IProfile profile = getProfile();
+			if (profile == null)
+				return null;
+			return profile.getInstallableUnitProperty(iu, name);
+		}
+
+		private IProfile getProfile() {
+			if (cachedProfile == null) {
+				IProfileRegistry profileRegistry = (IProfileRegistry) ServiceHelper.getService(AutomaticUpdatePlugin.getContext(), IProfileRegistry.class.getName());
+				if (profileRegistry != null)
+					return profileRegistry.getProfile(profileId);
+			}
+			return cachedProfile;
+		}
+
+		public Collector perform(Iterator iterator, Collector result) {
+			Collector collector = super.perform(iterator, result);
+			cachedProfile = null;
+			return collector;
+		}
+	}
+
+	/**
+	 * The constructor.
+	 */
+	public AutomaticUpdateScheduler() {
+		AutomaticUpdatePlugin.getDefault().setScheduler(this);
+		checker = (IUpdateChecker) ServiceHelper.getService(AutomaticUpdatePlugin.getContext(), IUpdateChecker.SERVICE_NAME);
+		if (checker == null) {
+			// Something did not initialize properly
+			IStatus status = new Status(IStatus.ERROR, AutomaticUpdatePlugin.PLUGIN_ID, AutomaticUpdateMessages.AutomaticUpdateScheduler_UpdateNotInitialized);
+			StatusManager.getManager().handle(status, StatusManager.LOG);
+			return;
+		}
+		profileId = IProfileRegistry.SELF;
+	}
+
+	public void earlyStartup() {
+		scheduleUpdate();
+	}
+
+	public void shutdown() {
+		removeUpdateListener();
+	}
+
+	public void rescheduleUpdate() {
+		removeUpdateListener();
+		Preferences pref = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
+		String schedule = pref.getString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE);
+		// See if we have a scheduled check or startup only.  If it is
+		// startup only, there is nothing more to do now, a listener will
+		// be created on the next startup.
+		if (schedule.equals(PreferenceConstants.PREF_UPDATE_ON_STARTUP)) {
+			return;
+		}
+		scheduleUpdate();
+	}
+
+	private void scheduleUpdate() {
+		// Nothing to do if we don't know what profile we are checking
+		if (profileId == null)
+			return;
+		Preferences pref = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
+		// See if automatic search is enabled at all
+		if (pref.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED) == false)
+			return;
+		String schedule = pref.getString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE);
+		long delay = IUpdateChecker.ONE_TIME_CHECK;
+		long poll = IUpdateChecker.ONE_TIME_CHECK;
+		if (!schedule.equals(PreferenceConstants.PREF_UPDATE_ON_STARTUP)) {
+			delay = computeDelay(pref);
+			poll = computePoll(pref);
+		}
+		listener = AutomaticUpdatePlugin.getDefault().getAutomaticUpdater();
+		checker.addUpdateCheck(profileId, getProfileQuery(), delay, poll, listener);
+
+	}
+
+	private Query getProfileQuery() {
+		// We specifically avoid going through the default policy's query provider or
+		// through the sdk ui bundle, so that we don't load all the p2 UI classes in doing so.  
+		return new IUProfilePropertyByIdQuery(IInstallableUnit.PROP_PROFILE_ROOT_IU, Boolean.toString(true));
+	}
+
+	private int getDay(Preferences pref) {
+		String day = pref.getString(P_DAY);
+		for (int d = 0; d < DAYS.length; d++)
+			if (DAYS[d].equals(day))
+				switch (d) {
+					case 0 :
+						return -1;
+					case 1 :
+						return Calendar.MONDAY;
+					case 2 :
+						return Calendar.TUESDAY;
+					case 3 :
+						return Calendar.WEDNESDAY;
+					case 4 :
+						return Calendar.THURSDAY;
+					case 5 :
+						return Calendar.FRIDAY;
+					case 6 :
+						return Calendar.SATURDAY;
+					case 7 :
+						return Calendar.SUNDAY;
+				}
+		return -1;
+	}
+
+	private int getHour(Preferences pref) {
+		String hour = pref.getString(P_HOUR);
+		for (int h = 0; h < HOURS.length; h++)
+			if (HOURS[h].equals(hour))
+				return h + 1;
+		return 1;
+	}
+
+	/*
+	 * Computes the number of milliseconds from this moment to the next
+	 * scheduled update check. If that moment has already passed, returns 0L (start
+	 * immediately).
+	 */
+	private long computeDelay(Preferences pref) {
+
+		int target_d = getDay(pref);
+		int target_h = getHour(pref);
+
+		Calendar calendar = Calendar.getInstance();
+		// may need to use the BootLoader locale
+		int current_d = calendar.get(Calendar.DAY_OF_WEEK);
+		// starts with SUNDAY
+		int current_h = calendar.get(Calendar.HOUR_OF_DAY);
+		int current_m = calendar.get(Calendar.MINUTE);
+		int current_s = calendar.get(Calendar.SECOND);
+		int current_ms = calendar.get(Calendar.MILLISECOND);
+
+		long delay = 0L; // milliseconds
+
+		if (target_d == -1) {
+			// Compute the delay for "every day at x o'clock"
+			// Is it now ?
+			if (target_h == current_h && current_m == 0 && current_s == 0)
+				return delay;
+
+			int delta_h = target_h - current_h;
+			if (target_h <= current_h)
+				delta_h += 24;
+			delay = ((delta_h * 60 - current_m) * 60 - current_s) * 1000 - current_ms;
+			return delay;
+		}
+		// Compute the delay for "every Xday at x o'clock"
+		// Is it now ?
+		if (target_d == current_d && target_h == current_h && current_m == 0 && current_s == 0)
+			return delay;
+
+		int delta_d = target_d - current_d;
+		if (target_d < current_d || target_d == current_d && (target_h < current_h || target_h == current_h && current_m > 0))
+			delta_d += 7;
+
+		delay = (((delta_d * 24 + target_h - current_h) * 60 - current_m) * 60 - current_s) * 1000 - current_ms;
+		return delay;
+	}
+
+	/*
+	 * Computes the number of milliseconds for the polling frequency.
+	 * We have already established that there is a schedule, vs. only
+	 * on startup.
+	 */
+	private long computePoll(Preferences pref) {
+
+		int target_d = getDay(pref);
+		if (target_d == -1) {
+			// Every 24 hours
+			return 24 * 60 * 60 * 1000;
+		}
+		return 7 * 24 * 60 * 60 * 1000;
+	}
+
+	private void removeUpdateListener() {
+		// Remove the current listener if there is one
+		if (listener != null && checker != null) {
+			checker.removeUpdateCheck(listener);
+			listener = null;
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdater.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdater.java
new file mode 100644
index 0000000..8358608
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdater.java
@@ -0,0 +1,422 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.EventObject;
+import org.eclipse.core.runtime.*;
+import org.eclipse.core.runtime.jobs.*;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
+import org.eclipse.equinox.internal.provisional.p2.core.eventbus.ProvisioningListener;
+import org.eclipse.equinox.internal.provisional.p2.director.ProfileChangeRequest;
+import org.eclipse.equinox.internal.provisional.p2.director.ProvisioningPlan;
+import org.eclipse.equinox.internal.provisional.p2.engine.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.ui.*;
+import org.eclipse.equinox.internal.provisional.p2.ui.model.Updates;
+import org.eclipse.equinox.internal.provisional.p2.ui.operations.*;
+import org.eclipse.equinox.internal.provisional.p2.ui.policy.Policy;
+import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener;
+import org.eclipse.equinox.internal.provisional.p2.updatechecker.UpdateEvent;
+import org.eclipse.jface.action.IStatusLineManager;
+import org.eclipse.jface.viewers.*;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.*;
+import org.eclipse.ui.*;
+import org.eclipse.ui.progress.WorkbenchJob;
+import org.eclipse.ui.statushandlers.StatusManager;
+
+/**
+ * @since 3.5
+ */
+public class AutomaticUpdater implements IUpdateListener {
+
+	Preferences prefs;
+	StatusLineCLabelContribution updateAffordance;
+	AutomaticUpdateAction updateAction;
+	IStatusLineManager statusLineManager;
+	IInstallableUnit[] iusWithUpdates;
+	String profileId;
+	AutomaticUpdatesPopup popup;
+	ProvisioningListener profileChangeListener;
+	IJobChangeListener provisioningJobListener;
+	boolean alreadyValidated = false;
+	boolean alreadyDownloaded = false;
+	private static final String AUTO_UPDATE_STATUS_ITEM = "AutoUpdatesStatus"; //$NON-NLS-1$
+
+	public AutomaticUpdater() {
+		prefs = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener#updatesAvailable(org.eclipse.equinox.internal.provisional.p2.updatechecker.UpdateEvent)
+	 */
+	public void updatesAvailable(final UpdateEvent event) {
+		final boolean download = prefs.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY);
+		profileId = event.getProfileId();
+		iusWithUpdates = event.getIUs();
+		validateUpdates(null, true);
+		alreadyDownloaded = false;
+
+		if (iusWithUpdates.length <= 0) {
+			clearUpdatesAvailable();
+			return;
+		}
+		registerProfileChangeListener();
+		registerProvisioningJobListener();
+
+		// Download the items if the preference dictates before
+		// showing the user that updates are available.
+		try {
+			if (download) {
+				ElementQueryDescriptor descriptor = Policy.getDefault().getQueryProvider().getQueryDescriptor(new Updates(event.getProfileId(), event.getIUs()));
+				IInstallableUnit[] replacements = (IInstallableUnit[]) descriptor.queryable.query(descriptor.query, descriptor.collector, null).toArray(IInstallableUnit.class);
+				if (replacements.length > 0) {
+					ProfileChangeRequest request = ProfileChangeRequest.createByProfileId(event.getProfileId());
+					request.removeInstallableUnits(iusWithUpdates);
+					request.addInstallableUnits(replacements);
+					final ProvisioningPlan plan = ProvisioningUtil.getPlanner().getProvisioningPlan(request, new ProvisioningContext(), null);
+					Job job = ProvisioningOperationRunner.schedule(new ProfileModificationOperation(AutomaticUpdateMessages.AutomaticUpdater_AutomaticDownloadOperationName, event.getProfileId(), plan, new DownloadPhaseSet(), false), null, StatusManager.LOG);
+					job.addJobChangeListener(new JobChangeAdapter() {
+						public void done(IJobChangeEvent jobEvent) {
+							alreadyDownloaded = true;
+							IStatus status = jobEvent.getResult();
+							if (status.isOK()) {
+								createUpdateAction();
+								PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
+									public void run() {
+										updateAction.suppressWizard(true);
+										updateAction.performAction(iusWithUpdates, event.getProfileId(), plan);
+									}
+								});
+							} else if (status.getSeverity() != IStatus.CANCEL) {
+								ProvUI.reportStatus(status, StatusManager.LOG);
+							}
+						}
+					});
+				}
+			} else {
+				createUpdateAction();
+				PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
+					public void run() {
+						updateAction.suppressWizard(true);
+						updateAction.run();
+					}
+				});
+			}
+
+		} catch (ProvisionException e) {
+			ProvUI.handleException(e, AutomaticUpdateMessages.AutomaticUpdater_ErrorCheckingUpdates, StatusManager.LOG);
+		}
+
+	}
+
+	/*
+	 * Validate that iusToBeUpdated is valid, and reset the cache.  
+	 * If isKnownToBeAvailable is false, then recheck that the update is
+	 * available.  isKnownToBeAvailable should be false when the update list 
+	 * might be stale (Reminding the user of updates may happen long
+	 * after the update check.  This reduces the risk of notifying the user
+	 * of updates and then not finding them .)
+	 */
+
+	void validateUpdates(IProgressMonitor monitor, boolean isKnownToBeAvailable) {
+		ArrayList list = new ArrayList();
+		for (int i = 0; i < iusWithUpdates.length; i++) {
+			try {
+				if (isKnownToBeAvailable || ProvisioningUtil.getPlanner().updatesFor(iusWithUpdates[i], new ProvisioningContext(), monitor).length > 0) {
+					if (validToUpdate(iusWithUpdates[i]))
+						list.add(iusWithUpdates[i]);
+				}
+			} catch (ProvisionException e) {
+				ProvUI.handleException(e, AutomaticUpdateMessages.AutomaticUpdater_ErrorCheckingUpdates, StatusManager.LOG);
+				continue;
+			} catch (OperationCanceledException e) {
+				// Nothing to report
+			}
+		}
+		iusWithUpdates = (IInstallableUnit[]) list.toArray(new IInstallableUnit[list.size()]);
+	}
+
+	// A proposed update is valid if it is still visible to the user as an installed item (it is a root)
+	// and if it is not locked for updating.
+	private boolean validToUpdate(IInstallableUnit iu) {
+		int lock = IInstallableUnit.LOCK_NONE;
+		boolean isRoot = false;
+		try {
+			IProfile profile = ProvisioningUtil.getProfile(profileId);
+			String value = profile.getInstallableUnitProperty(iu, IInstallableUnit.PROP_PROFILE_LOCKED_IU);
+			if (value != null)
+				lock = Integer.parseInt(value);
+			value = profile.getInstallableUnitProperty(iu, IInstallableUnit.PROP_PROFILE_ROOT_IU);
+			isRoot = value == null ? false : Boolean.valueOf(value).booleanValue();
+		} catch (ProvisionException e) {
+			// ignore
+		} catch (NumberFormatException e) {
+			// ignore and assume no lock
+		}
+		return isRoot && (lock & IInstallableUnit.LOCK_UPDATE) == 0;
+	}
+
+	Shell getWorkbenchWindowShell() {
+		IWorkbenchWindow activeWindow = PlatformUI.getWorkbench().getActiveWorkbenchWindow();
+		return activeWindow != null ? activeWindow.getShell() : null;
+
+	}
+
+	IStatusLineManager getStatusLineManager() {
+		if (statusLineManager != null)
+			return statusLineManager;
+		IWorkbenchWindow activeWindow = PlatformUI.getWorkbench().getActiveWorkbenchWindow();
+		if (activeWindow == null)
+			return null;
+		// YUCK!  YUCK!  YUCK!
+		// IWorkbenchWindow does not define getStatusLineManager(), yet WorkbenchWindow does
+		try {
+			Method method = activeWindow.getClass().getDeclaredMethod("getStatusLineManager", new Class[0]); //$NON-NLS-1$
+			try {
+				Object statusLine = method.invoke(activeWindow, new Object[0]);
+				if (statusLine instanceof IStatusLineManager) {
+					statusLineManager = (IStatusLineManager) statusLine;
+					return statusLineManager;
+				}
+			} catch (InvocationTargetException e) {
+				// oh well
+			} catch (IllegalAccessException e) {
+				// I tried
+			}
+		} catch (NoSuchMethodException e) {
+			// can't blame us for trying.
+		}
+
+		IWorkbenchPartSite site = activeWindow.getActivePage().getActivePart().getSite();
+		if (site instanceof IViewSite) {
+			statusLineManager = ((IViewSite) site).getActionBars().getStatusLineManager();
+		} else if (site instanceof IEditorSite) {
+			statusLineManager = ((IEditorSite) site).getActionBars().getStatusLineManager();
+		}
+		return statusLineManager;
+	}
+
+	void updateStatusLine() {
+		IStatusLineManager manager = getStatusLineManager();
+		if (manager != null)
+			manager.update(true);
+	}
+
+	void createUpdateAffordance() {
+		updateAffordance = new StatusLineCLabelContribution(AUTO_UPDATE_STATUS_ITEM, 5);
+		updateAffordance.addListener(SWT.MouseDown, new Listener() {
+			public void handleEvent(Event event) {
+				launchUpdate();
+			}
+		});
+		IStatusLineManager manager = getStatusLineManager();
+		if (manager != null) {
+			manager.add(updateAffordance);
+			manager.update(true);
+		}
+	}
+
+	void setUpdateAffordanceState(boolean isValid) {
+		if (updateAffordance == null)
+			return;
+		if (isValid) {
+			updateAffordance.setTooltip(AutomaticUpdateMessages.AutomaticUpdater_ClickToReviewUpdates);
+			updateAffordance.setImage(ProvUIImages.getImage(ProvUIImages.IMG_TOOL_UPDATE));
+		} else {
+			updateAffordance.setTooltip(AutomaticUpdateMessages.AutomaticUpdater_ClickToReviewUpdatesWithProblems);
+			updateAffordance.setImage(ProvUIImages.getImage(ProvUIImages.IMG_TOOL_UPDATE_PROBLEMS));
+		}
+		IStatusLineManager manager = getStatusLineManager();
+		if (manager != null) {
+			manager.update(true);
+		}
+	}
+
+	void checkUpdateAffordanceEnablement() {
+		// We don't currently support enablement in the affordance,
+		// so we hide it if it should not be enabled.
+		if (updateAffordance == null)
+			return;
+		boolean shouldBeVisible = !ProvisioningOperationRunner.hasScheduledOperations();
+		if (updateAffordance.isVisible() != shouldBeVisible) {
+			IStatusLineManager manager = getStatusLineManager();
+			if (manager != null) {
+				updateAffordance.setVisible(shouldBeVisible);
+				manager.update(true);
+			}
+		}
+	}
+
+	void createUpdatePopup() {
+		popup = new AutomaticUpdatesPopup(getWorkbenchWindowShell(), alreadyDownloaded, prefs);
+		popup.open();
+
+	}
+
+	void createUpdateAction() {
+		if (updateAction == null)
+			updateAction = new AutomaticUpdateAction(this, getSelectionProvider(), profileId);
+	}
+
+	void clearUpdatesAvailable() {
+		if (updateAffordance != null) {
+			IStatusLineManager manager = getStatusLineManager();
+			if (manager != null) {
+				manager.remove(updateAffordance);
+				manager.update(true);
+			}
+			updateAffordance.dispose();
+			updateAffordance = null;
+		}
+		if (popup != null) {
+			popup.close(false);
+			popup = null;
+		}
+		alreadyValidated = false;
+	}
+
+	ISelectionProvider getSelectionProvider() {
+		return new ISelectionProvider() {
+
+			/* (non-Javadoc)
+			 * @see org.eclipse.jface.viewers.ISelectionProvider#addSelectionChangedListener(org.eclipse.jface.viewers.ISelectionChangedListener)
+			 */
+			public void addSelectionChangedListener(ISelectionChangedListener listener) {
+				// Ignore because the selection won't change 
+			}
+
+			/* (non-Javadoc)
+			 * @see org.eclipse.jface.viewers.ISelectionProvider#getSelection()
+			 */
+			public ISelection getSelection() {
+				return new StructuredSelection(iusWithUpdates);
+			}
+
+			/* (non-Javadoc)
+			 * @see org.eclipse.jface.viewers.ISelectionProvider#removeSelectionChangedListener(org.eclipse.jface.viewers.ISelectionChangedListener)
+			 */
+			public void removeSelectionChangedListener(ISelectionChangedListener listener) {
+				// ignore because the selection is static
+			}
+
+			/* (non-Javadoc)
+			 * @see org.eclipse.jface.viewers.ISelectionProvider#setSelection(org.eclipse.jface.viewers.ISelection)
+			 */
+			public void setSelection(ISelection sel) {
+				throw new UnsupportedOperationException("This ISelectionProvider is static, and cannot be modified."); //$NON-NLS-1$
+			}
+		};
+	}
+
+	public void launchUpdate() {
+		alreadyValidated = true;
+		updateAction.suppressWizard(false);
+		updateAction.run();
+	}
+
+	private void registerProfileChangeListener() {
+		if (profileChangeListener == null) {
+			profileChangeListener = new ProvisioningListener() {
+				public void notify(EventObject o) {
+					if (o instanceof ProfileEvent) {
+						ProfileEvent event = (ProfileEvent) o;
+						if (event.getReason() == ProfileEvent.CHANGED && profileId.equals(event.getProfileId())) {
+							validateUpdates();
+						}
+					}
+				}
+			};
+			IProvisioningEventBus bus = AutomaticUpdatePlugin.getDefault().getProvisioningEventBus();
+			if (bus != null)
+				bus.addListener(profileChangeListener);
+		}
+	}
+
+	private void registerProvisioningJobListener() {
+		if (provisioningJobListener == null) {
+			provisioningJobListener = new JobChangeAdapter() {
+				public void done(IJobChangeEvent event) {
+					IWorkbench workbench = PlatformUI.getWorkbench();
+					if (workbench == null || workbench.isClosing())
+						return;
+					if (workbench.getDisplay() == null)
+						return;
+					workbench.getDisplay().asyncExec(new Runnable() {
+						public void run() {
+							checkUpdateAffordanceEnablement();
+						}
+					});
+				}
+
+				public void scheduled(final IJobChangeEvent event) {
+					IWorkbench workbench = PlatformUI.getWorkbench();
+					if (workbench == null || workbench.isClosing())
+						return;
+					if (workbench.getDisplay() == null)
+						return;
+					workbench.getDisplay().asyncExec(new Runnable() {
+						public void run() {
+							checkUpdateAffordanceEnablement();
+						}
+					});
+				}
+			};
+			ProvisioningOperationRunner.addJobChangeListener(provisioningJobListener);
+		}
+	}
+
+	/*
+	 * The profile has changed.  Make sure our toUpdate list is
+	 * still valid and if there is nothing to update, get rid
+	 * of the update popup and affordance.
+	 */
+	void validateUpdates() {
+		Job validateJob = new WorkbenchJob("Update validate job") { //$NON-NLS-1$
+			public IStatus runInUIThread(IProgressMonitor monitor) {
+				if (monitor.isCanceled())
+					return Status.CANCEL_STATUS;
+				validateUpdates(monitor, false);
+				if (iusWithUpdates.length == 0)
+					clearUpdatesAvailable();
+				else {
+					createUpdateAction();
+					updateAction.suppressWizard(true);
+					updateAction.run();
+				}
+				return Status.OK_STATUS;
+			}
+		};
+		validateJob.setSystem(true);
+		validateJob.setPriority(Job.SHORT);
+		validateJob.schedule();
+	}
+
+	public void shutdown() {
+		if (provisioningJobListener != null) {
+			ProvisioningOperationRunner.removeJobChangeListener(provisioningJobListener);
+			provisioningJobListener = null;
+		}
+		if (profileChangeListener == null)
+			return;
+		IProvisioningEventBus bus = AutomaticUpdatePlugin.getDefault().getProvisioningEventBus();
+		if (bus != null)
+			bus.removeListener(profileChangeListener);
+		profileChangeListener = null;
+		statusLineManager = null;
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPopup.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPopup.java
new file mode 100644
index 0000000..8c3871c
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPopup.java
@@ -0,0 +1,294 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+import org.eclipse.core.runtime.*;
+import org.eclipse.core.runtime.Preferences.IPropertyChangeListener;
+import org.eclipse.core.runtime.Preferences.PropertyChangeEvent;
+import org.eclipse.core.runtime.jobs.Job;
+import org.eclipse.equinox.internal.provisional.p2.ui.ProvUIImages;
+import org.eclipse.jface.dialogs.IDialogSettings;
+import org.eclipse.jface.dialogs.PopupDialog;
+import org.eclipse.jface.layout.GridDataFactory;
+import org.eclipse.jface.preference.PreferenceDialog;
+import org.eclipse.osgi.util.NLS;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.*;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.*;
+import org.eclipse.ui.dialogs.PreferencesUtil;
+import org.eclipse.ui.progress.WorkbenchJob;
+
+/**
+ * AutomaticUpdatesPopup is an async popup dialog for notifying
+ * the user of updates.
+ * 
+ * @since 3.4
+ */
+public class AutomaticUpdatesPopup extends PopupDialog {
+	public static final String[] ELAPSED = {AutomaticUpdateMessages.AutomaticUpdateScheduler_30Minutes, AutomaticUpdateMessages.AutomaticUpdateScheduler_60Minutes, AutomaticUpdateMessages.AutomaticUpdateScheduler_240Minutes};
+	private static final long MINUTE = 60 * 1000L;
+	private static final String PREFS_HREF = "PREFS"; //$NON-NLS-1$
+	private static final String DIALOG_SETTINGS_SECTION = "AutomaticUpdatesPopup"; //$NON-NLS-1$
+	private static final int POPUP_OFFSET = 20;
+
+	Preferences prefs;
+	long remindDelay = -1L;
+	IPropertyChangeListener prefListener;
+	WorkbenchJob remindJob;
+	boolean downloaded;
+	Composite dialogArea;
+	Link remindLink;
+	MouseListener clickListener;
+
+	public AutomaticUpdatesPopup(Shell parentShell, boolean alreadyDownloaded, Preferences prefs) {
+		super(parentShell, PopupDialog.INFOPOPUPRESIZE_SHELLSTYLE | SWT.MODELESS, false, true, true, false, false, AutomaticUpdateMessages.AutomaticUpdatesPopup_UpdatesAvailableTitle, null);
+		downloaded = alreadyDownloaded;
+		this.prefs = prefs;
+		remindDelay = computeRemindDelay();
+		clickListener = new MouseAdapter() {
+			public void mouseDown(MouseEvent e) {
+				AutomaticUpdatePlugin.getDefault().getAutomaticUpdater().launchUpdate();
+			}
+		};
+	}
+
+	protected Control createDialogArea(Composite parent) {
+		dialogArea = new Composite(parent, SWT.NONE);
+		dialogArea.setLayoutData(new GridData(GridData.FILL_BOTH));
+		GridLayout layout = new GridLayout();
+		layout.numColumns = 1;
+		dialogArea.setLayout(layout);
+		dialogArea.addMouseListener(clickListener);
+
+		// The "click to update" label
+		Label infoLabel = new Label(dialogArea, SWT.NONE);
+		if (downloaded)
+			infoLabel.setText(AutomaticUpdateMessages.AutomaticUpdatesPopup_ClickToReviewDownloaded);
+		else
+			infoLabel.setText(AutomaticUpdateMessages.AutomaticUpdatesPopup_ClickToReviewNotDownloaded);
+		infoLabel.setLayoutData(new GridData(GridData.FILL_BOTH));
+		infoLabel.addMouseListener(clickListener);
+
+		createRemindSection(dialogArea);
+
+		return dialogArea;
+
+	}
+
+	private void createRemindSection(Composite parent) {
+		remindLink = new Link(parent, SWT.MULTI | SWT.WRAP | SWT.RIGHT);
+		updateRemindText();
+		remindLink.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				PreferenceDialog dialog = PreferencesUtil.createPreferenceDialogOn(getShell(), PreferenceConstants.PREF_PAGE_AUTO_UPDATES, null, null);
+				dialog.open();
+
+			}
+		});
+		remindLink.setLayoutData(new GridData(GridData.FILL_BOTH));
+	}
+
+	private void updateRemindText() {
+		if (prefs.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE))
+			remindLink.setText(NLS.bind(AutomaticUpdateMessages.AutomaticUpdatesPopup_RemindAndPrefLink, new String[] {prefs.getString(PreferenceConstants.PREF_REMIND_ELAPSED), PREFS_HREF}));
+		else
+			remindLink.setText(AutomaticUpdateMessages.AutomaticUpdatesPopup_PrefLinkOnly);
+		remindLink.getParent().layout(true);
+	}
+
+	protected IDialogSettings getDialogBoundsSettings() {
+		IDialogSettings settings = AutomaticUpdatePlugin.getDefault().getDialogSettings();
+		IDialogSettings section = settings.getSection(DIALOG_SETTINGS_SECTION);
+		if (section == null) {
+			section = settings.addNewSection(DIALOG_SETTINGS_SECTION);
+		}
+		return section;
+	}
+
+	public int open() {
+		prefListener = new IPropertyChangeListener() {
+			public void propertyChange(PropertyChangeEvent event) {
+				handlePreferenceChange(event);
+			}
+		};
+		prefs.addPropertyChangeListener(prefListener);
+		return super.open();
+	}
+
+	public boolean close() {
+		return close(true);
+	}
+
+	public boolean close(boolean remind) {
+		if (remind && prefs.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE))
+			scheduleRemindJob();
+		else
+			cancelRemindJob();
+		if (prefListener != null) {
+			prefs.removePropertyChangeListener(prefListener);
+			prefListener = null;
+		}
+		return super.close();
+
+	}
+
+	void scheduleRemindJob() {
+		// Cancel any pending remind job if there is one
+		if (remindJob != null)
+			remindJob.cancel();
+		// If no updates have been found, there is nothing to remind
+		if (remindDelay < 0)
+			return;
+		remindJob = new WorkbenchJob(AutomaticUpdateMessages.AutomaticUpdatesPopup_ReminderJobTitle) {
+			public IStatus runInUIThread(IProgressMonitor monitor) {
+				if (monitor.isCanceled())
+					return Status.CANCEL_STATUS;
+				open();
+				return Status.OK_STATUS;
+			}
+		};
+		remindJob.setSystem(true);
+		remindJob.setPriority(Job.INTERACTIVE);
+		remindJob.schedule(remindDelay);
+
+	}
+
+	/*
+	 * Computes the number of milliseconds for the delay
+	 * in reminding the user of updates
+	 */
+	long computeRemindDelay() {
+		if (prefs.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE)) {
+			String elapsed = prefs.getString(PreferenceConstants.PREF_REMIND_ELAPSED);
+			for (int d = 0; d < ELAPSED.length; d++)
+				if (ELAPSED[d].equals(elapsed))
+					switch (d) {
+						case 0 :
+							// 30 minutes
+							return 30 * MINUTE;
+						case 1 :
+							// 60 minutes
+							return 60 * MINUTE;
+						case 2 :
+							// 240 minutes
+							return 240 * MINUTE;
+					}
+		}
+		return -1L;
+	}
+
+	void cancelRemindJob() {
+		if (remindJob != null) {
+			remindJob.cancel();
+			remindJob = null;
+		}
+	}
+
+	protected void configureShell(Shell newShell) {
+		super.configureShell(newShell);
+		newShell.setText(AutomaticUpdateMessages.AutomaticUpdatesPopup_UpdatesAvailableTitle);
+	}
+
+	/**
+	 * (non-Javadoc)
+	 * 
+	 * @see org.eclipse.jface.window.Window#getInitialLocation(org.eclipse.swt.graphics.Point)
+	 */
+	protected Point getInitialLocation(Point initialSize) {
+		Shell parent = getParentShell();
+		Point parentSize, parentLocation;
+
+		if (parent != null) {
+			parentSize = parent.getSize();
+			parentLocation = parent.getLocation();
+		} else {
+			Rectangle bounds = getShell().getDisplay().getBounds();
+			parentSize = new Point(bounds.width, bounds.height);
+			parentLocation = new Point(0, 0);
+		}
+		// We have to take parent location into account because SWT considers all
+		// shell locations to be in display coordinates, even if the shell is parented.
+		return new Point(parentSize.x - initialSize.x + parentLocation.x - POPUP_OFFSET, parentSize.y - initialSize.y + parentLocation.y - POPUP_OFFSET);
+	}
+
+	void handlePreferenceChange(PropertyChangeEvent event) {
+		if (PreferenceConstants.PREF_REMIND_SCHEDULE.equals(event.getProperty())) {
+			// Reminders turned on
+			if (prefs.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE)) {
+				if (remindLink == null)
+					createRemindSection(dialogArea);
+				else {
+					updateRemindText();
+					getShell().layout(true, true);
+				}
+				computeRemindDelay();
+				scheduleRemindJob();
+			} else { // reminders turned off
+				if (remindLink != null) {
+					updateRemindText();
+					getShell().layout(true, true);
+				}
+				cancelRemindJob();
+			}
+		} else if (PreferenceConstants.PREF_REMIND_ELAPSED.equals(event.getProperty())) {
+			// Reminding schedule changed
+			computeRemindDelay();
+			scheduleRemindJob();
+		}
+	}
+
+	/*
+	 * Overridden so that clicking in the title menu area closes the dialog.
+	 * Also creates a close box menu in the title area.
+	 */
+	protected Control createTitleMenuArea(Composite parent) {
+		Composite titleComposite = (Composite) super.createTitleMenuArea(parent);
+		titleComposite.addMouseListener(clickListener);
+
+		ToolBar toolBar = new ToolBar(titleComposite, SWT.FLAT);
+		ToolItem closeButton = new ToolItem(toolBar, SWT.PUSH, 0);
+
+		GridDataFactory.fillDefaults().align(SWT.END, SWT.CENTER).applyTo(toolBar);
+		closeButton.setImage(ProvUIImages.getImage(ProvUIImages.IMG_TOOL_CLOSE));
+		closeButton.setHotImage(ProvUIImages.getImage(ProvUIImages.IMG_TOOL_CLOSE_HOT));
+		closeButton.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				close();
+			}
+		});
+		// See https://bugs.eclipse.org/bugs/show_bug.cgi?id=177183
+		toolBar.addMouseListener(new MouseAdapter() {
+			public void mouseDown(MouseEvent e) {
+				close();
+			}
+		});
+		return titleComposite;
+	}
+
+	/*
+	 * Overridden to adjust the span of the title label.
+	 * Reachy, reachy....
+	 * (non-Javadoc)
+	 * @see org.eclipse.jface.dialogs.PopupDialog#createTitleControl(org.eclipse.swt.widgets.Composite)
+	 */
+	protected Control createTitleControl(Composite parent) {
+		Control control = super.createTitleControl(parent);
+		Object data = control.getLayoutData();
+		if (data instanceof GridData) {
+			((GridData) data).horizontalSpan = 1;
+		}
+		return control;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPreferencePage.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPreferencePage.java
new file mode 100644
index 0000000..b279bb8
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatesPreferencePage.java
@@ -0,0 +1,301 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+import org.eclipse.core.runtime.Preferences;
+import org.eclipse.jface.dialogs.Dialog;
+import org.eclipse.jface.preference.PreferencePage;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.*;
+import org.eclipse.ui.*;
+
+/**
+ * Preference page for automated updates.
+ * 
+ * @since 3.4
+ *
+ */
+public class AutomaticUpdatesPreferencePage extends PreferencePage implements IWorkbenchPreferencePage {
+
+	private Button enabledCheck;
+	private Button onStartupRadio, onScheduleRadio;
+	private Combo dayCombo;
+	private Label atLabel;
+	private Combo hourCombo;
+	private Button searchOnlyRadio, searchAndDownloadRadio;
+	private Button remindOnceRadio, remindScheduleRadio;
+	private Combo remindElapseCombo;
+	private Group updateScheduleGroup, downloadGroup, remindGroup;
+
+	public void init(IWorkbench workbench) {
+		// nothing to init
+	}
+
+	protected Control createContents(Composite parent) {
+		PlatformUI.getWorkbench().getHelpSystem().setHelp(parent, IAutomaticUpdaterHelpContextIds.AUTOMATIC_UPDATES_PREFERENCE_PAGE);
+
+		Composite container = new Composite(parent, SWT.NULL);
+		GridLayout layout = new GridLayout();
+		layout.marginWidth = layout.marginHeight = 0;
+		container.setLayout(layout);
+
+		enabledCheck = new Button(container, SWT.CHECK);
+		enabledCheck.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_findUpdates);
+
+		createSpacer(container, 1);
+
+		updateScheduleGroup = new Group(container, SWT.NONE);
+		updateScheduleGroup.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_UpdateSchedule);
+		layout = new GridLayout();
+		layout.numColumns = 3;
+		updateScheduleGroup.setLayout(layout);
+		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
+		updateScheduleGroup.setLayoutData(gd);
+
+		onStartupRadio = new Button(updateScheduleGroup, SWT.RADIO);
+		onStartupRadio.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_findOnStart);
+		gd = new GridData();
+		gd.horizontalSpan = 3;
+		onStartupRadio.setLayoutData(gd);
+		onStartupRadio.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				pageChanged();
+			}
+		});
+
+		onScheduleRadio = new Button(updateScheduleGroup, SWT.RADIO);
+		onScheduleRadio.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_findOnSchedule);
+		gd = new GridData();
+		gd.horizontalSpan = 3;
+		onScheduleRadio.setLayoutData(gd);
+		onScheduleRadio.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				pageChanged();
+			}
+		});
+
+		dayCombo = new Combo(updateScheduleGroup, SWT.READ_ONLY);
+		dayCombo.setItems(AutomaticUpdateScheduler.DAYS);
+		gd = new GridData();
+		gd.widthHint = 200;
+		gd.horizontalIndent = 30;
+		dayCombo.setLayoutData(gd);
+
+		atLabel = new Label(updateScheduleGroup, SWT.NULL);
+		atLabel.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_at);
+
+		hourCombo = new Combo(updateScheduleGroup, SWT.READ_ONLY);
+		hourCombo.setItems(AutomaticUpdateScheduler.HOURS);
+		gd = new GridData();
+		hourCombo.setLayoutData(gd);
+
+		createSpacer(container, 1);
+
+		downloadGroup = new Group(container, SWT.NONE);
+		downloadGroup.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_downloadOptions);
+		layout = new GridLayout();
+		layout.numColumns = 3;
+		downloadGroup.setLayout(layout);
+		gd = new GridData(GridData.FILL_HORIZONTAL);
+		downloadGroup.setLayoutData(gd);
+
+		searchOnlyRadio = new Button(downloadGroup, SWT.RADIO);
+		searchOnlyRadio.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_searchAndNotify);
+		gd = new GridData();
+		gd.horizontalSpan = 3;
+		searchOnlyRadio.setLayoutData(gd);
+		searchOnlyRadio.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				pageChanged();
+			}
+		});
+
+		searchAndDownloadRadio = new Button(downloadGroup, SWT.RADIO);
+		searchAndDownloadRadio.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_downloadAndNotify);
+		gd = new GridData();
+		gd.horizontalSpan = 3;
+		searchAndDownloadRadio.setLayoutData(gd);
+		searchAndDownloadRadio.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				pageChanged();
+			}
+		});
+
+		createSpacer(container, 1);
+
+		remindGroup = new Group(container, SWT.NONE);
+		remindGroup.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_RemindGroup);
+		layout = new GridLayout();
+		layout.numColumns = 3;
+		remindGroup.setLayout(layout);
+		gd = new GridData(GridData.FILL_HORIZONTAL);
+		remindGroup.setLayoutData(gd);
+
+		remindOnceRadio = new Button(remindGroup, SWT.RADIO);
+		remindOnceRadio.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_RemindOnce);
+		gd = new GridData();
+		gd.horizontalSpan = 3;
+		remindOnceRadio.setLayoutData(gd);
+		remindOnceRadio.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				pageChanged();
+			}
+		});
+
+		remindScheduleRadio = new Button(remindGroup, SWT.RADIO);
+		remindScheduleRadio.setText(AutomaticUpdateMessages.AutomaticUpdatesPreferencePage_RemindSchedule);
+		gd = new GridData();
+		gd.horizontalSpan = 3;
+		remindScheduleRadio.setLayoutData(gd);
+		remindScheduleRadio.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				pageChanged();
+			}
+		});
+
+		remindElapseCombo = new Combo(remindGroup, SWT.READ_ONLY);
+		remindElapseCombo.setItems(AutomaticUpdatesPopup.ELAPSED);
+
+		gd = new GridData();
+		gd.widthHint = 200;
+		gd.horizontalIndent = 30;
+		remindElapseCombo.setLayoutData(gd);
+
+		initialize();
+
+		enabledCheck.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				pageChanged();
+			}
+		});
+
+		Dialog.applyDialogFont(container);
+		return container;
+	}
+
+	protected void createSpacer(Composite composite, int columnSpan) {
+		Label label = new Label(composite, SWT.NONE);
+		GridData gd = new GridData();
+		gd.horizontalSpan = columnSpan;
+		label.setLayoutData(gd);
+	}
+
+	private void initialize() {
+		Preferences pref = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
+		enabledCheck.setSelection(pref.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED));
+		setSchedule(pref.getString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE));
+
+		dayCombo.setText(AutomaticUpdateScheduler.DAYS[getDay(pref, false)]);
+		hourCombo.setText(AutomaticUpdateScheduler.HOURS[getHour(pref, false)]);
+
+		remindScheduleRadio.setSelection(pref.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
+		remindOnceRadio.setSelection(!pref.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
+		remindElapseCombo.setText(pref.getString(PreferenceConstants.PREF_REMIND_ELAPSED));
+		searchOnlyRadio.setSelection(!pref.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
+		searchAndDownloadRadio.setSelection(pref.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
+
+		pageChanged();
+	}
+
+	private void setSchedule(String value) {
+		if (value.equals(PreferenceConstants.PREF_UPDATE_ON_STARTUP))
+			onStartupRadio.setSelection(true);
+		else
+			onScheduleRadio.setSelection(true);
+	}
+
+	void pageChanged() {
+		boolean master = enabledCheck.getSelection();
+		updateScheduleGroup.setEnabled(master);
+		onStartupRadio.setEnabled(master);
+		onScheduleRadio.setEnabled(master);
+		dayCombo.setEnabled(master && onScheduleRadio.getSelection());
+		atLabel.setEnabled(master && onScheduleRadio.getSelection());
+		hourCombo.setEnabled(master && onScheduleRadio.getSelection());
+		downloadGroup.setEnabled(master);
+		searchOnlyRadio.setEnabled(master);
+		searchAndDownloadRadio.setEnabled(master);
+		remindGroup.setEnabled(master);
+		remindScheduleRadio.setEnabled(master);
+		remindOnceRadio.setEnabled(master);
+		remindElapseCombo.setEnabled(master && remindScheduleRadio.getSelection());
+	}
+
+	protected void performDefaults() {
+		super.performDefaults();
+		Preferences pref = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
+		enabledCheck.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED));
+
+		setSchedule(pref.getDefaultString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE));
+		onScheduleRadio.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE));
+
+		dayCombo.setText(AutomaticUpdateScheduler.DAYS[getDay(pref, true)]);
+		hourCombo.setText(AutomaticUpdateScheduler.HOURS[getHour(pref, true)]);
+
+		remindOnceRadio.setSelection(!pref.getDefaultBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
+		remindScheduleRadio.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
+		remindElapseCombo.setText(pref.getDefaultString(PreferenceConstants.PREF_REMIND_ELAPSED));
+
+		searchOnlyRadio.setSelection(!pref.getDefaultBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
+		searchAndDownloadRadio.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
+		pageChanged();
+	}
+
+	/** 
+	 * Method declared on IPreferencePage.
+	 * Subclasses should override
+	 */
+	public boolean performOk() {
+		Preferences pref = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
+		pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, enabledCheck.getSelection());
+		if (onStartupRadio.getSelection())
+			pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_STARTUP);
+		else
+			pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_SCHEDULE);
+
+		if (remindScheduleRadio.getSelection()) {
+			pref.setValue(PreferenceConstants.PREF_REMIND_SCHEDULE, true);
+			pref.setValue(PreferenceConstants.PREF_REMIND_ELAPSED, remindElapseCombo.getText());
+		} else {
+			pref.setValue(PreferenceConstants.PREF_REMIND_SCHEDULE, false);
+		}
+
+		pref.setValue(AutomaticUpdateScheduler.P_DAY, dayCombo.getText());
+		pref.setValue(AutomaticUpdateScheduler.P_HOUR, hourCombo.getText());
+
+		pref.setValue(PreferenceConstants.PREF_DOWNLOAD_ONLY, searchAndDownloadRadio.getSelection());
+
+		AutomaticUpdatePlugin.getDefault().savePluginPreferences();
+
+		AutomaticUpdatePlugin.getDefault().getScheduler().rescheduleUpdate();
+		return true;
+	}
+
+	private int getDay(Preferences pref, boolean useDefault) {
+		String day = useDefault ? pref.getDefaultString(AutomaticUpdateScheduler.P_DAY) : pref.getString(AutomaticUpdateScheduler.P_DAY);
+		for (int i = 0; i < AutomaticUpdateScheduler.DAYS.length; i++)
+			if (AutomaticUpdateScheduler.DAYS[i].equals(day))
+				return i;
+		return 0;
+	}
+
+	private int getHour(Preferences pref, boolean useDefault) {
+		String hour = useDefault ? pref.getDefaultString(AutomaticUpdateScheduler.P_HOUR) : pref.getString(AutomaticUpdateScheduler.P_HOUR);
+		for (int i = 0; i < AutomaticUpdateScheduler.HOURS.length; i++)
+			if (AutomaticUpdateScheduler.HOURS[i].equals(hour))
+				return i;
+		return 0;
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/ClassicUpdateInitializer.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/ClassicUpdateInitializer.java
new file mode 100644
index 0000000..3c1767e
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/ClassicUpdateInitializer.java
@@ -0,0 +1,51 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+import org.eclipse.core.runtime.Platform;
+import org.eclipse.core.runtime.Preferences;
+import org.eclipse.core.runtime.preferences.*;
+import org.eclipse.equinox.internal.provisional.p2.ui.ProvUI;
+import org.eclipse.ui.statushandlers.StatusManager;
+import org.osgi.service.prefs.BackingStoreException;
+
+public class ClassicUpdateInitializer extends AbstractPreferenceInitializer {
+
+	private static final String P_ENABLED = "enabled"; //$NON-NLS-1$
+	private static final String UPDATE_PLUGIN_ID = "org.eclipse.update.scheduler"; //$NON-NLS-1$
+
+	public void initializeDefaultPreferences() {
+		Preferences prefP2 = AutomaticUpdatePlugin.getDefault().getPluginPreferences();
+		//only migrate auto-update preference from UM once
+		boolean autoUpdateInit = prefP2.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_INIT);
+		if (!autoUpdateInit) {
+			// get UM automatic update preference
+			IPreferencesService preferencesService = Platform.getPreferencesService();
+			org.osgi.service.prefs.Preferences instanceScope = preferencesService.getRootNode().node(InstanceScope.SCOPE);
+			try {
+				boolean updateNodeExists = instanceScope.nodeExists(UPDATE_PLUGIN_ID);
+				org.osgi.service.prefs.Preferences prefUM = instanceScope.node(UPDATE_PLUGIN_ID);
+				boolean enableUpdate = prefUM.getBoolean(P_ENABLED, false);
+				// set p2 automatic update preference to match UM preference
+				prefP2.setValue(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, enableUpdate);
+				prefP2.setValue(PreferenceConstants.PREF_AUTO_UPDATE_INIT, true);
+				AutomaticUpdatePlugin.getDefault().savePluginPreferences();
+				// turn off UM automatic update preference if it exists
+				if (updateNodeExists) {
+					prefUM.putBoolean(P_ENABLED, false);
+					prefUM.flush();
+				}
+			} catch (BackingStoreException e) {
+				ProvUI.handleException(e, "Error saving classic update preferences", StatusManager.LOG); //$NON-NLS-1$
+			}
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/IAutomaticUpdaterHelpContextIds.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/IAutomaticUpdaterHelpContextIds.java
new file mode 100644
index 0000000..608b684
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/IAutomaticUpdaterHelpContextIds.java
@@ -0,0 +1,26 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+/**
+ * Help context ids for the P2 Automatic Updater.
+ * <p>
+ * This interface contains constants only; it is not intended to be implemented
+ * or extended.
+ * </p>
+ * @since 3.5
+ */
+
+public interface IAutomaticUpdaterHelpContextIds {
+	public static final String PREFIX = AutomaticUpdatePlugin.PLUGIN_ID + "."; //$NON-NLS-1$
+
+	public static final String AUTOMATIC_UPDATES_PREFERENCE_PAGE = PREFIX + "automatic_updates_preference_page_context"; //$NON-NLS-1$
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceConstants.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceConstants.java
new file mode 100644
index 0000000..91876d4
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceConstants.java
@@ -0,0 +1,26 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+/**
+ * @since 3.5
+ */
+public class PreferenceConstants {
+	public static final String PREF_PAGE_AUTO_UPDATES = "org.eclipse.equinox.internal.p2.ui.sdk.AutomaticUpdatesPreferencePage"; //$NON-NLS-1$
+	public static final String PREF_AUTO_UPDATE_ENABLED = "enabled"; //$NON-NLS-1$
+	public static final String PREF_AUTO_UPDATE_SCHEDULE = "schedule"; //$NON-NLS-1$
+	public static final String PREF_UPDATE_ON_STARTUP = "on-startup"; //$NON-NLS-1$
+	public static final String PREF_UPDATE_ON_SCHEDULE = "on-schedule"; //$NON-NLS-1$  // string value defined in AutomaticUpdateScheduler 
+	public static final String PREF_DOWNLOAD_ONLY = "download"; // value is true or false, default is false //$NON-NLS-1$
+	public static final String PREF_REMIND_SCHEDULE = "remindOnSchedule"; // value is true or false //$NON-NLS-1$
+	public static final String PREF_REMIND_ELAPSED = "remindElapsedTime";//$NON-NLS-1$
+	public static final String PREF_AUTO_UPDATE_INIT = "autoUpdateInit"; //$NON-NLS-1$
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
new file mode 100644
index 0000000..3a5ebff
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/PreferenceInitializer.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer;
+import org.eclipse.core.runtime.preferences.DefaultScope;
+import org.osgi.service.prefs.Preferences;
+
+/**
+ * @since 3.5
+ */
+public class PreferenceInitializer extends AbstractPreferenceInitializer {
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer#initializeDefaultPreferences()
+	 */
+	public void initializeDefaultPreferences() {
+		Preferences node = new DefaultScope().getNode(AutomaticUpdatePlugin.PLUGIN_ID);
+		node.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, false);
+		node.put(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_STARTUP);
+		node.putBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY, false);
+		node.putBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE, false);
+		node.put(PreferenceConstants.PREF_REMIND_ELAPSED, AutomaticUpdateMessages.AutomaticUpdateScheduler_30Minutes);
+	}
+
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/StatusLineCLabelContribution.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/StatusLineCLabelContribution.java
new file mode 100644
index 0000000..fc29111
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/StatusLineCLabelContribution.java
@@ -0,0 +1,133 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
+
+import org.eclipse.jface.action.*;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CLabel;
+import org.eclipse.swt.graphics.*;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Listener;
+
+/**
+ * @since 3.4
+ */
+public class StatusLineCLabelContribution extends ContributionItem {
+
+	public final static int DEFAULT_CHAR_WIDTH = 40;
+
+	private int charWidth;
+	private CLabel label;
+	private Image image;
+	private String text = ""; //$NON-NLS-1$
+	private int widthHint = -1;
+	private int heightHint = -1;
+
+	private Listener listener;
+	private int eventType;
+	private String tooltip;
+
+	public StatusLineCLabelContribution(String id, int charWidth) {
+		super(id);
+		this.charWidth = charWidth;
+		setVisible(false); // no text to start with
+	}
+
+	public void fill(Composite parent) {
+		label = new CLabel(parent, SWT.DEFAULT);
+		StatusLineLayoutData statusLineLayoutData = new StatusLineLayoutData();
+
+		if (widthHint < 0) {
+			GC gc = new GC(parent);
+			gc.setFont(parent.getFont());
+			FontMetrics fm = gc.getFontMetrics();
+			widthHint = fm.getAverageCharWidth() * charWidth;
+			heightHint = fm.getHeight();
+			gc.dispose();
+		}
+
+		statusLineLayoutData.widthHint = widthHint;
+		label.setLayoutData(statusLineLayoutData);
+		label.setText(text);
+		label.setImage(image);
+		if (listener != null) {
+			label.addListener(eventType, listener);
+		}
+		if (tooltip != null) {
+			label.setToolTipText(tooltip);
+		}
+
+		statusLineLayoutData = new StatusLineLayoutData();
+		statusLineLayoutData.heightHint = heightHint;
+	}
+
+	public void addListener(int type, Listener labelListener) {
+		this.eventType = type;
+		this.listener = labelListener;
+	}
+
+	public void setText(String text) {
+		if (text == null)
+			throw new NullPointerException();
+
+		this.text = text;
+
+		if (label != null && !label.isDisposed())
+			label.setText(this.text);
+
+		if (this.text.length() == 0) {
+			if (isVisible()) {
+				setVisible(false);
+				IContributionManager contributionManager = getParent();
+
+				if (contributionManager != null)
+					contributionManager.update(true);
+			}
+		} else {
+			if (!isVisible()) {
+				setVisible(true);
+				IContributionManager contributionManager = getParent();
+
+				if (contributionManager != null)
+					contributionManager.update(true);
+			}
+		}
+	}
+
+	public void setTooltip(String tooltip) {
+		if (tooltip == null)
+			throw new NullPointerException();
+
+		this.tooltip = tooltip;
+
+		if (label != null && !label.isDisposed()) {
+			label.setToolTipText(this.tooltip);
+		}
+	}
+
+	public void setImage(Image image) {
+		if (image == null)
+			throw new NullPointerException();
+
+		this.image = image;
+
+		if (label != null && !label.isDisposed())
+			label.setImage(this.image);
+
+		if (!isVisible()) {
+			setVisible(true);
+			IContributionManager contributionManager = getParent();
+
+			if (contributionManager != null)
+				contributionManager.update(true);
+		}
+	}
+}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/messages.properties b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/messages.properties
new file mode 100644
index 0000000..a40c7db
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/messages.properties
@@ -0,0 +1,69 @@
+###############################################################################
+# Copyright (c) 2007, 2008 IBM Corporation and others.
+# All rights reserved. This program and the accompanying materials
+# are made available under the terms of the Eclipse Public License v1.0
+# which accompanies this distribution, and is available at
+# http://www.eclipse.org/legal/epl-v10.html
+#
+# Contributors:
+#     IBM Corporation - initial API and implementation
+###############################################################################
+
+
+SchedulerStartup_day=Every day
+SchedulerStartup_Monday=Every Monday
+SchedulerStartup_Tuesday=Every Tuesday
+SchedulerStartup_Wednesday=Every Wednesday
+SchedulerStartup_Thursday=Every Thursday
+SchedulerStartup_Friday=Every Friday
+SchedulerStartup_Saturday=Every Saturday
+SchedulerStartup_Sunday=Every Sunday
+SchedulerStartup_1AM=1:00 AM
+SchedulerStartup_2AM=2:00 AM
+SchedulerStartup_3AM=3:00 AM
+SchedulerStartup_4AM=4:00 AM
+SchedulerStartup_5AM=5:00 AM
+SchedulerStartup_6AM=6:00 AM
+SchedulerStartup_7AM=7:00 AM
+SchedulerStartup_8AM=8:00 AM
+SchedulerStartup_9AM=9:00 AM
+SchedulerStartup_10AM=10:00 AM
+SchedulerStartup_11AM=11:00 AM
+SchedulerStartup_12PM=12:00 PM
+SchedulerStartup_1PM=1:00 PM
+SchedulerStartup_2PM=2:00 PM
+SchedulerStartup_3PM=3:00 PM
+SchedulerStartup_4PM=4:00 PM
+SchedulerStartup_5PM=5:00 PM
+SchedulerStartup_6PM=6:00 PM
+SchedulerStartup_7PM=7:00 PM
+SchedulerStartup_8PM=8:00 PM
+SchedulerStartup_9PM=9:00 PM
+SchedulerStartup_10PM=10:00 PM
+SchedulerStartup_11PM=11:00 PM
+SchedulerStartup_12AM=12:00 AM
+AutomaticUpdatesPopup_PrefLinkOnly=Set up <a>Reminder options</a>
+AutomaticUpdatesPopup_RemindAndPrefLink=You will be reminded in {0}.\nSet reminder <a href="{1}">preferences</a>
+AutomaticUpdatesPopup_ReminderJobTitle=Update reminder job
+AutomaticUpdatesPreferencePage_findUpdates=Automatically &find new updates and notify me
+AutomaticUpdateScheduler_30Minutes=30 minutes
+AutomaticUpdateScheduler_60Minutes=Hour
+AutomaticUpdateScheduler_240Minutes= 4 Hours
+AutomaticUpdateScheduler_UpdateNotInitialized=The update checker service is not initialized
+AutomaticUpdatesPopup_UpdatesAvailableTitle=Updates Available
+AutomaticUpdater_AutomaticDownloadOperationName=Automatic updates download
+AutomaticUpdater_ClickToReviewUpdates=Updates are available.  Click here to review and install them.
+AutomaticUpdater_ClickToReviewUpdatesWithProblems=Updates are available, but there may be some compatibility problems.  Click here to review them.
+AutomaticUpdater_ErrorCheckingUpdates=Unexpected error while checking the validity of updates.
+AutomaticUpdatesPreferencePage_UpdateSchedule=&Update schedule
+AutomaticUpdatesPreferencePage_findOnStart=Look for updates each time &platform is started
+AutomaticUpdatesPreferencePage_findOnSchedule=Look for updates on the following &schedule:
+AutomaticUpdatesPreferencePage_downloadOptions=&Download options
+AutomaticUpdatesPreferencePage_searchAndNotify=Search for updates and &notify me when they are available
+AutomaticUpdatesPreferencePage_downloadAndNotify=Download new updates &automatically and notify me when ready to install them
+AutomaticUpdatesPopup_ClickToReviewDownloaded=Software updates have been downloaded.\nClick to review and install updates.
+AutomaticUpdatesPopup_ClickToReviewNotDownloaded=Updates are available for your software.\nClick to review and install updates.
+AutomaticUpdatesPreferencePage_at=at
+AutomaticUpdatesPreferencePage_RemindGroup=&When updates are found
+AutomaticUpdatesPreferencePage_RemindSchedule=&Remind me about updates every:
+AutomaticUpdatesPreferencePage_RemindOnce=Notify me &once about updates
commit 1c110c067c146ee3c4ee51820d79eb881f14290c
Author: Susan Franklin <sfranklin>
Date:   Thu Nov 13 17:43:09 2008 +0000

    Bug 227582 - [ui] Should the early startup extension be separated from the rest of the UI plugin?

7	1	bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
1	0	bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
4	1	bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
2	0	bundles/org.eclipse.equinox.p2.metadata/META-INF/MANIFEST.MF
1	2	bundles/org.eclipse.equinox.p2.ui.sdk/META-INF/MANIFEST.MF
0	1	bundles/org.eclipse.equinox.p2.ui.sdk/plugin.properties
2	20	bundles/org.eclipse.equinox.p2.ui.sdk/plugin.xml
0	214	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/AutomaticUpdateScheduler.java
0	5	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/IProvSDKHelpContextIds.java
0	57	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKMessages.java
1	28	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKUIActivator.java
0	133	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/StatusLineCLabelContribution.java
0	57	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/messages.properties
0	297	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/AutomaticUpdatesPreferencePage.java
0	52	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/ClassicUpdateInitializer.java
0	9	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/PreferenceConstants.java
0	6	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/PreferenceInitializer.java
0	490	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/updates/AutomaticUpdater.java
0	297	bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/updates/AutomaticUpdatesPopup.java
10	1	bundles/org.eclipse.equinox.p2.ui/META-INF/MANIFEST.MF
3	3	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/DefaultQueryProvider.java
0	64	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/IUProfilePropertyByIdQuery.java
1	1	bundles/org.eclipse.equinox.p2.updatechecker/META-INF/MANIFEST.MF
7	0	org.eclipse.equinox.p2.releng/buildtime-features/org.eclipse.equinox.p2.user.ui/feature.xml
1	0	org.eclipse.equinox.p2.releng/projectSet-extssh.psf
1	0	org.eclipse.equinox.p2.releng/projectSet.psf
diff --git a/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
index 4f20342..92507e8 100644
--- a/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.core/META-INF/MANIFEST.MF
@@ -20,7 +20,9 @@ Import-Package: javax.xml.parsers,
  org.osgi.util.tracker;version="1.3.3",
  org.xml.sax,
  org.xml.sax.helpers
-Export-Package: org.eclipse.equinox.internal.p2.core;x-friends:="org.eclipse.equinox.p2.metadata.generator,org.eclipse.equinox.p2.publisher",
+Export-Package: org.eclipse.equinox.internal.p2.core;
+  x-friends:="org.eclipse.equinox.p2.metadata.generator,
+   org.eclipse.equinox.p2.publisher",
  org.eclipse.equinox.internal.p2.core.helpers;
   x-friends:="org.eclipse.equinox.p2.director,
    org.eclipse.equinox.p2.artifact.processors,
@@ -40,6 +42,7 @@ Export-Package: org.eclipse.equinox.internal.p2.core;x-friends:="org.eclipse.equ
    org.eclipse.equinox.p2.touchpoint.natives,
    org.eclipse.equinox.p2.ui,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.equinox.p2.updatechecker,
    org.eclipse.equinox.p2.updatechecker.app,
    org.eclipse.equinox.p2.garbagecollector,
@@ -69,6 +72,7 @@ Export-Package: org.eclipse.equinox.internal.p2.core;x-friends:="org.eclipse.equ
    org.eclipse.equinox.p2.ui,
    org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.equinox.p2.updatechecker,
    org.eclipse.equinox.p2.updatesite,
    org.eclipse.pde.ui",
@@ -80,6 +84,7 @@ Export-Package: org.eclipse.equinox.internal.p2.core;x-friends:="org.eclipse.equ
    org.eclipse.equinox.p2.director,
    org.eclipse.equinox.p2.garbagecollector,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.equinox.p2.ui,
    org.eclipse.equinox.p2.directorywatcher,
    org.eclipse.equinox.p2.updatesite,
@@ -144,6 +149,7 @@ Export-Package: org.eclipse.equinox.internal.p2.core;x-friends:="org.eclipse.equ
    org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.admin.rcp,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.equinox.p2.updatechecker,
    org.eclipse.equinox.p2.updatesite,
    org.eclipse.equinox.p2.console,
diff --git a/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
index 611b572..d3f327f 100644
--- a/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.director/META-INF/MANIFEST.MF
@@ -30,6 +30,7 @@ Export-Package: org.eclipse.equinox.internal.p2.director;x-friends:="org.eclipse
    org.eclipse.equinox.p2.ui,
    org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.equinox.p2.updatechecker,
    org.eclipse.pde.ui"
 Bundle-Activator: org.eclipse.equinox.internal.p2.director.DirectorActivator
diff --git a/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
index c86d6b5..00406ca 100644
--- a/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.engine/META-INF/MANIFEST.MF
@@ -5,7 +5,9 @@ Bundle-Name: %pluginName
 Bundle-Vendor: %providerName
 Bundle-Localization: plugin
 Bundle-Version: 1.0.100.qualifier
-Export-Package: org.eclipse.equinox.internal.p2.engine;x-friends:="org.eclipse.equinox.p2.touchpoint.eclipse,org.eclipse.equinox.p2.touchpoint.natives",
+Export-Package: org.eclipse.equinox.internal.p2.engine;
+  x-friends:="org.eclipse.equinox.p2.touchpoint.eclipse,
+   org.eclipse.equinox.p2.touchpoint.natives",
  org.eclipse.equinox.internal.provisional.p2.engine;
   x-friends:="org.eclipse.equinox.p2.console,
    org.eclipse.equinox.p2.director,
@@ -19,6 +21,7 @@ Export-Package: org.eclipse.equinox.internal.p2.engine;x-friends:="org.eclipse.e
    org.eclipse.equinox.p2.ui,
    org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.equinox.p2.updatechecker,
    org.eclipse.pde.ui",
  org.eclipse.equinox.internal.provisional.p2.engine.phases;x-friends:="org.eclipse.equinox.p2.ui"
diff --git a/bundles/org.eclipse.equinox.p2.metadata/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.metadata/META-INF/MANIFEST.MF
index 35b33fd..4c399df 100644
--- a/bundles/org.eclipse.equinox.p2.metadata/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.metadata/META-INF/MANIFEST.MF
@@ -39,6 +39,7 @@ Export-Package: org.eclipse.equinox.internal.p2.metadata;
    org.eclipse.equinox.p2.ui,
    org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.equinox.p2.updatechecker,
    org.eclipse.equinox.p2.updatesite,
    org.eclipse.pde.ui",
@@ -66,6 +67,7 @@ Export-Package: org.eclipse.equinox.internal.p2.metadata;
    org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.admin.rcp,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.equinox.p2.updatechecker,
    org.eclipse.equinox.p2.updatesite,
    org.eclipse.equinox.p2.console,
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.ui.sdk/META-INF/MANIFEST.MF
index eb5b19f..698a021 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/META-INF/MANIFEST.MF
@@ -31,8 +31,7 @@ Import-Package: org.eclipse.equinox.internal.p2.core.helpers,
  org.osgi.framework;version="1.3.0",
  org.osgi.service.packageadmin;version="1.2.0"
 Export-Package: org.eclipse.equinox.internal.p2.ui.sdk;x-internal:=true,
- org.eclipse.equinox.internal.p2.ui.sdk.prefs;x-internal:=true,
- org.eclipse.equinox.internal.p2.ui.sdk.updates;x-internal:=true
+ org.eclipse.equinox.internal.p2.ui.sdk.prefs;x-internal:=true
 Require-Bundle: org.eclipse.ui,
  org.eclipse.core.runtime,
  org.eclipse.equinox.p2.ui
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/plugin.properties b/bundles/org.eclipse.equinox.p2.ui.sdk/plugin.properties
index 920fa08..1a05204 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/plugin.properties
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/plugin.properties
@@ -25,7 +25,6 @@ TempInstallView.command=Installation Information...
 TempInstallView.mnemonic=I
 provisioningPrefPage = Install/Update
 installedSoftwarePage = Installed Software
-automaticUpdatesPrefPage = Automatic Updates
 externalFilesPrefPage = Updating from the File System
 preferenceKeywords.general=automatic update schedule download software install import bundle
 preferences=Update and Install Preferences
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/plugin.xml b/bundles/org.eclipse.equinox.p2.ui.sdk/plugin.xml
index 0137e5e..896f155 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/plugin.xml
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/plugin.xml
@@ -5,12 +5,7 @@
    		id="preferences" point="org.eclipse.core.runtime.preferences" name="%preferences">
 		<initializer class="org.eclipse.equinox.internal.p2.ui.sdk.prefs.PreferenceInitializer"/>
 	</extension>
-   <extension
-         point="org.eclipse.ui.startup">
-      <startup class="org.eclipse.equinox.internal.p2.ui.sdk.AutomaticUpdateScheduler">
-      </startup>
-   </extension>
- <extension
+  <extension
          point="org.eclipse.ui.propertyPages">
       <page
             name="%IU.copyright"
@@ -64,13 +59,6 @@
             <keywordReference id="org.eclipse.equinox.p2.ui.sdk.updates.general"/>
       </page>
  
-      <page
-            name="%automaticUpdatesPrefPage"
-            category="org.eclipse.equinox.internal.p2.ui.sdk.ProvisioningPreferencePage"
-            class="org.eclipse.equinox.internal.p2.ui.sdk.prefs.AutomaticUpdatesPreferencePage"
-            id="org.eclipse.equinox.internal.p2.ui.sdk.AutomaticUpdatesPreferencePage">
-            <keywordReference id="org.eclipse.equinox.p2.ui.sdk.updates.general"/>
-      </page>
    </extension>
 
       <extension
@@ -169,13 +157,7 @@
             categoryId="org.eclipse.equinox.p2.ui.sdk.category.classicUpdate">
       </categoryActivityBinding>
    </extension>
-   <extension
-         point="org.eclipse.core.runtime.preferences">
-      <initializer
-            class="org.eclipse.equinox.internal.p2.ui.sdk.prefs.ClassicUpdateInitializer">
-      </initializer>
-   </extension>
-     	<extension 
+      	<extension 
    		id="preferences" point="org.eclipse.core.runtime.preferences" name="%preferences">
 		<initializer class="org.eclipse.equinox.internal.p2.ui.sdk.prefs.PreferenceInitializer"/>
 	</extension>
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/AutomaticUpdateScheduler.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/AutomaticUpdateScheduler.java
deleted file mode 100644
index 09ae72e..0000000
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/AutomaticUpdateScheduler.java
+++ /dev/null
@@ -1,214 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.ui.sdk;
-
-import java.util.Calendar;
-import org.eclipse.core.runtime.*;
-import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
-import org.eclipse.equinox.internal.p2.ui.sdk.prefs.PreferenceConstants;
-import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
-import org.eclipse.equinox.internal.provisional.p2.ui.ElementQueryDescriptor;
-import org.eclipse.equinox.internal.provisional.p2.ui.ProvUI;
-import org.eclipse.equinox.internal.provisional.p2.ui.model.ProfileElement;
-import org.eclipse.equinox.internal.provisional.p2.ui.policy.Policy;
-import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker;
-import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener;
-import org.eclipse.ui.IStartup;
-import org.eclipse.ui.statushandlers.StatusManager;
-
-/**
- * This plug-in is loaded on startup to fork a job that searches for new
- * plug-ins.
- */
-public class AutomaticUpdateScheduler implements IStartup {
-	// values are to be picked up from the arrays DAYS and HOURS
-	public static final String P_DAY = "day"; //$NON-NLS-1$
-
-	public static final String P_HOUR = "hour"; //$NON-NLS-1$
-
-	public static final String[] DAYS = {ProvSDKMessages.SchedulerStartup_day, ProvSDKMessages.SchedulerStartup_Monday, ProvSDKMessages.SchedulerStartup_Tuesday, ProvSDKMessages.SchedulerStartup_Wednesday, ProvSDKMessages.SchedulerStartup_Thursday, ProvSDKMessages.SchedulerStartup_Friday, ProvSDKMessages.SchedulerStartup_Saturday, ProvSDKMessages.SchedulerStartup_Sunday};
-
-	public static final String[] HOURS = {ProvSDKMessages.SchedulerStartup_1AM, ProvSDKMessages.SchedulerStartup_2AM, ProvSDKMessages.SchedulerStartup_3AM, ProvSDKMessages.SchedulerStartup_4AM, ProvSDKMessages.SchedulerStartup_5AM, ProvSDKMessages.SchedulerStartup_6AM, ProvSDKMessages.SchedulerStartup_7AM, ProvSDKMessages.SchedulerStartup_8AM, ProvSDKMessages.SchedulerStartup_9AM, ProvSDKMessages.SchedulerStartup_10AM, ProvSDKMessages.SchedulerStartup_11AM, ProvSDKMessages.SchedulerStartup_12PM, ProvSDKMessages.SchedulerStartup_1PM, ProvSDKMessages.SchedulerStartup_2PM, ProvSDKMessages.SchedulerStartup_3PM, ProvSDKMessages.SchedulerStartup_4PM, ProvSDKMessages.SchedulerStartup_5PM, ProvSDKMessages.SchedulerStartup_6PM, ProvSDKMessages.SchedulerStartup_7PM,
-			ProvSDKMessages.SchedulerStartup_8PM, ProvSDKMessages.SchedulerStartup_9PM, ProvSDKMessages.SchedulerStartup_10PM, ProvSDKMessages.SchedulerStartup_11PM, ProvSDKMessages.SchedulerStartup_12AM,};
-
-	private IUpdateListener listener = null;
-	private IUpdateChecker checker = null;
-	private String profileId;
-
-	/**
-	 * The constructor.
-	 */
-	public AutomaticUpdateScheduler() {
-		ProvSDKUIActivator.getDefault().setScheduler(this);
-		checker = (IUpdateChecker) ServiceHelper.getService(ProvSDKUIActivator.getContext(), IUpdateChecker.SERVICE_NAME);
-		if (checker == null) {
-			// Something did not initialize properly
-			IStatus status = new Status(IStatus.ERROR, ProvSDKUIActivator.PLUGIN_ID, ProvSDKMessages.AutomaticUpdateScheduler_UpdateNotInitialized);
-			ProvUI.reportStatus(status, StatusManager.LOG);
-			return;
-		}
-		try {
-			profileId = ProvSDKUIActivator.getSelfProfileId();
-		} catch (ProvisionException e) {
-			profileId = null;
-			if (e.getStatus() != null)
-				ProvUI.reportStatus(e.getStatus(), StatusManager.LOG);
-			else
-				ProvUI.handleException(e, null, StatusManager.LOG);
-			return;
-		}
-
-	}
-
-	public void earlyStartup() {
-		scheduleUpdate();
-	}
-
-	public void shutdown() {
-		removeUpdateListener();
-	}
-
-	public void rescheduleUpdate() {
-		removeUpdateListener();
-		Preferences pref = ProvSDKUIActivator.getDefault().getPluginPreferences();
-		String schedule = pref.getString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE);
-		// See if we have a scheduled check or startup only.  If it is
-		// startup only, there is nothing more to do now, a listener will
-		// be created on the next startup.
-		if (schedule.equals(PreferenceConstants.PREF_UPDATE_ON_STARTUP)) {
-			return;
-		}
-		scheduleUpdate();
-	}
-
-	private void scheduleUpdate() {
-		// Nothing to do if we don't know what profile we are checking
-		if (profileId == null)
-			return;
-		Preferences pref = ProvSDKUIActivator.getDefault().getPluginPreferences();
-		// See if automatic search is enabled at all
-		if (pref.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED) == false)
-			return;
-		String schedule = pref.getString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE);
-		long delay = IUpdateChecker.ONE_TIME_CHECK;
-		long poll = IUpdateChecker.ONE_TIME_CHECK;
-		if (!schedule.equals(PreferenceConstants.PREF_UPDATE_ON_STARTUP)) {
-			delay = computeDelay(pref);
-			poll = computePoll(pref);
-		}
-		listener = ProvSDKUIActivator.getDefault().getAutomaticUpdater();
-		ElementQueryDescriptor descriptor = Policy.getDefault().getQueryProvider().getQueryDescriptor(new ProfileElement(null, profileId));
-		checker.addUpdateCheck(profileId, descriptor.query, delay, poll, listener);
-
-	}
-
-	private int getDay(Preferences pref) {
-		String day = pref.getString(P_DAY);
-		for (int d = 0; d < DAYS.length; d++)
-			if (DAYS[d].equals(day))
-				switch (d) {
-					case 0 :
-						return -1;
-					case 1 :
-						return Calendar.MONDAY;
-					case 2 :
-						return Calendar.TUESDAY;
-					case 3 :
-						return Calendar.WEDNESDAY;
-					case 4 :
-						return Calendar.THURSDAY;
-					case 5 :
-						return Calendar.FRIDAY;
-					case 6 :
-						return Calendar.SATURDAY;
-					case 7 :
-						return Calendar.SUNDAY;
-				}
-		return -1;
-	}
-
-	private int getHour(Preferences pref) {
-		String hour = pref.getString(P_HOUR);
-		for (int h = 0; h < HOURS.length; h++)
-			if (HOURS[h].equals(hour))
-				return h + 1;
-		return 1;
-	}
-
-	/*
-	 * Computes the number of milliseconds from this moment to the next
-	 * scheduled update check. If that moment has already passed, returns 0L (start
-	 * immediately).
-	 */
-	private long computeDelay(Preferences pref) {
-
-		int target_d = getDay(pref);
-		int target_h = getHour(pref);
-
-		Calendar calendar = Calendar.getInstance();
-		// may need to use the BootLoader locale
-		int current_d = calendar.get(Calendar.DAY_OF_WEEK);
-		// starts with SUNDAY
-		int current_h = calendar.get(Calendar.HOUR_OF_DAY);
-		int current_m = calendar.get(Calendar.MINUTE);
-		int current_s = calendar.get(Calendar.SECOND);
-		int current_ms = calendar.get(Calendar.MILLISECOND);
-
-		long delay = 0L; // milliseconds
-
-		if (target_d == -1) {
-			// Compute the delay for "every day at x o'clock"
-			// Is it now ?
-			if (target_h == current_h && current_m == 0 && current_s == 0)
-				return delay;
-
-			int delta_h = target_h - current_h;
-			if (target_h <= current_h)
-				delta_h += 24;
-			delay = ((delta_h * 60 - current_m) * 60 - current_s) * 1000 - current_ms;
-			return delay;
-		}
-		// Compute the delay for "every Xday at x o'clock"
-		// Is it now ?
-		if (target_d == current_d && target_h == current_h && current_m == 0 && current_s == 0)
-			return delay;
-
-		int delta_d = target_d - current_d;
-		if (target_d < current_d || target_d == current_d && (target_h < current_h || target_h == current_h && current_m > 0))
-			delta_d += 7;
-
-		delay = (((delta_d * 24 + target_h - current_h) * 60 - current_m) * 60 - current_s) * 1000 - current_ms;
-		return delay;
-	}
-
-	/*
-	 * Computes the number of milliseconds for the polling frequency.
-	 * We have already established that there is a schedule, vs. only
-	 * on startup.
-	 */
-	private long computePoll(Preferences pref) {
-
-		int target_d = getDay(pref);
-		if (target_d == -1) {
-			// Every 24 hours
-			return 24 * 60 * 60 * 1000;
-		}
-		return 7 * 24 * 60 * 60 * 1000;
-	}
-
-	private void removeUpdateListener() {
-		// Remove the current listener if there is one
-		if (listener != null && checker != null) {
-			checker.removeUpdateCheck(listener);
-			listener = null;
-		}
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/IProvSDKHelpContextIds.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/IProvSDKHelpContextIds.java
index 4cafce0..556b579 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/IProvSDKHelpContextIds.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/IProvSDKHelpContextIds.java
@@ -13,9 +13,4 @@ public interface IProvSDKHelpContextIds {
 	public static final String PREFIX = ProvSDKUIActivator.PLUGIN_ID + "."; //$NON-NLS-1$
 
 	public static final String PROVISIONING_PREFERENCE_PAGE = PREFIX + "provisioning_preference_page_context"; //$NON-NLS-1$
-
-	public static final String AUTOMATIC_UPDATES_PREFERENCE_PAGE = PREFIX + "automatic_updates_preference_page_context"; //$NON-NLS-1$
-
-	public static final String EXTERNAL_FILES_PREFERENCE_PAGE = PREFIX + "external_files_preference_page_context"; //$NON-NLS-1$
-
 }
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKMessages.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKMessages.java
index 6f92125..bc685b9 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKMessages.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKMessages.java
@@ -26,63 +26,6 @@ public class ProvSDKMessages extends NLS {
 	}
 	public static String Handler_CannotLaunchUI;
 	public static String Handler_SDKUpdateUIMessageTitle;
-	public static String SchedulerStartup_day;
-	public static String SchedulerStartup_Monday;
-	public static String SchedulerStartup_Tuesday;
-	public static String SchedulerStartup_Wednesday;
-	public static String SchedulerStartup_Thursday;
-	public static String SchedulerStartup_Friday;
-	public static String SchedulerStartup_Saturday;
-	public static String SchedulerStartup_Sunday;
-	public static String SchedulerStartup_1AM;
-	public static String SchedulerStartup_2AM;
-	public static String SchedulerStartup_3AM;
-	public static String SchedulerStartup_4AM;
-	public static String SchedulerStartup_5AM;
-	public static String SchedulerStartup_6AM;
-	public static String SchedulerStartup_7AM;
-	public static String SchedulerStartup_8AM;
-	public static String SchedulerStartup_9AM;
-	public static String SchedulerStartup_10AM;
-	public static String SchedulerStartup_11AM;
-	public static String SchedulerStartup_12PM;
-	public static String SchedulerStartup_1PM;
-	public static String SchedulerStartup_2PM;
-	public static String SchedulerStartup_3PM;
-	public static String SchedulerStartup_4PM;
-	public static String SchedulerStartup_5PM;
-	public static String SchedulerStartup_6PM;
-	public static String SchedulerStartup_7PM;
-	public static String SchedulerStartup_8PM;
-	public static String SchedulerStartup_9PM;
-	public static String SchedulerStartup_10PM;
-	public static String SchedulerStartup_11PM;
-	public static String SchedulerStartup_12AM;
-	public static String AutomaticUpdatesPopup_PrefLinkOnly;
-	public static String AutomaticUpdatesPopup_RemindAndPrefLink;
-	public static String AutomaticUpdatesPopup_ReminderJobTitle;
-	public static String AutomaticUpdatesPreferencePage_findUpdates;
-	public static String AutomaticUpdateScheduler_30Minutes;
-	public static String AutomaticUpdateScheduler_60Minutes;
-	public static String AutomaticUpdateScheduler_240Minutes;
-	public static String AutomaticUpdateScheduler_UpdateNotInitialized;
-	public static String AutomaticUpdatesPopup_UpdatesAvailableTitle;
-	public static String AutomaticUpdater_AutomaticDownloadOperationName;
-	public static String AutomaticUpdater_ClickToReviewUpdates;
-	public static String AutomaticUpdater_ClickToReviewUpdatesWithProblems;
-	public static String AutomaticUpdater_ErrorCheckingUpdates;
-	public static String AutomaticUpdatesPreferencePage_UpdateSchedule;
-	public static String AutomaticUpdatesPreferencePage_findOnStart;
-	public static String AutomaticUpdatesPreferencePage_findOnSchedule;
-	public static String AutomaticUpdatesPreferencePage_downloadOptions;
-	public static String AutomaticUpdatesPreferencePage_searchAndNotify;
-	public static String AutomaticUpdatesPreferencePage_downloadAndNotify;
-	public static String AutomaticUpdatesPreferencePage_at;
-	public static String AutomaticUpdatesPreferencePage_RemindGroup;
-	public static String AutomaticUpdatesPreferencePage_RemindSchedule;
-	public static String AutomaticUpdatesPreferencePage_RemindOnce;
-	public static String AutomaticUpdatesPopup_ClickToReviewDownloaded;
-	public static String AutomaticUpdatesPopup_ClickToReviewNotDownloaded;
 	public static String InstallNewSoftwareHandler_LoadRepositoryJobLabel;
 	public static String ProvisioningPreferencePage_AlwaysOpenWizard;
 	public static String ProvisioningPreferencePage_BrowsingPrefsGroup;
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKUIActivator.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKUIActivator.java
index 1daa57c..b59a575 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKUIActivator.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/ProvSDKUIActivator.java
@@ -13,7 +13,6 @@ package org.eclipse.equinox.internal.p2.ui.sdk;
 import java.io.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.equinox.internal.p2.ui.sdk.prefs.PreferenceConstants;
-import org.eclipse.equinox.internal.p2.ui.sdk.updates.AutomaticUpdater;
 import org.eclipse.equinox.internal.provisional.p2.core.IServiceUI;
 import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
 import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
@@ -45,8 +44,6 @@ public class ProvSDKUIActivator extends AbstractUIPlugin {
 	private static final String LICENSE_STORAGE = "licenses.xml"; //$NON-NLS-1$
 	private static ProvSDKUIActivator plugin;
 	private static BundleContext context;
-	private AutomaticUpdateScheduler scheduler;
-	private AutomaticUpdater updater;
 	private ServiceRegistration certificateUIRegistration;
 
 	private IPropertyChangeListener preferenceListener;
@@ -140,27 +137,12 @@ public class ProvSDKUIActivator extends AbstractUIPlugin {
 
 	public void stop(BundleContext bundleContext) throws Exception {
 		writeLicenseRegistry();
-		if (scheduler != null) {
-			scheduler.shutdown();
-			scheduler = null;
-		}
-		if (updater != null) {
-			updater.shutdown();
-			updater = null;
-		}
 		plugin = null;
 		certificateUIRegistration.unregister();
 		getPreferenceStore().removePropertyChangeListener(preferenceListener);
 		super.stop(bundleContext);
 	}
 
-	public AutomaticUpdateScheduler getScheduler() {
-		// If the scheduler was disabled, it does not get initialized
-		if (scheduler == null)
-			scheduler = new AutomaticUpdateScheduler();
-		return scheduler;
-	}
-
 	public IProvisioningEventBus getProvisioningEventBus() {
 		ServiceReference busReference = context.getServiceReference(IProvisioningEventBus.SERVICE_NAME);
 		if (busReference == null)
@@ -168,12 +150,6 @@ public class ProvSDKUIActivator extends AbstractUIPlugin {
 		return (IProvisioningEventBus) context.getService(busReference);
 	}
 
-	public AutomaticUpdater getAutomaticUpdater() {
-		if (updater == null)
-			updater = new AutomaticUpdater();
-		return updater;
-	}
-
 	/**
 	 * Get the id of the profile for the running system.  Throw a ProvisionException
 	 * if no self profile is available, unless configured to answer any
@@ -196,10 +172,6 @@ public class ProvSDKUIActivator extends AbstractUIPlugin {
 		return profile.getProfileId();
 	}
 
-	void setScheduler(AutomaticUpdateScheduler scheduler) {
-		this.scheduler = scheduler;
-	}
-
 	static IStatus getNoSelfProfileStatus() {
 		return new Status(IStatus.WARNING, PLUGIN_ID, ProvSDKMessages.ProvSDKUIActivator_NoSelfProfile);
 	}
@@ -265,6 +237,7 @@ public class ProvSDKUIActivator extends AbstractUIPlugin {
 				// nothing to do
 			}
 		queryContext.setVisibleAvailableIUProperty(IInstallableUnit.PROP_TYPE_GROUP);
+		// If this ever changes, we must change AutomaticUpdateSchedule.getProfileQuery()
 		queryContext.setVisibleInstalledIUProperty(IInstallableUnit.PROP_PROFILE_ROOT_IU);
 		queryContext.setArtifactRepositoryFlags(IRepositoryManager.REPOSITORIES_NON_SYSTEM);
 		queryContext.setMetadataRepositoryFlags(IRepositoryManager.REPOSITORIES_NON_SYSTEM);
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/StatusLineCLabelContribution.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/StatusLineCLabelContribution.java
deleted file mode 100644
index 7d222a0..0000000
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/StatusLineCLabelContribution.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.ui.sdk;
-
-import org.eclipse.jface.action.*;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.custom.CLabel;
-import org.eclipse.swt.graphics.*;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Listener;
-
-/**
- * @since 3.4
- */
-public class StatusLineCLabelContribution extends ContributionItem {
-
-	public final static int DEFAULT_CHAR_WIDTH = 40;
-
-	private int charWidth;
-	private CLabel label;
-	private Image image;
-	private String text = ""; //$NON-NLS-1$
-	private int widthHint = -1;
-	private int heightHint = -1;
-
-	private Listener listener;
-	private int eventType;
-	private String tooltip;
-
-	public StatusLineCLabelContribution(String id, int charWidth) {
-		super(id);
-		this.charWidth = charWidth;
-		setVisible(false); // no text to start with
-	}
-
-	public void fill(Composite parent) {
-		label = new CLabel(parent, SWT.DEFAULT);
-		StatusLineLayoutData statusLineLayoutData = new StatusLineLayoutData();
-
-		if (widthHint < 0) {
-			GC gc = new GC(parent);
-			gc.setFont(parent.getFont());
-			FontMetrics fm = gc.getFontMetrics();
-			widthHint = fm.getAverageCharWidth() * charWidth;
-			heightHint = fm.getHeight();
-			gc.dispose();
-		}
-
-		statusLineLayoutData.widthHint = widthHint;
-		label.setLayoutData(statusLineLayoutData);
-		label.setText(text);
-		label.setImage(image);
-		if (listener != null) {
-			label.addListener(eventType, listener);
-		}
-		if (tooltip != null) {
-			label.setToolTipText(tooltip);
-		}
-
-		statusLineLayoutData = new StatusLineLayoutData();
-		statusLineLayoutData.heightHint = heightHint;
-	}
-
-	public void addListener(int type, Listener labelListener) {
-		this.eventType = type;
-		this.listener = labelListener;
-	}
-
-	public void setText(String text) {
-		if (text == null)
-			throw new NullPointerException();
-
-		this.text = text;
-
-		if (label != null && !label.isDisposed())
-			label.setText(this.text);
-
-		if (this.text.length() == 0) {
-			if (isVisible()) {
-				setVisible(false);
-				IContributionManager contributionManager = getParent();
-
-				if (contributionManager != null)
-					contributionManager.update(true);
-			}
-		} else {
-			if (!isVisible()) {
-				setVisible(true);
-				IContributionManager contributionManager = getParent();
-
-				if (contributionManager != null)
-					contributionManager.update(true);
-			}
-		}
-	}
-
-	public void setTooltip(String tooltip) {
-		if (tooltip == null)
-			throw new NullPointerException();
-
-		this.tooltip = tooltip;
-
-		if (label != null && !label.isDisposed()) {
-			label.setToolTipText(this.tooltip);
-		}
-	}
-
-	public void setImage(Image image) {
-		if (image == null)
-			throw new NullPointerException();
-
-		this.image = image;
-
-		if (label != null && !label.isDisposed())
-			label.setImage(this.image);
-
-		if (!isVisible()) {
-			setVisible(true);
-			IContributionManager contributionManager = getParent();
-
-			if (contributionManager != null)
-				contributionManager.update(true);
-		}
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/messages.properties b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/messages.properties
index e5b7008..afda529 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/messages.properties
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/messages.properties
@@ -12,63 +12,6 @@
 
 Handler_CannotLaunchUI=Cannot launch the Update UI.  This installation has not been configured properly for Software Updates.
 Handler_SDKUpdateUIMessageTitle=Software Updates
-SchedulerStartup_day=Every day
-SchedulerStartup_Monday=Every Monday
-SchedulerStartup_Tuesday=Every Tuesday
-SchedulerStartup_Wednesday=Every Wednesday
-SchedulerStartup_Thursday=Every Thursday
-SchedulerStartup_Friday=Every Friday
-SchedulerStartup_Saturday=Every Saturday
-SchedulerStartup_Sunday=Every Sunday
-SchedulerStartup_1AM=1:00 AM
-SchedulerStartup_2AM=2:00 AM
-SchedulerStartup_3AM=3:00 AM
-SchedulerStartup_4AM=4:00 AM
-SchedulerStartup_5AM=5:00 AM
-SchedulerStartup_6AM=6:00 AM
-SchedulerStartup_7AM=7:00 AM
-SchedulerStartup_8AM=8:00 AM
-SchedulerStartup_9AM=9:00 AM
-SchedulerStartup_10AM=10:00 AM
-SchedulerStartup_11AM=11:00 AM
-SchedulerStartup_12PM=12:00 PM
-SchedulerStartup_1PM=1:00 PM
-SchedulerStartup_2PM=2:00 PM
-SchedulerStartup_3PM=3:00 PM
-SchedulerStartup_4PM=4:00 PM
-SchedulerStartup_5PM=5:00 PM
-SchedulerStartup_6PM=6:00 PM
-SchedulerStartup_7PM=7:00 PM
-SchedulerStartup_8PM=8:00 PM
-SchedulerStartup_9PM=9:00 PM
-SchedulerStartup_10PM=10:00 PM
-SchedulerStartup_11PM=11:00 PM
-SchedulerStartup_12AM=12:00 AM
-AutomaticUpdatesPopup_PrefLinkOnly=Set up <a>Reminder options</a>
-AutomaticUpdatesPopup_RemindAndPrefLink=You will be reminded in {0}.\nSet reminder <a href="{1}">preferences</a>
-AutomaticUpdatesPopup_ReminderJobTitle=Update reminder job
-AutomaticUpdatesPreferencePage_findUpdates=Automatically &find new updates and notify me
-AutomaticUpdateScheduler_30Minutes=30 minutes
-AutomaticUpdateScheduler_60Minutes=Hour
-AutomaticUpdateScheduler_240Minutes= 4 Hours
-AutomaticUpdateScheduler_UpdateNotInitialized=The update checker service is not initialized
-AutomaticUpdatesPopup_UpdatesAvailableTitle=Updates Available
-AutomaticUpdater_AutomaticDownloadOperationName=Automatic updates download
-AutomaticUpdater_ClickToReviewUpdates=Updates are available.  Click here to review and install them.
-AutomaticUpdater_ClickToReviewUpdatesWithProblems=Updates are available, but there may be some compatibility problems.  Click here to review them.
-AutomaticUpdater_ErrorCheckingUpdates=Unexpected error while checking the validity of updates.
-AutomaticUpdatesPreferencePage_UpdateSchedule=&Update schedule
-AutomaticUpdatesPreferencePage_findOnStart=Look for updates each time &platform is started
-AutomaticUpdatesPreferencePage_findOnSchedule=Look for updates on the following &schedule:
-AutomaticUpdatesPreferencePage_downloadOptions=&Download options
-AutomaticUpdatesPreferencePage_searchAndNotify=Search for updates and &notify me when they are available
-AutomaticUpdatesPreferencePage_downloadAndNotify=Download new updates &automatically and notify me when ready to install them
-AutomaticUpdatesPopup_ClickToReviewDownloaded=Software updates have been downloaded.\nClick to review and install updates.
-AutomaticUpdatesPopup_ClickToReviewNotDownloaded=Updates are available for your software.\nClick to review and install updates.
-AutomaticUpdatesPreferencePage_at=at
-AutomaticUpdatesPreferencePage_RemindGroup=&When updates are found
-AutomaticUpdatesPreferencePage_RemindSchedule=&Remind me about updates every:
-AutomaticUpdatesPreferencePage_RemindOnce=Notify me &once about updates
 InstallNewSoftwareHandler_LoadRepositoryJobLabel=Contacting Software Sites
 ProvSDKUIActivator_ErrorWritingLicenseRegistry=Error writing license registry.  Accepted licenses will not be remembered.
 ProvSDKUIActivator_LicenseManagerReadError=Error reading license registry.  Accepted licenses will not be remembered.
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/AutomaticUpdatesPreferencePage.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/AutomaticUpdatesPreferencePage.java
deleted file mode 100644
index 0694d02..0000000
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/AutomaticUpdatesPreferencePage.java
+++ /dev/null
@@ -1,297 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.ui.sdk.prefs;
-
-import org.eclipse.core.runtime.Preferences;
-import org.eclipse.equinox.internal.p2.ui.sdk.*;
-import org.eclipse.equinox.internal.p2.ui.sdk.updates.AutomaticUpdatesPopup;
-import org.eclipse.jface.dialogs.Dialog;
-import org.eclipse.jface.preference.PreferencePage;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.*;
-import org.eclipse.ui.*;
-
-public class AutomaticUpdatesPreferencePage extends PreferencePage implements IWorkbenchPreferencePage {
-
-	private Button enabledCheck;
-	private Button onStartupRadio, onScheduleRadio;
-	private Combo dayCombo;
-	private Label atLabel;
-	private Combo hourCombo;
-	private Button searchOnlyRadio, searchAndDownloadRadio;
-	private Button remindOnceRadio, remindScheduleRadio;
-	private Combo remindElapseCombo;
-	private Group updateScheduleGroup, downloadGroup, remindGroup;
-
-	public void init(IWorkbench workbench) {
-		// nothing to init
-	}
-
-	protected Control createContents(Composite parent) {
-		PlatformUI.getWorkbench().getHelpSystem().setHelp(parent, IProvSDKHelpContextIds.AUTOMATIC_UPDATES_PREFERENCE_PAGE);
-
-		Composite container = new Composite(parent, SWT.NULL);
-		GridLayout layout = new GridLayout();
-		layout.marginWidth = layout.marginHeight = 0;
-		container.setLayout(layout);
-
-		enabledCheck = new Button(container, SWT.CHECK);
-		enabledCheck.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_findUpdates);
-
-		createSpacer(container, 1);
-
-		updateScheduleGroup = new Group(container, SWT.NONE);
-		updateScheduleGroup.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_UpdateSchedule);
-		layout = new GridLayout();
-		layout.numColumns = 3;
-		updateScheduleGroup.setLayout(layout);
-		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
-		updateScheduleGroup.setLayoutData(gd);
-
-		onStartupRadio = new Button(updateScheduleGroup, SWT.RADIO);
-		onStartupRadio.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_findOnStart);
-		gd = new GridData();
-		gd.horizontalSpan = 3;
-		onStartupRadio.setLayoutData(gd);
-		onStartupRadio.addSelectionListener(new SelectionAdapter() {
-			public void widgetSelected(SelectionEvent e) {
-				pageChanged();
-			}
-		});
-
-		onScheduleRadio = new Button(updateScheduleGroup, SWT.RADIO);
-		onScheduleRadio.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_findOnSchedule);
-		gd = new GridData();
-		gd.horizontalSpan = 3;
-		onScheduleRadio.setLayoutData(gd);
-		onScheduleRadio.addSelectionListener(new SelectionAdapter() {
-			public void widgetSelected(SelectionEvent e) {
-				pageChanged();
-			}
-		});
-
-		dayCombo = new Combo(updateScheduleGroup, SWT.READ_ONLY);
-		dayCombo.setItems(AutomaticUpdateScheduler.DAYS);
-		gd = new GridData();
-		gd.widthHint = 200;
-		gd.horizontalIndent = 30;
-		dayCombo.setLayoutData(gd);
-
-		atLabel = new Label(updateScheduleGroup, SWT.NULL);
-		atLabel.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_at);
-
-		hourCombo = new Combo(updateScheduleGroup, SWT.READ_ONLY);
-		hourCombo.setItems(AutomaticUpdateScheduler.HOURS);
-		gd = new GridData();
-		hourCombo.setLayoutData(gd);
-
-		createSpacer(container, 1);
-
-		downloadGroup = new Group(container, SWT.NONE);
-		downloadGroup.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_downloadOptions);
-		layout = new GridLayout();
-		layout.numColumns = 3;
-		downloadGroup.setLayout(layout);
-		gd = new GridData(GridData.FILL_HORIZONTAL);
-		downloadGroup.setLayoutData(gd);
-
-		searchOnlyRadio = new Button(downloadGroup, SWT.RADIO);
-		searchOnlyRadio.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_searchAndNotify);
-		gd = new GridData();
-		gd.horizontalSpan = 3;
-		searchOnlyRadio.setLayoutData(gd);
-		searchOnlyRadio.addSelectionListener(new SelectionAdapter() {
-			public void widgetSelected(SelectionEvent e) {
-				pageChanged();
-			}
-		});
-
-		searchAndDownloadRadio = new Button(downloadGroup, SWT.RADIO);
-		searchAndDownloadRadio.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_downloadAndNotify);
-		gd = new GridData();
-		gd.horizontalSpan = 3;
-		searchAndDownloadRadio.setLayoutData(gd);
-		searchAndDownloadRadio.addSelectionListener(new SelectionAdapter() {
-			public void widgetSelected(SelectionEvent e) {
-				pageChanged();
-			}
-		});
-
-		createSpacer(container, 1);
-
-		remindGroup = new Group(container, SWT.NONE);
-		remindGroup.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_RemindGroup);
-		layout = new GridLayout();
-		layout.numColumns = 3;
-		remindGroup.setLayout(layout);
-		gd = new GridData(GridData.FILL_HORIZONTAL);
-		remindGroup.setLayoutData(gd);
-
-		remindOnceRadio = new Button(remindGroup, SWT.RADIO);
-		remindOnceRadio.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_RemindOnce);
-		gd = new GridData();
-		gd.horizontalSpan = 3;
-		remindOnceRadio.setLayoutData(gd);
-		remindOnceRadio.addSelectionListener(new SelectionAdapter() {
-			public void widgetSelected(SelectionEvent e) {
-				pageChanged();
-			}
-		});
-
-		remindScheduleRadio = new Button(remindGroup, SWT.RADIO);
-		remindScheduleRadio.setText(ProvSDKMessages.AutomaticUpdatesPreferencePage_RemindSchedule);
-		gd = new GridData();
-		gd.horizontalSpan = 3;
-		remindScheduleRadio.setLayoutData(gd);
-		remindScheduleRadio.addSelectionListener(new SelectionAdapter() {
-			public void widgetSelected(SelectionEvent e) {
-				pageChanged();
-			}
-		});
-
-		remindElapseCombo = new Combo(remindGroup, SWT.READ_ONLY);
-		remindElapseCombo.setItems(AutomaticUpdatesPopup.ELAPSED);
-
-		gd = new GridData();
-		gd.widthHint = 200;
-		gd.horizontalIndent = 30;
-		remindElapseCombo.setLayoutData(gd);
-
-		initialize();
-
-		enabledCheck.addSelectionListener(new SelectionAdapter() {
-			public void widgetSelected(SelectionEvent e) {
-				pageChanged();
-			}
-		});
-
-		Dialog.applyDialogFont(container);
-		return container;
-	}
-
-	protected void createSpacer(Composite composite, int columnSpan) {
-		Label label = new Label(composite, SWT.NONE);
-		GridData gd = new GridData();
-		gd.horizontalSpan = columnSpan;
-		label.setLayoutData(gd);
-	}
-
-	private void initialize() {
-		Preferences pref = ProvSDKUIActivator.getDefault().getPluginPreferences();
-		enabledCheck.setSelection(pref.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED));
-		setSchedule(pref.getString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE));
-
-		dayCombo.setText(AutomaticUpdateScheduler.DAYS[getDay(pref, false)]);
-		hourCombo.setText(AutomaticUpdateScheduler.HOURS[getHour(pref, false)]);
-
-		remindScheduleRadio.setSelection(pref.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
-		remindOnceRadio.setSelection(!pref.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
-		remindElapseCombo.setText(pref.getString(PreferenceConstants.PREF_REMIND_ELAPSED));
-		searchOnlyRadio.setSelection(!pref.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
-		searchAndDownloadRadio.setSelection(pref.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
-
-		pageChanged();
-	}
-
-	private void setSchedule(String value) {
-		if (value.equals(PreferenceConstants.PREF_UPDATE_ON_STARTUP))
-			onStartupRadio.setSelection(true);
-		else
-			onScheduleRadio.setSelection(true);
-	}
-
-	void pageChanged() {
-		boolean master = enabledCheck.getSelection();
-		updateScheduleGroup.setEnabled(master);
-		onStartupRadio.setEnabled(master);
-		onScheduleRadio.setEnabled(master);
-		dayCombo.setEnabled(master && onScheduleRadio.getSelection());
-		atLabel.setEnabled(master && onScheduleRadio.getSelection());
-		hourCombo.setEnabled(master && onScheduleRadio.getSelection());
-		downloadGroup.setEnabled(master);
-		searchOnlyRadio.setEnabled(master);
-		searchAndDownloadRadio.setEnabled(master);
-		remindGroup.setEnabled(master);
-		remindScheduleRadio.setEnabled(master);
-		remindOnceRadio.setEnabled(master);
-		remindElapseCombo.setEnabled(master && remindScheduleRadio.getSelection());
-	}
-
-	protected void performDefaults() {
-		super.performDefaults();
-		Preferences pref = ProvSDKUIActivator.getDefault().getPluginPreferences();
-		enabledCheck.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED));
-
-		setSchedule(pref.getDefaultString(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE));
-		onScheduleRadio.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE));
-
-		dayCombo.setText(AutomaticUpdateScheduler.DAYS[getDay(pref, true)]);
-		hourCombo.setText(AutomaticUpdateScheduler.HOURS[getHour(pref, true)]);
-
-		remindOnceRadio.setSelection(!pref.getDefaultBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
-		remindScheduleRadio.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE));
-		remindElapseCombo.setText(pref.getDefaultString(PreferenceConstants.PREF_REMIND_ELAPSED));
-
-		searchOnlyRadio.setSelection(!pref.getDefaultBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
-		searchAndDownloadRadio.setSelection(pref.getDefaultBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY));
-		pageChanged();
-	}
-
-	/** 
-	 * Method declared on IPreferencePage.
-	 * Subclasses should override
-	 */
-	public boolean performOk() {
-		Preferences pref = ProvSDKUIActivator.getDefault().getPluginPreferences();
-		pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, enabledCheck.getSelection());
-		if (onStartupRadio.getSelection())
-			pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_STARTUP);
-		else
-			pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_SCHEDULE);
-
-		if (remindScheduleRadio.getSelection()) {
-			pref.setValue(PreferenceConstants.PREF_REMIND_SCHEDULE, true);
-			pref.setValue(PreferenceConstants.PREF_REMIND_ELAPSED, remindElapseCombo.getText());
-		} else {
-			pref.setValue(PreferenceConstants.PREF_REMIND_SCHEDULE, false);
-		}
-
-		pref.setValue(AutomaticUpdateScheduler.P_DAY, dayCombo.getText());
-		pref.setValue(AutomaticUpdateScheduler.P_HOUR, hourCombo.getText());
-
-		pref.setValue(PreferenceConstants.PREF_DOWNLOAD_ONLY, searchAndDownloadRadio.getSelection());
-
-		ProvSDKUIActivator.getDefault().savePluginPreferences();
-
-		ProvSDKUIActivator.getDefault().getScheduler().rescheduleUpdate();
-		return true;
-	}
-
-	private int getDay(Preferences pref, boolean useDefault) {
-		String day = useDefault ? pref.getDefaultString(AutomaticUpdateScheduler.P_DAY) : pref.getString(AutomaticUpdateScheduler.P_DAY);
-		for (int i = 0; i < AutomaticUpdateScheduler.DAYS.length; i++)
-			if (AutomaticUpdateScheduler.DAYS[i].equals(day))
-				return i;
-		return 0;
-	}
-
-	private int getHour(Preferences pref, boolean useDefault) {
-		String hour = useDefault ? pref.getDefaultString(AutomaticUpdateScheduler.P_HOUR) : pref.getString(AutomaticUpdateScheduler.P_HOUR);
-		for (int i = 0; i < AutomaticUpdateScheduler.HOURS.length; i++)
-			if (AutomaticUpdateScheduler.HOURS[i].equals(hour))
-				return i;
-		return 0;
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/ClassicUpdateInitializer.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/ClassicUpdateInitializer.java
deleted file mode 100644
index f831e96..0000000
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/ClassicUpdateInitializer.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.ui.sdk.prefs;
-
-import org.eclipse.core.runtime.Platform;
-import org.eclipse.core.runtime.Preferences;
-import org.eclipse.core.runtime.preferences.*;
-import org.eclipse.equinox.internal.p2.ui.sdk.ProvSDKUIActivator;
-import org.eclipse.equinox.internal.provisional.p2.ui.ProvUI;
-import org.eclipse.ui.statushandlers.StatusManager;
-import org.osgi.service.prefs.BackingStoreException;
-
-public class ClassicUpdateInitializer extends AbstractPreferenceInitializer {
-
-	private static final String P_ENABLED = "enabled"; //$NON-NLS-1$
-	private static final String UPDATE_PLUGIN_ID = "org.eclipse.update.scheduler"; //$NON-NLS-1$
-
-	public void initializeDefaultPreferences() {
-		Preferences prefP2 = ProvSDKUIActivator.getDefault().getPluginPreferences();
-		//only migrate auto-update preference from UM once
-		boolean autoUpdateInit = prefP2.getBoolean(PreferenceConstants.PREF_AUTO_UPDATE_INIT);
-		if (!autoUpdateInit) {
-			// get UM automatic update preference
-			IPreferencesService preferencesService = Platform.getPreferencesService();
-			org.osgi.service.prefs.Preferences instanceScope = preferencesService.getRootNode().node(InstanceScope.SCOPE);
-			try {
-				boolean updateNodeExists = instanceScope.nodeExists(UPDATE_PLUGIN_ID);
-				org.osgi.service.prefs.Preferences prefUM = instanceScope.node(UPDATE_PLUGIN_ID);
-				boolean enableUpdate = prefUM.getBoolean(P_ENABLED, false);
-				// set p2 automatic update preference to match UM preference
-				prefP2.setValue(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, enableUpdate);
-				prefP2.setValue(PreferenceConstants.PREF_AUTO_UPDATE_INIT, true);
-				ProvSDKUIActivator.getDefault().savePluginPreferences();
-				// turn off UM automatic update preference if it exists
-				if (updateNodeExists) {
-					prefUM.putBoolean(P_ENABLED, false);
-					prefUM.flush();
-				}
-			} catch (BackingStoreException e) {
-				ProvUI.handleException(e, "Error saving classic update preferences", StatusManager.LOG); //$NON-NLS-1$
-			}
-		}
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/PreferenceConstants.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/PreferenceConstants.java
index de1e1d3..daf9f2c 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/PreferenceConstants.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/PreferenceConstants.java
@@ -15,15 +15,6 @@ package org.eclipse.equinox.internal.p2.ui.sdk.prefs;
  */
 public class PreferenceConstants {
 	public static final String PREF_PAGE_PROVISIONING = "org.eclipse.equinox.internal.p2.ui.sdk.ProvisioningPreferencePage"; //$NON-NLS-1$
-	public static final String PREF_PAGE_AUTO_UPDATES = "org.eclipse.equinox.internal.p2.ui.sdk.AutomaticUpdatesPreferencePage"; //$NON-NLS-1$
-	public static final String PREF_AUTO_UPDATE_ENABLED = "enabled"; //$NON-NLS-1$
-	public static final String PREF_AUTO_UPDATE_SCHEDULE = "schedule"; //$NON-NLS-1$
-	public static final String PREF_UPDATE_ON_STARTUP = "on-startup"; //$NON-NLS-1$
-	public static final String PREF_UPDATE_ON_SCHEDULE = "on-schedule"; //$NON-NLS-1$  // string value defined in AutomaticUpdateScheduler 
-	public static final String PREF_DOWNLOAD_ONLY = "download"; // value is true or false, default is false //$NON-NLS-1$
-	public static final String PREF_REMIND_SCHEDULE = "remindOnSchedule"; // value is true or false //$NON-NLS-1$
-	public static final String PREF_REMIND_ELAPSED = "remindElapsedTime";//$NON-NLS-1$
 	public static final String PREF_SHOW_LATEST_VERSION = "showLatestVersion"; //$NON-NLS-1$
 	public static final String PREF_OPEN_WIZARD_ON_ERROR_PLAN = "allowNonOKPlan"; //$NON-NLS-1$
-	public static final String PREF_AUTO_UPDATE_INIT = "autoUpdateInit"; //$NON-NLS-1$
 }
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/PreferenceInitializer.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/PreferenceInitializer.java
index 4158839..83c7f1a 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/PreferenceInitializer.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/prefs/PreferenceInitializer.java
@@ -12,7 +12,6 @@ package org.eclipse.equinox.internal.p2.ui.sdk.prefs;
 
 import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer;
 import org.eclipse.core.runtime.preferences.DefaultScope;
-import org.eclipse.equinox.internal.p2.ui.sdk.ProvSDKMessages;
 import org.eclipse.jface.dialogs.MessageDialogWithToggle;
 import org.osgi.service.prefs.Preferences;
 
@@ -26,12 +25,7 @@ public class PreferenceInitializer extends AbstractPreferenceInitializer {
 	 */
 	public void initializeDefaultPreferences() {
 		Preferences node = new DefaultScope().getNode("org.eclipse.equinox.p2.ui.sdk"); //$NON-NLS-1$
-		node.putBoolean(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, false);
-		node.put(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_STARTUP);
-		node.putBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY, false);
-		node.putBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE, false);
 		node.putBoolean(PreferenceConstants.PREF_SHOW_LATEST_VERSION, true);
-		node.put(PreferenceConstants.PREF_REMIND_ELAPSED, ProvSDKMessages.AutomaticUpdateScheduler_30Minutes);
 		node.put(PreferenceConstants.PREF_OPEN_WIZARD_ON_ERROR_PLAN, MessageDialogWithToggle.PROMPT);
 	}
 
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/updates/AutomaticUpdater.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/updates/AutomaticUpdater.java
deleted file mode 100644
index 2a6aa54..0000000
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/updates/AutomaticUpdater.java
+++ /dev/null
@@ -1,490 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.ui.sdk.updates;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.EventObject;
-import org.eclipse.core.runtime.*;
-import org.eclipse.core.runtime.jobs.*;
-import org.eclipse.equinox.internal.p2.ui.sdk.*;
-import org.eclipse.equinox.internal.p2.ui.sdk.prefs.PreferenceConstants;
-import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
-import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
-import org.eclipse.equinox.internal.provisional.p2.core.eventbus.ProvisioningListener;
-import org.eclipse.equinox.internal.provisional.p2.director.ProfileChangeRequest;
-import org.eclipse.equinox.internal.provisional.p2.director.ProvisioningPlan;
-import org.eclipse.equinox.internal.provisional.p2.engine.*;
-import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.internal.provisional.p2.ui.*;
-import org.eclipse.equinox.internal.provisional.p2.ui.actions.UpdateAction;
-import org.eclipse.equinox.internal.provisional.p2.ui.model.Updates;
-import org.eclipse.equinox.internal.provisional.p2.ui.operations.*;
-import org.eclipse.equinox.internal.provisional.p2.ui.policy.PlanValidator;
-import org.eclipse.equinox.internal.provisional.p2.ui.policy.Policy;
-import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener;
-import org.eclipse.equinox.internal.provisional.p2.updatechecker.UpdateEvent;
-import org.eclipse.jface.action.IStatusLineManager;
-import org.eclipse.jface.dialogs.MessageDialogWithToggle;
-import org.eclipse.jface.viewers.*;
-import org.eclipse.jface.window.Window;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.widgets.*;
-import org.eclipse.ui.*;
-import org.eclipse.ui.progress.WorkbenchJob;
-import org.eclipse.ui.statushandlers.StatusManager;
-
-/**
- * @since 3.4
- */
-public class AutomaticUpdater implements IUpdateListener {
-
-	/**
-	 * Overridden so that we can use the profile change request computations,
-	 * but we hide the resolution from the user and optionally suppress the
-	 * wizard if we are resolving for reasons other than user request.
-	 * 
-	 * @since 3.4
-	 *
-	 */
-	final class AutomaticUpdateAction extends UpdateAction {
-
-		private boolean suppressWizard = false;
-
-		AutomaticUpdateAction(ISelectionProvider selectionProvider, String profileId) {
-			super(Policy.getDefault(), selectionProvider, profileId, false);
-		}
-
-		void suppressWizard(boolean suppress) {
-			suppressWizard = suppress;
-		}
-
-		protected int performAction(IInstallableUnit[] ius, String targetProfileId, ProvisioningPlan plan) {
-			if (suppressWizard) {
-				setUpdateAffordanceState(plan != null && plan.getStatus().isOK());
-				return Window.OK;
-			}
-			return super.performAction(ius, targetProfileId, plan);
-		}
-
-		protected PlanValidator getPlanValidator() {
-			return new PlanValidator() {
-				public boolean continueWorkingWithPlan(ProvisioningPlan plan, Shell shell) {
-					if (alreadyValidated)
-						return true;
-					// In all other cases we return false, because clicking the popup will actually run the action.
-					// We are just checking prefs to determine whether to to show the popup or not.
-					String openPlan = prefs.getString(PreferenceConstants.PREF_OPEN_WIZARD_ON_ERROR_PLAN);
-					if (plan != null) {
-						// If the user cancelled the operation, don't continue
-						if (plan.getStatus().getSeverity() == IStatus.CANCEL)
-							return false;
-						boolean noError = plan.getStatus().getSeverity() != IStatus.ERROR;
-						if (noError || !(MessageDialogWithToggle.NEVER.equals(openPlan))) {
-							// Show the affordance if user prefers always opening a currentPlan or being prompted
-							// In this context, the affordance is the prompt.
-							if (updateAffordance == null)
-								createUpdateAffordance();
-							setUpdateAffordanceState(noError);
-							// If the user always wants to open invalid plans, or there is no error then go ahead and show
-							// the popup.
-							if ((noError || MessageDialogWithToggle.ALWAYS.equals(openPlan)) && popup == null)
-								createUpdatePopup();
-						} else {
-							// There is an error and the pref is NEVER, the user doesn't want to know about it
-							ProvUI.reportStatus(plan.getStatus(), StatusManager.LOG);
-						}
-					}
-					return false;
-				}
-			};
-		}
-	}
-
-	Preferences prefs;
-	StatusLineCLabelContribution updateAffordance;
-	AutomaticUpdateAction updateAction;
-	IStatusLineManager statusLineManager;
-	IInstallableUnit[] iusWithUpdates;
-	String profileId;
-	AutomaticUpdatesPopup popup;
-	ProvisioningListener profileChangeListener;
-	IJobChangeListener provisioningJobListener;
-	boolean alreadyValidated = false;
-	boolean alreadyDownloaded = false;
-	private static final String AUTO_UPDATE_STATUS_ITEM = "AutoUpdatesStatus"; //$NON-NLS-1$
-
-	public AutomaticUpdater() {
-		prefs = ProvSDKUIActivator.getDefault().getPluginPreferences();
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener#updatesAvailable(org.eclipse.equinox.internal.provisional.p2.updatechecker.UpdateEvent)
-	 */
-	public void updatesAvailable(final UpdateEvent event) {
-		final boolean download = prefs.getBoolean(PreferenceConstants.PREF_DOWNLOAD_ONLY);
-		profileId = event.getProfileId();
-		iusWithUpdates = event.getIUs();
-		validateUpdates(null, true);
-		alreadyDownloaded = false;
-
-		if (iusWithUpdates.length <= 0) {
-			clearUpdatesAvailable();
-			return;
-		}
-		registerProfileChangeListener();
-		registerProvisioningJobListener();
-
-		// Download the items if the preference dictates before
-		// showing the user that updates are available.
-		try {
-			if (download) {
-				ElementQueryDescriptor descriptor = Policy.getDefault().getQueryProvider().getQueryDescriptor(new Updates(event.getProfileId(), event.getIUs()));
-				IInstallableUnit[] replacements = (IInstallableUnit[]) descriptor.queryable.query(descriptor.query, descriptor.collector, null).toArray(IInstallableUnit.class);
-				if (replacements.length > 0) {
-					ProfileChangeRequest request = ProfileChangeRequest.createByProfileId(event.getProfileId());
-					request.removeInstallableUnits(iusWithUpdates);
-					request.addInstallableUnits(replacements);
-					final ProvisioningPlan plan = ProvisioningUtil.getPlanner().getProvisioningPlan(request, new ProvisioningContext(), null);
-					Job job = ProvisioningOperationRunner.schedule(new ProfileModificationOperation(ProvSDKMessages.AutomaticUpdater_AutomaticDownloadOperationName, event.getProfileId(), plan, new DownloadPhaseSet(), false), null, StatusManager.LOG);
-					job.addJobChangeListener(new JobChangeAdapter() {
-						public void done(IJobChangeEvent jobEvent) {
-							alreadyDownloaded = true;
-							IStatus status = jobEvent.getResult();
-							if (status.isOK()) {
-								createUpdateAction();
-								PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
-									public void run() {
-										updateAction.suppressWizard(true);
-										updateAction.performAction(iusWithUpdates, event.getProfileId(), plan);
-									}
-								});
-							} else if (status.getSeverity() != IStatus.CANCEL) {
-								ProvUI.reportStatus(status, StatusManager.LOG);
-							}
-						}
-					});
-				}
-			} else {
-				createUpdateAction();
-				PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
-					public void run() {
-						updateAction.suppressWizard(true);
-						updateAction.run();
-					}
-				});
-			}
-
-		} catch (ProvisionException e) {
-			ProvUI.handleException(e, ProvSDKMessages.AutomaticUpdater_ErrorCheckingUpdates, StatusManager.LOG);
-		}
-
-	}
-
-	/*
-	 * Validate that iusToBeUpdated is valid, and reset the cache.  
-	 * If isKnownToBeAvailable is false, then recheck that the update is
-	 * available.  isKnownToBeAvailable should be false when the update list 
-	 * might be stale (Reminding the user of updates may happen long
-	 * after the update check.  This reduces the risk of notifying the user
-	 * of updates and then not finding them .)
-	 */
-
-	void validateUpdates(IProgressMonitor monitor, boolean isKnownToBeAvailable) {
-		ArrayList list = new ArrayList();
-		for (int i = 0; i < iusWithUpdates.length; i++) {
-			try {
-				if (isKnownToBeAvailable || ProvisioningUtil.getPlanner().updatesFor(iusWithUpdates[i], new ProvisioningContext(), monitor).length > 0) {
-					if (validToUpdate(iusWithUpdates[i]))
-						list.add(iusWithUpdates[i]);
-				}
-			} catch (ProvisionException e) {
-				ProvUI.handleException(e, ProvSDKMessages.AutomaticUpdater_ErrorCheckingUpdates, StatusManager.LOG);
-				continue;
-			} catch (OperationCanceledException e) {
-				// Nothing to report
-			}
-		}
-		iusWithUpdates = (IInstallableUnit[]) list.toArray(new IInstallableUnit[list.size()]);
-	}
-
-	// A proposed update is valid if it is still visible to the user as an installed item (it is a root)
-	// and if it is not locked for updating.
-	private boolean validToUpdate(IInstallableUnit iu) {
-		int lock = IInstallableUnit.LOCK_NONE;
-		boolean isRoot = false;
-		try {
-			IProfile profile = ProvisioningUtil.getProfile(profileId);
-			String value = profile.getInstallableUnitProperty(iu, IInstallableUnit.PROP_PROFILE_LOCKED_IU);
-			if (value != null)
-				lock = Integer.parseInt(value);
-			value = profile.getInstallableUnitProperty(iu, IInstallableUnit.PROP_PROFILE_ROOT_IU);
-			isRoot = value == null ? false : Boolean.valueOf(value).booleanValue();
-		} catch (ProvisionException e) {
-			// ignore
-		} catch (NumberFormatException e) {
-			// ignore and assume no lock
-		}
-		return isRoot && (lock & IInstallableUnit.LOCK_UPDATE) == 0;
-	}
-
-	Shell getWorkbenchWindowShell() {
-		IWorkbenchWindow activeWindow = PlatformUI.getWorkbench().getActiveWorkbenchWindow();
-		return activeWindow != null ? activeWindow.getShell() : null;
-
-	}
-
-	IStatusLineManager getStatusLineManager() {
-		if (statusLineManager != null)
-			return statusLineManager;
-		IWorkbenchWindow activeWindow = PlatformUI.getWorkbench().getActiveWorkbenchWindow();
-		if (activeWindow == null)
-			return null;
-		// YUCK!  YUCK!  YUCK!
-		// IWorkbenchWindow does not define getStatusLineManager(), yet WorkbenchWindow does
-		try {
-			Method method = activeWindow.getClass().getDeclaredMethod("getStatusLineManager", new Class[0]); //$NON-NLS-1$
-			try {
-				Object statusLine = method.invoke(activeWindow, new Object[0]);
-				if (statusLine instanceof IStatusLineManager) {
-					statusLineManager = (IStatusLineManager) statusLine;
-					return statusLineManager;
-				}
-			} catch (InvocationTargetException e) {
-				// oh well
-			} catch (IllegalAccessException e) {
-				// I tried
-			}
-		} catch (NoSuchMethodException e) {
-			// can't blame us for trying.
-		}
-
-		IWorkbenchPartSite site = activeWindow.getActivePage().getActivePart().getSite();
-		if (site instanceof IViewSite) {
-			statusLineManager = ((IViewSite) site).getActionBars().getStatusLineManager();
-		} else if (site instanceof IEditorSite) {
-			statusLineManager = ((IEditorSite) site).getActionBars().getStatusLineManager();
-		}
-		return statusLineManager;
-	}
-
-	void updateStatusLine() {
-		IStatusLineManager manager = getStatusLineManager();
-		if (manager != null)
-			manager.update(true);
-	}
-
-	void createUpdateAffordance() {
-		updateAffordance = new StatusLineCLabelContribution(AUTO_UPDATE_STATUS_ITEM, 5);
-		updateAffordance.addListener(SWT.MouseDown, new Listener() {
-			public void handleEvent(Event event) {
-				launchUpdate();
-			}
-		});
-		IStatusLineManager manager = getStatusLineManager();
-		if (manager != null) {
-			manager.add(updateAffordance);
-			manager.update(true);
-		}
-	}
-
-	void setUpdateAffordanceState(boolean isValid) {
-		if (updateAffordance == null)
-			return;
-		if (isValid) {
-			updateAffordance.setTooltip(ProvSDKMessages.AutomaticUpdater_ClickToReviewUpdates);
-			updateAffordance.setImage(ProvUIImages.getImage(ProvUIImages.IMG_TOOL_UPDATE));
-		} else {
-			updateAffordance.setTooltip(ProvSDKMessages.AutomaticUpdater_ClickToReviewUpdatesWithProblems);
-			updateAffordance.setImage(ProvUIImages.getImage(ProvUIImages.IMG_TOOL_UPDATE_PROBLEMS));
-		}
-		IStatusLineManager manager = getStatusLineManager();
-		if (manager != null) {
-			manager.update(true);
-		}
-	}
-
-	void checkUpdateAffordanceEnablement() {
-		// We don't currently support enablement in the affordance,
-		// so we hide it if it should not be enabled.
-		if (updateAffordance == null)
-			return;
-		boolean shouldBeVisible = !ProvisioningOperationRunner.hasScheduledOperations();
-		if (updateAffordance.isVisible() != shouldBeVisible) {
-			IStatusLineManager manager = getStatusLineManager();
-			if (manager != null) {
-				updateAffordance.setVisible(shouldBeVisible);
-				manager.update(true);
-			}
-		}
-	}
-
-	void createUpdatePopup() {
-		popup = new AutomaticUpdatesPopup(getWorkbenchWindowShell(), alreadyDownloaded, prefs);
-		popup.open();
-
-	}
-
-	void createUpdateAction() {
-		if (updateAction == null)
-			updateAction = new AutomaticUpdateAction(getSelectionProvider(), profileId);
-	}
-
-	void clearUpdatesAvailable() {
-		if (updateAffordance != null) {
-			IStatusLineManager manager = getStatusLineManager();
-			if (manager != null) {
-				manager.remove(updateAffordance);
-				manager.update(true);
-			}
-			updateAffordance.dispose();
-			updateAffordance = null;
-		}
-		if (popup != null) {
-			popup.close(false);
-			popup = null;
-		}
-		alreadyValidated = false;
-	}
-
-	ISelectionProvider getSelectionProvider() {
-		return new ISelectionProvider() {
-
-			/* (non-Javadoc)
-			 * @see org.eclipse.jface.viewers.ISelectionProvider#addSelectionChangedListener(org.eclipse.jface.viewers.ISelectionChangedListener)
-			 */
-			public void addSelectionChangedListener(ISelectionChangedListener listener) {
-				// Ignore because the selection won't change 
-			}
-
-			/* (non-Javadoc)
-			 * @see org.eclipse.jface.viewers.ISelectionProvider#getSelection()
-			 */
-			public ISelection getSelection() {
-				return new StructuredSelection(iusWithUpdates);
-			}
-
-			/* (non-Javadoc)
-			 * @see org.eclipse.jface.viewers.ISelectionProvider#removeSelectionChangedListener(org.eclipse.jface.viewers.ISelectionChangedListener)
-			 */
-			public void removeSelectionChangedListener(ISelectionChangedListener listener) {
-				// ignore because the selection is static
-			}
-
-			/* (non-Javadoc)
-			 * @see org.eclipse.jface.viewers.ISelectionProvider#setSelection(org.eclipse.jface.viewers.ISelection)
-			 */
-			public void setSelection(ISelection sel) {
-				throw new UnsupportedOperationException("This ISelectionProvider is static, and cannot be modified."); //$NON-NLS-1$
-			}
-		};
-	}
-
-	public void launchUpdate() {
-		alreadyValidated = true;
-		updateAction.suppressWizard(false);
-		updateAction.run();
-	}
-
-	private void registerProfileChangeListener() {
-		if (profileChangeListener == null) {
-			profileChangeListener = new ProvisioningListener() {
-				public void notify(EventObject o) {
-					if (o instanceof ProfileEvent) {
-						ProfileEvent event = (ProfileEvent) o;
-						if (event.getReason() == ProfileEvent.CHANGED && profileId.equals(event.getProfileId())) {
-							validateUpdates();
-						}
-					}
-				}
-			};
-			IProvisioningEventBus bus = ProvSDKUIActivator.getDefault().getProvisioningEventBus();
-			if (bus != null)
-				bus.addListener(profileChangeListener);
-		}
-	}
-
-	private void registerProvisioningJobListener() {
-		if (provisioningJobListener == null) {
-			provisioningJobListener = new JobChangeAdapter() {
-				public void done(IJobChangeEvent event) {
-					IWorkbench workbench = PlatformUI.getWorkbench();
-					if (workbench == null || workbench.isClosing())
-						return;
-					if (workbench.getDisplay() == null)
-						return;
-					workbench.getDisplay().asyncExec(new Runnable() {
-						public void run() {
-							checkUpdateAffordanceEnablement();
-						}
-					});
-				}
-
-				public void scheduled(final IJobChangeEvent event) {
-					IWorkbench workbench = PlatformUI.getWorkbench();
-					if (workbench == null || workbench.isClosing())
-						return;
-					if (workbench.getDisplay() == null)
-						return;
-					workbench.getDisplay().asyncExec(new Runnable() {
-						public void run() {
-							checkUpdateAffordanceEnablement();
-						}
-					});
-				}
-			};
-			ProvisioningOperationRunner.addJobChangeListener(provisioningJobListener);
-		}
-	}
-
-	/*
-	 * The profile has changed.  Make sure our toUpdate list is
-	 * still valid and if there is nothing to update, get rid
-	 * of the update popup and affordance.
-	 */
-	void validateUpdates() {
-		Job validateJob = new WorkbenchJob("Update validate job") { //$NON-NLS-1$
-			public IStatus runInUIThread(IProgressMonitor monitor) {
-				if (monitor.isCanceled())
-					return Status.CANCEL_STATUS;
-				validateUpdates(monitor, false);
-				if (iusWithUpdates.length == 0)
-					clearUpdatesAvailable();
-				else {
-					createUpdateAction();
-					updateAction.suppressWizard(true);
-					updateAction.run();
-				}
-				return Status.OK_STATUS;
-			}
-		};
-		validateJob.setSystem(true);
-		validateJob.setPriority(Job.SHORT);
-		validateJob.schedule();
-	}
-
-	public void shutdown() {
-		if (provisioningJobListener != null) {
-			ProvisioningOperationRunner.removeJobChangeListener(provisioningJobListener);
-			provisioningJobListener = null;
-		}
-		if (profileChangeListener == null)
-			return;
-		IProvisioningEventBus bus = ProvSDKUIActivator.getDefault().getProvisioningEventBus();
-		if (bus != null)
-			bus.removeListener(profileChangeListener);
-		profileChangeListener = null;
-		statusLineManager = null;
-	}
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/updates/AutomaticUpdatesPopup.java b/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/updates/AutomaticUpdatesPopup.java
deleted file mode 100644
index e13c85b..0000000
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/src/org/eclipse/equinox/internal/p2/ui/sdk/updates/AutomaticUpdatesPopup.java
+++ /dev/null
@@ -1,297 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.ui.sdk.updates;
-
-import org.eclipse.core.runtime.*;
-import org.eclipse.core.runtime.Preferences.IPropertyChangeListener;
-import org.eclipse.core.runtime.Preferences.PropertyChangeEvent;
-import org.eclipse.core.runtime.jobs.Job;
-import org.eclipse.equinox.internal.p2.ui.sdk.ProvSDKMessages;
-import org.eclipse.equinox.internal.p2.ui.sdk.ProvSDKUIActivator;
-import org.eclipse.equinox.internal.p2.ui.sdk.prefs.PreferenceConstants;
-import org.eclipse.equinox.internal.provisional.p2.ui.ProvUIImages;
-import org.eclipse.jface.dialogs.IDialogSettings;
-import org.eclipse.jface.dialogs.PopupDialog;
-import org.eclipse.jface.layout.GridDataFactory;
-import org.eclipse.jface.preference.PreferenceDialog;
-import org.eclipse.osgi.util.NLS;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.*;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.graphics.Rectangle;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.*;
-import org.eclipse.ui.dialogs.PreferencesUtil;
-import org.eclipse.ui.progress.WorkbenchJob;
-
-/**
- * AutomaticUpdatesPopup is an async popup dialog for notifying
- * the user of updates.
- * 
- * @since 3.4
- */
-public class AutomaticUpdatesPopup extends PopupDialog {
-	public static final String[] ELAPSED = {ProvSDKMessages.AutomaticUpdateScheduler_30Minutes, ProvSDKMessages.AutomaticUpdateScheduler_60Minutes, ProvSDKMessages.AutomaticUpdateScheduler_240Minutes};
-	private static final long MINUTE = 60 * 1000L;
-	private static final String PREFS_HREF = "PREFS"; //$NON-NLS-1$
-	private static final String DIALOG_SETTINGS_SECTION = "AutomaticUpdatesPopup"; //$NON-NLS-1$
-	private static final int POPUP_OFFSET = 20;
-
-	Preferences prefs;
-	long remindDelay = -1L;
-	IPropertyChangeListener prefListener;
-	WorkbenchJob remindJob;
-	boolean downloaded;
-	Composite dialogArea;
-	Link remindLink;
-	MouseListener clickListener;
-
-	public AutomaticUpdatesPopup(Shell parentShell, boolean alreadyDownloaded, Preferences prefs) {
-		super(parentShell, PopupDialog.INFOPOPUPRESIZE_SHELLSTYLE | SWT.MODELESS, false, true, true, false, false, ProvSDKMessages.AutomaticUpdatesPopup_UpdatesAvailableTitle, null);
-		downloaded = alreadyDownloaded;
-		this.prefs = prefs;
-		remindDelay = computeRemindDelay();
-		clickListener = new MouseAdapter() {
-			public void mouseDown(MouseEvent e) {
-				ProvSDKUIActivator.getDefault().getAutomaticUpdater().launchUpdate();
-			}
-		};
-	}
-
-	protected Control createDialogArea(Composite parent) {
-		dialogArea = new Composite(parent, SWT.NONE);
-		dialogArea.setLayoutData(new GridData(GridData.FILL_BOTH));
-		GridLayout layout = new GridLayout();
-		layout.numColumns = 1;
-		dialogArea.setLayout(layout);
-		dialogArea.addMouseListener(clickListener);
-
-		// The "click to update" label
-		Label infoLabel = new Label(dialogArea, SWT.NONE);
-		if (downloaded)
-			infoLabel.setText(ProvSDKMessages.AutomaticUpdatesPopup_ClickToReviewDownloaded);
-		else
-			infoLabel.setText(ProvSDKMessages.AutomaticUpdatesPopup_ClickToReviewNotDownloaded);
-		infoLabel.setLayoutData(new GridData(GridData.FILL_BOTH));
-		infoLabel.addMouseListener(clickListener);
-
-		createRemindSection(dialogArea);
-
-		return dialogArea;
-
-	}
-
-	private void createRemindSection(Composite parent) {
-		remindLink = new Link(parent, SWT.MULTI | SWT.WRAP | SWT.RIGHT);
-		updateRemindText();
-		remindLink.addSelectionListener(new SelectionAdapter() {
-			public void widgetSelected(SelectionEvent e) {
-				PreferenceDialog dialog = PreferencesUtil.createPreferenceDialogOn(getShell(), PreferenceConstants.PREF_PAGE_AUTO_UPDATES, null, null);
-				dialog.open();
-
-			}
-		});
-		remindLink.setLayoutData(new GridData(GridData.FILL_BOTH));
-	}
-
-	private void updateRemindText() {
-		if (prefs.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE))
-			remindLink.setText(NLS.bind(ProvSDKMessages.AutomaticUpdatesPopup_RemindAndPrefLink, new String[] {prefs.getString(PreferenceConstants.PREF_REMIND_ELAPSED), PREFS_HREF}));
-		else
-			remindLink.setText(ProvSDKMessages.AutomaticUpdatesPopup_PrefLinkOnly);
-		remindLink.getParent().layout(true);
-	}
-
-	protected IDialogSettings getDialogBoundsSettings() {
-		IDialogSettings settings = ProvSDKUIActivator.getDefault().getDialogSettings();
-		IDialogSettings section = settings.getSection(DIALOG_SETTINGS_SECTION);
-		if (section == null) {
-			section = settings.addNewSection(DIALOG_SETTINGS_SECTION);
-		}
-		return section;
-	}
-
-	public int open() {
-		prefListener = new IPropertyChangeListener() {
-			public void propertyChange(PropertyChangeEvent event) {
-				handlePreferenceChange(event);
-			}
-		};
-		prefs.addPropertyChangeListener(prefListener);
-		return super.open();
-	}
-
-	public boolean close() {
-		return close(true);
-	}
-
-	public boolean close(boolean remind) {
-		if (remind && prefs.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE))
-			scheduleRemindJob();
-		else
-			cancelRemindJob();
-		if (prefListener != null) {
-			prefs.removePropertyChangeListener(prefListener);
-			prefListener = null;
-		}
-		return super.close();
-
-	}
-
-	void scheduleRemindJob() {
-		// Cancel any pending remind job if there is one
-		if (remindJob != null)
-			remindJob.cancel();
-		// If no updates have been found, there is nothing to remind
-		if (remindDelay < 0)
-			return;
-		remindJob = new WorkbenchJob(ProvSDKMessages.AutomaticUpdatesPopup_ReminderJobTitle) {
-			public IStatus runInUIThread(IProgressMonitor monitor) {
-				if (monitor.isCanceled())
-					return Status.CANCEL_STATUS;
-				open();
-				return Status.OK_STATUS;
-			}
-		};
-		remindJob.setSystem(true);
-		remindJob.setPriority(Job.INTERACTIVE);
-		remindJob.schedule(remindDelay);
-
-	}
-
-	/*
-	 * Computes the number of milliseconds for the delay
-	 * in reminding the user of updates
-	 */
-	long computeRemindDelay() {
-		if (prefs.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE)) {
-			String elapsed = prefs.getString(PreferenceConstants.PREF_REMIND_ELAPSED);
-			for (int d = 0; d < ELAPSED.length; d++)
-				if (ELAPSED[d].equals(elapsed))
-					switch (d) {
-						case 0 :
-							// 30 minutes
-							return 30 * MINUTE;
-						case 1 :
-							// 60 minutes
-							return 60 * MINUTE;
-						case 2 :
-							// 240 minutes
-							return 240 * MINUTE;
-					}
-		}
-		return -1L;
-	}
-
-	void cancelRemindJob() {
-		if (remindJob != null) {
-			remindJob.cancel();
-			remindJob = null;
-		}
-	}
-
-	protected void configureShell(Shell newShell) {
-		super.configureShell(newShell);
-		newShell.setText(ProvSDKMessages.AutomaticUpdatesPopup_UpdatesAvailableTitle);
-	}
-
-	/**
-	 * (non-Javadoc)
-	 * 
-	 * @see org.eclipse.jface.window.Window#getInitialLocation(org.eclipse.swt.graphics.Point)
-	 */
-	protected Point getInitialLocation(Point initialSize) {
-		Shell parent = getParentShell();
-		Point parentSize, parentLocation;
-
-		if (parent != null) {
-			parentSize = parent.getSize();
-			parentLocation = parent.getLocation();
-		} else {
-			Rectangle bounds = getShell().getDisplay().getBounds();
-			parentSize = new Point(bounds.width, bounds.height);
-			parentLocation = new Point(0, 0);
-		}
-		// We have to take parent location into account because SWT considers all
-		// shell locations to be in display coordinates, even if the shell is parented.
-		return new Point(parentSize.x - initialSize.x + parentLocation.x - POPUP_OFFSET, parentSize.y - initialSize.y + parentLocation.y - POPUP_OFFSET);
-	}
-
-	void handlePreferenceChange(PropertyChangeEvent event) {
-		if (PreferenceConstants.PREF_REMIND_SCHEDULE.equals(event.getProperty())) {
-			// Reminders turned on
-			if (prefs.getBoolean(PreferenceConstants.PREF_REMIND_SCHEDULE)) {
-				if (remindLink == null)
-					createRemindSection(dialogArea);
-				else {
-					updateRemindText();
-					getShell().layout(true, true);
-				}
-				computeRemindDelay();
-				scheduleRemindJob();
-			} else { // reminders turned off
-				if (remindLink != null) {
-					updateRemindText();
-					getShell().layout(true, true);
-				}
-				cancelRemindJob();
-			}
-		} else if (PreferenceConstants.PREF_REMIND_ELAPSED.equals(event.getProperty())) {
-			// Reminding schedule changed
-			computeRemindDelay();
-			scheduleRemindJob();
-		}
-	}
-
-	/*
-	 * Overridden so that clicking in the title menu area closes the dialog.
-	 * Also creates a close box menu in the title area.
-	 */
-	protected Control createTitleMenuArea(Composite parent) {
-		Composite titleComposite = (Composite) super.createTitleMenuArea(parent);
-		titleComposite.addMouseListener(clickListener);
-
-		ToolBar toolBar = new ToolBar(titleComposite, SWT.FLAT);
-		ToolItem closeButton = new ToolItem(toolBar, SWT.PUSH, 0);
-
-		GridDataFactory.fillDefaults().align(SWT.END, SWT.CENTER).applyTo(toolBar);
-		closeButton.setImage(ProvUIImages.getImage(ProvUIImages.IMG_TOOL_CLOSE));
-		closeButton.setHotImage(ProvUIImages.getImage(ProvUIImages.IMG_TOOL_CLOSE_HOT));
-		closeButton.addSelectionListener(new SelectionAdapter() {
-			public void widgetSelected(SelectionEvent e) {
-				close();
-			}
-		});
-		// See https://bugs.eclipse.org/bugs/show_bug.cgi?id=177183
-		toolBar.addMouseListener(new MouseAdapter() {
-			public void mouseDown(MouseEvent e) {
-				close();
-			}
-		});
-		return titleComposite;
-	}
-
-	/*
-	 * Overridden to adjust the span of the title label.
-	 * Reachy, reachy....
-	 * (non-Javadoc)
-	 * @see org.eclipse.jface.dialogs.PopupDialog#createTitleControl(org.eclipse.swt.widgets.Composite)
-	 */
-	protected Control createTitleControl(Composite parent) {
-		Control control = super.createTitleControl(parent);
-		Object data = control.getLayoutData();
-		if (data instanceof GridData) {
-			((GridData) data).horizontalSpan = 1;
-		}
-		return control;
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.ui/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.ui/META-INF/MANIFEST.MF
index bbf930b..1ab7303 100644
--- a/bundles/org.eclipse.equinox.p2.ui/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.ui/META-INF/MANIFEST.MF
@@ -39,27 +39,36 @@ Export-Package: org.eclipse.equinox.internal.p2.ui;x-internal:=true,
   x-friends:="org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.admin.rcp,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.pde.ui",
  org.eclipse.equinox.internal.provisional.p2.ui.actions;
   x-friends:="org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.admin.rcp,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.pde.ui",
  org.eclipse.equinox.internal.provisional.p2.ui.dialogs;
   x-friends:="org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.admin.rcp,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.pde.ui",
- org.eclipse.equinox.internal.provisional.p2.ui.model;x-friends:="org.eclipse.equinox.p2.ui.admin,org.eclipse.equinox.p2.ui.admin.rcp,org.eclipse.equinox.p2.ui.sdk",
+ org.eclipse.equinox.internal.provisional.p2.ui.model;
+  x-friends:="org.eclipse.equinox.p2.ui.admin,
+    org.eclipse.equinox.p2.ui.admin.rcp,
+    org.eclipse.equinox.p2.ui.sdk,
+    org.eclipse.equinox.p2.ui.sdk.scheduler",
  org.eclipse.equinox.internal.provisional.p2.ui.operations;
   x-friends:="org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.admin.rcp,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.pde.ui",
  org.eclipse.equinox.internal.provisional.p2.ui.policy;
   x-friends:="org.eclipse.equinox.p2.ui.admin,
    org.eclipse.equinox.p2.ui.admin.rcp,
    org.eclipse.equinox.p2.ui.sdk,
+   org.eclipse.equinox.p2.ui.sdk.scheduler,
    org.eclipse.pde.ui",
  org.eclipse.equinox.internal.provisional.p2.ui.viewers;x-friends:="org.eclipse.equinox.p2.ui.admin,org.eclipse.equinox.p2.ui.admin.rcp,org.eclipse.equinox.p2.ui.sdk"
 Require-Bundle: org.eclipse.ui,
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/DefaultQueryProvider.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/DefaultQueryProvider.java
index 770e1e2..de12ba9 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/DefaultQueryProvider.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/DefaultQueryProvider.java
@@ -80,7 +80,7 @@ public class DefaultQueryProvider extends QueryProvider {
 				if (hideInstalled && profileId != null) {
 					try {
 						IProfile profile = ProvisioningUtil.getProfile(profileId);
-						installedQueryDescriptor = new ElementQueryDescriptor(profile, new IUProfilePropertyByIdQuery(profile.getProfileId(), context.getVisibleInstalledIUProperty(), Boolean.toString(true)), new Collector());
+						installedQueryDescriptor = new ElementQueryDescriptor(profile, new IUProfilePropertyQuery(profile, context.getVisibleInstalledIUProperty(), Boolean.toString(true)), new Collector());
 					} catch (ProvisionException e) {
 						// just bail out, we won't try to query the installed
 						installedQueryDescriptor = null;
@@ -159,7 +159,7 @@ public class DefaultQueryProvider extends QueryProvider {
 					return null;
 				Collector collector;
 				if (toUpdate == null) {
-					collector = profile.query(new IUProfilePropertyByIdQuery(profile.getProfileId(), context.getVisibleInstalledIUProperty(), Boolean.toString(true)), new Collector(), null);
+					collector = profile.query(new IUProfilePropertyQuery(profile, context.getVisibleInstalledIUProperty(), Boolean.toString(true)), new Collector(), null);
 					toUpdate = (IInstallableUnit[]) collector.toArray(IInstallableUnit.class);
 				}
 				QueryableUpdates updateQueryable = new QueryableUpdates(toUpdate);
@@ -185,7 +185,7 @@ public class DefaultQueryProvider extends QueryProvider {
 					return new ElementQueryDescriptor(profile, new IUProfilePropertyQuery(profile, context.getVisibleInstalledIUProperty(), Boolean.toString(true)), new InstalledIUCollector(profile, element));
 
 				// Just a normal query of the installed IU's, query the profile and look for the visible ones
-				return new ElementQueryDescriptor(profile, new IUProfilePropertyByIdQuery(profile.getProfileId(), context.getVisibleInstalledIUProperty(), Boolean.toString(true)), new InstalledIUCollector(profile, element));
+				return new ElementQueryDescriptor(profile, new IUProfilePropertyQuery(profile, context.getVisibleInstalledIUProperty(), Boolean.toString(true)), new InstalledIUCollector(profile, element));
 			case QueryProvider.METADATA_REPOS :
 				if (element instanceof MetadataRepositories) {
 					if (queryable == null) {
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/IUProfilePropertyByIdQuery.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/IUProfilePropertyByIdQuery.java
deleted file mode 100644
index f2bd638..0000000
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/IUProfilePropertyByIdQuery.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.ui;
-
-import java.util.Iterator;
-import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
-import org.eclipse.equinox.internal.provisional.p2.engine.IProfile;
-import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.internal.provisional.p2.metadata.query.IUPropertyQuery;
-import org.eclipse.equinox.internal.provisional.p2.query.Collector;
-import org.eclipse.equinox.internal.provisional.p2.ui.operations.ProvisioningUtil;
-
-/**
- * A query that searches for {@link IInstallableUnit} instances that have
- * a property associated with the specified profile, whose value matches the provided value.
- * Uses the profile id instead of the profile to reference the profile.
- * The profile instance is cached only during the duration of the query.
- * This query is used instead of IUProfilePropertyQuery because we pass
- * this query to the automatic update checker and it will be referenced during
- * the life of the platform.  
- */
-public class IUProfilePropertyByIdQuery extends IUPropertyQuery {
-	private String profileId;
-	private IProfile cachedProfile;
-
-	/**
-	 * Creates a new query on the given property name and value.
-	 */
-	public IUProfilePropertyByIdQuery(String profileId, String propertyName, String propertyValue) {
-		super(propertyName, propertyValue);
-		this.profileId = profileId;
-	}
-
-	protected String getProperty(IInstallableUnit iu, String name) {
-		IProfile profile = getProfile();
-		if (profile == null)
-			return null;
-		return profile.getInstallableUnitProperty(iu, name);
-	}
-
-	private IProfile getProfile() {
-		if (cachedProfile == null)
-			try {
-				cachedProfile = ProvisioningUtil.getProfile(profileId);
-			} catch (ProvisionException e) {
-				// ignore, this will return null
-			}
-		return cachedProfile;
-	}
-
-	public Collector perform(Iterator iterator, Collector result) {
-		Collector collector = super.perform(iterator, result);
-		cachedProfile = null;
-		return collector;
-	}
-}
diff --git a/bundles/org.eclipse.equinox.p2.updatechecker/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.updatechecker/META-INF/MANIFEST.MF
index cccc891..e408194 100644
--- a/bundles/org.eclipse.equinox.p2.updatechecker/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.updatechecker/META-INF/MANIFEST.MF
@@ -20,5 +20,5 @@ Import-Package: org.eclipse.equinox.internal.p2.core.helpers,
 Bundle-RequiredExecutionEnvironment: CDC-1.1/Foundation-1.1,
  J2SE-1.3
 Export-Package: org.eclipse.equinox.internal.p2.updatechecker;x-internal:=true,
- org.eclipse.equinox.internal.provisional.p2.updatechecker;x-friends:="org.eclipse.equinox.p2.ui,org.eclipse.equinox.p2.ui.sdk,org.eclipse.equinox.p2.ui.admin"
+ org.eclipse.equinox.internal.provisional.p2.updatechecker;x-friends:="org.eclipse.equinox.p2.ui.sdk.scheduler"
 Require-Bundle: org.eclipse.equinox.common;bundle-version="[3.3.0,4.0)"
diff --git a/org.eclipse.equinox.p2.releng/buildtime-features/org.eclipse.equinox.p2.user.ui/feature.xml b/org.eclipse.equinox.p2.releng/buildtime-features/org.eclipse.equinox.p2.user.ui/feature.xml
index e9b0f53..a3ff076 100644
--- a/org.eclipse.equinox.p2.releng/buildtime-features/org.eclipse.equinox.p2.user.ui/feature.xml
+++ b/org.eclipse.equinox.p2.releng/buildtime-features/org.eclipse.equinox.p2.user.ui/feature.xml
@@ -163,6 +163,13 @@
          unpack="false"/>
 
    <plugin
+         id="org.eclipse.equinox.p2.ui.sdk.scheduler"
+         download-size="0"
+         install-size="0"
+         version="0.0.0"
+         unpack="false"/>
+
+   <plugin
          id="org.eclipse.equinox.p2.updatechecker"
          download-size="0"
          install-size="0"
diff --git a/org.eclipse.equinox.p2.releng/projectSet-extssh.psf b/org.eclipse.equinox.p2.releng/projectSet-extssh.psf
index 88e5d75..4505261 100644
--- a/org.eclipse.equinox.p2.releng/projectSet-extssh.psf
+++ b/org.eclipse.equinox.p2.releng/projectSet-extssh.psf
@@ -38,6 +38,7 @@
 <project reference="1.0,:extssh:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.ui,org.eclipse.equinox.p2.ui"/>
 <project reference="1.0,:extssh:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.ui.admin,org.eclipse.equinox.p2.ui.admin"/>
 <project reference="1.0,:extssh:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.ui.sdk,org.eclipse.equinox.p2.ui.sdk"/>
+<project reference="1.0,:extssh:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler,org.eclipse.equinox.p2.ui.sdk.scheduler"/>
 <project reference="1.0,:extssh:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.ui.admin.rcp,org.eclipse.equinox.p2.ui.admin.rcp"/>
 <project reference="1.0,:extssh:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.updatechecker,org.eclipse.equinox.p2.updatechecker"/>
 <project reference="1.0,:extssh:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.updatesite,org.eclipse.equinox.p2.updatesite"/>
diff --git a/org.eclipse.equinox.p2.releng/projectSet.psf b/org.eclipse.equinox.p2.releng/projectSet.psf
index feb7826..4bcd25a 100644
--- a/org.eclipse.equinox.p2.releng/projectSet.psf
+++ b/org.eclipse.equinox.p2.releng/projectSet.psf
@@ -38,6 +38,7 @@
 <project reference="1.0,:pserver:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.ui,org.eclipse.equinox.p2.ui"/>
 <project reference="1.0,:pserver:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.ui.admin,org.eclipse.equinox.p2.ui.admin"/>
 <project reference="1.0,:pserver:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.ui.sdk,org.eclipse.equinox.p2.ui.sdk"/>
+<project reference="1.0,:pserver:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler,org.eclipse.equinox.p2.ui.sdk.scheduler"/>
 <project reference="1.0,:pserver:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.ui.admin.rcp,org.eclipse.equinox.p2.ui.admin.rcp"/>
 <project reference="1.0,:pserver:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.updatechecker,org.eclipse.equinox.p2.updatechecker"/>
 <project reference="1.0,:pserver:dev.eclipse.org:/cvsroot/rt,org.eclipse.equinox/p2/bundles/org.eclipse.equinox.p2.updatesite,org.eclipse.equinox.p2.updatesite"/>
commit a2bb7f2962928c6ec49f002d14b6d1ec39808b99
Author: Susan Franklin <sfranklin>
Date:   Thu Nov 13 21:11:24 2008 +0000

    Bug 227582 - [ui] Should the early startup extension be separated from the rest of the UI plugin?

2	1	bundles/org.eclipse.equinox.p2.tools/src/org/eclipse/equinox/internal/p2/tools/UpdateCheckerApplication.java
2	1	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/META-INF/MANIFEST.MF
7	1	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
0	1	bundles/org.eclipse.equinox.p2.ui.sdk/META-INF/MANIFEST.MF
0	1	bundles/org.eclipse.equinox.p2.ui/META-INF/MANIFEST.MF
1	1	bundles/org.eclipse.equinox.p2.updatechecker/META-INF/MANIFEST.MF
3	5	bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/p2/updatechecker/Activator.java
0	184	bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/p2/updatechecker/UpdateChecker.java
184	0	bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/provisional/p2/updatechecker/UpdateChecker.java
diff --git a/bundles/org.eclipse.equinox.p2.tools/src/org/eclipse/equinox/internal/p2/tools/UpdateCheckerApplication.java b/bundles/org.eclipse.equinox.p2.tools/src/org/eclipse/equinox/internal/p2/tools/UpdateCheckerApplication.java
index 17fa88c..d7b7829 100644
--- a/bundles/org.eclipse.equinox.p2.tools/src/org/eclipse/equinox/internal/p2/tools/UpdateCheckerApplication.java
+++ b/bundles/org.eclipse.equinox.p2.tools/src/org/eclipse/equinox/internal/p2/tools/UpdateCheckerApplication.java
@@ -10,11 +10,12 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.tools;
 
+import org.eclipse.equinox.internal.provisional.p2.updatechecker.UpdateChecker;
+
 import java.util.Map;
 import org.eclipse.equinox.app.IApplication;
 import org.eclipse.equinox.app.IApplicationContext;
 import org.eclipse.equinox.internal.p2.core.helpers.ServiceHelper;
-import org.eclipse.equinox.internal.p2.updatechecker.UpdateChecker;
 import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
 import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
 import org.eclipse.equinox.internal.provisional.p2.updatechecker.*;
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/META-INF/MANIFEST.MF
index 51a523a..f0f8bdb 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/META-INF/MANIFEST.MF
@@ -29,7 +29,8 @@ Import-Package: org.eclipse.equinox.internal.p2.core.helpers,
  org.osgi.service.packageadmin;version="1.2.0"
 Export-Package: org.eclipse.equinox.internal.p2.ui.sdk.scheduler;x-internal:=true
 Require-Bundle: org.eclipse.ui,
- org.eclipse.core.runtime
+ org.eclipse.core.runtime,
+ org.eclipse.equinox.p2.updatechecker
 Eclipse-LazyStart: true
 Bundle-RequiredExecutionEnvironment: J2SE-1.4,
  CDC-1.1/Foundation-1.1
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
index c78d69f..0b4e3c2 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
@@ -11,9 +11,12 @@
 package org.eclipse.equinox.internal.p2.ui.sdk.scheduler;
 
 import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEventBus;
+import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker;
+import org.eclipse.equinox.internal.provisional.p2.updatechecker.UpdateChecker;
 import org.eclipse.ui.plugin.AbstractUIPlugin;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.ServiceReference;
+import org.osgi.framework.ServiceRegistration;
 
 /**
  * Activator class for the automatic updates plugin
@@ -24,6 +27,7 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 	private static BundleContext context;
 	private AutomaticUpdateScheduler scheduler;
 	private AutomaticUpdater updater;
+	private ServiceRegistration registrationChecker;
 
 	public static final String PLUGIN_ID = "org.eclipse.equinox.p2.ui.sdk.scheduler"; //$NON-NLS-1$
 
@@ -52,7 +56,8 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 	public void start(BundleContext bundleContext) throws Exception {
 		super.start(bundleContext);
 		plugin = this;
-		AutomaticUpdatePlugin.context = bundleContext;
+		context = bundleContext;
+		registrationChecker = context.registerService(IUpdateChecker.SERVICE_NAME, new UpdateChecker(), null);
 	}
 
 	public void stop(BundleContext bundleContext) throws Exception {
@@ -66,6 +71,7 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 		}
 		plugin = null;
 		super.stop(bundleContext);
+		context = null;
 	}
 
 	public AutomaticUpdateScheduler getScheduler() {
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.ui.sdk/META-INF/MANIFEST.MF
index 698a021..f2c6bf4 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk/META-INF/MANIFEST.MF
@@ -25,7 +25,6 @@ Import-Package: org.eclipse.equinox.internal.p2.core.helpers,
  org.eclipse.equinox.internal.provisional.p2.ui.operations,
  org.eclipse.equinox.internal.provisional.p2.ui.policy,
  org.eclipse.equinox.internal.provisional.p2.ui.viewers,
- org.eclipse.equinox.internal.provisional.p2.updatechecker,
  org.eclipse.osgi.service.resolver;version="1.1.0",
  org.eclipse.osgi.util;version="1.1.0",
  org.osgi.framework;version="1.3.0",
diff --git a/bundles/org.eclipse.equinox.p2.ui/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.ui/META-INF/MANIFEST.MF
index 1ab7303..6c622c2 100644
--- a/bundles/org.eclipse.equinox.p2.ui/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.ui/META-INF/MANIFEST.MF
@@ -24,7 +24,6 @@ Import-Package: com.ibm.icu.text,
  org.eclipse.equinox.internal.provisional.p2.metadata.query,
  org.eclipse.equinox.internal.provisional.p2.metadata.repository,
  org.eclipse.equinox.internal.provisional.p2.query,
- org.eclipse.equinox.internal.provisional.p2.updatechecker,
  org.eclipse.equinox.internal.provisional.spi.p2.core.repository,
  org.eclipse.osgi.service.resolver;version="1.1.0",
  org.eclipse.osgi.util;version="1.1.0",
diff --git a/bundles/org.eclipse.equinox.p2.updatechecker/META-INF/MANIFEST.MF b/bundles/org.eclipse.equinox.p2.updatechecker/META-INF/MANIFEST.MF
index e408194..3c83990 100644
--- a/bundles/org.eclipse.equinox.p2.updatechecker/META-INF/MANIFEST.MF
+++ b/bundles/org.eclipse.equinox.p2.updatechecker/META-INF/MANIFEST.MF
@@ -4,7 +4,7 @@ Bundle-SymbolicName: org.eclipse.equinox.p2.updatechecker;singleton:=true
 Bundle-Name: %pluginName
 Bundle-Vendor: %providerName
 Bundle-Localization: plugin
-Bundle-Version: 1.0.0.qualifier
+Bundle-Version: 1.1.0.qualifier
 Bundle-Activator: org.eclipse.equinox.internal.p2.updatechecker.Activator
 Import-Package: org.eclipse.equinox.internal.p2.core.helpers,
  org.eclipse.equinox.internal.provisional.p2.artifact.repository,
diff --git a/bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/p2/updatechecker/Activator.java b/bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/p2/updatechecker/Activator.java
index d6a6e1f..afbdf8f 100644
--- a/bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/p2/updatechecker/Activator.java
+++ b/bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/p2/updatechecker/Activator.java
@@ -10,8 +10,8 @@
  *******************************************************************************/
 package org.eclipse.equinox.internal.p2.updatechecker;
 
-import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker;
-import org.osgi.framework.*;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
 
 /**
  * Activator class that registers the update checker service.
@@ -19,7 +19,6 @@ import org.osgi.framework.*;
 public class Activator implements BundleActivator {
 	public static final String ID = "org.eclipse.equinox.p2.updatechecker"; //$NON-NLS-1$
 	private static BundleContext context;
-	private ServiceRegistration registrationChecker;
 
 	public static BundleContext getContext() {
 		return context;
@@ -27,10 +26,9 @@ public class Activator implements BundleActivator {
 
 	public void start(BundleContext bundleContext) throws Exception {
 		Activator.context = bundleContext;
-		registrationChecker = context.registerService(IUpdateChecker.SERVICE_NAME, new UpdateChecker(), null);
 	}
 
 	public void stop(BundleContext bundleContext) throws Exception {
-		registrationChecker.unregister();
+		Activator.context = null;
 	}
 }
diff --git a/bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/p2/updatechecker/UpdateChecker.java b/bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/p2/updatechecker/UpdateChecker.java
deleted file mode 100644
index e06521d..0000000
--- a/bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/p2/updatechecker/UpdateChecker.java
+++ /dev/null
@@ -1,184 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.equinox.internal.p2.updatechecker;
-
-import java.net.URI;
-import java.text.SimpleDateFormat;
-import java.util.*;
-import org.eclipse.core.runtime.IStatus;
-import org.eclipse.core.runtime.Status;
-import org.eclipse.equinox.internal.p2.core.helpers.*;
-import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
-import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager;
-import org.eclipse.equinox.internal.provisional.p2.director.IPlanner;
-import org.eclipse.equinox.internal.provisional.p2.engine.*;
-import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
-import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
-import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
-import org.eclipse.equinox.internal.provisional.p2.query.Collector;
-import org.eclipse.equinox.internal.provisional.p2.query.Query;
-import org.eclipse.equinox.internal.provisional.p2.updatechecker.*;
-
-/**
- * Default implementation of {@link IUpdateChecker}.
- * <p>
- * This implementation is not optimized.  It doesn't optimize for multiple
- * polls on the same profile, nor does it cache any info about a profile from
- * poll to poll.
- */
-public class UpdateChecker implements IUpdateChecker {
-	public static boolean DEBUG = false;
-	public static boolean TRACE = false;
-	/**
-	 * Map of IUpdateListener->UpdateCheckThread.
-	 */
-	private HashMap checkers = new HashMap();
-
-	IProfileRegistry profileRegistry;
-	IPlanner planner;
-
-	private class UpdateCheckThread extends Thread {
-		boolean done = false;
-		long poll, delay;
-		IUpdateListener listener;
-		String profileId;
-		Query query;
-
-		UpdateCheckThread(String profileId, Query query, long delay, long poll, IUpdateListener listener) {
-			this.poll = poll;
-			this.delay = delay;
-			this.profileId = profileId;
-			this.query = query;
-			this.listener = listener;
-		}
-
-		public void run() {
-			try {
-				if (delay != ONE_TIME_CHECK && delay > 0) {
-					Thread.sleep(delay);
-				}
-				while (!done) {
-
-					trace("Checking for updates for " + profileId + " at " + getTimeStamp()); //$NON-NLS-1$ //$NON-NLS-2$
-					IInstallableUnit[] iusWithUpdates = checkForUpdates(profileId, query);
-					if (iusWithUpdates.length > 0) {
-						trace("Notifying listener of available updates"); //$NON-NLS-1$
-						UpdateEvent event = new UpdateEvent(profileId, iusWithUpdates);
-						if (!done)
-							listener.updatesAvailable(event);
-					} else {
-						trace("No updates were available"); //$NON-NLS-1$
-					}
-					if (delay == ONE_TIME_CHECK || delay <= 0) {
-						done = true;
-					} else {
-						Thread.sleep(poll);
-					}
-				}
-			} catch (InterruptedException e) {
-				// nothing
-			} catch (Exception e) {
-				LogHelper.log(new Status(IStatus.ERROR, Activator.ID, "Exception in update check thread", e)); //$NON-NLS-1$
-			}
-		}
-	}
-
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker#addUpdateCheck(java.lang.String, long, long, org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener)
-	 */
-	public void addUpdateCheck(String profileId, Query query, long delay, long poll, IUpdateListener listener) {
-		if (checkers.containsKey(listener))
-			return;
-		trace("Adding update checker for " + profileId + " at " + getTimeStamp()); //$NON-NLS-1$ //$NON-NLS-2$
-		UpdateCheckThread thread = new UpdateCheckThread(profileId, query, delay, poll, listener);
-		checkers.put(listener, thread);
-		thread.start();
-	}
-
-	/* (non-Javadoc)
-	 * @see org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker#removeUpdateCheck(org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener)
-	 */
-	public void removeUpdateCheck(IUpdateListener listener) {
-		checkers.remove(listener);
-	}
-
-	/*
-	 * Return the array of ius in the profile that have updates
-	 * available.
-	 */
-	IInstallableUnit[] checkForUpdates(String profileId, Query query) {
-		IProfile profile = getProfileRegistry().getProfile(profileId);
-		ArrayList iusWithUpdates = new ArrayList();
-		if (profile == null)
-			return new IInstallableUnit[0];
-		ProvisioningContext context = new ProvisioningContext(getAvailableRepositories());
-		if (query == null)
-			query = InstallableUnitQuery.ANY;
-		Iterator iter = profile.query(query, new Collector(), null).iterator();
-		while (iter.hasNext()) {
-			IInstallableUnit iu = (IInstallableUnit) iter.next();
-			IInstallableUnit[] replacements = getPlanner().updatesFor(iu, context, null);
-			if (replacements.length > 0)
-				iusWithUpdates.add(iu);
-		}
-		return (IInstallableUnit[]) iusWithUpdates.toArray(new IInstallableUnit[iusWithUpdates.size()]);
-	}
-
-	/**
-	 * Returns the list of metadata repositories that are currently available.
-	 */
-	private URI[] getAvailableRepositories() {
-		IMetadataRepositoryManager repoMgr = (IMetadataRepositoryManager) ServiceHelper.getService(Activator.getContext(), IMetadataRepositoryManager.class.getName());
-		URI[] repositories = repoMgr.getKnownRepositories(IRepositoryManager.REPOSITORIES_ALL);
-		ArrayList available = new ArrayList();
-		for (int i = 0; i < repositories.length; i++) {
-			try {
-				repoMgr.loadRepository(repositories[i], null);
-				available.add(repositories[i]);
-			} catch (ProvisionException e) {
-				//ignore unavailable repository
-			}
-		}
-		return (URI[]) available.toArray(new URI[available.size()]);
-	}
-
-	void trace(String message) {
-		if (Tracing.DEBUG_UPDATE_CHECK)
-			Tracing.debug(message);
-	}
-
-	String getTimeStamp() {
-		Date d = new Date();
-		SimpleDateFormat df = new SimpleDateFormat("[MM/dd/yy;HH:mm:ss:SSS]"); //$NON-NLS-1$
-		return df.format(d);
-	}
-
-	IPlanner getPlanner() {
-		if (planner == null) {
-			planner = (IPlanner) ServiceHelper.getService(Activator.getContext(), IPlanner.class.getName());
-			if (planner == null) {
-				throw new IllegalStateException("Provisioning system has not been initialized"); //$NON-NLS-1$
-			}
-		}
-		return planner;
-	}
-
-	IProfileRegistry getProfileRegistry() {
-		if (profileRegistry == null) {
-			profileRegistry = (IProfileRegistry) ServiceHelper.getService(Activator.getContext(), IProfileRegistry.class.getName());
-			if (profileRegistry == null) {
-				throw new IllegalStateException("Provisioning system has not been initialized"); //$NON-NLS-1$
-			}
-		}
-		return profileRegistry;
-	}
-
-}
diff --git a/bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/provisional/p2/updatechecker/UpdateChecker.java b/bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/provisional/p2/updatechecker/UpdateChecker.java
new file mode 100644
index 0000000..75169c7
--- /dev/null
+++ b/bundles/org.eclipse.equinox.p2.updatechecker/src/org/eclipse/equinox/internal/provisional/p2/updatechecker/UpdateChecker.java
@@ -0,0 +1,184 @@
+/*******************************************************************************
+ * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.equinox.internal.provisional.p2.updatechecker;
+
+import java.net.URI;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.equinox.internal.p2.core.helpers.*;
+import org.eclipse.equinox.internal.p2.updatechecker.Activator;
+import org.eclipse.equinox.internal.provisional.p2.core.ProvisionException;
+import org.eclipse.equinox.internal.provisional.p2.core.repository.IRepositoryManager;
+import org.eclipse.equinox.internal.provisional.p2.director.IPlanner;
+import org.eclipse.equinox.internal.provisional.p2.engine.*;
+import org.eclipse.equinox.internal.provisional.p2.metadata.IInstallableUnit;
+import org.eclipse.equinox.internal.provisional.p2.metadata.query.InstallableUnitQuery;
+import org.eclipse.equinox.internal.provisional.p2.metadata.repository.IMetadataRepositoryManager;
+import org.eclipse.equinox.internal.provisional.p2.query.Collector;
+import org.eclipse.equinox.internal.provisional.p2.query.Query;
+
+/**
+ * Default implementation of {@link IUpdateChecker}.
+ * <p>
+ * This implementation is not optimized.  It doesn't optimize for multiple
+ * polls on the same profile, nor does it cache any info about a profile from
+ * poll to poll.
+ */
+public class UpdateChecker implements IUpdateChecker {
+	public static boolean DEBUG = false;
+	public static boolean TRACE = false;
+	/**
+	 * Map of IUpdateListener->UpdateCheckThread.
+	 */
+	private HashMap checkers = new HashMap();
+
+	IProfileRegistry profileRegistry;
+	IPlanner planner;
+
+	private class UpdateCheckThread extends Thread {
+		boolean done = false;
+		long poll, delay;
+		IUpdateListener listener;
+		String profileId;
+		Query query;
+
+		UpdateCheckThread(String profileId, Query query, long delay, long poll, IUpdateListener listener) {
+			this.poll = poll;
+			this.delay = delay;
+			this.profileId = profileId;
+			this.query = query;
+			this.listener = listener;
+		}
+
+		public void run() {
+			try {
+				if (delay != ONE_TIME_CHECK && delay > 0) {
+					Thread.sleep(delay);
+				}
+				while (!done) {
+
+					trace("Checking for updates for " + profileId + " at " + getTimeStamp()); //$NON-NLS-1$ //$NON-NLS-2$
+					IInstallableUnit[] iusWithUpdates = checkForUpdates(profileId, query);
+					if (iusWithUpdates.length > 0) {
+						trace("Notifying listener of available updates"); //$NON-NLS-1$
+						UpdateEvent event = new UpdateEvent(profileId, iusWithUpdates);
+						if (!done)
+							listener.updatesAvailable(event);
+					} else {
+						trace("No updates were available"); //$NON-NLS-1$
+					}
+					if (delay == ONE_TIME_CHECK || delay <= 0) {
+						done = true;
+					} else {
+						Thread.sleep(poll);
+					}
+				}
+			} catch (InterruptedException e) {
+				// nothing
+			} catch (Exception e) {
+				LogHelper.log(new Status(IStatus.ERROR, Activator.ID, "Exception in update check thread", e)); //$NON-NLS-1$
+			}
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker#addUpdateCheck(java.lang.String, long, long, org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener)
+	 */
+	public void addUpdateCheck(String profileId, Query query, long delay, long poll, IUpdateListener listener) {
+		if (checkers.containsKey(listener))
+			return;
+		trace("Adding update checker for " + profileId + " at " + getTimeStamp()); //$NON-NLS-1$ //$NON-NLS-2$
+		UpdateCheckThread thread = new UpdateCheckThread(profileId, query, delay, poll, listener);
+		checkers.put(listener, thread);
+		thread.start();
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker#removeUpdateCheck(org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener)
+	 */
+	public void removeUpdateCheck(IUpdateListener listener) {
+		checkers.remove(listener);
+	}
+
+	/*
+	 * Return the array of ius in the profile that have updates
+	 * available.
+	 */
+	IInstallableUnit[] checkForUpdates(String profileId, Query query) {
+		IProfile profile = getProfileRegistry().getProfile(profileId);
+		ArrayList iusWithUpdates = new ArrayList();
+		if (profile == null)
+			return new IInstallableUnit[0];
+		ProvisioningContext context = new ProvisioningContext(getAvailableRepositories());
+		if (query == null)
+			query = InstallableUnitQuery.ANY;
+		Iterator iter = profile.query(query, new Collector(), null).iterator();
+		while (iter.hasNext()) {
+			IInstallableUnit iu = (IInstallableUnit) iter.next();
+			IInstallableUnit[] replacements = getPlanner().updatesFor(iu, context, null);
+			if (replacements.length > 0)
+				iusWithUpdates.add(iu);
+		}
+		return (IInstallableUnit[]) iusWithUpdates.toArray(new IInstallableUnit[iusWithUpdates.size()]);
+	}
+
+	/**
+	 * Returns the list of metadata repositories that are currently available.
+	 */
+	private URI[] getAvailableRepositories() {
+		IMetadataRepositoryManager repoMgr = (IMetadataRepositoryManager) ServiceHelper.getService(Activator.getContext(), IMetadataRepositoryManager.class.getName());
+		URI[] repositories = repoMgr.getKnownRepositories(IRepositoryManager.REPOSITORIES_ALL);
+		ArrayList available = new ArrayList();
+		for (int i = 0; i < repositories.length; i++) {
+			try {
+				repoMgr.loadRepository(repositories[i], null);
+				available.add(repositories[i]);
+			} catch (ProvisionException e) {
+				//ignore unavailable repository
+			}
+		}
+		return (URI[]) available.toArray(new URI[available.size()]);
+	}
+
+	void trace(String message) {
+		if (Tracing.DEBUG_UPDATE_CHECK)
+			Tracing.debug(message);
+	}
+
+	String getTimeStamp() {
+		Date d = new Date();
+		SimpleDateFormat df = new SimpleDateFormat("[MM/dd/yy;HH:mm:ss:SSS]"); //$NON-NLS-1$
+		return df.format(d);
+	}
+
+	IPlanner getPlanner() {
+		if (planner == null) {
+			planner = (IPlanner) ServiceHelper.getService(Activator.getContext(), IPlanner.class.getName());
+			if (planner == null) {
+				throw new IllegalStateException("Provisioning system has not been initialized"); //$NON-NLS-1$
+			}
+		}
+		return planner;
+	}
+
+	IProfileRegistry getProfileRegistry() {
+		if (profileRegistry == null) {
+			profileRegistry = (IProfileRegistry) ServiceHelper.getService(Activator.getContext(), IProfileRegistry.class.getName());
+			if (profileRegistry == null) {
+				throw new IllegalStateException("Provisioning system has not been initialized"); //$NON-NLS-1$
+			}
+		}
+		return profileRegistry;
+	}
+
+}
commit 842961a273de3679fad54258b95686d23407b651
Author: Susan Franklin <sfranklin>
Date:   Thu Nov 13 21:40:23 2008 +0000

    Bug 227582 - [ui] Should the early startup extension be separated from the rest of the UI plugin?

31	0	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
index 0b4e3c2..a0900a1 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
@@ -14,9 +14,11 @@ import org.eclipse.equinox.internal.provisional.p2.core.eventbus.IProvisioningEv
 import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker;
 import org.eclipse.equinox.internal.provisional.p2.updatechecker.UpdateChecker;
 import org.eclipse.ui.plugin.AbstractUIPlugin;
+import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.ServiceReference;
 import org.osgi.framework.ServiceRegistration;
+import org.osgi.service.packageadmin.PackageAdmin;
 
 /**
  * Activator class for the automatic updates plugin
@@ -25,6 +27,9 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 
 	private static AutomaticUpdatePlugin plugin;
 	private static BundleContext context;
+	private static PackageAdmin packageAdmin = null;
+	private static ServiceReference packageAdminRef = null;
+
 	private AutomaticUpdateScheduler scheduler;
 	private AutomaticUpdater updater;
 	private ServiceRegistration registrationChecker;
@@ -34,6 +39,21 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 	public static BundleContext getContext() {
 		return context;
 	}
+	
+	public static Bundle getBundle(String symbolicName) {
+		if (packageAdmin == null)
+			return null;
+		Bundle[] bundles = packageAdmin.getBundles(symbolicName, null);
+		if (bundles == null)
+			return null;
+		// Return the first bundle that is not installed or uninstalled
+		for (int i = 0; i < bundles.length; i++) {
+			if ((bundles[i].getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) == 0) {
+				return bundles[i];
+			}
+		}
+		return null;
+	}
 
 	/**
 	 * Returns the singleton plugin instance
@@ -57,6 +77,13 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 		super.start(bundleContext);
 		plugin = this;
 		context = bundleContext;
+		packageAdminRef = bundleContext.getServiceReference(PackageAdmin.class.getName());
+		packageAdmin = (PackageAdmin) bundleContext.getService(packageAdminRef);
+
+		// TODO for now we need to manually start up the update checker
+		// because the Eclipse Application launch config won't let me specify bundles to start.
+		getBundle("org.eclipse.equinox.p2.updatechecker").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
+
 		registrationChecker = context.registerService(IUpdateChecker.SERVICE_NAME, new UpdateChecker(), null);
 	}
 
@@ -69,6 +96,10 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 			updater.shutdown();
 			updater = null;
 		}
+		registrationChecker.unregister();
+		registrationChecker = null;
+		packageAdmin = null;
+		packageAdminRef = null;
 		plugin = null;
 		super.stop(bundleContext);
 		context = null;
commit 04fbe377707641cc8172c8872388fc34a8421229
Author: Susan Franklin <sfranklin>
Date:   Thu Nov 13 23:27:52 2008 +0000

    Bug 227582 - [ui] Should the early startup extension be separated from the rest of the UI plugin?

6	2	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
11	1	bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
0	1	bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/ProvUIActivator.java
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
index a0900a1..e367b38 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdatePlugin.java
@@ -80,8 +80,12 @@ public class AutomaticUpdatePlugin extends AbstractUIPlugin {
 		packageAdminRef = bundleContext.getServiceReference(PackageAdmin.class.getName());
 		packageAdmin = (PackageAdmin) bundleContext.getService(packageAdminRef);
 
-		// TODO for now we need to manually start up the update checker
-		// because the Eclipse Application launch config won't let me specify bundles to start.
+		// TODO for now we need to manually start up the provisioning infrastructure
+		// and the update checker, because the Eclipse Application launch config won't 
+		// let me specify bundles to start.
+		getBundle("org.eclipse.equinox.p2.exemplarysetup").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
+		getBundle("org.eclipse.equinox.frameworkadmin.equinox").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
+		getBundle("org.eclipse.equinox.simpleconfigurator.manipulator").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
 		getBundle("org.eclipse.equinox.p2.updatechecker").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
 
 		registrationChecker = context.registerService(IUpdateChecker.SERVICE_NAME, new UpdateChecker(), null);
diff --git a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
index 77724bc..53e9fcc 100644
--- a/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
+++ b/bundles/org.eclipse.equinox.p2.ui.sdk.scheduler/src/org/eclipse/equinox/internal/p2/ui/sdk/scheduler/AutomaticUpdateScheduler.java
@@ -22,6 +22,7 @@ import org.eclipse.equinox.internal.provisional.p2.query.Collector;
 import org.eclipse.equinox.internal.provisional.p2.query.Query;
 import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateChecker;
 import org.eclipse.equinox.internal.provisional.p2.updatechecker.IUpdateListener;
+import org.eclipse.equinox.internal.provisional.p2.updatechecker.UpdateEvent;
 import org.eclipse.ui.IStartup;
 import org.eclipse.ui.statushandlers.StatusManager;
 
@@ -138,7 +139,16 @@ public class AutomaticUpdateScheduler implements IStartup {
 			delay = computeDelay(pref);
 			poll = computePoll(pref);
 		}
-		listener = AutomaticUpdatePlugin.getDefault().getAutomaticUpdater();
+		// We do not access the AutomaticUpdater directly when we register 
+		// the listener. This prevents the UI classes from being started up
+		// too soon.
+		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=227582
+		listener = new IUpdateListener() {
+			public void updatesAvailable(UpdateEvent event) {
+				AutomaticUpdatePlugin.getDefault().getAutomaticUpdater().updatesAvailable(event);
+			}
+			
+		};
 		checker.addUpdateCheck(profileId, getProfileQuery(), delay, poll, listener);
 
 	}
diff --git a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/ProvUIActivator.java b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/ProvUIActivator.java
index 566ad91..01afaa4 100644
--- a/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/ProvUIActivator.java
+++ b/bundles/org.eclipse.equinox.p2.ui/src/org/eclipse/equinox/internal/p2/ui/ProvUIActivator.java
@@ -91,7 +91,6 @@ public class ProvUIActivator extends AbstractUIPlugin {
 		getBundle("org.eclipse.equinox.p2.exemplarysetup").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
 		getBundle("org.eclipse.equinox.frameworkadmin.equinox").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
 		getBundle("org.eclipse.equinox.simpleconfigurator.manipulator").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
-		getBundle("org.eclipse.equinox.p2.updatechecker").start(Bundle.START_TRANSIENT); //$NON-NLS-1$
 
 		initializeImages();
 		addProfileChangeListener();
