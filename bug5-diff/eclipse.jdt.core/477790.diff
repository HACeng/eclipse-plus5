commit c746ac6ae60dd73c0e681419d361cf16b338a627
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Wed Oct 14 11:01:42 2015 +0530

    Bug 477790 - Change usage of SubProgressMonitor to SubMonitor in
    org.eclipse.jdt.core
    
    Change-Id: Ie0954894d4ce9ea52b2346b0efe9814d9c52d364

3	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
5	5	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
4	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
4	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
index 55023d2..812e16f 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
@@ -25,7 +25,7 @@ import java.util.Set;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.core.runtime.SubProgressMonitor;
+import org.eclipse.core.runtime.SubMonitor;
 import org.eclipse.jdt.core.Flags;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IImportDeclaration;
@@ -1149,7 +1149,7 @@ public final class ImportRewrite {
 				parser.setSource(this.compilationUnit);
 				parser.setFocalPosition(0); // reduced AST
 				parser.setResolveBindings(false);
-				usedAstRoot= (CompilationUnit) parser.createAST(new SubProgressMonitor(monitor, 1));
+				usedAstRoot= (CompilationUnit) parser.createAST(SubMonitor.convert(monitor, 1));
 			}
 
 			ImportRewriteConfiguration config= buildImportRewriteConfiguration();
@@ -1177,7 +1177,7 @@ public final class ImportRewrite {
 				computer.requireExplicitImport(true, staticExplicitSimpleName);
 			}
 
-			ImportRewriteAnalyzer.RewriteResult result= computer.analyzeRewrite(new SubProgressMonitor(monitor, 1));
+			ImportRewriteAnalyzer.RewriteResult result= computer.analyzeRewrite(SubMonitor.convert(monitor, 1));
 
 			this.createdImports= result.getCreatedImports();
 			this.createdStaticImports= result.getCreatedStaticImports();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index fa4d46b..aff762f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -124,7 +124,7 @@ import org.eclipse.core.runtime.Path;
 import org.eclipse.core.runtime.Platform;
 import org.eclipse.core.runtime.Plugin;
 import org.eclipse.core.runtime.QualifiedName;
-import org.eclipse.core.runtime.SubProgressMonitor;
+import org.eclipse.core.runtime.SubMonitor;
 import org.eclipse.core.runtime.jobs.ISchedulingRule;
 import org.eclipse.core.resources.IContainer;
 import org.eclipse.core.resources.IFile;
@@ -4061,10 +4061,10 @@ public final class JavaCore extends Plugin {
 
 			// initialize all containers and variables
 			JavaModelManager manager = JavaModelManager.getJavaModelManager();
-			SubProgressMonitor subMonitor = null;
+			SubMonitor subMonitor = null;
 			try {
 				if (monitor != null) {
-					subMonitor = new SubProgressMonitor(monitor, 50); // 50% of the time is spent in initializing containers and variables
+					subMonitor = SubMonitor.convert(monitor, 50); // 50% of the time is spent in initializing containers and variables
 					subMonitor.beginTask("", 100); //$NON-NLS-1$
 					subMonitor.worked(5); // give feedback to the user that something is happening
 					manager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(subMonitor);
@@ -4143,7 +4143,7 @@ public final class JavaCore extends Plugin {
 					monitor.subTask(Messages.javamodel_refreshing_external_jars);
 				model.refreshExternalArchives(
 					null/*refresh all projects*/,
-					monitor == null ? null : new SubProgressMonitor(monitor, 1) // 1% of the time is spent in jar refresh
+					monitor == null ? null : SubMonitor.convert(monitor, 1) // 1% of the time is spent in jar refresh
 				);
 			} catch (JavaModelException e) {
 				// refreshing failed: ignore
@@ -4181,7 +4181,7 @@ public final class JavaCore extends Plugin {
 					// will not activate index query caches if indexes are not ready, since it would take to long
 					// to wait until indexes are fully rebuild
 					IJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,
-					monitor == null ? null : new SubProgressMonitor(monitor, 49) // 49% of the time is spent in the dummy search
+					monitor == null ? null : SubMonitor.convert(monitor, 49) // 49% of the time is spent in the dummy search
 				);
 			} catch (JavaModelException e) {
 				// /search failed: ignore
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index e03896a..94e1821 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -3069,7 +3069,7 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 						monitor.beginTask("", projectsToTouch.length); //$NON-NLS-1$
 					}
 					for (IProject iProject : projectsToTouch) {
-						IProgressMonitor subMonitor = monitor == null ? null: new SubProgressMonitor(monitor, 1);
+						IProgressMonitor subMonitor = monitor == null ? null: SubMonitor.convert(monitor, 1);
 						if (JavaBuilder.DEBUG) {
 							System.out.println("Touching project " + iProject.getName()); //$NON-NLS-1$
 						}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
index 176079e..8eff526 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -517,7 +517,7 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	protected IProgressMonitor getSubProgressMonitor(int workAmount) {
 		IProgressMonitor sub = null;
 		if (this.progressMonitor != null) {
-			sub = new SubProgressMonitor(this.progressMonitor, workAmount, SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
+			sub = SubMonitor.convert(this.progressMonitor, workAmount);
 		}
 		return sub;
 	}
@@ -578,7 +578,7 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	protected void moveResources(IResource[] resources, IPath container) throws JavaModelException {
 		IProgressMonitor subProgressMonitor = null;
 		if (this.progressMonitor != null) {
-			subProgressMonitor = new SubProgressMonitor(this.progressMonitor, resources.length, SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
+			subProgressMonitor = SubMonitor.convert(this.progressMonitor, resources.length);
 		}
 		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
 		try {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
index 1b090d1..f931e3f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,7 +17,7 @@ import org.eclipse.core.resources.IResource;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.core.runtime.SubProgressMonitor;
+import org.eclipse.core.runtime.SubMonitor;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.search.*;
@@ -113,7 +113,7 @@ public void build(boolean computeSubtypes) {
 			IProgressMonitor possibleSubtypesMonitor =
 				this.hierarchy.progressMonitor == null ?
 					null :
-					new SubProgressMonitor(this.hierarchy.progressMonitor, amountOfWorkForSubtypes);
+					SubMonitor.convert(this.hierarchy.progressMonitor, amountOfWorkForSubtypes);
 			HashSet localTypes = new HashSet(10); // contains the paths that have potential subtypes that are local/anonymous types
 			String[] allPossibleSubtypes;
 			if (((Member)focusType).getOuterMostLocalContext() == null) {
@@ -127,7 +127,7 @@ public void build(boolean computeSubtypes) {
 				IProgressMonitor buildMonitor =
 					this.hierarchy.progressMonitor == null ?
 						null :
-						new SubProgressMonitor(this.hierarchy.progressMonitor, 100 - amountOfWorkForSubtypes);
+						SubMonitor.convert(this.hierarchy.progressMonitor, 100 - amountOfWorkForSubtypes);
 				this.hierarchy.initialize(allPossibleSubtypes.length);
 				buildFromPotentialSubtypes(allPossibleSubtypes, localTypes, buildMonitor);
 			}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
index 70118f5..3545ef7 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,7 +16,7 @@ import java.util.Iterator;
 import java.util.Map;
 
 import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.SubProgressMonitor;
+import org.eclipse.core.runtime.SubMonitor;
 import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
@@ -50,13 +50,13 @@ public void build(boolean computeSubtypes) {
 			IProgressMonitor typeInRegionMonitor =
 				this.hierarchy.progressMonitor == null ?
 					null :
-					new SubProgressMonitor(this.hierarchy.progressMonitor, 30);
+					SubMonitor.convert(this.hierarchy.progressMonitor, 30);
 			HashMap allOpenablesInRegion = determineOpenablesInRegion(typeInRegionMonitor);
 			this.hierarchy.initialize(allOpenablesInRegion.size());
 			IProgressMonitor buildMonitor =
 				this.hierarchy.progressMonitor == null ?
 					null :
-					new SubProgressMonitor(this.hierarchy.progressMonitor, 70);
+					SubMonitor.convert(this.hierarchy.progressMonitor, 70);
 			createTypeHierarchyBasedOnRegion(allOpenablesInRegion, buildMonitor);
 			((RegionBasedTypeHierarchy)this.hierarchy).pruneDeadBranches();
 		} else {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
index fa43a28..b8e8c23 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
@@ -215,7 +215,7 @@ public class BasicSearchEngine {
 					indexManager.performConcurrentJob(
 						new PatternSearchJob(pattern, participant, scope, pathCollector),
 						IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
-						monitor==null ? null : new SubProgressMonitor(monitor, 50));
+						monitor==null ? null : SubMonitor.convert(monitor, 50));
 					if (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();
 
 					// locate index matches if any (note that all search matches could have been issued during index querying)
@@ -229,7 +229,7 @@ public class BasicSearchEngine {
 							indexMatches[j] = participant.getDocument(indexMatchPaths[j]);
 						}
 						SearchDocument[] matches = MatchLocator.addWorkingCopies(pattern, indexMatches, getWorkingCopies(), participant);
-						participant.locateMatches(matches, pattern, scope, requestor, monitor==null ? null : new SubProgressMonitor(monitor, 50));
+						participant.locateMatches(matches, pattern, scope, requestor, monitor==null ? null : SubMonitor.convert(monitor, 50));
 					}
 				} finally {
 					requestor.exitParticipant(participant);
@@ -646,7 +646,7 @@ public class BasicSearchEngine {
 					scope,
 					searchRequestor),
 				waitingPolicy,
-				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1000-copiesLength));
+				progressMonitor == null ? null : SubMonitor.convert(progressMonitor, 1000-copiesLength));
 
 			// add type names from working copies
 			if (copies != null) {
@@ -968,7 +968,7 @@ public class BasicSearchEngine {
 				waitForIndexes
 					? IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH
 					: IJavaSearchConstants.FORCE_IMMEDIATE_SEARCH,
-				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));
+				progressMonitor == null ? null : SubMonitor.convert(progressMonitor, 100));
 		} catch (OperationCanceledException oce) {
 			// do nothing
 		} finally {
@@ -1140,7 +1140,7 @@ public class BasicSearchEngine {
 					scope,
 					searchRequestor),
 				waitingPolicy,
-				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1000-copiesLength));
+				progressMonitor == null ? null : SubMonitor.convert(progressMonitor, 1000-copiesLength));
 
 			// add type names from working copies
 			if (copies != null) {
@@ -1390,7 +1390,7 @@ public class BasicSearchEngine {
 					scope,
 					searchRequestor),
 				waitingPolicy,
-				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));
+				progressMonitor == null ? null : SubMonitor.convert(progressMonitor, 100));
 
 			// add type names from working copies
 			if (copies != null) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
index 3b45099..94f2505 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,7 +11,7 @@
 package org.eclipse.jdt.internal.core.search.matching;
 
 import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.SubProgressMonitor;
+import org.eclipse.core.runtime.SubMonitor;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.search.*;
@@ -274,7 +274,7 @@ protected String[] getPathsOfDeclaringType() {
 			scope,
 			searchRequestor),
 		IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
-		this.progressMonitor == null ? null : new SubProgressMonitor(this.progressMonitor, 100));
+		this.progressMonitor == null ? null : SubMonitor.convert(this.progressMonitor, 100));
 	return pathCollector.getPaths();
 }
 public char[][][] getSamePackageSuperTypeNames() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
index e1774d9..6a826e4 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -186,7 +186,7 @@ public abstract class JobManager implements Runnable {
 							Util.verbose("-> NOT READY - forcing immediate - " + searchJob);//$NON-NLS-1$
 						try {
 							disable(); // pause indexing
-							status = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));
+							status = searchJob.execute(progress == null ? null : SubMonitor.convert(progress, concurrentJobWork));
 						} finally {
 							enable();
 						}
@@ -206,7 +206,7 @@ public abstract class JobManager implements Runnable {
 						try {
 							int totalWork = 1000;
 							if (progress != null) {
-								subProgress = new SubProgressMonitor(progress, concurrentJobWork * 8 / 10);
+								subProgress = SubMonitor.convert(progress, concurrentJobWork * 8 / 10);
 								subProgress.beginTask("", totalWork); //$NON-NLS-1$
 								concurrentJobWork = concurrentJobWork * 2 / 10;
 							}
@@ -274,7 +274,7 @@ public abstract class JobManager implements Runnable {
 						}
 				}
 			}
-			status = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));
+			status = searchJob.execute(progress == null ? null : SubMonitor.convert(progress, concurrentJobWork));
 		} finally {
 			if (progress != null)
 				progress.done();
commit 638b00bc8e52106dab44ca0f7aa7dd0d9f96d9dc
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Thu Oct 15 09:45:13 2015 +0530

    Revert "Bug 477790 - Change usage of SubProgressMonitor to SubMonitor in org.eclipse.jdt.core"
    
    This reverts commit c746ac6ae60dd73c0e681419d361cf16b338a627.

3	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
5	5	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
4	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
4	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
3	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
index 812e16f..55023d2 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
@@ -25,7 +25,7 @@ import java.util.Set;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.core.runtime.SubMonitor;
+import org.eclipse.core.runtime.SubProgressMonitor;
 import org.eclipse.jdt.core.Flags;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IImportDeclaration;
@@ -1149,7 +1149,7 @@ public final class ImportRewrite {
 				parser.setSource(this.compilationUnit);
 				parser.setFocalPosition(0); // reduced AST
 				parser.setResolveBindings(false);
-				usedAstRoot= (CompilationUnit) parser.createAST(SubMonitor.convert(monitor, 1));
+				usedAstRoot= (CompilationUnit) parser.createAST(new SubProgressMonitor(monitor, 1));
 			}
 
 			ImportRewriteConfiguration config= buildImportRewriteConfiguration();
@@ -1177,7 +1177,7 @@ public final class ImportRewrite {
 				computer.requireExplicitImport(true, staticExplicitSimpleName);
 			}
 
-			ImportRewriteAnalyzer.RewriteResult result= computer.analyzeRewrite(SubMonitor.convert(monitor, 1));
+			ImportRewriteAnalyzer.RewriteResult result= computer.analyzeRewrite(new SubProgressMonitor(monitor, 1));
 
 			this.createdImports= result.getCreatedImports();
 			this.createdStaticImports= result.getCreatedStaticImports();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index aff762f..fa4d46b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -124,7 +124,7 @@ import org.eclipse.core.runtime.Path;
 import org.eclipse.core.runtime.Platform;
 import org.eclipse.core.runtime.Plugin;
 import org.eclipse.core.runtime.QualifiedName;
-import org.eclipse.core.runtime.SubMonitor;
+import org.eclipse.core.runtime.SubProgressMonitor;
 import org.eclipse.core.runtime.jobs.ISchedulingRule;
 import org.eclipse.core.resources.IContainer;
 import org.eclipse.core.resources.IFile;
@@ -4061,10 +4061,10 @@ public final class JavaCore extends Plugin {
 
 			// initialize all containers and variables
 			JavaModelManager manager = JavaModelManager.getJavaModelManager();
-			SubMonitor subMonitor = null;
+			SubProgressMonitor subMonitor = null;
 			try {
 				if (monitor != null) {
-					subMonitor = SubMonitor.convert(monitor, 50); // 50% of the time is spent in initializing containers and variables
+					subMonitor = new SubProgressMonitor(monitor, 50); // 50% of the time is spent in initializing containers and variables
 					subMonitor.beginTask("", 100); //$NON-NLS-1$
 					subMonitor.worked(5); // give feedback to the user that something is happening
 					manager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(subMonitor);
@@ -4143,7 +4143,7 @@ public final class JavaCore extends Plugin {
 					monitor.subTask(Messages.javamodel_refreshing_external_jars);
 				model.refreshExternalArchives(
 					null/*refresh all projects*/,
-					monitor == null ? null : SubMonitor.convert(monitor, 1) // 1% of the time is spent in jar refresh
+					monitor == null ? null : new SubProgressMonitor(monitor, 1) // 1% of the time is spent in jar refresh
 				);
 			} catch (JavaModelException e) {
 				// refreshing failed: ignore
@@ -4181,7 +4181,7 @@ public final class JavaCore extends Plugin {
 					// will not activate index query caches if indexes are not ready, since it would take to long
 					// to wait until indexes are fully rebuild
 					IJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,
-					monitor == null ? null : SubMonitor.convert(monitor, 49) // 49% of the time is spent in the dummy search
+					monitor == null ? null : new SubProgressMonitor(monitor, 49) // 49% of the time is spent in the dummy search
 				);
 			} catch (JavaModelException e) {
 				// /search failed: ignore
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index 94e1821..e03896a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -3069,7 +3069,7 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 						monitor.beginTask("", projectsToTouch.length); //$NON-NLS-1$
 					}
 					for (IProject iProject : projectsToTouch) {
-						IProgressMonitor subMonitor = monitor == null ? null: SubMonitor.convert(monitor, 1);
+						IProgressMonitor subMonitor = monitor == null ? null: new SubProgressMonitor(monitor, 1);
 						if (JavaBuilder.DEBUG) {
 							System.out.println("Touching project " + iProject.getName()); //$NON-NLS-1$
 						}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
index 8eff526..176079e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -517,7 +517,7 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	protected IProgressMonitor getSubProgressMonitor(int workAmount) {
 		IProgressMonitor sub = null;
 		if (this.progressMonitor != null) {
-			sub = SubMonitor.convert(this.progressMonitor, workAmount);
+			sub = new SubProgressMonitor(this.progressMonitor, workAmount, SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
 		}
 		return sub;
 	}
@@ -578,7 +578,7 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	protected void moveResources(IResource[] resources, IPath container) throws JavaModelException {
 		IProgressMonitor subProgressMonitor = null;
 		if (this.progressMonitor != null) {
-			subProgressMonitor = SubMonitor.convert(this.progressMonitor, resources.length);
+			subProgressMonitor = new SubProgressMonitor(this.progressMonitor, resources.length, SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
 		}
 		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
 		try {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
index f931e3f..1b090d1 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,7 +17,7 @@ import org.eclipse.core.resources.IResource;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.core.runtime.SubMonitor;
+import org.eclipse.core.runtime.SubProgressMonitor;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.search.*;
@@ -113,7 +113,7 @@ public void build(boolean computeSubtypes) {
 			IProgressMonitor possibleSubtypesMonitor =
 				this.hierarchy.progressMonitor == null ?
 					null :
-					SubMonitor.convert(this.hierarchy.progressMonitor, amountOfWorkForSubtypes);
+					new SubProgressMonitor(this.hierarchy.progressMonitor, amountOfWorkForSubtypes);
 			HashSet localTypes = new HashSet(10); // contains the paths that have potential subtypes that are local/anonymous types
 			String[] allPossibleSubtypes;
 			if (((Member)focusType).getOuterMostLocalContext() == null) {
@@ -127,7 +127,7 @@ public void build(boolean computeSubtypes) {
 				IProgressMonitor buildMonitor =
 					this.hierarchy.progressMonitor == null ?
 						null :
-						SubMonitor.convert(this.hierarchy.progressMonitor, 100 - amountOfWorkForSubtypes);
+						new SubProgressMonitor(this.hierarchy.progressMonitor, 100 - amountOfWorkForSubtypes);
 				this.hierarchy.initialize(allPossibleSubtypes.length);
 				buildFromPotentialSubtypes(allPossibleSubtypes, localTypes, buildMonitor);
 			}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
index 3545ef7..70118f5 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,7 +16,7 @@ import java.util.Iterator;
 import java.util.Map;
 
 import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.SubMonitor;
+import org.eclipse.core.runtime.SubProgressMonitor;
 import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
@@ -50,13 +50,13 @@ public void build(boolean computeSubtypes) {
 			IProgressMonitor typeInRegionMonitor =
 				this.hierarchy.progressMonitor == null ?
 					null :
-					SubMonitor.convert(this.hierarchy.progressMonitor, 30);
+					new SubProgressMonitor(this.hierarchy.progressMonitor, 30);
 			HashMap allOpenablesInRegion = determineOpenablesInRegion(typeInRegionMonitor);
 			this.hierarchy.initialize(allOpenablesInRegion.size());
 			IProgressMonitor buildMonitor =
 				this.hierarchy.progressMonitor == null ?
 					null :
-					SubMonitor.convert(this.hierarchy.progressMonitor, 70);
+					new SubProgressMonitor(this.hierarchy.progressMonitor, 70);
 			createTypeHierarchyBasedOnRegion(allOpenablesInRegion, buildMonitor);
 			((RegionBasedTypeHierarchy)this.hierarchy).pruneDeadBranches();
 		} else {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
index b8e8c23..fa43a28 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
@@ -215,7 +215,7 @@ public class BasicSearchEngine {
 					indexManager.performConcurrentJob(
 						new PatternSearchJob(pattern, participant, scope, pathCollector),
 						IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
-						monitor==null ? null : SubMonitor.convert(monitor, 50));
+						monitor==null ? null : new SubProgressMonitor(monitor, 50));
 					if (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();
 
 					// locate index matches if any (note that all search matches could have been issued during index querying)
@@ -229,7 +229,7 @@ public class BasicSearchEngine {
 							indexMatches[j] = participant.getDocument(indexMatchPaths[j]);
 						}
 						SearchDocument[] matches = MatchLocator.addWorkingCopies(pattern, indexMatches, getWorkingCopies(), participant);
-						participant.locateMatches(matches, pattern, scope, requestor, monitor==null ? null : SubMonitor.convert(monitor, 50));
+						participant.locateMatches(matches, pattern, scope, requestor, monitor==null ? null : new SubProgressMonitor(monitor, 50));
 					}
 				} finally {
 					requestor.exitParticipant(participant);
@@ -646,7 +646,7 @@ public class BasicSearchEngine {
 					scope,
 					searchRequestor),
 				waitingPolicy,
-				progressMonitor == null ? null : SubMonitor.convert(progressMonitor, 1000-copiesLength));
+				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1000-copiesLength));
 
 			// add type names from working copies
 			if (copies != null) {
@@ -968,7 +968,7 @@ public class BasicSearchEngine {
 				waitForIndexes
 					? IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH
 					: IJavaSearchConstants.FORCE_IMMEDIATE_SEARCH,
-				progressMonitor == null ? null : SubMonitor.convert(progressMonitor, 100));
+				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));
 		} catch (OperationCanceledException oce) {
 			// do nothing
 		} finally {
@@ -1140,7 +1140,7 @@ public class BasicSearchEngine {
 					scope,
 					searchRequestor),
 				waitingPolicy,
-				progressMonitor == null ? null : SubMonitor.convert(progressMonitor, 1000-copiesLength));
+				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1000-copiesLength));
 
 			// add type names from working copies
 			if (copies != null) {
@@ -1390,7 +1390,7 @@ public class BasicSearchEngine {
 					scope,
 					searchRequestor),
 				waitingPolicy,
-				progressMonitor == null ? null : SubMonitor.convert(progressMonitor, 100));
+				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));
 
 			// add type names from working copies
 			if (copies != null) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
index 94f2505..3b45099 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,7 +11,7 @@
 package org.eclipse.jdt.internal.core.search.matching;
 
 import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.SubMonitor;
+import org.eclipse.core.runtime.SubProgressMonitor;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.search.*;
@@ -274,7 +274,7 @@ protected String[] getPathsOfDeclaringType() {
 			scope,
 			searchRequestor),
 		IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
-		this.progressMonitor == null ? null : SubMonitor.convert(this.progressMonitor, 100));
+		this.progressMonitor == null ? null : new SubProgressMonitor(this.progressMonitor, 100));
 	return pathCollector.getPaths();
 }
 public char[][][] getSamePackageSuperTypeNames() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
index 6a826e4..e1774d9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -186,7 +186,7 @@ public abstract class JobManager implements Runnable {
 							Util.verbose("-> NOT READY - forcing immediate - " + searchJob);//$NON-NLS-1$
 						try {
 							disable(); // pause indexing
-							status = searchJob.execute(progress == null ? null : SubMonitor.convert(progress, concurrentJobWork));
+							status = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));
 						} finally {
 							enable();
 						}
@@ -206,7 +206,7 @@ public abstract class JobManager implements Runnable {
 						try {
 							int totalWork = 1000;
 							if (progress != null) {
-								subProgress = SubMonitor.convert(progress, concurrentJobWork * 8 / 10);
+								subProgress = new SubProgressMonitor(progress, concurrentJobWork * 8 / 10);
 								subProgress.beginTask("", totalWork); //$NON-NLS-1$
 								concurrentJobWork = concurrentJobWork * 2 / 10;
 							}
@@ -274,7 +274,7 @@ public abstract class JobManager implements Runnable {
 						}
 				}
 			}
-			status = searchJob.execute(progress == null ? null : SubMonitor.convert(progress, concurrentJobWork));
+			status = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));
 		} finally {
 			if (progress != null)
 				progress.done();
commit 0199702ff6cca8392f62e334c86875a1b31484e2
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Nov 11 09:00:42 2015 -0800

    Bug 477790 - Adopt SubMonitor in JDT core
    
    Adopt SubMonitor in the type hierarchy builders
    
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>
    Change-Id: Ic7ecbd08bd3a6ab13d73a643485dbf50762245a5

29	14	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
3	12	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
34	11	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
index 1b090d1..6a1d826 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/IndexBasedHierarchyBuilder.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,17 +10,31 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.hierarchy;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
 
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.resources.IResource;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.core.runtime.SubProgressMonitor;
-import org.eclipse.jdt.core.*;
+import org.eclipse.core.runtime.SubMonitor;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.core.search.*;
+import org.eclipse.jdt.core.search.IJavaSearchConstants;
+import org.eclipse.jdt.core.search.IJavaSearchScope;
+import org.eclipse.jdt.core.search.SearchParticipant;
+import org.eclipse.jdt.core.search.SearchPattern;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
@@ -28,7 +42,14 @@ import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfObject;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
-import org.eclipse.jdt.internal.core.*;
+import org.eclipse.jdt.internal.core.ClassFile;
+import org.eclipse.jdt.internal.core.IPathRequestor;
+import org.eclipse.jdt.internal.core.JavaModelManager;
+import org.eclipse.jdt.internal.core.JavaProject;
+import org.eclipse.jdt.internal.core.Member;
+import org.eclipse.jdt.internal.core.Openable;
+import org.eclipse.jdt.internal.core.PackageFragment;
+import org.eclipse.jdt.internal.core.SearchableEnvironment;
 import org.eclipse.jdt.internal.core.search.IndexQueryRequestor;
 import org.eclipse.jdt.internal.core.search.JavaSearchParticipant;
 import org.eclipse.jdt.internal.core.search.SubTypeSearchJob;
@@ -110,10 +131,7 @@ public void build(boolean computeSubtypes) {
 			IType focusType = getType();
 			boolean focusIsObject = focusType.getElementName().equals(new String(IIndexConstants.OBJECT));
 			int amountOfWorkForSubtypes = focusIsObject ? 5 : 80; // percentage of work needed to get possible subtypes
-			IProgressMonitor possibleSubtypesMonitor =
-				this.hierarchy.progressMonitor == null ?
-					null :
-					new SubProgressMonitor(this.hierarchy.progressMonitor, amountOfWorkForSubtypes);
+			SubMonitor possibleSubtypesMonitor = this.hierarchy.progressMonitor.split(amountOfWorkForSubtypes);
 			HashSet localTypes = new HashSet(10); // contains the paths that have potential subtypes that are local/anonymous types
 			String[] allPossibleSubtypes;
 			if (((Member)focusType).getOuterMostLocalContext() == null) {
@@ -124,10 +142,7 @@ public void build(boolean computeSubtypes) {
 				allPossibleSubtypes = CharOperation.NO_STRINGS;
 			}
 			if (allPossibleSubtypes != null) {
-				IProgressMonitor buildMonitor =
-					this.hierarchy.progressMonitor == null ?
-						null :
-						new SubProgressMonitor(this.hierarchy.progressMonitor, 100 - amountOfWorkForSubtypes);
+				SubMonitor buildMonitor = this.hierarchy.progressMonitor.split(100 - amountOfWorkForSubtypes);
 				this.hierarchy.initialize(allPossibleSubtypes.length);
 				buildFromPotentialSubtypes(allPossibleSubtypes, localTypes, buildMonitor);
 			}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
index 70118f5..3a4305f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/RegionBasedHierarchyBuilder.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,7 +16,6 @@ import java.util.Iterator;
 import java.util.Map;
 
 import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.SubProgressMonitor;
 import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
@@ -47,17 +46,9 @@ public void build(boolean computeSubtypes) {
 		manager.cacheZipFiles(this);
 
 		if (this.hierarchy.focusType == null || computeSubtypes) {
-			IProgressMonitor typeInRegionMonitor =
-				this.hierarchy.progressMonitor == null ?
-					null :
-					new SubProgressMonitor(this.hierarchy.progressMonitor, 30);
-			HashMap allOpenablesInRegion = determineOpenablesInRegion(typeInRegionMonitor);
+			HashMap allOpenablesInRegion = determineOpenablesInRegion(this.hierarchy.progressMonitor.split(30));
 			this.hierarchy.initialize(allOpenablesInRegion.size());
-			IProgressMonitor buildMonitor =
-				this.hierarchy.progressMonitor == null ?
-					null :
-					new SubProgressMonitor(this.hierarchy.progressMonitor, 70);
-			createTypeHierarchyBasedOnRegion(allOpenablesInRegion, buildMonitor);
+			createTypeHierarchyBasedOnRegion(allOpenablesInRegion, this.hierarchy.progressMonitor.split(70));
 			((RegionBasedTypeHierarchy)this.hierarchy).pruneDeadBranches();
 		} else {
 			this.hierarchy.initialize(1);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java
index d89f266..0f82b6a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java
@@ -27,10 +27,36 @@ import org.eclipse.core.runtime.ISafeRunnable;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.OperationCanceledException;
 import org.eclipse.core.runtime.SafeRunner;
-import org.eclipse.jdt.core.*;
+import org.eclipse.core.runtime.SubMonitor;
+import org.eclipse.jdt.core.ElementChangedEvent;
+import org.eclipse.jdt.core.Flags;
+import org.eclipse.jdt.core.IClasspathEntry;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IElementChangedListener;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaElementDelta;
+import org.eclipse.jdt.core.IJavaModelStatusConstants;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IOpenable;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeHierarchy;
+import org.eclipse.jdt.core.ITypeHierarchyChangedListener;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.WorkingCopyOwner;
 import org.eclipse.jdt.core.search.IJavaSearchScope;
 import org.eclipse.jdt.core.search.SearchEngine;
-import org.eclipse.jdt.internal.core.*;
+import org.eclipse.jdt.internal.core.ClassFile;
+import org.eclipse.jdt.internal.core.CompilationUnit;
+import org.eclipse.jdt.internal.core.JavaElement;
+import org.eclipse.jdt.internal.core.JavaModelStatus;
+import org.eclipse.jdt.internal.core.JavaProject;
+import org.eclipse.jdt.internal.core.Openable;
+import org.eclipse.jdt.internal.core.PackageFragment;
+import org.eclipse.jdt.internal.core.Region;
+import org.eclipse.jdt.internal.core.TypeVector;
 import org.eclipse.jdt.internal.core.util.Messages;
 import org.eclipse.jdt.internal.core.util.Util;
 
@@ -90,7 +116,7 @@ public class TypeHierarchy implements ITypeHierarchy, IElementChangedListener {
 	/**
 	 * The progress monitor to report work completed too.
 	 */
-	protected IProgressMonitor progressMonitor = null;
+	protected SubMonitor progressMonitor = SubMonitor.convert(null);
 
 	/**
 	 * Change listeners - null if no one is listening.
@@ -1239,14 +1265,11 @@ protected boolean packageRegionContainsSamePackageFragment(PackageFragment eleme
  */
 public synchronized void refresh(IProgressMonitor monitor) throws JavaModelException {
 	try {
-		this.progressMonitor = monitor;
-		if (monitor != null) {
-			monitor.beginTask(
-					this.focusType != null ?
-							Messages.bind(Messages.hierarchy_creatingOnType, this.focusType.getFullyQualifiedName()) :
-							Messages.hierarchy_creating,
-					100);
-		}
+		this.progressMonitor = SubMonitor.convert(monitor,
+			this.focusType != null ?
+					Messages.bind(Messages.hierarchy_creatingOnType, this.focusType.getFullyQualifiedName()) :
+					Messages.hierarchy_creating,
+			100);
 		long start = -1;
 		if (DEBUG) {
 			start = System.currentTimeMillis();
commit 4d36cf912bda83cf994dbb030b9c8cbc9e169048
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Nov 11 08:56:19 2015 -0800

    Bug 477790 - Adopt SubMonitor in JDT core
    
    Change-Id: I67cf1238bebe4a8fdf54e2b03c3164eb32eba281
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

40	47	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
148	168	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
5	15	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
469	521	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
index 55023d2..f7c257e 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
@@ -24,8 +24,7 @@ import java.util.Set;
 
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.core.runtime.SubProgressMonitor;
+import org.eclipse.core.runtime.SubMonitor;
 import org.eclipse.jdt.core.Flags;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IImportDeclaration;
@@ -68,8 +67,8 @@ import org.eclipse.jdt.core.dom.StringLiteral;
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeLiteral;
 import org.eclipse.jdt.core.dom.WildcardType;
-import org.eclipse.jdt.internal.core.dom.rewrite.imports.ImportRewriteConfiguration;
 import org.eclipse.jdt.internal.core.dom.rewrite.imports.ImportRewriteAnalyzer;
+import org.eclipse.jdt.internal.core.dom.rewrite.imports.ImportRewriteConfiguration;
 import org.eclipse.jdt.internal.core.dom.rewrite.imports.ImportRewriteConfiguration.ImplicitImportIdentification;
 import org.eclipse.jdt.internal.core.dom.rewrite.imports.ImportRewriteConfiguration.ImportContainerSorting;
 import org.eclipse.jdt.internal.core.util.Messages;
@@ -1131,61 +1130,55 @@ public final class ImportRewrite {
 	 * @throws CoreException the exception is thrown if the rewrite fails.
 	 */
 	public final TextEdit rewriteImports(IProgressMonitor monitor) throws CoreException {
-		if (monitor == null) {
-			monitor= new NullProgressMonitor();
-		}
 
-		try {
-			monitor.beginTask(Messages.bind(Messages.importRewrite_processDescription), 2);
-			if (!hasRecordedChanges()) {
-				this.createdImports= CharOperation.NO_STRINGS;
-				this.createdStaticImports= CharOperation.NO_STRINGS;
-				return new MultiTextEdit();
-			}
+		SubMonitor subMonitor = SubMonitor.convert(monitor,
+				Messages.bind(Messages.importRewrite_processDescription), 2);
+		if (!hasRecordedChanges()) {
+			this.createdImports= CharOperation.NO_STRINGS;
+			this.createdStaticImports= CharOperation.NO_STRINGS;
+			return new MultiTextEdit();
+		}
 
-			CompilationUnit usedAstRoot= this.astRoot;
-			if (usedAstRoot == null) {
-				ASTParser parser= ASTParser.newParser(AST.JLS8);
-				parser.setSource(this.compilationUnit);
-				parser.setFocalPosition(0); // reduced AST
-				parser.setResolveBindings(false);
-				usedAstRoot= (CompilationUnit) parser.createAST(new SubProgressMonitor(monitor, 1));
-			}
+		CompilationUnit usedAstRoot= this.astRoot;
+		if (usedAstRoot == null) {
+			ASTParser parser= ASTParser.newParser(AST.JLS8);
+			parser.setSource(this.compilationUnit);
+			parser.setFocalPosition(0); // reduced AST
+			parser.setResolveBindings(false);
+			usedAstRoot= (CompilationUnit) parser.createAST(subMonitor.split(1));
+		}
 
-			ImportRewriteConfiguration config= buildImportRewriteConfiguration();
+		ImportRewriteConfiguration config= buildImportRewriteConfiguration();
 
-			ImportRewriteAnalyzer computer=
-				new ImportRewriteAnalyzer(this.compilationUnit, usedAstRoot, config);
+		ImportRewriteAnalyzer computer=
+			new ImportRewriteAnalyzer(this.compilationUnit, usedAstRoot, config);
 
-			for (String addedImport : this.addedImports) {
-				boolean isStatic = STATIC_PREFIX == addedImport.charAt(0);
-				String qualifiedName = addedImport.substring(1);
-				computer.addImport(isStatic, qualifiedName);
-			}
+		for (String addedImport : this.addedImports) {
+			boolean isStatic = STATIC_PREFIX == addedImport.charAt(0);
+			String qualifiedName = addedImport.substring(1);
+			computer.addImport(isStatic, qualifiedName);
+		}
 
-			for (String removedImport : this.removedImports) {
-				boolean isStatic = STATIC_PREFIX == removedImport.charAt(0);
-				String qualifiedName = removedImport.substring(1);
-				computer.removeImport(isStatic, qualifiedName);
-			}
+		for (String removedImport : this.removedImports) {
+			boolean isStatic = STATIC_PREFIX == removedImport.charAt(0);
+			String qualifiedName = removedImport.substring(1);
+			computer.removeImport(isStatic, qualifiedName);
+		}
 
-			for (String typeExplicitSimpleName : this.typeExplicitSimpleNames) {
-				computer.requireExplicitImport(false, typeExplicitSimpleName);
-			}
+		for (String typeExplicitSimpleName : this.typeExplicitSimpleNames) {
+			computer.requireExplicitImport(false, typeExplicitSimpleName);
+		}
 
-			for (String staticExplicitSimpleName : this.staticExplicitSimpleNames) {
-				computer.requireExplicitImport(true, staticExplicitSimpleName);
-			}
+		for (String staticExplicitSimpleName : this.staticExplicitSimpleNames) {
+			computer.requireExplicitImport(true, staticExplicitSimpleName);
+		}
 
-			ImportRewriteAnalyzer.RewriteResult result= computer.analyzeRewrite(new SubProgressMonitor(monitor, 1));
+		ImportRewriteAnalyzer.RewriteResult result= computer.analyzeRewrite(subMonitor.split(1));
 
-			this.createdImports= result.getCreatedImports();
-			this.createdStaticImports= result.getCreatedStaticImports();
+		this.createdImports= result.getCreatedImports();
+		this.createdStaticImports= result.getCreatedStaticImports();
 
-			return result.getTextEdit();
-		} finally {
-			monitor.done();
-		}
+		return result.getTextEdit();
 	}
 
 	private ImportRewriteConfiguration buildImportRewriteConfiguration() {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 55ad05f..46b045b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -125,7 +125,7 @@ import org.eclipse.core.runtime.Path;
 import org.eclipse.core.runtime.Platform;
 import org.eclipse.core.runtime.Plugin;
 import org.eclipse.core.runtime.QualifiedName;
-import org.eclipse.core.runtime.SubProgressMonitor;
+import org.eclipse.core.runtime.SubMonitor;
 import org.eclipse.core.runtime.jobs.ISchedulingRule;
 import org.eclipse.core.resources.IContainer;
 import org.eclipse.core.resources.IFile;
@@ -4067,191 +4067,171 @@ public final class JavaCore extends Plugin {
 	 * @since 3.1
 	 */
 	public static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException {
-		try {
-			if (monitor != null) {
-				monitor.beginTask(Messages.javamodel_initialization, 100);
-				monitor.subTask(Messages.javamodel_configuring_classpath_containers);
-			}
+		SubMonitor mainMonitor = SubMonitor.convert(monitor, Messages.javamodel_initialization, 100);
+		mainMonitor.subTask(Messages.javamodel_configuring_classpath_containers);
 
-			// initialize all containers and variables
-			JavaModelManager manager = JavaModelManager.getJavaModelManager();
-			SubProgressMonitor subMonitor = null;
-			try {
-				if (monitor != null) {
-					subMonitor = new SubProgressMonitor(monitor, 50); // 50% of the time is spent in initializing containers and variables
-					subMonitor.beginTask("", 100); //$NON-NLS-1$
-					subMonitor.worked(5); // give feedback to the user that something is happening
-					manager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(subMonitor);
-				}
-				if (manager.forceBatchInitializations(true/*initAfterLoad*/)) { // if no other thread has started the batch container initializations
-					manager.getClasspathContainer(Path.EMPTY, null); // force the batch initialization
-				} else { // else wait for the batch initialization to finish
-					while (manager.batchContainerInitializations == JavaModelManager.BATCH_INITIALIZATION_IN_PROGRESS) {
-						if (subMonitor != null) {
-							subMonitor.subTask(manager.batchContainerInitializationsProgress.subTaskName);
-							subMonitor.worked(manager.batchContainerInitializationsProgress.getWorked());
-						}
-						synchronized(manager) {
-							try {
-								manager.wait(100);
-							} catch (InterruptedException e) {
-								// continue
-							}
+		// initialize all containers and variables
+		JavaModelManager manager = JavaModelManager.getJavaModelManager();
+		try {
+			SubMonitor subMonitor = mainMonitor.split(50).setWorkRemaining(100); // 50% of the time is spent in initializing containers and variables
+			subMonitor.worked(5); // give feedback to the user that something is happening
+			manager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(subMonitor);
+			if (manager.forceBatchInitializations(true/*initAfterLoad*/)) { // if no other thread has started the batch container initializations
+				manager.getClasspathContainer(Path.EMPTY, null); // force the batch initialization
+			} else { // else wait for the batch initialization to finish
+				while (manager.batchContainerInitializations == JavaModelManager.BATCH_INITIALIZATION_IN_PROGRESS) {
+					subMonitor.subTask(manager.batchContainerInitializationsProgress.subTaskName);
+					subMonitor.worked(manager.batchContainerInitializationsProgress.getWorked());
+					synchronized(manager) {
+						try {
+							manager.wait(100);
+						} catch (InterruptedException e) {
+							// continue
 						}
 					}
 				}
-			} finally {
-				if (subMonitor != null)
-					subMonitor.done();
-				manager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(null);
 			}
+		} finally {
+			manager.batchContainerInitializationsProgress.initializeAfterLoadMonitor.set(null);
+		}
 
-			// avoid leaking source attachment properties (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=183413 )
-			// and recreate links for external folders if needed
-			if (monitor != null)
-				monitor.subTask(Messages.javamodel_resetting_source_attachment_properties);
-			final IJavaProject[] projects = manager.getJavaModel().getJavaProjects();
-			HashSet visitedPaths = new HashSet();
-			ExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();
-			for (int i = 0, length = projects.length; i < length; i++) {
-				JavaProject javaProject = (JavaProject) projects[i];
-				IClasspathEntry[] classpath;
-				try {
-					classpath = javaProject.getResolvedClasspath();
-				} catch (JavaModelException e) {
-					// project no longer exist: ignore
-					continue;
-				}
-				if (classpath != null) {
-					for (int j = 0, length2 = classpath.length; j < length2; j++) {
-						IClasspathEntry entry = classpath[j];
-						if (entry.getSourceAttachmentPath() != null) {
-							IPath entryPath = entry.getPath();
-							if (visitedPaths.add(entryPath)) {
-								Util.setSourceAttachmentProperty(entryPath, null);
-							}
+		// avoid leaking source attachment properties (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=183413 )
+		// and recreate links for external folders if needed
+		mainMonitor.subTask(Messages.javamodel_resetting_source_attachment_properties);
+		final IJavaProject[] projects = manager.getJavaModel().getJavaProjects();
+		HashSet visitedPaths = new HashSet();
+		ExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();
+		for (int i = 0, length = projects.length; i < length; i++) {
+			JavaProject javaProject = (JavaProject) projects[i];
+			IClasspathEntry[] classpath;
+			try {
+				classpath = javaProject.getResolvedClasspath();
+			} catch (JavaModelException e) {
+				// project no longer exist: ignore
+				continue;
+			}
+			if (classpath != null) {
+				for (int j = 0, length2 = classpath.length; j < length2; j++) {
+					IClasspathEntry entry = classpath[j];
+					if (entry.getSourceAttachmentPath() != null) {
+						IPath entryPath = entry.getPath();
+						if (visitedPaths.add(entryPath)) {
+							Util.setSourceAttachmentProperty(entryPath, null);
 						}
-						// else source might have been attached by IPackageFragmentRoot#attachSource(...), we keep it
-						if (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
-							IPath entryPath = entry.getPath();
-							if (ExternalFoldersManager.isExternalFolderPath(entryPath) && externalFoldersManager.getFolder(entryPath) == null) {
-								externalFoldersManager.addFolder(entryPath, true);
-							}
+					}
+					// else source might have been attached by IPackageFragmentRoot#attachSource(...), we keep it
+					if (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
+						IPath entryPath = entry.getPath();
+						if (ExternalFoldersManager.isExternalFolderPath(entryPath) && externalFoldersManager.getFolder(entryPath) == null) {
+							externalFoldersManager.addFolder(entryPath, true);
 						}
 					}
 				}
 			}
-			try {
-				externalFoldersManager.createPendingFolders(monitor);
-			}
-			catch(JavaModelException jme) {
-				// Creation of external folder project failed. Log it and continue;
-				Util.log(jme, "Error while processing external folders"); //$NON-NLS-1$
-			}
+		}
+		try {
+			externalFoldersManager.createPendingFolders(mainMonitor.split(1));
+		}
+		catch(JavaModelException jme) {
+			// Creation of external folder project failed. Log it and continue;
+			Util.log(jme, "Error while processing external folders"); //$NON-NLS-1$
+		}
 
-			// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)
-			// before search is initialized (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=405051)
-			final JavaModel model = manager.getJavaModel();
-			try {
-				if (monitor != null)
-					monitor.subTask(Messages.javamodel_refreshing_external_jars);
-				model.refreshExternalArchives(
-					null/*refresh all projects*/,
-					monitor == null ? null : new SubProgressMonitor(monitor, 1) // 1% of the time is spent in jar refresh
-				);
-			} catch (JavaModelException e) {
-				// refreshing failed: ignore
-			}
+		// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)
+		// before search is initialized (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=405051)
+		final JavaModel model = manager.getJavaModel();
+		try {
+			mainMonitor.subTask(Messages.javamodel_refreshing_external_jars);
+			model.refreshExternalArchives(
+				null/*refresh all projects*/,
+				mainMonitor.split(1) // 1% of the time is spent in jar refresh
+			);
+		} catch (JavaModelException e) {
+			// refreshing failed: ignore
+		}
 
-			// initialize delta state
-			if (monitor != null)
-				monitor.subTask(Messages.javamodel_initializing_delta_state);
-			manager.deltaState.rootsAreStale = true; // in case it was already initialized before we cleaned up the source attachment properties
-			manager.deltaState.initializeRoots(true/*initAfteLoad*/);
-
-			// dummy query for waiting until the indexes are ready
-			if (monitor != null)
-				monitor.subTask(Messages.javamodel_configuring_searchengine);
-			SearchEngine engine = new SearchEngine();
-			IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
-			try {
-				engine.searchAllTypeNames(
-					null,
-					SearchPattern.R_EXACT_MATCH,
-					"!@$#!@".toCharArray(), //$NON-NLS-1$
-					SearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,
-					IJavaSearchConstants.CLASS,
-					scope,
-					new TypeNameRequestor() {
-						public void acceptType(
-							int modifiers,
-							char[] packageName,
-							char[] simpleTypeName,
-							char[][] enclosingTypeNames,
-							String path) {
-							// no type to accept
-						}
-					},
-					// will not activate index query caches if indexes are not ready, since it would take to long
-					// to wait until indexes are fully rebuild
-					IJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,
-					monitor == null ? null : new SubProgressMonitor(monitor, 49) // 49% of the time is spent in the dummy search
-				);
-			} catch (JavaModelException e) {
-				// /search failed: ignore
-			} catch (OperationCanceledException e) {
-				if (monitor != null && monitor.isCanceled())
-					throw e;
-				// else indexes were not ready: catch the exception so that jars are still refreshed
-			}
+		// initialize delta state
+		mainMonitor.subTask(Messages.javamodel_initializing_delta_state);
+		manager.deltaState.rootsAreStale = true; // in case it was already initialized before we cleaned up the source attachment properties
+		manager.deltaState.initializeRoots(true/*initAfteLoad*/);
 
-			// check if the build state version number has changed since last session
-			// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)
-			if (monitor != null)
-				monitor.subTask(Messages.javamodel_getting_build_state_number);
-			QualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, "stateVersionNumber"); //$NON-NLS-1$
-			IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
-			String versionNumber = null;
-			try {
-				versionNumber = root.getPersistentProperty(qName);
-			} catch (CoreException e) {
-				// could not read version number: consider it is new
-			}
-			String newVersionNumber = Byte.toString(State.VERSION);
-			if (!newVersionNumber.equals(versionNumber)) {
-				// build state version number has changed: touch every projects to force a rebuild
-				if (JavaBuilder.DEBUG)
-					System.out.println("Build state version number has changed"); //$NON-NLS-1$
-				IWorkspaceRunnable runnable = new IWorkspaceRunnable() {
-					public void run(IProgressMonitor progressMonitor2) throws CoreException {
-						for (int i = 0, length = projects.length; i < length; i++) {
-							IJavaProject project = projects[i];
-							try {
-								if (JavaBuilder.DEBUG)
-									System.out.println("Touching " + project.getElementName()); //$NON-NLS-1$
-								new ClasspathValidation((JavaProject) project).validate(); // https://bugs.eclipse.org/bugs/show_bug.cgi?id=287164
-								project.getProject().touch(progressMonitor2);
-							} catch (CoreException e) {
-								// could not touch this project: ignore
-							}
+		// dummy query for waiting until the indexes are ready
+		mainMonitor.subTask(Messages.javamodel_configuring_searchengine);
+		SearchEngine engine = new SearchEngine();
+		IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
+		try {
+			engine.searchAllTypeNames(
+				null,
+				SearchPattern.R_EXACT_MATCH,
+				"!@$#!@".toCharArray(), //$NON-NLS-1$
+				SearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,
+				IJavaSearchConstants.CLASS,
+				scope,
+				new TypeNameRequestor() {
+					public void acceptType(
+						int modifiers,
+						char[] packageName,
+						char[] simpleTypeName,
+						char[][] enclosingTypeNames,
+						String path) {
+						// no type to accept
+					}
+				},
+				// will not activate index query caches if indexes are not ready, since it would take to long
+				// to wait until indexes are fully rebuild
+				IJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,
+				mainMonitor.split(47) // 47% of the time is spent in the dummy search
+			);
+		} catch (JavaModelException e) {
+			// /search failed: ignore
+		} catch (OperationCanceledException e) {
+			if (mainMonitor.isCanceled())
+				throw e;
+			// else indexes were not ready: catch the exception so that jars are still refreshed
+		}
+
+		// check if the build state version number has changed since last session
+		// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)
+		mainMonitor.subTask(Messages.javamodel_getting_build_state_number);
+		QualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, "stateVersionNumber"); //$NON-NLS-1$
+		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
+		String versionNumber = null;
+		try {
+			versionNumber = root.getPersistentProperty(qName);
+		} catch (CoreException e) {
+			// could not read version number: consider it is new
+		}
+		String newVersionNumber = Byte.toString(State.VERSION);
+		if (!newVersionNumber.equals(versionNumber)) {
+			// build state version number has changed: touch every projects to force a rebuild
+			if (JavaBuilder.DEBUG)
+				System.out.println("Build state version number has changed"); //$NON-NLS-1$
+			IWorkspaceRunnable runnable = new IWorkspaceRunnable() {
+				public void run(IProgressMonitor progressMonitor2) throws CoreException {
+					for (int i = 0, length = projects.length; i < length; i++) {
+						IJavaProject project = projects[i];
+						try {
+							if (JavaBuilder.DEBUG)
+								System.out.println("Touching " + project.getElementName()); //$NON-NLS-1$
+							new ClasspathValidation((JavaProject) project).validate(); // https://bugs.eclipse.org/bugs/show_bug.cgi?id=287164
+							project.getProject().touch(progressMonitor2);
+						} catch (CoreException e) {
+							// could not touch this project: ignore
 						}
 					}
-				};
-				if (monitor != null)
-					monitor.subTask(Messages.javamodel_building_after_upgrade);
-				try {
-					ResourcesPlugin.getWorkspace().run(runnable, monitor);
-				} catch (CoreException e) {
-					// could not touch all projects
-				}
-				try {
-					root.setPersistentProperty(qName, newVersionNumber);
-				} catch (CoreException e) {
-					Util.log(e, "Could not persist build state version number"); //$NON-NLS-1$
 				}
+			};
+			mainMonitor.subTask(Messages.javamodel_building_after_upgrade);
+			try {
+				ResourcesPlugin.getWorkspace().run(runnable, mainMonitor.split(1));
+			} catch (CoreException e) {
+				// could not touch all projects
+			}
+			try {
+				root.setPersistentProperty(qName, newVersionNumber);
+			} catch (CoreException e) {
+				Util.log(e, "Could not persist build state version number"); //$NON-NLS-1$
 			}
-		} finally {
-			if (monitor != null) monitor.done();
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index 8230d55..56fb0ef 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -3066,22 +3066,12 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 	void touchProjects(final IProject[] projectsToTouch, IProgressMonitor progressMonitor) throws JavaModelException {
 		WorkspaceJob touchJob = new WorkspaceJob(Messages.synchronizing_projects_job) {
 			public IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {
-				try {
-					if (monitor != null) {
-						monitor.beginTask("", projectsToTouch.length); //$NON-NLS-1$
-					}
-					for (IProject iProject : projectsToTouch) {
-						IProgressMonitor subMonitor = monitor == null ? null: new SubProgressMonitor(monitor, 1);
-						if (JavaBuilder.DEBUG) {
-							System.out.println("Touching project " + iProject.getName()); //$NON-NLS-1$
-						}
-						iProject.touch(subMonitor);
-					}
-				}
-				finally {
-					if (monitor != null) {
-						monitor.done();
+				SubMonitor subMonitor = SubMonitor.convert(monitor, projectsToTouch.length);
+				for (IProject iProject : projectsToTouch) {
+					if (JavaBuilder.DEBUG) {
+						System.out.println("Touching project " + iProject.getName()); //$NON-NLS-1$
 					}
+					iProject.touch(subMonitor.split(1));
 				}
 				return Status.OK_STATUS;
 			}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
index f447138..7e03c45 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/BasicSearchEngine.java
@@ -186,7 +186,6 @@ public class BasicSearchEngine {
 	 * @param requestor a callback object to which each match is reported
 	 */
 	void findMatches(SearchPattern pattern, SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException {
-		if (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();
 		try {
 			if (VERBOSE) {
 				Util.verbose("Searching for pattern: " + pattern.toString()); //$NON-NLS-1$
@@ -199,27 +198,25 @@ public class BasicSearchEngine {
 
 			/* initialize progress monitor */
 			int length = participants.length;
-			if (monitor != null)
-				monitor.beginTask(Messages.engine_searching, 100 * length);
+			SubMonitor loopMonitor = SubMonitor.convert(monitor, Messages.engine_searching, length);
 			IndexManager indexManager = JavaModelManager.getIndexManager();
 			requestor.beginReporting();
 			for (int i = 0; i < length; i++) {
-				if (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();
+				SubMonitor iterationMonitor = loopMonitor.split(1).setWorkRemaining(100);
 
 				SearchParticipant participant = participants[i];
 				try {
-					if (monitor != null) monitor.subTask(Messages.bind(Messages.engine_searching_indexing, new String[] {participant.getDescription()}));
+					iterationMonitor.subTask(Messages.bind(Messages.engine_searching_indexing, new String[] {participant.getDescription()}));
 					participant.beginSearching();
 					requestor.enterParticipant(participant);
 					PathCollector pathCollector = new PathCollector();
 					indexManager.performConcurrentJob(
 						new PatternSearchJob(pattern, participant, scope, pathCollector),
 						IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
-						monitor==null ? null : new SubProgressMonitor(monitor, 50));
-					if (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();
+						iterationMonitor.split(50));
 
 					// locate index matches if any (note that all search matches could have been issued during index querying)
-					if (monitor != null) monitor.subTask(Messages.bind(Messages.engine_searching_matching, new String[] {participant.getDescription()}));
+					iterationMonitor.subTask(Messages.bind(Messages.engine_searching_matching, new String[] {participant.getDescription()}));
 					String[] indexMatchPaths = pathCollector.getPaths();
 					if (indexMatchPaths != null) {
 						pathCollector = null; // release
@@ -229,7 +226,7 @@ public class BasicSearchEngine {
 							indexMatches[j] = participant.getDocument(indexMatchPaths[j]);
 						}
 						SearchDocument[] matches = MatchLocator.addWorkingCopies(pattern, indexMatches, getWorkingCopies(), participant);
-						participant.locateMatches(matches, pattern, scope, requestor, monitor==null ? null : new SubProgressMonitor(monitor, 50));
+						participant.locateMatches(matches, pattern, scope, requestor, iterationMonitor.split(50));
 					}
 				} finally {
 					requestor.exitParticipant(participant);
@@ -238,8 +235,6 @@ public class BasicSearchEngine {
 			}
 		} finally {
 			requestor.endReporting();
-			if (monitor != null)
-				monitor.done();
 		}
 	}
 	/**
@@ -680,83 +675,65 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 			}
 		};
 
-		try {
-			if (progressMonitor != null) {
-				progressMonitor.beginTask(Messages.engine_searching, 1000);
-			}
-			// add type names from indexes
-			indexManager.performConcurrentJob(
-				new PatternSearchJob(
-					pattern,
-					getDefaultSearchParticipant(), // Java search only
-					scope,
-					searchRequestor),
-				waitingPolicy,
-				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1000-copiesLength));
-
-			// add type names from working copies
-			if (copies != null) {
-				for (int i = 0; i < copiesLength; i++) {
-					final ICompilationUnit workingCopy = copies[i];
-					if (scope instanceof HierarchyScope) {
-						if (!((HierarchyScope)scope).encloses(workingCopy, progressMonitor)) continue;
-					} else {
-						if (!scope.encloses(workingCopy)) continue;
-					}
-					
-					final String path = workingCopy.getPath().toString();
-					if (workingCopy.isConsistent()) {
-						IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
-						char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
-						IType[] allTypes = workingCopy.getAllTypes();
-						for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
-							IType type = allTypes[j];
-							char[] simpleName = type.getElementName().toCharArray();
-							if (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, simpleName) && !type.isMember()) {
-								
-								int extraFlags = ExtraFlags.getExtraFlags(type);
-								
-								boolean hasConstructor = false;
-								
-								IMethod[] methods = type.getMethods();
-								for (int k = 0; k < methods.length; k++) {
-									IMethod method = methods[k];
-									if (method.isConstructor()) {
-										hasConstructor = true;
-										
-										String[] stringParameterNames = method.getParameterNames();
-										String[] stringParameterTypes = method.getParameterTypes();
-										int length = stringParameterNames.length;
-										char[][] parameterNames = new char[length][];
-										char[][] parameterTypes = new char[length][];
-										for (int l = 0; l < length; l++) {
-											parameterNames[l] = stringParameterNames[l].toCharArray();
-											parameterTypes[l] = Signature.toCharArray(Signature.getTypeErasure(stringParameterTypes[l]).toCharArray());
-										}
-										
-										nameRequestor.acceptConstructor(
-												method.getFlags(),
-												simpleName,
-												parameterNames.length,
-												null,// signature is not used for source type
-												parameterTypes, 
-												parameterNames,
-												type.getFlags(),
-												packageDeclaration,
-												extraFlags,
-												path,
-												null);
+		SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 1000);
+		// add type names from indexes
+		indexManager.performConcurrentJob(
+			new PatternSearchJob(
+				pattern,
+				getDefaultSearchParticipant(), // Java search only
+				scope,
+				searchRequestor),
+			waitingPolicy,
+			subMonitor.split(Math.max(1000-copiesLength, 0)));
+
+		// add type names from working copies
+		if (copies != null) {
+			for (int i = 0; i < copiesLength; i++) {
+				SubMonitor iterationMonitor = subMonitor.split(1);
+				final ICompilationUnit workingCopy = copies[i];
+				if (scope instanceof HierarchyScope) {
+					if (!((HierarchyScope)scope).encloses(workingCopy, iterationMonitor)) continue;
+				} else {
+					if (!scope.encloses(workingCopy)) continue;
+				}
+				
+				final String path = workingCopy.getPath().toString();
+				if (workingCopy.isConsistent()) {
+					IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
+					char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
+					IType[] allTypes = workingCopy.getAllTypes();
+					for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
+						IType type = allTypes[j];
+						char[] simpleName = type.getElementName().toCharArray();
+						if (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, simpleName) && !type.isMember()) {
+							
+							int extraFlags = ExtraFlags.getExtraFlags(type);
+							
+							boolean hasConstructor = false;
+							
+							IMethod[] methods = type.getMethods();
+							for (int k = 0; k < methods.length; k++) {
+								IMethod method = methods[k];
+								if (method.isConstructor()) {
+									hasConstructor = true;
+									
+									String[] stringParameterNames = method.getParameterNames();
+									String[] stringParameterTypes = method.getParameterTypes();
+									int length = stringParameterNames.length;
+									char[][] parameterNames = new char[length][];
+									char[][] parameterTypes = new char[length][];
+									for (int l = 0; l < length; l++) {
+										parameterNames[l] = stringParameterNames[l].toCharArray();
+										parameterTypes[l] = Signature.toCharArray(Signature.getTypeErasure(stringParameterTypes[l]).toCharArray());
 									}
-								}
-								
-								if (!hasConstructor) {
+									
 									nameRequestor.acceptConstructor(
-											Flags.AccPublic,
+											method.getFlags(),
 											simpleName,
-											-1,
-											null, // signature is not used for source type
-											CharOperation.NO_CHAR_CHAR,
-											CharOperation.NO_CHAR_CHAR,
+											parameterNames.length,
+											null,// signature is not used for source type
+											parameterTypes, 
+											parameterNames,
 											type.getFlags(),
 											packageDeclaration,
 											extraFlags,
@@ -764,137 +741,144 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 											null);
 								}
 							}
+							
+							if (!hasConstructor) {
+								nameRequestor.acceptConstructor(
+										Flags.AccPublic,
+										simpleName,
+										-1,
+										null, // signature is not used for source type
+										CharOperation.NO_CHAR_CHAR,
+										CharOperation.NO_CHAR_CHAR,
+										type.getFlags(),
+										packageDeclaration,
+										extraFlags,
+										path,
+										null);
+							}
 						}
-					} else {
-						Parser basicParser = getParser();
-						org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
-						CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
-						CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
-						if (parsedUnit != null) {
-							final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
-							class AllConstructorDeclarationsVisitor extends ASTVisitor {
-								private TypeDeclaration[] declaringTypes = new TypeDeclaration[0];
-								private int declaringTypesPtr = -1;
-								
-								private void endVisit(TypeDeclaration typeDeclaration) {
-									if (!hasConstructor(typeDeclaration) && typeDeclaration.enclosingType == null) {
-									
-										if (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, typeDeclaration.name)) {
-											nameRequestor.acceptConstructor(
-													Flags.AccPublic,
-													typeName,
-													-1,
-													null, // signature is not used for source type
-													CharOperation.NO_CHAR_CHAR,
-													CharOperation.NO_CHAR_CHAR,
-													typeDeclaration.modifiers,
-													packageDeclaration,
-													ExtraFlags.getExtraFlags(typeDeclaration),
-													path,
-													null);
-										}
-									}
-									
-									this.declaringTypes[this.declaringTypesPtr] = null;
-									this.declaringTypesPtr--;
-								}
-								
-								public void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
-									endVisit(typeDeclaration);
-								}
-								
-								public void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
-									endVisit(memberTypeDeclaration);
-								}
+					}
+				} else {
+					Parser basicParser = getParser();
+					org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
+					CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
+					CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
+					if (parsedUnit != null) {
+						final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
+						class AllConstructorDeclarationsVisitor extends ASTVisitor {
+							private TypeDeclaration[] declaringTypes = new TypeDeclaration[0];
+							private int declaringTypesPtr = -1;
+							
+							private void endVisit(TypeDeclaration typeDeclaration) {
+								if (!hasConstructor(typeDeclaration) && typeDeclaration.enclosingType == null) {
 								
-								private boolean hasConstructor(TypeDeclaration typeDeclaration) {
-									AbstractMethodDeclaration[] methods = typeDeclaration.methods;
-									int length = methods == null ? 0 : methods.length;
-									for (int j = 0; j < length; j++) {
-										if (methods[j].isConstructor()) {
-											return true;
-										}
-									}
-									
-									return false;
-								}
-								public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope classScope) {
-									TypeDeclaration typeDeclaration = this.declaringTypes[this.declaringTypesPtr];
 									if (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, typeDeclaration.name)) {
-										Argument[] arguments = constructorDeclaration.arguments;
-										int length = arguments == null ? 0 : arguments.length;
-										char[][] parameterNames = new char[length][];
-										char[][] parameterTypes = new char[length][];
-										for (int l = 0; l < length; l++) {
-											Argument argument = arguments[l];
-											parameterNames[l] = argument.name;
-											if (argument.type instanceof SingleTypeReference) {
-												parameterTypes[l] = ((SingleTypeReference)argument.type).token;
-											} else {
-												parameterTypes[l] = CharOperation.concatWith(((QualifiedTypeReference)argument.type).tokens, '.');
-											}
-										}
-										
-										TypeDeclaration enclosing = typeDeclaration.enclosingType;
-										char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
-										while (enclosing != null) {
-											enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
-											if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
-												enclosing = enclosing.enclosingType;
-											} else {
-												enclosing = null;
-											}
-										}
-										
 										nameRequestor.acceptConstructor(
-												constructorDeclaration.modifiers,
+												Flags.AccPublic,
 												typeName,
-												parameterNames.length,
+												-1,
 												null, // signature is not used for source type
-												parameterTypes,
-												parameterNames,
+												CharOperation.NO_CHAR_CHAR,
+												CharOperation.NO_CHAR_CHAR,
 												typeDeclaration.modifiers,
 												packageDeclaration,
 												ExtraFlags.getExtraFlags(typeDeclaration),
 												path,
 												null);
 									}
-									return false; // no need to find constructors from local/anonymous type
-								}
-								public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
-									return false; 
 								}
 								
-								private boolean visit(TypeDeclaration typeDeclaration) {
-									if(this.declaringTypes.length <= ++this.declaringTypesPtr) {
-										int length = this.declaringTypesPtr;
-										System.arraycopy(this.declaringTypes, 0, this.declaringTypes = new TypeDeclaration[length * 2 + 1], 0, length);
+								this.declaringTypes[this.declaringTypesPtr] = null;
+								this.declaringTypesPtr--;
+							}
+							
+							public void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
+								endVisit(typeDeclaration);
+							}
+							
+							public void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
+								endVisit(memberTypeDeclaration);
+							}
+							
+							private boolean hasConstructor(TypeDeclaration typeDeclaration) {
+								AbstractMethodDeclaration[] methods = typeDeclaration.methods;
+								int length = methods == null ? 0 : methods.length;
+								for (int j = 0; j < length; j++) {
+									if (methods[j].isConstructor()) {
+										return true;
 									}
-									this.declaringTypes[this.declaringTypesPtr] = typeDeclaration;
-									return true;
 								}
 								
-								public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
-									return visit(typeDeclaration);
+								return false;
+							}
+							public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope classScope) {
+								TypeDeclaration typeDeclaration = this.declaringTypes[this.declaringTypesPtr];
+								if (match(NoSuffix, packageName, pkgMatchRule, typeName, validatedTypeMatchRule, 0/*no kind*/, packageDeclaration, typeDeclaration.name)) {
+									Argument[] arguments = constructorDeclaration.arguments;
+									int length = arguments == null ? 0 : arguments.length;
+									char[][] parameterNames = new char[length][];
+									char[][] parameterTypes = new char[length][];
+									for (int l = 0; l < length; l++) {
+										Argument argument = arguments[l];
+										parameterNames[l] = argument.name;
+										if (argument.type instanceof SingleTypeReference) {
+											parameterTypes[l] = ((SingleTypeReference)argument.type).token;
+										} else {
+											parameterTypes[l] = CharOperation.concatWith(((QualifiedTypeReference)argument.type).tokens, '.');
+										}
+									}
+									
+									TypeDeclaration enclosing = typeDeclaration.enclosingType;
+									char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+									while (enclosing != null) {
+										enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
+										if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
+											enclosing = enclosing.enclosingType;
+										} else {
+											enclosing = null;
+										}
+									}
+									
+									nameRequestor.acceptConstructor(
+											constructorDeclaration.modifiers,
+											typeName,
+											parameterNames.length,
+											null, // signature is not used for source type
+											parameterTypes,
+											parameterNames,
+											typeDeclaration.modifiers,
+											packageDeclaration,
+											ExtraFlags.getExtraFlags(typeDeclaration),
+											path,
+											null);
 								}
-								
-								public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
-									return visit(memberTypeDeclaration);
+								return false; // no need to find constructors from local/anonymous type
+							}
+							public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
+								return false; 
+							}
+							
+							private boolean visit(TypeDeclaration typeDeclaration) {
+								if(this.declaringTypes.length <= ++this.declaringTypesPtr) {
+									int length = this.declaringTypesPtr;
+									System.arraycopy(this.declaringTypes, 0, this.declaringTypes = new TypeDeclaration[length * 2 + 1], 0, length);
 								}
+								this.declaringTypes[this.declaringTypesPtr] = typeDeclaration;
+								return true;
+							}
+							
+							public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
+								return visit(typeDeclaration);
+							}
+							
+							public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
+								return visit(memberTypeDeclaration);
 							}
-							parsedUnit.traverse(new AllConstructorDeclarationsVisitor(), parsedUnit.scope);
 						}
-					}
-					if (progressMonitor != null) {
-						if (progressMonitor.isCanceled()) throw new OperationCanceledException();
-						progressMonitor.worked(1);
+						parsedUnit.traverse(new AllConstructorDeclarationsVisitor(), parsedUnit.scope);
 					}
 				}
 			}
-		} finally {
-			if (progressMonitor != null) {
-				progressMonitor.done();
-			}
 		}
 	}
 
@@ -1023,146 +1007,135 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 				}
 			};
 
-			try {
-				if (progressMonitor != null) {
-					progressMonitor.beginTask(Messages.engine_searching, 1000);
-				}
-				// add type names from indexes
-				indexManager.performConcurrentJob(
-					new PatternSearchJob(
-						pattern,
-						getDefaultSearchParticipant(), // Java search only
-						scope,
-						searchRequestor),
-					waitingPolicy,
-					progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1000-copiesLength));
+			SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 1000);
+			// add type names from indexes
+			indexManager.performConcurrentJob(
+				new PatternSearchJob(
+					pattern,
+					getDefaultSearchParticipant(), // Java search only
+					scope,
+					searchRequestor),
+				waitingPolicy,
+				subMonitor.split(Math.max(1000-copiesLength, 0)));
 
-				// add type names from working copies
-				if (copies != null) {
-					boolean isPkgCaseSensitive = (pkgMatchRule & SearchPattern.R_CASE_SENSITIVE) != 0; 
-					for (int i = 0; i < copiesLength; i++) {
-						final ICompilationUnit workingCopy = copies[i];
-						if (scope instanceof HierarchyScope) {
-							if (!((HierarchyScope)scope).encloses(workingCopy, progressMonitor)) continue;
-						} else {
-							if (!scope.encloses(workingCopy)) continue;
-						}
+			// add type names from working copies
+			if (copies != null) {
+				boolean isPkgCaseSensitive = (pkgMatchRule & SearchPattern.R_CASE_SENSITIVE) != 0; 
+				for (int i = 0; i < copiesLength; i++) {
+					SubMonitor iterationMonitor = subMonitor.split(1);
+					final ICompilationUnit workingCopy = copies[i];
+					if (scope instanceof HierarchyScope) {
+						if (!((HierarchyScope)scope).encloses(workingCopy, iterationMonitor)) continue;
+					} else {
+						if (!scope.encloses(workingCopy)) continue;
+					}
 
-						final String path = workingCopy.getPath().toString();
-						if (workingCopy.isConsistent()) {
-							IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
-							char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
-							if (packageName != null && !CharOperation.equals(packageName, packageDeclaration, isPkgCaseSensitive))
+					final String path = workingCopy.getPath().toString();
+					if (workingCopy.isConsistent()) {
+						IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
+						char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
+						if (packageName != null && !CharOperation.equals(packageName, packageDeclaration, isPkgCaseSensitive))
+							continue;
+						
+						IType[] allTypes = workingCopy.getAllTypes();
+						for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
+							IType type = allTypes[j];
+							IJavaElement parent = type.getParent();
+							char[] rDeclaringQualification = parent instanceof IType ? ((IType) parent).getTypeQualifiedName('.').toCharArray() : CharOperation.NO_CHAR;
+							char[] rSimpleName = type.getElementName().toCharArray();
+							if (!match(declaringQualification, declQualificationMatchRule, rDeclaringQualification) ||
+									!match(declaringSimpleName, declSimpleNameMatchRule, rSimpleName))
 								continue;
-							
-							IType[] allTypes = workingCopy.getAllTypes();
-							for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
-								IType type = allTypes[j];
-								IJavaElement parent = type.getParent();
-								char[] rDeclaringQualification = parent instanceof IType ? ((IType) parent).getTypeQualifiedName('.').toCharArray() : CharOperation.NO_CHAR;
-								char[] rSimpleName = type.getElementName().toCharArray();
-								if (!match(declaringQualification, declQualificationMatchRule, rDeclaringQualification) ||
-										!match(declaringSimpleName, declSimpleNameMatchRule, rSimpleName))
-									continue;
-								reportMatchingMethods(methodName, methodMatchRule, nameRequestor, path,
-										packageDeclaration, type, rDeclaringQualification, rSimpleName); 
-							}
-						} else {
-							Parser basicParser = getParser();
-							org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
-							CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
-							CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
-							if (parsedUnit != null) {
-								final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
-								class AllMethodDeclarationVisitor extends ASTVisitor {
-
-									class TypeInfo {
-										public TypeDeclaration typeDecl;
-										public IType type;
-										public boolean visitMethods;
-										public char[] enclosingTypeName;
-										
-										TypeInfo(TypeDeclaration typeDecl, boolean visitMethods, char[] enclosingTypeName) {
-											this.typeDecl = typeDecl;
-											this.type = workingCopy.getType(new String(typeDecl.name));
-											this.visitMethods = visitMethods;
-											this.enclosingTypeName = enclosingTypeName;
-										}
+							reportMatchingMethods(methodName, methodMatchRule, nameRequestor, path,
+									packageDeclaration, type, rDeclaringQualification, rSimpleName); 
+						}
+					} else {
+						Parser basicParser = getParser();
+						org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
+						CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
+						CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
+						if (parsedUnit != null) {
+							final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
+							class AllMethodDeclarationVisitor extends ASTVisitor {
+
+								class TypeInfo {
+									public TypeDeclaration typeDecl;
+									public IType type;
+									public boolean visitMethods;
+									public char[] enclosingTypeName;
+									
+									TypeInfo(TypeDeclaration typeDecl, boolean visitMethods, char[] enclosingTypeName) {
+										this.typeDecl = typeDecl;
+										this.type = workingCopy.getType(new String(typeDecl.name));
+										this.visitMethods = visitMethods;
+										this.enclosingTypeName = enclosingTypeName;
 									}
-									Stack<TypeInfo> typeInfoStack = new Stack<>();
-									IType getCurrentType() {
-										int l = this.typeInfoStack.size();
-										if (l <= 0) return null;
-										TypeInfo typeInfo = this.typeInfoStack.get(0);
-										IType type = typeInfo.type;
-										if (type == null) {
-											TypeInfo ti = this.typeInfoStack.get(0);
-											ti.type = ti.type == null ? workingCopy.getType(new String(ti.typeDecl.name)) : ti.type;
-											type = ti.type;
-											for (int j = 1; j < l && type != null; ++j) {
-												ti = this.typeInfoStack.get(j);
-												if (ti.type == null) {
-													ti.type = type.getType(new String(ti.typeDecl.name));
-												}
-												type = ti.type;
+								}
+								Stack<TypeInfo> typeInfoStack = new Stack<>();
+								IType getCurrentType() {
+									int l = this.typeInfoStack.size();
+									if (l <= 0) return null;
+									TypeInfo typeInfo = this.typeInfoStack.get(0);
+									IType type = typeInfo.type;
+									if (type == null) {
+										TypeInfo ti = this.typeInfoStack.get(0);
+										ti.type = ti.type == null ? workingCopy.getType(new String(ti.typeDecl.name)) : ti.type;
+										type = ti.type;
+										for (int j = 1; j < l && type != null; ++j) {
+											ti = this.typeInfoStack.get(j);
+											if (ti.type == null) {
+												ti.type = type.getType(new String(ti.typeDecl.name));
 											}
+											type = ti.type;
 										}
-										return type;
 									}
+									return type;
+								}
 
-									private void addStackEntry(TypeDeclaration typeDeclaration, char[] enclosingTypeName) {
-										boolean visitMethods = match(declaringQualification, declQualificationMatchRule, enclosingTypeName) &&
-												match(declaringSimpleName, declSimpleNameMatchRule, typeDeclaration.name);
-										this.typeInfoStack.push(new TypeInfo(typeDeclaration, visitMethods, enclosingTypeName));
-									}
-									public void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
-										this.typeInfoStack.pop();
-									}
-									public void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
-										this.typeInfoStack.pop();
-									}
-									public boolean visit(MethodDeclaration methodDeclaration, ClassScope classScope) {
-										TypeInfo typeInfo = this.typeInfoStack.peek();
-										if (typeInfo.visitMethods &&
-											match(methodName, methodMatchRule, methodDeclaration.selector)) {
-											reportMatchingMethod(path, packageDeclaration,
-													typeInfo.enclosingTypeName, 
-													typeInfo.typeDecl, 
-													methodDeclaration,
-													getCurrentType(),
-													nameRequestor);
-										}
-										
-										return false; // no need to find methods from local/anonymous type
-									}
-									public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
-										return false; // do not visit local/anonymous types
-									}
-									public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
-										addStackEntry(typeDeclaration, CharOperation.NO_CHAR);
-										return true;
-									}
-									public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
-										TypeInfo typeInfo = this.typeInfoStack.peek();
-										addStackEntry(memberTypeDeclaration, typeInfo.enclosingTypeName == CharOperation.NO_CHAR ? typeInfo.typeDecl.name :
-												CharOperation.concat(typeInfo.enclosingTypeName, typeInfo.typeDecl.name, '.'));
-										return true;
+								private void addStackEntry(TypeDeclaration typeDeclaration, char[] enclosingTypeName) {
+									boolean visitMethods = match(declaringQualification, declQualificationMatchRule, enclosingTypeName) &&
+											match(declaringSimpleName, declSimpleNameMatchRule, typeDeclaration.name);
+									this.typeInfoStack.push(new TypeInfo(typeDeclaration, visitMethods, enclosingTypeName));
+								}
+								public void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
+									this.typeInfoStack.pop();
+								}
+								public void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
+									this.typeInfoStack.pop();
+								}
+								public boolean visit(MethodDeclaration methodDeclaration, ClassScope classScope) {
+									TypeInfo typeInfo = this.typeInfoStack.peek();
+									if (typeInfo.visitMethods &&
+										match(methodName, methodMatchRule, methodDeclaration.selector)) {
+										reportMatchingMethod(path, packageDeclaration,
+												typeInfo.enclosingTypeName, 
+												typeInfo.typeDecl, 
+												methodDeclaration,
+												getCurrentType(),
+												nameRequestor);
 									}
+									
+									return false; // no need to find methods from local/anonymous type
+								}
+								public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
+									return false; // do not visit local/anonymous types
+								}
+								public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope s) {
+									addStackEntry(typeDeclaration, CharOperation.NO_CHAR);
+									return true;
+								}
+								public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope s) {
+									TypeInfo typeInfo = this.typeInfoStack.peek();
+									addStackEntry(memberTypeDeclaration, typeInfo.enclosingTypeName == CharOperation.NO_CHAR ? typeInfo.typeDecl.name :
+											CharOperation.concat(typeInfo.enclosingTypeName, typeInfo.typeDecl.name, '.'));
+									return true;
 								}
-								if (match(packageName, pkgMatchRule, packageDeclaration))
-									parsedUnit.traverse(new AllMethodDeclarationVisitor(), parsedUnit.scope);
 							}
-						}
-						if (progressMonitor != null) {
-							if (progressMonitor.isCanceled()) throw new OperationCanceledException();
-							progressMonitor.worked(1);
+							if (match(packageName, pkgMatchRule, packageDeclaration))
+								parsedUnit.traverse(new AllMethodDeclarationVisitor(), parsedUnit.scope);
 						}
 					}
 				}
-			} finally {
-				if (progressMonitor != null) {
-					progressMonitor.done();
-				}
 			}
 		}
 
@@ -1366,9 +1339,7 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 
 		// add type names from indexes
 		try {
-			if (progressMonitor != null) {
-				progressMonitor.beginTask(Messages.engine_searching, 100);
-			}
+			SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 100);
 			indexManager.performConcurrentJob(
 				new PatternSearchJob(
 					pattern,
@@ -1378,13 +1349,9 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 				waitForIndexes
 					? IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH
 					: IJavaSearchConstants.FORCE_IMMEDIATE_SEARCH,
-				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));
+				subMonitor.split(100));
 		} catch (OperationCanceledException oce) {
 			// do nothing
-		} finally {
-			if (progressMonitor != null) {
-				progressMonitor.done();
-			}
 		}
 	}
 
@@ -1538,125 +1505,114 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 			}
 		};
 
-		try {
-			if (progressMonitor != null) {
-				progressMonitor.beginTask(Messages.engine_searching, 1000);
-			}
-			// add type names from indexes
-			indexManager.performConcurrentJob(
-				new PatternSearchJob(
-					pattern,
-					getDefaultSearchParticipant(), // Java search only
-					scope,
-					searchRequestor),
-				waitingPolicy,
-				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1000-copiesLength));
-
-			// add type names from working copies
-			if (copies != null) {
-				for (int i = 0; i < copiesLength; i++) {
-					final ICompilationUnit workingCopy = copies[i];
-					if (scope instanceof HierarchyScope) {
-						if (!((HierarchyScope)scope).encloses(workingCopy, progressMonitor)) continue;
-					} else {
-						if (!scope.encloses(workingCopy)) continue;
-					}
-					final String path = workingCopy.getPath().toString();
-					if (workingCopy.isConsistent()) {
-						IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
-						char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
-						IType[] allTypes = workingCopy.getAllTypes();
-						for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
-							IType type = allTypes[j];
-							IJavaElement parent = type.getParent();
-							char[][] enclosingTypeNames;
-							if (parent instanceof IType) {
-								char[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();
-								enclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);
+		SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 1000);
+		// add type names from indexes
+		indexManager.performConcurrentJob(
+			new PatternSearchJob(
+				pattern,
+				getDefaultSearchParticipant(), // Java search only
+				scope,
+				searchRequestor),
+			waitingPolicy,
+			subMonitor.split(Math.max(1000-copiesLength, 0)));
+
+		// add type names from working copies
+		if (copies != null) {
+			for (int i = 0; i < copiesLength; i++) {
+				SubMonitor iterationMonitor = subMonitor.split(i);
+				final ICompilationUnit workingCopy = copies[i];
+				if (scope instanceof HierarchyScope) {
+					if (!((HierarchyScope)scope).encloses(workingCopy, iterationMonitor)) continue;
+				} else {
+					if (!scope.encloses(workingCopy)) continue;
+				}
+				final String path = workingCopy.getPath().toString();
+				if (workingCopy.isConsistent()) {
+					IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
+					char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
+					IType[] allTypes = workingCopy.getAllTypes();
+					for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
+						IType type = allTypes[j];
+						IJavaElement parent = type.getParent();
+						char[][] enclosingTypeNames;
+						if (parent instanceof IType) {
+							char[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();
+							enclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);
+						} else {
+							enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+						}
+						char[] simpleName = type.getElementName().toCharArray();
+						int kind;
+						if (type.isEnum()) {
+							kind = TypeDeclaration.ENUM_DECL;
+						} else if (type.isAnnotation()) {
+							kind = TypeDeclaration.ANNOTATION_TYPE_DECL;
+						}	else if (type.isClass()) {
+							kind = TypeDeclaration.CLASS_DECL;
+						} else /*if (type.isInterface())*/ {
+							kind = TypeDeclaration.INTERFACE_DECL;
+						}
+						if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, kind, packageDeclaration, simpleName)) {
+							if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
+								((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, type.getFlags()));
 							} else {
-								enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+								nameRequestor.acceptType(type.getFlags(), packageDeclaration, simpleName, enclosingTypeNames, path, null);
 							}
-							char[] simpleName = type.getElementName().toCharArray();
-							int kind;
-							if (type.isEnum()) {
-								kind = TypeDeclaration.ENUM_DECL;
-							} else if (type.isAnnotation()) {
-								kind = TypeDeclaration.ANNOTATION_TYPE_DECL;
-							}	else if (type.isClass()) {
-								kind = TypeDeclaration.CLASS_DECL;
-							} else /*if (type.isInterface())*/ {
-								kind = TypeDeclaration.INTERFACE_DECL;
+						}
+					}
+				} else {
+					Parser basicParser = getParser();
+					org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
+					CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
+					CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
+					if (parsedUnit != null) {
+						final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
+						class AllTypeDeclarationsVisitor extends ASTVisitor {
+							public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
+								return false; // no local/anonymous type
 							}
-							if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, kind, packageDeclaration, simpleName)) {
-								if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
-									((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, type.getFlags()));
-								} else {
-									nameRequestor.acceptType(type.getFlags(), packageDeclaration, simpleName, enclosingTypeNames, path, null);
+							public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope compilationUnitScope) {
+								if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, TypeDeclaration.kind(typeDeclaration.modifiers), packageDeclaration, typeDeclaration.name)) {
+									if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
+										IType type = workingCopy.getType(new String(typeName));
+										((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, typeDeclaration.modifiers));
+									} else {
+										nameRequestor.acceptType(typeDeclaration.modifiers, packageDeclaration, typeDeclaration.name, CharOperation.NO_CHAR_CHAR, path, null);
+									}
 								}
+								return true;
 							}
-						}
-					} else {
-						Parser basicParser = getParser();
-						org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
-						CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
-						CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
-						if (parsedUnit != null) {
-							final char[] packageDeclaration = parsedUnit.currentPackage == null ? CharOperation.NO_CHAR : CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
-							class AllTypeDeclarationsVisitor extends ASTVisitor {
-								public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
-									return false; // no local/anonymous type
-								}
-								public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope compilationUnitScope) {
-									if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, TypeDeclaration.kind(typeDeclaration.modifiers), packageDeclaration, typeDeclaration.name)) {
-										if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
-											IType type = workingCopy.getType(new String(typeName));
-											((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, typeDeclaration.modifiers));
+							public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {
+								if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, TypeDeclaration.kind(memberTypeDeclaration.modifiers), packageDeclaration, memberTypeDeclaration.name)) {
+									// compute enclosing type names
+									TypeDeclaration enclosing = memberTypeDeclaration.enclosingType;
+									char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+									while (enclosing != null) {
+										enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
+										if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
+											enclosing = enclosing.enclosingType;
 										} else {
-											nameRequestor.acceptType(typeDeclaration.modifiers, packageDeclaration, typeDeclaration.name, CharOperation.NO_CHAR_CHAR, path, null);
+											enclosing = null;
 										}
 									}
-									return true;
-								}
-								public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {
-									if (match(typeSuffix, packageName, packageMatchRule, typeName, validatedTypeMatchRule, TypeDeclaration.kind(memberTypeDeclaration.modifiers), packageDeclaration, memberTypeDeclaration.name)) {
-										// compute enclosing type names
-										TypeDeclaration enclosing = memberTypeDeclaration.enclosingType;
-										char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
-										while (enclosing != null) {
-											enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
-											if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
-												enclosing = enclosing.enclosingType;
-											} else {
-												enclosing = null;
-											}
-										}
-										// report
-										if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
-											IType type = workingCopy.getType(new String(enclosingTypeNames[0]));
-											for (int j=1, l=enclosingTypeNames.length; j<l; j++) {
-												type = type.getType(new String(enclosingTypeNames[j]));
-											}
-											((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, 0));
-										} else {
-											nameRequestor.acceptType(memberTypeDeclaration.modifiers, packageDeclaration, memberTypeDeclaration.name, enclosingTypeNames, path, null);
+									// report
+									if (nameRequestor instanceof TypeNameMatchRequestorWrapper) {
+										IType type = workingCopy.getType(new String(enclosingTypeNames[0]));
+										for (int j=1, l=enclosingTypeNames.length; j<l; j++) {
+											type = type.getType(new String(enclosingTypeNames[j]));
 										}
+										((TypeNameMatchRequestorWrapper)nameRequestor).requestor.acceptTypeNameMatch(new JavaSearchTypeNameMatch(type, 0));
+									} else {
+										nameRequestor.acceptType(memberTypeDeclaration.modifiers, packageDeclaration, memberTypeDeclaration.name, enclosingTypeNames, path, null);
 									}
-									return true;
 								}
+								return true;
 							}
-							parsedUnit.traverse(new AllTypeDeclarationsVisitor(), parsedUnit.scope);
 						}
-					}
-					if (progressMonitor != null) {
-						if (progressMonitor.isCanceled()) throw new OperationCanceledException();
-						progressMonitor.worked(1);
+						parsedUnit.traverse(new AllTypeDeclarationsVisitor(), parsedUnit.scope);
 					}
 				}
 			}
-		} finally {
-			if (progressMonitor != null) {
-				progressMonitor.done();
-			}
 		}
 	}
 
@@ -1788,108 +1744,100 @@ boolean match(char[] patternName, int matchRule, char[] name) {
 			}
 		};
 
-		try {
-			if (progressMonitor != null) {
-				progressMonitor.beginTask(Messages.engine_searching, 100);
-			}
-			// add type names from indexes
-			indexManager.performConcurrentJob(
-				new PatternSearchJob(
-					pattern,
-					getDefaultSearchParticipant(), // Java search only
-					scope,
-					searchRequestor),
-				waitingPolicy,
-				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));
-
-			// add type names from working copies
-			if (copies != null) {
-				for (int i = 0, length = copies.length; i < length; i++) {
-					ICompilationUnit workingCopy = copies[i];
-					final String path = workingCopy.getPath().toString();
-					if (workingCopy.isConsistent()) {
-						IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
-						char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
-						IType[] allTypes = workingCopy.getAllTypes();
-						for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
-							IType type = allTypes[j];
-							IJavaElement parent = type.getParent();
-							char[][] enclosingTypeNames;
-							char[] qualification = packageDeclaration;
-							if (parent instanceof IType) {
-								char[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();
-								enclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);
-								qualification = CharOperation.concat(qualification, parentQualifiedName);
-							} else {
-								enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
-							}
-							char[] simpleName = type.getElementName().toCharArray();
-							char suffix = IIndexConstants.TYPE_SUFFIX;
-							if (type.isClass()) {
-								suffix = IIndexConstants.CLASS_SUFFIX;
-							} else if (type.isInterface()) {
-								suffix = IIndexConstants.INTERFACE_SUFFIX;
-							} else if (type.isEnum()) {
-								suffix = IIndexConstants.ENUM_SUFFIX;
-							} else if (type.isAnnotation()) {
-								suffix = IIndexConstants.ANNOTATION_TYPE_SUFFIX;
-							}
-							if (pattern.matchesDecodedKey(new QualifiedTypeDeclarationPattern(qualification, simpleName, suffix, matchRule))) {
-								nameRequestor.acceptType(type.getFlags(), packageDeclaration, simpleName, enclosingTypeNames, path, null);
-							}
+		SubMonitor subMonitor = SubMonitor.convert(progressMonitor, Messages.engine_searching, 100);
+		// add type names from indexes
+		indexManager.performConcurrentJob(
+			new PatternSearchJob(
+				pattern,
+				getDefaultSearchParticipant(), // Java search only
+				scope,
+				searchRequestor),
+			waitingPolicy,
+			subMonitor.split(100));
+
+		// add type names from working copies
+		if (copies != null) {
+			for (int i = 0, length = copies.length; i < length; i++) {
+				ICompilationUnit workingCopy = copies[i];
+				final String path = workingCopy.getPath().toString();
+				if (workingCopy.isConsistent()) {
+					IPackageDeclaration[] packageDeclarations = workingCopy.getPackageDeclarations();
+					char[] packageDeclaration = packageDeclarations.length == 0 ? CharOperation.NO_CHAR : packageDeclarations[0].getElementName().toCharArray();
+					IType[] allTypes = workingCopy.getAllTypes();
+					for (int j = 0, allTypesLength = allTypes.length; j < allTypesLength; j++) {
+						IType type = allTypes[j];
+						IJavaElement parent = type.getParent();
+						char[][] enclosingTypeNames;
+						char[] qualification = packageDeclaration;
+						if (parent instanceof IType) {
+							char[] parentQualifiedName = ((IType)parent).getTypeQualifiedName('.').toCharArray();
+							enclosingTypeNames = CharOperation.splitOn('.', parentQualifiedName);
+							qualification = CharOperation.concat(qualification, parentQualifiedName);
+						} else {
+							enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
 						}
-					} else {
-						Parser basicParser = getParser();
-						org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
-						CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
-						CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
-						if (parsedUnit != null) {
-							final char[] packageDeclaration = parsedUnit.currentPackage == null
-								? CharOperation.NO_CHAR
-								: CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
-							class AllTypeDeclarationsVisitor extends ASTVisitor {
-								public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
-									return false; // no local/anonymous type
+						char[] simpleName = type.getElementName().toCharArray();
+						char suffix = IIndexConstants.TYPE_SUFFIX;
+						if (type.isClass()) {
+							suffix = IIndexConstants.CLASS_SUFFIX;
+						} else if (type.isInterface()) {
+							suffix = IIndexConstants.INTERFACE_SUFFIX;
+						} else if (type.isEnum()) {
+							suffix = IIndexConstants.ENUM_SUFFIX;
+						} else if (type.isAnnotation()) {
+							suffix = IIndexConstants.ANNOTATION_TYPE_SUFFIX;
+						}
+						if (pattern.matchesDecodedKey(new QualifiedTypeDeclarationPattern(qualification, simpleName, suffix, matchRule))) {
+							nameRequestor.acceptType(type.getFlags(), packageDeclaration, simpleName, enclosingTypeNames, path, null);
+						}
+					}
+				} else {
+					Parser basicParser = getParser();
+					org.eclipse.jdt.internal.compiler.env.ICompilationUnit unit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) workingCopy;
+					CompilationResult compilationUnitResult = new CompilationResult(unit, 0, 0, this.compilerOptions.maxProblemsPerUnit);
+					CompilationUnitDeclaration parsedUnit = basicParser.dietParse(unit, compilationUnitResult);
+					if (parsedUnit != null) {
+						final char[] packageDeclaration = parsedUnit.currentPackage == null
+							? CharOperation.NO_CHAR
+							: CharOperation.concatWith(parsedUnit.currentPackage.getImportName(), '.');
+						class AllTypeDeclarationsVisitor extends ASTVisitor {
+							public boolean visit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
+								return false; // no local/anonymous type
+							}
+							public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope compilationUnitScope) {
+								SearchPattern decodedPattern =
+									new QualifiedTypeDeclarationPattern(packageDeclaration, typeDeclaration.name, convertTypeKind(TypeDeclaration.kind(typeDeclaration.modifiers)), matchRule);
+								if (pattern.matchesDecodedKey(decodedPattern)) {
+									nameRequestor.acceptType(typeDeclaration.modifiers, packageDeclaration, typeDeclaration.name, CharOperation.NO_CHAR_CHAR, path, null);
 								}
-								public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope compilationUnitScope) {
-									SearchPattern decodedPattern =
-										new QualifiedTypeDeclarationPattern(packageDeclaration, typeDeclaration.name, convertTypeKind(TypeDeclaration.kind(typeDeclaration.modifiers)), matchRule);
-									if (pattern.matchesDecodedKey(decodedPattern)) {
-										nameRequestor.acceptType(typeDeclaration.modifiers, packageDeclaration, typeDeclaration.name, CharOperation.NO_CHAR_CHAR, path, null);
+								return true;
+							}
+							public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {
+								// compute enclosing type names
+								char[] qualification = packageDeclaration;
+								TypeDeclaration enclosing = memberTypeDeclaration.enclosingType;
+								char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
+								while (enclosing != null) {
+									qualification = CharOperation.concat(qualification, enclosing.name, '.');
+									enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
+									if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
+										enclosing = enclosing.enclosingType;
+									} else {
+										enclosing = null;
 									}
-									return true;
 								}
-								public boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope classScope) {
-									// compute enclosing type names
-									char[] qualification = packageDeclaration;
-									TypeDeclaration enclosing = memberTypeDeclaration.enclosingType;
-									char[][] enclosingTypeNames = CharOperation.NO_CHAR_CHAR;
-									while (enclosing != null) {
-										qualification = CharOperation.concat(qualification, enclosing.name, '.');
-										enclosingTypeNames = CharOperation.arrayConcat(new char[][] {enclosing.name}, enclosingTypeNames);
-										if ((enclosing.bits & ASTNode.IsMemberType) != 0) {
-											enclosing = enclosing.enclosingType;
-										} else {
-											enclosing = null;
-										}
-									}
-									SearchPattern decodedPattern =
-										new QualifiedTypeDeclarationPattern(qualification, memberTypeDeclaration.name, convertTypeKind(TypeDeclaration.kind(memberTypeDeclaration.modifiers)), matchRule);
-									if (pattern.matchesDecodedKey(decodedPattern)) {
-										nameRequestor.acceptType(memberTypeDeclaration.modifiers, packageDeclaration, memberTypeDeclaration.name, enclosingTypeNames, path, null);
-									}
-									return true;
+								SearchPattern decodedPattern =
+									new QualifiedTypeDeclarationPattern(qualification, memberTypeDeclaration.name, convertTypeKind(TypeDeclaration.kind(memberTypeDeclaration.modifiers)), matchRule);
+								if (pattern.matchesDecodedKey(decodedPattern)) {
+									nameRequestor.acceptType(memberTypeDeclaration.modifiers, packageDeclaration, memberTypeDeclaration.name, enclosingTypeNames, path, null);
 								}
+								return true;
 							}
-							parsedUnit.traverse(new AllTypeDeclarationsVisitor(), parsedUnit.scope);
 						}
+						parsedUnit.traverse(new AllTypeDeclarationsVisitor(), parsedUnit.scope);
 					}
 				}
 			}
-		} finally {
-			if (progressMonitor != null) {
-				progressMonitor.done();
-			}
 		}
 	}
 
commit dc7291f0a9feed37c37f8f392684000644c0ba35
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Thu Nov 12 15:24:15 2015 +0530

    Bug 477790 - Adopt SubMonitor in JDT core
    
    Patch set 3
    
    Change-Id: I0662a1990ed1e2fa3d090fb73d1ef2a8859b9a4b

3	10	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
4	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
index 176079e..67bcf63 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
@@ -515,11 +515,7 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	 * Creates and returns a subprogress monitor if appropriate.
 	 */
 	protected IProgressMonitor getSubProgressMonitor(int workAmount) {
-		IProgressMonitor sub = null;
-		if (this.progressMonitor != null) {
-			sub = new SubProgressMonitor(this.progressMonitor, workAmount, SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
-		}
-		return sub;
+		return SubMonitor.convert(this.progressMonitor, workAmount);
 	}
 
 	/**
@@ -576,17 +572,14 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	 * Convenience method to move resources
 	 */
 	protected void moveResources(IResource[] resources, IPath container) throws JavaModelException {
-		IProgressMonitor subProgressMonitor = null;
-		if (this.progressMonitor != null) {
-			subProgressMonitor = new SubProgressMonitor(this.progressMonitor, resources.length, SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
-		}
+		SubMonitor subProgressMonitor = SubMonitor.convert(this.progressMonitor, resources.length);
 		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
 		try {
 			for (int i = 0, length = resources.length; i < length; i++) {
 				IResource resource = resources[i];
 				IPath destination = container.append(resource.getName());
 				if (root.findMember(destination) == null) {
-					resource.move(destination, false, subProgressMonitor);
+					resource.move(destination, false, subProgressMonitor.split(1));
 				}
 			}
 			setAttribute(HAS_MODIFIED_RESOURCE_ATTR, TRUE);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
index 3b45099..776d91f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,7 +11,7 @@
 package org.eclipse.jdt.internal.core.search.matching;
 
 import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.SubProgressMonitor;
+import org.eclipse.core.runtime.SubMonitor;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.search.*;
@@ -266,15 +266,14 @@ protected String[] getPathsOfDeclaringType() {
 			return true;
 		}
 	};
-
+	SubMonitor subMonitor = SubMonitor.convert(this.progressMonitor, 100);
 	indexManager.performConcurrentJob(
 		new PatternSearchJob(
 			searchPattern,
 			new JavaSearchParticipant(),
 			scope,
 			searchRequestor),
-		IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
-		this.progressMonitor == null ? null : new SubProgressMonitor(this.progressMonitor, 100));
+		IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, subMonitor.split(100));
 	return pathCollector.getPaths();
 }
 public char[][][] getSamePackageSuperTypeNames() {
commit 126dd6025c8f23861069be98f78a4771959a405b
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Fri Nov 13 00:39:30 2015 +0530

    Partial Revert "Bug 477790 - Adopt SubMonitor in JDT core"
    
    This partially reverts commit dc7291f0a9feed37c37f8f392684000644c0ba35.

10	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
index 67bcf63..176079e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
@@ -515,7 +515,11 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	 * Creates and returns a subprogress monitor if appropriate.
 	 */
 	protected IProgressMonitor getSubProgressMonitor(int workAmount) {
-		return SubMonitor.convert(this.progressMonitor, workAmount);
+		IProgressMonitor sub = null;
+		if (this.progressMonitor != null) {
+			sub = new SubProgressMonitor(this.progressMonitor, workAmount, SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
+		}
+		return sub;
 	}
 
 	/**
@@ -572,14 +576,17 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	 * Convenience method to move resources
 	 */
 	protected void moveResources(IResource[] resources, IPath container) throws JavaModelException {
-		SubMonitor subProgressMonitor = SubMonitor.convert(this.progressMonitor, resources.length);
+		IProgressMonitor subProgressMonitor = null;
+		if (this.progressMonitor != null) {
+			subProgressMonitor = new SubProgressMonitor(this.progressMonitor, resources.length, SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
+		}
 		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
 		try {
 			for (int i = 0, length = resources.length; i < length; i++) {
 				IResource resource = resources[i];
 				IPath destination = container.append(resource.getName());
 				if (root.findMember(destination) == null) {
-					resource.move(destination, false, subProgressMonitor.split(1));
+					resource.move(destination, false, subProgressMonitor);
 				}
 			}
 			setAttribute(HAS_MODIFIED_RESOURCE_ATTR, TRUE);
commit 1bd28947ec61a68bcbaa48e5f62a38f1082dad74
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Nov 12 10:34:06 2015 -0800

    Bug 477790 - Change usage of SubProgressMonitor to SubMonitor in
    org.eclipse.jdt.core
    
    Adopting SubMonitor in JobManager and JavaModelOperation and fixing a
    test in TypeHierarchyTests
    
    Change-Id: I8f42c4de169268b79f62ee8997ff971b409a78df
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

3	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyTests.java
5	12	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
54	68	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyTests.java
index 03b2983..39f2733 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/TypeHierarchyTests.java
@@ -659,7 +659,7 @@ public void testCycle2() throws JavaModelException {
 	);
 }
 /*
- * Ensures that creating a type hierarchy accross multiple project is efficient enough.
+ * Ensures that creating a type hierarchy accross multiple project checks for cancellation regularly.
  */
 public void testEfficiencyMultipleProjects() throws CoreException {
 	try {
@@ -681,7 +681,7 @@ public void testEfficiencyMultipleProjects() throws CoreException {
 		}
 		ProgressCounter counter = new ProgressCounter();
 		type.newTypeHierarchy(counter);
-		assertEquals("Unexpected work count", 85, counter.count);
+		assertTrue("Not enough cancellation checks", counter.count >= 85); 
 	} finally {
 		deleteProjects(new String[] {"P1", "P2", "P3"});
 	}
@@ -2361,7 +2361,7 @@ public void testBug215841() throws JavaModelException, CoreException, Interrupte
 		IType type = getClassFile("TypeHierarchy", getExternalJCLPathString(), "java.lang", "Throwable.class").getType();
 		LocalProgressMonitor monitor = new LocalProgressMonitor();
 		type.newTypeHierarchy(monitor);
-		assertEquals("Unexpected indexing of non-existent external jar file while building hierarchy!", 2, monitor.count);
+		assertEquals("Unexpected indexing of non-existent external jar file while building hierarchy!", 1, monitor.count);
 	} finally {
 		project.setRawClasspath(originalClasspath, null);
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
index 176079e..66ccb75 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelOperation.java
@@ -96,7 +96,7 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	/**
 	 * The progress monitor passed into this operation
 	 */
-	public IProgressMonitor progressMonitor= null;
+	public SubMonitor progressMonitor= SubMonitor.convert(null);
 	/**
 	 * A flag indicating whether this operation is nested.
 	 */
@@ -515,11 +515,7 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	 * Creates and returns a subprogress monitor if appropriate.
 	 */
 	protected IProgressMonitor getSubProgressMonitor(int workAmount) {
-		IProgressMonitor sub = null;
-		if (this.progressMonitor != null) {
-			sub = new SubProgressMonitor(this.progressMonitor, workAmount, SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
-		}
-		return sub;
+		return this.progressMonitor.split(workAmount);
 	}
 
 	/**
@@ -576,17 +572,14 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 	 * Convenience method to move resources
 	 */
 	protected void moveResources(IResource[] resources, IPath container) throws JavaModelException {
-		IProgressMonitor subProgressMonitor = null;
-		if (this.progressMonitor != null) {
-			subProgressMonitor = new SubProgressMonitor(this.progressMonitor, resources.length, SubProgressMonitor.PREPEND_MAIN_LABEL_TO_SUBTASK);
-		}
+		SubMonitor subProgressMonitor = this.progressMonitor.newChild(resources.length);
 		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
 		try {
 			for (int i = 0, length = resources.length; i < length; i++) {
 				IResource resource = resources[i];
 				IPath destination = container.append(resource.getName());
 				if (root.findMember(destination) == null) {
-					resource.move(destination, false, subProgressMonitor);
+					resource.move(destination, false, subProgressMonitor.split(1));
 				}
 			}
 			setAttribute(HAS_MODIFIED_RESOURCE_ATTR, TRUE);
@@ -717,7 +710,7 @@ public abstract class JavaModelOperation implements IWorkspaceRunnable, IProgres
 		DeltaProcessor deltaProcessor = manager.getDeltaProcessor();
 		int previousDeltaCount = deltaProcessor.javaModelDeltas.size();
 		try {
-			this.progressMonitor = monitor;
+			this.progressMonitor = SubMonitor.convert(monitor);
 			pushOperation(this);
 			try {
 				if (canModifyRoots()) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
index e1774d9..4626c37 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java
@@ -175,9 +175,7 @@ public abstract class JobManager implements Runnable {
 
 		boolean status = IJob.FAILED;
 		try {
-			int concurrentJobWork = 100;
-			if (progress != null)
-				progress.beginTask("", concurrentJobWork); //$NON-NLS-1$
+			SubMonitor subMonitor = SubMonitor.convert(progress);
 			if (awaitingJobsCount() > 0) {
 				switch (waitingPolicy) {
 
@@ -186,7 +184,7 @@ public abstract class JobManager implements Runnable {
 							Util.verbose("-> NOT READY - forcing immediate - " + searchJob);//$NON-NLS-1$
 						try {
 							disable(); // pause indexing
-							status = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));
+							status = searchJob.execute(subMonitor);
 						} finally {
 							enable();
 						}
@@ -202,82 +200,70 @@ public abstract class JobManager implements Runnable {
 						throw new OperationCanceledException();
 
 					case IJob.WaitUntilReady :
-						IProgressMonitor subProgress = null;
+						int totalWork = 1000;
+						SubMonitor subProgress = subMonitor.setWorkRemaining(10).split(8).setWorkRemaining(totalWork);
+						// use local variable to avoid potential NPE (see bug 20435 NPE when searching java method
+						// and bug 42760 NullPointerException in JobManager when searching)
+						Thread t = this.processingThread;
+						int originalPriority = t == null ? -1 : t.getPriority();
 						try {
-							int totalWork = 1000;
-							if (progress != null) {
-								subProgress = new SubProgressMonitor(progress, concurrentJobWork * 8 / 10);
-								subProgress.beginTask("", totalWork); //$NON-NLS-1$
-								concurrentJobWork = concurrentJobWork * 2 / 10;
+							if (t != null)
+								t.setPriority(Thread.currentThread().getPriority());
+							synchronized(this) {
+								this.awaitingClients++;
 							}
-							// use local variable to avoid potential NPE (see bug 20435 NPE when searching java method
-							// and bug 42760 NullPointerException in JobManager when searching)
-							Thread t = this.processingThread;
-							int originalPriority = t == null ? -1 : t.getPriority();
-							try {
-								if (t != null)
-									t.setPriority(Thread.currentThread().getPriority());
-								synchronized(this) {
-									this.awaitingClients++;
-								}
-								IJob previousJob = null;
-								int awaitingJobsCount;
-								int lastJobsCount = totalWork;
-								float lastWorked = 0;
-								float totalWorked = 0;
-								while ((awaitingJobsCount = awaitingJobsCount()) > 0) {
-									if ((subProgress != null && subProgress.isCanceled())
-											|| this.processingThread == null)
-										throw new OperationCanceledException();
-									IJob currentJob = currentJob();
-									// currentJob can be null when jobs have been added to the queue but job manager is not enabled
-									if (currentJob != null && currentJob != previousJob) {
-										if (VERBOSE)
-											Util.verbose("-> NOT READY - waiting until ready - " + searchJob);//$NON-NLS-1$
-										if (subProgress != null) {
-											String indexing = Messages.bind(Messages.jobmanager_filesToIndex, currentJob.getJobFamily(), Integer.toString(awaitingJobsCount));
-											subProgress.subTask(indexing);
-											// ratio of the amount of work relative to the total work
-											float ratio = awaitingJobsCount < totalWork ? 1 : ((float) totalWork) / awaitingJobsCount;
-											if (lastJobsCount > awaitingJobsCount) {
-												totalWorked += (lastJobsCount - awaitingJobsCount) * ratio;
-											} else {
-												// more jobs were added, just increment by the ratio
-												totalWorked += ratio;
-											}
-											if (totalWorked - lastWorked >= 1) {
-												subProgress.worked((int) (totalWorked - lastWorked));
-												lastWorked = totalWorked;
-											}
-											lastJobsCount = awaitingJobsCount;
+							IJob previousJob = null;
+							int awaitingJobsCount;
+							int lastJobsCount = totalWork;
+							float lastWorked = 0;
+							float totalWorked = 0;
+							while ((awaitingJobsCount = awaitingJobsCount()) > 0) {
+								if ((subProgress != null && subProgress.isCanceled())
+										|| this.processingThread == null)
+									throw new OperationCanceledException();
+								IJob currentJob = currentJob();
+								// currentJob can be null when jobs have been added to the queue but job manager is not enabled
+								if (currentJob != null && currentJob != previousJob) {
+									if (VERBOSE)
+										Util.verbose("-> NOT READY - waiting until ready - " + searchJob);//$NON-NLS-1$
+									if (subProgress != null) {
+										String indexing = Messages.bind(Messages.jobmanager_filesToIndex, currentJob.getJobFamily(), Integer.toString(awaitingJobsCount));
+										subProgress.subTask(indexing);
+										// ratio of the amount of work relative to the total work
+										float ratio = awaitingJobsCount < totalWork ? 1 : ((float) totalWork) / awaitingJobsCount;
+										if (lastJobsCount > awaitingJobsCount) {
+											totalWorked += (lastJobsCount - awaitingJobsCount) * ratio;
+										} else {
+											// more jobs were added, just increment by the ratio
+											totalWorked += ratio;
 										}
-										previousJob = currentJob;
-									}
-									try {
-										if (VERBOSE)
-											Util.verbose("-> GOING TO SLEEP - " + searchJob);//$NON-NLS-1$
-										Thread.sleep(50);
-									} catch (InterruptedException e) {
-										// ignore
+										if (totalWorked - lastWorked >= 1) {
+											subProgress.worked((int) (totalWorked - lastWorked));
+											lastWorked = totalWorked;
+										}
+										lastJobsCount = awaitingJobsCount;
 									}
+									previousJob = currentJob;
 								}
-							} finally {
-								synchronized(this) {
-									this.awaitingClients--;
+								try {
+									if (VERBOSE)
+										Util.verbose("-> GOING TO SLEEP - " + searchJob);//$NON-NLS-1$
+									Thread.sleep(50);
+								} catch (InterruptedException e) {
+									// ignore
 								}
-								if (t != null && originalPriority > -1 && t.isAlive())
-									t.setPriority(originalPriority);
 							}
 						} finally {
-							if (subProgress != null)
-								subProgress.done();
+							synchronized(this) {
+								this.awaitingClients--;
+							}
+							if (t != null && originalPriority > -1 && t.isAlive())
+								t.setPriority(originalPriority);
 						}
 				}
 			}
-			status = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));
+			status = searchJob.execute(subMonitor);
 		} finally {
-			if (progress != null)
-				progress.done();
 			if (VERBOSE)
 				Util.verbose("FINISHED  concurrent job - " + searchJob); //$NON-NLS-1$
 		}
