commit a170a70f9fd89b9996c94f318397ff4dca1db782
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Sep 17 15:51:18 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - item (2)

13	16	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 3f214c2..53609b8 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -1668,7 +1668,6 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	}
 
 	// types without null annotations are converted (unsafe) to types with detail annotations (array content)
-	// FIXME(Stephan) : Old messages are wrong, the new diagnostics are correct, but the leaf component types differ - null annotated readable names don't reflect that - this needs to be fixed.
 	public void testCompatibility3a() {
 		runNegativeTestWithLibs(
 			new String[] {
@@ -1689,7 +1688,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				+ "		acceptNulls(dubious);\n"
 				+ "		acceptNoNulls(dubious);\n"
 				+ "	}\n"
-				+ "	void acceptNulls(@NonNull String[] noNulls) {}\n"
+				+ "	void acceptNulls(@Nullable String[] withNulls) {}\n"
 				+ "	void acceptNoNulls(@NonNull String[] noNulls) {}\n"
 				+ "}\n"
 			},
@@ -1697,32 +1696,32 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"1. WARNING in X.java (at line 4)\n" + 
 			"	return dubious;\n" + 
 			"	       ^^^^^^^\n" + 
-			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'String []\'\n" + 
+			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'@NonNull String []\'\n" + 
 			"----------\n" + 
 			"2. WARNING in X.java (at line 7)\n" + 
 			"	return dubious;\n" + 
 			"	       ^^^^^^^\n" + 
-			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'String []\'\n" + 
+			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'@Nullable String []\'\n" + 
 			"----------\n" + 
 			"3. WARNING in X.java (at line 10)\n" + 
 			"	@Nullable String[] l1 = dubious;\n" + 
 			"	                        ^^^^^^^\n" + 
-			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'String []\'\n" + 
+			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'@Nullable String []\'\n" + 
 			"----------\n" + 
 			"4. WARNING in X.java (at line 11)\n" + 
 			"	@NonNull String[] l2 = dubious;\n" + 
 			"	                       ^^^^^^^\n" + 
-			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'String []\'\n" + 
+			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'@NonNull String []\'\n" + 
 			"----------\n" + 
 			"5. WARNING in X.java (at line 14)\n" + 
 			"	acceptNulls(dubious);\n" + 
 			"	            ^^^^^^^\n" + 
-			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'String []\'\n" + 
+			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'@Nullable String []\'\n" + 
 			"----------\n" + 
 			"6. WARNING in X.java (at line 15)\n" + 
 			"	acceptNoNulls(dubious);\n" + 
 			"	              ^^^^^^^\n" + 
-			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'String []\'\n" + 
+			"Null type safety (type annotations): The expression of type \'String[]\' needs unchecked conversion to conform to \'@NonNull String []\'\n" + 
 			"----------\n");
 	}
 
@@ -1783,8 +1782,6 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	}
 
 	// types with null annotations on details (array content) are incompatible to opposite types
-	// TODO(Stephan) : Per the right interpretation of the spec, @Nullable and @NonNull are annotating the component type and not the arrays. The new diagnostics are correct, but
-	// should mention the annotation on the leaf type.
 	public void testCompatibility4a() {
 		runNegativeTestWithLibs(
 			new String[] {
@@ -1810,32 +1807,32 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"1. ERROR in X.java (at line 4)\n" + 
 			"	return noNulls;\n" + 
 			"	       ^^^^^^^\n" + 
-			"Null type mismatch (type annotations): required \'String []\' but this expression has type \'String []\'\n" + 
+			"Null type mismatch (type annotations): required \'@Nullable String []\' but this expression has type \'@NonNull String []\'\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 7)\n" + 
 			"	return withNulls;\n" + 
 			"	       ^^^^^^^^^\n" + 
-			"Null type mismatch (type annotations): required \'String []\' but this expression has type \'String []\'\n" + 
+			"Null type mismatch (type annotations): required \'@NonNull String []\' but this expression has type \'@Nullable String []\'\n" + 
 			"----------\n" + 
 			"3. ERROR in X.java (at line 10)\n" + 
 			"	@NonNull String[] l1 = withNulls;\n" + 
 			"	                       ^^^^^^^^^\n" + 
-			"Null type mismatch (type annotations): required \'String []\' but this expression has type \'String []\'\n" + 
+			"Null type mismatch (type annotations): required \'@NonNull String []\' but this expression has type \'@Nullable String []\'\n" + 
 			"----------\n" + 
 			"4. ERROR in X.java (at line 11)\n" + 
 			"	@Nullable String[] l2 = noNulls;\n" + 
 			"	                        ^^^^^^^\n" + 
-			"Null type mismatch (type annotations): required \'String []\' but this expression has type \'String []\'\n" + 
+			"Null type mismatch (type annotations): required \'@Nullable String []\' but this expression has type \'@NonNull String []\'\n" + 
 			"----------\n" + 
 			"5. ERROR in X.java (at line 14)\n" + 
 			"	assigns(withNulls, noNulls);\n" + 
 			"	        ^^^^^^^^^\n" + 
-			"Null type mismatch (type annotations): required \'String []\' but this expression has type \'String []\'\n" + 
+			"Null type mismatch (type annotations): required \'@NonNull String []\' but this expression has type \'@Nullable String []\'\n" + 
 			"----------\n" + 
 			"6. ERROR in X.java (at line 14)\n" + 
 			"	assigns(withNulls, noNulls);\n" + 
 			"	                   ^^^^^^^\n" + 
-			"Null type mismatch (type annotations): required \'String []\' but this expression has type \'String []\'\n" + 
+			"Null type mismatch (type annotations): required \'@Nullable String []\' but this expression has type \'@NonNull String []\'\n" + 
 			"----------\n");
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
index 29a82ac..c655ee5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
@@ -19,6 +19,7 @@
  *								Bug 415291 - [1.8][null] differentiate type incompatibilities due to null annotations
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
  *								Bug 416176 - [1.8][compiler][null] null type annotations cause grief on type variables
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -298,8 +299,7 @@ public char[] nullAnnotatedReadableName(CompilerOptions options, boolean shortNa
 			brackets[i] = new char[]{'[', ']'}; 
 		}
 	}
-	char[] leafTypeName = shortNames ? this.leafComponentType.shortReadableName() : this.leafComponentType.readableName();
-	return CharOperation.concat(leafTypeName, 
+	return CharOperation.concat(this.leafComponentType.nullAnnotatedReadableName(options, shortNames), 
 								 CharOperation.concatWith(brackets, ' '),
 								 ' ');
 }
commit 25c55f5a3b95044fb71ce56ee0bb0a797b58daa1
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Sep 17 18:20:52 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - item (1)

4	16	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
3	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
14	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
9	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
7	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 53609b8..737a7cf 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -1030,7 +1030,6 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	}
 
 	// storing and decoding null-type-annotations to/from classfile: CLASS_TYPE_PARAMETER & METHOD_TYPE_PARAMETER
-	// TODO(Stephan) : 3rd error message looks weird. We need to clone and set the bits for allocation expression or otherwise handle.
 	public void testBinary05() {
 		Map customOptions = getCompilerOptions();
 		customOptions.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
@@ -1070,13 +1069,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"	x.<@NonNull Object>foo(new Object());\n" + 
 				"	   ^^^^^^^^^^^^^^^\n" + 
 				"Null constraint mismatch: The type \'@NonNull Object\' is not a valid substitute for the type parameter \'S\' which is constrained as \'@Nullable\'\n" + 
-				"----------\n" + 
-				"3. WARNING in Y1.java (at line 6)\n" + 
-				"	x.<@NonNull Object>foo(new Object());\n" + 
-				"	                       ^^^^^^^^^^^^\n" + 
-				"Null type safety (type annotations): The expression of type \'Object\' needs unchecked conversion to conform to \'@NonNull Object\'\n" + 
-				"----------\n"
-				);
+				"----------\n");
 	}
 
 	// storing and decoding null-type-annotations to/from classfile: CLASS_TYPE_PARAMETER_BOUND & METHOD_TYPE_PARAMETER_BOUND
@@ -2465,7 +2458,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n");
 	}
 
-	public void testBug416182() {
+	public void testBug416182() { 
 		runNegativeTestWithLibs(
 			new String[] {
 				"X.java",
@@ -2477,7 +2470,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"		return t;\n" + 
 				"	}\n" + 
 				"	public static void main(String[] args) {\n" + 
-				"		X<@Nullable String> xs = new X<String>();\n" + 
+				"		X<@Nullable String> xs = new X<String>();\n" + // TODO(stephan): must detect that foo() now has contradictory annots, see bug 416190 
 				"		xs.foo(null);\n" + 
 				"	}\n" + 
 				"	\n" +
@@ -2496,12 +2489,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"	                         ^^^^^^^^^^^^^^^\n" + 
 			"Null type safety (type annotations): The expression of type 'X<String>' needs unchecked conversion to conform to 'X<@Nullable String>'\n" + 
 			"----------\n" + 
-			"2. ERROR in X.java (at line 10)\n" + 
-			"	xs.foo(null);\n" + 
-			"	       ^^^^\n" + 
-			"Null type mismatch: required '@NonNull String' but the provided value is null\n" + 
-			"----------\n" + 
-			"3. WARNING in X.java (at line 14)\n" + 
+			"2. WARNING in X.java (at line 14)\n" + 
 			"	X<@Nullable String> xs = x;\n" + 
 			"	                         ^\n" + 
 			"Null type safety (type annotations): The expression of type \'X<String>\' needs unchecked conversion to conform to \'X<@Nullable String>\'\n" + 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index d5f4144..28ca2d3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -23,6 +23,7 @@
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *								Bug 403216 - [1.8][null] TypeReference#captureTypeAnnotations treats type annotations as type argument annotations
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -661,8 +662,9 @@ public abstract class AbstractMethodDeclaration
 		} else {
 			int length = this.binding.parameters.length;
 			for (int i=0; i<length; i++) {
-				if (!this.scope.validateNullAnnotation(this.binding.parameters[i].tagBits, this.arguments[i].type, this.arguments[i].annotations))
-					this.binding.parameters[i] = this.binding.parameters[i].unannotated();
+				this.scope.validateNullAnnotation(this.binding.parameters[i].tagBits, this.arguments[i].type, this.arguments[i].annotations);
+// TODO(stephan) remove once we're sure:
+//					this.binding.parameters[i] = this.binding.parameters[i].unannotated();
 			}			
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 45ed0b5..6db9d96 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -23,6 +23,7 @@
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *							bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
+ *							Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *							bug 378674 - "The method can be declared as static" is wrong
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -303,7 +304,7 @@ public TypeBinding resolveType(BlockScope scope) {
 		this.resolvedType = scope.enclosingReceiverType();
 	} else {
 		this.resolvedType = this.type.resolveType(scope, true /* check bounds*/);
-		this.resolvedType = checkIllegalNullAnnotation(scope, this.resolvedType);
+		checkIllegalNullAnnotation(scope, this.resolvedType);
 		checkParameterizedAllocation: {
 			if (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()
 				ReferenceBinding currentType = (ReferenceBinding)this.resolvedType;
@@ -468,19 +469,16 @@ public TypeBinding resolveType(BlockScope scope) {
 
 /**
  * Check if 'allocationType' illegally has a top-level null annotation.
- * If so: report an error and return the unannotated variant.
  */
-TypeBinding checkIllegalNullAnnotation(BlockScope scope, TypeBinding allocationType) {
+void checkIllegalNullAnnotation(BlockScope scope, TypeBinding allocationType) {
 	if (allocationType != null) {
 		// only check top-level null annotation (annots on details are OK):
 		long nullTagBits = allocationType.tagBits & TagBits.AnnotationNullMASK;
 		if (nullTagBits != 0) {
 			Annotation annotation = this.type.findAnnotation(nullTagBits);
 			scope.problemReporter().nullAnnotationUnsupportedLocation(annotation);
-			return allocationType.unannotated();
 		}
 	}
-	return allocationType;
 }
 
 public TypeBinding[] inferElidedTypes(ReferenceBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 3834927..2cc0b39 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -19,6 +19,7 @@
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409517 - [1.8][compiler] Type annotation problems on more elaborate array references
@@ -1003,7 +1004,6 @@ public abstract class Annotation extends Expression {
 								} else if (nullTagBits != (variable.type.tagBits & TagBits.AnnotationNullMASK)) {
 									if (((variable.type.tagBits & TagBits.AnnotationNullMASK) | nullTagBits ) == TagBits.AnnotationNullMASK) {
 										scope.problemReporter().contradictoryNullAnnotations(this);
-										variable.type = variable.type.unannotated();
 									}
 								}
 							}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index f2e9a04..41a566e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -20,7 +20,8 @@
  *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *								bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
- *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis 
+ *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -260,7 +261,7 @@ public final boolean checkCastTypesCompatibility(Scope scope, TypeBinding castTy
 	boolean use17specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_7;
 	if (castType.isBaseType()) {
 		if (expressionType.isBaseType()) {
-			if (expressionType == castType) {
+			if (TypeBinding.equalsEquals(expressionType, castType)) {
 				if (expression != null) {
 					this.constant = expression.constant; //use the same constant
 				}
@@ -315,7 +316,7 @@ public final boolean checkCastTypesCompatibility(Scope scope, TypeBinding castTy
 			return false;
 
 		case Binding.ARRAY_TYPE :
-			if (castType == expressionType) {
+			if (TypeBinding.equalsEquals(castType, expressionType)) {
 				tagAsUnnecessaryCast(scope, castType);
 				return true; // identity conversion
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
index 9cd23f2..5f84c19 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
@@ -16,6 +16,7 @@
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -93,7 +94,6 @@ public TypeBinding resolveType(BlockScope scope) {
 	TypeBinding checkedType = this.type.resolveType(scope, true /* check bounds*/);
 	if (expressionType != null && checkedType != null && NullAnnotationMatching.analyse(checkedType, expressionType, -1).isAnyMismatch()) {
 		scope.problemReporter().nullAnnotationUnsupportedLocation(this.type);
-		checkedType = checkedType.unannotated();
 	}
 	if (expressionType == null || checkedType == null)
 		return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 44644fb..d3a41ff 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -37,6 +37,7 @@
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 405569 - Resource leak check false positive when using DbUtils.closeQuietly
  *								Bug 411964 - [1.8][null] leverage null type annotation in foreach statement
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -160,13 +161,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 		analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 	}
-	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
-		if (this.binding instanceof ParameterizedGenericMethodBinding && this.typeArguments != null) {
-			TypeVariableBinding[] typeVariables = this.binding.original().typeVariables();
-			for (int i = 0; i < this.typeArguments.length; i++)
-				this.typeArguments[i].checkNullConstraints(currentScope, typeVariables, i);
-		}
-	}
 	ReferenceBinding[] thrownExceptions;
 	if ((thrownExceptions = this.binding.thrownExceptions) != Binding.NO_EXCEPTIONS) {
 		if ((this.bits & ASTNode.Unchecked) != 0 && this.genericTypeArguments == null) {
@@ -732,10 +726,19 @@ public TypeBinding resolveType(BlockScope scope) {
 		return null;
 	}
 
-	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
-		// not interested in reporting problems against this.binding:
-		new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations)
-				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
+	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled) {
+		if ((this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
+			// not interested in reporting problems against this.binding:
+			new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations)
+					.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
+		}
+		if (compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
+			if (this.binding instanceof ParameterizedGenericMethodBinding && this.typeArguments != null) {
+				TypeVariableBinding[] typeVariables = this.binding.original().typeVariables();
+				for (int i = 0; i < this.typeArguments.length; i++)
+					this.typeArguments[i].checkNullConstraints(scope, typeVariables, i);
+			}
+		}
 	}
 	
 	if (((this.bits & ASTNode.InsideExpressionStatement) != 0)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
index 24a9493..474bfdf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
@@ -106,8 +106,8 @@ public class NullAnnotationMatching {
 						severity = 1; // required is annotated, provided not, need unchecked conversion
 					} else {
 						for (int i=0; i<=dims; i++) {
-							long requiredBits = requiredDimsTagBits[i] & TagBits.AnnotationNullMASK;
-							long providedBits = providedDimsTagBits[i] & TagBits.AnnotationNullMASK;
+							long requiredBits = validNullTagBits(requiredDimsTagBits[i]);
+							long providedBits = validNullTagBits(providedDimsTagBits[i]);
 							if (i > 0)
 								nullStatus = -1; // don't use beyond the outermost dimension
 							severity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, nullStatus));
@@ -121,11 +121,11 @@ public class NullAnnotationMatching {
 				}
 			}
 		} else if (requiredType.hasNullTypeAnnotations() || providedType.hasNullTypeAnnotations()) {
-			long requiredBits = requiredType.tagBits & TagBits.AnnotationNullMASK;
+			long requiredBits = validNullTagBits(requiredType.tagBits);
 			if (requiredBits != TagBits.AnnotationNullable // nullable lhs accepts everything, ...
 					|| nullStatus == -1) // only at detail/recursion even nullable must be matched exactly
 			{
-				long providedBits = providedType.tagBits & TagBits.AnnotationNullMASK;
+				long providedBits = validNullTagBits(providedType.tagBits);
 				severity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus);
 			}
 			if (severity < 2) {
@@ -160,6 +160,11 @@ public class NullAnnotationMatching {
 		return new NullAnnotationMatching(severity, superTypeHint);
 	}
 
+	public static long validNullTagBits(long bits) {
+		bits &= TagBits.AnnotationNullMASK;
+		return bits == TagBits.AnnotationNullMASK ? 0 : bits;
+	}
+
 	private static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus) {
 		if (requiredBits != 0 && requiredBits != providedBits) {
 			if (providedBits != 0) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index f6f84cf..183e6c1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -23,6 +23,7 @@
  *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -326,7 +327,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				hasError = true;
 			} else {
 				receiverType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingInstanceType);
-				receiverType = checkIllegalNullAnnotation(scope, receiverType);
+				checkIllegalNullAnnotation(scope, receiverType);
 				if (receiverType != null && enclosingInstanceContainsCast) {
 					CastExpression.checkNeedForEnclosingInstanceCast(scope, this.enclosingInstance, enclosingInstanceType, receiverType);
 				}
@@ -337,7 +338,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				receiverType = scope.enclosingSourceType();
 			} else {
 				receiverType = this.type.resolveType(scope, true /* check bounds*/);
-				receiverType = checkIllegalNullAnnotation(scope, receiverType);
+				checkIllegalNullAnnotation(scope, receiverType);
 				checkParameterizedAllocation: {
 					if (receiverType == null || !receiverType.isValidBinding()) break checkParameterizedAllocation;
 					if (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index b2dc10d..4b7bdc7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -17,6 +17,7 @@
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409236 - [1.8][compiler] Type annotations on intersection cast types dropped by code generator
@@ -589,7 +590,7 @@ protected void checkNullConstraints(Scope scope, TypeReference[] typeArguments)
 protected void checkNullConstraints(Scope scope, TypeBinding[] variables, int rank) {
 	if (variables != null && variables.length > rank) {
 		if (variables[rank].hasNullTypeAnnotations()) {
-			if ((this.resolvedType.tagBits & TagBits.AnnotationNullMASK) != (variables[rank].tagBits & TagBits.AnnotationNullMASK)) {
+			if (NullAnnotationMatching.validNullTagBits(this.resolvedType.tagBits) != NullAnnotationMatching.validNullTagBits(variables[rank].tagBits)) {
 				scope.problemReporter().nullityMismatchTypeArgument(variables[rank], this.resolvedType, this);
 			}
     	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
index 5235cde..4bf06d1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Wildcard.java
@@ -15,6 +15,7 @@
  *                          Bug 415397 - [1.8][compiler] Type Annotations on wildcard type argument dropped
  *        Stephan Herrmann - Contribution for
  *							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
+ *							Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -78,8 +79,6 @@ public class Wildcard extends SingleTypeReference {
 			if (((boundType.tagBits | this.resolvedType.tagBits) & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) { // are both set?
 				Annotation annotation = this.bound.findAnnotation(boundType.tagBits & TagBits.AnnotationNullMASK);
 				scope.problemReporter().contradictoryNullAnnotationsOnBounds(annotation, this.resolvedType.tagBits);
-				this.resolvedType = this.resolvedType.unannotated();
-				this.bound.resolvedType = ((WildcardBinding)this.resolvedType).bound = boundType.unannotated();
 			}
 		}
 		return this.resolvedType;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 6da5f2f..389e4ae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -23,6 +23,7 @@ import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 
@@ -391,7 +392,7 @@ public class ImplicitNullAnnotationVerifier {
 		if (useTypeAnnotations) {
 			TypeBinding parameter = method.parameters[i];
 			if (parameter != null) {
-				long nullBits = parameter.tagBits & TagBits.AnnotationNullMASK;
+				long nullBits = NullAnnotationMatching.validNullTagBits(parameter.tagBits);
 				if (nullBits != 0L)
 					return Boolean.valueOf(nullBits == TagBits.AnnotationNonNull);
 			}
@@ -405,7 +406,7 @@ public class ImplicitNullAnnotationVerifier {
 		if (useTypeAnnotations) {
 			if (method.returnType == null)
 				return 0L;
-			return method.returnType.tagBits & TagBits.AnnotationNullMASK;
+			return NullAnnotationMatching.validNullTagBits(method.returnType.tagBits);
 		}
 		return method.tagBits & TagBits.AnnotationNullMASK;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
index 516ba78..214d83f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
@@ -16,9 +16,11 @@
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
+import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 
 /**
@@ -125,14 +127,14 @@ public class ParameterizedMethodBinding extends MethodBinding {
 
 			// after substitution transfer nullness information from type annotations:
 			if (parameterizedDeclaringClass.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
-				long returnNullBits = this.returnType.tagBits & TagBits.AnnotationNullMASK;
+				long returnNullBits = NullAnnotationMatching.validNullTagBits(this.returnType.tagBits);
 				if (returnNullBits != 0L) {
 					this.tagBits &= ~TagBits.AnnotationNullMASK;
 					this.tagBits |= returnNullBits;
 				}
 				int parametersLen = this.parameters.length;
 				for (int i=0; i<parametersLen; i++) {
-					long paramTagBits = this.parameters[i].tagBits & TagBits.AnnotationNullMASK;
+					long paramTagBits = NullAnnotationMatching.validNullTagBits(this.parameters[i].tagBits);
 					if (paramTagBits != 0) {
 						if (this.parameterNonNullness == null)
 							this.parameterNonNullness = new Boolean[parametersLen];
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 29b1156..4348ab9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -18,6 +18,7 @@
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415291 - [1.8][null] differentiate type incompatibilities due to null annotations
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -1368,6 +1369,7 @@ public void setTypeAnnotations(AnnotationBinding[] annotations, boolean evalNull
 				}
 			}
 		}
+		// we do accept contradictory tagBits here, to support detecting contradictions caused by type substitution
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
index b5893db..e9cf746 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
@@ -19,11 +19,13 @@
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
@@ -193,9 +195,9 @@ public class TypeVariableBinding extends ReferenceBinding {
 				}
 	    	}
 	    }
-	    long nullTagBits = this.tagBits & TagBits.AnnotationNullMASK;
+	    long nullTagBits = NullAnnotationMatching.validNullTagBits(this.tagBits);
 	    if (nullTagBits != 0) {
-	    	long argBits = argumentType.tagBits & TagBits.AnnotationNullMASK;
+	    	long argBits = NullAnnotationMatching.validNullTagBits(argumentType.tagBits);
 	    	if (argBits != nullTagBits) {
 //	    		System.err.println("TODO(stephan): issue proper error: bound conflict at "+String.valueOf(this.declaringElement.readableName()));
 	    	}
@@ -592,9 +594,9 @@ public class TypeVariableBinding extends ReferenceBinding {
 	}
 
 	public void evaluateNullAnnotations(Scope scope, TypeParameter parameter) {
-		long nullTagBits = this.tagBits & TagBits.AnnotationNullMASK;
+		long nullTagBits = NullAnnotationMatching.validNullTagBits(this.tagBits);
 		if (this.firstBound != null && this.firstBound.isValidBinding()) {
-			long superNullTagBits = this.firstBound.tagBits & TagBits.AnnotationNullMASK;
+			long superNullTagBits = NullAnnotationMatching.validNullTagBits(this.firstBound.tagBits);
 			if (superNullTagBits != 0L) {
 				if (nullTagBits == 0L) {
 					nullTagBits |= superNullTagBits;
@@ -612,7 +614,7 @@ public class TypeVariableBinding extends ReferenceBinding {
 		if ((length = interfaces.length) != 0) {
 			for (int i = length; --i >= 0;) {
 				ReferenceBinding resolveType = interfaces[i];
-				long superNullTagBits = resolveType.tagBits & TagBits.AnnotationNullMASK;
+				long superNullTagBits = NullAnnotationMatching.validNullTagBits(resolveType.tagBits);
 				if (superNullTagBits != 0L) {
 					if (nullTagBits == 0L) {
 						nullTagBits |= superNullTagBits;
commit aa6078ae8b56e2dd94bf0e99bd049422ccaa24f4
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Sep 17 18:22:29 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - item (6)

3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index b158091..fb0932e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -19,6 +19,7 @@
  *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *     Jesper Steen Moller - Contributions for
  *								Bug 412150 [1.8] [compiler] Enable reflected parameter names during annotation processing
  *******************************************************************************/
@@ -518,8 +519,7 @@ protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod
 		if (existing == 0L) {
 			added = true;
 			if (!parameter.isBaseType()) {
-				// TODO(Stephan): Synthesize AnnotationBinding[] and call LE#createAnnotatedType(TB, AB[]);
-				// this.parameters[i] = env.createAnnotatedType(parameter, TagBits.AnnotationNonNull);
+				this.parameters[i] = env.createAnnotatedType(parameter, new AnnotationBinding[]{env.getNonNullAnnotation()});
 				if (sourceMethod != null)
 					sourceMethod.arguments[i].binding.type = this.parameters[i];
 			}
@@ -533,8 +533,7 @@ protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod
 		&& !this.returnType.isBaseType()
 		&& (this.returnType.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
 	{
-		// TODO(Stephan: Synthesize AnnotationBinding[] and call LE#createAnnotatedType(TB, AB[]);
-		// this.returnType = env.createAnnotatedType(this.returnType, TagBits.AnnotationNonNull);
+		this.returnType = env.createAnnotatedType(this.returnType, new AnnotationBinding[]{env.getNonNullAnnotation()});
 	} else if (sourceMethod != null && (this.returnType.tagBits & TagBits.AnnotationNonNull) != 0) {
 		sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, -1/*signifies method return*/);
 	}
commit e3e2c6db2bd518e6c887dd95ff25a83382caa874
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Sep 17 19:12:51 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - item (3)

1	6	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest8.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BaseTypeBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest8.java
index fa8e4f1..f50670f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/FlowAnalysisTest8.java
@@ -153,7 +153,7 @@ public void testLambda_03() {
 		"----------\n");
 }
 
-// Lambda with declared args has illegal @NonNull an primitive argument, we now emit an additional not-invalid message.
+// Lambda with declared args has illegal @NonNull an primitive argument
 public void testLambda_04() {
 	Map customOptions = getCompilerOptions();
 	runNegativeTestWithLibs(
@@ -177,11 +177,6 @@ public void testLambda_04() {
 		"	ISAM printer1 = (@NonNull int i) \n" + 
 		"	                 ^^^^^^^^\n" + 
 		"The nullness annotation @NonNull is not applicable for the primitive type int\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 4)\n" + 
-		"	ISAM printer1 = (@NonNull int i) \n" + 
-		"	                 ^^^^^^^^^^^^\n" + 
-		"Illegal redefinition of parameter i, inherited method from ISAM does not constrain this parameter\n" + 
 		"----------\n");
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 2cc0b39..3afb016 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -1009,7 +1009,7 @@ public abstract class Annotation extends Expression {
 							}
 						}
 						if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
-							 LocalDeclaration localDeclaration = variable.declaration;
+							LocalDeclaration localDeclaration = variable.declaration;
 							recordSuppressWarnings(scope, localDeclaration.declarationSourceStart, localDeclaration.declarationSourceEnd, scope.compilerOptions().suppressWarnings);
 						}
 						break;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BaseTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BaseTypeBinding.java
index 3104eed..8e4f027 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BaseTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BaseTypeBinding.java
@@ -13,6 +13,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -177,6 +178,10 @@ public final class BaseTypeBinding extends TypeBinding {
 		return this == TypeBinding.NULL && !right.isBaseType();
 	}
 	
+	public void setTypeAnnotations(AnnotationBinding[] annotations, boolean evalNullAnnotations) {
+		super.setTypeAnnotations(annotations, false); // never set nullTagBits on base types
+	}
+
 	public TypeBinding unannotated() {
 		if (!this.hasTypeAnnotations())
 			return this;
commit 79dfe93fb5ee8f61e6c4f3be92a2d21cce1717db
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Sep 17 19:31:07 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - item (4)

2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 737a7cf..1cd7948 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -2307,12 +2307,12 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"1. WARNING in X.java (at line 8)\n" + 
 			"	List<@NonNull ? extends @NonNull String> ls = new ArrayList<String>();\n" + 
 			"	                                              ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Null type safety (type annotations): The expression of type \'ArrayList<String>\' needs unchecked conversion to conform to \'List<@NonNull ? extends java.lang.String>\'\n" + 
+			"Null type safety (type annotations): The expression of type \'ArrayList<String>\' needs unchecked conversion to conform to \'List<@NonNull ? extends String>\'\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 9)\n" + 
 			"	ls.add(null);\n" + 
 			"	       ^^^^\n" + 
-			"Null type mismatch: required \'@NonNull capture#\' but the provided value is null\n" + 
+			"Null type mismatch: required \'@NonNull ? extends String\' but the provided value is null\n" + 
 			"----------\n");
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
index ad32854..6212879 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
@@ -15,6 +15,7 @@
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *     							bug 359362 - FUP of bug 349326: Resource leak on non-Closeable resource
  *								bug 358903 - Filter practically unimportant resource leak warnings
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -594,7 +595,8 @@ public class WildcardBinding extends ReferenceBinding {
                 break;
             case Wildcard.EXTENDS :
             	if (this.otherBounds == null) {
-            		buffer.append(TypeConstants.WILDCARD_NAME).append(TypeConstants.WILDCARD_EXTENDS).append(this.bound.readableName());
+            		buffer.append(TypeConstants.WILDCARD_NAME).append(TypeConstants.WILDCARD_EXTENDS);
+            		buffer.append(shortNames ? this.bound.shortReadableName(): this.bound.readableName());
             	} else {
 	            	buffer.append(this.bound.nullAnnotatedReadableName(options, shortNames));
 	            	for (int i = 0, length = this.otherBounds.length; i < length; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index ecca991..caf12c4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -134,6 +134,7 @@ import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
@@ -8908,6 +8909,11 @@ public void nullityMismatch(Expression expression, TypeBinding providedType, Typ
 		nullityMismatchingTypeAnnotation(expression, providedType, requiredType, NullAnnotationMatching.NULL_ANNOTATIONS_UNCHECKED);
 }
 public void nullityMismatchIsNull(Expression expression, TypeBinding requiredType) {
+	if (requiredType instanceof CaptureBinding) {
+		CaptureBinding capture = (CaptureBinding) requiredType;
+		if (capture.wildcard != null)
+			requiredType = capture.wildcard;
+	}
 	int problemId = IProblem.RequiredNonNullButProvidedNull;
 	String[] arguments = new String[] {
 			annotatedTypeName(requiredType, this.options.nonNullAnnotationName)
commit 6ca7655344cc04fd2732983b3bef96aa0f451863
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Sep 17 21:38:11 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - item (5)

19	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 5a13aa9..81a47e3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -6382,4 +6382,23 @@ public void testBug415850_b() {
 		"",
 		"class test180.Test");
 }
+public void testBug417295_5() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"AllAreNonNull.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"public class AllAreNonNull {\n" + 
+			"	String s3 = \"\";\n" + 
+			"	void test() {\n" + 
+			"		this.s3 = null;\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in AllAreNonNull.java (at line 5)\n" + 
+		"	this.s3 = null;\n" + 
+		"	          ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+		"----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
index 8a609b7..3644bc4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
  *								bug 185682 - Increment/decrement operators mark local variables as read
  *								bug 331649 - [compiler][null] consider null annotations for fields
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -226,11 +227,15 @@ public Constant constant() {
 }
 
 public void fillInDefaultNonNullness(FieldDeclaration sourceField, Scope scope) {
+	LookupEnvironment environment = scope.environment();
 	if (   this.type != null
 		&& !this.type.isBaseType()
 		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
 	{
-		this.tagBits |= TagBits.AnnotationNonNull;
+		if (environment.globalOptions.sourceLevel < ClassFileConstants.JDK1_8)
+			this.tagBits |= TagBits.AnnotationNonNull;
+		else
+			this.type = environment.createAnnotatedType(this.type, new AnnotationBinding[]{environment.getNonNullAnnotation()});
 	} else if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
 		scope.problemReporter().nullAnnotationIsRedundant(sourceField);
 	}
commit 43351a2f71910029138257aaee18da33f0b724b2
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Sep 17 21:48:47 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - item (7)

30	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
12	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 81a47e3..e3e89bd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -6401,4 +6401,34 @@ public void testBug417295_5() {
 		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
 		"----------\n");
 }
+public void testBug417295_7() {
+	runConformTestWithLibs(
+			new String[] {
+				"p1/AllAreNonNull.java",
+				"package p1;\n" +
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+				"public class AllAreNonNull {\n" + 
+				"	public String s3 = \"\";\n" + 
+				"}\n"
+			},
+			getCompilerOptions(),
+			"");
+	runNegativeTestWithLibs(
+		false,
+		new String[] {
+			"Client.java",
+			"public class Client {\n" + 
+			"	void test(p1.AllAreNonNull aann) {\n" + 
+			"		aann.s3 = null;\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in Client.java (at line 3)\n" + 
+		"	aann.s3 = null;\n" + 
+		"	          ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+		"----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 65d34fb..34cbee8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -25,6 +25,7 @@
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *    Jesper Steen Moller - Contributions for
  *								Bug 412150 [1.8] [compiler] Enable reflected parameter names during annotation processing
  *******************************************************************************/
@@ -1349,6 +1350,17 @@ SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 }
 
 private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBinding) {
+	if (this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
+		TypeBinding fieldType = fieldBinding.type;
+		if (fieldType != null
+				&& !fieldType.isBaseType()
+				&& (fieldType.tagBits & TagBits.AnnotationNullMASK) == 0
+				&& (this.tagBits & TagBits.AnnotationNonNullByDefault) != 0) {
+			fieldBinding.type = this.environment.createAnnotatedType(fieldType, new AnnotationBinding[]{this.environment.getNonNullAnnotation()});
+		}
+		return; // not using fieldBinding.tagBits when we have type annotations.
+	}
+
 	// global option is checked by caller
 	char[][] nullableAnnotationName = this.environment.getNullableAnnotationName();
 	char[][] nonNullAnnotationName = this.environment.getNonNullAnnotationName();
commit 68db0a50107f072688f40bcdb70cc1c2cadc3119
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Wed Sep 18 00:59:02 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - consolidate checking for contradictions

25	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
30	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
4	22	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 9e4db8f..63777c2 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -2348,9 +2348,16 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"	@NonNull T bar1(@NonNull T t) {\n" +
 				"		return t;\n" +
 				"	}\n" + 
-				"	@NonNull T bar2(@Nullable T t) { // contradiction: cannot make T @Nullable\n" +
+				"	@NonNull T bar2(@Nullable T t) { // argument: contradiction (1)\n" +
 				"		return t;\n" +
 				"	}\n" + 
+				"	@Nullable T bar3(T t) { // return type: contradiction (2)\n" +
+				"		@Nullable T l = t; // local: contradiction (3)\n" +
+				"		return l;\n" +
+				"	}\n" +
+				"	class Inner {\n" +
+				"		@Nullable T f; // field: contradiction (4)\n" +
+				"	}\n" + 
 				"	T bar3() {\n" +
 				"		return null;\n" +
 				"	}\n" + 
@@ -2359,11 +2366,26 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			getCompilerOptions(),
 			"----------\n" + 
 			"1. ERROR in X.java (at line 11)\n" + 
-			"	@NonNull T bar2(@Nullable T t) { // contradiction: cannot make T @Nullable\n" + 
+			"	@NonNull T bar2(@Nullable T t) { // argument: contradiction (1)\n" + 
 			"	                ^^^^^^^^^\n" + 
 			"Contradictory null specification; only one of @NonNull and @Nullable can be specified at any location\n" + 
 			"----------\n" + 
-			"2. ERROR in X.java (at line 15)\n" + 
+			"2. ERROR in X.java (at line 14)\n" + 
+			"	@Nullable T bar3(T t) { // return type: contradiction (2)\n" + 
+			"	^^^^^^^^^\n" + 
+			"Contradictory null specification; only one of @NonNull and @Nullable can be specified at any location\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 15)\n" + 
+			"	@Nullable T l = t; // local: contradiction (3)\n" + 
+			"	^^^^^^^^^\n" + 
+			"Contradictory null specification; only one of @NonNull and @Nullable can be specified at any location\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 19)\n" + 
+			"	@Nullable T f; // field: contradiction (4)\n" + 
+			"	^^^^^^^^^\n" + 
+			"Contradictory null specification; only one of @NonNull and @Nullable can be specified at any location\n" + 
+			"----------\n" + 
+			"5. ERROR in X.java (at line 22)\n" + 
 			"	return null;\n" + 
 			"	       ^^^^\n" + 
 			"Null type mismatch: required \'@NonNull T\' but the provided value is null\n" + 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index a81bd24..a717ad9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -20,7 +20,8 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 384870 - [compiler] @Deprecated annotation not detected if preceded by other annotation
  *								bug 393719 - [compiler] inconsistent warnings on iteration variables
- *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis 
+ *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *     Jesper S Moller - Contributions for
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
  *******************************************************************************/
@@ -761,7 +762,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 		}
 
 		if (copySE8AnnotationsToType)
-			copySE8AnnotationsToType(scope, recipient, annotations);
+			copySE8AnnotationsToType(scope, recipient, sourceAnnotations);
 		
 		// check duplicate annotations
 		if (annotations != null && length > 1) {
@@ -815,20 +816,31 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	/** When SE8 annotations feature in SE7 locations, they get attributed to the declared entity. Copy these to the type of the declared entity (field, local, argument etc.)
 	    We leave in the annotation in the declared entity's binding as of now, i.e we do a copy not a transfer.
 	*/
-	public static void copySE8AnnotationsToType(BlockScope scope, Binding recipient, AnnotationBinding[] annotations) {
+	public static void copySE8AnnotationsToType(BlockScope scope, Binding recipient, Annotation[] annotations) {
 		if (annotations != null && recipient.kind() != Binding.TYPE_USE) {
 			AnnotationBinding [] se8Annotations = null;
 			int se8count = 0;
+			long se8nullBits = 0;
+			Annotation se8NullAnnotation = null;
 			for (int i = 0, length = annotations.length; i < length; i++) {
-				final ReferenceBinding annotationType = annotations[i].getAnnotationType();
+				AnnotationBinding annotation = annotations[i].getCompilerAnnotation();
+				if (annotation == null) continue;
+				final ReferenceBinding annotationType = annotation.getAnnotationType();
 				long metaTagBits = annotationType.getAnnotationTagBits();
 				if ((metaTagBits & TagBits.AnnotationForTypeUse) != 0) {
 					if (se8Annotations == null) {
-						se8Annotations = new AnnotationBinding[] { annotations[i] };
+						se8Annotations = new AnnotationBinding[] { annotation };
 						se8count = 1;
 					} else {
 						System.arraycopy(se8Annotations, 0, se8Annotations = new AnnotationBinding[se8count + 1], 0, se8count);
-						se8Annotations[se8count++] = annotations[i];
+						se8Annotations[se8count++] = annotation;
+					}
+					if (annotationType.id == TypeIds.T_ConfiguredAnnotationNonNull) {
+						se8nullBits = TagBits.AnnotationNonNull;
+						se8NullAnnotation = annotations[i];
+					} else if (annotationType.id == TypeIds.T_ConfiguredAnnotationNullable) {
+						se8nullBits = TagBits.AnnotationNullable;
+						se8NullAnnotation = annotations[i];
 					}
 				}
 			}
@@ -839,6 +851,10 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 						if (Annotation.isTypeUseCompatible(local.declaration.type, scope)) { // discard hybrid annotations on package qualified types.
 							local.declaration.bits |= HasTypeAnnotations;
 							final TypeBinding localType = local.type;
+							long prevNullBits = localType.tagBits & TagBits.AnnotationNullMASK;
+							if (se8nullBits != 0 && prevNullBits != se8nullBits && ((prevNullBits | se8nullBits) == TagBits.AnnotationNullMASK)) {
+								scope.problemReporter().contradictoryNullAnnotations(se8NullAnnotation);
+							}
 							TypeBinding oldLeafType = localType.leafComponentType();
 							AnnotationBinding [][] goodies = new AnnotationBinding[local.declaration.type.getAnnotatableLevels()][];
 							goodies[0] = se8Annotations;  // @T X.Y.Z local; ==> @T should annotate X
@@ -852,6 +868,10 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 						FieldDeclaration fieldDeclaration = sourceType.scope.referenceContext.declarationOf(field);
 						if (Annotation.isTypeUseCompatible(fieldDeclaration.type, scope)) { // discard hybrid annotations on package qualified types.
 							TypeBinding fieldType = field.type;
+							long prevNullBits = fieldType.tagBits & TagBits.AnnotationNullMASK;
+							if (se8nullBits != 0 && prevNullBits != se8nullBits && ((prevNullBits | se8nullBits) == TagBits.AnnotationNullMASK)) {
+								scope.problemReporter().contradictoryNullAnnotations(se8NullAnnotation);
+							}
 							TypeBinding oldLeafType = fieldType.leafComponentType();
 							AnnotationBinding [][] goodies = new AnnotationBinding[fieldDeclaration.type.getAnnotatableLevels()][];
 							goodies[0] = se8Annotations; // @T X.Y.Z field; ==> @T should annotate X
@@ -866,6 +886,10 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 							MethodDeclaration methodDecl = (MethodDeclaration) sourceType.scope.referenceContext.declarationOf(method);
 							if (Annotation.isTypeUseCompatible(methodDecl.returnType, scope)) {
 								final TypeBinding returnType = method.returnType;
+								long prevNullBits = returnType.tagBits & TagBits.AnnotationNullMASK;
+								if (se8nullBits != 0 && prevNullBits != se8nullBits && ((prevNullBits | se8nullBits) == TagBits.AnnotationNullMASK)) {
+									scope.problemReporter().contradictoryNullAnnotations(se8NullAnnotation);
+								}
 								TypeBinding oldLeafType = returnType.leafComponentType();
 								AnnotationBinding [][] goodies = new AnnotationBinding[methodDecl.returnType.getAnnotatableLevels()][];
 								goodies[0] = se8Annotations;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 3afb016..487821b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -985,28 +985,10 @@ public abstract class Annotation extends Expression {
 						break;
 					case Binding.LOCAL :
 						LocalVariableBinding variable = (LocalVariableBinding) this.recipient;
-						if (scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8) {
-							variable.tagBits |= tagBits;
-							if ((variable.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
-								scope.problemReporter().contradictoryNullAnnotations(this);
-								variable.tagBits &= ~TagBits.AnnotationNullMASK; // avoid secondary problems
-							}
-						} else if (variable.type != null) {
-							// bits not relating to null analysis go into the variable:
-							variable.tagBits |= tagBits & ~TagBits.AnnotationNullMASK;
-							// null bits go into the type:
-							long nullTagBits = tagBits & TagBits.AnnotationNullMASK;
-							if (nullTagBits != 0) {
-								if (variable.type.isBaseType()) {
-									scope.problemReporter().illegalAnnotationForBaseType(this, variable.type);
-								} else if (variable.declaration.type instanceof QualifiedTypeReference) {
-									scope.problemReporter().nullAnnotationUnsupportedLocation(this);
-								} else if (nullTagBits != (variable.type.tagBits & TagBits.AnnotationNullMASK)) {
-									if (((variable.type.tagBits & TagBits.AnnotationNullMASK) | nullTagBits ) == TagBits.AnnotationNullMASK) {
-										scope.problemReporter().contradictoryNullAnnotations(this);
-									}
-								}
-							}
+						variable.tagBits |= tagBits;
+						if ((variable.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
+							scope.problemReporter().contradictoryNullAnnotations(this);
+							variable.tagBits &= ~TagBits.AnnotationNullMASK; // avoid secondary problems
 						}
 						if ((tagBits & TagBits.AnnotationSuppressWarnings) != 0) {
 							LocalDeclaration localDeclaration = variable.declaration;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
index d4fd8e7..397e534 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
@@ -14,6 +14,7 @@
  *     Stephan Herrmann - Contributions for
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 409246 - [1.8][compiler] Type annotations on catch parameters not handled properly
  *******************************************************************************/
@@ -67,7 +68,11 @@ public class Argument extends LocalDeclaration {
 				}
 			}
 		}
-		resolveAnnotations(scope, this.annotations, this.binding, true);
+		if ((this.binding.tagBits & TagBits.AnnotationResolved) == 0) {
+			resolveAnnotations(scope, this.annotations, this.binding, true);
+			if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8)
+				scope.validateNullAnnotation(this.binding.tagBits, this.type, this.annotations);
+		}
 		this.binding.declaration = this;
 		return this.binding.type; // might have been updated during resolveAnnotations (for typeAnnotations)
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index cb04c3c..c28011e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -31,6 +31,7 @@
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
  *								Bug 416172 - [1.8][compiler][null] null type annotation not evaluated on method return type
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1620,7 +1621,7 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 			if (sourceLevel >= ClassFileConstants.JDK1_8) {
 				AnnotationBinding [] annotations = field.getAnnotations();
 				if (annotations != null && annotations != Binding.NO_ANNOTATIONS) {
-					ASTNode.copySE8AnnotationsToType(initializationScope, field, annotations);
+					ASTNode.copySE8AnnotationsToType(initializationScope, field, fieldDecl.annotations);
 				}
 			}
 			// apply null default:
@@ -1805,7 +1806,7 @@ public MethodBinding resolveTypesFor(MethodBinding method) {
 				if (sourceLevel >= ClassFileConstants.JDK1_8) {
 					AnnotationBinding [] annotations = method.getAnnotations();
 					if (annotations != null && annotations != Binding.NO_ANNOTATIONS) {
-						ASTNode.copySE8AnnotationsToType(methodDecl.scope, method, annotations);
+						ASTNode.copySE8AnnotationsToType(methodDecl.scope, method, methodDecl.annotations);
 					}
 				}
 				TypeBinding leafType = methodType.leafComponentType();
commit 7c0be3631ccaa5ae2d50fbe318ed50c01164d856
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Wed Sep 18 01:10:45 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - refactoring

19	31	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index a717ad9..81fe9f9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -848,18 +848,10 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 				switch (recipient.kind()) {
 					case Binding.LOCAL:
 						LocalVariableBinding local = (LocalVariableBinding) recipient;
-						if (Annotation.isTypeUseCompatible(local.declaration.type, scope)) { // discard hybrid annotations on package qualified types.
+						TypeReference typeRef = local.declaration.type;
+						if (Annotation.isTypeUseCompatible(typeRef, scope)) { // discard hybrid annotations on package qualified types.
 							local.declaration.bits |= HasTypeAnnotations;
-							final TypeBinding localType = local.type;
-							long prevNullBits = localType.tagBits & TagBits.AnnotationNullMASK;
-							if (se8nullBits != 0 && prevNullBits != se8nullBits && ((prevNullBits | se8nullBits) == TagBits.AnnotationNullMASK)) {
-								scope.problemReporter().contradictoryNullAnnotations(se8NullAnnotation);
-							}
-							TypeBinding oldLeafType = localType.leafComponentType();
-							AnnotationBinding [][] goodies = new AnnotationBinding[local.declaration.type.getAnnotatableLevels()][];
-							goodies[0] = se8Annotations;  // @T X.Y.Z local; ==> @T should annotate X
-							TypeBinding newLeafType = scope.environment().createAnnotatedType(oldLeafType, goodies);
-							local.type = localType.isArrayType() ? scope.environment().createArrayType(newLeafType, localType.dimensions(), localType.getTypeAnnotations()) : newLeafType;
+							local.type = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, typeRef, local.type);
 						}
 						break;
 					case Binding.FIELD:
@@ -867,16 +859,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 						SourceTypeBinding sourceType = (SourceTypeBinding) field.declaringClass;
 						FieldDeclaration fieldDeclaration = sourceType.scope.referenceContext.declarationOf(field);
 						if (Annotation.isTypeUseCompatible(fieldDeclaration.type, scope)) { // discard hybrid annotations on package qualified types.
-							TypeBinding fieldType = field.type;
-							long prevNullBits = fieldType.tagBits & TagBits.AnnotationNullMASK;
-							if (se8nullBits != 0 && prevNullBits != se8nullBits && ((prevNullBits | se8nullBits) == TagBits.AnnotationNullMASK)) {
-								scope.problemReporter().contradictoryNullAnnotations(se8NullAnnotation);
-							}
-							TypeBinding oldLeafType = fieldType.leafComponentType();
-							AnnotationBinding [][] goodies = new AnnotationBinding[fieldDeclaration.type.getAnnotatableLevels()][];
-							goodies[0] = se8Annotations; // @T X.Y.Z field; ==> @T should annotate X
-							TypeBinding newLeafType = scope.environment().createAnnotatedType(oldLeafType, goodies);
-							field.type = fieldType.isArrayType() ? scope.environment().createArrayType(newLeafType, fieldType.dimensions(), fieldType.getTypeAnnotations()) : newLeafType;
+							field.type = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, fieldDeclaration.type, field.type);
 						}
 						break;
 					case Binding.METHOD:
@@ -885,16 +868,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 							sourceType = (SourceTypeBinding) method.declaringClass;
 							MethodDeclaration methodDecl = (MethodDeclaration) sourceType.scope.referenceContext.declarationOf(method);
 							if (Annotation.isTypeUseCompatible(methodDecl.returnType, scope)) {
-								final TypeBinding returnType = method.returnType;
-								long prevNullBits = returnType.tagBits & TagBits.AnnotationNullMASK;
-								if (se8nullBits != 0 && prevNullBits != se8nullBits && ((prevNullBits | se8nullBits) == TagBits.AnnotationNullMASK)) {
-									scope.problemReporter().contradictoryNullAnnotations(se8NullAnnotation);
-								}
-								TypeBinding oldLeafType = returnType.leafComponentType();
-								AnnotationBinding [][] goodies = new AnnotationBinding[methodDecl.returnType.getAnnotatableLevels()][];
-								goodies[0] = se8Annotations;
-								TypeBinding newLeafType = scope.environment().createAnnotatedType(oldLeafType, goodies);
-								method.returnType = returnType.isArrayType() ? scope.environment().createArrayType(newLeafType, returnType.dimensions(), returnType.getTypeAnnotations()) : newLeafType;
+								method.returnType = mergeAnnotationsIntoType(scope, se8Annotations, se8nullBits, se8NullAnnotation, methodDecl.returnType, method.returnType);
 							}
 						}
 						break;
@@ -903,6 +877,20 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 		}
 	}
 
+	private static TypeBinding mergeAnnotationsIntoType(BlockScope scope, AnnotationBinding[] se8Annotations, long se8nullBits, Annotation se8NullAnnotation,
+			TypeReference typeRef, TypeBinding existingType) 
+	{
+		long prevNullBits = existingType.tagBits & TagBits.AnnotationNullMASK;
+		if (se8nullBits != 0 && prevNullBits != se8nullBits && ((prevNullBits | se8nullBits) == TagBits.AnnotationNullMASK)) {
+			scope.problemReporter().contradictoryNullAnnotations(se8NullAnnotation);
+		}
+		TypeBinding oldLeafType = existingType.leafComponentType();
+		AnnotationBinding [][] goodies = new AnnotationBinding[typeRef.getAnnotatableLevels()][];
+		goodies[0] = se8Annotations;  // @T X.Y.Z local; ==> @T should annotate X
+		TypeBinding newLeafType = scope.environment().createAnnotatedType(oldLeafType, goodies);
+		return existingType.isArrayType() ? scope.environment().createArrayType(newLeafType, existingType.dimensions(), existingType.getTypeAnnotations()) : newLeafType;
+	}
+
 /**
  * Figures if @Deprecated annotation is specified, do not resolve entire annotations.
  */
commit c8fa56c625729a2c5aff4c492dea2eebe9fdcef6
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Wed Sep 18 23:58:13 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - fix {Method,Field}Binding#canBeSeenBy(..)

12	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
10	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
index 3644bc4..4b07a42 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
@@ -66,7 +70,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 	if (isPublic()) return true;
 
 	SourceTypeBinding invocationType = scope.enclosingSourceType();
-	if (invocationType == this.declaringClass && invocationType == receiverType) return true;
+	if (TypeBinding.equalsEquals(invocationType, this.declaringClass) && TypeBinding.equalsEquals(invocationType, receiverType)) return true;
 
 	if (invocationType == null) // static import call
 		return !isPrivate() && scope.getCurrentPackage() == this.declaringClass.fPackage;
@@ -77,7 +81,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 		//    AND the receiverType is the invocationType or its subclass
 		//    OR the method is a static method accessed directly through a type
 		//    OR previous assertions are true for one of the enclosing type
-		if (invocationType == this.declaringClass) return true;
+		if (TypeBinding.equalsEquals(invocationType, this.declaringClass)) return true;
 		if (invocationType.fPackage == this.declaringClass.fPackage) return true;
 
 		ReferenceBinding currentType = invocationType;
@@ -95,7 +99,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 					if (depth > 0) invocationSite.setDepth(depth);
 					return true; // see 1FMEPDL - return invocationSite.isTypeAccess();
 				}
-				if (currentType == receiverErasure || receiverErasure.findSuperTypeOriginatingFrom(currentType) != null) {
+				if (TypeBinding.equalsEquals(currentType, receiverErasure) || receiverErasure.findSuperTypeOriginatingFrom(currentType) != null) {
 					if (depth > 0) invocationSite.setDepth(depth);
 					return true;
 				}
@@ -110,7 +114,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 		// answer true if the receiverType is the declaringClass
 		// AND the invocationType and the declaringClass have a common enclosingType
 		receiverCheck: {
-			if (receiverType != this.declaringClass) {
+			if (TypeBinding.notEquals(receiverType, this.declaringClass)) {
 				// special tolerance for type variable direct bounds, but only if compliance <= 1.6, see: https://bugs.eclipse.org/bugs/show_bug.cgi?id=334622
 				if (scope.compilerOptions().complianceLevel <= ClassFileConstants.JDK1_6 && receiverType.isTypeVariable() && ((TypeVariableBinding) receiverType).isErasureBoundTo(this.declaringClass.erasure()))
 					break receiverCheck;
@@ -118,7 +122,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 			}
 		}
 
-		if (invocationType != this.declaringClass) {
+		if (TypeBinding.notEquals(invocationType, this.declaringClass)) {
 			ReferenceBinding outerInvocationType = invocationType;
 			ReferenceBinding temp = outerInvocationType.enclosingType();
 			while (temp != null) {
@@ -132,7 +136,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 				outerDeclaringClass = temp;
 				temp = temp.enclosingType();
 			}
-			if (outerInvocationType != outerDeclaringClass) return false;
+			if (TypeBinding.notEquals(outerInvocationType, outerDeclaringClass)) return false;
 		}
 		return true;
 	}
@@ -148,9 +152,9 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 	ReferenceBinding currentType = (ReferenceBinding) receiverType;
 	do {
 		if (currentType.isCapture()) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=285002
-			if (originalDeclaringClass == currentType.erasure().original()) return true;
+			if (TypeBinding.equalsEquals(originalDeclaringClass, currentType.erasure().original())) return true;
 		} else {
-			if (originalDeclaringClass == currentType.original()) return true;
+			if (TypeBinding.equalsEquals(originalDeclaringClass, currentType.original())) return true;
 		}
 		PackageBinding currentPackage = currentType.fPackage;
 		// package could be null for wildcards/intersection types, ignore and recurse in superclass
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index fb0932e..9d12b21 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -268,9 +268,9 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 		// Static interface methods can be explicitly invoked only through the type reference of the declaring interface or implicitly in the interface itself.
 		if (scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8)
 			return false;
-		if (invocationSite.isTypeAccess() && receiverType == this.declaringClass)
+		if (invocationSite.isTypeAccess() && TypeBinding.equalsEquals(receiverType, this.declaringClass))
 			return true;
-		if (invocationSite.receiverIsImplicitThis() && invocationType == this.declaringClass)
+		if (invocationSite.receiverIsImplicitThis() && TypeBinding.equalsEquals(invocationType, this.declaringClass))
 			return true;
 		return false;
 	}
@@ -278,7 +278,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 	if (isPublic()) return true;
 	
 
-	if (invocationType == this.declaringClass && invocationType == receiverType) return true;
+	if (TypeBinding.equalsEquals(invocationType, this.declaringClass) && TypeBinding.equalsEquals(invocationType, receiverType)) return true;
 
 	if (invocationType == null) // static import call
 		return !isPrivate() && scope.getCurrentPackage() == this.declaringClass.fPackage;
@@ -289,7 +289,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 		//    AND the receiverType is the invocationType or its subclass
 		//    OR the method is a static method accessed directly through a type
 		//    OR previous assertions are true for one of the enclosing type
-		if (invocationType == this.declaringClass) return true;
+		if (TypeBinding.equalsEquals(invocationType, this.declaringClass)) return true;
 		if (invocationType.fPackage == this.declaringClass.fPackage) return true;
 
 		ReferenceBinding currentType = invocationType;
@@ -307,7 +307,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 					if (depth > 0) invocationSite.setDepth(depth);
 					return true; // see 1FMEPDL - return invocationSite.isTypeAccess();
 				}
-				if (currentType == receiverErasure || receiverErasure.findSuperTypeOriginatingFrom(currentType) != null) {
+				if (TypeBinding.equalsEquals(currentType, receiverErasure) || receiverErasure.findSuperTypeOriginatingFrom(currentType) != null) {
 					if (depth > 0) invocationSite.setDepth(depth);
 					return true;
 				}
@@ -322,7 +322,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 		// answer true if the receiverType is the declaringClass
 		// AND the invocationType and the declaringClass have a common enclosingType
 		receiverCheck: {
-			if (receiverType != this.declaringClass) {
+			if (TypeBinding.notEquals(receiverType, this.declaringClass)) {
 				// special tolerance for type variable direct bounds, but only if compliance <= 1.6, see: https://bugs.eclipse.org/bugs/show_bug.cgi?id=334622
 				if (scope.compilerOptions().complianceLevel <= ClassFileConstants.JDK1_6 && receiverType.isTypeVariable() && ((TypeVariableBinding) receiverType).isErasureBoundTo(this.declaringClass.erasure()))
 					break receiverCheck;
@@ -330,7 +330,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 			}
 		}
 
-		if (invocationType != this.declaringClass) {
+		if (TypeBinding.notEquals(invocationType, this.declaringClass)) {
 			ReferenceBinding outerInvocationType = invocationType;
 			ReferenceBinding temp = outerInvocationType.enclosingType();
 			while (temp != null) {
@@ -344,7 +344,7 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 				outerDeclaringClass = temp;
 				temp = temp.enclosingType();
 			}
-			if (outerInvocationType != outerDeclaringClass) return false;
+			if (TypeBinding.notEquals(outerInvocationType, outerDeclaringClass)) return false;
 		}
 		return true;
 	}
@@ -360,9 +360,9 @@ public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invoca
 	ReferenceBinding currentType = (ReferenceBinding) (receiverType);
 	do {
 		if (currentType.isCapture()) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=285002
-			if (originalDeclaringClass == currentType.erasure().original()) return true;
+			if (TypeBinding.equalsEquals(originalDeclaringClass, currentType.erasure().original())) return true;
 		} else {
-			if (originalDeclaringClass == currentType.original()) return true;
+			if (TypeBinding.equalsEquals(originalDeclaringClass, currentType.original())) return true;
 		}
 		PackageBinding currentPackage = currentType.fPackage;
 		// package could be null for wildcards/intersection types, ignore and recurse in superclass
commit 841f0bfe84392d37aa864c563d3642fdef603b24
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Sep 19 00:26:37 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - resolve TODOs to fix 10 failures in NullAnnotationTest

5	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 389e4ae..36bc73c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -124,9 +124,8 @@ public class ImplicitNullAnnotationVerifier {
 							currentMethod.tagBits |= tagBits;
 						} else {
 							if (!currentMethod.returnType.isBaseType()) {
-								// TODO(Stephan: Synthesize AnnotationBinding[] and call LE#createAnnotatedType(TB, AB[]);
-								// currentMethod.returnType = scope.environment()
-								//		.createAnnotatedType(currentMethod.returnType, tagBits);
+								LookupEnvironment env = scope.environment();
+								currentMethod.returnType = env.createAnnotatedType(currentMethod.returnType, env.nullAnnotationsFromTagBits(tagBits));
 							}
 						}
 					}
@@ -382,8 +381,7 @@ public class ImplicitNullAnnotationVerifier {
 			method.tagBits |= nullnessBits;
 		} else {
 			if (!method.returnType.isBaseType()) {
-				// TODO(Stephan: Synthesize AnnotationBinding[] and call LE#createAnnotatedType(TB, AB[]);
-				//	method.returnType = environment.createAnnotatedType(method.returnType, nullnessBits);
+				method.returnType = environment.createAnnotatedType(method.returnType, environment.nullAnnotationsFromTagBits(nullnessBits));
 			}
 		}
 	}
@@ -439,9 +437,8 @@ public class ImplicitNullAnnotationVerifier {
 		}
 	}
 	void recordArgNonNullness18(MethodBinding method, int paramIdx, Argument currentArgument, Boolean nonNullNess, LookupEnvironment env) {
-		// TODO(Stephan: Synthesize AnnotationBinding[] and call LE#createAnnotatedType(TB, AB[]);
-		//		method.parameters[paramIdx] = env.createAnnotatedType(method.parameters[paramIdx],
-		//										nonNullNess.booleanValue() ? TagBits.AnnotationNonNull : TagBits.AnnotationNullable);
+		AnnotationBinding annotationBinding = nonNullNess.booleanValue() ? env.getNonNullAnnotation() : env.getNullableAnnotation();
+		method.parameters[paramIdx] = env.createAnnotatedType(method.parameters[paramIdx], new AnnotationBinding[]{ annotationBinding});
 		if (currentArgument != null) {
 			currentArgument.binding.type = method.parameters[paramIdx];
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 1241349..5a23a77 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -25,6 +25,7 @@
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 416183 - [1.8][compiler][null] Overload resolution fails with null annotations
  *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
+ *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1032,6 +1033,14 @@ public AnnotationBinding getNonNullAnnotation() {
 	return new AnnotationBinding(nonNull, Binding.NO_ELEMENT_VALUE_PAIRS);
 }
 
+public AnnotationBinding[] nullAnnotationsFromTagBits(long nullTagBits) {
+	if (nullTagBits == TagBits.AnnotationNonNull)
+		return new AnnotationBinding[] { getNonNullAnnotation() };
+	else if (nullTagBits == TagBits.AnnotationNullable)
+		return new AnnotationBinding[] { getNullableAnnotation() };
+	return null;
+}
+
 public char[][] getNonNullAnnotationName() {
 	return this.globalOptions.nonNullAnnotationName;
 }
commit 9c5c069c4ddd977815302e00ff7a4760365b1a17
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Sep 19 00:29:04 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - some cleanup

1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
3	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index bcc7dd7..a6d8bfc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -727,7 +727,7 @@ public void traverse(ASTVisitor visitor, BlockScope scope) {
 public VariableBinding nullAnnotatedVariableBinding(boolean supportTypeAnnotations) {
 	if (this.binding != null) {
 		if (supportTypeAnnotations
-				|| ((this.binding.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) != 0)) {
+				|| ((this.binding.tagBits & TagBits.AnnotationNullMASK) != 0)) {
 			return this.binding;
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
index 31b9843..56cb66b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
@@ -856,7 +856,7 @@ public VariableBinding nullAnnotatedVariableBinding(boolean supportTypeAnnotatio
 		case Binding.FIELD : // reading a field
 		case Binding.LOCAL : // reading a local variable
 			if (supportTypeAnnotations 
-					|| (((VariableBinding)this.binding).tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) != 0)
+					|| (((VariableBinding)this.binding).tagBits & TagBits.AnnotationNullMASK) != 0)
 				return (VariableBinding) this.binding;
 	}
 	return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 34cbee8..107d32b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -1418,12 +1418,11 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 			if (CharOperation.equals(typeName, nonNullByDefaultAnnotationName)) {
 				methodBinding.tagBits |= TagBits.AnnotationNonNullByDefault;
 			}
-			if (!useTypeAnnotations) {
-				if (!explicitNullness && CharOperation.equals(typeName, nonNullAnnotationName)) {
+			if (!useTypeAnnotations && !explicitNullness) {
+				if (CharOperation.equals(typeName, nonNullAnnotationName)) {
 					methodBinding.tagBits |= TagBits.AnnotationNonNull;
 					explicitNullness = true;
-				}
-				if (!explicitNullness && CharOperation.equals(typeName, nullableAnnotationName)) {
+				} else if (CharOperation.equals(typeName, nullableAnnotationName)) {
 					methodBinding.tagBits |= TagBits.AnnotationNullable;
 					explicitNullness = true;
 				}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
index 4b07a42..26c9ee2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/FieldBinding.java
@@ -234,7 +234,7 @@ public void fillInDefaultNonNullness(FieldDeclaration sourceField, Scope scope)
 	LookupEnvironment environment = scope.environment();
 	if (   this.type != null
 		&& !this.type.isBaseType()
-		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
+		&& (this.tagBits & TagBits.AnnotationNullMASK) == 0)
 	{
 		if (environment.globalOptions.sourceLevel < ClassFileConstants.JDK1_8)
 			this.tagBits |= TagBits.AnnotationNonNull;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index 9d12b21..e565778 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -500,7 +500,7 @@ protected void fillInDefaultNonNullness(AbstractMethodDeclaration sourceMethod)
 		this.tagBits |= TagBits.HasParameterAnnotations;
 	if (   this.returnType != null
 		&& !this.returnType.isBaseType()
-		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
+		&& (this.tagBits & TagBits.AnnotationNullMASK) == 0)
 	{
 		this.tagBits |= TagBits.AnnotationNonNull;
 	} else if (sourceMethod != null && (this.tagBits & TagBits.AnnotationNonNull) != 0) {
@@ -531,7 +531,7 @@ protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod
 		this.tagBits |= TagBits.HasParameterAnnotations;
 	if (   this.returnType != null
 		&& !this.returnType.isBaseType()
-		&& (this.returnType.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
+		&& (this.returnType.tagBits & TagBits.AnnotationNullMASK) == 0)
 	{
 		this.returnType = env.createAnnotatedType(this.returnType, new AnnotationBinding[]{env.getNonNullAnnotation()});
 	} else if (sourceMethod != null && (this.returnType.tagBits & TagBits.AnnotationNonNull) != 0) {
commit 2070676b1e20c45846e614809eff55257373d539
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Sep 19 12:47:57 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - fix failure in NullAnnotationTest.test_nonnull_parameter_006()

0	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
20	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index eedf2d6..455231b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -221,9 +221,6 @@ public static Test suite() {
 		tests_1_8.addAll(since_1_6);
 		tests_1_8.addAll(since_1_7);
 		tests_1_8.addAll(since_1_8);
-		// TODO(stephan) temporary workaround, several tests currently fail at 1.8:
-		tests_1_8.remove(NullAnnotationTest.class);
-		//
 		// Reset forgotten subsets tests
 		TestCase.TESTS_PREFIX = null;
 		TestCase.TESTS_NAMES = null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 05dc8f1..1d09d07 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -22,6 +22,7 @@
  *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
+ *							Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -516,7 +517,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 			// from valueIFTrue or valueIfFalse to the receiver constant
 			this.constant = condConstant.booleanValue() ? trueConstant : falseConstant;
 		}
-		if (valueIfTrueType == valueIfFalseType) { // harmed the implicit conversion
+		if (TypeBinding.equalsEquals(valueIfTrueType, valueIfFalseType)) { // harmed the implicit conversion
 			this.valueIfTrue.computeConversion(scope, valueIfTrueType, this.originalValueIfTrueType);
 			this.valueIfFalse.computeConversion(scope, valueIfFalseType, this.originalValueIfFalseType);
 			if (valueIfTrueType == TypeBinding.BOOLEAN) {
@@ -533,7 +534,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 						: this.optimizedIfFalseConstant;
 				}
 			}
-			return this.resolvedType = valueIfTrueType;
+			return this.resolvedType = NullAnnotationMatching.moreDangerousType(valueIfTrueType, valueIfFalseType);
 		}
 		// Determine the return type depending on argument types
 		// Numeric types
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
index 474bfdf..e233802 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
@@ -164,15 +164,32 @@ public class NullAnnotationMatching {
 		bits &= TagBits.AnnotationNullMASK;
 		return bits == TagBits.AnnotationNullMASK ? 0 : bits;
 	}
+	
+	/** Provided that both types are {@link TypeBinding#equalsEquals}, return the one that is more likely to show null at runtime. */
+	public static TypeBinding moreDangerousType(TypeBinding one, TypeBinding two) {
+		if (one == null) return null;
+		long oneNullBits = validNullTagBits(one.tagBits);
+		long twoNullBits = validNullTagBits(two.tagBits);
+		if (oneNullBits == twoNullBits)
+			return one;			// same difference
+		if (oneNullBits == TagBits.AnnotationNullable)
+			return one;			// nullable is dangerous
+		if (twoNullBits == TagBits.AnnotationNullable)
+			return two;			// nullable is dangerous
+		// below this point we have unknown vs. nonnull, which is which?
+		if (oneNullBits == 0)
+			return one;			// unknown is more dangerous than nonnull
+		return two;				// unknown is more dangerous than nonnull
+	}
 
 	private static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus) {
 		if (requiredBits != 0 && requiredBits != providedBits) {
+			if (requiredBits == TagBits.AnnotationNonNull && nullStatus == FlowInfo.NON_NULL) {
+				return 0; // OK by flow analysis
+			}
 			if (providedBits != 0) {
 				return 2; // mismatching annotations
 			} else {
-				if (requiredBits == TagBits.AnnotationNonNull && nullStatus == FlowInfo.NON_NULL) {
-					return 0; // OK by flow analysis
-				}
 				return 1; // need unchecked conversion regarding type detail
 			}
 		}
commit 3e7114db66d7154ea4072c5af4dcd065de055bb8
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Sep 19 14:31:21 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - resolve TODOs in NTAT

39	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
14	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 63777c2..40972dd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -29,7 +29,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	// Static initializer to specify tests subset using TESTS_* static variables
 	// All specified tests which do not belong to the class are skipped...
 	static {
-//			TESTS_NAMES = new String[] { "testCompatibility6" };
+//			TESTS_NAMES = new String[] { "testConditional2" };
 //			TESTS_NUMBERS = new int[] { 561 };
 //			TESTS_RANGE = new int[] { 1, 2049 };
 	}
@@ -1452,7 +1452,6 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"Null type mismatch (type annotations): required \'List<@Nullable ? extends X1>\' but this expression has type \'ArrayList<@NonNull X1>\', corresponding supertype is \'List<@NonNull X1>\'\n" + 
 				"----------\n");
 	}
-	// TODO(Stephan): Fix lub computation to create an intersection type when annotations differ. See comment in Scope#lowerUpperBound.
 	public void testConditional1() {
 		runNegativeTestWithLibs(
 			new String[] {
@@ -1472,7 +1471,43 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				+ "}\n"
 			},
 			"----------\n" + 
-			"1. WARNING in X.java (at line 8)\n" + 
+			"1. WARNING in X.java (at line 6)\n" + 
+			"	return f == 0 ? good : dubious;\n" + 
+			"	       ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Null type safety (type annotations): The expression of type \'List<String>\' needs unchecked conversion to conform to \'List<@NonNull String>\'\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 8)\n" + 
+			"	return f == 2 ? dubious : good;\n" + 
+			"	       ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Null type safety (type annotations): The expression of type \'List<String>\' needs unchecked conversion to conform to \'List<@NonNull String>\'\n" + 
+			"----------\n");
+	}
+
+	public void _testConditional2() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n"
+				+ "import java.util.*;\n"
+				+ "public class X {\n"
+				+ "	List<@NonNull String> foo(List<@NonNull String> good, ArrayList<String> dubious, int f) {\n"
+				+ "		if (f < 2)\n"
+				+ "			return f == 0 ? good : dubious;\n"
+				+ "		if (f < 4)\n"
+				+ "			return f == 2 ? dubious : good;\n"
+				+ "		if (f < 6)\n"
+				+ "			return f == 4 ? good : good;\n"
+				+ "		return null;\n"
+				+ "	}\n"
+				+ "}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in X.java (at line 6)\n" + 
+			"	return f == 0 ? good : dubious;\n" + 
+			"	       ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Null type safety (type annotations): The expression of type \'List<String>\' needs unchecked conversion to conform to \'List<@NonNull String>\'\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 8)\n" + 
 			"	return f == 2 ? dubious : good;\n" + 
 			"	       ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
 			"Null type safety (type annotations): The expression of type \'List<String>\' needs unchecked conversion to conform to \'List<@NonNull String>\'\n" + 
@@ -2284,7 +2319,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"The method foo(List<X>) of type Z should be tagged with @Override since it actually overrides a superclass method\n" + 
 			"----------\n");
 	}
-	// TODO(Stephan) : the message needs clean up.
+
 	public void testBug416175() {
 		runNegativeTestWithLibs(
 			new String[] {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
index e233802..63f0d21 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
@@ -170,16 +170,20 @@ public class NullAnnotationMatching {
 		if (one == null) return null;
 		long oneNullBits = validNullTagBits(one.tagBits);
 		long twoNullBits = validNullTagBits(two.tagBits);
-		if (oneNullBits == twoNullBits)
-			return one;			// same difference
-		if (oneNullBits == TagBits.AnnotationNullable)
-			return one;			// nullable is dangerous
-		if (twoNullBits == TagBits.AnnotationNullable)
-			return two;			// nullable is dangerous
-		// below this point we have unknown vs. nonnull, which is which?
-		if (oneNullBits == 0)
-			return one;			// unknown is more dangerous than nonnull
-		return two;				// unknown is more dangerous than nonnull
+		if (oneNullBits != twoNullBits) {
+			if (oneNullBits == TagBits.AnnotationNullable)
+				return one;			// nullable is dangerous
+			if (twoNullBits == TagBits.AnnotationNullable)
+				return two;			// nullable is dangerous
+			// below this point we have unknown vs. nonnull, which is which?
+			if (oneNullBits == 0)
+				return one;			// unknown is more dangerous than nonnull
+			return two;				// unknown is more dangerous than nonnull
+		} else if (one != two) {
+			if (analyse(one, two, -1).isAnyMismatch())
+				return two;			// two doesn't snugly fit into one, so it must be more dangerous
+		}
+		return one;
 	}
 
 	private static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus) {
commit 7bc187afbb4bb56c7b85a00c0e5a5881aabde72f
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Sep 19 15:27:49 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - item (10)

9	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 5a23a77..6706382 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -98,6 +98,9 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 	PackageBinding nonnullAnnotationPackage;			// the package supposed to contain the NonNull annotation type
 	PackageBinding nonnullByDefaultAnnotationPackage;	// the package supposed to contain the NonNullByDefault annotation type
 
+	AnnotationBinding nonNullAnnotation;
+	AnnotationBinding nullableAnnotation;
+
 	final static int BUILD_FIELDS_AND_METHODS = 4;
 	final static int BUILD_TYPE_HIERARCHY = 1;
 	final static int CHECK_AND_SET_IMPORTS = 2;
@@ -1020,8 +1023,10 @@ public ReferenceBinding getCachedType(char[][] compoundName) {
 }
 
 public AnnotationBinding getNullableAnnotation() {
+	if (this.nullableAnnotation != null)
+		return this.nullableAnnotation;
 	ReferenceBinding nullable = getResolvedType(this.globalOptions.nullableAnnotationName, null);
-	return new AnnotationBinding(nullable, Binding.NO_ELEMENT_VALUE_PAIRS);
+	return this.nullableAnnotation = this.typeSystem.getAnnotationType(nullable);
 }
 
 public char[][] getNullableAnnotationName() {
@@ -1029,8 +1034,10 @@ public char[][] getNullableAnnotationName() {
 }
 
 public AnnotationBinding getNonNullAnnotation() {
+	if (this.nonNullAnnotation != null) 
+		return this.nonNullAnnotation;
 	ReferenceBinding nonNull = getResolvedType(this.globalOptions.nonNullAnnotationName, null);
-	return new AnnotationBinding(nonNull, Binding.NO_ELEMENT_VALUE_PAIRS);
+	return this.nonNullAnnotation = this.typeSystem.getAnnotationType(nonNull);
 }
 
 public AnnotationBinding[] nullAnnotationsFromTagBits(long nullTagBits) {
commit 0de87442117bb22923c82a3ea7fce2ce6f7d0ece
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Sep 19 15:45:49 2013 +0200

    Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel
    well with deep encoded type bindings.
    - item (11)

0	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index dfaa9c4..28ebb7d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -782,9 +782,6 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	            for (int i = 0; i < length; i++) {
 	            	if (!this.arguments[i].isTypeArgumentContainedBy(otherArguments[i]))
 	            		return false;
-	            	// Stephan : is this intentional ?? 
-//	            	if ((this.arguments[i].tagBits & TagBits.AnnotationNullMASK) != (otherArguments[i].tagBits & TagBits.AnnotationNullMASK))
-//	            		return false;
 	            }
 	            return true;
 
