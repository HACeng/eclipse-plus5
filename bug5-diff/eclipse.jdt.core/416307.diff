commit af79dfe4ab6f88841082d7727b71d3b65b4f7778
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Sep 1 13:43:57 2013 +0200

    Bug 416307 - [1.8][compiler][null] subclass with type parameter
    substitution confuses null checking

5	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
55	5	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
17	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
5	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
6	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
55	28	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
27	14	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
14	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index a984a0b..362d4d6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -33,6 +33,7 @@
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
+ *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *     Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -828,8 +829,10 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NullityMismatchingTypeAnnotationSuperHint", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullityMismatchTypeArgument", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullityUncheckedTypeAnnotationDetail", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NullityUncheckedTypeAnnotationDetailSuperHint", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullSourceString", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("NullUnboxing", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NumericValueOutOfRange", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -1616,8 +1619,10 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NullAnnotationUnsupportedLocation", SKIP);
 		expectedProblemAttributes.put("NullAnnotationUnsupportedLocationAtType", SKIP);
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("NullityMismatchingTypeAnnotationSuperHint", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("NullityMismatchTypeArgument", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("NullityUncheckedTypeAnnotationDetail", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
+		expectedProblemAttributes.put("NullityUncheckedTypeAnnotationDetailSuperHint", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
 		expectedProblemAttributes.put("NullExpressionReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 7620800..a169fe1 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -29,7 +29,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	// Static initializer to specify tests subset using TESTS_* static variables
 	// All specified tests which do not belong to the class are skipped...
 	static {
-//			TESTS_NAMES = new String[] { "testUnsupportedLocation" };
+//			TESTS_NAMES = new String[] { "testCompatibility6" };
 //			TESTS_NUMBERS = new int[] { 561 };
 //			TESTS_RANGE = new int[] { 1, 2049 };
 	}
@@ -1355,12 +1355,12 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"4. ERROR in Y1.java (at line 10)\n" + 
 				"	x.wildcard2(new ArrayList<@Nullable Object>()); // incompatible(1)\n" + 
 				"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Null type mismatch (type annotations): required \'List<? super @NonNull X1>\' but this expression has type \'ArrayList<@Nullable Object>\'\n" + 
+				"Null type mismatch (type annotations): required \'List<? super @NonNull X1>\' but this expression has type \'ArrayList<@Nullable Object>\', corresponding supertype is \'List<@Nullable Object>\'\n" + 
 				"----------\n" + 
 				"5. ERROR in Y1.java (at line 11)\n" + 
 				"	x.wildcard1(new ArrayList<@NonNull X1>()); // incompatible(2)\n" + 
 				"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Null type mismatch (type annotations): required \'List<@Nullable ? extends p.X1>\' but this expression has type \'ArrayList<@NonNull X1>\'\n" + 
+				"Null type mismatch (type annotations): required \'List<@Nullable ? extends p.X1>\' but this expression has type \'ArrayList<@NonNull X1>\', corresponding supertype is \'List<@NonNull X1>\'\n" + 
 				"----------\n");
 	}
 
@@ -1445,12 +1445,12 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"4. ERROR in Y1.java (at line 10)\n" + 
 				"	x.wildcard2(new ArrayList<java.lang.@Nullable Object>()); // incompatible(1)\n" + 
 				"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Null type mismatch (type annotations): required \'List<? super @NonNull X1>\' but this expression has type \'ArrayList<@Nullable Object>\'\n" + 
+				"Null type mismatch (type annotations): required \'List<? super @NonNull X1>\' but this expression has type \'ArrayList<@Nullable Object>\', corresponding supertype is \'List<@Nullable Object>\'\n" + 
 				"----------\n" + 
 				"5. ERROR in Y1.java (at line 11)\n" + 
 				"	x.wildcard1(new ArrayList<p.@NonNull X1>()); // incompatible(2)\n" + 
 				"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Null type mismatch (type annotations): required \'List<@Nullable ? extends p.X1>\' but this expression has type \'ArrayList<@NonNull X1>\'\n" + 
+				"Null type mismatch (type annotations): required \'List<@Nullable ? extends p.X1>\' but this expression has type \'ArrayList<@NonNull X1>\', corresponding supertype is \'List<@NonNull X1>\'\n" + 
 				"----------\n");
 	}
 
@@ -1835,6 +1835,56 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n");
 	}
 
+	// challenge parameterized type with partial substitution of super's type parameters
+	public void testCompatibility5() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import java.util.Map;\n" + 
+				"\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"abstract public class X<Y> implements Map<@NonNull String,Y> {\n" + 
+				"	void foo(X<Object> x) {\n" + 
+				"		Map<@NonNull String, Object> m1 = x; // OK\n" + 
+				"		Map<@Nullable String, Object> m2 = x; // NOK\n" + 
+				"	}\n" + 
+				"}"
+			},
+			getCompilerOptions(),
+			"----------\n" +
+			"1. ERROR in X.java (at line 8)\n" + 
+			"	Map<@Nullable String, Object> m2 = x; // NOK\n" + 
+			"	                                   ^\n" + 
+			"Null type mismatch (type annotations): required \'Map<@Nullable String,Object>\' but this expression has type \'X<Object>\', corresponding supertype is \'Map<@NonNull String,Object>\'\n" + 
+			"----------\n");
+	}
+
+	// challenge parameterized type with partial substitution of super's type parameters
+	public void testCompatibility6() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import java.util.Map;\n" + 
+				"\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"abstract public class X<@Nullable Y> implements Map<@Nullable String,Y> {\n" + 
+				"	void foo(X<Object> x) {\n" + 
+				"		Map<@Nullable String, @Nullable Object> m1 = x; // OK\n" + 
+				"		Map<@Nullable String, @NonNull Object> m2 = x; // NOK\n" + 
+				"	}\n" + 
+				"}"
+			},
+			getCompilerOptions(),
+			"----------\n" +
+			"1. ERROR in X.java (at line 8)\n" + 
+			"	Map<@Nullable String, @NonNull Object> m2 = x; // NOK\n" + 
+			"	                                            ^\n" + 
+			"Null type mismatch (type annotations): required \'Map<@Nullable String,@NonNull Object>\' but this expression has type \'X<Object>\', corresponding supertype is \'Map<@Nullable String,@Nullable Object>\'\n" + 
+			"----------\n");
+	}
+
 	// illegal for type declaration
 	public void testUnsupportedLocation01() {
 		runNegativeTestWithLibs(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index fe1d19c..8db8042 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -161,7 +161,9 @@
  *									ArrayReferencePotentialNullReference
  *									DereferencingNullableExpression
  *									NullityMismatchingTypeAnnotation
+ *									NullityMismatchingTypeAnnotationSuperHint
  *									NullityUncheckedTypeAnnotationDetail
+ *									NullityUncheckedTypeAnnotationDetailSuperHint
  *									NullableFieldReference
  *									UninitializedNonNullField
  *									UninitializedNonNullFieldHintMissingDefault
@@ -1685,27 +1687,31 @@ void setSourceStart(int sourceStart);
 	/** @since 3.9 BETA_JAVA8 */
 	int NullityMismatchingTypeAnnotation = Internal + 953;
 	/** @since 3.9 BETA_JAVA8 */
-	int NullityUncheckedTypeAnnotationDetail = Internal + 954;
+	int NullityMismatchingTypeAnnotationSuperHint = Internal + 954;
 	/** @since 3.9 BETA_JAVA8 */
-	int ReferenceExpressionParameterMismatchPromisedNullable = MethodRelated + 955;
+	int NullityUncheckedTypeAnnotationDetail = Internal + 955;
 	/** @since 3.9 BETA_JAVA8 */
-	int ReferenceExpressionParameterRequiredNonnullUnchecked = MethodRelated + 956;
+	int NullityUncheckedTypeAnnotationDetailSuperHint = Internal + 956;
 	/** @since 3.9 BETA_JAVA8 */
-	int ReferenceExpressionReturnNullRedef = MethodRelated + 957;
+	int ReferenceExpressionParameterMismatchPromisedNullable = MethodRelated + 957;
 	/** @since 3.9 BETA_JAVA8 */
-	int ReferenceExpressionReturnNullRedefUnchecked = MethodRelated + 958;
+	int ReferenceExpressionParameterRequiredNonnullUnchecked = MethodRelated + 958;
 	/** @since 3.9 BETA_JAVA8 */
-	int RedundantNullCheckAgainstNonNullType = Internal + 959;
+	int ReferenceExpressionReturnNullRedef = MethodRelated + 959;
 	/** @since 3.9 BETA_JAVA8 */
-	int NullAnnotationUnsupportedLocation = Internal + 960;
+	int ReferenceExpressionReturnNullRedefUnchecked = MethodRelated + 960;
 	/** @since 3.9 BETA_JAVA8 */
-	int NullAnnotationUnsupportedLocationAtType = Internal + 961;
+	int RedundantNullCheckAgainstNonNullType = Internal + 961;
 	/** @since 3.9 BETA_JAVA8 */
-	int NullityMismatchTypeArgument = Internal + 962;
+	int NullAnnotationUnsupportedLocation = Internal + 962;
 	/** @since 3.9 BETA_JAVA8 */
-	int ContradictoryNullAnnotationsOnBound = Internal + 963;
+	int NullAnnotationUnsupportedLocationAtType = Internal + 963;
 	/** @since 3.9 BETA_JAVA8 */
-	int UnsafeNullnessCast = Internal + 964;
+	int NullityMismatchTypeArgument = Internal + 964;
+	/** @since 3.9 BETA_JAVA8 */
+	int ContradictoryNullAnnotationsOnBound = Internal + 965;
+	/** @since 3.9 BETA_JAVA8 */
+	int UnsafeNullnessCast = Internal + 966;
 
 	// Java 8 work
 	/** @since 3.9 BETA_JAVA8 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
index 40e8289..07d3b2a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
@@ -20,6 +20,7 @@
  *								bug 401017 - [compiler][null] casted reference to @Nullable field lacks a warning
  *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
+ *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 415541 - [1.8][compiler] Type annotations in the body of static initializer get dropped
  *******************************************************************************/
@@ -87,7 +88,7 @@ public static void checkNeedForAssignedCast(BlockScope scope, TypeBinding expect
 	if (castedExpressionType.isCompatibleWith(expectedType, scope)) {
 		if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
 			// are null annotations compatible, too?
-			if (findNullTypeAnnotationMismatch(expectedType, castedExpressionType, -1) > 0)
+			if (findNullTypeAnnotationMismatch(expectedType, castedExpressionType, -1).isAnyMismatch())
 				return; // already reported unchecked cast (nullness), say no more.
 		}
 		scope.problemReporter().unnecessaryCast(rhs);
@@ -537,8 +538,8 @@ public TypeBinding resolveType(BlockScope scope) {
 
 			// internally for type checking use the unannotated types:
 			TypeBinding unannotatedCastType = castType.unannotated();
-			int nullityMismatch = findNullTypeAnnotationMismatch(castType, expressionType, -1);
-			if (nullityMismatch > 0)
+			boolean nullAnnotationMismatch = findNullTypeAnnotationMismatch(castType, expressionType, -1).isAnyMismatch();
+			if (nullAnnotationMismatch)
 				castType = unannotatedCastType; // problem exists, so use the unannotated type also externally
 			expressionType = expressionType.unannotated();
 
@@ -550,7 +551,7 @@ public TypeBinding resolveType(BlockScope scope) {
 							|| !(expressionType.isRawType() && this.expression.forcedToBeRaw(scope.referenceContext()))) {
 						scope.problemReporter().unsafeCast(this, scope);
 					}
-				} else if (nullityMismatch > 0) {
+				} else if (nullAnnotationMismatch) {
 					// report null annotation issue at medium priority
 					scope.problemReporter().unsafeNullnessCast(this, scope);
 				} else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
index 9b9f90b..61b10df 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
@@ -14,6 +14,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
+ *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -89,7 +90,7 @@ public TypeBinding resolveType(BlockScope scope) {
 	this.constant = Constant.NotAConstant;
 	TypeBinding expressionType = this.expression.resolveType(scope);
 	TypeBinding checkedType = this.type.resolveType(scope, true /* check bounds*/);
-	if (expressionType != null && checkedType != null && findNullTypeAnnotationMismatch(checkedType, expressionType, -1) > 0) {
+	if (expressionType != null && checkedType != null && findNullTypeAnnotationMismatch(checkedType, expressionType, -1).isAnyMismatch()) {
 		scope.problemReporter().nullAnnotationUnsupportedLocation(this.type);
 		checkedType = checkedType.unannotated();
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 92de0cc..1748548 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -30,6 +30,7 @@
  *								bug 401030 - [1.8][null] Null analysis support for lambda methods.
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
+ *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *     Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *******************************************************************************/
@@ -171,16 +172,13 @@ void checkAgainstNullAnnotation(BlockScope scope, FlowContext flowContext, int n
 		return;			
 	}
 	if (useTypeAnnotations) {
-		int severity = findNullTypeAnnotationMismatch(methodBinding.returnType, this.expression.resolvedType, nullStatus);
-		if (severity == 2) {
-			scope.problemReporter().nullityMismatchingTypeAnnotation(this.expression, this.expression.resolvedType, methodBinding.returnType, severity);
-			return;
-		} else if (severity == 1) {
+		NullAnnotationStatus annotationStatus = findNullTypeAnnotationMismatch(methodBinding.returnType, this.expression.resolvedType, nullStatus);
+		if (annotationStatus.isDefiniteMismatch()) {
+			scope.problemReporter().nullityMismatchingTypeAnnotation(this.expression, this.expression.resolvedType, methodBinding.returnType, annotationStatus);
+		} else if (annotationStatus.isUnchecked()) {
 			flowContext.recordNullityMismatch(scope, this.expression, this.expression.resolvedType, methodBinding.returnType, nullStatus);
-			return;
 		}
-	}
-	if (nullStatus != FlowInfo.NON_NULL) {
+	} else if (nullStatus != FlowInfo.NON_NULL) {
 		// if we can't prove non-null check against declared null-ness of the enclosing method:
 		if ((tagBits & TagBits.AnnotationNonNull) != 0) {
 			flowContext.recordNullityMismatch(scope, this.expression, this.expression.resolvedType, methodBinding.returnType, nullStatus);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index bbfe46f..5751f0a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -26,6 +26,7 @@
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 415291 - [1.8][null] differentiate type incompatibilities due to null annotations
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
+ *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409250 - [1.8][compiler] Various loose ends in 308 code generation
@@ -41,6 +42,29 @@ import org.eclipse.jdt.internal.compiler.lookup.*;
 
 public abstract class Statement extends ASTNode {
 
+	/** Result from analyzing null annotation compatibility. */
+	public static class NullAnnotationStatus {
+		/* 0 = OK, 1 = unchecked, 2 = definite mismatch */
+		final int severity;
+		/** If non-null this field holds the supertype of the provided type which was used for direct matching. */
+		public final TypeBinding superTypeHint;
+		
+		public NullAnnotationStatus(int severity, TypeBinding superTypeHint) {
+			this.severity = severity;
+			this.superTypeHint = superTypeHint;
+		}
+
+		public boolean isAnyMismatch() { return this.severity != 0; }
+		public boolean isUnchecked() { return this.severity == 1; }
+		public boolean isDefiniteMismatch() { return this.severity == 2; }
+		public String superTypeHintName(CompilerOptions options, boolean shortNames) {
+			return String.valueOf(this.superTypeHint.nullAnnotatedReadableName(options, shortNames));
+		}
+	}
+	public static final NullAnnotationStatus NULL_ANNOTATIONS_OK = new NullAnnotationStatus(0, null);
+	public static final NullAnnotationStatus NULL_ANNOTATIONS_UNCHECKED = new NullAnnotationStatus(1, null);
+	public static final NullAnnotationStatus NULL_ANNOTATIONS_MISMATCH = new NullAnnotationStatus(2, null);
+
 	/**
 	 * Answers true if the if is identified as a known coding pattern which
 	 * should be tolerated by dead code analysis.
@@ -134,18 +158,12 @@ protected void analyseArguments(BlockScope currentScope, FlowContext flowContext
 }
 void analyseOneArgument18(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo,
 		TypeBinding expectedType, Expression argument) {
-	int nullStatus = argument.nullStatus(flowInfo, flowContext); // slight loss of precision: should also use the null info from the receiver.
-	int severity = findNullTypeAnnotationMismatch(expectedType, argument.resolvedType, nullStatus);
-	switch (severity) {
-		case 2:
-			// immediate reporting:
-			currentScope.problemReporter().nullityMismatchingTypeAnnotation(argument, argument.resolvedType, expectedType, severity);
-			return;
-		case 1:
-			flowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);
-			return;
-	}
-	if ((expectedType.tagBits & TagBits.AnnotationNonNull) != 0 && nullStatus != FlowInfo.NON_NULL) {
+	int nullStatus = argument.nullStatus(flowInfo, flowContext);
+	NullAnnotationStatus annotationStatus = findNullTypeAnnotationMismatch(expectedType, argument.resolvedType, nullStatus);
+	if (annotationStatus.isDefiniteMismatch()) {
+		// immediate reporting:
+		currentScope.problemReporter().nullityMismatchingTypeAnnotation(argument, argument.resolvedType, expectedType, annotationStatus);
+	} else if (annotationStatus.isUnchecked()) {
 		flowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);
 	}
 }
@@ -160,11 +178,11 @@ protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, Flow
 		lhsTagBits = var.tagBits & TagBits.AnnotationNullMASK;
 	} else {
 		lhsTagBits = var.type.tagBits & TagBits.AnnotationNullMASK;
-		int severity = findNullTypeAnnotationMismatch(var.type, providedType, nullStatus);
-		if (severity == 2) {
-			currentScope.problemReporter().nullityMismatchingTypeAnnotation(expression, providedType, var.type, severity);
+		NullAnnotationStatus annotationStatus = findNullTypeAnnotationMismatch(var.type, providedType, nullStatus);
+		if (annotationStatus.isDefiniteMismatch()) {
+			currentScope.problemReporter().nullityMismatchingTypeAnnotation(expression, providedType, var.type, annotationStatus);
 			hasReported = true;
-		} else if (severity == 1) {
+		} else if (annotationStatus.isUnchecked()) {
 			flowContext.recordNullityMismatch(currentScope, expression, providedType, var.type, nullStatus);
 			hasReported = true;
 		}
@@ -178,10 +196,10 @@ protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, Flow
 	}
 	return nullStatus;
 }
-// return: severity: 0 = no problem; 1 = unchecked conversion wrt type detail; 2 = conflicting annotations
 // nullStatus: we are only interested in NULL or NON_NULL, -1 indicates that we are in a recursion, where flow info is ignored
-protected static int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {
+protected static NullAnnotationStatus findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {
 	int severity = 0;
+	TypeBinding superTypeHint = null;
 	if (requiredType instanceof ArrayBinding) {
 		long[] requiredDimsTagBits = ((ArrayBinding)requiredType).nullTagBitsPerDimension;
 		if (requiredDimsTagBits != null) {
@@ -198,12 +216,12 @@ protected static int findNullTypeAnnotationMismatch(TypeBinding requiredType, Ty
 							nullStatus = -1; // don't use beyond the outermost dimension
 						severity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, nullStatus));
 						if (severity == 2)
-							return severity;
+							return NULL_ANNOTATIONS_MISMATCH;
 					}
 				}
 			} else if (providedType.id == TypeIds.T_null) {
 				if (dims > 0 && requiredDimsTagBits[0] == TagBits.AnnotationNonNull)
-					return 2;
+					return NULL_ANNOTATIONS_MISMATCH;
 			}
 		}
 	} else if (requiredType.hasNullTypeAnnotations() || providedType.hasNullTypeAnnotations()) {
@@ -215,26 +233,35 @@ protected static int findNullTypeAnnotationMismatch(TypeBinding requiredType, Ty
 			severity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus);
 		}
 		if (severity < 2) {
-			if (requiredType.isParameterizedType()  && providedType.isParameterizedType()) { // TODO(stephan): handle providedType.isRaw()
+			TypeBinding providedSuper = providedType.findSuperTypeOriginatingFrom(requiredType);
+			if (providedSuper != providedType)
+				superTypeHint = providedSuper;
+			if (requiredType.isParameterizedType()  && providedSuper instanceof ParameterizedTypeBinding) { // TODO(stephan): handle providedType.isRaw()
 				TypeBinding[] requiredArguments = ((ParameterizedTypeBinding) requiredType).arguments;
-				TypeBinding[] providedArguments = ((ParameterizedTypeBinding) providedType).arguments;
+				TypeBinding[] providedArguments = ((ParameterizedTypeBinding) providedSuper).arguments;
 				if (requiredArguments != null && providedArguments != null && requiredArguments.length == providedArguments.length) {
 					for (int i = 0; i < requiredArguments.length; i++) {
-						severity = Math.max(severity, findNullTypeAnnotationMismatch(requiredArguments[i], providedArguments[i], -1));
+						NullAnnotationStatus status = findNullTypeAnnotationMismatch(requiredArguments[i], providedArguments[i], -1);
+						severity = Math.max(severity, status.severity);
 						if (severity == 2)
-							return severity;
+							return new NullAnnotationStatus(severity, superTypeHint);
 					}
 				}
 			} else 	if (requiredType instanceof WildcardBinding) {
-				severity = Math.max(severity, findNullTypeAnnotationMismatch(((WildcardBinding) requiredType).bound, providedType, nullStatus));
+				NullAnnotationStatus status = findNullTypeAnnotationMismatch(((WildcardBinding) requiredType).bound, providedType, nullStatus);
+				severity = Math.max(severity, status.severity);
 			}
 			TypeBinding requiredEnclosing = requiredType.enclosingType();
 			TypeBinding providedEnclosing = providedType.enclosingType();
-			if (requiredEnclosing != null && providedEnclosing != null)
-				severity = Math.max(severity, findNullTypeAnnotationMismatch(requiredEnclosing, providedEnclosing, -1));
+			if (requiredEnclosing != null && providedEnclosing != null) {
+				NullAnnotationStatus status = findNullTypeAnnotationMismatch(requiredEnclosing, providedEnclosing, -1);
+				severity = Math.max(severity, status.severity);
+			}
 		}
 	}
-	return severity;
+	if (severity == 0)
+		return NULL_ANNOTATIONS_OK;
+	return new NullAnnotationStatus(severity, superTypeHint);
 }
 static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus) {
 	if (requiredBits != 0 && requiredBits != providedBits) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 483b3e9..b012672 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -24,6 +24,7 @@
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 416183 - [1.8][compiler][null] Overload resolution fails with null annotations
+ *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1055,7 +1056,7 @@ public TypeBinding copyAnnotations(TypeBinding annotatedType, TypeBinding unanno
 		if (annotatedEnclosing != null && annotatedEnclosing.hasNullTypeAnnotations())
 			newEnclosing = (ReferenceBinding) copyAnnotations(annotatedEnclosing, newEnclosing);
 		long nullTagBits = annotatedType.tagBits & TagBits.AnnotationNullMASK;
-		return createParameterizedType((ReferenceBinding)unannotatedSubstite, newArguments, nullTagBits, newEnclosing);
+		return createParameterizedType((ReferenceBinding)unannotatedSubstite.original(), newArguments, nullTagBits, newEnclosing);
 
 	} else if (annotatedType instanceof ArrayBinding && unannotatedSubstite instanceof ArrayBinding) {
 		long[] tagBitsOnDimensions = ((ArrayBinding) annotatedType).nullTagBitsPerDimension;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 0aea7d5..db54336 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -44,6 +44,7 @@
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
  *								Bug 414380 - [compiler][internal] QualifiedNameReference#indexOfFirstFieldBinding does not point to the first field
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
+ *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -375,6 +376,7 @@ public static int getIrritant(int problemID) {
 		case IProblem.ConflictingNullAnnotations:
 		case IProblem.ConflictingInheritedNullAnnotations:
 		case IProblem.NullityMismatchingTypeAnnotation:
+		case IProblem.NullityMismatchingTypeAnnotationSuperHint:
 		case IProblem.NullityMismatchTypeArgument:
 		case IProblem.UninitializedNonNullField:
 		case IProblem.UninitializedNonNullFieldHintMissingDefault:
@@ -389,6 +391,7 @@ public static int getIrritant(int problemID) {
 			return CompilerOptions.NullAnnotationInferenceConflict;
 		case IProblem.RequiredNonNullButProvidedUnknown:
 		case IProblem.NullityUncheckedTypeAnnotationDetail:
+		case IProblem.NullityUncheckedTypeAnnotationDetailSuperHint:
 		case IProblem.ReferenceExpressionParameterRequiredNonnullUnchecked:
 		case IProblem.ReferenceExpressionReturnNullRedefUnchecked:
 		case IProblem.UnsafeNullnessCast:
@@ -8901,7 +8904,7 @@ public void nullityMismatch(Expression expression, TypeBinding providedType, Typ
 	if (this.options.sourceLevel < ClassFileConstants.JDK1_8)
 		nullityMismatchIsUnknown(expression, providedType, requiredType, annotationName);
 	else
-		nullityMismatchingTypeAnnotation(expression, providedType, requiredType, 1/*unchecked*/);
+		nullityMismatchingTypeAnnotation(expression, providedType, requiredType, Statement.NULL_ANNOTATIONS_UNCHECKED);
 }
 public void nullityMismatchIsNull(Expression expression, TypeBinding requiredType) {
 	int problemId = IProblem.RequiredNonNullButProvidedNull;
@@ -9419,24 +9422,34 @@ public void arrayReferencePotentialNullReference(ArrayReference arrayReference)
 	this.handle(IProblem.ArrayReferencePotentialNullReference, NoArgument, NoArgument, arrayReference.sourceStart, arrayReference.sourceEnd);
 	
 }
-public void nullityMismatchingTypeAnnotation(Expression expression, TypeBinding providedType, TypeBinding requiredType, int severity) 
+public void nullityMismatchingTypeAnnotation(Expression expression, TypeBinding providedType, TypeBinding requiredType, Statement.NullAnnotationStatus status) 
 {
 	if (providedType.id == TypeIds.T_null) {
 		nullityMismatchIsNull(expression, requiredType);
 		return;
 	}
-	String[] arguments = new String[] {
-		String.valueOf(requiredType.nullAnnotatedReadableName(this.options, false)),
-		String.valueOf(providedType.nullAnnotatedReadableName(this.options, false))
-	};
-	String[] shortArguments = new String[] {
-		String.valueOf(requiredType.nullAnnotatedReadableName(this.options, true)),
-		String.valueOf(providedType.nullAnnotatedReadableName(this.options, true))
-	};
-	int problemId = severity == 1 ? IProblem.NullityUncheckedTypeAnnotationDetail : IProblem.NullityMismatchingTypeAnnotation;			
-	this.handle(
-			problemId,
-			arguments, shortArguments, expression.sourceStart, expression.sourceEnd);
+	String[] arguments ;
+	String[] shortArguments;
+		
+	int problemId = 0;
+	if (status.superTypeHint != null) {
+		problemId = (status.isUnchecked()
+			? IProblem.NullityUncheckedTypeAnnotationDetailSuperHint
+			: IProblem.NullityMismatchingTypeAnnotationSuperHint);
+		arguments      = new String[] { null, null, status.superTypeHintName(this.options, false) };
+		shortArguments = new String[] { null, null, status.superTypeHintName(this.options, true) };
+	} else {
+		problemId = (status.isUnchecked()
+			? IProblem.NullityUncheckedTypeAnnotationDetail
+			: IProblem.NullityMismatchingTypeAnnotation);
+		arguments      = new String[2];
+		shortArguments = new String[2];
+	}
+	arguments[0] = String.valueOf(requiredType.nullAnnotatedReadableName(this.options, false));
+	arguments[1] = String.valueOf(providedType.nullAnnotatedReadableName(this.options, false));
+	shortArguments[0] = String.valueOf(requiredType.nullAnnotatedReadableName(this.options, true));
+	shortArguments[1] = String.valueOf(providedType.nullAnnotatedReadableName(this.options, true));
+	this.handle(problemId, arguments, shortArguments, expression.sourceStart, expression.sourceEnd);
 }
 
 public void nullityMismatchTypeArgument(TypeBinding typeVariable, TypeBinding typeArgument, ASTNode location) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 21a55f6..16b5ede 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -35,6 +35,7 @@
 #							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
 #							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
 #							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
+#							Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
 #		Jesper S Moller <jesper@selskabet.org> - Contributions for
 #							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
 #							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
@@ -780,17 +781,19 @@
 951 = Potential null pointer access: array element may be null
 952 = Potential null pointer access: this expression has a ''@{0}'' type
 953 = Null type mismatch (type annotations): required ''{0}'' but this expression has type ''{1}''
-954 = Null type safety (type annotations): The expression of type ''{1}'' needs unchecked conversion to conform to ''{0}''
-955 = Null type mismatch at parameter {0}: required ''{1}{2}'' but provided ''@{3} {4}'' via method descriptor {5}
-956 = Null type safety: parameter {0} provided via method descriptor {1} needs unchecked conversion to conform to ''@{2} {3}''
-957 = Null type mismatch at method return type: Method descriptor {0} promises ''@{1} {2}'' but referenced method provides ''{3}{4}''
-958 = Null type safety at method return type: Method descriptor {0} promises ''@{1} {2}'' but referenced method provides ''{3}{4}''
-959 = Redundant null check: comparing ''{0}'' against null
-960 = The nullness annotation ''{0}'' is not applicable at this location
-961 = Nullness annotations are not applicable at this location 
-962 = Null constraint mismatch: The type ''{2}'' is not a valid substitute for the type parameter ''{0}'' which is constrained as ''@{1}''
-963 = This nullness annotation conflicts with a ''@{0}'' annotation which is effective on the same type parameter 
-964 = Null type safety: Unchecked cast from {0} to {1}
+954 = Null type mismatch (type annotations): required ''{0}'' but this expression has type ''{1}'', corresponding supertype is ''{2}''
+955 = Null type safety (type annotations): The expression of type ''{1}'' needs unchecked conversion to conform to ''{0}''
+956 = Null type safety (type annotations): The expression of type ''{1}'' needs unchecked conversion to conform to ''{0}'', corresponding supertype is ''{2}''
+957 = Null type mismatch at parameter {0}: required ''{1}{2}'' but provided ''@{3} {4}'' via method descriptor {5}
+958 = Null type safety: parameter {0} provided via method descriptor {1} needs unchecked conversion to conform to ''@{2} {3}''
+959 = Null type mismatch at method return type: Method descriptor {0} promises ''@{1} {2}'' but referenced method provides ''{3}{4}''
+960 = Null type safety at method return type: Method descriptor {0} promises ''@{1} {2}'' but referenced method provides ''{3}{4}''
+961 = Redundant null check: comparing ''{0}'' against null
+962 = The nullness annotation ''{0}'' is not applicable at this location
+963 = Nullness annotations are not applicable at this location 
+964 = Null constraint mismatch: The type ''{2}'' is not a valid substitute for the type parameter ''{0}'' which is constrained as ''@{1}''
+965 = This nullness annotation conflicts with a ''@{0}'' annotation which is effective on the same type parameter 
+966 = Null type safety: Unchecked cast from {0} to {1}
 
 # Java 8
 1001 = Syntax error, modifiers and annotations are not allowed for the lambda parameter {0} as its type is elided
