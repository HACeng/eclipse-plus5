commit 9221731a3d20320a45d9e6a6337379d8a431c366
Author: Olivier Thomann <oliviert>
Date:   Thu Apr 21 14:43:24 2011 +0000

    HEAD - Fixed bug 342598: Inconsistent handling of error types

-	-	org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
101	50	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java
13	5	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
diff --git a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
index 00baa74..f83509d 100644
Binary files a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar and b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar differ
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java
index 2c1af08..fae5a11 100644
--- a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java
@@ -290,30 +290,42 @@ public class NegativeModelProc extends AbstractProcessor
 		"  <superclass>\n" + 
 		"   <type-mirror kind=\"DECLARED\" to-string=\"java.lang.Object\"/>\n" + 
 		"  </superclass>\n" + 
+		"  <interfaces>\n" + 
+		"   <type-mirror kind=\"ERROR\" to-string=\"RemoteNegative8a\"/>\n" + 
+		"  </interfaces>\n" + 
 		"  <executable-element kind=\"CONSTRUCTOR\" sname=\"&lt;init&gt;\"/>\n" + 
 		" </type-element>\n" + 
 		" <type-element kind=\"INTERFACE\" qname=\"targets.negative.pa.Negative8b\" sname=\"Negative8b\">\n" + 
 		"  <superclass>\n" + 
 		"   <type-mirror kind=\"NONE\" to-string=\"&lt;none&gt;\"/>\n" + 
 		"  </superclass>\n" + 
+		"  <interfaces>\n" + 
+		"   <type-mirror kind=\"ERROR\" to-string=\"RemoteNegative8a\"/>\n" + 
+		"  </interfaces>\n" + 
 		" </type-element>\n" + 
 		" <type-element kind=\"CLASS\" qname=\"targets.negative.pa.Negative8c\" sname=\"Negative8c\">\n" + 
 		"  <superclass>\n" + 
 		"   <type-mirror kind=\"DECLARED\" to-string=\"java.lang.Object\"/>\n" + 
 		"  </superclass>\n" + 
+		"  <interfaces>\n" + 
+		"   <type-mirror kind=\"ERROR\" to-string=\"RemoteNegative8b&lt;T&gt;\"/>\n" + 
+		"  </interfaces>\n" + 
 		"  <executable-element kind=\"CONSTRUCTOR\" sname=\"&lt;init&gt;\"/>\n" + 
 		" </type-element>\n" + 
 		" <type-element kind=\"INTERFACE\" qname=\"targets.negative.pa.Negative8d\" sname=\"Negative8d\">\n" + 
 		"  <superclass>\n" + 
 		"   <type-mirror kind=\"NONE\" to-string=\"&lt;none&gt;\"/>\n" + 
 		"  </superclass>\n" + 
+		"  <interfaces>\n" + 
+		"   <type-mirror kind=\"ERROR\" to-string=\"RemoteNegative8b&lt;T&gt;\"/>\n" + 
+		"  </interfaces>\n" + 
 		" </type-element>\n" + 
 		" <type-element kind=\"INTERFACE\" qname=\"targets.negative.pa.Negative8e\" sname=\"Negative8e\">\n" + 
 		"  <superclass>\n" + 
 		"   <type-mirror kind=\"NONE\" to-string=\"&lt;none&gt;\"/>\n" + 
 		"  </superclass>\n" + 
 		"  <interfaces>\n" + 
-		"   <type-mirror kind=\"DECLARED\" to-string=\"targets.negative.pa.Negative8f&lt;T&gt;\"/>\n" + 
+		"   <type-mirror kind=\"ERROR\" to-string=\"targets.negative.pa.Negative8f&lt;T&gt;\"/>\n" + 
 		"  </interfaces>\n" + 
 		" </type-element>\n" + 
 		" <type-element kind=\"INTERFACE\" qname=\"targets.negative.pa.Negative8f\" sname=\"Negative8f\">\n" + 
@@ -322,7 +334,47 @@ public class NegativeModelProc extends AbstractProcessor
 		"  </superclass>\n" + 
 		" </type-element>\n" + 
 		"</model>\n";
-	
+
+	/*
+	 * Reference model for class Negative8.
+	 */
+	private static final String NEGATIVE_8_MODEL_VERSION6 = 
+		"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n" + 
+		"<model>\n" + 
+		" <type-element kind=\"CLASS\" qname=\"targets.negative.pa.Negative8a\" sname=\"Negative8a\">\n" + 
+		"  <superclass>\n" + 
+		"   <type-mirror kind=\"DECLARED\" to-string=\"java.lang.Object\"/>\n" + 
+		"  </superclass>\n" + 
+		"  <executable-element kind=\"CONSTRUCTOR\" sname=\"&lt;init&gt;\"/>\n" + 
+		" </type-element>\n" + 
+		" <type-element kind=\"INTERFACE\" qname=\"targets.negative.pa.Negative8b\" sname=\"Negative8b\">\n" + 
+		"  <superclass>\n" + 
+		"   <type-mirror kind=\"NONE\" to-string=\"&lt;none&gt;\"/>\n" + 
+		"  </superclass>\n" + 
+		" </type-element>\n" + 
+		" <type-element kind=\"CLASS\" qname=\"targets.negative.pa.Negative8c\" sname=\"Negative8c\">\n" + 
+		"  <superclass>\n" + 
+		"   <type-mirror kind=\"DECLARED\" to-string=\"java.lang.Object\"/>\n" + 
+		"  </superclass>\n" + 
+		"  <executable-element kind=\"CONSTRUCTOR\" sname=\"&lt;init&gt;\"/>\n" + 
+		" </type-element>\n" + 
+		" <type-element kind=\"INTERFACE\" qname=\"targets.negative.pa.Negative8d\" sname=\"Negative8d\">\n" + 
+		"  <superclass>\n" + 
+		"   <type-mirror kind=\"NONE\" to-string=\"&lt;none&gt;\"/>\n" + 
+		"  </superclass>\n" + 
+		" </type-element>\n" + 
+		" <type-element kind=\"INTERFACE\" qname=\"targets.negative.pa.Negative8e\" sname=\"Negative8e\">\n" + 
+		"  <superclass>\n" + 
+		"   <type-mirror kind=\"NONE\" to-string=\"&lt;none&gt;\"/>\n" + 
+		"  </superclass>\n" + 
+		" </type-element>\n" + 
+		" <type-element kind=\"INTERFACE\" qname=\"targets.negative.pa.Negative8f\" sname=\"Negative8f\">\n" + 
+		"  <superclass>\n" + 
+		"   <type-mirror kind=\"NONE\" to-string=\"&lt;none&gt;\"/>\n" + 
+		"  </superclass>\n" + 
+		" </type-element>\n" + 
+		"</model>\n";
+
 	/**
 	 * Reference model for types in Negative1 test
 	 */
@@ -339,11 +391,29 @@ public class NegativeModelProc extends AbstractProcessor
 		"   <type-mirror kind=\"NONE\" to-string=\"&lt;none&gt;\"/>\n" + 
 		"  </superclass>\n" + 
 		"  <interfaces>\n" + 
-		"   <type-mirror kind=\"DECLARED\" to-string=\"targets.negative.pa.Negative9a&lt;T&gt;\"/>\n" + 
+		"   <type-mirror kind=\"ERROR\" to-string=\"targets.negative.pa.Negative9a&lt;T&gt;\"/>\n" + 
 		"  </interfaces>\n" + 
 		" </type-element>\n" + 
 		"</model>\n";
-
+	
+	/**
+	 * Reference model for types in Negative1 test
+	 */
+	private static final String NEGATIVE_9_MODEL_VERSION6 = 
+		"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n" + 
+		"<model>\n" + 
+		" <type-element kind=\"INTERFACE\" qname=\"targets.negative.pa.Negative9a\" sname=\"Negative9a\">\n" + 
+		"  <superclass>\n" + 
+		"   <type-mirror kind=\"NONE\" to-string=\"&lt;none&gt;\"/>\n" + 
+		"  </superclass>\n" + 
+		" </type-element>\n" + 
+		" <type-element kind=\"INTERFACE\" qname=\"targets.negative.pa.Negative9b\" sname=\"Negative9b\">\n" + 
+		"  <superclass>\n" + 
+		"   <type-mirror kind=\"NONE\" to-string=\"&lt;none&gt;\"/>\n" + 
+		"  </superclass>\n" + 
+		" </type-element>\n" + 
+		"</model>\n";
+	
 	/**
 	 * Declare this option (-AignoreJavacBugs) to ignore failures of cases that are
 	 * known to fail under javac, i.e., known bugs in javac.
@@ -702,24 +772,14 @@ public class NegativeModelProc extends AbstractProcessor
 			}
 			rootElements.add(element);
 		}
-		if (!checkModel(rootElements, NEGATIVE_8_MODEL, "Negative8")) {
-			return false;
-		}
-		// check that specific elements are not here
-		suffixes = new String[] {"a", "b", "c", "d"};
-		boolean result = true;
-		String errorMessage = "";
-		for (int i = 0, l = suffixes.length; i < l; i++) {
-			TypeElement element = _elementUtils.getTypeElement("targets.negative.pa.Negative8" + suffixes[i]);
-			if (! element.getInterfaces().isEmpty()) {
-				errorMessage += "Element Negative8" + suffixes[i] + " has extraneous interfaces\n";
-				result = false;
+		if (this.processingEnv.getSourceVersion() == SourceVersion.RELEASE_6) {
+			if (!checkModel(rootElements, NEGATIVE_8_MODEL_VERSION6, "Negative8")) {
+				return false;
 			}
+		} else if (!checkModel(rootElements, NEGATIVE_8_MODEL, "Negative8")) {
+			return false;
 		}
-		if (!result) {
-			reportError(errorMessage);
-		}
-		return result;
+		return true;
 	}
 	/**
 	 * Check the model of resources/targets.negative.pa.Negative9
@@ -737,41 +797,32 @@ public class NegativeModelProc extends AbstractProcessor
 			}
 			rootElements.add(element);
 		}
-		if (!checkModel(rootElements, NEGATIVE_9_MODEL, "Negative9")) {
-			return false;
-		}
-		// check that specific elements are not here
-		suffixes = new String[] { "b" };
-		boolean result = true;
-		String errorMessage = "";
-		for (int i = 0, l = suffixes.length; i < l; i++) {
-			TypeElement element = _elementUtils.getTypeElement("targets.negative.pa.Negative9" + suffixes[i]);
-			List<? extends TypeMirror> interfaces = element.getInterfaces();
-			if (interfaces.isEmpty()) {
-				errorMessage += "Element Negative9" + suffixes[i] + " has extraneous interfaces\n";
-				result = false;
+		if (this.processingEnv.getSourceVersion() == SourceVersion.RELEASE_6) {
+			if (!checkModel(rootElements, NEGATIVE_9_MODEL_VERSION6, "Negative9")) {
+				return false;
+			}
+			return true;
+		} else {
+			if (!checkModel(rootElements, NEGATIVE_9_MODEL, "Negative9")) {
+				return false;
 			}
-			for (TypeMirror typeMirror : interfaces) {
-				TypeKind kind = typeMirror.getKind();
-				if (kind != TypeKind.DECLARED) {
-					errorMessage += "Element Negative9" + suffixes[i] + " super interface is not a declared type: " + kind + " \n";
+			// check that specific elements are not here
+			suffixes = new String[] { "b" };
+			boolean result = true;
+			String errorMessage = "";
+			for (int i = 0, l = suffixes.length; i < l; i++) {
+				TypeElement element = _elementUtils.getTypeElement("targets.negative.pa.Negative9" + suffixes[i]);
+				List<? extends TypeMirror> interfaces = element.getInterfaces();
+				if (interfaces.isEmpty()) {
+					errorMessage += "Element Negative9" + suffixes[i] + " has missing interfaces\n";
 					result = false;
 				}
-				DeclaredType type = (DeclaredType) typeMirror;
-				List<? extends TypeMirror> typeArguments = type.getTypeArguments();
-				for (TypeMirror typeMirror2 : typeArguments) {
-					kind = typeMirror2.getKind();
-					if (kind != TypeKind.ERROR) {
-						errorMessage += "Element Negative9" + suffixes[i] + " superinterface's type argument is not an error type: " + kind + " \n";
-						result = false;
-					}
-				}
 			}
+			if (!result) {
+				reportError(errorMessage);
+			}
+			return result;
 		}
-		if (!result) {
-			reportError(errorMessage);
-		}
-		return result;
 	}
 	/**
 	 * Compare a set of elements to a reference model, and output error information if there is a
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
index 6595f70..0c9c019 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
@@ -27,6 +27,7 @@ import org.eclipse.jdt.internal.compiler.Compiler;
 import org.eclipse.jdt.internal.compiler.apt.model.ElementsImpl;
 import org.eclipse.jdt.internal.compiler.apt.model.Factory;
 import org.eclipse.jdt.internal.compiler.apt.model.TypesImpl;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
@@ -116,11 +117,18 @@ public abstract class BaseProcessingEnvImpl implements ProcessingEnvironment {
 
 	@Override
 	public SourceVersion getSourceVersion() {
-		// As of this writing, RELEASE_6 is the highest level available.
-		// It is also the lowest level for which this code can possibly
-		// be called.  When Java 7 is released, this method will need to
-		// return a value based on _compiler.options.sourceLevel.
-		return SourceVersion.RELEASE_6;
+		if (this._compiler.options.sourceLevel <= ClassFileConstants.JDK1_5) {
+			return SourceVersion.RELEASE_5;
+		}
+		if (this._compiler.options.sourceLevel == ClassFileConstants.JDK1_6) {
+			return SourceVersion.RELEASE_6;
+		}
+		try {
+			return SourceVersion.valueOf("RELEASE_7"); //$NON-NLS-1$
+		} catch(IllegalArgumentException e) {
+			// handle call on a JDK 6
+			return SourceVersion.RELEASE_6;
+		}
 	}
 
 	/**
commit 730caa252c0447802cd9dbe163cdf0f853f36524
Author: Olivier Thomann <oliviert>
Date:   Thu Apr 21 14:47:23 2011 +0000

    HEAD - Fixed bug 342598: Inconsistent handling of error types

-	-	org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
2	2	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java
2	6	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
2	7	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
5	10	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/DeclaredTypeImpl.java
17	7	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
31	8	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
2	2	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
12	45	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
10	16	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeElementImpl.java
10	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
5	12	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeVariableImpl.java
31	28	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
2	7	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/WildcardTypeImpl.java
diff --git a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
index f83509d..874d975 100644
Binary files a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar and b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar differ
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java
index fae5a11..b0349e1 100644
--- a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/negative/NegativeModelProc.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2009 BEA Systems, Inc.
+ * Copyright (c) 2007, 2011 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,8 +7,8 @@
  *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
+ *    IBM Corporation - fix for 342598
  *******************************************************************************/
-
 package org.eclipse.jdt.compiler.apt.tests.processors.negative;
 
 import java.io.ByteArrayOutputStream;
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
index 6a38940..ad297f0 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2010 IBM Corporation and others.
+ * Copyright (c) 2005, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -93,11 +93,7 @@ public class AnnotationMirrorImpl implements AnnotationMirror, InvocationHandler
 	}
 
 	public DeclaredType getAnnotationType() {
-		if (this._binding == null) {
-			return _env.getFactory().getErrorType();
-		}
-		ReferenceBinding annoType = _binding.getAnnotationType();
-		return _env.getFactory().newAnnotationType(annoType);
+		return (DeclaredType) _env.getFactory().newTypeMirror(_binding.getAnnotationType());
 	}
 	
 	/**
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
index 66f17a7..0a4cf69 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2009 BEA Systems, Inc. 
+ * Copyright (c) 2007, 2011 BEA Systems, Inc. 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,7 @@
  *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
- *    
+ *    IBM Corporation - fix for 342598
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
@@ -19,7 +19,6 @@ import javax.lang.model.type.TypeVisitor;
 
 import org.eclipse.jdt.internal.compiler.apt.dispatch.BaseProcessingEnvImpl;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
-import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 
 /**
  * Implementation of ArrayType, which represents an array of some type.
@@ -51,10 +50,6 @@ public class ArrayTypeImpl extends TypeMirrorImpl implements ArrayType {
 	 */
 	@Override
 	public TypeKind getKind() {
-		ArrayBinding type = (ArrayBinding)_binding;
-		if (!type.isValidBinding() || ((type.leafComponentType().tagBits & TagBits.HasMissingType) != 0)) {
-			return TypeKind.ERROR;
-		}
 		return TypeKind.ARRAY;
 	}
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/DeclaredTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/DeclaredTypeImpl.java
index b7862c4..95c6103 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/DeclaredTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/DeclaredTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2009 BEA Systems, Inc. 
+ * Copyright (c) 2006, 2011 BEA Systems, Inc. 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,7 @@
  *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
- *    
+ *    IBM Corporation - fix for 342598
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
@@ -64,7 +64,9 @@ public class DeclaredTypeImpl extends TypeMirrorImpl implements DeclaredType {
 	public TypeMirror getEnclosingType() {
 		ReferenceBinding binding = (ReferenceBinding)_binding;
 		ReferenceBinding enclosingType = binding.enclosingType();
-		if (enclosingType != null) return _env.getFactory().newDeclaredType(enclosingType);
+		if (enclosingType != null) {
+			return _env.getFactory().newTypeMirror(enclosingType);
+		}
 		return _env.getFactory().getNoType(TypeKind.NONE);
 	}
 
@@ -108,13 +110,6 @@ public class DeclaredTypeImpl extends TypeMirrorImpl implements DeclaredType {
 
 	@Override
 	public TypeKind getKind() {
-		// Binding.isValidBinding() will return true for a parameterized or array type whose raw
-		// or member type is unresolved.  So we need to be a little more sensitive, so that we
-		// can report Zork<Quux> or Zork[] as error types.
-		ReferenceBinding type = (ReferenceBinding)_binding;
-		if (!type.isValidBinding()) {
-			return TypeKind.ERROR;
-		}
 		return TypeKind.DECLARED;
 	}
 
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
index f44ed74..3eccbf9 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2008 IBM Corporation and others.
+ * Copyright (c) 2007, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -26,16 +26,17 @@ import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 
+import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.apt.dispatch.BaseProcessingEnvImpl;
-import org.eclipse.jdt.internal.compiler.util.Util;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 
 /**
  * Element corresponding to the Error type mirror
  */
 public class ErrorTypeElement extends TypeElementImpl {
 	
-	ErrorTypeElement(BaseProcessingEnvImpl env) {
-		super(env, null, null);
+	ErrorTypeElement(BaseProcessingEnvImpl env, ReferenceBinding binding) {
+		super(env, binding, null);
 	}
 	/* (non-Javadoc)
 	 * @see javax.lang.model.element.TypeElement#getInterfaces()
@@ -58,7 +59,15 @@ public class ErrorTypeElement extends TypeElementImpl {
 	 */
 	@Override
 	public Name getQualifiedName() {
-		return new NameImpl(Util.EMPTY_STRING);
+		ReferenceBinding binding = (ReferenceBinding)_binding;
+		char[] qName;
+		if (binding.isMemberType()) {
+			qName = CharOperation.concatWith(binding.enclosingType().compoundName, binding.sourceName, '.');
+			CharOperation.replace(qName, '$', '.');
+		} else {
+			qName = CharOperation.concatWith(binding.compoundName, '.');
+		}
+		return new NameImpl(qName);
 	}
 
 	/* (non-Javadoc)
@@ -82,7 +91,7 @@ public class ErrorTypeElement extends TypeElementImpl {
 	 */
 	@Override
 	public TypeMirror asType() {
-		return this._env.getFactory().getErrorType();
+		return this._env.getFactory().getErrorType((ReferenceBinding) this._binding);
 	}
 
 	/* (non-Javadoc)
@@ -138,6 +147,7 @@ public class ErrorTypeElement extends TypeElementImpl {
 	 */
 	@Override
 	public Name getSimpleName() {
-		return new NameImpl(Util.EMPTY_STRING);
+		ReferenceBinding binding = (ReferenceBinding)_binding;
+		return new NameImpl(binding.sourceName());
 	}
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
index acd75c0..6b826b7 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 IBM Corporation and others.
+ * Copyright (c) 2007, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.apt.model;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
@@ -20,14 +21,18 @@ import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVisitor;
 
 import org.eclipse.jdt.internal.compiler.apt.dispatch.BaseProcessingEnvImpl;
+import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 
 /**
  * Implementation of the {@link ErrorType} interface.
  */
 public class ErrorTypeImpl extends DeclaredTypeImpl implements ErrorType {
 
-	/* package */ ErrorTypeImpl(BaseProcessingEnvImpl env) {
-		super(env, null);
+	/* package */ ErrorTypeImpl(BaseProcessingEnvImpl env, ReferenceBinding binding) {
+		super(env, binding);
 	}
 
 	/* (non-Javadoc)
@@ -35,7 +40,7 @@ public class ErrorTypeImpl extends DeclaredTypeImpl implements ErrorType {
 	 */
 	@Override
 	public Element asElement() {
-		return this._env.getFactory().newElement(null);
+		return this._env.getFactory().newElement((ReferenceBinding) this._binding);
 	}
 
 	/* (non-Javadoc)
@@ -46,14 +51,32 @@ public class ErrorTypeImpl extends DeclaredTypeImpl implements ErrorType {
 		return NoTypeImpl.NO_TYPE_NONE;
 	}
 
-	/* (non-Javadoc)
-	 * @see javax.lang.model.type.DeclaredType#getTypeArguments()
-	 */
 	@Override
 	public List<? extends TypeMirror> getTypeArguments() {
+		ReferenceBinding binding = (ReferenceBinding)_binding;
+		if (binding.isParameterizedType()) {
+			ParameterizedTypeBinding ptb = (ParameterizedTypeBinding)_binding;
+			TypeBinding[] arguments = ptb.arguments;
+			int length = arguments == null ? 0 : arguments.length;
+			if (length == 0) return Collections.emptyList();
+			List<TypeMirror> args = new ArrayList<TypeMirror>(length);
+			for (TypeBinding arg : arguments) {
+				args.add(_env.getFactory().newTypeMirror(arg));
+			}
+			return Collections.unmodifiableList(args);
+		}
+		if (binding.isGenericType()) {
+			TypeVariableBinding[] typeVariables = binding.typeVariables();
+			List<TypeMirror> args = new ArrayList<TypeMirror>(typeVariables.length);
+			for (TypeBinding arg : typeVariables) {
+				args.add(_env.getFactory().newTypeMirror(arg));
+			}
+			return Collections.unmodifiableList(args);
+		}
 		return Collections.emptyList();
 	}
 
+
 	/* (non-Javadoc)
 	 * @see javax.lang.model.type.TypeMirror#accept(javax.lang.model.type.TypeVisitor, java.lang.Object)
 	 */
@@ -72,6 +95,6 @@ public class ErrorTypeImpl extends DeclaredTypeImpl implements ErrorType {
 	
 	@Override
 	public String toString() {
-		return "<any>"; //$NON-NLS-1$
+		return new String(_binding.readableName());
 	}
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
index e9d1cdc..3681abe 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2007 IBM Corporation and others.
+ * Copyright (c) 2006, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -34,7 +34,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
  */
 public class ExecutableTypeImpl extends TypeMirrorImpl implements ExecutableType {
 	
-	public ExecutableTypeImpl(BaseProcessingEnvImpl env, MethodBinding binding) {
+	ExecutableTypeImpl(BaseProcessingEnvImpl env, MethodBinding binding) {
 		super(env, binding);
 	}
 	/* (non-Javadoc)
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
index 5bf3484..aa8264d 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2008 BEA Systems, Inc. 
+ * Copyright (c) 2007, 2011 BEA Systems, Inc. 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,7 @@
  *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
- *    
+ *    IBM Corporation - fix for 342598
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
@@ -25,7 +25,6 @@ import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeParameterElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.NoType;
 import javax.lang.model.type.NullType;
@@ -42,6 +41,7 @@ import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
@@ -247,9 +247,6 @@ public class Factory {
 	 * Create a new element that knows what kind it is even if the binding is unresolved.
 	 */
 	public Element newElement(Binding binding, ElementKind kindHint) {
-		if (binding == null) {
-			return new ErrorTypeElement(this._env);
-		}
 		switch (binding.kind()) {
 		case Binding.FIELD:
 		case Binding.LOCAL:
@@ -258,6 +255,9 @@ public class Factory {
 		case Binding.TYPE:
 		case Binding.GENERIC_TYPE:
 			ReferenceBinding referenceBinding = (ReferenceBinding)binding;
+			if ((referenceBinding.tagBits & TagBits.HasMissingType) != 0) {
+				return new ErrorTypeElement(this._env, referenceBinding);
+			}
 			if (referenceBinding.sourceName == TypeConstants.PACKAGE_INFO_NAME) {
 				return new PackageElementImpl(_env, referenceBinding.fPackage);
 			}
@@ -285,36 +285,6 @@ public class Factory {
 	public Element newElement(Binding binding) {
 		return newElement(binding, null);
 	}
-	
-	public DeclaredType newDeclaredType(ReferenceBinding binding) {
-		switch (binding.kind()) {
-			case Binding.WILDCARD_TYPE :
-				// JDT wildcard binding is a subclass of reference binding, but in JSR269 they're siblings
-				throw new IllegalArgumentException("A wildcard binding can't be turned into a DeclaredType"); //$NON-NLS-1$
-			case Binding.INTERSECTION_TYPE :
-				// JDT intersection binding is a subclass of reference binding, but in JSR269 they're siblings
-				throw new IllegalArgumentException("An intersection binding can't be turned into a DeclaredType"); //$NON-NLS-1$
-		}
-		return new DeclaredTypeImpl(_env, binding);
-	}
-
-	/**
-	 * When an annotation is of unresolved type, its binding won't know that it's an annotation type,
-	 * so later on if the caller tries to get the type asElement(), and then asks for the ElementKind,
-	 * they'll get back CLASS rather than ANNOTATION_TYPE.  If we know from context that the binding
-	 * is to an annotation type, calling this method allows us to hint to the underlying TypeElementImpl. 
-	 */
-	public DeclaredType newAnnotationType(ReferenceBinding binding) {
-		switch (binding.kind()) {
-			case Binding.WILDCARD_TYPE :
-				// JDT wildcard binding is a subclass of reference binding, but in JSR269 they're siblings
-				throw new IllegalArgumentException("A wildcard binding can't be turned into a DeclaredType"); //$NON-NLS-1$
-			case Binding.INTERSECTION_TYPE :
-				// JDT intersection binding is a subclass of reference binding, but in JSR269 they're siblings
-				throw new IllegalArgumentException("An intersection binding can't be turned into a DeclaredType"); //$NON-NLS-1$
-		}
-		return new DeclaredTypeImpl(_env, binding, ElementKind.ANNOTATION_TYPE);
-	}
 
 	/**
 	 * Convenience method - equivalent to {@code (PackageElement)Factory.newElement(binding)}
@@ -369,13 +339,6 @@ public class Factory {
 			throw new IllegalStateException();
 		}
 	}
-	
-	/**
-	 * Convenience method to get the PrimitiveTypeImpl corresponding to a particular BaseTypeBinding.
-	 */
-	public PrimitiveTypeImpl getPrimitiveType(BaseTypeBinding binding) {
-		return getPrimitiveType(PrimitiveTypeImpl.getKind(binding));
-	}
 
 	/**
 	 * Given a binding of uncertain type, try to create the right sort of TypeMirror for it.
@@ -401,6 +364,10 @@ public class Factory {
 		case Binding.RAW_TYPE:
 		case Binding.GENERIC_TYPE:
 		case Binding.PARAMETERIZED_TYPE:
+			ReferenceBinding referenceBinding = (ReferenceBinding) binding;
+			if ((referenceBinding.tagBits & TagBits.HasMissingType) != 0) {
+				return getErrorType(referenceBinding);
+			}
 			return new DeclaredTypeImpl(_env, (ReferenceBinding)binding);
 			
 		case Binding.ARRAY_TYPE:
@@ -435,8 +402,8 @@ public class Factory {
 		return new TypeParameterElementImpl(_env, variable, declaringElement);
 	}
 
-    public ErrorType getErrorType() {
-		return new ErrorTypeImpl(this._env);
+    public ErrorType getErrorType(ReferenceBinding binding) {
+		return new ErrorTypeImpl(this._env, binding);
 	}
 
 	/**
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeElementImpl.java
index 0ed3725..5d5e966 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeElementImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2008 IBM Corporation and others.
+ * Copyright (c) 2005, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,6 +15,7 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
+import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ElementVisitor;
@@ -35,9 +36,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
-import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
-import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 
@@ -118,18 +117,13 @@ public class TypeElementImpl extends ElementImpl implements TypeElement {
 		}
 		List<TypeMirror> interfaces = new ArrayList<TypeMirror>(binding.superInterfaces().length);
 		for (ReferenceBinding interfaceBinding : binding.superInterfaces()) {
-			// JSR269 spec requires us to return unresolved superinterfaces, but javac has
-			// a bug in this regard; as of 5/08 we emulate javac, rather than follow the spec.
-			// See https://bugs.eclipse.org/bugs/show_bug.cgi?id=231521
-			if (interfaceBinding.isValidBinding() &&
-				// using binding types...
-					!(interfaceBinding instanceof MissingTypeBinding) &&
-					!(interfaceBinding instanceof ParameterizedTypeBinding &&
-							((ParameterizedTypeBinding) interfaceBinding).genericType() instanceof MissingTypeBinding)
-				// since HasMissingType reports indirect missing types, which is not what we need
-				/* &&
-					(interfaceBinding.tagBits & TagBits.HasMissingType) == 0 */) {
-				TypeMirror interfaceType = _env.getFactory().newTypeMirror(interfaceBinding);
+			TypeMirror interfaceType = _env.getFactory().newTypeMirror(interfaceBinding);
+			if (interfaceType.getKind() == TypeKind.ERROR) {
+				if (this._env.getSourceVersion().compareTo(SourceVersion.RELEASE_6) > 0) {
+					// for jdk 7 and above, add error types
+					interfaces.add(interfaceType);
+				}
+			} else {
 				interfaces.add(interfaceType);
 			}
 		}
@@ -225,7 +219,7 @@ public class TypeElementImpl extends ElementImpl implements TypeElement {
 			return _env.getFactory().getNoType(TypeKind.NONE);
 		}
 		// superclass of a type must be a DeclaredType
-		return _env.getFactory().newDeclaredType(superBinding);
+		return _env.getFactory().newTypeMirror(superBinding);
 	}
 	
 	@Override
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
index 999d5bb..7da7c3a 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
@@ -8,6 +8,7 @@
  * Contributors:
  *    wharley@bea.com - initial API and implementation
  *    IBM Corporation - fix for 342470
+ *    IBM Corporation - fix for 342598
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
@@ -65,9 +66,16 @@ public class TypeParameterElementImpl extends ElementImpl implements TypeParamet
 		ReferenceBinding varSuperclass = typeVariableBinding.superclass();
 		TypeBinding firstClassOrArrayBound = typeVariableBinding.firstBound;
 		int boundsLength = 0;
+		boolean isFirstBoundATypeVariable = false;
 		if (firstClassOrArrayBound != null) {
+			if (firstClassOrArrayBound.isTypeVariable()) {
+				isFirstBoundATypeVariable = true;
+			}
 			if (firstClassOrArrayBound == varSuperclass) {
 				boundsLength++;
+				if (firstClassOrArrayBound.isTypeVariable()) {
+					isFirstBoundATypeVariable = true;
+				}
 			} else if (firstClassOrArrayBound.isArrayType()) { // capture of ? extends/super arrayType
 				boundsLength++;
 			} else {
@@ -89,7 +97,8 @@ public class TypeParameterElementImpl extends ElementImpl implements TypeParamet
 				}
 				typeBounds.add(typeBinding);
 			}
-			if (superinterfaces != null) {
+			// we need to filter out remaining bounds if the first bound is a type variable
+			if (superinterfaces != null && !isFirstBoundATypeVariable) {
 				for (int i = 0; i < superinterfacesLength; i++) {
 					TypeMirror typeBinding = _env.getFactory().newTypeMirror(superinterfaces[i]);
 					if (typeBinding == null) {
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeVariableImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeVariableImpl.java
index f1520cf..59e45cc 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeVariableImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeVariableImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2009 IBM Corporation and others.
+ * Copyright (c) 2006, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -19,17 +19,15 @@ import javax.lang.model.type.TypeVisitor;
 
 import org.eclipse.jdt.internal.compiler.apt.dispatch.BaseProcessingEnvImpl;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
-import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 
 /**
- * @author OThomann
- *
+ * Implementation of TypeVariable
  */
 public class TypeVariableImpl extends TypeMirrorImpl implements TypeVariable {
 	
-	public TypeVariableImpl(BaseProcessingEnvImpl env, TypeVariableBinding binding) {
+	TypeVariableImpl(BaseProcessingEnvImpl env, TypeVariableBinding binding) {
 		super(env, binding);
 	}
 	/* (non-Javadoc)
@@ -65,7 +63,7 @@ public class TypeVariableImpl extends TypeMirrorImpl implements TypeVariable {
 			// only one bound that is an interface
 			return _env.getFactory().newTypeMirror(typeVariableBinding.upperBound());
 		}
-		return this._env.getFactory().newDeclaredType((TypeVariableBinding) this._binding);
+		return this._env.getFactory().newTypeMirror((TypeVariableBinding) this._binding);
 	}
 
 	/* (non-Javadoc)
@@ -77,12 +75,7 @@ public class TypeVariableImpl extends TypeMirrorImpl implements TypeVariable {
 	}
 	
 	@Override
-	public TypeKind getKind()
-	{
-		TypeVariableBinding variableBinding = (TypeVariableBinding) _binding;
-		if ((!variableBinding.isValidBinding() || ((variableBinding.tagBits & TagBits.HasMissingType) != 0))) {
-			return TypeKind.ERROR;
-		}
+	public TypeKind getKind() {
 		return TypeKind.TYPEVAR;
 	}
 	
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
index d213261..5d1982f 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2009 BEA Systems, Inc. and others
+ * Copyright (c) 2007, 2011 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,7 @@
  *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
- *
+ *    IBM Corporation - fix for 342598
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.model;
@@ -195,18 +195,19 @@ public class TypesImpl implements Types {
      */
     @Override
     public TypeMirror erasure(TypeMirror t) {
-        TypeMirrorImpl typeMirrorImpl = (TypeMirrorImpl) t;
-        Binding binding = typeMirrorImpl._binding;
-        if (binding instanceof ReferenceBinding) {
-            return _env.getFactory().newTypeMirror(((ReferenceBinding) binding).erasure());
-        }
-        if (binding instanceof ArrayBinding) {
-        	TypeBinding typeBinding = (TypeBinding) binding;
-            return new ArrayTypeImpl(_env, this._env.getLookupEnvironment().createArrayType(
-                    typeBinding.leafComponentType().erasure(),
-                    typeBinding.dimensions()));
-        }
-        return t;
+    	TypeMirrorImpl typeMirrorImpl = (TypeMirrorImpl) t;
+    	Binding binding = typeMirrorImpl._binding;
+    	if (binding instanceof ReferenceBinding) {
+    		return _env.getFactory().newTypeMirror(((ReferenceBinding) binding).erasure());
+    	}
+    	if (binding instanceof ArrayBinding) {
+    		TypeBinding typeBinding = (TypeBinding) binding;
+    		return _env.getFactory().newTypeMirror(
+    				this._env.getLookupEnvironment().createArrayType(
+    						typeBinding.leafComponentType().erasure(),
+    						typeBinding.dimensions()));
+    	}
+    	return t;
     }
 
     /* (non-Javadoc)
@@ -216,9 +217,10 @@ public class TypesImpl implements Types {
     public ArrayType getArrayType(TypeMirror componentType) {
         TypeMirrorImpl typeMirrorImpl = (TypeMirrorImpl) componentType;
         TypeBinding typeBinding = (TypeBinding) typeMirrorImpl._binding;
-        return new ArrayTypeImpl(_env, this._env.getLookupEnvironment().createArrayType(
-                typeBinding.leafComponentType(),
-                typeBinding.dimensions() + 1));
+        return (ArrayType) _env.getFactory().newTypeMirror(
+        		this._env.getLookupEnvironment().createArrayType(
+        				typeBinding.leafComponentType(),
+        				typeBinding.dimensions() + 1));
     }
 
     /* (non-Javadoc)
@@ -234,7 +236,7 @@ public class TypesImpl implements Types {
         if (typeArgsLength == 0) {
             if (referenceBinding.isGenericType()) {
                 // must return a raw type
-                return _env.getFactory().newDeclaredType(this._env.getLookupEnvironment().createRawType(referenceBinding, null));
+                return (DeclaredType) _env.getFactory().newTypeMirror(this._env.getLookupEnvironment().createRawType(referenceBinding, null));
             }
             return (DeclaredType)typeElem.asType();
         } else if (typeArgsLength != typeVariablesLength) {
@@ -249,7 +251,7 @@ public class TypesImpl implements Types {
             }
             typeArguments[i] = (TypeBinding) binding;
         }
-        return _env.getFactory().newDeclaredType(
+        return (DeclaredType) _env.getFactory().newTypeMirror(
                 this._env.getLookupEnvironment().createParameterizedType(referenceBinding, typeArguments, null));
     }
 
@@ -269,7 +271,7 @@ public class TypesImpl implements Types {
         if (typeArgsLength == 0) {
             if (referenceBinding.isGenericType()) {
                 // must return a raw type
-                return _env.getFactory().newDeclaredType(this._env.getLookupEnvironment().createRawType(referenceBinding, enclosingType));
+                return (DeclaredType) _env.getFactory().newTypeMirror(this._env.getLookupEnvironment().createRawType(referenceBinding, enclosingType));
             }
             // TODO (see how to create a member type binding
             throw new UnsupportedOperationException("NYI: TypesImpl.getDeclaredType(...) for member types"); //$NON-NLS-1$
@@ -285,7 +287,7 @@ public class TypesImpl implements Types {
             }
             typeArguments[i] = (TypeBinding) binding;
         }
-        return _env.getFactory().newDeclaredType(
+        return (DeclaredType) _env.getFactory().newTypeMirror(
                 this._env.getLookupEnvironment().createParameterizedType(referenceBinding, typeArguments, enclosingType));
     }
 
@@ -321,12 +323,13 @@ public class TypesImpl implements Types {
         if (extendsBound != null) {
             TypeMirrorImpl extendsBoundMirrorType = (TypeMirrorImpl) extendsBound;
             TypeBinding typeBinding = (TypeBinding) extendsBoundMirrorType._binding;
-            return new WildcardTypeImpl(_env, this._env.getLookupEnvironment().createWildcard(
-                    null,
-                    0,
-                    typeBinding,
-                    null,
-                    Wildcard.EXTENDS));
+            return (WildcardType) _env.getFactory().newTypeMirror(
+            		this._env.getLookupEnvironment().createWildcard(
+	                    null,
+	                    0,
+	                    typeBinding,
+	                    null,
+	                    Wildcard.EXTENDS));
         }
         if (superBound != null) {
             TypeMirrorImpl superBoundMirrorType = (TypeMirrorImpl) superBound;
@@ -452,7 +455,7 @@ public class TypesImpl implements Types {
             // No boxing conversion was found
             throw new IllegalArgumentException();
         }
-        return _env.getFactory().getPrimitiveType((BaseTypeBinding)unboxed);
+        return (PrimitiveType) _env.getFactory().newTypeMirror((BaseTypeBinding)unboxed);
     }
 
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/WildcardTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/WildcardTypeImpl.java
index 4029f1f..c341cc4 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/WildcardTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/WildcardTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2009 IBM Corporation and others.
+ * Copyright (c) 2006, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -18,7 +18,6 @@ import javax.lang.model.type.WildcardType;
 
 import org.eclipse.jdt.internal.compiler.apt.dispatch.BaseProcessingEnvImpl;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
-import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 
@@ -27,7 +26,7 @@ import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
  */
 public class WildcardTypeImpl extends TypeMirrorImpl implements WildcardType {
 	
-	public WildcardTypeImpl(BaseProcessingEnvImpl env, WildcardBinding binding) {
+	WildcardTypeImpl(BaseProcessingEnvImpl env, WildcardBinding binding) {
 		super(env, binding);
 	}
 
@@ -48,10 +47,6 @@ public class WildcardTypeImpl extends TypeMirrorImpl implements WildcardType {
 	 */
 	@Override
 	public TypeKind getKind() {
-		WildcardBinding wildcardBinding = (WildcardBinding) _binding;
-		if ((!wildcardBinding.isValidBinding() || ((wildcardBinding.tagBits & TagBits.HasMissingType) != 0))) {
-			return TypeKind.ERROR;
-		}
 		return TypeKind.WILDCARD;
 	}
 	/* (non-Javadoc)
commit 44ed4cc96570ca19a458e8fcaac47d3ca1286ef0
Author: Olivier Thomann <oliviert>
Date:   Thu Apr 21 14:47:39 2011 +0000

    HEAD - Fixed bug 342598: Inconsistent handling of error types

-	-	org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
2	2	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
diff --git a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
index 874d975..e955bb9 100644
Binary files a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar and b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar differ
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
index 0c9c019..e4e1fdd 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 BEA Systems, Inc. 
+ * Copyright (c) 2007, 2011 BEA Systems, Inc. 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,7 @@
  *
  * Contributors:
  *    wharley@bea.com - initial API and implementation
- *    
+ *    IBM Corporation - fix for 342598
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.apt.dispatch;
