commit 6cb38423959485832f6b2b451a0cc3345d452e56
Author: Alex Blewitt <alex.blewitt@gmail.com>
Date:   Tue Mar 15 23:32:55 2016 +0000

    Bug 489702 - Replace new PrimitiveWrapper() with .valueOf()
    
    The primitive wrapper classes (Byte, Short, Character, Integer, Long)
    all have
    a constructor that takes a String (or primitive) value and return a new
    instance wrapping that type. They also have a valueOf method which does
    the
    same thing, but without creating a new object instance. Replace calls to
    the
    constructor and in-line calls where the object creation doesn't escape
    (for
    example, new Integer().intValue() or equivalent).
    
    Change-Id: I70310f46c085879b6efa28740186426de59c81b5
    Signed-off-by: Alex Blewitt <alex.blewitt@gmail.com>

3	3	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AnnotationInvocationHandler.java
17	17	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Factory.java
2	2	org.eclipse.jdt.apt.tests/src-annotations/org/eclipse/jdt/apt/tests/annotations/mirrortest/MirrorDeclarationTestAnnotationProcessor.java
3	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
17	17	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
11	11	org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/BasicBuildTests.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractComparableTest.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTest.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceImplTests.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceImplTransformations.java
4	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTest2.java
3	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST3_2.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST4_2.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST8_2.java
4	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/BatchASTCreationTests.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
3	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java
3	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritePropertyTest.java
22	22	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTest.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTrackingTest.java
13	13	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
3	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/LineCommentOffsetsTest.java
6	6	org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
2	2	org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
2	2	org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
2	2	org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
3	3	org.eclipse.jdt.core.tests.model/workspace/Converter/src/junit/framework/Assert.java
24	24	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
7	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ProcessTaskManager.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/StackMapFrameCodeStream.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
6	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
6	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MemberValuePairBinding.java
6	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/core/ToolFactory.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessingState.java
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
4	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
4	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
6	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
7	7	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SortElementsOperation.java
8	8	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceField.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
19	19	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
8	8	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java
7	7	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
14	14	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java
8	8	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
6	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
7	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchingNodeSet.java
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AnnotationInvocationHandler.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AnnotationInvocationHandler.java
index 5533931..91ac291 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AnnotationInvocationHandler.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AnnotationInvocationHandler.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2015 BEA Systems, Inc.
+ * Copyright (c) 2005, 2016 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -49,7 +49,7 @@ public class AnnotationInvocationHandler implements InvocationHandler
         if( args == null || args.length == 0 )
         {
             if( methodName.equals("hashCode") ) //$NON-NLS-1$
-                return new Integer( _instance.hashCode() );
+                return Integer.valueOf( _instance.hashCode() );
             if( methodName.equals("toString") ) //$NON-NLS-1$
                 return _instance.toString();
             if( methodName.equals("annotationType")) //$NON-NLS-1$
@@ -57,7 +57,7 @@ public class AnnotationInvocationHandler implements InvocationHandler
         }
         else if( args.length == 1 && methodName.equals("equals") ) //$NON-NLS-1$
         {
-            return new Boolean( _instance.equals( args[0] ) );
+            return Boolean.valueOf(_instance.equals(args[0]));
         }
         if( args != null && args.length != 0 )
             throw new NoSuchMethodException("method " + method.getName() + formatArgs(args) + " does not exists"); //$NON-NLS-1$ //$NON-NLS-2$
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Factory.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Factory.java
index bbdc53b..aeed41a 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Factory.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Factory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2015 BEA Systems, Inc. and others
+ * Copyright (c) 2005, 2016 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -468,17 +468,17 @@ public class Factory
 				else 
 					return avoidReflectException ? Boolean.FALSE : value;
 			case 'c':
-				return new Character((char)b); // narrowing.
+				return Character.valueOf((char)b); // narrowing.
 			case 'd':
 				return new Double(b); // widening.
 			case 'f':
 				return new Float(b); // widening.
 			case 'i':
-				return new Integer(b); // widening.
+				return Integer.valueOf(b); // widening.
 			case 'l':
-				return new Long(b); // widening.
+				return Long.valueOf(b); // widening.
 			case 's':
-				return new Short(b); // widening.
+				return Short.valueOf(b); // widening.
 			default:  				
 				throw new IllegalStateException("unknown type " + expectedTypeChar); //$NON-NLS-1$
 			}
@@ -492,19 +492,19 @@ public class Factory
 			{
 			case 'b':
 				if(nameLen == 4) // byte
-					return new Byte((byte)s); // narrowing.
+					return Byte.valueOf((byte)s); // narrowing.
 				else
 					return avoidReflectException ? Boolean.FALSE : value; // completely wrong.
 			case 'c':
-				return new Character((char)s); // narrowing.
+				return Character.valueOf((char)s); // narrowing.
 			case 'd':
 				return new Double(s); // widening.
 			case 'f':
 				return new Float(s); // widening.
 			case 'i':
-				return new Integer(s); // widening.
+				return Integer.valueOf(s); // widening.
 			case 'l':
-				return new Long(s); // widening.
+				return Long.valueOf(s); // widening.
 			case 's':
 				return value; // exact match
 			default:  				
@@ -520,7 +520,7 @@ public class Factory
 			{
 			case 'b':
 				if(nameLen == 4) // byte
-					return new Byte((byte)c); // narrowing.
+					return Byte.valueOf((byte)c); // narrowing.
 				else
 					return avoidReflectException ? Boolean.FALSE : value; // completely wrong.
 			case 'c':
@@ -530,11 +530,11 @@ public class Factory
 			case 'f':
 				return new Float(c); // widening.
 			case 'i':
-				return new Integer(c); // widening.
+				return Integer.valueOf(c); // widening.
 			case 'l':
-				return new Long(c); // widening.
+				return Long.valueOf(c); // widening.
 			case 's':
-				return new Short((short)c); // narrowing.
+				return Short.valueOf((short)c); // narrowing.
 			default:  				
 				throw new IllegalStateException("unknown type " + expectedTypeChar); //$NON-NLS-1$
 			}
@@ -549,11 +549,11 @@ public class Factory
 			{    
 			case 'b':
 				if(nameLen == 4) // byte
-					return new Byte((byte)i); // narrowing.
+					return Byte.valueOf((byte)i); // narrowing.
 				else
 					return avoidReflectException ? Boolean.FALSE : value; // completely wrong.
 			case 'c':
-				return new Character((char)i); // narrowing
+				return Character.valueOf((char)i); // narrowing
 			case 'd':
 				return new Double(i); // widening.
 			case 'f':
@@ -561,9 +561,9 @@ public class Factory
 			case 'i':
 				return value; // exact match
 			case 'l':
-				return new Long(i); // widening.
+				return Long.valueOf(i); // widening.
 			case 's':
-				return new Short((short)i); // narrowing.
+				return Short.valueOf((short)i); // narrowing.
 			default:  				
 				throw new IllegalStateException("unknown type " + expectedTypeChar); //$NON-NLS-1$
 			}
diff --git a/org.eclipse.jdt.apt.tests/src-annotations/org/eclipse/jdt/apt/tests/annotations/mirrortest/MirrorDeclarationTestAnnotationProcessor.java b/org.eclipse.jdt.apt.tests/src-annotations/org/eclipse/jdt/apt/tests/annotations/mirrortest/MirrorDeclarationTestAnnotationProcessor.java
index bf32611..d7e40fe 100644
--- a/org.eclipse.jdt.apt.tests/src-annotations/org/eclipse/jdt/apt/tests/annotations/mirrortest/MirrorDeclarationTestAnnotationProcessor.java
+++ b/org.eclipse.jdt.apt.tests/src-annotations/org/eclipse/jdt/apt/tests/annotations/mirrortest/MirrorDeclarationTestAnnotationProcessor.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 BEA Systems, Inc. and others
+ * Copyright (c) 2005, 2016 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -136,7 +136,7 @@ public class MirrorDeclarationTestAnnotationProcessor extends BaseProcessor {
         ProcessorTestStatus.assertTrue("position should be null", posVS == null); // the anno is declared in binary - no AST.
         AnnotationValue valueInt = elementInt.getDefaultValue();
         ProcessorTestStatus.assertEquals("", "bob", valueString.getValue());
-        ProcessorTestStatus.assertEquals("", new Integer(3), valueInt.getValue());
+        ProcessorTestStatus.assertEquals("", Integer.valueOf(3), valueInt.getValue());
         ProcessorTestStatus.assertEquals("", "\"bob\"", valueString.toString());
         ProcessorTestStatus.assertEquals("", "3", valueInt.toString());
 	}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
index 044386a..02ec122 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2015 IBM Corporation and others.
+ * Copyright (c) 2005, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -193,7 +193,7 @@ public class AnnotationMirrorImpl implements AnnotationMirror, InvocationHandler
         final String methodName = method.getName();
         if ( args == null || args.length == 0 ) {
             if( methodName.equals("hashCode") ) { //$NON-NLS-1$
-                return new Integer( hashCode() );
+                return Integer.valueOf(hashCode());
             }
             else if( methodName.equals("toString") ) { //$NON-NLS-1$
                 return toString();
@@ -203,7 +203,7 @@ public class AnnotationMirrorImpl implements AnnotationMirror, InvocationHandler
             }
         }
         else if ( args.length == 1 && methodName.equals("equals") ) { //$NON-NLS-1$
-            return new Boolean( equals( args[0] ) );
+            return Boolean.valueOf(equals(args[0]));
         }
 
         // If it's not one of the above methods, it must be an annotation member, so it cannot take any arguments
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
index 94f593a..70ac259 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2015 BEA Systems, Inc. and others
+ * Copyright (c) 2007, 2016 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -569,17 +569,17 @@ public class Factory {
 				else 
 					return avoidReflectException ? Boolean.FALSE : value;
 			case 'c':
-				return new Character((char)b); // narrowing.
+				return Character.valueOf((char) b); // narrowing.
 			case 'd':
 				return new Double(b); // widening.
 			case 'f':
 				return new Float(b); // widening.
 			case 'i':
-				return new Integer(b); // widening.
+				return Integer.valueOf(b); // widening.
 			case 'l':
-				return new Long(b); // widening.
+				return Long.valueOf(b); // widening.
 			case 's':
-				return new Short(b); // widening.
+				return Short.valueOf(b); // widening.
 			default:  				
 				throw new IllegalStateException("unknown type " + expectedTypeChar); //$NON-NLS-1$
 			}
@@ -593,19 +593,19 @@ public class Factory {
 			{
 			case 'b':
 				if(nameLen == 4) // byte
-					return new Byte((byte)s); // narrowing.
+					return Byte.valueOf((byte) s); // narrowing.
 				else
 					return avoidReflectException ? Boolean.FALSE : value; // completely wrong.
 			case 'c':
-				return new Character((char)s); // narrowing.
+				return Character.valueOf((char) s); // narrowing.
 			case 'd':
 				return new Double(s); // widening.
 			case 'f':
 				return new Float(s); // widening.
 			case 'i':
-				return new Integer(s); // widening.
+				return Integer.valueOf(s); // widening.
 			case 'l':
-				return new Long(s); // widening.
+				return Long.valueOf(s); // widening.
 			case 's':
 				return value; // exact match
 			default:  				
@@ -621,7 +621,7 @@ public class Factory {
 			{
 			case 'b':
 				if(nameLen == 4) // byte
-					return new Byte((byte)c); // narrowing.
+					return Byte.valueOf((byte) c); // narrowing.
 				else
 					return avoidReflectException ? Boolean.FALSE : value; // completely wrong.
 			case 'c':
@@ -631,11 +631,11 @@ public class Factory {
 			case 'f':
 				return new Float(c); // widening.
 			case 'i':
-				return new Integer(c); // widening.
+				return Integer.valueOf(c); // widening.
 			case 'l':
-				return new Long(c); // widening.
+				return Long.valueOf(c); // widening.
 			case 's':
-				return new Short((short)c); // narrowing.
+				return Short.valueOf((short) c); // narrowing.
 			default:  				
 				throw new IllegalStateException("unknown type " + expectedTypeChar); //$NON-NLS-1$
 			}
@@ -650,11 +650,11 @@ public class Factory {
 			{    
 			case 'b':
 				if(nameLen == 4) // byte
-					return new Byte((byte)i); // narrowing.
+					return Byte.valueOf((byte) i); // narrowing.
 				else
 					return avoidReflectException ? Boolean.FALSE : value; // completely wrong.
 			case 'c':
-				return new Character((char)i); // narrowing
+				return Character.valueOf((char) i); // narrowing
 			case 'd':
 				return new Double(i); // widening.
 			case 'f':
@@ -662,9 +662,9 @@ public class Factory {
 			case 'i':
 				return value; // exact match
 			case 'l':
-				return new Long(i); // widening.
+				return Long.valueOf(i); // widening.
 			case 's':
-				return new Short((short)i); // narrowing.
+				return Short.valueOf((short) i); // narrowing.
 			default:  				
 				throw new IllegalStateException("unknown type " + expectedTypeChar); //$NON-NLS-1$
 			}
diff --git a/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/BasicBuildTests.java b/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/BasicBuildTests.java
index 6820f35..738bc66 100644
--- a/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/BasicBuildTests.java
+++ b/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/BasicBuildTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -141,21 +141,21 @@ public class BasicBuildTests extends BuilderTests {
 			String message = (String) marker.getAttribute(IMarker.MESSAGE);
 			assertTrue("Wrong message", message.startsWith("TODO "));
 			assertNotNull("No task priority", priority);
-			assertEquals("Wrong priority", new Integer(IMarker.PRIORITY_NORMAL), priority);
+			assertEquals("Wrong priority", Integer.valueOf(IMarker.PRIORITY_NORMAL), priority);
 
 			marker = markers[1];
 			priority = marker.getAttribute(IMarker.PRIORITY);
 			message = (String) marker.getAttribute(IMarker.MESSAGE);
 			assertTrue("Wrong message", message.startsWith("FIXME "));
 			assertNotNull("No task priority", priority);
-			assertEquals("Wrong priority", new Integer(IMarker.PRIORITY_HIGH), priority);
+			assertEquals("Wrong priority", Integer.valueOf(IMarker.PRIORITY_HIGH), priority);
 
 			marker = markers[2];
 			priority = marker.getAttribute(IMarker.PRIORITY);
 			message = (String) marker.getAttribute(IMarker.MESSAGE);
 			assertTrue("Wrong message", message.startsWith("XXX "));
 			assertNotNull("No task priority", priority);
-			assertEquals("Wrong priority", new Integer(IMarker.PRIORITY_LOW), priority);
+			assertEquals("Wrong priority", Integer.valueOf(IMarker.PRIORITY_LOW), priority);
 		} catch (CoreException e) {
 			assertTrue(false);
 		}
@@ -197,21 +197,21 @@ public class BasicBuildTests extends BuilderTests {
 			String message = (String) marker.getAttribute(IMarker.MESSAGE);
 			assertEquals("Wrong message", "TODO should be done", message);
 			assertNotNull("No task priority", priority);
-			assertEquals("Wrong priority", new Integer(IMarker.PRIORITY_NORMAL), priority);
+			assertEquals("Wrong priority", Integer.valueOf(IMarker.PRIORITY_NORMAL), priority);
 
 			marker = markers[1];
 			priority = marker.getAttribute(IMarker.PRIORITY);
 			message = (String) marker.getAttribute(IMarker.MESSAGE);
 			assertEquals("Wrong message", "FIXME need to review the loop", message);
 			assertNotNull("No task priority", priority);
-			assertEquals("Wrong priority", new Integer(IMarker.PRIORITY_HIGH), priority);
+			assertEquals("Wrong priority", Integer.valueOf(IMarker.PRIORITY_HIGH), priority);
 
 			marker = markers[0];
 			priority = marker.getAttribute(IMarker.PRIORITY);
 			message = (String) marker.getAttribute(IMarker.MESSAGE);
 			assertEquals("Wrong message", "TODO need to review the loop", message);
 			assertNotNull("No task priority", priority);
-			assertEquals("Wrong priority", new Integer(IMarker.PRIORITY_NORMAL), priority);
+			assertEquals("Wrong priority", Integer.valueOf(IMarker.PRIORITY_NORMAL), priority);
 		} catch (CoreException e) {
 			assertTrue(false);
 		}
@@ -253,14 +253,14 @@ public class BasicBuildTests extends BuilderTests {
 			String message = (String) marker.getAttribute(IMarker.MESSAGE);
 			assertEquals("Wrong message", "TODO need to review the loop", message);
 			assertNotNull("No task priority", priority);
-			assertEquals("Wrong priority", new Integer(IMarker.PRIORITY_NORMAL), priority);
+			assertEquals("Wrong priority", Integer.valueOf(IMarker.PRIORITY_NORMAL), priority);
 
 			marker = markers[0];
 			priority = marker.getAttribute(IMarker.PRIORITY);
 			message = (String) marker.getAttribute(IMarker.MESSAGE);
 			assertEquals("Wrong message", "TODO need to review the loop", message);
 			assertNotNull("No task priority", priority);
-			assertEquals("Wrong priority", new Integer(IMarker.PRIORITY_NORMAL), priority);
+			assertEquals("Wrong priority", Integer.valueOf(IMarker.PRIORITY_NORMAL), priority);
 		} catch (CoreException e) {
 			assertTrue(false);
 		}
@@ -508,14 +508,14 @@ public class BasicBuildTests extends BuilderTests {
 			String message = (String) marker.getAttribute(IMarker.MESSAGE);
 			assertEquals("Wrong message", "TODO? need to review the loop", message);
 			assertNotNull("No task priority", priority);
-			assertEquals("Wrong priority", new Integer(IMarker.PRIORITY_LOW), priority);
+			assertEquals("Wrong priority", Integer.valueOf(IMarker.PRIORITY_LOW), priority);
 
 			marker = markers[0];
 			priority = marker.getAttribute(IMarker.PRIORITY);
 			message = (String) marker.getAttribute(IMarker.MESSAGE);
 			assertEquals("Wrong message", "TODO! need to review the loop", message);
 			assertNotNull("No task priority", priority);
-			assertEquals("Wrong priority", new Integer(IMarker.PRIORITY_HIGH), priority);
+			assertEquals("Wrong priority", Integer.valueOf(IMarker.PRIORITY_HIGH), priority);
 		} catch (CoreException e) {
 			assertTrue(false);
 		}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractComparableTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractComparableTest.java
index dc9770e..bb9772a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractComparableTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractComparableTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -65,7 +65,7 @@ public class AbstractComparableTest extends AbstractRegressionTest {
 
 	public static Test buildComparableTestSuite(Class evaluationTestClass) {
 		Test suite = buildMinimalComplianceTestSuite(evaluationTestClass, F_1_5);
-		TESTS_COUNTERS.put(evaluationTestClass.getName(), new Integer(suite.countTestCases()));
+		TESTS_COUNTERS.put(evaluationTestClass.getName(), Integer.valueOf(suite.countTestCases()));
 		return suite;
 	}
 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
index 04806c9..bfbeaeb 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
@@ -1178,7 +1178,7 @@ protected static class JavacTestOptions {
 			Integer count = (Integer)TESTS_COUNTERS.get(CURRENT_CLASS_NAME);
 			if (count != null) {
 				int newCount = count.intValue()-1;
-				TESTS_COUNTERS.put(CURRENT_CLASS_NAME, new Integer(newCount));
+				TESTS_COUNTERS.put(CURRENT_CLASS_NAME, Integer.valueOf(newCount));
 				if (newCount == 0) {
 					if (DIFF_COUNTERS[0]!=0 || DIFF_COUNTERS[1]!=0 || DIFF_COUNTERS[2]!=0) {
 						dualPrintln("===========================================================================");
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 325dbb7..0e13bb2 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1158,7 +1158,7 @@ private String categoryName(int category) {
 				String name = field.getName();
 				if (name.startsWith("CAT_")) {
 					try {
-						categoryNames.put(new Integer(field.getInt(CategorizedProblem.class)), name);
+						categoryNames.put(Integer.valueOf(field.getInt(CategorizedProblem.class)), name);
 					} catch (IllegalArgumentException e) {
 					} catch (IllegalAccessException e) {
 					}
@@ -1166,7 +1166,7 @@ private String categoryName(int category) {
 			}
 		}
 	}
-	return (String) categoryNames.get(new Integer(category));
+	return (String) categoryNames.get(Integer.valueOf(category));
 }
 // compiler problems tuning
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=218603
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTest.java
index 8c8d60b..c396105 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/JavadocTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -612,7 +612,7 @@ public abstract class JavadocTest extends AbstractRegressionTest {
 			Integer count = (Integer)TESTS_COUNTERS.get(CURRENT_CLASS_NAME);
 			if (count != null) {
 				int newCount = count.intValue()-1;
-				TESTS_COUNTERS.put(CURRENT_CLASS_NAME, new Integer(newCount));
+				TESTS_COUNTERS.put(CURRENT_CLASS_NAME, Integer.valueOf(newCount));
 				if (newCount == 0) {
 					if (DIFF_COUNTERS[0]!=0 || DIFF_COUNTERS[1]!=0 || DIFF_COUNTERS[2]!=0) {
 						dualPrintln("===========================================================================");
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceImplTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceImplTests.java
index ccec78a..13c9fee 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceImplTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceImplTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 IBM Corporation and others.
+ * Copyright (c) 2005, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1710,7 +1710,7 @@ private static void reinitializeFromComputedValues(String source, String target)
 	transitiveClosure = addSymbolicStates(transitiveClosure); // don't rely on reachibility alone, since we don't cover all operations in these tests.
 	Arrays.sort(transitiveClosure, new Comparator() {
 		public int compare(Object o1, Object o2) {
-			return new Integer(((State)o1).value).compareTo(new Integer(((State)o2).value));
+			return Integer.valueOf(((State)o1).value).compareTo(Integer.valueOf(((State)o2).value));
 		}
 	});
 	try {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceImplTransformations.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceImplTransformations.java
index fd02e62..882ac45 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceImplTransformations.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceImplTransformations.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 IBM Corporation and others.
+ * Copyright (c) 2005, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1572,7 +1572,7 @@ int rankForState(State state) {
 	if (ranksForStates == null) {
 		ranksForStates = new HashMap(length = truthTableRowNames.length);
 		for (int i = 0; i < length; i++) {
-			ranksForStates.put(truthTableRowNames[i], new Integer(i));
+			ranksForStates.put(truthTableRowNames[i], Integer.valueOf(i));
 		}
 	}
 	Integer rank;
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java
index 4c2fc8e..e8ef9c1 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/AbstractCompilerTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -428,12 +428,12 @@ public class AbstractCompilerTest extends TestCase {
 		Class testClass;
 		if (testClasses.size() == 1) {
 			suite = new TestSuite(testClass = (Class)testClasses.get(0), CompilerOptions.versionFromJdkLevel(complianceLevel));
-			TESTS_COUNTERS.put(testClass.getName(), new Integer(suite.countTestCases()));
+			TESTS_COUNTERS.put(testClass.getName(), Integer.valueOf(suite.countTestCases()));
 		} else {
 			suite = new TestSuite(CompilerOptions.versionFromJdkLevel(complianceLevel));
 			for (int i = 0, length = testClasses.size(); i < length; i++) {
 				TestSuite innerSuite = new TestSuite(testClass = (Class)testClasses.get(i));
-				TESTS_COUNTERS.put(testClass.getName(), new Integer(innerSuite.countTestCases()));
+				TESTS_COUNTERS.put(testClass.getName(), Integer.valueOf(innerSuite.countTestCases()));
 				suite.addTest(innerSuite);
 			}
 		}
@@ -464,7 +464,7 @@ public class AbstractCompilerTest extends TestCase {
 		int newTestsNb = suite.countTestCases();
 		if ((testsNb = (Integer) TESTS_COUNTERS.get(className)) != null)
 			newTestsNb += testsNb.intValue();
-		TESTS_COUNTERS.put(className, new Integer(newTestsNb));
+		TESTS_COUNTERS.put(className, Integer.valueOf(newTestsNb));
 		return suite;
 	}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTest2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTest2.java
index ff7fb98..d2ad55d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTest2.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTest2.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -4462,7 +4462,7 @@ public class ASTConverterTest2 extends ConverterTestSetup {
 		assertEquals("Wrong name", "BOOLEAN_FIELD", variableBinding.getName());
 		constantValue = variableBinding.getConstantValue();
 		assertNotNull("No constant", constantValue);
-		assertEquals("Wrong value", new Boolean(true), constantValue);
+		assertEquals("Wrong value", Boolean.TRUE, constantValue);
 		initializer = fragment.getInitializer();
 		assertNotNull("No initializer", initializer);
 		checkSourceRange(initializer, "true", source);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST3_2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST3_2.java
index 873db29..960b66d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST3_2.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST3_2.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -4539,7 +4539,7 @@ public class ASTConverterTestAST3_2 extends ConverterTestSetup {
 		assertEquals("Wrong name", "BOOLEAN_FIELD", variableBinding.getName());
 		constantValue = variableBinding.getConstantValue();
 		assertNotNull("No constant", constantValue);
-		assertEquals("Wrong value", new Boolean(true), constantValue);
+		assertEquals("Wrong value", Boolean.TRUE, constantValue);
 		initializer = fragment.getInitializer();
 		assertNotNull("No initializer", initializer);
 		checkSourceRange(initializer, "true", source);
@@ -10670,4 +10670,4 @@ public class ASTConverterTestAST3_2 extends ConverterTestSetup {
 		SuperConstructorInvocation statement = (SuperConstructorInvocation) node;
 		checkSourceRange(statement, "super();", source);
 	}
-}
\ No newline at end of file
+}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST4_2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST4_2.java
index 7edddf2..514f6f0 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST4_2.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST4_2.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2015 IBM Corporation and others.
+ * Copyright (c) 2011, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -4536,7 +4536,7 @@ public class ASTConverterTestAST4_2 extends ConverterTestSetup {
 		assertEquals("Wrong name", "BOOLEAN_FIELD", variableBinding.getName());
 		constantValue = variableBinding.getConstantValue();
 		assertNotNull("No constant", constantValue);
-		assertEquals("Wrong value", new Boolean(true), constantValue);
+		assertEquals("Wrong value", Boolean.TRUE, constantValue);
 		initializer = fragment.getInitializer();
 		assertNotNull("No initializer", initializer);
 		checkSourceRange(initializer, "true", source);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST8_2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST8_2.java
index f49e562..466c9e8 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST8_2.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverterTestAST8_2.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2015 IBM Corporation and others.
+ * Copyright (c) 2011, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -4565,7 +4565,7 @@ public class ASTConverterTestAST8_2 extends ConverterTestSetup {
 		assertEquals("Wrong name", "BOOLEAN_FIELD", variableBinding.getName());
 		constantValue = variableBinding.getConstantValue();
 		assertNotNull("No constant", constantValue);
-		assertEquals("Wrong value", new Boolean(true), constantValue);
+		assertEquals("Wrong value", Boolean.TRUE, constantValue);
 		initializer = fragment.getInitializer();
 		assertNotNull("No initializer", initializer);
 		checkSourceRange(initializer, "true", source);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
index e2e5695..7f0ef7a 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -6362,7 +6362,7 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 				int start = buffer.length();
 				buffer.append("(");
 				// push start position - popped by postVisit for same node
-				stack.add(new Integer(start));
+				stack.add(Integer.valueOf(start));
 			}
 			public void postVisit(ASTNode node) {
 				// pop start position placed there by preVisit
@@ -8876,11 +8876,11 @@ public class ASTTest extends org.eclipse.jdt.core.tests.junit.extension.TestCase
 			String name = field.getName();
 			if ("MALFORMED".equals(name) || "ORIGINAL".equals(name) || "PROTECT".equals(name) || "RECOVERED".equals(name))
 				continue;
-			declaredNodeTypes.add(new Integer(field.getInt(null)));
+			declaredNodeTypes.add(Integer.valueOf(field.getInt(null)));
 		}
 		for (int i= 0; i < nodeTypes.length; i++) {
 			int nodeType= nodeTypes[i];
-			assertTrue("node type " + nodeType + " from test is missing in ASTNode", declaredNodeTypes.remove(new Integer(nodeType)));
+			assertTrue("node type " + nodeType + " from test is missing in ASTNode", declaredNodeTypes.remove(Integer.valueOf(nodeType)));
 			nodeTypes[i] = -1;
 		}
 		for (int i= 0; i < nodeTypes.length; i++) {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/BatchASTCreationTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/BatchASTCreationTests.java
index 9263dd2..ba87ae9 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/BatchASTCreationTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/BatchASTCreationTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2012 IBM Corporation and others.
+ * Copyright (c) 2004, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1692,7 +1692,7 @@ public class BatchASTCreationTests extends AbstractASTTests {
 		Requestor requestor = new Requestor();
 		resolveASTs(new ICompilationUnit[] {this.workingCopies[0]}, requestor);
 
-		assertEquals("Unexpected constant value", new Integer(5), requestor.constantValue);
+		assertEquals("Unexpected constant value", 5, requestor.constantValue);
 	}
 
 	/*
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
index 33a5ce2..94ea5ea 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/MarkedASTFlattener.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2015 IBM Corporation and others.
+ * Copyright (c) 2008, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -553,7 +553,7 @@ public class MarkedASTFlattener extends NaiveASTFlattener {
 				if (this.nodeFromMarker.get(markerName) == null) {
 					this.markerFromNode.put(node, markerName);
 					this.nodeFromMarker.put(markerName, node);
-					this.markerPositonInBuffer.put(markerName, new Integer(this.buffer.length()));
+					this.markerPositonInBuffer.put(markerName, Integer.valueOf(this.buffer.length()));
 					this.foundNodeFromMarker[index] = true;
 				}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java
index 8498db2..36066d8 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SortCompilationUnitElementsTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -82,7 +82,7 @@ private void oldAPISortUnit(ICompilationUnit unit, String expectedResult, boolea
 	if (testPositions) {
 		for (int i = 0; i < initialSource.length(); i++) {
 			if (!Character.isWhitespace(initialSource.charAt(i))) {
-				arrayList.add(new Integer(i));
+				arrayList.add(Integer.valueOf(i));
 			}
 		}
 		final int length = arrayList.size();
@@ -123,7 +123,7 @@ private void sortUnit(int apiLevel, ICompilationUnit unit, String expectedResult
 	if (testPositions) {
 		for (int i = 0; i < initialSource.length(); i++) {
 			if (!Character.isWhitespace(initialSource.charAt(i))) {
-				arrayList.add(new Integer(i));
+				arrayList.add(Integer.valueOf(i));
 			}
 		}
 		final int length = arrayList.size();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritePropertyTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritePropertyTest.java
index c01ed5a..faa6b05 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritePropertyTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritePropertyTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013 IBM Corporation and others.
+ * Copyright (c) 2013, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -50,7 +50,7 @@ public class ASTRewritePropertyTest extends ASTRewritingTest {
 			// ignore
 		}
 		rewrite.setProperty(propertyName1, "value");
-		rewrite.setProperty(propertyName2, new Integer(1));
+		rewrite.setProperty(propertyName2, 1);
 		try {
 			rewrite.setProperty(null, "");
 			assertTrue("Should not be reached", false);
@@ -63,7 +63,7 @@ public class ASTRewritePropertyTest extends ASTRewritingTest {
 		
 		Object value2 = rewrite.getProperty(propertyName2);
 		assertTrue("Not an Integer", value2 instanceof Integer);
-		assertTrue("Wrong value", new Integer(1).equals(value2));
+		assertTrue("Wrong value", Integer.valueOf(1).equals(value2));
 
 		rewrite.setProperty(propertyName1, null);
 		value1 = rewrite.getProperty(propertyName1);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
index 78140a9..fbce7ed 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingMethodDeclTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -82,7 +82,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 	/** @deprecated using deprecated code */
 	private void setModifiers(ASTRewrite rewrite, MethodDeclaration methodDecl, int newModifiers) {
 		if (this.apiLevel < AST.JLS3) {
-			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 		} else {
 			ListRewrite listRewrite = rewrite.getListRewrite(methodDecl, MethodDeclaration.MODIFIERS2_PROPERTY);
 			for (Iterator iter= listRewrite.getOriginalList().iterator(); iter.hasNext(); ) {
@@ -100,7 +100,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 	/** @deprecated using deprecated code */
 	private void setExtraDimensions(ASTRewrite rewrite, MethodDeclaration methodDecl, int extraDimensions) {
 		if (this.apiLevel < AST.JLS8) {
-			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(extraDimensions), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, Integer.valueOf(extraDimensions), null);
 		} else {
 			ListRewrite listRewrite = rewrite.getListRewrite(methodDecl, MethodDeclaration.EXTRA_DIMENSIONS2_PROPERTY);
 			for (Iterator iter= listRewrite.getOriginalList().iterator(); iter.hasNext(); ) {
@@ -364,7 +364,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 		{ // insert return type, add second modifier
 			MethodDeclaration methodDecl= (MethodDeclaration) list.get(0);
-			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, new Integer(Modifier.PUBLIC | Modifier.FINAL), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, Integer.valueOf(Modifier.PUBLIC | Modifier.FINAL), null);
 
 			Type newReturnType= astRoot.getAST().newPrimitiveType(PrimitiveType.FLOAT);
 
@@ -375,7 +375,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		}
 		{ // insert return type, add (first) modifier
 			MethodDeclaration methodDecl= (MethodDeclaration) list.get(1);
-			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, new Integer(Modifier.FINAL), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, Integer.valueOf(Modifier.FINAL), null);
 
 			Type newReturnType= astRoot.getAST().newPrimitiveType(PrimitiveType.FLOAT);
 
@@ -387,7 +387,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		{ // insert return type, add second modifier with comments
 			MethodDeclaration methodDecl= (MethodDeclaration) list.get(2);
 
-			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, new Integer(Modifier.FINAL), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, Integer.valueOf(Modifier.FINAL), null);
 
 			Type newReturnType= astRoot.getAST().newPrimitiveType(PrimitiveType.FLOAT);
 
@@ -399,7 +399,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 		{ // add second modifier
 			MethodDeclaration methodDecl= (MethodDeclaration) list.get(3);
-			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, new Integer(Modifier.PUBLIC | Modifier.FINAL), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, Integer.valueOf(Modifier.PUBLIC | Modifier.FINAL), null);
 
 			// from method to constructor
 			rewrite.set(methodDecl, MethodDeclaration.CONSTRUCTOR_PROPERTY, Boolean.TRUE, null);
@@ -407,7 +407,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		}
 		{ // add (first) modifier
 			MethodDeclaration methodDecl= (MethodDeclaration) list.get(4);
-			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, new Integer(Modifier.FINAL), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, Integer.valueOf(Modifier.FINAL), null);
 
 			// from method to constructor
 			rewrite.set(methodDecl, MethodDeclaration.CONSTRUCTOR_PROPERTY, Boolean.TRUE, null);
@@ -416,7 +416,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		{ // add second modifier with comments
 			MethodDeclaration methodDecl= (MethodDeclaration) list.get(5);
 
-			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, new Integer(Modifier.FINAL), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, Integer.valueOf(Modifier.FINAL), null);
 
 			// from method to constructor
 			rewrite.set(methodDecl, MethodDeclaration.CONSTRUCTOR_PROPERTY, Boolean.TRUE, null);
@@ -464,7 +464,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 		{ // insert return type, remove second modifier
 			MethodDeclaration methodDecl= (MethodDeclaration) list.get(0);
-			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, new Integer(Modifier.PUBLIC), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, Integer.valueOf(Modifier.PUBLIC), null);
 
 			Type newReturnType= astRoot.getAST().newPrimitiveType(PrimitiveType.FLOAT);
 
@@ -499,7 +499,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 		{ // remove second modifier
 			MethodDeclaration methodDecl= (MethodDeclaration) list.get(3);
-			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, new Integer(Modifier.PUBLIC), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_MODIFIERS_PROPERTY, Integer.valueOf(Modifier.PUBLIC), null);
 
 			// from method to constructor
 			rewrite.set(methodDecl, MethodDeclaration.CONSTRUCTOR_PROPERTY, Boolean.TRUE, null);
@@ -1505,7 +1505,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		{ // add extra dim, add throws
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo1");
 
-			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, 1, null);
 
 			Name newThrownException2= ast.newSimpleName("ArrayStoreException");
 			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
@@ -1514,14 +1514,14 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		{ // add extra dim, remove throws
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo2");
 
-			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, 1, null);
 
 			rewrite.remove((ASTNode) getThrownExceptions(methodDecl).get(0), null);
 		}
 		{ // remove extra dim, add throws
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo3");
 
-			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, 1, null);
 
 			Name newThrownException2= ast.newSimpleName("ArrayStoreException");
 			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
@@ -1530,7 +1530,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 		{ // add extra dim, remove throws
 			MethodDeclaration methodDecl= findMethodDeclaration(type, "foo4");
 
-			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, 1, null);
 
 			rewrite.remove((ASTNode) getThrownExceptions(methodDecl).get(0), null);
 		}
@@ -1541,7 +1541,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			rewrite.getListRewrite(methodDecl, MethodDeclaration.PARAMETERS_PROPERTY).insertLast(newParam1, null);
 
 
-			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(4), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, 4, null);
 
 			Name newThrownException2= ast.newSimpleName("ArrayStoreException");
 			rewrite.getListRewrite(methodDecl, INTERNAL_METHOD_THROWN_EXCEPTIONS_PROPERTY).insertLast(newThrownException2, null);
@@ -1552,7 +1552,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 			rewrite.remove((ASTNode) methodDecl.parameters().get(0), null);
 
-			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, new Integer(4), null);
+			rewrite.set(methodDecl, INTERNAL_METHOD_EXTRA_DIMENSIONS_PROPERTY, 4, null);
 
 			rewrite.remove((ASTNode) getThrownExceptions(methodDecl).get(0), null);
 		}
@@ -1850,7 +1850,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 			// add modifier
 			int newModifiers= Modifier.FINAL;
-			rewrite.set(decl, INTERNAL_FIELD_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(decl, INTERNAL_FIELD_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 			PrimitiveType newType= ast.newPrimitiveType(PrimitiveType.BOOLEAN);
 			rewrite.replace(decl.getType(), newType, null);
@@ -1867,7 +1867,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 			// add modifier
 			int newModifiers= Modifier.FINAL | Modifier.STATIC | Modifier.TRANSIENT;
-			rewrite.set(decl, INTERNAL_FIELD_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(decl, INTERNAL_FIELD_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 			List fragments= decl.fragments();
 			assertTrue("Number of fragments not 3", fragments.size() == 3);
@@ -1886,7 +1886,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 			// change modifier
 			int newModifiers= 0;
-			rewrite.set(decl, INTERNAL_FIELD_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(decl, INTERNAL_FIELD_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 		}
 
 		String preview= evaluateRewrite(cu, rewrite);
@@ -1931,7 +1931,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 
 			// add modifier
 			int newModifiers= Modifier.STATIC;
-			rewrite.set(initializer, INTERNAL_INITIALIZER_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(initializer, INTERNAL_INITIALIZER_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 
 			Block block= ast.newBlock();
@@ -1943,7 +1943,7 @@ public class ASTRewritingMethodDeclTest extends ASTRewritingTest {
 			Initializer initializer= (Initializer) declarations.get(1);
 
 			int newModifiers= 0;
-			rewrite.set(initializer, INTERNAL_INITIALIZER_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(initializer, INTERNAL_INITIALIZER_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 		}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTest.java
index 3e3b788..2d46ab6 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -163,7 +163,7 @@ public class ASTRewritingTest extends AbstractJavaModelTests {
 						for (int j= 0; j < JLS_LEVELS.length; j++) {
 							int level = JLS_LEVELS[j];
 							if (level >= since && level >= classSince) {
-								suite.addTest((Test) cons.newInstance(new Object[]{name, new Integer(level)}));
+								suite.addTest((Test) cons.newInstance(new Object[]{name, Integer.valueOf(level)}));
 							}
 						}
 					}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTrackingTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTrackingTest.java
index 8c90a19..aff2b0d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTrackingTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTrackingTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -244,7 +244,7 @@ public class ASTRewritingTrackingTest extends ASTRewritingTest {
 
 		// change modifier
 		int newModifiers= Modifier.STATIC | Modifier.TRANSIENT | Modifier.PRIVATE;
-		rewrite.set(field, INTERNAL_FIELD_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+		rewrite.set(field, INTERNAL_FIELD_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 		String preview= evaluateRewrite(cu, rewrite);
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
index e235d0e..14b716d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/ASTRewritingTypeDeclTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -149,7 +149,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 
 			// change flags
 			int newModifiers= 0;
-			rewrite.set(type, INTERNAL_TYPE_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(type, INTERNAL_TYPE_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 			// change to interface
 			rewrite.set(type, TypeDeclaration.INTERFACE_PROPERTY, Boolean.TRUE, null);
@@ -167,7 +167,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 
 			// change flags
 			int newModifiers= 0;
-			rewrite.set(type, INTERNAL_TYPE_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(type, INTERNAL_TYPE_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 			// change to class
 			rewrite.set(type, TypeDeclaration.INTERFACE_PROPERTY, Boolean.FALSE, null);
@@ -395,7 +395,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 
 			// change flags
 			int newModifiers= 0;
-			rewrite.set(type, INTERNAL_TYPE_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(type, INTERNAL_TYPE_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 			// change to interface
 			rewrite.set(type, TypeDeclaration.INTERFACE_PROPERTY, Boolean.TRUE, null);
@@ -423,7 +423,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 
 			// change flags
 			int newModifiers= Modifier.FINAL;
-			rewrite.set(type, INTERNAL_TYPE_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(type, INTERNAL_TYPE_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 			// change to interface
 			rewrite.set(type, TypeDeclaration.INTERFACE_PROPERTY, Boolean.TRUE, null);
@@ -498,7 +498,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 
 			// change flags
 			int newModifiers= Modifier.PUBLIC | Modifier.FINAL;
-			rewrite.set(type, INTERNAL_TYPE_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(type, INTERNAL_TYPE_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 			SimpleName newSuperinterface= ast.newSimpleName("Cloneable");
 
@@ -1046,9 +1046,9 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 			SingleVariableDeclaration decl= (SingleVariableDeclaration) arguments.get(0);
 
 			int newModifiers= Modifier.FINAL;
-			rewrite.set(decl, INTERNAL_VARIABLE_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(decl, INTERNAL_VARIABLE_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
-			rewrite.set(decl, INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY, new Integer(1), null);
+			rewrite.set(decl, INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY, 1, null);
 
 			ArrayType newVarType= ast.newArrayType(ast.newPrimitiveType(PrimitiveType.FLOAT), 2);
 			rewrite.replace(decl.getType(), newVarType, null);
@@ -1060,7 +1060,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 			SingleVariableDeclaration decl= (SingleVariableDeclaration) arguments.get(1);
 
 			int newModifiers= 0;
-			rewrite.set(decl, INTERNAL_VARIABLE_MODIFIERS_PROPERTY, new Integer(newModifiers), null);
+			rewrite.set(decl, INTERNAL_VARIABLE_MODIFIERS_PROPERTY, Integer.valueOf(newModifiers), null);
 
 			Type newVarType= ast.newPrimitiveType(PrimitiveType.FLOAT);
 			rewrite.replace(decl.getType(), newVarType, null);
@@ -1068,7 +1068,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 		{ // remove extra dim
 			SingleVariableDeclaration decl= (SingleVariableDeclaration) arguments.get(2);
 
-			rewrite.set(decl, INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY, new Integer(0), null);
+			rewrite.set(decl, INTERNAL_VARIABLE_EXTRA_DIMENSIONS_PROPERTY, 0, null);
 		}
 
 		String preview= evaluateRewrite(cu, rewrite);
@@ -1117,7 +1117,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 			ASTNode name= ast.newSimpleName("a");
 			rewrite.replace(fragment.getName(), name, null);
 
-			rewrite.set(fragment, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, new Integer(2), null);
+			rewrite.set(fragment, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, 2, null);
 		}
 
 		{ // add initializer
@@ -1138,7 +1138,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 		{ // add dimension, add initializer
 			VariableDeclarationFragment fragment= (VariableDeclarationFragment) fragments.get(3);
 
-			rewrite.set(fragment, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, new Integer(4), null);
+			rewrite.set(fragment, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, 4, null);
 
 			assertTrue("Has initializer", fragment.getInitializer() == null);
 
@@ -1148,7 +1148,7 @@ public class ASTRewritingTypeDeclTest extends ASTRewritingTest {
 		{ // remove dimension
 			VariableDeclarationFragment fragment= (VariableDeclarationFragment) fragments.get(4);
 
-			rewrite.set(fragment, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, new Integer(0), null);
+			rewrite.set(fragment, INTERNAL_FRAGMENT_EXTRA_DIMENSIONS_PROPERTY, 0, null);
 		}
 
 		String preview= evaluateRewrite(cu, rewrite);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/LineCommentOffsetsTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/LineCommentOffsetsTest.java
index 5dc4ead..0cd6368 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/LineCommentOffsetsTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/rewrite/describing/LineCommentOffsetsTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -157,7 +157,7 @@ public class LineCommentOffsetsTest extends ASTRewritingTest {
 		for (int i= 0; i < content.length(); i++) {
 			char ch= content.charAt(i);
 			if (ch == 'Y') {
-				expectedOffsets.add(new Integer(i + 1));
+				expectedOffsets.add(Integer.valueOf(i + 1));
 			}
 		}
 
@@ -208,7 +208,7 @@ public class LineCommentOffsetsTest extends ASTRewritingTest {
 		for (int i= 0; i < content.length(); i++) {
 			char ch= content.charAt(i);
 			if (ch == 'Y') {
-				expectedOffsets.add(new Integer(i + 1));
+				expectedOffsets.add(Integer.valueOf(i + 1));
 			}
 		}
 
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java b/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
index 9b26177..60e046c 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2004 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials 
  * are made available under the terms of the Common Public License v1.0
  * which accompanies this distribution, and is available at
@@ -144,16 +144,16 @@ public Object getWrappedConstantValue() {
 			Constant fieldConstant = getConstant();
 			switch (fieldConstant.typeID()) {
 				case T_int :
-					this.wrappedConstantValue = new Integer(fieldConstant.intValue());
+					this.wrappedConstantValue = Integer.valueOf(fieldConstant.intValue());
 					break;
 				case T_byte :
-					this.wrappedConstantValue = new Byte(fieldConstant.byteValue());
+					this.wrappedConstantValue = Byte.valueOf(fieldConstant.byteValue());
 					break;
 				case T_short :
-					this.wrappedConstantValue = new Short(fieldConstant.shortValue());
+					this.wrappedConstantValue = Short.valueOf(fieldConstant.shortValue());
 					break;
 				case T_char :
-					this.wrappedConstantValue = new Character(fieldConstant.charValue());
+					this.wrappedConstantValue = Character.valueOf(fieldConstant.charValue());
 					break;
 				case T_float :
 					this.wrappedConstantValue = new Float(fieldConstant.floatValue());
@@ -165,7 +165,7 @@ public Object getWrappedConstantValue() {
 					this.wrappedConstantValue = Util.toBoolean(fieldConstant.booleanValue());
 					break;
 				case T_long :
-					this.wrappedConstantValue = new Long(fieldConstant.longValue());
+					this.wrappedConstantValue = Long.valueOf(fieldConstant.longValue());
 					break;
 				case T_String :
 					this.wrappedConstantValue = fieldConstant.stringValue();
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java b/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
index 9a5e56a..5c71a62 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2004 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials 
  * are made available under the terms of the Common Public License v1.0
  * which accompanies this distribution, and is available at
@@ -39,7 +39,7 @@ public short shortValue() {
 public String stringValue() {
 	//spec 15.17.11
 	
-	String s = new Integer(value).toString() ;
+	String s = Integer.valueOf(value).toString() ;
 	if (s == null) return "null"; //$NON-NLS-1$
 	return s;
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/IntConstant.java b/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
index 8d54e90..d5682a4 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2004 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials 
  * are made available under the terms of the Common Public License v1.0
  * which accompanies this distribution, and is available at
@@ -48,7 +48,7 @@ public class IntConstant extends Constant {
 	
 	public String stringValue() {
 		//spec 15.17.11
-		String s = new Integer(value).toString();
+		String s = Integer.valueOf(value).toString();
 		if (s == null) return "null"; //$NON-NLS-1$
 		return s;
 	}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java b/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
index 0bad92d..cb1878a 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Compiler/src/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2004 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials 
  * are made available under the terms of the Common Public License v1.0
  * which accompanies this distribution, and is available at
@@ -39,7 +39,7 @@ public short shortValue() {
 public String stringValue() {
 	//spec 15.17.11
 	
-	String s = new Integer(value).toString() ;
+	String s = Integer.valueOf(value).toString() ;
 	if (s == null) return "null"; //$NON-NLS-1$
 	return s;
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Converter/src/junit/framework/Assert.java b/org.eclipse.jdt.core.tests.model/workspace/Converter/src/junit/framework/Assert.java
index 8d928e7..a30132c 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Converter/src/junit/framework/Assert.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Converter/src/junit/framework/Assert.java
@@ -146,7 +146,7 @@ public class Assert {
 	 * an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertEquals(String message, boolean expected, boolean actual) {
-    		assertEquals(message, new Boolean(expected), new Boolean(actual));
+    		assertEquals(message, Boolean.valueOf(expected), Boolean.valueOf(actual));
   	}
 	/**
 	 * Asserts that two booleans are equal.
@@ -198,7 +198,7 @@ public class Assert {
 	 * an AssertionFailedError is thrown with the given message.
 	 */
   	static public void assertEquals(String message, int expected, int actual) {
-		assertEquals(message, new Integer(expected), new Integer(actual));
+		assertEquals(message, Integer.valueOf(expected), Integer.valueOf(actual));
   	}
   	/**
    	 * Asserts that two ints are equal.
@@ -288,4 +288,4 @@ public class Assert {
 			formatted= message+" ";
 		return formatted+"expected:<"+expected+"> but was:<"+actual+">";
 	}
-}
\ No newline at end of file
+}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 46ca544..bc8b0bf 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -713,7 +713,7 @@ public class Main implements ProblemSeverities, SuffixConstants {
 		 */
 		public void logNumberOfClassFilesGenerated(int exportedClassFilesCounter) {
 			if ((this.tagBits & Logger.XML) != 0) {
-				this.parameters.put(Logger.VALUE, new Integer(exportedClassFilesCounter));
+				this.parameters.put(Logger.VALUE, Integer.valueOf(exportedClassFilesCounter));
 				printTag(Logger.NUMBER_OF_CLASSFILES, this.parameters, true, true);
 			}
 			if (exportedClassFilesCounter == 1) {
@@ -876,10 +876,10 @@ public class Main implements ProblemSeverities, SuffixConstants {
 			int globalErrorsCount, int globalWarningsCount, int globalTasksCount) {
 			if ((this.tagBits & Logger.XML) != 0) {
 				// generate xml
-				this.parameters.put(Logger.NUMBER_OF_PROBLEMS, new Integer(globalProblemsCount));
-				this.parameters.put(Logger.NUMBER_OF_ERRORS, new Integer(globalErrorsCount));
-				this.parameters.put(Logger.NUMBER_OF_WARNINGS, new Integer(globalWarningsCount));
-				this.parameters.put(Logger.NUMBER_OF_TASKS, new Integer(globalTasksCount));
+				this.parameters.put(Logger.NUMBER_OF_PROBLEMS, Integer.valueOf(globalProblemsCount));
+				this.parameters.put(Logger.NUMBER_OF_ERRORS, Integer.valueOf(globalErrorsCount));
+				this.parameters.put(Logger.NUMBER_OF_WARNINGS, Integer.valueOf(globalWarningsCount));
+				this.parameters.put(Logger.NUMBER_OF_TASKS, Integer.valueOf(globalTasksCount));
 				printTag(Logger.PROBLEM_SUMMARY, this.parameters, true, true);
 			}
 			if (globalProblemsCount == 1) {
@@ -959,9 +959,9 @@ public class Main implements ProblemSeverities, SuffixConstants {
 			long time = compilerStats.elapsedTime();
 			long lineCount = compilerStats.lineCount;
 			if ((this.tagBits & Logger.XML) != 0) {
-				this.parameters.put(Logger.VALUE, new Long(time));
+				this.parameters.put(Logger.VALUE, Long.valueOf(time));
 				printTag(Logger.TIME, this.parameters, true, true);
-				this.parameters.put(Logger.VALUE, new Long(lineCount));
+				this.parameters.put(Logger.VALUE, Long.valueOf(lineCount));
 				printTag(Logger.NUMBER_OF_LINES, this.parameters, true, true);
 			}
 			if (lineCount != 0) {
@@ -1049,9 +1049,9 @@ public class Main implements ProblemSeverities, SuffixConstants {
 			final int sourceEnd = problem.getSourceEnd();
 			boolean isError = problem.isError();
 			this.parameters.put(Logger.PROBLEM_SEVERITY, isError ? Logger.ERROR : Logger.WARNING);
-			this.parameters.put(Logger.PROBLEM_LINE, new Integer(problem.getSourceLineNumber()));
-			this.parameters.put(Logger.PROBLEM_SOURCE_START, new Integer(sourceStart));
-			this.parameters.put(Logger.PROBLEM_SOURCE_END, new Integer(sourceEnd));
+			this.parameters.put(Logger.PROBLEM_LINE, Integer.valueOf(problem.getSourceLineNumber()));
+			this.parameters.put(Logger.PROBLEM_SOURCE_START, Integer.valueOf(sourceStart));
+			this.parameters.put(Logger.PROBLEM_SOURCE_END, Integer.valueOf(sourceEnd));
 			printTag(Logger.EXTRA_PROBLEM_TAG, this.parameters, true, false);
 			this.parameters.put(Logger.VALUE, problem.getMessage());
 			printTag(Logger.PROBLEM_MESSAGE, this.parameters, true, true);
@@ -1069,19 +1069,19 @@ public class Main implements ProblemSeverities, SuffixConstants {
 			final int sourceEnd = problem.getSourceEnd();
 			final int id = problem.getID();
 			this.parameters.put(Logger.ID, getFieldName(id)); // ID as field name
-			this.parameters.put(Logger.PROBLEM_ID, new Integer(id)); // ID as numeric value
+			this.parameters.put(Logger.PROBLEM_ID, Integer.valueOf(id)); // ID as numeric value
 			boolean isError = problem.isError();
 			int severity = isError ? ProblemSeverities.Error : ProblemSeverities.Warning;
 			this.parameters.put(Logger.PROBLEM_SEVERITY, isError ? Logger.ERROR : Logger.WARNING);
-			this.parameters.put(Logger.PROBLEM_LINE, new Integer(problem.getSourceLineNumber()));
-			this.parameters.put(Logger.PROBLEM_SOURCE_START, new Integer(sourceStart));
-			this.parameters.put(Logger.PROBLEM_SOURCE_END, new Integer(sourceEnd));
+			this.parameters.put(Logger.PROBLEM_LINE, Integer.valueOf(problem.getSourceLineNumber()));
+			this.parameters.put(Logger.PROBLEM_SOURCE_START, Integer.valueOf(sourceStart));
+			this.parameters.put(Logger.PROBLEM_SOURCE_END, Integer.valueOf(sourceEnd));
 			String problemOptionKey = getProblemOptionKey(id);
 			if (problemOptionKey != null) {
 				this.parameters.put(Logger.PROBLEM_OPTION_KEY, problemOptionKey);
 			}
 			int categoryID = ProblemReporter.getProblemCategory(severity, id);
-			this.parameters.put(Logger.PROBLEM_CATEGORY_ID, new Integer(categoryID));
+			this.parameters.put(Logger.PROBLEM_CATEGORY_ID, Integer.valueOf(categoryID));
 			printTag(Logger.PROBLEM_TAG, this.parameters, true, false);
 			this.parameters.put(Logger.VALUE, problem.getMessage());
 			printTag(Logger.PROBLEM_MESSAGE, this.parameters, true, true);
@@ -1105,9 +1105,9 @@ public class Main implements ProblemSeverities, SuffixConstants {
 		 *            the given unit source
 		 */
 		private void logXmlTask(CategorizedProblem problem, char[] unitSource) {
-			this.parameters.put(Logger.PROBLEM_LINE, new Integer(problem.getSourceLineNumber()));
-			this.parameters.put(Logger.PROBLEM_SOURCE_START, new Integer(problem.getSourceStart()));
-			this.parameters.put(Logger.PROBLEM_SOURCE_END, new Integer(problem.getSourceEnd()));
+			this.parameters.put(Logger.PROBLEM_LINE, Integer.valueOf(problem.getSourceLineNumber()));
+			this.parameters.put(Logger.PROBLEM_SOURCE_START, Integer.valueOf(problem.getSourceStart()));
+			this.parameters.put(Logger.PROBLEM_SOURCE_END, Integer.valueOf(problem.getSourceEnd()));
 			String problemOptionKey = getProblemOptionKey(problem.getID());
 			if (problemOptionKey != null) {
 				this.parameters.put(Logger.PROBLEM_OPTION_KEY, problemOptionKey);
@@ -1222,7 +1222,7 @@ public class Main implements ProblemSeverities, SuffixConstants {
 			}
 		}
 		private void startLoggingExtraProblems(int count) {
-			this.parameters.put(Logger.NUMBER_OF_PROBLEMS, new Integer(count));
+			this.parameters.put(Logger.NUMBER_OF_PROBLEMS, Integer.valueOf(count));
 			printTag(Logger.EXTRA_PROBLEMS, this.parameters, true, false);
 		}
 
@@ -1231,9 +1231,9 @@ public class Main implements ProblemSeverities, SuffixConstants {
 		 * Only use in xml mode.
 		 */
 		private void startLoggingProblems(int errors, int warnings) {
-			this.parameters.put(Logger.NUMBER_OF_PROBLEMS, new Integer(errors + warnings));
-			this.parameters.put(Logger.NUMBER_OF_ERRORS, new Integer(errors));
-			this.parameters.put(Logger.NUMBER_OF_WARNINGS, new Integer(warnings));
+			this.parameters.put(Logger.NUMBER_OF_PROBLEMS, Integer.valueOf(errors + warnings));
+			this.parameters.put(Logger.NUMBER_OF_ERRORS, Integer.valueOf(errors));
+			this.parameters.put(Logger.NUMBER_OF_WARNINGS, Integer.valueOf(warnings));
 			printTag(Logger.PROBLEMS, this.parameters, true, false);
 		}
 
@@ -1277,7 +1277,7 @@ public class Main implements ProblemSeverities, SuffixConstants {
 
 		public void startLoggingTasks(int tasks) {
 			if ((this.tagBits & Logger.XML) != 0) {
-				this.parameters.put(Logger.NUMBER_OF_TASKS, new Integer(tasks));
+				this.parameters.put(Logger.NUMBER_OF_TASKS, Integer.valueOf(tasks));
 				printTag(Logger.TASKS, this.parameters, true, false);
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index fe6d81e..fddc2d1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -5354,7 +5354,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 	private List filterFakeFrames(Set realJumpTargets, Map frames, int codeLength) {
 		// no more frame to generate
 		// filter out "fake" frames
-		realJumpTargets.remove(new Integer(codeLength));
+		realJumpTargets.remove(Integer.valueOf(codeLength));
 		List result = new ArrayList();
 		for (Iterator iterator = realJumpTargets.iterator(); iterator.hasNext(); ) {
 			Integer jumpTarget = (Integer) iterator.next();
@@ -6672,8 +6672,8 @@ public class ClassFile implements TypeConstants, TypeIds {
 								Messages.bind(
 										Messages.abort_invalidOpcode,
 										new Object[] {
-												new Byte(opcode),
-												new Integer(pc),
+												Byte.valueOf(opcode),
+												Integer.valueOf(pc),
 												new String(methodBinding.shortReadableName()),
 										}),
 										this.codeStream.methodDeclaration);
@@ -6682,8 +6682,8 @@ public class ClassFile implements TypeConstants, TypeIds {
 								Messages.bind(
 										Messages.abort_invalidOpcode,
 										new Object[] {
-												new Byte(opcode),
-												new Integer(pc),
+												Byte.valueOf(opcode),
+												Integer.valueOf(pc),
 												new String(methodBinding.shortReadableName()),
 										}),
 										this.codeStream.lambdaExpression);
@@ -6698,10 +6698,10 @@ public class ClassFile implements TypeConstants, TypeIds {
 	}
 
 	private void addRealJumpTarget(Set realJumpTarget, int pc) {
-		realJumpTarget.add(new Integer(pc));
+		realJumpTarget.add(Integer.valueOf(pc));
 	}
 	private void add(Map frames, StackMapFrame frame) {
-		frames.put(new Integer(frame.pc), frame);
+		frames.put(Integer.valueOf(frame.pc), frame);
 	}
 	private final int u1At(byte[] reference, int relativeOffset,
 			int structOffset) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ProcessTaskManager.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ProcessTaskManager.java
index be99442..db3c919 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ProcessTaskManager.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ProcessTaskManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2015 IBM Corporation and others.
+ * Copyright (c) 2008, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -49,7 +49,7 @@ public ProcessTaskManager(Compiler compiler, int startingIndex) {
 private synchronized void addNextUnit(CompilationUnitDeclaration newElement) {
 	while (this.units[this.availableIndex] != null) {
 		//System.out.print('a');
-		//if (this.sleepCount < 0) throw new IllegalStateException(new Integer(this.sleepCount).toString());
+		//if (this.sleepCount < 0) throw new IllegalStateException(Integer.valueOf(this.sleepCount).toString());
 		this.sleepCount = 1;
 		try {
 			wait(250);
@@ -83,7 +83,7 @@ public CompilationUnitDeclaration removeNextUnit() throws Error {
 					return null;
 				}
 				//System.out.print('r');
-				//if (this.sleepCount > 0) throw new IllegalStateException(new Integer(this.sleepCount).toString());
+				//if (this.sleepCount > 0) throw new IllegalStateException(Integer.valueOf(this.sleepCount).toString());
 				this.sleepCount = -1;
 				try {
 					wait(100);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
index 1a1f787..25d3c21 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2015 GK Software AG and others.
+ * Copyright (c) 2011, 2016 GK Software AG and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -900,7 +900,7 @@ public class FakedTrackingVariable extends LocalDeclaration {
 		}
 		if (this.recordedLocations == null)
 			this.recordedLocations = new HashMap();
-		this.recordedLocations.put(location, new Integer(nullStatus));
+		this.recordedLocations.put(location, Integer.valueOf(nullStatus));
 	}
 
 	public boolean reportRecordedErrors(Scope scope, int mergedStatus, boolean atDeadEnd) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
index fbcf5c1..039f3a4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/FieldInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -253,16 +253,16 @@ public Object getWrappedConstantValue() {
 			Constant fieldConstant = getConstant();
 			switch (fieldConstant.typeID()) {
 				case TypeIds.T_int :
-					this.wrappedConstantValue = new Integer(fieldConstant.intValue());
+					this.wrappedConstantValue = Integer.valueOf(fieldConstant.intValue());
 					break;
 				case TypeIds.T_byte :
-					this.wrappedConstantValue = new Byte(fieldConstant.byteValue());
+					this.wrappedConstantValue = Byte.valueOf(fieldConstant.byteValue());
 					break;
 				case TypeIds.T_short :
-					this.wrappedConstantValue = new Short(fieldConstant.shortValue());
+					this.wrappedConstantValue = Short.valueOf(fieldConstant.shortValue());
 					break;
 				case TypeIds.T_char :
-					this.wrappedConstantValue = new Character(fieldConstant.charValue());
+					this.wrappedConstantValue = Character.valueOf(fieldConstant.charValue());
 					break;
 				case TypeIds.T_float :
 					this.wrappedConstantValue = new Float(fieldConstant.floatValue());
@@ -274,7 +274,7 @@ public Object getWrappedConstantValue() {
 					this.wrappedConstantValue = Util.toBoolean(fieldConstant.booleanValue());
 					break;
 				case TypeIds.T_long :
-					this.wrappedConstantValue = new Long(fieldConstant.longValue());
+					this.wrappedConstantValue = Long.valueOf(fieldConstant.longValue());
 					break;
 				case TypeIds.T_JavaLangString :
 					this.wrappedConstantValue = fieldConstant.stringValue();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
index 1d916e9..448a720 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
@@ -2531,7 +2531,7 @@ public void generateSyntheticBodyForDeserializeLambda(SyntheticMethodBinding met
 		if (syntheticMethodBinding.lambda!=null && syntheticMethodBinding.lambda.isSerializable ||
 				syntheticMethodBinding.serializableMethodRef != null) {
 			// TODO can I use > Java 1.4 features here?
-			Integer hashcode = new Integer(new String(syntheticMethodBinding.selector).hashCode());
+			Integer hashcode = Integer.valueOf(new String(syntheticMethodBinding.selector).hashCode());
 			List syntheticssForThisHashcode = (List)hashcodesTosynthetics.get(hashcode);
 			if (syntheticssForThisHashcode==null) {
 				syntheticssForThisHashcode = new ArrayList();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/StackMapFrameCodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/StackMapFrameCodeStream.java
index 08416a0..6f2630c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/StackMapFrameCodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/StackMapFrameCodeStream.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2013 IBM Corporation and others.
+ * Copyright (c) 2006, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -204,7 +204,7 @@ public void addExceptionMarker(int pc, TypeBinding typeBinding) {
 	}
 }
 public void addFramePosition(int pc) {
-	Integer newEntry = new Integer(pc);
+	Integer newEntry = Integer.valueOf(pc);
 	FramePosition value;
 	if ((value = (FramePosition) this.framePositions.get(newEntry)) != null) {
 		value.counter++;
@@ -217,7 +217,7 @@ public void optimizeBranch(int oldPosition, BranchLabel lbl) {
 	removeFramePosition(oldPosition);
 }
 public void removeFramePosition(int pc) {
-	Integer entry = new Integer(pc);
+	Integer entry = Integer.valueOf(pc);
 	FramePosition value;
 	if ((value = (FramePosition) this.framePositions.get(entry)) != null) {
 		value.counter--;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index c42ca52..73e9b9d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1674,7 +1674,7 @@ public abstract class ASTNode {
 			SimplePropertyDescriptor p = (SimplePropertyDescriptor) property;
 			if (p.getValueType() == int.class) {
 				int result = internalGetSetIntProperty(p, true, 0);
-				return new Integer(result);
+				return Integer.valueOf(result);
 			} else if (p.getValueType() == boolean.class) {
 				boolean result = internalGetSetBooleanProperty(p, true, false);
 				return Boolean.valueOf(result);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
index 5e551ad..6e07687 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -645,14 +645,14 @@ class DefaultBindingResolver extends BindingResolver {
 			Constant constant = compilerExpression.constant;
 			if (constant != null && constant != Constant.NotAConstant) {
 				switch (constant.typeID()) {
-					case TypeIds.T_int : return new Integer(constant.intValue());
-					case TypeIds.T_byte : return new Byte(constant.byteValue());
-					case TypeIds.T_short : return new Short(constant.shortValue());
-					case TypeIds.T_char : return new Character(constant.charValue());
+					case TypeIds.T_int : return Integer.valueOf(constant.intValue());
+					case TypeIds.T_byte : return Byte.valueOf(constant.byteValue());
+					case TypeIds.T_short : return Short.valueOf(constant.shortValue());
+					case TypeIds.T_char : return Character.valueOf(constant.charValue());
 					case TypeIds.T_float : return new Float(constant.floatValue());
 					case TypeIds.T_double : return new Double(constant.doubleValue());
 					case TypeIds.T_boolean : return constant.booleanValue() ? Boolean.TRUE : Boolean.FALSE;
-					case TypeIds.T_long : return new Long(constant.longValue());
+					case TypeIds.T_long : return Long.valueOf(constant.longValue());
 					case TypeIds.T_JavaLangString : return constant.stringValue();
 				}
 				return null;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MemberValuePairBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MemberValuePairBinding.java
index cfd8640..6a95af2 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MemberValuePairBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MemberValuePairBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2011 BEA Systems, Inc.
+ * Copyright (c) 2005, 2016 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -60,19 +60,19 @@ class MemberValuePairBinding implements IMemberValuePairBinding {
 				case TypeIds.T_boolean:
 					return Boolean.valueOf(constant.booleanValue());
 				case TypeIds.T_byte:
-					return new Byte(constant.byteValue());
+					return Byte.valueOf(constant.byteValue());
 				case TypeIds.T_char:
-					return new Character(constant.charValue());
+					return Character.valueOf(constant.charValue());
 				case TypeIds.T_double:
 					return new Double(constant.doubleValue());
 				case TypeIds.T_float:
 					return new Float(constant.floatValue());
 				case TypeIds.T_int:
-					return new Integer(constant.intValue());
+					return Integer.valueOf(constant.intValue());
 				case TypeIds.T_long:
-					return new Long(constant.longValue());
+					return Long.valueOf(constant.longValue());
 				case TypeIds.T_short:
-					return new Short(constant.shortValue());
+					return Short.valueOf(constant.shortValue());
 				default:
 					// TypeIds.T_JavaLangString:
 					return constant.stringValue();
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
index d6e5390..85c436f 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -89,19 +89,19 @@ class VariableBinding implements IVariableBinding {
 			case TypeIds.T_boolean:
 				return Boolean.valueOf(c.booleanValue());
 			case TypeIds.T_byte:
-				return new Byte(c.byteValue());
+				return Byte.valueOf(c.byteValue());
 			case TypeIds.T_char:
-				return new Character(c.charValue());
+				return Character.valueOf(c.charValue());
 			case TypeIds.T_double:
 				return new Double(c.doubleValue());
 			case TypeIds.T_float:
 				return new Float(c.floatValue());
 			case TypeIds.T_int:
-				return new Integer(c.intValue());
+				return Integer.valueOf(c.intValue());
 			case TypeIds.T_long:
-				return new Long(c.longValue());
+				return Long.valueOf(c.longValue());
 			case TypeIds.T_short:
-				return new Short(c.shortValue());
+				return Short.valueOf(c.shortValue());
 			case TypeIds.T_JavaLangString:
 				return c.stringValue();
 		}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
index 765a32c..cfe425b 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1009,7 +1009,7 @@ public final class ImportRewrite {
 			context= this.defaultContext;
 		}
 		int kind= isField ? ImportRewriteContext.KIND_STATIC_FIELD : ImportRewriteContext.KIND_STATIC_METHOD;
-		this.importsKindMap.put(key, new Integer(kind));
+		this.importsKindMap.put(key, Integer.valueOf(kind));
 		int res= context.findInContext(declaringTypeName, simpleName, kind);
 		if (res == ImportRewriteContext.RES_NAME_CONFLICT) {
 			return key;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ToolFactory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ToolFactory.java
index 8984deb..4f78528 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ToolFactory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ToolFactory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -72,7 +72,7 @@ public class ToolFactory {
 	 * @see #createCodeFormatter(Map, int)
 	 * @since 3.3
 	 */
-	public static final int M_FORMAT_NEW = new Integer(0).intValue();
+	public static final int M_FORMAT_NEW = 0;
 
 	/**
 	 * This mode is used for formatting existing code when all formatter options should be used.
@@ -85,7 +85,7 @@ public class ToolFactory {
 	 * @see #createCodeFormatter(Map, int)
 	 * @since 3.3
 	 */
-	public static final int M_FORMAT_EXISTING = new Integer(1).intValue();
+	public static final int M_FORMAT_EXISTING = 1;
 
 	/**
 	 * Create an instance of a code formatter. A code formatter implementation can be contributed via the
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessingState.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessingState.java
index 0d495e6..d5a8569 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessingState.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessingState.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -499,7 +499,7 @@ public class DeltaProcessingState implements IResourceChangeListener {
 				while (size-- > 0) {
 					String key = in.readUTF();
 					long timestamp = in.readLong();
-					timeStamps.put(Path.fromPortableString(key), new Long(timestamp));
+					timeStamps.put(Path.fromPortableString(key), Long.valueOf(timestamp));
 				}
 			} catch (IOException e) {
 				if (timestampsFile.exists())
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
index 9d912ad..18f5b75 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -976,7 +976,7 @@ public class DeltaProcessor {
 
 								} else if (oldTimestamp.longValue() != newTimeStamp){
 									externalArchivesStatus.put(entryPath, EXTERNAL_JAR_CHANGED);
-									this.state.getExternalLibTimeStamps().put(entryPath, new Long(newTimeStamp));
+									this.state.getExternalLibTimeStamps().put(entryPath, Long.valueOf(newTimeStamp));
 									// first remove the index so that it is forced to be re-indexed
 									this.manager.indexManager.removeIndex(entryPath);
 									// then index the jar
@@ -993,7 +993,7 @@ public class DeltaProcessor {
 									externalArchivesStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);
 								} else {
 									externalArchivesStatus.put(entryPath, EXTERNAL_JAR_ADDED);
-									this.state.getExternalLibTimeStamps().put(entryPath, new Long(newTimeStamp));
+									this.state.getExternalLibTimeStamps().put(entryPath, Long.valueOf(newTimeStamp));
 									// index the new jar
 									this.manager.indexManager.removeIndex(entryPath);
 									this.manager.indexManager.indexLibrary(entryPath, project.getProject(), ((ClasspathEntry)entries[j]).getLibraryIndexLocation());
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index da4de00..594699e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1268,7 +1268,7 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 						Object target = JavaModel.getExternalTarget(path, true);
 						if (target instanceof File) {
 							long timestamp = DeltaProcessor.getTimeStamp((java.io.File)target);
-							externalTimeStamps.put(path, new Long(timestamp));
+							externalTimeStamps.put(path, Long.valueOf(timestamp));
 						}
 					}
 				}
@@ -4402,8 +4402,8 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 
 	private void traceVariableAndContainers(String action, long start) {
 
-		Long delta = new Long(System.currentTimeMillis() - start);
-		Long length = new Long(getVariableAndContainersFile().length());
+		Long delta = Long.valueOf(System.currentTimeMillis() - start);
+		Long length = Long.valueOf(getVariableAndContainersFile().length());
 		String pattern = "{0} {1} bytes in variablesAndContainers.dat in {2}ms"; //$NON-NLS-1$
 		String message = MessageFormat.format(pattern, new Object[]{action, length, delta});
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
index 13cfffb..02e6460 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -871,14 +871,14 @@ public class JavaProject
 				},
 				new Object[] {
 					status.getMessage(),
-					new Integer(severity),
+					Integer.valueOf(severity),
 					Messages.classpath_buildPath,
 					isCycleProblem ? "true" : "false",//$NON-NLS-1$ //$NON-NLS-2$
 					isClasspathFileFormatProblem ? "true" : "false",//$NON-NLS-1$ //$NON-NLS-2$
 					isOutputOverlapping ? "true" : "false", //$NON-NLS-1$ //$NON-NLS-2$
-					new Integer(status.getCode()),
+					Integer.valueOf(status.getCode()),
 					Util.getProblemArgumentsForMarker(arguments) ,
-					new Integer(CategorizedProblem.CAT_BUILDPATH),
+					Integer.valueOf(CategorizedProblem.CAT_BUILDPATH),
 					JavaBuilder.SOURCE_ID,
 				}
 			);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
index 10ce6ea..d03a5be 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Member.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -69,19 +69,19 @@ protected static Object convertConstant(Constant constant) {
 		case TypeIds.T_boolean :
 			return constant.booleanValue() ? Boolean.TRUE : Boolean.FALSE;
 		case TypeIds.T_byte :
-			return new Byte(constant.byteValue());
+			return Byte.valueOf(constant.byteValue());
 		case TypeIds.T_char :
-			return new Character(constant.charValue());
+			return Character.valueOf(constant.charValue());
 		case TypeIds.T_double :
 			return new Double(constant.doubleValue());
 		case TypeIds.T_float :
 			return new Float(constant.floatValue());
 		case TypeIds.T_int :
-			return new Integer(constant.intValue());
+			return Integer.valueOf(constant.intValue());
 		case TypeIds.T_long :
-			return new Long(constant.longValue());
+			return Long.valueOf(constant.longValue());
 		case TypeIds.T_short :
-			return new Short(constant.shortValue());
+			return Short.valueOf(constant.shortValue());
 		case TypeIds.T_JavaLangString :
 			return constant.stringValue();
 		default :
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SortElementsOperation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SortElementsOperation.java
index f0bbcef..b8e3580 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SortElementsOperation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SortElementsOperation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -194,7 +194,7 @@ public class SortElementsOperation extends JavaModelOperation {
 				boolean contains_malformed_nodes = false;
 				for (Iterator iter = types.iterator(); iter.hasNext();) {
 					AbstractTypeDeclaration typeDeclaration = (AbstractTypeDeclaration) iter.next();
-					typeDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(typeDeclaration.getStartPosition()));
+					typeDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, Integer.valueOf(typeDeclaration.getStartPosition()));
 					contains_malformed_nodes |= Boolean.valueOf(isMalformed(typeDeclaration));
 				}
 				compilationUnit.setProperty(CONTAINS_MALFORMED_NODES, contains_malformed_nodes);
@@ -205,7 +205,7 @@ public class SortElementsOperation extends JavaModelOperation {
 				boolean contains_malformed_nodes = false;
 				for (Iterator iter = bodyDeclarations.iterator(); iter.hasNext();) {
 					BodyDeclaration bodyDeclaration = (BodyDeclaration) iter.next();
-					bodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(bodyDeclaration.getStartPosition()));
+					bodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, Integer.valueOf(bodyDeclaration.getStartPosition()));
 					contains_malformed_nodes |= Boolean.valueOf(isMalformed(bodyDeclaration));
 				}
 				annotationTypeDeclaration.setProperty(CONTAINS_MALFORMED_NODES, contains_malformed_nodes);
@@ -217,7 +217,7 @@ public class SortElementsOperation extends JavaModelOperation {
 				boolean contains_malformed_nodes = false;
 				for (Iterator iter = bodyDeclarations.iterator(); iter.hasNext();) {
 					BodyDeclaration bodyDeclaration = (BodyDeclaration) iter.next();
-					bodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(bodyDeclaration.getStartPosition()));
+					bodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, Integer.valueOf(bodyDeclaration.getStartPosition()));
 					contains_malformed_nodes |= Boolean.valueOf(isMalformed(bodyDeclaration));
 				}
 				anonymousClassDeclaration.setProperty(CONTAINS_MALFORMED_NODES, contains_malformed_nodes);
@@ -229,7 +229,7 @@ public class SortElementsOperation extends JavaModelOperation {
 				boolean contains_malformed_nodes = false;
 				for (Iterator iter = bodyDeclarations.iterator(); iter.hasNext();) {
 					BodyDeclaration bodyDeclaration = (BodyDeclaration) iter.next();
-					bodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(bodyDeclaration.getStartPosition()));
+					bodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, Integer.valueOf(bodyDeclaration.getStartPosition()));
 					contains_malformed_nodes |= Boolean.valueOf(isMalformed(bodyDeclaration));
 				}
 				typeDeclaration.setProperty(CONTAINS_MALFORMED_NODES, contains_malformed_nodes);
@@ -241,13 +241,13 @@ public class SortElementsOperation extends JavaModelOperation {
 				boolean contains_malformed_nodes = false;
 				for (Iterator iter = bodyDeclarations.iterator(); iter.hasNext();) {
 					BodyDeclaration bodyDeclaration = (BodyDeclaration) iter.next();
-					bodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(bodyDeclaration.getStartPosition()));
+					bodyDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, Integer.valueOf(bodyDeclaration.getStartPosition()));
 					contains_malformed_nodes |= Boolean.valueOf(isMalformed(bodyDeclaration));
 				}
 				List enumConstants = enumDeclaration.enumConstants();
 				for (Iterator iter = enumConstants.iterator(); iter.hasNext();) {
 					EnumConstantDeclaration enumConstantDeclaration = (EnumConstantDeclaration) iter.next();
-					enumConstantDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, new Integer(enumConstantDeclaration.getStartPosition()));
+					enumConstantDeclaration.setProperty(CompilationUnitSorter.RELATIVE_ORDER, Integer.valueOf(enumConstantDeclaration.getStartPosition()));
 					contains_malformed_nodes |= Boolean.valueOf(isMalformed(enumConstantDeclaration));
 				}
 				enumDeclaration.setProperty(CONTAINS_MALFORMED_NODES, contains_malformed_nodes);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceField.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceField.java
index 0634cf1..bff0df4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceField.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceField.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -56,18 +56,18 @@ public Object getConstant() throws JavaModelException {
 	String signature = info.getTypeSignature();
 	try {
 		if (signature.equals(Signature.SIG_INT)) {
-			constant = new Integer(constantSource);
+			constant = Integer.valueOf(constantSource);
 		} else if (signature.equals(Signature.SIG_SHORT)) {
-			constant = new Short(constantSource);
+			constant = Short.valueOf(constantSource);
 		} else if (signature.equals(Signature.SIG_BYTE)) {
-			constant = new Byte(constantSource);
+			constant = Byte.valueOf(constantSource);
 		} else if (signature.equals(Signature.SIG_BOOLEAN)) {
 			constant = Boolean.valueOf(constantSource);
 		} else if (signature.equals(Signature.SIG_CHAR)) {
 			if (constantSourceChars.length != 3) {
 				return null;
 			}
-			constant = new Character(constantSourceChars[1]);
+			constant = Character.valueOf(constantSourceChars[1]);
 		} else if (signature.equals(Signature.SIG_DOUBLE)) {
 			constant = new Double(constantSource);
 		} else if (signature.equals(Signature.SIG_FLOAT)) {
@@ -76,12 +76,12 @@ public Object getConstant() throws JavaModelException {
 			if (constantSource.endsWith("L") || constantSource.endsWith("l")) { //$NON-NLS-1$ //$NON-NLS-2$
 				int index = constantSource.lastIndexOf("L");//$NON-NLS-1$
 				if (index != -1) {
-					constant = new Long(constantSource.substring(0, index));
+					constant = Long.valueOf(constantSource.substring(0, index));
 				} else {
-					constant = new Long(constantSource.substring(0, constantSource.lastIndexOf("l")));//$NON-NLS-1$
+					constant = Long.valueOf(constantSource.substring(0, constantSource.lastIndexOf("l")));//$NON-NLS-1$
 				}
 			} else {
-				constant = new Long(constantSource);
+				constant = Long.valueOf(constantSource);
 			}
 		} else if (signature.equals("QString;")) {//$NON-NLS-1$
 			constant = constantSource;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
index 6be7c79..e950a9c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -328,7 +328,7 @@ public class SourceMapper
 		}
 		imports[importsCounter++] = name;
 		this.importsTable.put(this.binaryType, imports);
-		this.importsCounterTable.put(this.binaryType, new Integer(importsCounter));
+		this.importsCounterTable.put(this.binaryType, Integer.valueOf(importsCounter));
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
index ea5bc06..ac2dc19 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -80,12 +80,12 @@ public final static String[] JAVA_TASK_MARKER_ATTRIBUTE_NAMES = {
 	IMarker.USER_EDITABLE,
 	IMarker.SOURCE_ID,
 };
-public final static Integer S_ERROR = new Integer(IMarker.SEVERITY_ERROR);
-public final static Integer S_WARNING = new Integer(IMarker.SEVERITY_WARNING);
-public final static Integer S_INFO = new Integer(IMarker.SEVERITY_INFO);
-public final static Integer P_HIGH = new Integer(IMarker.PRIORITY_HIGH);
-public final static Integer P_NORMAL = new Integer(IMarker.PRIORITY_NORMAL);
-public final static Integer P_LOW = new Integer(IMarker.PRIORITY_LOW);
+public final static Integer S_ERROR = Integer.valueOf(IMarker.SEVERITY_ERROR);
+public final static Integer S_WARNING = Integer.valueOf(IMarker.SEVERITY_WARNING);
+public final static Integer S_INFO = Integer.valueOf(IMarker.SEVERITY_INFO);
+public final static Integer P_HIGH = Integer.valueOf(IMarker.PRIORITY_HIGH);
+public final static Integer P_NORMAL = Integer.valueOf(IMarker.PRIORITY_NORMAL);
+public final static Integer P_LOW = Integer.valueOf(IMarker.PRIORITY_LOW);
 
 protected AbstractImageBuilder(JavaBuilder javaBuilder, boolean buildStarting, State newState) {
 	// local copies
@@ -414,7 +414,7 @@ protected void createProblemFor(IResource resource, IMember javaElement, String
 		int end = range == null ? 1 : start + range.getLength();
 		marker.setAttributes(
 			new String[] {IMarker.MESSAGE, IMarker.SEVERITY, IMarker.CHAR_START, IMarker.CHAR_END, IMarker.SOURCE_ID},
-			new Object[] {message, new Integer(severity), new Integer(start), new Integer(end), JavaBuilder.SOURCE_ID});
+			new Object[] {message, Integer.valueOf(severity), Integer.valueOf(start), Integer.valueOf(end), JavaBuilder.SOURCE_ID});
 	} catch (CoreException e) {
 		throw internalException(e);
 	}
@@ -699,8 +699,8 @@ protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] prob
 				new String[] {IMarker.MESSAGE, IMarker.SEVERITY, IJavaModelMarker.CATEGORY_ID, IMarker.SOURCE_ID},
 				new Object[] {
 					Messages.bind(Messages.build_incompleteClassPath, missingClassfileName),
-					new Integer(isInvalidClasspathError ? IMarker.SEVERITY_ERROR : IMarker.SEVERITY_WARNING),
-					new Integer(CategorizedProblem.CAT_BUILDPATH),
+					Integer.valueOf(isInvalidClasspathError ? IMarker.SEVERITY_ERROR : IMarker.SEVERITY_WARNING),
+					Integer.valueOf(CategorizedProblem.CAT_BUILDPATH),
 					JavaBuilder.SOURCE_ID
 				}
 			);
@@ -765,12 +765,12 @@ protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] prob
 			int index = 0;
 			allValues[index++] = problem.getMessage(); // message
 			allValues[index++] = problem.isError() ? S_ERROR : problem.isWarning() ? S_WARNING : S_INFO; // severity
-			allValues[index++] = new Integer(id); // ID
-			allValues[index++] = new Integer(problem.getSourceStart()); // start
-			allValues[index++] = new Integer(problem.getSourceEnd() + 1); // end
-			allValues[index++] = new Integer(problem.getSourceLineNumber()); // line
+			allValues[index++] = Integer.valueOf(id); // ID
+			allValues[index++] = Integer.valueOf(problem.getSourceStart()); // start
+			allValues[index++] = Integer.valueOf(problem.getSourceEnd() + 1); // end
+			allValues[index++] = Integer.valueOf(problem.getSourceLineNumber()); // line
 			allValues[index++] = Util.getProblemArgumentsForMarker(problem.getArguments()); // arguments
-			allValues[index++] = new Integer(problem.getCategoryID()); // category ID
+			allValues[index++] = Integer.valueOf(problem.getCategoryID()); // category ID
 			// SOURCE_ID attribute for JDT problems
 			if (managedLength > 0)
 				allValues[index++] = JavaBuilder.SOURCE_ID;
@@ -816,10 +816,10 @@ protected void storeTasksFor(SourceFile sourceFile, CategorizedProblem[] tasks)
 			int index = 0;
 			allValues[index++] = task.getMessage();
 			allValues[index++] = priority;
-			allValues[index++] = new Integer(task.getID());
-			allValues[index++] = new Integer(task.getSourceStart());
-			allValues[index++] = new Integer(task.getSourceEnd() + 1);
-			allValues[index++] = new Integer(task.getSourceLineNumber());
+			allValues[index++] = Integer.valueOf(task.getID());
+			allValues[index++] = Integer.valueOf(task.getSourceStart());
+			allValues[index++] = Integer.valueOf(task.getSourceEnd() + 1);
+			allValues[index++] = Integer.valueOf(task.getSourceLineNumber());
 			allValues[index++] = Boolean.FALSE;
 			allValues[index++] = JavaBuilder.SOURCE_ID;
 			// optional extra attributes
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java
index c919e79..451caed 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -226,7 +226,7 @@ protected IProject[] build(int kind, Map ignored, IProgressMonitor monitor) thro
 			new String[] {IMarker.MESSAGE, IMarker.SEVERITY, IMarker.SOURCE_ID},
 			new Object[] {
 				Messages.bind(Messages.build_missingSourceFile, e.missingSourceFile),
-				new Integer(IMarker.SEVERITY_ERROR),
+				Integer.valueOf(IMarker.SEVERITY_ERROR),
 				JavaBuilder.SOURCE_ID
 			}
 		);
@@ -319,8 +319,8 @@ private void createInconsistentBuildMarker(CoreException coreException) throws C
 		new String[] {IMarker.MESSAGE, IMarker.SEVERITY, IJavaModelMarker.CATEGORY_ID, IMarker.SOURCE_ID},
 		new Object[] {
 			Messages.bind(Messages.build_inconsistentProject, message),
-			new Integer(IMarker.SEVERITY_ERROR),
-			new Integer(CategorizedProblem.CAT_BUILDPATH),
+			Integer.valueOf(IMarker.SEVERITY_ERROR),
+			Integer.valueOf(CategorizedProblem.CAT_BUILDPATH),
 			JavaBuilder.SOURCE_ID
 		}
 	);
@@ -671,8 +671,8 @@ private boolean isWorthBuilding() throws CoreException {
 			new String[] {IMarker.MESSAGE, IMarker.SEVERITY, IJavaModelMarker.CATEGORY_ID, IMarker.SOURCE_ID},
 			new Object[] {
 				Messages.build_abortDueToClasspathProblems,
-				new Integer(IMarker.SEVERITY_ERROR),
-				new Integer(CategorizedProblem.CAT_BUILDPATH),
+				Integer.valueOf(IMarker.SEVERITY_ERROR),
+				Integer.valueOf(CategorizedProblem.CAT_BUILDPATH),
 				JavaBuilder.SOURCE_ID
 			}
 		);
@@ -714,8 +714,8 @@ private boolean isWorthBuilding() throws CoreException {
 					isClasspathBroken(prereq, true)
 						? Messages.bind(Messages.build_prereqProjectHasClasspathProblems, p.getName())
 						: Messages.bind(Messages.build_prereqProjectMustBeRebuilt, p.getName()),
-					new Integer(IMarker.SEVERITY_ERROR),
-					new Integer(CategorizedProblem.CAT_BUILDPATH),
+					Integer.valueOf(IMarker.SEVERITY_ERROR),
+					Integer.valueOf(CategorizedProblem.CAT_BUILDPATH),
 					JavaBuilder.SOURCE_ID
 				}
 			);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
index c28e5c3..f7fb9fb 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
@@ -193,7 +193,7 @@ void recordLocatorForType(String qualifiedTypeName, String typeLocator) {
 void recordStructuralDependency(IProject prereqProject, State prereqState) {
 	if (prereqState != null)
 		if (prereqState.lastStructuralBuildTime > 0) // can skip if 0 (full build) since its assumed to be 0 if unknown
-			this.structuralBuildTimes.put(prereqProject.getName(), new Long(prereqState.lastStructuralBuildTime));
+			this.structuralBuildTimes.put(prereqProject.getName(), Long.valueOf(prereqState.lastStructuralBuildTime));
 }
 
 void removeLocator(String typeLocatorToRemove) {
@@ -280,7 +280,7 @@ static State read(IProject project, DataInputStream in) throws IOException {
 
 	newState.structuralBuildTimes = new SimpleLookupTable(length = in.readInt());
 	for (int i = 0; i < length; i++)
-		newState.structuralBuildTimes.put(in.readUTF(), new Long(in.readLong()));
+		newState.structuralBuildTimes.put(in.readUTF(), Long.valueOf(in.readLong()));
 
 	String[] internedTypeLocators = new String[length = in.readInt()];
 	for (int i = 0; i < length; i++)
@@ -502,7 +502,7 @@ void write(DataOutputStream out) throws IOException {
 				length--;
 				String key = (String) keyTable[i];
 				out.writeUTF(key);
-				internedTypeLocators.put(key, new Integer(internedTypeLocators.elementSize));
+				internedTypeLocators.put(key, Integer.valueOf(internedTypeLocators.elementSize));
 			}
 		}
 		if (JavaBuilder.DEBUG && length != 0)
@@ -546,17 +546,17 @@ void write(DataOutputStream out) throws IOException {
 			for (int j = 0, m = rNames.length; j < m; j++) {
 				char[] rName = rNames[j];
 				if (!internedRootNames.containsKey(rName)) // remember the names have been interned
-					internedRootNames.put(rName, new Integer(internedRootNames.elementSize));
+					internedRootNames.put(rName, Integer.valueOf(internedRootNames.elementSize));
 			}
 			char[][][] qNames = collection.qualifiedNameReferences;
 			for (int j = 0, m = qNames.length; j < m; j++) {
 				char[][] qName = qNames[j];
 				if (!internedQualifiedNames.containsKey(qName)) { // remember the names have been interned
-					internedQualifiedNames.put(qName, new Integer(internedQualifiedNames.elementSize));
+					internedQualifiedNames.put(qName, Integer.valueOf(internedQualifiedNames.elementSize));
 					for (int k = 0, n = qName.length; k < n; k++) {
 						char[] sName = qName[k];
 						if (!internedSimpleNames.containsKey(sName)) // remember the names have been interned
-							internedSimpleNames.put(sName, new Integer(internedSimpleNames.elementSize));
+							internedSimpleNames.put(sName, Integer.valueOf(internedSimpleNames.elementSize));
 					}
 				}
 			}
@@ -564,7 +564,7 @@ void write(DataOutputStream out) throws IOException {
 			for (int j = 0, m = sNames.length; j < m; j++) {
 				char[] sName = sNames[j];
 				if (!internedSimpleNames.containsKey(sName)) // remember the names have been interned
-					internedSimpleNames.put(sName, new Integer(internedSimpleNames.elementSize));
+					internedSimpleNames.put(sName, Integer.valueOf(internedSimpleNames.elementSize));
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java
index 0f82b6a..e90caee 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/TypeHierarchy.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -256,7 +256,7 @@ public synchronized void addTypeHierarchyChangedListener(ITypeHierarchyChangedLi
 }
 private static Integer bytesToFlags(byte[] bytes){
 	if(bytes != null && bytes.length > 0) {
-		return new Integer(new String(bytes));
+		return Integer.valueOf(new String(bytes));
 	} else {
 		return null;
 	}
@@ -265,7 +265,7 @@ private static Integer bytesToFlags(byte[] bytes){
  * cacheFlags.
  */
 public void cacheFlags(IType type, int flags) {
-	this.typeFlags.put(type, new Integer(flags));
+	this.typeFlags.put(type, Integer.valueOf(flags));
 }
 /**
  * Caches the handle of the superclass for the specified type.
@@ -1195,11 +1195,11 @@ public static ITypeHierarchy load(IType type, InputStream input, WorkingCopyOwne
 		while((b = (byte)input.read()) != SEPARATOR1 && b != -1) {
 			bytes = readUntil(input, SEPARATOR3, 1);
 			bytes[0] = b;
-			int subClass = new Integer(new String(bytes)).intValue();
+			int subClass = Integer.parseInt(new String(bytes));
 
 			// read super type
 			bytes = readUntil(input, SEPARATOR1);
-			int superClass = new Integer(new String(bytes)).intValue();
+			int superClass = Integer.parseInt(new String(bytes));
 
 			typeHierarchy.cacheSuperclass(
 				types[subClass],
@@ -1210,7 +1210,7 @@ public static ITypeHierarchy load(IType type, InputStream input, WorkingCopyOwne
 		while((b = (byte)input.read()) != SEPARATOR1 && b != -1) {
 			bytes = readUntil(input, SEPARATOR3, 1);
 			bytes[0] = b;
-			int subClass = new Integer(new String(bytes)).intValue();
+			int subClass = Integer.parseInt(new String(bytes));
 
 			// read super interface
 			bytes = readUntil(input, SEPARATOR1);
@@ -1224,12 +1224,12 @@ public static ITypeHierarchy load(IType type, InputStream input, WorkingCopyOwne
 					b2 = new byte[i - j];
 					System.arraycopy(bytes, j, b2, 0, i - j);
 					j = i + 1;
-					superInterfaces[interfaceCount++] = types[new Integer(new String(b2)).intValue()];
+					superInterfaces[interfaceCount++] = types[Integer.parseInt(new String(b2))];
 				}
 			}
 			b2 = new byte[bytes.length - j];
 			System.arraycopy(bytes, j, b2, 0, bytes.length - j);
-			superInterfaces[interfaceCount++] = types[new Integer(new String(b2)).intValue()];
+			superInterfaces[interfaceCount++] = types[Integer.parseInt(new String(b2))];
 			System.arraycopy(superInterfaces, 0, superInterfaces = new IType[interfaceCount], 0, interfaceCount);
 
 			typeHierarchy.cacheSuperInterfaces(
@@ -1335,7 +1335,7 @@ public void store(OutputStream output, IProgressMonitor monitor) throws JavaMode
 		int count = 0;
 
 		if(this.focusType != null) {
-			Integer index = new Integer(count++);
+			Integer index = Integer.valueOf(count++);
 			hashtable.put(this.focusType, index);
 			hashtable2.put(index, this.focusType);
 		}
@@ -1344,13 +1344,13 @@ public void store(OutputStream output, IProgressMonitor monitor) throws JavaMode
 			Map.Entry<IType, IType> entry = (Map.Entry<IType, IType>) types[i];
 			IType t = entry.getKey();
 			if(hashtable.get(t) == null) {
-				Integer index = new Integer(count++);
+				Integer index = Integer.valueOf(count++);
 				hashtable.put(t, index);
 				hashtable2.put(index, t);
 			}
 			IType superClass = entry.getValue();
 			if(superClass != null && hashtable.get(superClass) == null) {
-				Integer index = new Integer(count++);
+				Integer index = Integer.valueOf(count++);
 				hashtable.put(superClass, index);
 				hashtable2.put(index, superClass);
 			}
@@ -1360,7 +1360,7 @@ public void store(OutputStream output, IProgressMonitor monitor) throws JavaMode
 			Map.Entry<IType, IType[]> entry = (Map.Entry<IType, IType[]>) intfs[i];
 			IType t = entry.getKey();
 			if(hashtable.get(t) == null) {
-				Integer index = new Integer(count++);
+				Integer index = Integer.valueOf(count++);
 				hashtable.put(t, index);
 				hashtable2.put(index, t);
 			}
@@ -1369,7 +1369,7 @@ public void store(OutputStream output, IProgressMonitor monitor) throws JavaMode
 				for (int j = 0; j < sp.length; j++) {
 					IType superInterface = sp[j];
 					if(sp[j] != null && hashtable.get(superInterface) == null) {
-						Integer index = new Integer(count++);
+						Integer index = Integer.valueOf(count++);
 						hashtable.put(superInterface, index);
 						hashtable2.put(index, superInterface);
 					}
@@ -1404,7 +1404,7 @@ public void store(OutputStream output, IProgressMonitor monitor) throws JavaMode
 
 		// save types
 		for (int i = 0; i < count ; i++) {
-			IType t = hashtable2.get(new Integer(i));
+			IType t = hashtable2.get(Integer.valueOf(i));
 
 			// n bytes
 			output.write(t.getHandleIdentifier().getBytes());
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
index e08855c..9db001f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -2865,16 +2865,16 @@ public class Util {
 		switch (constant.typeID()) {
 			case TypeIds.T_int :
 				memberValuePair.valueKind = IMemberValuePair.K_INT;
-				return new Integer(constant.intValue());
+				return Integer.valueOf(constant.intValue());
 			case TypeIds.T_byte :
 				memberValuePair.valueKind = IMemberValuePair.K_BYTE;
-				return new Byte(constant.byteValue());
+				return Byte.valueOf(constant.byteValue());
 			case TypeIds.T_short :
 				memberValuePair.valueKind = IMemberValuePair.K_SHORT;
-				return new Short(constant.shortValue());
+				return Short.valueOf(constant.shortValue());
 			case TypeIds.T_char :
 				memberValuePair.valueKind = IMemberValuePair.K_CHAR;
-				return new Character(constant.charValue());
+				return Character.valueOf(constant.charValue());
 			case TypeIds.T_float :
 				memberValuePair.valueKind = IMemberValuePair.K_FLOAT;
 				return new Float(constant.floatValue());
@@ -2886,7 +2886,7 @@ public class Util {
 				return Boolean.valueOf(constant.booleanValue());
 			case TypeIds.T_long :
 				memberValuePair.valueKind = IMemberValuePair.K_LONG;
-				return new Long(constant.longValue());
+				return Long.valueOf(constant.longValue());
 			case TypeIds.T_JavaLangString :
 				memberValuePair.valueKind = IMemberValuePair.K_STRING;
 				return constant.stringValue();
@@ -2908,7 +2908,7 @@ public class Util {
 		switch (constant.typeID()) {
 			case TypeIds.T_int :
 				memberValuePair.valueKind = IMemberValuePair.K_INT;
-				return new Integer(constant.intValue() * -1);
+				return Integer.valueOf(constant.intValue() * -1);
 			case TypeIds.T_float :
 				memberValuePair.valueKind = IMemberValuePair.K_FLOAT;
 				return new Float(constant.floatValue() * -1.0f);
@@ -2917,7 +2917,7 @@ public class Util {
 				return new Double(constant.doubleValue() * -1.0);
 			case TypeIds.T_long :
 				memberValuePair.valueKind = IMemberValuePair.K_LONG;
-				return new Long(constant.longValue() * -1L);
+				return Long.valueOf(constant.longValue() * -1L);
 			default:
 				memberValuePair.valueKind = IMemberValuePair.K_UNKNOWN;
 				return null;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
index efb3a5b..d7c78b7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -272,7 +272,7 @@ private String[] computeDocumentNames(String[] onDiskNames, int[] positions, Sim
 				newDocNames[count++] = (String) added[i];
 		Util.sort(newDocNames);
 		for (int i = 0, l = newDocNames.length; i < l; i++)
-			indexedDocuments.put(newDocNames[i], new Integer(i));
+			indexedDocuments.put(newDocNames[i], Integer.valueOf(i));
 		return newDocNames;
 	}
 
@@ -316,7 +316,7 @@ private String[] computeDocumentNames(String[] onDiskNames, int[] positions, Sim
 		Util.sort(newDocNames);
 		for (int i = 0, l = newDocNames.length; i < l; i++)
 			if (indexedDocuments.containsKey(newDocNames[i]))
-				indexedDocuments.put(newDocNames[i], new Integer(i)); // remember the position for each new document
+				indexedDocuments.put(newDocNames[i], Integer.valueOf(i)); // remember the position for each new document
 	}
 
 	// need to be able to look up an old position (ref# from a ref[]) and map it to its new position
@@ -331,7 +331,7 @@ private String[] computeDocumentNames(String[] onDiskNames, int[] positions, Sim
 			case RE_INDEXED :
 				String newName = newDocNames[++count];
 				if (newName.equals(onDiskNames[i])) {
-					indexedDocuments.put(newName, new Integer(count)); // the reindexed docName that was at position i is now at position count
+					indexedDocuments.put(newName, Integer.valueOf(count)); // the reindexed docName that was at position i is now at position count
 					i++;
 				}
 				break;
@@ -692,7 +692,7 @@ private synchronized HashtableOfObject readCategoryTable(char[] categoryName, bo
 						firstOffset = arrayOffset;
 					matchingWords[count++] = word;
 				}
-				categoryTable.putUnsafely(word, new Integer(arrayOffset)); // offset to array in the file
+				categoryTable.putUnsafely(word, Integer.valueOf(arrayOffset)); // offset to array in the file
 			}
 		}
 		this.categoryTables.put(INTERNED_CATEGORY_NAMES.get(categoryName), categoryTable);
@@ -1108,7 +1108,7 @@ private void writeCategoryTable(char[] categoryName, HashtableOfObject wordsToDo
 				o = values[i] = ((IntList) values[i]).asArray();
 			int[] documentNumbers = (int[]) o;
 			if (documentNumbers.length >= largeArraySize) {
-				values[i] = new Integer(this.streamEnd);
+				values[i] = Integer.valueOf(this.streamEnd);
 				writeDocumentNumbers(documentNumbers, stream);
 			}
 		}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
index 543549d..1f53509 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -58,11 +58,11 @@ public class IndexManager extends JobManager implements IIndexConstants {
 	private File savedIndexNamesFile = new File(getSavedIndexesDirectory(), "savedIndexNames.txt"); //$NON-NLS-1$
 	private File participantIndexNamesFile = new File(getSavedIndexesDirectory(), "participantsIndexNames.txt"); //$NON-NLS-1$
 	private boolean javaLikeNamesChanged = true;
-	public static final Integer SAVED_STATE = new Integer(0);
-	public static final Integer UPDATING_STATE = new Integer(1);
-	public static final Integer UNKNOWN_STATE = new Integer(2);
-	public static final Integer REBUILDING_STATE = new Integer(3);
-	public static final Integer REUSE_STATE = new Integer(4);
+	public static final Integer SAVED_STATE = 0;
+	public static final Integer UPDATING_STATE = 1;
+	public static final Integer UNKNOWN_STATE = 2;
+	public static final Integer REBUILDING_STATE = 3;
+	public static final Integer REUSE_STATE = 4;
 	
 	// search participants who register indexes with the index manager
 	private SimpleLookupTable participantsContainers = null;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchingNodeSet.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchingNodeSet.java
index dffd842..d407df1 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchingNodeSet.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchingNodeSet.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -32,9 +32,9 @@ public class MatchingNodeSet {
  */
 SimpleLookupTable matchingNodes = new SimpleLookupTable(3); // node -> accuracy
 private HashtableOfLong matchingNodesKeys = new HashtableOfLong(3); // sourceRange -> node
-static Integer EXACT_MATCH = new Integer(SearchMatch.A_ACCURATE);
-static Integer POTENTIAL_MATCH = new Integer(SearchMatch.A_INACCURATE);
-static Integer ERASURE_MATCH = new Integer(SearchPattern.R_ERASURE_MATCH);
+static Integer EXACT_MATCH = Integer.valueOf(SearchMatch.A_ACCURATE);
+static Integer POTENTIAL_MATCH = Integer.valueOf(SearchMatch.A_INACCURATE);
+static Integer ERASURE_MATCH = Integer.valueOf(SearchPattern.R_ERASURE_MATCH);
 
 /**
  * Tell whether locators need to resolve or not for current matching node set.
@@ -59,7 +59,7 @@ public int addMatch(ASTNode node, int matchLevel) {
 	switch (maskedLevel) {
 		case PatternLocator.INACCURATE_MATCH:
 			if (matchLevel != maskedLevel) {
-				addTrustedMatch(node, new Integer(SearchMatch.A_INACCURATE+(matchLevel & PatternLocator.FLAVORS_MASK)));
+				addTrustedMatch(node, Integer.valueOf(SearchMatch.A_INACCURATE+(matchLevel & PatternLocator.FLAVORS_MASK)));
 			} else {
 				addTrustedMatch(node, POTENTIAL_MATCH);
 			}
@@ -69,14 +69,14 @@ public int addMatch(ASTNode node, int matchLevel) {
 			break;
 		case PatternLocator.ERASURE_MATCH:
 			if (matchLevel != maskedLevel) {
-				addTrustedMatch(node, new Integer(SearchPattern.R_ERASURE_MATCH+(matchLevel & PatternLocator.FLAVORS_MASK)));
+				addTrustedMatch(node, Integer.valueOf(SearchPattern.R_ERASURE_MATCH+(matchLevel & PatternLocator.FLAVORS_MASK)));
 			} else {
 				addTrustedMatch(node, ERASURE_MATCH);
 			}
 			break;
 		case PatternLocator.ACCURATE_MATCH:
 			if (matchLevel != maskedLevel) {
-				addTrustedMatch(node, new Integer(SearchMatch.A_ACCURATE+(matchLevel & PatternLocator.FLAVORS_MASK)));
+				addTrustedMatch(node, Integer.valueOf(SearchMatch.A_ACCURATE+(matchLevel & PatternLocator.FLAVORS_MASK)));
 			} else {
 				addTrustedMatch(node, EXACT_MATCH);
 			}
commit b51cc5d8fad9e9863182caa1bdcc31e7c01d0d67
Author: Alex Blewitt <alex.blewitt@gmail.com>
Date:   Wed Apr 6 15:08:49 2016 +0100

    Bug 489702 - Revert ToolFactory.M_FORMAT_* changes
    
    The constants in ToolFactory.M_FORMAT_* are supposed to be non compile-time
    constants, according to Markus Keller, so these are being changed for
    Integer.valueOf().intValue() instead.
    
    Change-Id: I926a9d8e53d7851c6047abd45673498cf1ec9b53
    Signed-off-by: Alex Blewitt <alex.blewitt@gmail.com>

4	2	org.eclipse.jdt.core/model/org/eclipse/jdt/core/ToolFactory.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ToolFactory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ToolFactory.java
index 4f78528..0b2c70e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ToolFactory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/ToolFactory.java
@@ -72,7 +72,8 @@ public class ToolFactory {
 	 * @see #createCodeFormatter(Map, int)
 	 * @since 3.3
 	 */
-	public static final int M_FORMAT_NEW = 0;
+	// Supposed to be a non-compile time constant
+	public static final int M_FORMAT_NEW = Integer.valueOf(0).intValue();
 
 	/**
 	 * This mode is used for formatting existing code when all formatter options should be used.
@@ -85,7 +86,8 @@ public class ToolFactory {
 	 * @see #createCodeFormatter(Map, int)
 	 * @since 3.3
 	 */
-	public static final int M_FORMAT_EXISTING = 1;
+	// Supposed to be a non-compile time constant
+	public static final int M_FORMAT_EXISTING = Integer.valueOf(1).intValue();
 
 	/**
 	 * Create an instance of a code formatter. A code formatter implementation can be contributed via the
