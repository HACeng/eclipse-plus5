commit 72895982cdfd43c6e856c9e0af3d1d64cc3e0181
Author: Jerome lanneluc <jlanneluc>
Date:   Mon Nov 18 11:43:51 2002 +0000

    Fix for bug 23126

57	56	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AttachSourceTests.java
3	2	org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/.classpath
-	-	org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/lib/p/X.class
5	0	org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/srcLib/p/X.java
5	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
6	311	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
2	20	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRootInfo.java
311	16	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
21	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRootInfo.java
66	35	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AttachSourceTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AttachSourceTests.java
index 74dac41..e1f0dc1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AttachSourceTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AttachSourceTests.java
@@ -47,7 +47,7 @@ protected void attachSource(IPackageFragmentRoot root, String sourcePath, String
 	}
 	javaProject.setRawClasspath(entries, null);
 }
-	private IPackageFragmentRoot jarRoot;
+	private IPackageFragmentRoot root;
 	
 public AttachSourceTests(String name) {
 	super(name);
@@ -66,6 +66,7 @@ public static Test suite() {
 	suite.addTest(new AttachSourceTests("testChangeSourceAttachmentFile"));
 	suite.addTest(new AttachSourceTests("testDetachSource"));
 	suite.addTest(new AttachSourceTests("testAttachSourceWithRootPath"));
+	suite.addTest(new AttachSourceTests("testAttachSourceToLibFolder"));
 	return suite;
 
 }
@@ -76,14 +77,14 @@ public void setUpSuite() throws Exception {
 	super.setUpSuite();
 	
 	IJavaProject project = setUpJavaProject("AttachSourceTests");
-	this.jarRoot = project.getPackageFragmentRoot("/AttachSourceTests/attach.jar");
+	this.root = project.getPackageFragmentRoot("/AttachSourceTests/attach.jar");
 }
 /**
  * Reset the jar placeholder and delete project.
  */
 public void tearDownSuite() throws Exception {
-	this.jarRoot.close();
-	this.jarRoot = null;
+	this.root.close();
+	this.root = null;
 	this.deleteProject("AttachSourceTests");
 	
 	super.tearDown();
@@ -92,12 +93,8 @@ public void tearDownSuite() throws Exception {
 /**
  * Attaches a source zip to the classes.zip jar.
  */
-public void testAttachSource() {
-	try {
-		this.attachSource(this.jarRoot, "/AttachSourceTests/attachsrc.zip", null);
-	} catch (JavaModelException jme) {
-		fail("Attach source operation creation failed");
-	}
+public void testAttachSource() throws CoreException {
+	this.attachSource(this.root, "/AttachSourceTests/attachsrc.zip", null);
 }
 
 /**
@@ -105,11 +102,11 @@ public void testAttachSource() {
  * mapped source.
  */
 public void testAttachSourceNameRange() throws JavaModelException {
-	IClassFile cf = this.jarRoot.getPackageFragment("x.y").getClassFile("A.class");
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
 	IMethod method = cf.getType().getMethod("foo", null);
 	assertTrue("method name range not correct", method.getNameRange().getOffset() != -1 && method.getNameRange().getLength() != 0);
 
-	IClassFile objectCF = this.jarRoot.getPackageFragment("x.y").getClassFile("A.class");
+	IClassFile objectCF = this.root.getPackageFragment("x.y").getClassFile("A.class");
 	ISourceRange range= objectCF.getType().getNameRange();
 	int start, end;
 	start= range.getOffset();
@@ -124,7 +121,7 @@ public void testAttachSourceNameRange() throws JavaModelException {
  * attachment still exists.
  */
 public void testAttachSourcePersisted() throws JavaModelException {
-	this.jarRoot.close();
+	this.root.close();
 	testAttachSourceRetrievalClass();
 	testAttachSourceRetrievalMethod();
 }
@@ -132,7 +129,7 @@ public void testAttachSourcePersisted() throws JavaModelException {
  * Retrieves the source code for methods of class A.
  */
 public void testAttachSourceRetrievalMethod() throws JavaModelException {
-	IClassFile cf = this.jarRoot.getPackageFragment("x.y").getClassFile("A.class");
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
 	IMethod[] methods = cf.getType().getMethods();
 	for (int i = 0; i < methods.length; i++) {
 		IMethod method = methods[i];
@@ -145,7 +142,7 @@ public void testAttachSourceRetrievalMethod() throws JavaModelException {
  * the entire CU for "A.java".
  */
 public void testAttachSourceRetrievalClass() throws JavaModelException {
-	IClassFile objectCF = this.jarRoot.getPackageFragment("x.y").getClassFile("A.class");
+	IClassFile objectCF = this.root.getPackageFragment("x.y").getClassFile("A.class");
 	assertTrue("source code does not exist for the entire attached compilation unit", objectCF.getSource() != null);
 }
 /**
@@ -153,54 +150,62 @@ public void testAttachSourceRetrievalClass() throws JavaModelException {
  * mapped source.
  */
 public void testAttachSourceSourceRange() throws JavaModelException {
-	IClassFile cf = this.jarRoot.getPackageFragment("x.y").getClassFile("A.class");
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
 	assertTrue("Class file source range not correct", cf.getSourceRange().getOffset() == 0 && cf.getSourceRange().getLength() != 0);
-
 }
 /**
  * Ensures that a source range exists for the (inner) class file that has
  * mapped source.
  */
 public void testAttachSourceSourceRangeInnerClass() throws JavaModelException {
-	IClassFile cf = this.jarRoot.getPackageFragment("x.y").getClassFile("A$Inner.class");
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A$Inner.class");
 	assertTrue("Inner Class file source range not correct", cf.getSourceRange().getOffset() == 0 && cf.getSourceRange().getLength() != 0);
-
 }
 /**
- * Attaches a source zip to the Minimal.zip jar.  The source zip has
+ * Ensures that a source folder can be attached to a lib folder.
+ */
+public void testAttachSourceToLibFolder() throws JavaModelException {
+	IPackageFragmentRoot root = this.getPackageFragmentRoot("/AttachSourceTests/lib");
+	this.attachSource(root, "/AttachSourceTests/srcLib", "");
+	
+	IClassFile cf = root.getPackageFragment("p").getClassFile("X.class");
+	String lineSeparator = System.getProperty("line.separator");
+	assertEquals(
+		"Unexpected source for class file",
+		"package p;" + lineSeparator +		"public class X {" + lineSeparator +		"	public void foo() {" + lineSeparator +		"	}" + lineSeparator +		"}" + lineSeparator,
+		cf.getSource());
+}
+/**
+ * Attaches a source zip to a jar.  The source zip has
  * a nested root structure and exists as a resource.  Tests that
  * the attachment is persisted as a server property for the jar.
  */
 public void testAttachSourceWithRootPath() throws JavaModelException {
-	try {
-		IJavaProject project = getJavaProject("AttachSourceTests");
-		IFile jar = (IFile) project.getProject().findMember("attach2.jar");
-		IFile srcZip=(IFile) project.getProject().findMember("attach2src.zip");
-		JarPackageFragmentRoot jarRoot = (JarPackageFragmentRoot) project.getPackageFragmentRoot(jar);
-		jarRoot.attachSource(srcZip.getFullPath(), new Path("src/nested"), null);
+	IJavaProject project = getJavaProject("AttachSourceTests");
+	IFile jar = (IFile) project.getProject().findMember("attach2.jar");
+	IFile srcZip=(IFile) project.getProject().findMember("attach2src.zip");
+	JarPackageFragmentRoot root = (JarPackageFragmentRoot) project.getPackageFragmentRoot(jar);
+	root.attachSource(srcZip.getFullPath(), new Path("src/nested"), null);
 
-		IClassFile cf = jarRoot.getPackageFragment("x.y").getClassFile("B.class");
-		assertTrue("source code does not exist for the entire attached compilation unit", cf.getSource() != null);
-		jarRoot.close();
-		cf = jarRoot.getPackageFragment("x.y").getClassFile("B.class");
-		assertTrue("source code does not exist for the entire attached compilation unit", cf.getSource() != null);
+	IClassFile cf = root.getPackageFragment("x.y").getClassFile("B.class");
+	assertTrue("source code does not exist for the entire attached compilation unit", cf.getSource() != null);
+	root.close();
+	cf = root.getPackageFragment("x.y").getClassFile("B.class");
+	assertTrue("source code does not exist for the entire attached compilation unit", cf.getSource() != null);
 
-		IPath rootSAPath= jarRoot.getSourceAttachmentRootPath();
-		assertEquals("Unexpected source attachment root path for " + jarRoot.getPath(), "src/nested", rootSAPath.toString());
+	IPath rootSAPath= root.getSourceAttachmentRootPath();
+	assertEquals("Unexpected source attachment root path for " + root.getPath(), "src/nested", rootSAPath.toString());
 
-		IPath saPath= jarRoot.getSourceAttachmentPath();
-		assertEquals("Unexpected source attachment path for " + jarRoot.getPath(), "/AttachSourceTests/attach2src.zip", saPath.toString());
-		
-		jarRoot.close();
-	} catch (JavaModelException jme) {
-		fail("Attach source operation creation failed");
-	}
+	IPath saPath= root.getSourceAttachmentPath();
+	assertEquals("Unexpected source attachment path for " + root.getPath(), "/AttachSourceTests/attach2src.zip", saPath.toString());
+	
+	root.close();
 }
 /**
  * Ensure that a class file with an attached source can retrieve its children given a source index.
  */
 public void testClassFileGetElementAt() throws JavaModelException {
-	IClassFile cf = this.jarRoot.getPackageFragment("x.y").getClassFile("A.class");
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
 	IJavaElement elt = null;
 	
 	elt = cf.getElementAt(15);
@@ -226,7 +231,7 @@ public void testClassFileGetElementAt() throws JavaModelException {
  * (regression test for bug 23292 Must restart Eclipse after debug of source in .zip is updated)
  */
 public void testChangeSourceAttachmentFile() throws CoreException {
-	IClassFile cf = this.jarRoot.getPackageFragment("x.y").getClassFile("A.class");
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
 	IMethod method = cf.getType().getMethod("foo", new String[] {});
 	String lineSeparator = System.getProperty("line.separator");
 	
@@ -265,25 +270,21 @@ public void testChangeSourceAttachmentFile() throws CoreException {
  * Removes the source attachment from the jar.
  */
 public void testDetachSource() throws JavaModelException {
-	try {
-		this.attachSource(this.jarRoot, null, null);
-		IClassFile cf = this.jarRoot.getPackageFragment("x.y").getClassFile("A.class");
-		assertTrue("source code should no longer exist for A", cf.getSource() == null);
-		assertTrue("name range should no longer exist for A", cf.getType().getNameRange().getOffset() == -1);
-		assertTrue("source range should no longer exist for A", cf.getType().getSourceRange().getOffset() == -1);
-		assertTrue("Source attachment path should be null", null == this.jarRoot.getSourceAttachmentPath());
-		assertTrue("Source attachment root path should be null", null ==this.jarRoot.getSourceAttachmentRootPath());
-	} catch (JavaModelException jme) {
-		fail("Source Detach Failed");
-	}
+	this.attachSource(this.root, null, null);
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
+	assertTrue("source code should no longer exist for A", cf.getSource() == null);
+	assertTrue("name range should no longer exist for A", cf.getType().getNameRange().getOffset() == -1);
+	assertTrue("source range should no longer exist for A", cf.getType().getSourceRange().getOffset() == -1);
+	assertTrue("Source attachment path should be null", null == this.root.getSourceAttachmentPath());
+	assertTrue("Source attachment root path should be null", null ==this.root.getSourceAttachmentRootPath());
 }
 /**
  * Retrieves the source attachment paths for jar root.
  */
 public void testGetSourceAttachmentPath() throws JavaModelException {
-	IPath saPath= this.jarRoot.getSourceAttachmentPath();
-	assertEquals("Source attachment path not correct for root " + this.jarRoot, "/AttachSourceTests/attachsrc.zip", saPath.toString());
-	assertEquals("Source attachment root path should be empty", new Path(""), this.jarRoot.getSourceAttachmentRootPath());
+	IPath saPath= this.root.getSourceAttachmentPath();
+	assertEquals("Source attachment path not correct for root " + this.root, "/AttachSourceTests/attachsrc.zip", saPath.toString());
+	assertEquals("Source attachment root path should be empty", new Path(""), this.root.getSourceAttachmentRootPath());
 }
 
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/.classpath b/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/.classpath
index c47ceba..0e87d51 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/.classpath
+++ b/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/.classpath
@@ -2,7 +2,8 @@
 <classpath>
     <classpathentry kind="lib" path="attach.jar"/>
     <classpathentry kind="lib" path="attach2.jar"/>
-    <classpathentry kind="src" path=""/>
+    <classpathentry kind="lib" path="lib"/>
+    <classpathentry kind="src" path="src"/>
     <classpathentry kind="var" path="JCL_LIB" sourcepath="JCL_SRC" rootpath="JCL_SRCROOT"/>
-    <classpathentry kind="output" path=""/>
+    <classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/lib/p/X.class b/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/lib/p/X.class
new file mode 100644
index 0000000..555a887
Binary files /dev/null and b/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/lib/p/X.class differ
diff --git a/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/srcLib/p/X.java b/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/srcLib/p/X.java
new file mode 100644
index 0000000..3d41ef1
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/srcLib/p/X.java
@@ -0,0 +1,5 @@
+package p;
+public class X {
+	public void foo() {
+	}
+}
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 415c238..8b4c94e 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -41,7 +41,11 @@ What's new in this drop</h2>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=26459">26459</a>  
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=23126">23126</a>
+allow selecting directories when attaching source to jar's 
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=22145">22145</a>
+Attach source directory in addition to archive file [build path] 
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=26459">26459</a>  
 Unused NonVoidMethodRequestor
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=26122">26122</a>  
 JACKS: VerifyError when affecting final local in anonymous class header
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
index 7861cae..44f942a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
@@ -1,9 +1,9 @@
 /*******************************************************************************
  * Copyright (c) 2000, 2001, 2002 International Business Machines Corp. and others.
  * All rights reserved. This program and the accompanying materials 
- * are made available under the terms of the Common Public License v0.5 
+ * are made available under the terms of the Common Public License v1.0 
  * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/cpl-v05.html
+ * http://www.eclipse.org/legal/cpl-v10.html
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
@@ -11,34 +11,16 @@
 package org.eclipse.jdt.internal.core;
 
 import java.io.File;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Iterator;
+import java.util.*;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
-import org.eclipse.core.resources.IFile;
 import org.eclipse.core.resources.IResource;
-import org.eclipse.core.resources.IWorkspace;
-import org.eclipse.core.resources.IWorkspaceRoot;
 import org.eclipse.core.resources.ResourcesPlugin;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
-import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.Path;
-import org.eclipse.core.runtime.QualifiedName;
-import org.eclipse.jdt.core.IBuffer;
-import org.eclipse.jdt.core.IClasspathEntry;
-import org.eclipse.jdt.core.IJavaElement;
-import org.eclipse.jdt.core.IJavaModel;
-import org.eclipse.jdt.core.IJavaModelStatusConstants;
-import org.eclipse.jdt.core.IJavaProject;
-import org.eclipse.jdt.core.IOpenable;
-import org.eclipse.jdt.core.IPackageFragment;
-import org.eclipse.jdt.core.IPackageFragmentRoot;
-import org.eclipse.jdt.core.JavaCore;
-import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.*;
 
 /**
  * A package fragment root that corresponds to a .jar or .zip.
@@ -63,18 +45,6 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 	protected final IPath jarPath;
 
 	/**
-	 * The delimiter between the zip path and source path in the
-	 * attachment server property.
-	 */
-	protected final static char ATTACHMENT_PROPERTY_DELIMITER= '*';
-
-	/**
-	 * The name of the meta-inf directory not to be included as a 
-	 * jar package fragment.
-	 * @see #computeJarChildren
-	 */
-	//protected final static String META_INF_NAME = "META-INF/";
-	/**
 	 * Constructs a package fragment root which is the root of the Java package directory hierarchy 
 	 * based on a JAR file that is not contained in a <code>IJavaProject</code> and
 	 * does not have an associated <code>IResource</code>.
@@ -92,100 +62,6 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 		this.jarPath = resource.getFullPath();
 	}
 	/**
-	 * @see IPackageFragmentRoot
-	 */
-	public void attachSource(IPath zipPath, IPath rootPath, IProgressMonitor monitor) throws JavaModelException {
-		try {
-			verifyAttachSource(zipPath);
-			if (monitor != null) {
-				monitor.beginTask(Util.bind("element.attachingSource"), 2); //$NON-NLS-1$
-			}
-			SourceMapper mapper= null;
-			SourceMapper oldMapper= getSourceMapper();
-			IWorkspace workspace= getJavaModel().getWorkspace();
-			boolean rootNeedsToBeClosed= false;
-
-			if (zipPath == null) {
-				//source being detached
-				rootNeedsToBeClosed= true;
-			/* Disable deltas (see 1GDTUSD)
-				// fire a delta to notify the UI about the source detachement.
-				JavaModelManager manager = (JavaModelManager) JavaModelManager.getJavaModelManager();
-				JavaModel model = (JavaModel) getJavaModel();
-				JavaElementDelta attachedSourceDelta = new JavaElementDelta(model);
-				attachedSourceDelta .sourceDetached(this); // this would be a JarPackageFragmentRoot
-				manager.registerResourceDelta(attachedSourceDelta );
-				manager.fire(); // maybe you want to fire the change later. Let us know about it.
-			*/
-			} else {
-			/*
-				// fire a delta to notify the UI about the source attachement.
-				JavaModelManager manager = (JavaModelManager) JavaModelManager.getJavaModelManager();
-				JavaModel model = (JavaModel) getJavaModel();
-				JavaElementDelta attachedSourceDelta = new JavaElementDelta(model);
-				attachedSourceDelta .sourceAttached(this); // this would be a JarPackageFragmentRoot
-				manager.registerResourceDelta(attachedSourceDelta );
-				manager.fire(); // maybe you want to fire the change later. Let us know about it.
-			 */
-
-				//check if different from the current attachment
-				IPath storedZipPath= getSourceAttachmentPath();
-				IPath storedRootPath= getSourceAttachmentRootPath();
-				if (monitor != null) {
-					monitor.worked(1);
-				}
-				if (storedZipPath != null) {
-					if (!(storedZipPath.equals(zipPath) && rootPath.equals(storedRootPath))) {
-						rootNeedsToBeClosed= true;
-					}
-				}
-				// check if zip path is valid
-				Object target = JavaModel.getTarget(workspace.getRoot(), zipPath, false);
-				if (!(target instanceof IFile || target instanceof File)) {
-					if (monitor != null) {
-						monitor.done();
-					}
-					throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, zipPath));
-				}
-				mapper= new SourceMapper(
-					zipPath, 
-					rootPath.toOSString(), 
-					this.isExternal() ? JavaCore.getOptions() : this.getJavaProject().getOptions(true)); // only project options if associated with resource
-			}
-			setSourceMapper(mapper);
-			if (zipPath == null) {
-				setSourceAttachmentProperty(null); //remove the property
-			} else {
-				//set the property to the path of the mapped zip
-				setSourceAttachmentProperty(zipPath.toString() + ATTACHMENT_PROPERTY_DELIMITER + rootPath.toString());
-			}
-			if (rootNeedsToBeClosed) {
-				if (oldMapper != null) {
-					oldMapper.close();
-				}
-				BufferManager manager= BufferManager.getDefaultBufferManager();
-				Enumeration openBuffers= manager.getOpenBuffers();
-				while (openBuffers.hasMoreElements()) {
-					IBuffer buffer= (IBuffer) openBuffers.nextElement();
-					IOpenable possibleJarMember= buffer.getOwner();
-					if (isAncestorOf((IJavaElement) possibleJarMember)) {
-						buffer.close();
-					}
-				}
-				if (monitor != null) {
-					monitor.worked(1);
-				}
-			}
-		} catch (JavaModelException e) {
-			setSourceAttachmentProperty(null); // loose info - will be recomputed
-			throw e;
-		} finally {
-			if (monitor != null) {
-				monitor.done();
-			}
-		}
-	}
-	/**
 	 * Close the associated JAR file stored in the info of this element. If
 	 * this jar has an associated ZIP source attachment, close it too.
 	 *
@@ -355,73 +231,6 @@ protected void computeJarChildren(JarPackageFragmentRootInfo info, ArrayList vCh
 		}
 		return false;
 	}
-public IClasspathEntry findSourceAttachmentRecommendation() {
-
-	try {
-
-		IPath rootPath = this.getPath();
-		IClasspathEntry entry;
-		IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
-		
-		// try on enclosing project first
-		JavaProject parentProject = (JavaProject) getJavaProject();
-		try {
-			entry = parentProject.getClasspathEntryFor(rootPath);
-			if (entry != null){
-				Object target = JavaModel.getTarget(workspaceRoot, entry.getSourceAttachmentPath(), true);
-				if (target instanceof IFile){
-					IFile file = (IFile) target;
-					if ("jar".equalsIgnoreCase(file.getFileExtension()) || "zip".equalsIgnoreCase(file.getFileExtension())){ //$NON-NLS-2$ //$NON-NLS-1$
-						return entry;
-					}
-				}
-				if (target instanceof java.io.File){
-					java.io.File file = (java.io.File) target;
-					String name = file.getName();
-					if (Util.endsWithIgnoreCase(name, ".jar") || Util.endsWithIgnoreCase(name, ".zip")){ //$NON-NLS-2$ //$NON-NLS-1$
-						return entry;
-					}
-				}
-			}
-		} catch(JavaModelException e){
-		}
-		
-		// iterate over all projects
-		IJavaModel model = getJavaModel();
-		IJavaProject[] jProjects = model.getJavaProjects();
-		for (int i = 0, max = jProjects.length; i < max; i++){
-			JavaProject jProject = (JavaProject) jProjects[i];
-			if (jProject == parentProject) continue; // already done
-			try {
-				entry = jProject.getClasspathEntryFor(rootPath);
-				if (entry != null){
-					Object target = JavaModel.getTarget(workspaceRoot, entry.getSourceAttachmentPath(), true);
-					if (target instanceof IFile){
-						IFile file = (IFile) target;
-						String name = file.getName();
-						if (Util.endsWithIgnoreCase(name, ".jar") || Util.endsWithIgnoreCase(name, ".zip")){ //$NON-NLS-2$ //$NON-NLS-1$
-							return entry;
-						}
-					}
-					if (target instanceof java.io.File){
-						java.io.File file = (java.io.File) target;
-						String name = file.getName();
-						if (Util.endsWithIgnoreCase(name, ".jar") || Util.endsWithIgnoreCase(name, ".zip")){ //$NON-NLS-2$ //$NON-NLS-1$
-							return entry;
-						}
-					}
-				}
-			} catch(JavaModelException e){
-			}
-		}
-	} catch(JavaModelException e){
-	}
-
-	return null;
-}
-
-
-
 	/**
 	 * Returns the underlying ZipFile for this Jar package fragment root.
 	 *
@@ -471,84 +280,7 @@ public IClasspathEntry findSourceAttachmentRecommendation() {
 			return super.getPath();
 		}
 	}
-	/**
-	 * @see IPackageFragmentRoot
-	 */
-	public IPath getSourceAttachmentPath() throws JavaModelException {
-		String serverPathString= getSourceAttachmentProperty();
-		if (serverPathString == null) {
-			return null;
-		}
-		int index= serverPathString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER);
-		if (index < 0) return null;
-		String serverZipPathString= serverPathString.substring(0, index);
-		return new Path(serverZipPathString);
-	}
-	/**
-	 * Returns the server property for this package fragment root's
-	 * source attachement.
-	 */
-	protected String getSourceAttachmentProperty() throws JavaModelException {
-		String propertyString = null;
-		QualifiedName qName= getSourceAttachmentPropertyName();
-		try {
-			propertyString = getWorkspace().getRoot().getPersistentProperty(qName);
-			
-			// if no existing source attachment information, then lookup a recommendation from classpath entries
-			if (propertyString == null || propertyString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER) < 0){
-				IClasspathEntry recommendation = findSourceAttachmentRecommendation();
-				if (recommendation != null){
-					propertyString = recommendation.getSourceAttachmentPath().toString() 
-										+ ATTACHMENT_PROPERTY_DELIMITER 
-										+ (recommendation.getSourceAttachmentRootPath() == null ? "" : recommendation.getSourceAttachmentRootPath().toString()); //$NON-NLS-1$
-					setSourceAttachmentProperty(propertyString);
-				}
-			}
-			return propertyString;
-		} catch (CoreException ce) {
-			throw new JavaModelException(ce);
-		}
-	}
-	
-	public void setSourceAttachmentProperty(String property){
-		try {
-			getWorkspace().getRoot().setPersistentProperty(this.getSourceAttachmentPropertyName(), property);
-		} catch (CoreException ce) {
-		}
-	}
-	
-	/**
-	 * Returns the qualified name for the source attachment property
-	 * of this jar.
-	 */
-	protected QualifiedName getSourceAttachmentPropertyName() throws JavaModelException {
-		return new QualifiedName(JavaCore.PLUGIN_ID, "sourceattachment: " + this.jarPath.toOSString()); //$NON-NLS-1$
-	}
-	/**
-	 * @see IPackageFragmentRoot
-	 */
-	public IPath getSourceAttachmentRootPath() throws JavaModelException {
-		String serverPathString= getSourceAttachmentProperty();
-		if (serverPathString == null) {
-			return null;
-		}
-		int index= serverPathString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER);
-		String serverRootPathString= IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH;
-		if (index != serverPathString.length() - 1) {
-			serverRootPathString= serverPathString.substring(index + 1);
-		}
-		return new Path(serverRootPathString);
-	}
-	/**
-	 * @see JavaElement
-	 */
-	public SourceMapper getSourceMapper() {
-		try {
-			return ((JarPackageFragmentRootInfo) getElementInfo()).getSourceMapper();
-		} catch (JavaModelException e) {
-			return null;
-		}
-	}
+
 	/**
 	 * @see IJavaElement
 	 */
@@ -593,21 +325,7 @@ public IClasspathEntry findSourceAttachmentRecommendation() {
 	public boolean isReadOnly() {
 		return true;
 	}
-	/**
-	 * @see Openable#openWhenClosed()
-	 */
-	protected void openWhenClosed(IProgressMonitor pm) throws JavaModelException {
-		super.openWhenClosed(pm);
-		try {
-			//restore any stored attached source zip
-			IPath zipPath= getSourceAttachmentPath();
-			if (zipPath != null) {
-				IPath rootPath= getSourceAttachmentRootPath();
-				attachSource(zipPath, rootPath, pm);
-			}
-		} catch(JavaModelException e){ // no attached source
-		}
-	}
+
 	/**
 	 * An archive cannot refresh its children.
 	 */
@@ -645,29 +363,6 @@ public IJavaElement rootedAt(IJavaProject project) {
 	}
 }
 
-	/**
-	 * For use by <code>AttachSourceOperation</code> only.
-	 * Sets the source mapper associated with this jar.
-	 */
-	public void setSourceMapper(SourceMapper mapper) throws JavaModelException {
-		((JarPackageFragmentRootInfo) getElementInfo()).setSourceMapper(mapper);
-	}
-	/**
-	 * Possible failures: <ul>
-	 *  <li>RELATIVE_PATH - the path supplied to this operation must be
-	 *      an absolute path
-	 *  <li>ELEMENT_NOT_PRESENT - the jar supplied to the operation
-	 *      does not exist
-	 * </ul>
-	 */
-	protected void verifyAttachSource(IPath zipPath) throws JavaModelException {
-		if (!exists()) {
-			throw newNotPresentException();
-		} else if (zipPath != null && !zipPath.isAbsolute()) {
-			throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, zipPath));
-		}
-	}
-
 /**
  * @see JavaElement#getHandleMemento()
  */
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRootInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRootInfo.java
index 2eb3b77..5a3a069 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRootInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRootInfo.java
@@ -1,9 +1,9 @@
 /*******************************************************************************
  * Copyright (c) 2000, 2001, 2002 International Business Machines Corp. and others.
  * All rights reserved. This program and the accompanying materials 
- * are made available under the terms of the Common Public License v0.5 
+ * are made available under the terms of the Common Public License v1.0 
  * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/cpl-v05.html
+ * http://www.eclipse.org/legal/cpl-v10.html
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
@@ -14,11 +14,6 @@ package org.eclipse.jdt.internal.core;
  * The element info for <code>JarPackageFragmentRoot</code>s.
  */
 class JarPackageFragmentRootInfo extends PackageFragmentRootInfo {
-	/**
-	 * The SourceMapper for this JAR (or <code>null</code> if
-	 * this JAR does not have source attached).
-	 */
-	protected SourceMapper fSourceMapper= null;
 /**
  * Returns an array of non-java resources contained in the receiver.
  */
@@ -26,17 +21,4 @@ public Object[] getNonJavaResources() {
 	fNonJavaResources = NO_NON_JAVA_RESOURCES;
 	return fNonJavaResources;
 }
-/**
- * Retuns the SourceMapper for this JAR, or <code>null</code>
- * if this JAR does not have attached source.
- */
-protected SourceMapper getSourceMapper() {
-	return fSourceMapper;
-}
-/**
- * Sets the SourceMapper for this JAR.
- */
-protected void setSourceMapper(SourceMapper mapper) {
-	fSourceMapper= mapper;
-}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index 4c8ed9a..9f2b9aa 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -1,9 +1,9 @@
 /*******************************************************************************
  * Copyright (c) 2000, 2001, 2002 International Business Machines Corp. and others.
  * All rights reserved. This program and the accompanying materials 
- * are made available under the terms of the Common Public License v0.5 
+ * are made available under the terms of the Common Public License v1.0 
  * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/cpl-v05.html
+ * http://www.eclipse.org/legal/cpl-v10.html
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
@@ -11,11 +11,14 @@
 package org.eclipse.jdt.internal.core;
 
 import java.util.ArrayList;
+import java.util.Enumeration;
 import java.util.Map;
 
+import org.eclipse.core.resources.*;
 import org.eclipse.core.resources.IContainer;
 import org.eclipse.core.resources.IFolder;
 import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.*;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
@@ -28,10 +31,17 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 public class PackageFragmentRoot extends Openable implements IPackageFragmentRoot {
 
 	/**
+	 * The delimiter between the source path and root path in the
+	 * attachment server property.
+	 */
+	protected final static char ATTACHMENT_PROPERTY_DELIMITER= '*';
+
+	/**
 	 * The resource associated with this root.
 	 * @see IResource
 	 */
 	protected IResource fResource;
+	
 /**
  * Constructs a package fragment root which is the root of the java package
  * directory hierarchy.
@@ -40,6 +50,7 @@ protected PackageFragmentRoot(IResource resource, IJavaProject project) {
 	this(resource, project, resource.getProjectRelativePath().toString());
 	fResource = resource;
 }
+
 /**
  * Constructs a package fragment root which is the root of the java package
  * directory hierarchy.
@@ -48,12 +59,102 @@ protected PackageFragmentRoot(IResource resource, IJavaProject project, String p
 	super(PACKAGE_FRAGMENT_ROOT, project, path);
 	fResource = resource;
 }
+
 /**
  * @see IPackageFragmentRoot
  */
-public void attachSource(IPath zipPath, IPath rootPath, IProgressMonitor monitor) throws JavaModelException {
-	throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.INVALID_ELEMENT_TYPES, this));
+public void attachSource(IPath sourcePath, IPath rootPath, IProgressMonitor monitor) throws JavaModelException {
+	try {
+		verifyAttachSource(sourcePath);
+		if (monitor != null) {
+			monitor.beginTask(Util.bind("element.attachingSource"), 2); //$NON-NLS-1$
+		}
+		SourceMapper mapper= null;
+		SourceMapper oldMapper= getSourceMapper();
+		IWorkspace workspace= getJavaModel().getWorkspace();
+		boolean rootNeedsToBeClosed= false;
+
+		if (sourcePath == null) {
+			//source being detached
+			rootNeedsToBeClosed= true;
+		/* Disable deltas (see 1GDTUSD)
+			// fire a delta to notify the UI about the source detachement.
+			JavaModelManager manager = (JavaModelManager) JavaModelManager.getJavaModelManager();
+			JavaModel model = (JavaModel) getJavaModel();
+			JavaElementDelta attachedSourceDelta = new JavaElementDelta(model);
+			attachedSourceDelta .sourceDetached(this); // this would be a PackageFragmentRoot
+			manager.registerResourceDelta(attachedSourceDelta );
+			manager.fire(); // maybe you want to fire the change later. Let us know about it.
+		*/
+		} else {
+		/*
+			// fire a delta to notify the UI about the source attachement.
+			JavaModelManager manager = (JavaModelManager) JavaModelManager.getJavaModelManager();
+			JavaModel model = (JavaModel) getJavaModel();
+			JavaElementDelta attachedSourceDelta = new JavaElementDelta(model);
+			attachedSourceDelta .sourceAttached(this); // this would be a PackageFragmentRoot
+			manager.registerResourceDelta(attachedSourceDelta );
+			manager.fire(); // maybe you want to fire the change later. Let us know about it.
+		 */
+
+			//check if different from the current attachment
+			IPath storedSourcePath= getSourceAttachmentPath();
+			IPath storedRootPath= getSourceAttachmentRootPath();
+			if (monitor != null) {
+				monitor.worked(1);
+			}
+			if (storedSourcePath != null) {
+				if (!(storedSourcePath.equals(sourcePath) && rootPath.equals(storedRootPath))) {
+					rootNeedsToBeClosed= true;
+				}
+			}
+			// check if source path is valid
+			Object target = JavaModel.getTarget(workspace.getRoot(), sourcePath, false);
+			if (target == null) {
+				if (monitor != null) {
+					monitor.done();
+				}
+				throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, sourcePath));
+			}
+			mapper= new SourceMapper(
+				sourcePath, 
+				rootPath.toOSString(), 
+				this.isExternal() ? JavaCore.getOptions() : this.getJavaProject().getOptions(true)); // only project options if associated with resource
+		}
+		setSourceMapper(mapper);
+		if (sourcePath == null) {
+			setSourceAttachmentProperty(null); //remove the property
+		} else {
+			//set the property to the path of the mapped source
+			setSourceAttachmentProperty(sourcePath.toString() + ATTACHMENT_PROPERTY_DELIMITER + rootPath.toString());
+		}
+		if (rootNeedsToBeClosed) {
+			if (oldMapper != null) {
+				oldMapper.close();
+			}
+			BufferManager manager= BufferManager.getDefaultBufferManager();
+			Enumeration openBuffers= manager.getOpenBuffers();
+			while (openBuffers.hasMoreElements()) {
+				IBuffer buffer= (IBuffer) openBuffers.nextElement();
+				IOpenable possibleMember= buffer.getOwner();
+				if (isAncestorOf((IJavaElement) possibleMember)) {
+					buffer.close();
+				}
+			}
+			if (monitor != null) {
+				monitor.worked(1);
+			}
+		}
+	} catch (JavaModelException e) {
+		setSourceAttachmentProperty(null); // loose info - will be recomputed
+		throw e;
+	} finally {
+		if (monitor != null) {
+			monitor.done();
+		}
+	}
 }
+
 /**
  * Compute the package fragment children of this package fragment root.
  * 
@@ -78,6 +179,7 @@ protected boolean computeChildren(OpenableElementInfo info) throws JavaModelExce
 	}
 	return true;
 }
+
 /**
  * Starting at this folder, create package fragments and add the fragments that are not exclused
  * to the collection of children.
@@ -115,12 +217,14 @@ protected void computeFolderChildren(IContainer folder, String prefix, ArrayList
 		throw new JavaModelException(e);
 	}
 }
+
 /**
  * Returns a new element info for this element.
  */
 protected OpenableElementInfo createElementInfo() {
 	return new PackageFragmentRootInfo();
 }
+
 /**
  * @see IPackageFragmentRoot
  */
@@ -129,6 +233,7 @@ public IPackageFragment createPackageFragment(String name, boolean force, IProgr
 	runOperation(op, monitor);
 	return getPackageFragment(name);
 }
+
 /**
  * Returns the root's kind - K_SOURCE or K_BINARY, defaults
  * to K_SOURCE if it is not on the classpath.
@@ -146,6 +251,7 @@ protected int determineKind(IResource underlyingResource) throws JavaModelExcept
 	}
 	return IPackageFragmentRoot.K_SOURCE;
 }
+
 /**
  * Compares two objects for equality;
  * for <code>PackageFragmentRoot</code>s, equality is having the
@@ -167,10 +273,84 @@ public boolean equals(Object o) {
  * @see IJavaElement
  */
 public boolean exists() {
-
 	return super.exists() 
 				&& isOnClasspath();
 }
+
+public IClasspathEntry findSourceAttachmentRecommendation() {
+	try {
+		IPath rootPath = this.getPath();
+		IClasspathEntry entry;
+		IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
+		
+		// try on enclosing project first
+		JavaProject parentProject = (JavaProject) getJavaProject();
+		try {
+			entry = parentProject.getClasspathEntryFor(rootPath);
+			if (entry != null){
+				Object target = JavaModel.getTarget(workspaceRoot, entry.getSourceAttachmentPath(), true);
+				if (target instanceof IFile){
+					IFile file = (IFile) target;
+					if (Util.isArchiveFileName(file.getName())){
+						return entry;
+					}
+				} else if (target instanceof IFolder) {
+					return entry;
+				}
+				if (target instanceof java.io.File){
+					java.io.File file = (java.io.File) target;
+					if (file.isFile()) {
+						if (Util.isArchiveFileName(file.getName())){
+							return entry;
+						}
+					} else {
+						// external directory
+						return entry;
+					}
+				}
+			}
+		} catch(JavaModelException e){
+		}
+		
+		// iterate over all projects
+		IJavaModel model = getJavaModel();
+		IJavaProject[] jProjects = model.getJavaProjects();
+		for (int i = 0, max = jProjects.length; i < max; i++){
+			JavaProject jProject = (JavaProject) jProjects[i];
+			if (jProject == parentProject) continue; // already done
+			try {
+				entry = jProject.getClasspathEntryFor(rootPath);
+				if (entry != null){
+					Object target = JavaModel.getTarget(workspaceRoot, entry.getSourceAttachmentPath(), true);
+					if (target instanceof IFile){
+						IFile file = (IFile) target;
+						if (Util.isArchiveFileName(file.getName())){
+							return entry;
+						}
+					} else if (target instanceof IFolder) {
+						return entry;
+					}
+					if (target instanceof java.io.File){
+						java.io.File file = (java.io.File) target;
+						if (file.isFile()) {
+							if (Util.isArchiveFileName(file.getName())){
+								return entry;
+							}
+						} else {
+							// external directory
+							return entry;
+						}
+					}
+				}
+			} catch(JavaModelException e){
+			}
+		}
+	} catch(JavaModelException e){
+	}
+
+	return null;
+}
+
 /*
  * Returns the exclusion patterns from the classpath entry associated with this root. */
 char[][] fullExclusionPatternChars() {
@@ -185,6 +365,7 @@ char[][] fullExclusionPatternChars() {
 		return null;
 	}
 }		
+
 /**
  * @see Openable
  */
@@ -193,24 +374,28 @@ protected boolean generateInfos(OpenableElementInfo info, IProgressMonitor pm, M
 	((PackageFragmentRootInfo) info).setRootKind(determineKind(underlyingResource));
 	return computeChildren(info);
 }
+
 /**
  * @see JavaElement#getHandleMemento()
  */
 protected char getHandleMementoDelimiter() {
 	return JavaElement.JEM_PACKAGEFRAGMENTROOT;
 }
+
 /**
  * @see IPackageFragmentRoot
  */
 public int getKind() throws JavaModelException {
 	return ((PackageFragmentRootInfo)getElementInfo()).getRootKind();
 }
+
 /**
  * Returns an array of non-java resources contained in the receiver.
  */
 public Object[] getNonJavaResources() throws JavaModelException {
 	return ((PackageFragmentRootInfo) getElementInfo()).getNonJavaResources(getJavaProject(), getResource(), this);
 }
+
 /**
  * @see IPackageFragmentRoot
  */
@@ -228,6 +413,7 @@ public IPackageFragment getPackageFragment(String packageName) {
 	}
 	return new PackageFragment(this, packageName);
 }
+
 /**
  * Returns the package name for the given folder
  * (which is a decendent of this root).
@@ -246,12 +432,14 @@ protected String getPackageName(IFolder folder) throws JavaModelException {
 	}
 	return name.toString();
 }
+
 /**
  * @see IJavaElement
  */
 public IPath getPath() {
 	return fResource.getFullPath();
 }
+
 /*
  * @see IPackageFragmentRoot 
  */
@@ -289,28 +477,108 @@ public IClasspathEntry getRawClasspathEntry() throws JavaModelException {
 	}
 	return null;
 }
+
 /*
  * @see IJavaElement
  */
 public IResource getResource() {
 	return fResource;
 }
+
 /**
- * Cannot attach source to a folder.
- *
  * @see IPackageFragmentRoot
  */
 public IPath getSourceAttachmentPath() throws JavaModelException {
-	return null;
+	if (getKind() != K_BINARY) return null;
+	
+	String serverPathString= getSourceAttachmentProperty();
+	if (serverPathString == null) {
+		return null;
+	}
+	int index= serverPathString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER);
+	if (index < 0) return null;
+	String serverSourcePathString= serverPathString.substring(0, index);
+	return new Path(serverSourcePathString);
 }
+
+/**
+ * Returns the server property for this package fragment root's
+ * source attachement.
+ */
+protected String getSourceAttachmentProperty() throws JavaModelException {
+	String propertyString = null;
+	QualifiedName qName= getSourceAttachmentPropertyName();
+	try {
+		propertyString = getWorkspace().getRoot().getPersistentProperty(qName);
+		
+		// if no existing source attachment information, then lookup a recommendation from classpath entries
+		if (propertyString == null || propertyString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER) < 0){
+			IClasspathEntry recommendation = findSourceAttachmentRecommendation();
+			if (recommendation != null){
+				propertyString = recommendation.getSourceAttachmentPath().toString() 
+									+ ATTACHMENT_PROPERTY_DELIMITER 
+									+ (recommendation.getSourceAttachmentRootPath() == null ? "" : recommendation.getSourceAttachmentRootPath().toString()); //$NON-NLS-1$
+				setSourceAttachmentProperty(propertyString);
+			}
+		}
+		return propertyString;
+	} catch (CoreException ce) {
+		throw new JavaModelException(ce);
+	}
+}
+	
+public void setSourceAttachmentProperty(String property){
+	try {
+		getWorkspace().getRoot().setPersistentProperty(this.getSourceAttachmentPropertyName(), property);
+	} catch (CoreException ce) {
+	}
+}
+
+/**
+ * For use by <code>AttachSourceOperation</code> only.
+ * Sets the source mapper associated with this root.
+ */
+public void setSourceMapper(SourceMapper mapper) throws JavaModelException {
+	((PackageFragmentRootInfo) getElementInfo()).setSourceMapper(mapper);
+}
+
+/**
+ * Returns the qualified name for the source attachment property
+ * of this root.
+ */
+protected QualifiedName getSourceAttachmentPropertyName() throws JavaModelException {
+	return new QualifiedName(JavaCore.PLUGIN_ID, "sourceattachment: " + this.getPath().toOSString()); //$NON-NLS-1$
+}
+
 /**
- * Cannot attach source to a folder.
- *
  * @see IPackageFragmentRoot
  */
 public IPath getSourceAttachmentRootPath() throws JavaModelException {
-	return null;
+	if (getKind() != K_BINARY) return null;
+	
+	String serverPathString= getSourceAttachmentProperty();
+	if (serverPathString == null) {
+		return null;
+	}
+	int index= serverPathString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER);
+	String serverRootPathString= IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH;
+	if (index != serverPathString.length() - 1) {
+		serverRootPathString= serverPathString.substring(index + 1);
+	}
+	return new Path(serverRootPathString);
+}
+
+/**
+ * @see JavaElement
+ */
+public SourceMapper getSourceMapper() {
+	try {
+		return ((PackageFragmentRootInfo) getElementInfo()).getSourceMapper();
+	} catch (JavaModelException e) {
+		return null;
+	}
 }
+
 /**
  * @see IJavaElement
  */
@@ -318,15 +586,18 @@ public IResource getUnderlyingResource() throws JavaModelException {
 	if (!exists()) throw newNotPresentException();
 	return fResource;
 }
+
 public int hashCode() {
 	return fResource.hashCode();
 }
+
 /**
  * @see IPackageFragmentRoot
  */
 public boolean isArchive() {
 	return false;
 }
+
 /**
  * @see IPackageFragmentRoot
  */
@@ -338,17 +609,14 @@ public boolean isExternal() {
  * Returns whether this package fragment root is on the classpath of its project.
  */
 protected boolean isOnClasspath() {
-
-	IJavaProject project = this.getJavaProject();
-
 	if (this.getElementType() == IJavaElement.JAVA_PROJECT){
 		return true;
 	}
 	
 	IPath path = this.getPath();
-
 	try {
 		// check package fragment root on classpath of its project
+		IJavaProject project = this.getJavaProject();
 		IClasspathEntry[] classpath = project.getResolvedClasspath(true);	
 		for (int i = 0, length = classpath.length; i < length; i++) {
 			IClasspathEntry entry = classpath[i];
@@ -360,12 +628,20 @@ protected boolean isOnClasspath() {
 		// could not read classpath, then assume it is outside
 	}
 	return false;
-
 }
 
 protected void openWhenClosed(IProgressMonitor pm) throws JavaModelException {
 	if (!this.resourceExists() || !this.isOnClasspath()) throw newNotPresentException();
 	super.openWhenClosed(pm);
+	try {
+		//restore any stored attached source
+		IPath sourcePath= getSourceAttachmentPath();
+		if (sourcePath != null) {
+			IPath rootPath= getSourceAttachmentRootPath();
+			attachSource(sourcePath, rootPath, pm);
+		}
+	} catch(JavaModelException e){ // no attached source
+	}
 }
 
 /**
@@ -380,6 +656,7 @@ public void refreshChildren() {
 		// do nothing.
 	}
 }
+
 /*
  * @see JavaElement#rootedAt(IJavaProject)
  */
@@ -390,6 +667,7 @@ public IJavaElement rootedAt(IJavaProject project) {
 			project, 
 			fName);
 }
+
 /**
  * @private Debugging purposes
  */
@@ -404,4 +682,21 @@ protected void toStringInfo(int tab, StringBuffer buffer, Object info) {
 		buffer.append(" (not open)"); //$NON-NLS-1$
 	}
 }
+
+/**
+ * Possible failures: <ul>
+ *  <li>RELATIVE_PATH - the path supplied to this operation must be
+ *      an absolute path
+ *  <li>ELEMENT_NOT_PRESENT - the root supplied to the operation
+ *      does not exist
+ * </ul>
+ */
+protected void verifyAttachSource(IPath sourcePath) throws JavaModelException {
+	if (!exists()) {
+		throw newNotPresentException();
+	} else if (sourcePath != null && !sourcePath.isAbsolute()) {
+		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, sourcePath));
+	}
+}
+
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRootInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRootInfo.java
index daf7d7b..40603eb 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRootInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRootInfo.java
@@ -1,9 +1,9 @@
 /*******************************************************************************
  * Copyright (c) 2000, 2001, 2002 International Business Machines Corp. and others.
  * All rights reserved. This program and the accompanying materials 
- * are made available under the terms of the Common Public License v0.5 
+ * are made available under the terms of the Common Public License v1.0 
  * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/cpl-v05.html
+ * http://www.eclipse.org/legal/cpl-v10.html
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
@@ -24,6 +24,12 @@ import org.eclipse.jdt.core.JavaModelException;
 class PackageFragmentRootInfo extends OpenableElementInfo {
 
 	/**
+	 * The SourceMapper for this JAR (or <code>null</code> if
+	 * this JAR does not have source attached).
+	 */
+	protected SourceMapper sourceMapper = null;
+
+	/**
 	 * The kind of the root associated with this info.
 	 * Valid kinds are: <ul>
 	 * <li><code>IPackageFragmentRoot.K_SOURCE</code>
@@ -125,6 +131,13 @@ public int getRootKind() {
 	return fRootKind;
 }
 /**
+ * Retuns the SourceMapper for this root, or <code>null</code>
+ * if this root does not have attached source.
+ */
+protected SourceMapper getSourceMapper() {
+	return this.sourceMapper;
+}
+/**
  * Set the fNonJavaResources to res value
  */
 synchronized void setNonJavaResources(Object[] resources) {
@@ -136,4 +149,10 @@ synchronized void setNonJavaResources(Object[] resources) {
 protected void setRootKind(int newRootKind) {
 	fRootKind = newRootKind;
 }
+/**
+ * Sets the SourceMapper for this root.
+ */
+protected void setSourceMapper(SourceMapper mapper) {
+	this.sourceMapper= mapper;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
index 7537444..20633eb 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
@@ -1,21 +1,26 @@
 /*******************************************************************************
  * Copyright (c) 2000, 2001, 2002 International Business Machines Corp. and others.
  * All rights reserved. This program and the accompanying materials 
- * are made available under the terms of the Common Public License v0.5 
+ * are made available under the terms of the Common Public License v1.0 
  * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/cpl-v05.html
+ * http://www.eclipse.org/legal/cpl-v10.html
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  ******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
+import java.io.File;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
+import org.eclipse.core.resources.*;
+import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.ResourcesPlugin;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.jdt.core.*;
@@ -51,13 +56,13 @@ public class SourceMapper
 	/**
 	 * The location of the zip file containing source.
 	 */
-	protected IPath fZipPath;
+	protected IPath sourcePath;
 	/**
 	 * Specifies the location of the package fragment root within
 	 * the zip (empty specifies the default root). <code>null</code> is
 	 * not a valid root path.
 	 */
-	protected String fRootPath;
+	protected String rootPath;
 
 	/**
 	 * Used for efficiency
@@ -144,12 +149,13 @@ public class SourceMapper
 	 * Creates a <code>SourceMapper</code> that locates source in the zip file
 	 * at the given location in the specified package fragment root.
 	 */
-	public SourceMapper(IPath zipPath, String rootPath, Map options) {
-		this.fZipPath = zipPath;
-		this.fRootPath = rootPath.replace('\\', '/');
-		if (this.fRootPath.endsWith("/" )) { //$NON-NLS-1$
-			this.fRootPath = this.fRootPath.substring(0, this.fRootPath.lastIndexOf('/'));
+	public SourceMapper(IPath sourcePath, String rootPath, Map options) {
+		this.sourcePath = sourcePath;
+		rootPath = rootPath.replace('\\', '/');
+		if (rootPath.endsWith("/" )) { //$NON-NLS-1$
+			rootPath =rootPath.substring(0, rootPath.lastIndexOf('/'));
 		}
+		this.rootPath = rootPath;
 		this.fSourceRanges = new HashMap();
 		this.fParameterNames = new HashMap();
 		this.importsTable = new HashMap();
@@ -575,39 +581,64 @@ public class SourceMapper
 		if (name == null) {
 			return null;
 		}
-		// try to get the entry
-		ZipEntry entry = null;
-		ZipFile zip = null;
+
+		String fullName;
+		//add the root path if specified
+		if (!this.rootPath.equals(IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH)) {
+			fullName = this.rootPath + '/' + name;
+		} else {
+			fullName = name;
+		}
+
 		char[] source = null;
-		try {
-			String fullName;
-			//add the root path if specified
-			if (!fRootPath.equals(IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH)) {
-				fullName = fRootPath + '/' + name;
-			} else {
-				fullName = name;
+		if (Util.isArchiveFileName(this.sourcePath.lastSegment())) {
+			// try to get the entry
+			ZipEntry entry = null;
+			ZipFile zip = null;
+			try {
+				zip = getZip();
+				entry = zip.getEntry(fullName);
+				if (entry != null) {
+					// now read the source code
+					byte[] bytes = null;
+					try {
+						bytes = Util.getZipEntryByteContent(entry, zip);
+					} catch (IOException e) {
+					}
+					if (bytes != null) {
+						try {
+							source = Util.bytesToChar(bytes, this.encoding);
+						} catch (IOException e) {
+							source = null;
+						}
+					}
+				}
+			} catch (CoreException e) {
+				return null;
+			} finally {
+				JavaModelManager.getJavaModelManager().closeZipFile(zip);
 			}
-			zip = getZip();
-			entry = zip.getEntry(fullName);
-			if (entry != null) {
-				// now read the source code
-				byte[] bytes = null;
-				try {
-					bytes = Util.getZipEntryByteContent(entry, zip);
-				} catch (IOException e) {
+		} else {
+			Object target = JavaModel.getTarget(ResourcesPlugin.getWorkspace().getRoot(), this.sourcePath, true);
+			if (target instanceof IFolder) {
+				IFolder folder = (IFolder)target;
+				IResource res = folder.findMember(fullName);
+				if (res instanceof IFile) {
+					try {
+						source = org.eclipse.jdt.internal.core.Util.getResourceContentsAsCharArray((IFile)res, this.encoding);
+					} catch (JavaModelException e) {
+					}
 				}
-				if (bytes != null) {
+			} else if (target instanceof File) {
+				File file = (File)target;
+				if (file.isDirectory()) {
+					File sourceFile = new File(file, fullName);
 					try {
-						source = Util.bytesToChar(bytes, this.encoding);
+						source = Util.getFileCharContent(sourceFile, this.encoding);
 					} catch (IOException e) {
-						source = null;
 					}
 				}
 			}
-		} catch (CoreException e) {
-			return null;
-		} finally {
-			JavaModelManager.getJavaModelManager().closeZipFile(zip);
 		}
 		return source;
 	}
@@ -735,7 +766,7 @@ public class SourceMapper
 	 * Returns the <code>ZipFile</code> that source is located in.
 	 */
 	public ZipFile getZip() throws CoreException {
-		return JavaModelManager.getJavaModelManager().getZipFile(fZipPath);
+		return JavaModelManager.getJavaModelManager().getZipFile(this.sourcePath);
 	}
 	
 	/**
