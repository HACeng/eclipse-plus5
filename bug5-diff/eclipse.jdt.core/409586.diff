commit a8073c80a69f6c184e71b3ada3faf15faa3ff3ae
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Fri Sep 13 11:28:23 2013 +0530

    Bug 409586 - [1.8][dom ast] Cannot identify TYPE_USE annotation from
    ITypeBinding

2	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
121	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
1045	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
11	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnionTypeReference.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
7	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedReferenceBinding.java
21	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
19	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ITypeBinding.java
4	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
67	19	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
index 4a2cb71..4aaaa42 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
@@ -31,6 +31,7 @@ import org.eclipse.jdt.core.tests.dom.ASTConverterBugsTestJLS8;
 import org.eclipse.jdt.core.tests.dom.ASTConverterTestAST8_2;
 import org.eclipse.jdt.core.tests.dom.ConverterTestSetup;
 import org.eclipse.jdt.core.tests.dom.TypeAnnotationsConverterTest;
+import org.eclipse.jdt.core.tests.dom.TypeBindingTests308;
 import org.eclipse.jdt.core.tests.formatter.FormatterJSR308Tests;
 import org.eclipse.jdt.core.tests.formatter.FormatterJSR335Tests;
 import org.eclipse.jdt.core.tests.model.JavaSearchBugs8Tests;
@@ -60,6 +61,7 @@ public class RunAllJava8Tests extends TestCase {
 				ASTConverter15JLS8Test.class,
 				ASTConverter18Test.class,
 				ASTRewritingTest.class,
+				TypeBindingTests308.class,
 		};
 	}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
index 31b5bc8..dd8e4ed 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
@@ -2872,5 +2872,126 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertTrue(singleVariableDeclaration.varargsAnnotations().size() == 1);
 
 	}
+	// 	https://bugs.eclipse.org/bugs/show_bug.cgi?id=409586
+	public void testBug409586() throws JavaModelException {
+		String contents = 
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {\n" +
+				" 	String value() default \"\";\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {\n" +
+				" 	String value() default \"22\";\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	public @Marker(\"1\") String foo(int @Marker @Marker2 [] args) {\n" +
+				"      return null;\n" +
+				"	}\n" +
+				"	public @Marker(\"3\") String bar() {\n" +
+				"      return null;\n" +
+				"	}\n" +
+				"   public String @Marker(\"i0\") @Marker2 [] [] @Marker(\"i1\") [] str = null;\n" +
+				"   public @Marker String str2 = null;\n" +
+				"   public @Marker String str3 = null;\n" +
+				"   public String str4 = null;\n" +
+				"}";
 
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		node = getASTNode(compilationUnit, 2, 0);
+		assertTrue("Not a method declaration", node.getNodeType() == ASTNode.METHOD_DECLARATION);
+		MethodDeclaration methodDeclaration = (MethodDeclaration) node;
+		IMethodBinding mBinding = methodDeclaration.resolveBinding();
+		assertNotNull("Should not be null", mBinding);
+		ITypeBinding tBinding1 = mBinding.getReturnType();
+		assertNotNull("Should not be null", tBinding1);
+		
+		List params = methodDeclaration.parameters();
+		assertEquals("Incorrect params", 1, params.size());
+		SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(0);
+		ArrayType type = (ArrayType) param.getType();
+		ITypeBinding tBinding = type.resolveBinding();
+		assertNotNull("Should not be null", tBinding);
+		IAnnotationBinding[] annots = tBinding.getTypeAnnotations();
+		assertEquals("Incorrect type annotations", 2, annots.length);
+		assertEquals("Incorrect annotation", "@Marker()", annots[0].toString());
+		assertEquals("Incorrect annotation", "@Marker2()", annots[1].toString());
+		
+		node = getASTNode(compilationUnit, 2, 1);
+		assertTrue("Not a method declaration", node.getNodeType() == ASTNode.METHOD_DECLARATION);
+		methodDeclaration = (MethodDeclaration) node;
+		mBinding = methodDeclaration.resolveBinding();
+		assertNotNull("Should not be null", mBinding);
+		ITypeBinding tBinding2 = mBinding.getReturnType();
+		assertNotNull("Should not be null", tBinding1);
+		assertNotSame("Type bindings should not be same", tBinding1, tBinding2);
+		annots = tBinding1.getTypeAnnotations();
+		assertEquals("Incorrect type annotations", 1, annots.length);
+		IAnnotationBinding annot = annots[0];
+		assertEquals("Incorrect annotation", "@Marker(value = 1)", annot.toString());
+		annots = tBinding2.getTypeAnnotations();
+		assertEquals("Incorrect type annotations", 1, annots.length);
+		annot = annots[0];
+		assertEquals("Incorrect annotation", "@Marker(value = 3)", annot.toString());
+
+		node = getASTNode(compilationUnit, 2, 2);
+		assertTrue("Not a field declaration", node.getNodeType() == ASTNode.FIELD_DECLARATION);
+		FieldDeclaration field = (FieldDeclaration) node;
+		List fragments = field.fragments();
+		assertEquals("Incorrect no of fragments", 1, fragments.size());
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);
+		IVariableBinding variable = fragment.resolveBinding();
+		assertNotNull("Should not be null", variable);
+		ITypeBinding tBinding3 = variable.getType();
+		assertNotNull("Should not be null", tBinding3);
+		annots = tBinding3.getTypeAnnotations();
+
+		assertEquals("Incorrect type annotations", 2, annots.length);
+		assertEquals("Incorrect annotation", "@Marker(value = i0)", annots[0].toString());
+		assertEquals("Incorrect annotation", "@Marker2()", annots[1].toString());
+		tBinding3 = tBinding3.getComponentType();
+		annots = tBinding3.getTypeAnnotations();
+		assertEquals("Incorrect type annotations", 0, annots.length);
+		tBinding3 = tBinding3.getComponentType();
+		annots = tBinding3.getTypeAnnotations();
+		assertEquals("Incorrect type annotations", 1, annots.length);
+		assertEquals("Incorrect annotation", "@Marker(value = i1)", annots[0].toString());
+		
+		node = getASTNode(compilationUnit, 2, 3);
+		assertTrue("Not a field declaration", node.getNodeType() == ASTNode.FIELD_DECLARATION);
+		field = (FieldDeclaration) node;
+		fragments = field.fragments();
+		assertEquals("Incorrect no of fragments", 1, fragments.size());
+		fragment = (VariableDeclarationFragment) fragments.get(0);
+		variable = fragment.resolveBinding();
+		assertNotNull("Should not be null", variable);
+		tBinding1 = variable.getType();
+		
+		node = getASTNode(compilationUnit, 2, 4);
+		assertTrue("Not a field declaration", node.getNodeType() == ASTNode.FIELD_DECLARATION);
+		field = (FieldDeclaration) node;
+		fragments = field.fragments();
+		assertEquals("Incorrect no of fragments", 1, fragments.size());
+		fragment = (VariableDeclarationFragment) fragments.get(0);
+		variable = fragment.resolveBinding();
+		assertNotNull("Should not be null", variable);
+		tBinding2 = variable.getType();
+		assertSame("Type bindings should be same", tBinding1, tBinding2);
+		assertTrue("Unannotated bindings should be same", tBinding1.isEqualTo(tBinding2));
+		
+		node = getASTNode(compilationUnit, 2, 5);
+		assertTrue("Not a field declaration", node.getNodeType() == ASTNode.FIELD_DECLARATION);
+		field = (FieldDeclaration) node;
+		fragments = field.fragments();
+		assertEquals("Incorrect no of fragments", 1, fragments.size());
+		fragment = (VariableDeclarationFragment) fragments.get(0);
+		variable = fragment.resolveBinding();
+		assertNotNull("Should not be null", variable);
+		tBinding2 = variable.getType();
+		assertNotSame("Type bindings should not be same", tBinding1, tBinding2);
+		assertTrue("Unannotated bindings should be same", tBinding1.isEqualTo(tBinding2));
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
new file mode 100644
index 0000000..3e520e9
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
@@ -0,0 +1,1045 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.dom;
+
+import java.util.List;
+
+import junit.framework.Test;
+
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.ArrayCreation;
+import org.eclipse.jdt.core.dom.ArrayType;
+import org.eclipse.jdt.core.dom.CastExpression;
+import org.eclipse.jdt.core.dom.CatchClause;
+import org.eclipse.jdt.core.dom.ClassInstanceCreation;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.CreationReference;
+import org.eclipse.jdt.core.dom.EnhancedForStatement;
+import org.eclipse.jdt.core.dom.FieldDeclaration;
+import org.eclipse.jdt.core.dom.IAnnotationBinding;
+import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IfStatement;
+import org.eclipse.jdt.core.dom.InstanceofExpression;
+import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.ParameterizedType;
+import org.eclipse.jdt.core.dom.ParenthesizedExpression;
+import org.eclipse.jdt.core.dom.PrefixExpression;
+import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.TryStatement;
+import org.eclipse.jdt.core.dom.Type;
+import org.eclipse.jdt.core.dom.TypeDeclaration;
+import org.eclipse.jdt.core.dom.TypeMethodReference;
+import org.eclipse.jdt.core.dom.TypeParameter;
+import org.eclipse.jdt.core.dom.UnionType;
+import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
+import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
+import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
+import org.eclipse.jdt.core.dom.WildcardType;
+
+public class TypeBindingTests308 extends ConverterTestSetup {
+
+	ICompilationUnit workingCopy;
+
+	public static Test suite() {
+		return buildModelTestSuite(TypeBindingTests308.class);
+	}
+	public void setUpSuite() throws Exception {
+		super.setUpSuite();
+		this.ast = AST.newAST(AST.JLS8);
+	}
+	public TypeBindingTests308(String testName){
+		super(testName);
+	}
+	static {
+//		TESTS_NUMBERS = new int[] { };
+//		TESTS_RANGE = new int[] { };
+//		TESTS_NAMES = new String[] {"test027"};
+	}
+
+	private void verifyAnnotationOnType(Type type, String[] annots) {
+		verifyAnnotationsOnBinding(type.resolveBinding(), annots);
+	}
+
+	private void verifyAnnotationsOnBinding(ITypeBinding binding, String[] annots) {
+		IAnnotationBinding[] annotations = binding.getTypeAnnotations();
+		assertNotNull("Should not be null", annotations);
+		int length = annots.length;
+		assertEquals("Incorrect type use annotations", length, annotations.length);
+		for (int i = 0; i < length; i++) {
+			assertEquals("Incorrect annotation", annots[i], (annotations[i] == null) ? null : annotations[i].toString());
+		}
+	}
+	
+	public void test000() throws Exception {
+		String contents = 
+					"public class X extends @Marker @SingleMember(0) @Normal(value = 0) Object {\n" +
+					"}\n" +
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Marker {}\n" +
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface SingleMember { int value() default 0;}\n" +
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Normal { int value() default 0;}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		Type type = typeDecl.getSuperclassType();
+		assertNotNull("Super class should not be null", type);
+		
+		verifyAnnotationOnType(type, new String[]{"@Marker()", "@SingleMember(value = 0)", "@Normal(value = 0)"});
+	}
+	public void test001() throws Exception {
+		String contents = 
+				"public class X {\n" +
+						"    @Marker int x;\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect field", 1, fields.length);
+		FieldDeclaration field = fields[0];
+		verifyAnnotationOnType(field.getType(), new String[]{"@Marker()"});
+	}
+	public void test002() throws Exception {
+		String contents = 
+						"public class X {\n" +
+						"    @Marker <@Marker2 T> int x() { return 10; };\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_PARAMETER)\n" +
+						"@interface Marker2{}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List params = method.typeParameters();
+		TypeParameter param = (TypeParameter) params.get(0);
+		ITypeBinding binding = param.resolveBinding();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+		verifyAnnotationOnType(method.getReturnType2(), new String[]{"@Marker()"});
+	}
+	public void test003() throws Exception {
+		String contents = 
+						"public class X {\n" +
+						"    int x(@Marker int p) { return 10; };\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List params = method.parameters();
+		SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(0);
+		ITypeBinding binding = param.resolveBinding().getType();
+		
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+		verifyAnnotationOnType(param.getType(), new String[]{"@Marker()"});
+	}
+	public void test004() throws Exception {
+		String contents = 
+				"public class X {\n" +
+						"    int x(@Marker int ... p) { return 10; };\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List params = method.parameters();
+		SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(0);
+		verifyAnnotationOnType(param.getType(), new String[]{"@Marker()"});
+	}
+
+	public void test005() throws Exception {
+			String contents = 
+				"public class X {\n" +
+						"    int x(@Marker int @Marker2 [] @Marker3 ... p) { return 10; };\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker2 {}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker3 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List params = method.parameters();
+		SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(0);
+		ArrayType type = (ArrayType) param.getType();
+		ITypeBinding binding = type.resolveBinding();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+		verifyAnnotationsOnBinding(param.resolveBinding().getType(), new String[]{"@Marker2()"});
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+	}
+	public void test006() throws Exception {
+		String contents = 
+						"public class X {\n" +
+						"    int x() {\n" +
+						"        try {\n" +
+						"        } catch (@Marker NullPointerException | @Marker2 ArrayIndexOutOfBoundsException e) {\n" +
+						"        }\n" +
+						"        return 10;\n" +
+						"    }\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		TryStatement trySt = (TryStatement) statements.get(0);
+		CatchClause catchCl = (CatchClause) trySt.catchClauses().get(0);
+		UnionType union = (UnionType) catchCl.getException().getType();
+		types = union.types();
+		assertEquals("Incorrect union types", 2, types.size());
+		Type type = (Type) types.get(0);
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		
+		type = (Type) types.get(1);
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+	}	
+	public void test007() throws Exception {
+		String contents = 
+				"package java.lang;\n" +
+				"public class X {\n" +
+				"    public void x() throws Exception {\n" +
+				"        try (@Marker LocalStream p = null; final @Marker2 LocalStream q = null; @Marker3 final LocalStream r = null) {}\n" +
+				"    }\n" +
+				"}\n" +
+				"class LocalStream implements AutoCloseable {\n" +
+				"    public void close() throws Exception {}\n" +
+				"}\n" +
+				"interface AutoCloseable {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker3 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/java/lang/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 6, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		TryStatement trySt = (TryStatement) statements.get(0);
+		List resources = trySt.resources();
+		assertEquals("Incorrect no of resources", 3, resources.size());
+		VariableDeclarationExpression resource = (VariableDeclarationExpression) resources.get(0);
+		Type type = resource.getType();
+		assertNotNull("Resource type should not be null", type);
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		
+		resource = (VariableDeclarationExpression) resources.get(1);
+		type = resource.getType();
+		assertNotNull("Resource type should not be null", type);
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+		
+		resource = (VariableDeclarationExpression) resources.get(2);
+		type = resource.getType();
+		assertNotNull("Resource type should not be null", type);
+		verifyAnnotationOnType(type, new String[]{"@Marker3()"});
+	}
+	public void test008() throws Exception {
+		String contents = 
+				"public class X {\n" +
+						"    int x() {\n" +
+						"        for (@Marker int i: new int[3]) {}\n" +
+						"        for (final @Marker int i: new int[3]) {}\n" +
+						"        for (@Marker final int i: new int[3]) {}\n" +
+						"        return 10;\n" +
+						"    }\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		EnhancedForStatement forStmt = (EnhancedForStatement) statements.get(0);
+		SingleVariableDeclaration param = forStmt.getParameter();
+		Type type = param.getType();
+		assertNotNull("Resource type should not be null", type);
+		ITypeBinding binding = param.resolveBinding().getType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+		binding = type.resolveBinding();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+	}	
+	public void test009() throws Exception {
+		String contents = 
+				"interface I {\n" +
+				"    Object copy(int [] ia);\n" +
+				"}\n" +
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        I i = @Marker int @Marker2 []::clone;\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		TypeMethodReference lambda = (TypeMethodReference) fragment.getInitializer();
+		ArrayType type = (ArrayType) lambda.getType();
+
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+		ITypeBinding binding = type.resolveBinding();
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+	}
+	public void test010() throws Exception {
+		String contents = 
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        int i [] = new @Marker int @Marker2 [4];\n" +
+				"        int j [] = new @Marker2 int @Marker [] { 10 };\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		ArrayCreation arrayCr = (ArrayCreation) fragment.getInitializer();
+
+		ArrayType type = arrayCr.getType();
+		ITypeBinding binding = type.resolveBinding();
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+
+		stmt = (VariableDeclarationStatement) statements.get(1);
+		fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		arrayCr = (ArrayCreation) fragment.getInitializer();
+		type = arrayCr.getType();
+		
+		binding = type.resolveBinding();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+	}
+	public void test011() throws Exception {
+		String contents = 
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        int i = (@Marker int) 0;\n" +
+				"        int j [] = (@Marker int @Marker2 []) null;\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		CastExpression castExp = (CastExpression) fragment.getInitializer();
+		Type type = castExp.getType();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		
+		stmt = (VariableDeclarationStatement) statements.get(1);
+		fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		castExp = (CastExpression) fragment.getInitializer();
+		ArrayType arrayType = (ArrayType) castExp.getType();
+		
+		ITypeBinding binding = arrayType.resolveBinding();
+		verifyAnnotationOnType(arrayType, new String[]{"@Marker2()"});
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+	}
+	public void test012() throws Exception {
+		String contents = 
+				"public class X  {\n" +
+				"    public static void main(String args) {\n" +
+				"        if (args instanceof @Marker String) {\n" +
+				"        }\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		IfStatement ifStmt = (IfStatement) statements.get(0);
+		InstanceofExpression instanceOf = (InstanceofExpression) ifStmt.getExpression();
+		Type type = instanceOf.getRightOperand();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+	}
+	public void test013() throws Exception {
+			String contents = 
+				"public class X extends Y<@Marker(10) Integer, String> {}\n" +
+				"class Y<T, V> {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {int value();}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		ParameterizedType superClass = (ParameterizedType) typeDecl.getSuperclassType();
+		List arguments = superClass.typeArguments();
+		assertEquals("Incorrect no of type arguments", 2, arguments.size());
+		Type type = (Type) arguments.get(0);
+		
+		verifyAnnotationOnType(type, new String[]{"@Marker(value = 10)"});
+	}
+	public void test014() throws Exception {
+		String contents = 
+				"public class X<T extends Object & Comparable<? super @Marker String>> {}\n" +
+				"class Y<T> {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		List typeParams = typeDecl.typeParameters();
+
+		TypeParameter typeParam = (TypeParameter) typeParams.get(0);
+		List bounds = typeParam.typeBounds();
+		assertEquals("Incorrect no of type bounds", 2, bounds.size());
+		ParameterizedType type = (ParameterizedType) bounds.get(1);
+		typeParams = type.typeArguments();
+		assertEquals("Incorrect type params", 1, typeParams.size());
+		WildcardType wildcard = (WildcardType)typeParams.get(0);
+		Type bound = wildcard.getBound();
+		assertNotNull("Bound should not be null", bound);
+		verifyAnnotationOnType(bound, new String[]{"@Marker()"});
+	}
+	public void test015() throws Exception {
+		String contents = 
+				"public class X {\n" +
+				"	void foo(Map<@Marker ? super @Marker2 Object, @Marker3 ? extends @Marker4 String> m){}\n" +
+				"   void goo(Map<@Marker4 ? extends @Marker3 Object, @Marker2 ? super @Marker String> m){}\n" +
+				"}\n" +
+				"class Map<K, V>{}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker3 {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker4 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 6, types.size());
+		
+		MethodDeclaration[] methods = ((TypeDeclaration) types.get(0)).getMethods();
+		assertEquals("Incorrect no of metods", 2, methods.length);
+		MethodDeclaration method = methods[0];
+		SingleVariableDeclaration arg = (SingleVariableDeclaration) method.parameters().get(0);
+		
+		
+		List typeArgs = ((ParameterizedType) arg.getType()).typeArguments();
+		
+		WildcardType wildcard = (WildcardType) typeArgs.get(0);
+		verifyAnnotationOnType(wildcard, new String[]{"@Marker()"});
+		Type type = wildcard.getBound();
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+
+		wildcard = (WildcardType) typeArgs.get(1);
+		verifyAnnotationOnType(wildcard, new String[]{"@Marker3()"});
+		type = wildcard.getBound();
+		verifyAnnotationOnType(type, new String[]{"@Marker4()"});
+		
+		method = methods[1];
+		arg = (SingleVariableDeclaration) method.parameters().get(0);
+		typeArgs = ((ParameterizedType) arg.getType()).typeArguments();
+
+		wildcard = (WildcardType) typeArgs.get(0);
+		verifyAnnotationOnType(wildcard, new String[]{"@Marker4()"});
+		type = wildcard.getBound();
+		verifyAnnotationOnType(type, new String[]{"@Marker3()"});
+
+		wildcard = (WildcardType) typeArgs.get(1);
+		verifyAnnotationOnType(wildcard, new String[]{"@Marker2()"});
+		type = wildcard.getBound();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+	}
+	public void test016() throws Exception {
+		String contents = 
+				"public class X<E> {\n" +
+				"  class Y {\n" +
+				"    E e;\n" +
+				"    E getOtherElement(Object other) {\n" +
+				"      if (!(other instanceof @Marker X<?>.Y)) {};\n" +
+				"      return null;\n" +
+				"    }\n" +
+				"  }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		typeDecl = typeDecl.getTypes()[0];
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		IfStatement ifStmt = (IfStatement) method.getBody().statements().get(0);
+		PrefixExpression prefix = (PrefixExpression ) ifStmt.getExpression();
+		ParenthesizedExpression operand = (ParenthesizedExpression) prefix.getOperand();
+		InstanceofExpression expression = (InstanceofExpression) operand.getExpression();
+		QualifiedType type = (QualifiedType) expression.getRightOperand();
+		verifyAnnotationOnType(type, new String[]{});
+		verifyAnnotationOnType(type.getQualifier(), new String[]{"@Marker()"});
+	}
+	public void test017() throws Exception {
+		String contents = 
+				"public class X<P, C> {\n" +
+				"  public X() {\n" +
+				"    if (!(this instanceof @Marker X)) {}\n" +
+				"  }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		IfStatement ifStmt = (IfStatement) method.getBody().statements().get(0);
+		PrefixExpression prefix = (PrefixExpression ) ifStmt.getExpression();
+		ParenthesizedExpression operand = (ParenthesizedExpression) prefix.getOperand();
+		InstanceofExpression expression = (InstanceofExpression) operand.getExpression();
+		verifyAnnotationOnType(expression.getRightOperand(), new String[]{"@Marker()"});
+	}
+	public void test018() throws Exception {
+		String contents = 
+				"interface I {\n" +
+				"    void foo(Y<String>.Z z, int x);\n" +
+				"}\n" +
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        I i = Y<String>.@Marker Z::foo;\n" +
+				"        i.foo(new Y<String>().new Z(), 10); \n" +
+				"    }\n" +
+				"}\n" +
+				"class Y<T> {\n" +
+				"    class Z {\n" +
+				"        void foo(int x) {\n" +
+				"        }\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		VariableDeclarationStatement statement = (VariableDeclarationStatement) method.getBody().statements().get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		TypeMethodReference initializer = (TypeMethodReference) fragment.getInitializer();
+		Type type = initializer.getType();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		assertEquals("Should be a qualified type", ASTNode.QUALIFIED_TYPE, type.getNodeType());
+		verifyAnnotationOnType(((QualifiedType) type).getQualifier() , new String[]{});
+	}
+	public void test019() throws Exception {
+		String contents = 
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        X [] x = new @Marker X @Marker2 [5];\n" +
+				"        X [] x2 = new @Marker2 X @Marker [] { null };\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		List statements = method.getBody().statements();
+		assertEquals("Incorrect no of statements", 2, statements.size());
+		VariableDeclarationStatement statement = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		ArrayCreation initializer = (ArrayCreation) fragment.getInitializer();
+		ArrayType arrayType = initializer.getType();
+		ITypeBinding binding = arrayType.resolveBinding();
+		
+		verifyAnnotationOnType(arrayType, new String[]{"@Marker2()"});
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+		
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+
+		statement = (VariableDeclarationStatement) statements.get(1);
+		fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		initializer = (ArrayCreation) fragment.getInitializer();
+		arrayType = initializer.getType();
+		binding = arrayType.resolveBinding();
+		verifyAnnotationOnType(arrayType, new String[]{"@Marker()"});
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+		
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+	}
+	public void test020() throws Exception {
+		String contents = 
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        Map.Entry<String, String> [] e = (Map.@Marker Entry<String, String> []) null;\n" +
+				"    }\n" +
+				"}\n" +
+				"class Map<K, V> {\n" +
+				"	interface Entry<K, V> {}\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		List statements = method.getBody().statements();
+		assertEquals("Incorrect no of statements", 1, statements.size());
+		VariableDeclarationStatement statement = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		CastExpression castExp = (CastExpression) fragment.getInitializer();
+		ArrayType arrayType = (ArrayType) castExp.getType();
+		verifyAnnotationOnType(arrayType, new String[]{});
+		ParameterizedType type = (ParameterizedType) arrayType.getElementType();
+		verifyAnnotationOnType(type.getType(), new String[]{"@Marker()"});
+	}
+	public void test021() throws Exception {
+		String contents = 
+				"import java.io.Serializable;\n" +
+				"import java.util.List;\n" +
+				"public class X<T extends Comparable<T> & Serializable> {\n" +
+				"	void foo(List<? extends @Marker @Marker2 Comparable<T>> p) {} \n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		SingleVariableDeclaration param = (SingleVariableDeclaration) method.parameters().get(0);
+		Type type = param.getType();
+		assertEquals("Should be a parameterized type", ASTNode.PARAMETERIZED_TYPE, type.getNodeType());
+		List typeArgs = ((ParameterizedType) type).typeArguments();
+		assertEquals("Incorrect type args", 1, typeArgs.size());
+		WildcardType wildcard = (WildcardType) typeArgs.get(0);
+		ParameterizedType bound = (ParameterizedType) wildcard.getBound();
+		verifyAnnotationOnType(bound, new String[]{"@Marker()", "@Marker2()"});
+	}
+	public void test022() throws Exception {
+		String contents = 
+				"public class X {\n" +
+				"    X x = new @Marker X();\n" +
+				"    X y = new <String> @Marker X();\n" +	
+				"	<T> X(){}\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect no of fields", 2, fields.length);
+		FieldDeclaration field = fields[0];
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
+		ClassInstanceCreation creation = (ClassInstanceCreation) fragment.getInitializer();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
+		
+		field = fields[1];
+		fragment = (VariableDeclarationFragment) field.fragments().get(0);
+		creation = (ClassInstanceCreation) fragment.getInitializer();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
+	}
+	public void test023() throws Exception {
+		String contents = 
+				"public class X {\n" +
+				"    class Y {\n" +
+				"	    <T> Y(){}\n" +
+				"    }\n" +
+				"    Y y1 = new @Marker X().new @Marker2 Y();\n" +
+				"    Y y2 = new @Marker2 X().new <String> @Marker Y();\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect no of fields", 2, fields.length);
+		FieldDeclaration field = fields[0];
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
+		ClassInstanceCreation creation = (ClassInstanceCreation) fragment.getInitializer();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker2()"});
+		creation = (ClassInstanceCreation) creation.getExpression();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
+		
+		field = fields[1];
+		fragment = (VariableDeclarationFragment) field.fragments().get(0);
+		creation = (ClassInstanceCreation) fragment.getInitializer();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
+		creation = (ClassInstanceCreation) creation.getExpression();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker2()"});
+	}
+	public void test024() throws Exception {
+		String contents = 
+				"public class X {\n" +
+				"    void foo() throws @Marker NullPointerException, @Marker2 ArrayIndexOutOfBoundsException {}\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		List thrownTypes = method.thrownExceptionTypes();
+		assertEquals("Incorrect no of thrown exceptions", 2, thrownTypes.size());
+		Type type = (Type) thrownTypes.get(0);
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		type = (Type) thrownTypes.get(1);
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+	}
+	public void test025() throws Exception {
+		String contents = 
+				"interface I {}\n" +
+				"interface J {}\n" +
+				"interface K extends @Marker I, @Marker2 J {}\n" +
+				"interface L {}\n" +
+				"public class X implements @Marker2 K, @Marker L {\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 7, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(2);
+		List interfaces = typeDecl.superInterfaceTypes();
+		assertEquals("Incorrect no of super interfaces", 2, interfaces.size());
+		verifyAnnotationOnType((Type) interfaces.get(0), new String[]{"@Marker()"});
+		verifyAnnotationOnType((Type) interfaces.get(1), new String[]{"@Marker2()"});
+		
+		typeDecl = (TypeDeclaration) types.get(4);
+		interfaces = typeDecl.superInterfaceTypes();
+		assertEquals("Incorrect no of super interfaces", 2, interfaces.size());
+		verifyAnnotationOnType((Type) interfaces.get(0), new String[]{"@Marker2()"});
+		verifyAnnotationOnType((Type) interfaces.get(1), new String[]{"@Marker()"});
+	}
+	public void test026() throws Exception {
+		String contents = 
+				"interface I {\n" +
+				"    void foo(int x);\n" +
+				"}\n" +
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        I i = A.Y.@Marker Z ::foo;\n" +
+				"        i.foo(10); \n" +
+				"    }\n" +
+				"}\n" +
+				"class A {\n" +
+				"  static class Y {\n" +
+				"    static class Z {\n" +
+				"        public static void foo(int x) {\n" +
+				"	        System.out.println(x);\n" +
+				"        }\n" +
+				"    }\n" +
+				"  }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		List statements = method.getBody().statements();
+		
+		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		TypeMethodReference lambda = (TypeMethodReference) fragment.getInitializer();
+		Type type = lambda.getType();
+
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		verifyAnnotationOnType(((QualifiedType)type).getQualifier(), new String[]{});
+	}
+	public void test027() throws Exception {
+		String contents = 
+				"interface I {\n" +
+				"    Y foo(int x);\n" +
+				"}\n" +
+				"public class X  {\n" +
+				"    class Z extends Y {\n" +
+				"        public Z(int x) {\n" +
+				"            super(x);\n" +
+				"        }\n" +
+				"    }\n" +
+				"    public static void main(String [] args) {\n" +
+				"        I i = @Marker W<@Marker2 Integer>::<@Marker3 String> new;\n" +
+				"    }\n" +
+				"}\n" +
+				"class W<T> extends Y {\n" +
+				"    public <C> W(T x) {\n" +
+				"        super(0);\n" +
+				"    }\n" +
+				"}\n" +
+				"class Y {\n" +
+				"    public Y(int x) {\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker3 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 7, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		List statements = method.getBody().statements();
+		VariableDeclarationStatement statement = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		CreationReference lambda = (CreationReference) fragment.getInitializer();
+		Type type = lambda.getType();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		ParameterizedType paramType = (ParameterizedType) type;
+		verifyAnnotationOnType((Type) paramType.typeArguments().get(0), new String[]{"@Marker2()"});
+		List typeArgs = lambda.typeArguments();
+		verifyAnnotationOnType((Type) typeArgs.get(0), new String[]{"@Marker3()"});
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index e4d5816..b0b1224 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -880,15 +880,24 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	private static TypeBinding mergeAnnotationsIntoType(BlockScope scope, AnnotationBinding[] se8Annotations, long se8nullBits, Annotation se8NullAnnotation,
 			TypeReference typeRef, TypeBinding existingType) 
 	{
+		if (existingType == null || !existingType.isValidBinding()) return existingType;
+		TypeReference unionRef = typeRef.isUnionType() ? ((UnionTypeReference) typeRef).typeReferences[0] : null;
+		
 		long prevNullBits = existingType.tagBits & TagBits.AnnotationNullMASK;
 		if (se8nullBits != 0 && prevNullBits != se8nullBits && ((prevNullBits | se8nullBits) == TagBits.AnnotationNullMASK)) {
 			scope.problemReporter().contradictoryNullAnnotations(se8NullAnnotation);
 		}
-		TypeBinding oldLeafType = existingType.leafComponentType();
+		TypeBinding oldLeafType = (unionRef == null) ? existingType.leafComponentType() : unionRef.resolvedType;
 		AnnotationBinding [][] goodies = new AnnotationBinding[typeRef.getAnnotatableLevels()][];
 		goodies[0] = se8Annotations;  // @T X.Y.Z local; ==> @T should annotate X
 		TypeBinding newLeafType = scope.environment().createAnnotatedType(oldLeafType, goodies);
-		return typeRef.resolvedType = existingType.isArrayType() ? scope.environment().createArrayType(newLeafType, existingType.dimensions(), existingType.getTypeAnnotations()) : newLeafType;
+
+		if (unionRef == null) {
+			typeRef.resolvedType = existingType.isArrayType() ? scope.environment().createArrayType(newLeafType, existingType.dimensions(), existingType.getTypeAnnotations()) : newLeafType;
+		} else {
+			unionRef.resolvedType = newLeafType;
+		}
+		return typeRef.resolvedType;
 	}
 
 /**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index 4b7bdc7..c17c5d4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -482,6 +482,9 @@ public boolean isTypeReference() {
 public boolean isWildcard() {
 	return false;
 }
+public boolean isUnionType() {
+	return false;
+}
 public boolean isParameterizedTypeReference() {
 	return false;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnionTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnionTypeReference.java
index 9a4e07c..275a5b1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnionTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/UnionTypeReference.java
@@ -159,7 +159,9 @@ public class UnionTypeReference extends TypeReference {
 		}
 		return output;
 	}
-
+	public boolean isUnionType() {
+		return true;
+	}
 	public TypeReference copyDims(int dim, Annotation[][] annotationsOnDimensions) {
 		return this; // arrays are not legal as union types.
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index b407d15..9131ca0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -1278,6 +1278,11 @@ public MethodBinding[] methods() {
 	this.tagBits |= TagBits.AreMethodsComplete;
 	return this.methods;
 }
+
+public TypeBinding prototype() {
+	return this.prototype;
+}
+
 private FieldBinding resolveTypeFor(FieldBinding field) {
 	
 	if (this != this.prototype)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 337ef6b..ff9837c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -860,8 +860,12 @@ public abstract class Scope {
 	}
 
 	public ArrayBinding createArrayType(TypeBinding type, int dimension) {
+		return createArrayType(type, dimension, Binding.NO_ANNOTATIONS);
+	}
+
+	public ArrayBinding createArrayType(TypeBinding type, int dimension, AnnotationBinding[] annotations) {
 		if (type.isValidBinding())
-			return environment().createArrayType(type, dimension);
+			return environment().createArrayType(type, dimension, annotations);
 		// do not cache obvious invalid types
 		return new ArrayBinding(type, dimension, environment());
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 47a8321..ae2d661 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -1562,6 +1562,11 @@ public MethodBinding[] methods() {
 	}
 	return this.methods;
 }
+
+public TypeBinding prototype() {
+	return this.prototype;
+}
+
 public FieldBinding resolveTypeFor(FieldBinding field) {
 	
 	if (this != this.prototype)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index aa4a115..9b82212 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -1430,5 +1430,12 @@ public static boolean notEquals(TypeBinding that, TypeBinding other) {
 		return false;
 	return true;
 }
+/** Return the primordial type from which the receiver was cloned. Not all types track a prototype, only {@link SourceTypeBinding},
+ * {@link BinaryTypeBinding} and {@link UnresolvedReferenceBinding} do so as of now. In fact some types e.g {@link ParameterizedTypeBinding}
+ * should not do so. Deflecting a query to a prototype would lead to wrong results in the case of {@link ParameterizedTypeBinding}
+ */
+public TypeBinding prototype() {
+	return null;
+}
 
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedReferenceBinding.java
index 7e6b83e..00155f2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedReferenceBinding.java
@@ -79,6 +79,11 @@ public boolean hasTypeBit(int bit) {
 	// shouldn't happen since we are not called before analyseCode(), but play safe:
 	return false;
 }
+
+public TypeBinding prototype() {
+	return this.prototype;
+}
+
 ReferenceBinding resolve(LookupEnvironment environment, boolean convertGenericToRawType) {
 	if (this != this.prototype) {
 		this.prototype.resolve(environment, convertGenericToRawType);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
index 7bcf9f8..11a230c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
@@ -27,10 +27,10 @@ import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
 import org.eclipse.jdt.internal.compiler.ast.FieldReference;
-import org.eclipse.jdt.internal.compiler.ast.JavadocImplicitTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;
 import org.eclipse.jdt.internal.compiler.ast.JavadocAllocationExpression;
 import org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference;
+import org.eclipse.jdt.internal.compiler.ast.JavadocImplicitTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend;
 import org.eclipse.jdt.internal.compiler.ast.JavadocQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.JavadocSingleNameReference;
@@ -1603,7 +1603,8 @@ class DefaultBindingResolver extends BindingResolver {
 					}
 					ArrayType arrayType = (ArrayType) type;
 					ArrayBinding arrayBinding = (ArrayBinding) typeBinding;
-					return getTypeBinding(this.scope.createArrayType(arrayBinding.leafComponentType, arrayType.getDimensions()));
+					int dimensions = arrayType.getDimensions();
+					return getTypeBinding(this.scope.createArrayType(arrayBinding.leafComponentType, dimensions, getTypeAnnotations(dimensions, arrayBinding)));
 				}
 				if (typeBinding.isArrayType()) {
 					// 'typeBinding' can still be an array type because 'node' may be "larger" than 'type' (see comment of newAstToOldAst).
@@ -1652,7 +1653,8 @@ class DefaultBindingResolver extends BindingResolver {
 						return null;
 					}
 					ArrayBinding arrayBinding = (ArrayBinding) binding;
-					return getTypeBinding(this.scope.createArrayType(arrayBinding.leafComponentType, arrayType.getDimensions()));
+					int dimensions = arrayType.getDimensions();
+					return getTypeBinding(this.scope.createArrayType(arrayBinding.leafComponentType, dimensions, getTypeAnnotations(dimensions, arrayBinding)));
 				} else if (binding.isArrayType()) {
 					// 'binding' can still be an array type because 'node' may be "larger" than 'type' (see comment of newAstToOldAst).
 					ArrayBinding arrayBinding = (ArrayBinding) binding;
@@ -1671,6 +1673,22 @@ class DefaultBindingResolver extends BindingResolver {
 		return null;
 	}
 
+	private org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding[] getTypeAnnotations(int dimensions, ArrayBinding binding) {
+		org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding [] oldies = binding.getTypeAnnotations();
+		org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding[] newbies = Binding.NO_ANNOTATIONS;
+		for (int i = 0, length = oldies == null ? 0 : oldies.length; i < length; i++) {
+			if (oldies[i] == null) {
+				dimensions--;
+				if (dimensions == 0) {
+					System.arraycopy(oldies, 0, newbies = 
+							new org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding[i+1], 0, i+1);
+					break;
+				}
+			}
+		}
+		return newbies;
+	}
+
 	/*
 	 * Method declared on BindingResolver.
 	 */
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ITypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ITypeBinding.java
index b32089a..61aa3a4 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ITypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ITypeBinding.java
@@ -965,4 +965,23 @@ public interface ITypeBinding extends IBinding {
 	 * @see #isUpperbound()
 	 */
 	public boolean isWildcardType();
+
+	/**
+	 * Returns the annotations that this type reference is annotated with. Since JLS8, 
+	 * multiple instances of type bindings may be created if they are annotated with 
+	 * different type use annotations.
+	 * <p>
+	 * For example, the following two type references would produce two distinct type 
+	 * bindings for java.lang.String.
+	 * <ul>
+	 * <li>java.lang.@Marker1 String</li>
+	 * <li>java.lang.@Marker2 String</li>
+	 * </ul>
+	 * </p>
+	 * @return type annotations specified on this type reference, or an empty array if
+	 * no type use annotations are found.
+	 * @since 3.9 BETA_JAVA8
+	 */
+	public IAnnotationBinding[] getTypeAnnotations();
+	
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
index b579b41..4f04fa8 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
@@ -715,4 +715,8 @@ class RecoveredTypeBinding implements ITypeBinding {
 		}
 		return null; // should not happen
 	}
+
+	public IAnnotationBinding[] getTypeAnnotations() {
+		return AnnotationBinding.NoAnnotations;
+	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
index bf82a02..f7fe232 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
@@ -58,10 +58,12 @@ class TypeBinding implements ITypeBinding {
 		Modifier.ABSTRACT | Modifier.STATIC | Modifier.FINAL | Modifier.STRICTFP;
 
 	org.eclipse.jdt.internal.compiler.lookup.TypeBinding binding;
+	private TypeBinding prototype = null;
 	private String key;
 	private BindingResolver resolver;
 	private IVariableBinding[] fields;
 	private IAnnotationBinding[] annotations;
+	private IAnnotationBinding[] typeAnnotations;
 	private IMethodBinding[] methods;
 	private ITypeBinding[] members;
 	private ITypeBinding[] interfaces;
@@ -72,6 +74,8 @@ class TypeBinding implements ITypeBinding {
 	public TypeBinding(BindingResolver resolver, org.eclipse.jdt.internal.compiler.lookup.TypeBinding binding) {
 		this.binding = binding;
 		this.resolver = resolver;
+		org.eclipse.jdt.internal.compiler.lookup.TypeBinding compilerPrototype = binding.prototype();
+		this.prototype = (TypeBinding) (compilerPrototype == null || compilerPrototype == binding ? null : resolver.getTypeBinding(compilerPrototype));
 	}
 
 	public ITypeBinding createArrayType(int dimension) {
@@ -84,6 +88,9 @@ class TypeBinding implements ITypeBinding {
 	}
 
 	public IAnnotationBinding[] getAnnotations() {
+		if (this.prototype != null) {
+			return this.prototype.getAnnotations();
+		}
 		if (this.annotations != null) {
 			return this.annotations;
 		}
@@ -94,29 +101,35 @@ class TypeBinding implements ITypeBinding {
 			refType = (org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding) this.binding;
 		}
 		if (refType != null) {
-			org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding[] internalAnnotations = refType.getAnnotations();
-			int length = internalAnnotations == null ? 0 : internalAnnotations.length;
-			if (length != 0) {
-				IAnnotationBinding[] tempAnnotations = new IAnnotationBinding[length];
-				int convertedAnnotationCount = 0;
-				for (int i = 0; i < length; i++) {
-					org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding internalAnnotation = internalAnnotations[i];
-					IAnnotationBinding annotationInstance = this.resolver.getAnnotationInstance(internalAnnotation);
-					if (annotationInstance == null) {
-						continue;
-					}
-					tempAnnotations[convertedAnnotationCount++] = annotationInstance;
+			return this.annotations = resolveAnnotationBindings(refType.getAnnotations(), false);
+		}
+		return this.annotations = AnnotationBinding.NoAnnotations;
+	}
+	private IAnnotationBinding[] resolveAnnotationBindings(org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding[] internalAnnotations, boolean isTypeUse) {
+		int length = internalAnnotations == null ? 0 : internalAnnotations.length;
+		if (length != 0) {
+			IAnnotationBinding[] tempAnnotations = new IAnnotationBinding[length];
+			int convertedAnnotationCount = 0;
+			for (int i = 0; i < length; i++) {
+				org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding internalAnnotation = internalAnnotations[i];
+				if (isTypeUse && internalAnnotation == null) {
+					break;
 				}
-				if (convertedAnnotationCount != length) {
-					if (convertedAnnotationCount == 0) {
-						return this.annotations = AnnotationBinding.NoAnnotations;
-					}
-					System.arraycopy(tempAnnotations, 0, (tempAnnotations = new IAnnotationBinding[convertedAnnotationCount]), 0, convertedAnnotationCount);
+				IAnnotationBinding annotationInstance = this.resolver.getAnnotationInstance(internalAnnotation);
+				if (annotationInstance == null) {
+					continue;
 				}
-				return this.annotations = tempAnnotations;
+				tempAnnotations[convertedAnnotationCount++] = annotationInstance;
 			}
+			if (convertedAnnotationCount != length) {
+				if (convertedAnnotationCount == 0) {
+					return this.annotations = AnnotationBinding.NoAnnotations;
+				}
+				System.arraycopy(tempAnnotations, 0, (tempAnnotations = new IAnnotationBinding[convertedAnnotationCount]), 0, convertedAnnotationCount);
+			}
+			return tempAnnotations;
 		}
-		return this.annotations = AnnotationBinding.NoAnnotations;
+		return AnnotationBinding.NoAnnotations;
 	}
 
 	/*
@@ -219,6 +232,9 @@ class TypeBinding implements ITypeBinding {
 	 * @see ITypeBinding#getDeclaredFields()
 	 */
 	public synchronized IVariableBinding[] getDeclaredFields() {
+		if (this.prototype != null) {
+			return this.prototype.getDeclaredFields();
+		}
 		if (this.fields != null) {
 			return this.fields;
 		}
@@ -262,6 +278,9 @@ class TypeBinding implements ITypeBinding {
 	 * @see ITypeBinding#getDeclaredMethods()
 	 */
 	public synchronized IMethodBinding[] getDeclaredMethods() {
+		if (this.prototype != null) {
+			return this.prototype.getDeclaredMethods();
+		}
 		if (this.methods != null) {
 			return this.methods;
 		}
@@ -314,6 +333,9 @@ class TypeBinding implements ITypeBinding {
 	 * @see ITypeBinding#getDeclaredTypes()
 	 */
 	public synchronized ITypeBinding[] getDeclaredTypes() {
+		if (this.prototype != null) {
+			return this.prototype.getDeclaredTypes();
+		}
 		if (this.members != null) {
 			return this.members;
 		}
@@ -459,6 +481,9 @@ class TypeBinding implements ITypeBinding {
 	}
 
 	public synchronized ITypeBinding[] getInterfaces() {
+		if (this.prototype != null) {
+			return this.prototype.getInterfaces();
+		}
 		if (this.interfaces != null) {
 			return this.interfaces;
 		}
@@ -829,6 +854,9 @@ class TypeBinding implements ITypeBinding {
 	 * @see org.eclipse.jdt.core.dom.ITypeBinding#getTypeArguments()
 	 */
 	public ITypeBinding[] getTypeArguments() {
+		if (this.prototype != null) {
+			return this.prototype.getTypeArguments();
+		}
 		if (this.typeArguments != null) {
 			return this.typeArguments;
 		}
@@ -853,6 +881,9 @@ class TypeBinding implements ITypeBinding {
 	 * @see org.eclipse.jdt.core.dom.ITypeBinding#getTypeBounds()
 	 */
 	public ITypeBinding[] getTypeBounds() {
+		if (this.prototype != null) {
+			return this.prototype.getTypeBounds();
+		}
 		if (this.bounds != null) {
 			return this.bounds;
 		}
@@ -905,6 +936,9 @@ class TypeBinding implements ITypeBinding {
 	 * @see org.eclipse.jdt.core.dom.ITypeBinding#getTypeParameters()
 	 */
 	public ITypeBinding[] getTypeParameters() {
+		if (this.prototype != null) {
+			return this.prototype.getTypeParameters();
+		}
 		if (this.typeParameters != null) {
 			return this.typeParameters;
 		}
@@ -1071,6 +1105,9 @@ class TypeBinding implements ITypeBinding {
 			return false;
 		}
 		org.eclipse.jdt.internal.compiler.lookup.TypeBinding otherBinding = ((TypeBinding) other).binding;
+		if (otherBinding.unannotated() == this.binding.unannotated()) {
+			return true;
+		}
 		// check return type
 		return BindingComparator.isEqual(this.binding, otherBinding);
 	}
@@ -1284,4 +1321,15 @@ class TypeBinding implements ITypeBinding {
 	public String toString() {
 		return this.binding.toString();
 	}
+
+	/*
+	 * @see ITypeBinding#getTypeUseAnnotations()
+	 */
+	public IAnnotationBinding[] getTypeAnnotations() {
+		if (this.typeAnnotations != null) {
+			return this.typeAnnotations;
+		}
+		this.typeAnnotations = resolveAnnotationBindings(this.binding.getTypeAnnotations(), true);
+		return this.typeAnnotations;
+	}
 }
