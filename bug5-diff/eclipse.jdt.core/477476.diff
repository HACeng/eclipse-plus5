commit 1d27cfb65a8550e3dd44f890da53c4bdcdcccdbf
Author: Mateusz Matela <mateusz.matela@gmail.com>
Date:   Sat Nov 7 15:44:07 2015 +0100

    Bug 477476 - Auto-formatter gets indentation wrong when used as post-save action
    
    Signed-off-by: Mateusz Matela <mateusz.matela@gmail.com>

10	10	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterBugsTests.java
5	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsBugsTest.java
39	8	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
97	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_in.java
97	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_out.java
97	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_in.java
98	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_out.java
4	21	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java
7	4	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
44	20	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/TextEditsBuilder.java
33	21	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Token.java
3	2	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/CommentWrapExecutor.java
0	7	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/FieldAligner.java
115	101	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
247	75	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterBugsTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterBugsTests.java
index c674922..6517312 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterBugsTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterBugsTests.java
@@ -5746,7 +5746,7 @@ public void testBug302123() {
 		"public class Test {\n" + 
 		"	public static void main(String[] args) {\n" + 
 		"		String s = \"X\" + /** ***/\n" + 
-		"		\"Y\";\n" + 
+		"				\"Y\";\n" + 
 		"	}\n" + 
 		"\n" + 
 		"}\n"
@@ -5767,7 +5767,7 @@ public void testBug302123b() {
 		"public class Test {\n" + 
 		"	public static void main(String[] args) {\n" + 
 		"		String s = \"X\" + /** XXX ***/\n" + 
-		"		\"Y\";\n" + 
+		"				\"Y\";\n" + 
 		"	}\n" + 
 		"\n" + 
 		"}\n"
@@ -5788,7 +5788,7 @@ public void testBug302123c() {
 		"public class Test {\n" + 
 		"	public static void main(String[] args) {\n" + 
 		"		String s = \"X\" + /** ** XXX ** ***/\n" + 
-		"		\"Y\";\n" + 
+		"				\"Y\";\n" + 
 		"	}\n" + 
 		"\n" + 
 		"}\n"
@@ -5809,7 +5809,7 @@ public void testBug302123d() {
 		"public class Test {\n" + 
 		"	public static void main(String[] args) {\n" + 
 		"		String s = \"X\" + /** AAA *** BBB *** CCC ***/\n" + 
-		"		\"Y\";\n" + 
+		"				\"Y\";\n" + 
 		"	}\n" + 
 		"\n" + 
 		"}\n"
@@ -11279,8 +11279,8 @@ public void testBug474918() {
 		"	int					bb					= 4;\r\n" + 
 		"\r\n" + 
 		"	Object				c					= new Object() {\r\n" + 
-		"												int			a				= 55;\r\n" + 
-		"												Object		cdddddddddddd	= null;\r\n" + 
+		"												int		a				= 55;\r\n" + 
+		"												Object	cdddddddddddd	= null;\r\n" + 
 		"											};\r\n" + 
 		"\r\n" + 
 		"	private enum E {\r\n" + 
@@ -11344,8 +11344,8 @@ public void testBug474918b() {
 		"    int              bb               = 4;\r\n" + 
 		"\r\n" + 
 		"    Object           c                = new Object() {\r\n" + 
-		"                                          int      a             = 55;\r\n" + 
-		"                                          Object   cdddddddddddd = null;\r\n" + 
+		"                                          int    a             = 55;\r\n" + 
+		"                                          Object cdddddddddddd = null;\r\n" + 
 		"                                      };\r\n" + 
 		"\r\n" + 
 		"    private enum E {\r\n" + 
@@ -11409,8 +11409,8 @@ public void testBug474918c() {
 		"	int					bb					= 4;\r\n" + 
 		"\r\n" + 
 		"	Object				c					= new Object() {\r\n" + 
-		"		                                        int			a				= 55;\r\n" + 
-		"		                                        Object		cdddddddddddd	= null;\r\n" + 
+		"		                                        int		a				= 55;\r\n" + 
+		"		                                        Object	cdddddddddddd	= null;\r\n" + 
 		"	                                        };\r\n" + 
 		"\r\n" + 
 		"	private enum E {\r\n" + 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsBugsTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsBugsTest.java
index 4f6a2b8..f6e8a03 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsBugsTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterCommentsBugsTest.java
@@ -2056,7 +2056,7 @@ public void testBug234583_Bug237592() throws JavaModelException {
 		"	\n" + 
 		"	\n" + 
 		"	\n" + 
-		"	 \n" + 
+		"\n" + 
 		"	\n" + 
 		"	\n" + 
 		"	\n" + 
@@ -2339,8 +2339,8 @@ public void testBug236406_EX1() {
 	formatSource(source,
 		"//        Line		comment    	    \n" + 
 		"i =\n" + 
-		"/**        Javadoc		comment    	    */\n" + 
-		"1 + (/*      Block		comment*/++a)\n",
+		"		/**        Javadoc		comment    	    */\n" + 
+		"		1 + (/*      Block		comment*/++a)\n",
 		CodeFormatter.K_EXPRESSION
 	);
 }
@@ -2353,8 +2353,8 @@ public void testBug236406_EX2() {
 	formatSource(source,
 		"// Line comment\n" + 
 		"i =\n" + 
-		"/** Javadoc comment */\n" + 
-		"1 + (/* Block comment */++a)\n",
+		"		/** Javadoc comment */\n" + 
+		"		1 + (/* Block comment */++a)\n",
 		CodeFormatter.K_EXPRESSION | CodeFormatter.F_INCLUDE_COMMENTS
 	);
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
index 566dd2c..d7cdd89 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
@@ -15,6 +15,7 @@ package org.eclipse.jdt.core.tests.formatter;
 
 import java.io.BufferedInputStream;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Map;
@@ -76,6 +77,16 @@ public class FormatterRegressionTests extends AbstractJavaModelTests {
 		super(name);
 	}
 
+	/**
+	 * Helper method for tests that require a certain compiler compliance level.
+	 * @param level use one of the {@code CompilerOptions.VERSION_***} constants
+	 */
+	protected void setComplianceLevel(String level) {
+		this.formatterOptions.put(CompilerOptions.OPTION_Compliance, level);
+		this.formatterOptions.put(CompilerOptions.OPTION_TargetPlatform, level);
+		this.formatterOptions.put(CompilerOptions.OPTION_Source, level);
+	}
+
 	/* 
 	 * helper function for tests that are compatible with earlier page width
 	 */
@@ -277,8 +288,7 @@ public class FormatterRegressionTests extends AbstractJavaModelTests {
 	void formatSource(String source, String formattedOutput, int kind, int indentationLevel, boolean repeat) {
 		int regionStart = source.indexOf("[#");
 		if (regionStart != -1) {
-			IRegion[] regions =  new Region[10];
-			int idx = 0;
+			ArrayList<IRegion> regions =  new ArrayList<>();
 			int start = 0;
 			int delta = 0;
 			StringBuffer buffer = new StringBuffer();
@@ -286,7 +296,7 @@ public class FormatterRegressionTests extends AbstractJavaModelTests {
 				buffer.append(source.substring(start, regionStart));
 				int regionEnd = source.indexOf("#]", regionStart+2);
 				buffer.append(source.substring(regionStart+2, regionEnd));
-				regions[idx++] = new Region(regionStart-delta, regionEnd-(regionStart+2));
+				regions.add(new Region(regionStart-delta, regionEnd-(regionStart+2)));
 				delta += 4;
 				start = regionEnd + 2;
 				regionStart = source.indexOf("[#", start);
@@ -294,12 +304,12 @@ public class FormatterRegressionTests extends AbstractJavaModelTests {
 			buffer.append(source.substring(start, source.length()));
 			String newSource = buffer.toString();
 			String result;
-			if (idx == 1) {
+			if (regions.size() == 1) {
 				// Use offset and length until bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=233967 is fixed
-				result = runFormatter(codeFormatter(), newSource, kind, indentationLevel, regions[0].getOffset(), regions[0].getLength(), LINE_SEPARATOR, repeat);
+				result = runFormatter(codeFormatter(), newSource, kind, indentationLevel, regions.get(0).getOffset(), regions.get(0).getLength(), LINE_SEPARATOR, repeat);
 			} else {
-				System.arraycopy(regions, 0, regions = new Region[idx], 0, idx);
-				result = runFormatter(codeFormatter(), newSource, kind, indentationLevel, regions, LINE_SEPARATOR);
+				IRegion[] regionsArray = regions.toArray(new IRegion[regions.size()]);
+				result = runFormatter(codeFormatter(), newSource, kind, indentationLevel, regionsArray, LINE_SEPARATOR);
 			}
 			assertLineEquals(result, newSource, formattedOutput);
 		} else {
@@ -13113,5 +13123,26 @@ public void testBug467229() throws IOException {
 	String key = keysToCheck[0]; // the other is lost in this conversion
 	assertEquals(key, optionsMap.get(key), optionsMap2.get(key));
 }
-
+/**
+ * https://bugs.eclipse.org/477476 - Auto-formatter gets indentation wrong when used as post-save action
+ */
+public void testBug477476a() {
+	setComplianceLevel(CompilerOptions.VERSION_1_5);
+	this.formatterPrefs.use_tabs_only_for_leading_indentations = true;
+	runTest(codeFormatter(), "test477476a", "A.java", CodeFormatter.K_COMPILATION_UNIT, false);
+}
+/**
+ * https://bugs.eclipse.org/477476 - Auto-formatter gets indentation wrong when used as post-save action
+ */
+public void testBug477476b() {
+	setComplianceLevel(CompilerOptions.VERSION_1_5);
+	try {
+		String input = getCompilationUnit("Formatter" , "", "test477476b", "A_in.java").getSource();
+		String output = getCompilationUnit("Formatter" , "", "test477476b", "A_out.java").getSource();
+		formatSource(input, output);
+	} catch (JavaModelException e) {
+		e.printStackTrace();
+		assertTrue(false);
+	}
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_in.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_in.java
new file mode 100644
index 0000000..b78fe42
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_in.java
@@ -0,0 +1,97 @@
+package org.example;
+
+import java.util.Arrays;
+
+public class Example //
+extends //
+Object //
+implements //
+Runnable//
+, //
+Serializable //
+{
+	public enum ExampleEnum //
+implements //
+Runnable//
+, //
+Serializable {
+		/** doc */
+		AAA//
+,
+		/** doc */
+		BBB,
+		/** doc */
+		CCC//
+, DDD,//
+ EEE, FFF
+	}
+
+	public int[] array = { 11111//
+, 22222, //
+33333, //
+44444//
+, 55555//
+ };
+	public String[] array2 = //
+			new String[] {//
+			"aaaaa", "bbbbb"
+	};
+	public Object[] array3 =//
+	{ null,//
+			null//
+	};
+
+	public void function1(Object //
+param1//
+, Object param2, //
+Object param3, Object param4//
+) throws Exc1, Ex2, Ex3 {
+		List<String> strings = Arrays.asList("aaa", //
+"bbb", "ccc"//
+, "ddd"//
+);
+
+		int aa = 11111, //
+bb = 22222, cc = 33333//
+, dd = 44444//
+;
+
+		param1//
+.field1.field2.//
+field3.function(//
+);
+
+		param2.function1()//
+.function2(//
+).function3().//
+function4();
+
+		String sss1 = this.array.length > 3 //
+? "yes" //
+: "no";
+		String sss2 = this.array.length > 3 ? //
+"yes" : //
+"no";
+
+		try (InputStream in = new IStream();//
+ OutputStream out = new OStream()//
+; Object o = null) {
+			System.out.println(//
+aa * //
+(aa + bb) //
+* cc * (cc //
++ aa//
+)//
+);
+		} catch (Exception1 //
+| Exception2 |//
+ Exception3 e) {
+			System.out.println(//
+param3.function1(//
+aa, //
+bb//
+)//
+);
+		}
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_out.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_out.java
new file mode 100644
index 0000000..04cdb3c
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_out.java
@@ -0,0 +1,97 @@
+package org.example;
+
+import java.util.Arrays;
+
+public class Example //
+        extends //
+        Object //
+        implements //
+        Runnable//
+        , //
+        Serializable //
+{
+	public enum ExampleEnum //
+	        implements //
+	        Runnable//
+	        , //
+	        Serializable {
+	    /** doc */
+		AAA//
+		,
+		/** doc */
+		BBB,
+		/** doc */
+		CCC//
+		, DDD, //
+		EEE, FFF
+	}
+
+	public int[] array = { 11111//
+	        , 22222, //
+	        33333, //
+	        44444//
+	        , 55555//
+	};
+	public String[] array2 = //
+	        new String[] { //
+	                "aaaaa", "bbbbb" };
+	public Object[] array3 = //
+	        { null, //
+	                null//
+			};
+
+	public void function1(Object //
+	param1//
+	        , Object param2, //
+	        Object param3, Object param4//
+	) throws Exc1, Ex2, Ex3 {
+		List<String> strings = Arrays.asList("aaa", //
+		        "bbb", "ccc"//
+		        , "ddd"//
+		);
+
+		int aa = 11111, //
+		        bb = 22222, cc = 33333//
+		        , dd = 44444//
+		;
+
+		param1//
+		        .field1.field2.//
+		        field3.function(//
+				);
+
+		param2.function1()//
+		        .function2(//
+				).function3().//
+				function4();
+
+		String sss1 = this.array.length > 3 //
+		        ? "yes" //
+		        : "no";
+		String sss2 = this.array.length > 3 ? //
+		        "yes" : //
+		        "no";
+
+		try (InputStream in = new IStream(); //
+		        OutputStream out = new OStream()//
+		        ;
+		        Object o = null) {
+			System.out.println(//
+			        aa * //
+			                (aa + bb) //
+			                * cc * (cc //
+			                        + aa//
+							)//
+			);
+		} catch (Exception1 //
+		        | Exception2 | //
+		        Exception3 e) {
+			System.out.println(//
+			        param3.function1(//
+			                aa, //
+			                bb//
+					)//
+			);
+		}
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_in.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_in.java
new file mode 100644
index 0000000..3899aff
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_in.java
@@ -0,0 +1,97 @@
+package org.example;
+
+import java.util.Arrays;
+
+public class Example
+[#extends#] 
+[#Object #]
+[#implements #]
+[#Runnable#]
+[#, #]
+[#Serializable #]
+[#{#]
+	public enum ExampleEnum 
+[#implements #]
+[#Runnable#]
+[#, #]
+[#Serializable {#]
+		/** doc */
+		AAA
+[#,#]
+		/** doc */
+		BBB,
+		/** doc */
+		CCC
+[#, DDD,#]
+[# EEE, FFF#]
+	}
+
+	public int[] array = { 11111
+[#, 22222, #]
+			[#33333, #]
+[#44444#]
+[#					, 55555#]
+	[# };#]
+	public String[] array2 = 
+[#		new String[] {#]
+[#		"aaaaa", "bbbbb"#]
+[#};#]
+	public Object[] array3 =
+[#{ null,#]
+[#		null#]
+[#};#]
+
+	public void function1(Object 
+[#param1#]
+[#, Object param2, #]
+[#Object param3, Object param4#]
+[#) throws Exc1, Ex2, Ex3 {#]
+		List<String> strings = Arrays.asList("aaa", 
+[#"bbb", "ccc"#]
+[#, "ddd"#]
+[#);#]
+
+		int aa = 11111, 
+[#bb = 22222, cc = 33333#]
+[#, dd = 44444#]
+[#;#]
+
+		param1
+[#.field1.field2.#]
+[#field3.function(#]
+[#);#]
+
+		param2.function1()
+[#.function2(#]
+[#).function3().#]
+[#function4();#]
+
+		String sss1 = this.array.length > 3 
+		[#? "yes" #]
+		[#: "no";#]
+		String sss2 = this.array.length > 3 ? 
+[#"yes" : #]
+[#"no";#]
+
+		try (InputStream in = new IStream();
+[# OutputStream out = new OStream()#]
+[#; Object o = null) {#]
+			System.out.println(
+[#aa * #]
+[#(aa + bb) #]
+[#* cc * (cc #]
+[#+ aa#]
+[#)#]
+[#);#]
+		} catch (Exception1 
+[#| Exception2 |#]
+[# Exception3 e) {#]
+			System.out.println(
+[#param3.function1(#]
+[#aa, #]
+[#bb#]
+[#)#]
+[#);#]
+		}
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_out.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_out.java
new file mode 100644
index 0000000..a946229
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_out.java
@@ -0,0 +1,98 @@
+package org.example;
+
+import java.util.Arrays;
+
+public class Example
+		extends 
+		Object
+		implements
+		Runnable
+		,
+		Serializable
+{
+	public enum ExampleEnum 
+			implements
+			Runnable
+			,
+			Serializable {
+		/** doc */
+		AAA
+		,
+		/** doc */
+		BBB,
+		/** doc */
+		CCC
+		, DDD,
+		EEE, FFF
+	}
+
+	public int[] array = { 11111
+			, 22222,
+			33333,
+			44444
+			, 55555
+	};
+	public String[] array2 = 
+			new String[] {
+					"aaaaa", "bbbbb"
+			};
+	public Object[] array3 =
+			{ null,
+					null
+			};
+
+	public void function1(Object 
+	param1
+			, Object param2,
+			Object param3, Object param4
+	) throws Exc1, Ex2, Ex3 {
+		List<String> strings = Arrays.asList("aaa", 
+				"bbb", "ccc"
+				, "ddd"
+		);
+
+		int aa = 11111, 
+				bb = 22222, cc = 33333
+				, dd = 44444
+		;
+
+		param1
+				.field1.field2.
+				field3.function(
+				);
+
+		param2.function1()
+				.function2(
+				).function3().
+				function4();
+
+		String sss1 = this.array.length > 3 
+				? "yes"
+				: "no";
+		String sss2 = this.array.length > 3 ? 
+				"yes" :
+				"no";
+
+		try (InputStream in = new IStream();
+				OutputStream out = new OStream()
+				;
+				Object o = null) {
+			System.out.println(
+					aa *
+							(aa + bb)
+							* cc * (cc
+									+ aa
+							)
+			);
+		} catch (Exception1 
+				| Exception2 |
+				Exception3 e) {
+			System.out.println(
+					param3.function1(
+							aa,
+							bb
+					)
+			);
+		}
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java
index 7233476..83f81fc 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java
@@ -17,10 +17,7 @@ package org.eclipse.jdt.internal.formatter;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMENT_BLOCK;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMENT_JAVADOC;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMENT_LINE;
-import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameLBRACE;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameNotAToken;
-import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameRBRACE;
-import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameRPAREN;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameStringLiteral;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameWHITESPACE;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamepackage;
@@ -46,6 +43,7 @@ import org.eclipse.jdt.core.formatter.CodeFormatter;
 import org.eclipse.jdt.core.formatter.DefaultCodeFormatterConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.parser.ScannerHelper;
+import org.eclipse.jdt.internal.formatter.Token.WrapMode;
 import org.eclipse.jdt.internal.formatter.Token.WrapPolicy;
 
 public class CommentsPreparator extends ASTVisitor {
@@ -88,11 +86,6 @@ public class CommentsPreparator extends ASTVisitor {
 
 	private final static List<String> IMMUTABLE_TAGS = Arrays.asList("@code", "@literal"); //$NON-NLS-1$ //$NON-NLS-2$
 
-	private final static int[] NO_INDENT_AFTER_COMMENT = { TokenNameRPAREN, TokenNameLBRACE, TokenNameRBRACE };
-	static {
-		Arrays.sort(NO_INDENT_AFTER_COMMENT);
-	}
-
 	private final TokenManager tm;
 	private final DefaultCodeFormatterOptions options;
 	private final String sourceLevel;
@@ -176,7 +169,7 @@ public class CommentsPreparator extends ASTVisitor {
 				if (policy == null) {
 					int lineStart = this.tm.getPositionInLine(this.tm.findFirstTokenInLine(commentIndex - 1));
 					int commentStart = this.tm.getPositionInLine(commentIndex - 1);
-					policy = new WrapPolicy(commentStart - lineStart, commentIndex - 1, true);
+					policy = new WrapPolicy(WrapMode.WHERE_NECESSARY, commentIndex - 1, commentStart - lineStart);
 				}
 				commentToken.setWrapPolicy(policy);
 				this.lastLineComment = commentToken;
@@ -191,7 +184,8 @@ public class CommentsPreparator extends ASTVisitor {
 		if (isContinuation) {
 			Token first = structure.get(0);
 			first.breakBefore();
-			first.setWrapPolicy(new WrapPolicy(this.lastLineCommentPosition, commentIndex - 1, false));
+			first.setWrapPolicy(
+					new WrapPolicy(WrapMode.WHERE_NECESSARY, commentIndex - 1, this.lastLineCommentPosition));
 
 			// merge previous and current line comment
 			Token previous = this.lastLineComment;
@@ -424,17 +418,6 @@ public class CommentsPreparator extends ASTVisitor {
 				next = next2;
 			}
 
-			if (previous != null && previous.getLineBreaksAfter() == 0
-					&& next != null && next.getLineBreaksBefore() == 0
-					&& Arrays.binarySearch(NO_INDENT_AFTER_COMMENT, next.tokenType) < 0) {
-				int policyIndent = (commentToken.getIndent() - previous.getIndent());
-				WrapPolicy wrapPolicy = new WrapPolicy(policyIndent, commentIndex - 1, true);
-				if (this.tm.countLineBreaksBetween(previous, commentToken) == 1)
-					commentToken.setWrapPolicy(wrapPolicy);
-				if (this.tm.countLineBreaksBetween(commentToken, next) == 1)
-					next.setWrapPolicy(wrapPolicy);
-			}
-
 			if (existingBreaksBefore < existingBreaksAfter && previous != null) {
 				commentToken.putLineBreaksAfter(previous.getLineBreaksAfter());
 				previous.clearLineBreaksAfter();
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
index 68e9194..f267831 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
@@ -76,6 +76,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 
 	private String sourceString;
 	private char[] sourceArray;
+	private IRegion[] formatRegions;
 
 	private ASTNode astRoot;
 	private List<Token> tokens = new ArrayList<>();
@@ -148,11 +149,12 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		if (!regionsSatisfiesPreconditions(regions, source.length())) {
 			throw new IllegalArgumentException();
 		}
+		this.formatRegions = regions;
 
 		updateWorkingOptions(indentationLevel, lineSeparator, kind);
 
 		if ((kind & K_COMMENTS_MASK) != 0)
-			return formatComments(source, kind & K_COMMENTS_MASK, regions);
+			return formatComments(source, kind & K_COMMENTS_MASK);
 
 		if (prepareFormattedCode(source, kind) == null)
 			return this.tokens.isEmpty() ? new MultiTextEdit() : null;
@@ -214,7 +216,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		}
 	}
 
-	private TextEdit formatComments(String source, int kind, IRegion[] regions) {
+	private TextEdit formatComments(String source, int kind) {
 		MultiTextEdit result = new MultiTextEdit();
 		if (!init(source))
 			return result;
@@ -268,7 +270,8 @@ public class DefaultCodeFormatter extends CodeFormatter {
 
 		this.tokenManager.applyFormatOff();
 
-		TextEditsBuilder resultBuilder = new TextEditsBuilder(source, regions, this.tokenManager, this.workingOptions);
+		TextEditsBuilder resultBuilder = new TextEditsBuilder(source, this.formatRegions, this.tokenManager,
+				this.workingOptions);
 		resultBuilder.setAlignChar(DefaultCodeFormatterOptions.SPACE);
 		for (Token token : this.tokens) {
 			List<Token> structure = token.getInternalStructure();
@@ -374,7 +377,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 	private void prepareWraps(int kind) {
 		WrapPreparator wrapPreparator = new WrapPreparator(this.tokenManager, this.workingOptions, kind);
 		this.astRoot.accept(wrapPreparator);
-		wrapPreparator.finishUp(this.astRoot);
+		wrapPreparator.finishUp(this.astRoot, this.formatRegions);
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/TextEditsBuilder.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/TextEditsBuilder.java
index 8e725a9..40ef3dc 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/TextEditsBuilder.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/TextEditsBuilder.java
@@ -22,6 +22,7 @@ import java.util.Arrays;
 import java.util.List;
 
 import org.eclipse.jdt.internal.compiler.parser.ScannerHelper;
+import org.eclipse.jdt.internal.formatter.Token.WrapMode;
 import org.eclipse.jdt.internal.formatter.Token.WrapPolicy;
 import org.eclipse.jface.text.IRegion;
 import org.eclipse.jface.text.Region;
@@ -229,8 +230,17 @@ public class TextEditsBuilder extends TokenTraverser {
 			additionalSpaces = indent - wrapRootIndent;
 			indent = wrapRootIndent;
 
-			if (wrapPolicy != null && wrapPolicy.isForced) {
-				int extraIndent = wrapPolicy.extraIndent;
+			if (wrapPolicy != null && wrapPolicy.wrapMode == WrapMode.FORCED) {
+				int parentIndex = wrapPolicy.wrapParentIndex;
+				int parentAlign = 0;
+				int lineStart = this.tm.findFirstTokenInLine(parentIndex);
+				for (int i = parentIndex; i >= lineStart; i--) {
+					parentAlign = this.tm.get(i).getAlign();
+					if (parentAlign > 0)
+						break;
+				}
+
+				int extraIndent = parentAlign == 0 ? wrapPolicy.extraIndent : (token.getIndent() - parentAlign);
 				additionalSpaces -= extraIndent;
 				indent += extraIndent;
 			}
@@ -316,29 +326,43 @@ public class TextEditsBuilder extends TokenTraverser {
 		String buffered = this.buffer.toString();
 		boolean sourceMatch = this.source.startsWith(buffered, this.counter)
 				&& this.counter + buffered.length() == currentPosition;
-		if (!sourceMatch && checkRegions(this.counter, currentPosition)) {
-			TextEdit edit = getReplaceEdit(this.counter, currentPosition, buffered);
-			this.edits.add(edit);
+		while (!sourceMatch && this.currentRegion < this.regions.size()) {
+			IRegion region = this.regions.get(this.currentRegion);
+			if (currentPosition < region.getOffset())
+				break;
+			int regionEnd = region.getOffset() + region.getLength();
+			if (this.counter >= regionEnd) {
+				this.currentRegion++;
+				continue;
+			}
+			if (this.currentRegion == this.regions.size() - 1
+					|| this.regions.get(this.currentRegion + 1).getOffset() > currentPosition) {
+				this.edits.add(getReplaceEdit(this.counter, currentPosition, buffered, region));
+				break;
+			}
+
+			// this edit will span more than one region, split it
+			IRegion nextRegion = this.regions.get(this.currentRegion + 1);
+			int bestSplit = 0;
+			int bestSplitScore = Integer.MAX_VALUE;
+			for (int i = 0; i < buffered.length(); i++) {
+				ReplaceEdit edit1 = getReplaceEdit(this.counter, regionEnd, buffered.substring(0, i), region);
+				ReplaceEdit edit2 = getReplaceEdit(regionEnd, currentPosition, buffered.substring(i), nextRegion);
+				int score = edit1.getLength() + edit1.getText().length() + edit2.getLength() + edit2.getText().length();
+				if (score < bestSplitScore) {
+					bestSplit = i;
+					bestSplitScore = score;
+				}
+			}
+			this.edits.add(getReplaceEdit(this.counter, regionEnd, buffered.substring(0, bestSplit), region));
+			buffered = buffered.substring(bestSplit);
+			this.counter = regionEnd;
 		}
 		this.buffer.setLength(0);
 		this.counter = currentPosition;
 	}
 
-	private boolean checkRegions(int editStart, int editEnd) {
-		while (true) {
-			if (this.currentRegion >= this.regions.size())
-				return false;
-			IRegion region = this.regions.get(this.currentRegion);
-			if (editEnd < region.getOffset())
-				return false;
-			if (editStart < region.getOffset() + region.getLength())
-				return true;
-			this.currentRegion++;
-		}
-	}
-
-	private TextEdit getReplaceEdit(int editStart, int editEnd, String text) {
-		IRegion region = this.regions.get(this.currentRegion);
+	private ReplaceEdit getReplaceEdit(int editStart, int editEnd, String text, IRegion region) {
 		int regionEnd = region.getOffset() + region.getLength();
 		if (editStart < region.getOffset() && regionEnd < editEnd) {
 			int breaksInReplacement = this.tm.countLineBreaksBetween(text, 0, text.length());
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Token.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Token.java
index 762edd0..49057a2 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Token.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Token.java
@@ -25,48 +25,59 @@ import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
  */
 public class Token {
 
+	public static enum WrapMode {
+		/**
+		 * Wrap mode for the "Do not wrap" policy. Tokens still should be indented as if wrapped when a preceding line
+		 * break cannot be removed due to a line comment or formatting region restriction.
+		 */
+		DISABLED,
+		/** Wrap mode for the "Wrap where necessary" policies. */
+		WHERE_NECESSARY,
+		/** Wrap mode for the "Wrap all elements" policies. */
+		TOP_PRIORITY,
+		/**
+		 * Wrap mode for tokens that are already in new line before wrapping, but their indentation should be adjusted
+		 * in similar way to wrapping. Used for anonymous class body, lambda body and comments inside code.
+		 */
+		FORCED
+	}
+
 	public static class WrapPolicy {
 
 		/** Policy used for internal structure of multiline comments to mark tokens that should never be wrapped */
-		public final static WrapPolicy DISABLE_WRAP = new WrapPolicy(0, 0, false);
+		public final static WrapPolicy DISABLE_WRAP = new WrapPolicy(WrapMode.DISABLED, 0, 0);
 
 		/**
 		 * Policy used for internal structure of multiline comments to mark tokens that can be wrapped only in lines
 		 * that have no other tokens to wrap.
 		 */
-		public final static WrapPolicy SUBSTITUTE_ONLY = new WrapPolicy(0, 0, false);
+		public final static WrapPolicy SUBSTITUTE_ONLY = new WrapPolicy(WrapMode.DISABLED, 0, 0);
 
-		public final int extraIndent;
+		public final WrapMode wrapMode;
 		public final int wrapParentIndex;
+		public final int groupEndIndex;
+		public final int extraIndent;
 		public final int structureDepth;
 		public final float penaltyMultiplier;
 		public final boolean isFirstInGroup;
 		public final boolean indentOnColumn;
-		public final int topPriorityGroupEnd;
-		/**
-		 * If true, it means the token was in new line even before wrapping, but should be treaded as wrapped token for
-		 * indentation purposes. Used for anonymous class body, lambda body and comments inside code.
-		 */
-		public final boolean isForced;
 
-		public WrapPolicy(int extraIndent, int wrapParentIndex, int structureDepth, float penaltyMultiplier,
-				boolean isFirstInGroup, boolean indentOnColumn, int topPriorityGroupEnd, boolean isForced) {
-			this.extraIndent = extraIndent;
+		public WrapPolicy(WrapMode wrapMode, int wrapParentIndex, int groupEndIndex, int extraIndent,
+				int structureDepth, float penaltyMultiplier, boolean isFirstInGroup, boolean indentOnColumn) {
+			assert wrapMode != null && (wrapParentIndex < groupEndIndex || groupEndIndex == -1);
+
+			this.wrapMode = wrapMode;
 			this.wrapParentIndex = wrapParentIndex;
+			this.groupEndIndex = groupEndIndex;
+			this.extraIndent = extraIndent;
 			this.structureDepth = structureDepth;
 			this.penaltyMultiplier = penaltyMultiplier;
 			this.isFirstInGroup = isFirstInGroup;
 			this.indentOnColumn = indentOnColumn;
-			this.topPriorityGroupEnd = topPriorityGroupEnd;
-			this.isForced = isForced;
-		}
-
-		public WrapPolicy(int extraIndent, int wrapParentIndex, boolean isForced) {
-			this(extraIndent, wrapParentIndex, 0, 1, false, false, -1, isForced);
 		}
 
-		public boolean isTopPriority() {
-			return this.topPriorityGroupEnd >= 0;
+		public WrapPolicy(WrapMode wrapMode, int wrapParentIndex, int extraIndent) {
+			this(wrapMode, wrapParentIndex, -1, extraIndent, 0, 1, false, false);
 		}
 	}
 
@@ -245,7 +256,8 @@ public class Token {
 	}
 
 	public boolean isWrappable() {
-		return this.wrapPolicy != null && !this.wrapPolicy.isForced;
+		WrapPolicy wp = this.wrapPolicy;
+		return wp != null && wp.wrapMode != WrapMode.DISABLED && wp.wrapMode != WrapMode.FORCED;
 	}
 
 	public void setNLSTag(Token nlsTagToken) {
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/CommentWrapExecutor.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/CommentWrapExecutor.java
index b24658a..3a1e5c3 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/CommentWrapExecutor.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/CommentWrapExecutor.java
@@ -25,6 +25,7 @@ import org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions;
 import org.eclipse.jdt.internal.formatter.Token;
 import org.eclipse.jdt.internal.formatter.TokenManager;
 import org.eclipse.jdt.internal.formatter.TokenTraverser;
+import org.eclipse.jdt.internal.formatter.Token.WrapMode;
 import org.eclipse.jdt.internal.formatter.Token.WrapPolicy;
 
 public class CommentWrapExecutor extends TokenTraverser {
@@ -228,7 +229,7 @@ public class CommentWrapExecutor extends TokenTraverser {
 			whitespace = new Token(prefix);
 			whitespace.breakBefore();
 			whitespace.setIndent(indent);
-			whitespace.setWrapPolicy(new WrapPolicy(0, commentIndex, false));
+			whitespace.setWrapPolicy(new WrapPolicy(WrapMode.WHERE_NECESSARY, commentIndex, 0));
 			prefix = structure.get(1);
 			assert prefix.tokenType == TokenNameCOMMENT_LINE;
 		}
@@ -238,7 +239,7 @@ public class CommentWrapExecutor extends TokenTraverser {
 		prefix = new Token(commentToken.originalStart, prefixEnd, TokenNameCOMMENT_LINE);
 		if (whitespace == null) {
 			prefix.breakBefore();
-			prefix.setWrapPolicy(new WrapPolicy(0, commentIndex, false));
+			prefix.setWrapPolicy(new WrapPolicy(WrapMode.WHERE_NECESSARY, commentIndex, 0));
 		}
 
 		int lineStartIndex = whitespace == null ? 0 : 1;
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/FieldAligner.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/FieldAligner.java
index 9c15869..a4a495e 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/FieldAligner.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/FieldAligner.java
@@ -122,13 +122,6 @@ public class FieldAligner {
 				int assingIndex = this.tm.firstIndexAfter(fragment.getName(), TokenNameEQUAL);
 				Token assignToken = this.tm.get(assingIndex);
 				assignToken.setAlign(maxAssignAlign);
-
-				int baseIndent = this.tm.getPositionInLine(assingIndex + 1) - assignToken.getIndent();
-				int lastIndex = this.tm.lastIndexIn(declaration, -1);
-				for (int i = assingIndex + 1; i <= lastIndex; i++) {
-					Token token = this.tm.get(i);
-					token.setIndent(baseIndent + token.getIndent());
-				}
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
index a25a29b..49272996 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
@@ -26,6 +26,7 @@ import org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions;
 import org.eclipse.jdt.internal.formatter.Token;
 import org.eclipse.jdt.internal.formatter.TokenManager;
 import org.eclipse.jdt.internal.formatter.TokenTraverser;
+import org.eclipse.jdt.internal.formatter.Token.WrapMode;
 import org.eclipse.jdt.internal.formatter.Token.WrapPolicy;
 
 public class WrapExecutor {
@@ -74,8 +75,6 @@ public class WrapExecutor {
 
 		public static final WrapResult NO_WRAP_NEEDED = new WrapResult(0, 0, null);
 
-		public static final WrapResult TOP_PRIORITY_WRAP_MET = new WrapResult(0, 0, null);
-
 		public final double penalty;
 		public final int totalExtraLines;
 		/**
@@ -91,6 +90,16 @@ public class WrapExecutor {
 		}
 	}
 
+	private static class WrapRestartException extends Exception {
+		private static final long serialVersionUID = -2980600077230803443L; // backward compatible
+
+		public final int topPriorityWrap;
+
+		public WrapRestartException(int topPriorityWrap) {
+			this.topPriorityWrap = topPriorityWrap;
+		}
+	}
+
 	private class LineAnalyzer extends TokenTraverser {
 
 		final private CommentWrapExecutor commentWrapper;
@@ -133,10 +142,10 @@ public class WrapExecutor {
 
 			if (token.isWrappable()) {
 				WrapPolicy wrapPolicy = token.getWrapPolicy();
-				if (wrapPolicy.isTopPriority() && getLineBreaksBefore() == 0
+				if (wrapPolicy.wrapMode == WrapMode.TOP_PRIORITY && getLineBreaksBefore() == 0
 						&& index > this.currentTopPriorityGroupEnd) {
 					this.topPriorityGroupStarts.add(index);
-					this.currentTopPriorityGroupEnd = wrapPolicy.topPriorityGroupEnd;
+					this.currentTopPriorityGroupEnd = wrapPolicy.groupEndIndex;
 				}
 				if (this.firstPotentialWrap < 0 && getWrapIndent(token) < this.counter)
 					this.firstPotentialWrap = index;
@@ -274,8 +283,6 @@ public class WrapExecutor {
 	final TokenManager tm;
 	final DefaultCodeFormatterOptions options;
 
-	private int topPriorityWrapIndex;
-
 	private final WrapInfo wrapInfoTemp = new WrapInfo();
 
 	public WrapExecutor(TokenManager tokenManager, DefaultCodeFormatterOptions options) {
@@ -286,88 +293,102 @@ public class WrapExecutor {
 
 	public void executeWraps() {
 		int index = 0;
-		mainLoop: while (index < this.tm.size()) {
+		while (index < this.tm.size()) {
 			Token token = this.tm.get(index);
-			handleOnColumnIndent(index, token.getWrapPolicy());
-			// this might be a pre-existing wrap that should trigger other top priority wraps
-			int jumpToIndex = handleTopPriorityWraps(index);
-			if (jumpToIndex >= 0) {
-				index = jumpToIndex;
-				continue mainLoop;
+			while (true) {
+				try {
+					int currentIndent = getWrapIndent(token);
+					this.wrapSearchResults.clear();
+					index = applyWraps(index, currentIndent);
+					break;
+				} catch (WrapRestartException e) {
+					handleTopPriorityWraps(e);
+				}
 			}
-
-			// determine wraps for incoming line
-			int currentIndent = getWrapIndent(token);
-			boolean isLineWrapped = token.isWrappable();
 			this.wrapSearchResults.clear();
-			WrapResult wrapResult = findWraps(index, currentIndent);
-			if (wrapResult == WrapResult.TOP_PRIORITY_WRAP_MET) {
-				jumpToIndex = handleTopPriorityWraps(this.topPriorityWrapIndex);
-				assert jumpToIndex >= 0;
-				index = Math.min(index, jumpToIndex);
-				continue mainLoop;
-			}
+			this.usedTopPriorityWraps.clear();
+		}
 
-			// apply wraps and indents
-			WrapInfo wrapInfo = wrapResult.nextWrap;
-			while (wrapInfo != null) {
-				isLineWrapped = true;
-				for (; index < wrapInfo.wrapTokenIndex; index++) {
-					token = this.tm.get(index);
-					if (shouldForceWrap(token, currentIndent)) {
-						currentIndent = token.getIndent();
-						wrapInfo = new WrapInfo(index, currentIndent);
-						findWrapsCached(index, currentIndent);
-						break;
-					}
-					currentIndent = Math.max(currentIndent, token.getAlign());
-					token.setIndent(currentIndent);
-				}
-				token = this.tm.get(index);
+		this.tm.traverse(0, new NLSTagHandler());
+	}
+
+	private int applyWraps(int index, int indent) throws WrapRestartException {
+		WrapInfo wrapInfo = findWrapsCached(index, indent).nextWrap;
+		Token token = this.tm.get(index);
+		index++;
+		token.setIndent(indent);
+		int groupEnd = token.getWrapPolicy() != null ? token.getWrapPolicy().groupEndIndex : -1;
+		while (index < this.tm.size()) {
+			token = this.tm.get(index);
+			if (token.isNextLineOnWrap() && this.tm.get(this.tm.findFirstTokenInLine(index)).isWrappable()) {
 				token.breakBefore();
-				token.setIndent(currentIndent = wrapInfo.indent);
-				handleOnColumnIndent(index, token.getWrapPolicy());
-				jumpToIndex = handleTopPriorityWraps(index);
-				if (jumpToIndex >= 0) {
-					index = jumpToIndex;
-					continue mainLoop;
-				}
+				return index;
+			}
+			while (wrapInfo != null && wrapInfo.wrapTokenIndex < index)
 				wrapInfo = this.wrapSearchResults.get(wrapInfo).nextWrap;
+			if (wrapInfo != null && wrapInfo.wrapTokenIndex == index) {
+				token.breakBefore();
+				handleOnColumnIndent(index, token.getWrapPolicy());
+				checkTopPriorityWraps(index);
+				index = applyWraps(index, wrapInfo.indent);
+				continue;
 			}
 
-			// apply indent until the beginning of the next line
-			token.setIndent(currentIndent);
-			for (index++; index < this.tm.size(); index++) {
-				if (token.getLineBreaksAfter() > 0)
-					break;
-				token = this.tm.get(index);
-				if (token.isNextLineOnWrap() && isLineWrapped)
-					token.breakBefore();
-				if (token.getLineBreaksBefore() > 0)
-					break;
-				if (shouldForceWrap(token, currentIndent))
-					currentIndent = token.getIndent();
-				currentIndent = Math.max(currentIndent, token.getAlign());
-				token.setIndent(currentIndent);
+			boolean isNewLine = this.tm.get(index - 1).getLineBreaksAfter() > 0 || token.getLineBreaksBefore() > 0;
+			if (isNewLine) {
+				if (token.getWrapPolicy() != null) {
+					handleOnColumnIndent(index, token.getWrapPolicy());
+					checkTopPriorityWraps(index);
+					int newIndent = getWrapIndent(token);
+					if (newIndent < indent)
+						return index;
+					wrapInfo = findWrapsCached(index, newIndent).nextWrap;
+					if (newIndent > indent) {
+						index = applyWraps(index, newIndent);
+						continue;
+					}
+				} else if (index > groupEnd) {
+					return index;
+				}
+			} else {
+				checkForceWrap(token, indent);
 			}
-		}
-		this.wrapSearchResults.clear();
-		this.usedTopPriorityWraps.clear();
 
-		this.tm.traverse(0, new NLSTagHandler());
+			token.setIndent(indent);
+			index++;
+		}
+		return index;
 	}
 
-	private WrapResult findWrapsCached(int startTokenIndex, int indent) {
+	private WrapResult findWrapsCached(int startTokenIndex, int indent) throws WrapRestartException {
 		this.wrapInfoTemp.wrapTokenIndex = startTokenIndex;
 		this.wrapInfoTemp.indent = indent;
 		WrapResult wrapResult = this.wrapSearchResults.get(this.wrapInfoTemp);
+		if (wrapResult == null && this.wrapSearchResults.containsKey(this.wrapInfoTemp))
+			return null; // no wrap needed
+
+		// pre-existing result may be based on different wrapping of earlier tokens and therefore be wrong
+		WrapResult wr = wrapResult;
+		while (wr != null && wr.nextWrap != null) {
+			WrapInfo wi = wr.nextWrap;
+			Token token = this.tm.get(wi.wrapTokenIndex);
+			if (token.getWrapPolicy().wrapParentIndex < startTokenIndex && getWrapIndent(token) != wi.indent) {
+				wrapResult = null;
+				break;
+			}
+			wr = this.wrapSearchResults.get(wi);
+		}
+
 		if (wrapResult == null) {
 			Token token = this.tm.get(startTokenIndex);
 			boolean wasLineBreak = token.getLineBreaksBefore() > 0;
 			token.breakBefore();
-			wrapResult = findWraps(startTokenIndex, indent);
-			if (!wasLineBreak)
-				token.clearLineBreaksBefore();
+			try {
+				wrapResult = findWraps(startTokenIndex, indent);
+			} finally {
+				if (!wasLineBreak)
+					token.clearLineBreaksBefore();
+			}
 
 			WrapInfo wrapInfo = new WrapInfo(startTokenIndex, indent);
 			this.wrapSearchResults.put(wrapInfo, wrapResult);
@@ -379,7 +400,7 @@ public class WrapExecutor {
 	 * The main algorithm that looks for optimal places to wrap.
 	 * Calls itself recursively to get results for wrapped sub-lines.  
 	 */
-	private WrapResult findWraps(int wrapTokenIndex, int indent) {
+	private WrapResult findWraps(int wrapTokenIndex, int indent) throws WrapRestartException {
 		final int lastIndex = this.lineAnalyzer.analyzeLine(wrapTokenIndex, indent);
 		final boolean lineExceeded = this.lineAnalyzer.lineExceeded;
 		final int lastPosition = this.lineAnalyzer.getLastPosition();
@@ -392,7 +413,7 @@ public class WrapExecutor {
 		final int[] topPriorityGroupStarts = toArray(this.lineAnalyzer.topPriorityGroupStarts);
 		int topPriorityIndex = topPriorityGroupStarts.length - 1;
 		int nearestGroupEnd = topPriorityIndex == -1 ? 0
-				: this.tm.get(topPriorityGroupStarts[topPriorityIndex]).getWrapPolicy().topPriorityGroupEnd;
+				: this.tm.get(topPriorityGroupStarts[topPriorityIndex]).getWrapPolicy().groupEndIndex;
 
 		double bestTotalPenalty = getWrapPenalty(wrapTokenIndex, indent, lastIndex + 1, -1, WrapResult.NO_WRAP_NEEDED);
 		int bestExtraLines = lineExceeded ? Integer.MAX_VALUE : extraLines; // if line is exceeded, accept every wrap
@@ -416,8 +437,7 @@ public class WrapExecutor {
 
 		if (firstPotentialWrap < 0 && lineExceeded) {
 			if (topPriorityGroupStarts.length > 0) {
-				this.topPriorityWrapIndex = topPriorityGroupStarts[0];
-				return WrapResult.TOP_PRIORITY_WRAP_MET;
+				checkTopPriorityWraps(topPriorityGroupStarts[0]);
 			}
 
 			// Report high number of extra lines to encourage the algorithm to look
@@ -441,7 +461,7 @@ public class WrapExecutor {
 				assert i == topPriorityGroupStarts[topPriorityIndex];
 				topPriorityIndex--;
 				nearestGroupEnd = topPriorityIndex == -1 ? 0
-						: this.tm.get(topPriorityGroupStarts[topPriorityIndex]).getWrapPolicy().topPriorityGroupEnd;
+						: this.tm.get(topPriorityGroupStarts[topPriorityIndex]).getWrapPolicy().groupEndIndex;
 			}
 
 			if (!token.isWrappable())
@@ -450,9 +470,6 @@ public class WrapExecutor {
 			int nextWrapIndent = getWrapIndent(token);
 			WrapResult nextWrapResult = findWrapsCached(i, nextWrapIndent);
 
-			if (nextWrapResult == WrapResult.TOP_PRIORITY_WRAP_MET)
-				continue;
-
 			double totalPenalty = getWrapPenalty(wrapTokenIndex, indent, i, nextWrapIndent, nextWrapResult);
 			int totalExtraLines = extraLines + nextWrapResult.totalExtraLines;
 			boolean isBetter = totalExtraLines < bestExtraLines || bestExtraLines == Integer.MAX_VALUE;
@@ -470,8 +487,7 @@ public class WrapExecutor {
 		}
 
 		if (bestNextWrap == -1 && lineExceeded && topPriorityGroupStarts.length > 0) {
-			this.topPriorityWrapIndex = topPriorityGroupStarts[0];
-			return WrapResult.TOP_PRIORITY_WRAP_MET;
+			checkTopPriorityWraps(topPriorityGroupStarts[0]);
 		}
 
 		return new WrapResult(bestTotalPenalty, bestExtraLines,
@@ -479,7 +495,7 @@ public class WrapExecutor {
 	}
 
 	private double getWrapPenalty(int lineStartIndex, int lineIndent, int wrapIndex, int wrapIndent,
-			WrapResult wrapResult) {
+			WrapResult wrapResult) throws WrapRestartException {
 		WrapPolicy wrapPolicy = null;
 		Token wrapToken = null;
 		if (wrapIndex < this.tm.size()) {
@@ -523,12 +539,12 @@ public class WrapExecutor {
 		// a wrap of the same parent (bar2). If so, then bar1 must be wrapped (so give it negative penalty).
 		// Update: Actually, every token that is followed by a higher level depth wrap should be also wrapped,
 		// as long as this next wrap is not the last in line and the token is not the first in its wrap group.
-		WrapResult nextWrapResult = wrapResult;
+		WrapInfo nextWrap = wrapResult.nextWrap;
 		boolean checkDepth = wrapToken != null && wrapToken.isWrappable()
 				&& (lineStartWrapPolicy == null || wrapPolicy.structureDepth >= lineStartWrapPolicy.structureDepth);
 		double penaltyDiff = 0;
-		while (checkDepth && nextWrapResult.nextWrap != null) {
-			WrapPolicy nextPolicy = this.tm.get(nextWrapResult.nextWrap.wrapTokenIndex).getWrapPolicy();
+		while (checkDepth && nextWrap != null) {
+			WrapPolicy nextPolicy = this.tm.get(nextWrap.wrapTokenIndex).getWrapPolicy();
 			if (nextPolicy.wrapParentIndex == wrapPolicy.wrapParentIndex
 					|| (penaltyDiff != 0 && !wrapPolicy.isFirstInGroup)) {
 				penalty -= penaltyDiff * 1.25;
@@ -537,7 +553,7 @@ public class WrapExecutor {
 			if (nextPolicy.structureDepth <= wrapPolicy.structureDepth)
 				break;
 			penaltyDiff = Math.max(penaltyDiff, getPenalty(nextPolicy));
-			nextWrapResult = this.wrapSearchResults.get(nextWrapResult.nextWrap);
+			nextWrap = findWrapsCached(nextWrap.wrapTokenIndex, nextWrap.indent).nextWrap;
 		}
 
 		return penalty + wrapResult.penalty;
@@ -547,7 +563,7 @@ public class WrapExecutor {
 		return Math.exp(policy.structureDepth) * policy.penaltyMultiplier;
 	}
 
-	private boolean shouldForceWrap(Token token, int currentIndent) {
+	private void checkForceWrap(Token token, int currentIndent) throws WrapRestartException {
 		// A token that will have smaller indent when wrapped than the current line indent,
 		// should be wrapped because it's a low depth token following some complex wraps of higher depth.
 		// This rule could not be implemented in getWrapPenalty() because a token's wrap indent may depend
@@ -556,31 +572,30 @@ public class WrapExecutor {
 			int indent = getWrapIndent(token);
 			if (indent < currentIndent) {
 				token.breakBefore();
-				token.setIndent(indent);
-				return true;
+				throw new WrapRestartException(-1);
 			}
 		}
-		return false;
 	}
 
-	/**
-	 * @return index of the first token in the top priority group that given token belongs to or -1 if it doesn't belong
-	 *         to any top priority.
-	 */
-	private int handleTopPriorityWraps(int wrapIndex) {
-		// wrap all tokens in the same top priority group and jump back to the first one
+	private void checkTopPriorityWraps(int wrapIndex) throws WrapRestartException {
+		WrapPolicy wrapPolicy = this.tm.get(wrapIndex).getWrapPolicy();
+		if (wrapPolicy != null && wrapPolicy.wrapMode == WrapMode.TOP_PRIORITY
+				&& !this.usedTopPriorityWraps.contains(wrapPolicy))
+			throw new WrapRestartException(wrapIndex);
+	}
+
+	private void handleTopPriorityWraps(WrapRestartException restartException) {
+		int wrapIndex = restartException.topPriorityWrap;
+		if (wrapIndex < 0)
+			return;
 		WrapPolicy wrapPolicy = this.tm.get(wrapIndex).getWrapPolicy();
-		if (wrapPolicy == null || !wrapPolicy.isTopPriority() || this.usedTopPriorityWraps.contains(wrapPolicy))
-			return -1;
-		int firstTokenIndex = -1;
 		int parentIndex = wrapPolicy.wrapParentIndex;
 		for (int i = wrapIndex; i > parentIndex; i--) {
 			Token token = this.tm.get(i);
 			wrapPolicy = token.getWrapPolicy();
 			if (wrapPolicy != null && wrapPolicy.wrapParentIndex == parentIndex) {
-				if (wrapPolicy.isTopPriority()) {
+				if (wrapPolicy.wrapMode == WrapMode.TOP_PRIORITY) {
 					token.breakBefore();
-					firstTokenIndex = i;
 					this.usedTopPriorityWraps.add(wrapPolicy);
 				}
 				if (wrapPolicy.isFirstInGroup)
@@ -596,14 +611,13 @@ public class WrapExecutor {
 			} else if (wrapPolicy != null && wrapPolicy.wrapParentIndex == parentIndex) {
 				if (wrapPolicy.isFirstInGroup)
 					break;
-				if (wrapPolicy.isTopPriority()) {
+				if (wrapPolicy.wrapMode == WrapMode.TOP_PRIORITY) {
 					token.breakBefore();
 					this.usedTopPriorityWraps.add(wrapPolicy);
 				}
 			}
 			breakAfterPrevious = token.getLineBreaksAfter() > 0;
 		}
-		return firstTokenIndex;
 	}
 
 	private int[] toArray(List<Integer> list) {
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
index 3ac9ad2..69b90fa 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
@@ -12,6 +12,7 @@
 package org.eclipse.jdt.internal.formatter.linewrap;
 
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOLON;
+import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMA;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMENT_BLOCK;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMENT_JAVADOC;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMENT_LINE;
@@ -23,11 +24,14 @@ import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameO
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameQUESTION;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameRBRACE;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameRPAREN;
+import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameSEMICOLON;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameStringLiteral;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameextends;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameimplements;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameIdentifier;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamenew;
+import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamesuper;
+import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamethis;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamethrows;
 
 import java.util.ArrayList;
@@ -50,6 +54,7 @@ import org.eclipse.jdt.core.dom.ConstructorInvocation;
 import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
 import org.eclipse.jdt.core.dom.EnumDeclaration;
 import org.eclipse.jdt.core.dom.Expression;
+import org.eclipse.jdt.core.dom.FieldAccess;
 import org.eclipse.jdt.core.dom.FieldDeclaration;
 import org.eclipse.jdt.core.dom.IfStatement;
 import org.eclipse.jdt.core.dom.ImportDeclaration;
@@ -59,10 +64,13 @@ import org.eclipse.jdt.core.dom.LambdaExpression;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.NormalAnnotation;
+import org.eclipse.jdt.core.dom.QualifiedName;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.Statement;
 import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
+import org.eclipse.jdt.core.dom.SuperFieldAccess;
 import org.eclipse.jdt.core.dom.SuperMethodInvocation;
+import org.eclipse.jdt.core.dom.ThisExpression;
 import org.eclipse.jdt.core.dom.TryStatement;
 import org.eclipse.jdt.core.dom.Type;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
@@ -75,12 +83,54 @@ import org.eclipse.jdt.core.formatter.CodeFormatter;
 import org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions;
 import org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions.Alignment;
 import org.eclipse.jdt.internal.formatter.Token;
+import org.eclipse.jdt.internal.formatter.Token.WrapMode;
 import org.eclipse.jdt.internal.formatter.Token.WrapPolicy;
 import org.eclipse.jdt.internal.formatter.TokenManager;
 import org.eclipse.jdt.internal.formatter.TokenTraverser;
+import org.eclipse.jface.text.IRegion;
 
 public class WrapPreparator extends ASTVisitor {
 
+	/**
+	 * Helper for common handling of all expressions that should be treated the same as {@link FieldAccess}
+	 */
+	private static class FieldAccessAdapter {
+		final Expression accessExpression;
+
+		public FieldAccessAdapter(Expression expression) {
+			this.accessExpression = expression;
+		}
+
+		public static boolean isFieldAccess(ASTNode expr) {
+			return expr instanceof FieldAccess || expr instanceof QualifiedName || expr instanceof ThisExpression
+					|| expr instanceof SuperFieldAccess;
+		}
+
+		public Expression getExpression() {
+			if (this.accessExpression instanceof FieldAccess)
+				return ((FieldAccess) this.accessExpression).getExpression();
+			if (this.accessExpression instanceof QualifiedName)
+				return ((QualifiedName) this.accessExpression).getQualifier();
+			if (this.accessExpression instanceof ThisExpression)
+				return ((ThisExpression) this.accessExpression).getQualifier();
+			if (this.accessExpression instanceof SuperFieldAccess)
+				return ((SuperFieldAccess) this.accessExpression).getQualifier();
+			throw new AssertionError();
+		}
+
+		public int getIdentifierIndex(TokenManager tm) {
+			if (this.accessExpression instanceof FieldAccess)
+				return tm.firstIndexIn(((FieldAccess) this.accessExpression).getName(), TokenNameIdentifier);
+			if (this.accessExpression instanceof QualifiedName)
+				return tm.firstIndexIn(((QualifiedName) this.accessExpression).getName(), TokenNameIdentifier);
+			if (this.accessExpression instanceof ThisExpression)
+				return tm.lastIndexIn(this.accessExpression, TokenNamethis);
+			if (this.accessExpression instanceof SuperFieldAccess)
+				return tm.lastIndexIn(this.accessExpression, TokenNamesuper);
+			throw new AssertionError();
+		}
+	}
+
 	private final static Map<Operator, Integer> OPERATOR_PRECEDENCE;
 	static {
 		HashMap<Operator, Integer> precedence = new HashMap<Operator, Integer>();
@@ -106,7 +156,7 @@ public class WrapPreparator extends ASTVisitor {
 	final TokenManager tm;
 	final DefaultCodeFormatterOptions options;
 	final int kind;
-	
+
 	final FieldAligner fieldAligner;
 
 	int importsStart = -1, importsEnd = -1;
@@ -116,6 +166,8 @@ public class WrapPreparator extends ASTVisitor {
 	 * parameters
 	 */
 	private List<Integer> wrapIndexes = new ArrayList<Integer>();
+	/** Indexes for wraps that shouldn't happen but should be indented if cannot be removed */
+	private List<Integer> secondaryWrapIndexes = new ArrayList<Integer>();
 	private List<Float> wrapPenalties = new ArrayList<Float>();
 	private int wrapParentIndex = -1;
 	private int wrapGroupEnd = -1;
@@ -134,7 +186,7 @@ public class WrapPreparator extends ASTVisitor {
 	public boolean preVisit2(ASTNode node) {
 		this.currentDepth++;
 
-		assert this.wrapIndexes.isEmpty() && this.wrapPenalties.isEmpty();
+		assert this.wrapIndexes.isEmpty() && this.secondaryWrapIndexes.isEmpty() && this.wrapPenalties.isEmpty();
 		assert this.wrapParentIndex == -1 && this.wrapGroupEnd == -1;
 
 		boolean isMalformed = (node.getFlags() & ASTNode.MALFORMED) != 0;
@@ -180,10 +232,8 @@ public class WrapPreparator extends ASTVisitor {
 		if (!superInterfaceTypes.isEmpty()) {
 			int implementsToken = node.isInterface() ? TokenNameextends : TokenNameimplements;
 			this.wrapParentIndex = this.tm.lastIndexIn(node.getName(), -1);
-			this.wrapGroupEnd = this.tm.lastIndexIn(superInterfaceTypes.get(superInterfaceTypes.size() - 1), -1);
 			this.wrapIndexes.add(this.tm.firstIndexBefore(superInterfaceTypes.get(0), implementsToken));
-			for (Type type : superInterfaceTypes)
-				this.wrapIndexes.add(this.tm.firstIndexIn(type, -1));
+			prepareElementsList(superInterfaceTypes, TokenNameCOMMA, -1);
 			handleWrap(this.options.alignment_for_superinterfaces_in_type_declaration, PREFERRED);
 		}
 
@@ -223,13 +273,10 @@ public class WrapPreparator extends ASTVisitor {
 
 		List<Type> exceptionTypes = node.thrownExceptionTypes();
 		if (!exceptionTypes.isEmpty()) {
-			this.wrapParentIndex = this.tm.firstIndexBefore(exceptionTypes.get(0), TokenNameRPAREN);
-			this.wrapGroupEnd = this.tm.lastIndexIn(exceptionTypes.get(exceptionTypes.size() - 1), -1);
 			int wrappingOption = node.isConstructor()
 					? this.options.alignment_for_throws_clause_in_constructor_declaration
 					: this.options.alignment_for_throws_clause_in_method_declaration;
-			for (Type exceptionType : exceptionTypes)
-				this.wrapIndexes.add(this.tm.firstIndexIn(exceptionType, -1));
+			prepareElementsList(exceptionTypes, TokenNameCOMMA, TokenNameRPAREN);
 			// instead of the first exception type, wrap the "throws" token
 			this.wrapIndexes.set(0, this.tm.firstIndexBefore(exceptionTypes.get(0), TokenNamethrows));
 			handleWrap(wrappingOption, 0.5f);
@@ -258,20 +305,18 @@ public class WrapPreparator extends ASTVisitor {
 		if (!enumConstants.isEmpty()) {
 			for (EnumConstantDeclaration constant : enumConstants)
 				this.wrapIndexes.add(this.tm.firstIndexIn(constant, -1));
-			this.wrapParentIndex = this.tm.firstIndexBefore(enumConstants.get(0), TokenNameLBRACE);
+			this.wrapParentIndex = (this.options.alignment_for_enum_constants & Alignment.M_INDENT_ON_COLUMN) > 0
+					? this.tm.firstIndexBefore(enumConstants.get(0), TokenNameLBRACE) : this.tm.firstIndexIn(node, -1);
 			this.wrapGroupEnd = this.tm.lastIndexIn(enumConstants.get(enumConstants.size() - 1), -1);
 			handleWrap(this.options.alignment_for_enum_constants, node);
 		}
 
 		List<Type> superInterfaceTypes = node.superInterfaceTypes();
 		if (!superInterfaceTypes.isEmpty()) {
-			this.wrapIndexes.add(this.tm.firstIndexBefore(superInterfaceTypes.get(0), TokenNameimplements));
-			for (Type type : superInterfaceTypes)
-				this.wrapIndexes.add(this.tm.firstIndexIn(type, -1));
 			this.wrapParentIndex = this.tm.lastIndexIn(node.getName(), -1);
-			this.wrapGroupEnd = this.tm.lastIndexIn(superInterfaceTypes.get(superInterfaceTypes.size() - 1), -1);
-			this.wrapPenalties.add(PREFERRED);
-			handleWrap(this.options.alignment_for_superinterfaces_in_enum_declaration, node);
+			this.wrapIndexes.add(this.tm.firstIndexBefore(superInterfaceTypes.get(0), TokenNameimplements));
+			prepareElementsList(superInterfaceTypes, TokenNameCOMMA, -1);
+			handleWrap(this.options.alignment_for_superinterfaces_in_enum_declaration, PREFERRED);
 		}
 
 		if (this.options.align_type_members_on_columns)
@@ -302,8 +347,10 @@ public class WrapPreparator extends ASTVisitor {
 			while (expression instanceof MethodInvocation) {
 				invocation = (MethodInvocation) expression;
 				expression = invocation.getExpression();
-				if (expression != null)
+				if (expression != null) {
 					this.wrapIndexes.add(this.tm.firstIndexBefore(invocation.getName(), TokenNameDOT));
+					this.secondaryWrapIndexes.add(this.tm.firstIndexIn(invocation.getName(), TokenNameIdentifier));
+				}
 			}
 			Collections.reverse(this.wrapIndexes);
 			this.wrapParentIndex = (expression != null) ? this.tm.lastIndexIn(expression, -1)
@@ -347,6 +394,62 @@ public class WrapPreparator extends ASTVisitor {
 	}
 
 	@Override
+	public boolean visit(FieldAccess node) {
+		handleFieldAccess(node);
+		return true;
+	}
+
+	@Override
+	public boolean visit(QualifiedName node) {
+		handleFieldAccess(node);
+		return true;
+	}
+
+	@Override
+	public boolean visit(ThisExpression node) {
+		handleFieldAccess(node);
+		return true;
+	}
+
+	@Override
+	public boolean visit(SuperFieldAccess node) {
+		handleFieldAccess(node);
+		return true;
+	}
+
+	private void handleFieldAccess(Expression node) {
+		boolean isAccessChainRoot = !FieldAccessAdapter.isFieldAccess(node.getParent());
+		if (!isAccessChainRoot)
+			return;
+
+		Expression expression = node;
+		FieldAccessAdapter access = null;
+		while (FieldAccessAdapter.isFieldAccess(expression)) {
+			access = new FieldAccessAdapter(expression);
+			int nameIndex = access.getIdentifierIndex(this.tm);
+			// find a dot preceding the name, may not be there
+			for (int i = nameIndex - 1; i > this.tm.firstIndexIn(node, -1); i--) {
+				Token t = this.tm.get(i);
+				if (t.tokenType == TokenNameDOT) {
+					this.wrapIndexes.add(i);
+					this.secondaryWrapIndexes.add(nameIndex);
+				}
+				if (!t.isComment() && t.tokenType != TokenNamesuper)
+					break;
+			}
+			expression = access.getExpression();
+		}
+		Collections.reverse(this.wrapIndexes);
+		this.wrapParentIndex = this.tm.lastIndexIn(expression != null ? expression : access.accessExpression, -1);
+		boolean isFollowedByInvocation = node.getParent() instanceof MethodInvocation
+				&& node.getLocationInParent() == MethodInvocation.EXPRESSION_PROPERTY;
+		this.wrapGroupEnd = isFollowedByInvocation ? this.tm.lastIndexIn(node.getParent(), -1)
+				: new FieldAccessAdapter(node).getIdentifierIndex(this.tm);
+		// TODO need configuration for this, now only handles line breaks that cannot be removed
+		handleWrap(Alignment.M_NO_ALIGNMENT);
+	}
+
+	@Override
 	public boolean visit(InfixExpression node) {
 		Integer operatorPrecedence = OPERATOR_PRECEDENCE.get(node.getOperator());
 		if (operatorPrecedence == null)
@@ -393,6 +496,7 @@ public class WrapPreparator extends ASTVisitor {
 			assert node.getOperator().toString().equals(this.tm.toString(indexBefore));
 			int indexAfter = this.tm.firstIndexIn(operand, -1);
 			this.wrapIndexes.add(this.options.wrap_before_binary_operator ? indexBefore : indexAfter);
+			this.secondaryWrapIndexes.add(this.options.wrap_before_binary_operator ? indexAfter : indexBefore);
 
 			if (!this.options.join_wrapped_lines) {
 				// TODO there should be an option for never joining wraps on opposite side of the operator
@@ -419,6 +523,8 @@ public class WrapPreparator extends ASTVisitor {
 	public boolean visit(ConditionalExpression node) {
 		this.wrapIndexes.add(this.tm.firstIndexAfter(node.getExpression(), TokenNameQUESTION));
 		this.wrapIndexes.add(this.tm.firstIndexAfter(node.getThenExpression(), TokenNameCOLON));
+		this.secondaryWrapIndexes.add(this.tm.firstIndexIn(node.getThenExpression(), -1));
+		this.secondaryWrapIndexes.add(this.tm.firstIndexIn(node.getElseExpression(), -1));
 		this.wrapParentIndex = this.tm.lastIndexIn(node.getExpression(), -1);
 		this.wrapGroupEnd = this.tm.lastIndexIn(node, -1);
 		handleWrap(this.options.alignment_for_conditional_expression);
@@ -429,10 +535,7 @@ public class WrapPreparator extends ASTVisitor {
 	public boolean visit(ArrayInitializer node) {
 		List<Expression> expressions = node.expressions();
 		if (!expressions.isEmpty()) {
-			for (Expression expression : expressions)
-				this.wrapIndexes.add(this.tm.firstIndexIn(expression, -1));
-			this.wrapParentIndex = this.tm.firstIndexBefore(expressions.get(0), TokenNameLBRACE);
-			this.wrapGroupEnd = this.tm.lastIndexIn(node, -1);
+			prepareElementsList(expressions, TokenNameCOMMA, TokenNameLBRACE);
 			handleWrap(this.options.alignment_for_expressions_in_array_initializer, node);
 		}
 		if (!this.options.join_wrapped_lines
@@ -442,8 +545,8 @@ public class WrapPreparator extends ASTVisitor {
 			Token closingBrace = this.tm.get(closingBraceIndex);
 			if (this.tm.countLineBreaksBetween(this.tm.get(closingBraceIndex - 1), closingBrace) == 1) {
 				int openingBraceIndex = this.tm.firstIndexIn(node, TokenNameLBRACE);
-				closingBrace.setWrapPolicy(
-						new WrapPolicy(0, openingBraceIndex, this.currentDepth, 1, true, false, -1, false));
+				closingBrace.setWrapPolicy(new WrapPolicy(WrapMode.WHERE_NECESSARY, openingBraceIndex,
+						closingBraceIndex, 0, this.currentDepth, 1, true, false));
 			}
 		}
 		return true;
@@ -451,14 +554,18 @@ public class WrapPreparator extends ASTVisitor {
 
 	@Override
 	public boolean visit(Assignment node) {
-		this.wrapIndexes.add(this.tm.firstIndexIn(node.getRightHandSide(), -1));
+		int wrapIndex = this.tm.firstIndexIn(node.getRightHandSide(), -1);
+		if (this.tm.get(wrapIndex).getLineBreaksBefore() > 0)
+			return true;
 
 		int operatorIndex = this.tm.firstIndexBefore(node.getRightHandSide(), -1);
 		while (this.tm.get(operatorIndex).isComment())
 			operatorIndex--;
 		assert node.getOperator().toString().equals(this.tm.toString(operatorIndex));
 
-		this.wrapParentIndex = operatorIndex;
+		this.wrapIndexes.add(wrapIndex);
+		this.secondaryWrapIndexes.add(operatorIndex);
+		this.wrapParentIndex = operatorIndex - 1;
 		this.wrapGroupEnd = this.tm.lastIndexIn(node.getRightHandSide(), -1);
 		handleWrap(this.options.alignment_for_assignment);
 		return true;
@@ -466,12 +573,18 @@ public class WrapPreparator extends ASTVisitor {
 
 	@Override
 	public boolean visit(VariableDeclarationFragment node) {
-		if (node.getInitializer() != null) {
-			this.wrapIndexes.add(this.tm.firstIndexIn(node.getInitializer(), -1));
-			this.wrapParentIndex = this.tm.firstIndexBefore(node.getInitializer(), TokenNameEQUAL);
-			this.wrapGroupEnd = this.tm.lastIndexIn(node.getInitializer(), -1);
-			handleWrap(this.options.alignment_for_assignment);
-		}
+		if (node.getInitializer() == null)
+			return true;
+		int wrapIndex = this.tm.firstIndexIn(node.getInitializer(), -1);
+		if (this.tm.get(wrapIndex).getLineBreaksBefore() > 0)
+			return true;
+		int equalIndex = this.tm.firstIndexBefore(node.getInitializer(), TokenNameEQUAL);
+
+		this.wrapIndexes.add(wrapIndex);
+		this.secondaryWrapIndexes.add(equalIndex);
+		this.wrapParentIndex = equalIndex - 1;
+		this.wrapGroupEnd = this.tm.lastIndexIn(node.getInitializer(), -1);
+		handleWrap(this.options.alignment_for_assignment);
 		return true;
 	}
 
@@ -479,45 +592,53 @@ public class WrapPreparator extends ASTVisitor {
 	public boolean visit(IfStatement node) {
 		if (!(node.getThenStatement() instanceof Block)) {
 			int thenIndex = this.tm.firstIndexIn(node.getThenStatement(), -1);
-			if (this.tm.get(thenIndex).getLineBreaksBefore() == 0)
+			if (this.tm.get(thenIndex).getLineBreaksBefore() == 0) {
 				this.wrapIndexes.add(thenIndex);
+				this.wrapParentIndex = this.tm.firstIndexAfter(node.getExpression(), TokenNameRPAREN);
+				this.wrapGroupEnd = this.tm.lastIndexIn(node.getThenStatement(), -1);
+				handleWrap(this.options.alignment_for_compact_if, node);
+			}
 		}
 		Statement elseStatement = node.getElseStatement();
 		if (elseStatement != null && !(elseStatement instanceof Block) && !(elseStatement instanceof IfStatement)) {
 			int elseIndex = this.tm.firstIndexIn(elseStatement, -1);
-			if (this.tm.get(elseIndex).getLineBreaksBefore() == 0)
+			if (this.tm.get(elseIndex).getLineBreaksBefore() == 0) {
 				this.wrapIndexes.add(elseIndex);
-		}
-		if (!this.wrapIndexes.isEmpty()) {
-			this.wrapParentIndex = this.tm.firstIndexAfter(node.getExpression(), TokenNameRPAREN);
-			this.wrapGroupEnd = this.tm.lastIndexIn(node, -1);
-			handleWrap(this.options.alignment_for_compact_if, node);
+				this.wrapParentIndex = this.tm.firstIndexAfter(node.getExpression(), TokenNameRPAREN);
+				this.wrapGroupEnd = this.tm.lastIndexIn(elseStatement, -1);
+				handleWrap(this.options.alignment_for_compact_if, node);
+			}
 		}
 		return true;
 	}
 
 	@Override
 	public boolean visit(TryStatement node) {
-		handleArguments(node.resources(), this.options.alignment_for_resources_in_try);
+		prepareElementsList(node.resources(), TokenNameSEMICOLON, TokenNameLPAREN);
+		handleWrap(this.options.alignment_for_resources_in_try);
 		return true;
 	}
 
 	@Override
 	public boolean visit(UnionType node) {
 		List<Type> types = node.types();
-		if (this.options.wrap_before_or_operator_multicatch && !types.isEmpty()) {
+		if (types.isEmpty())
+			return true;
+		if (this.options.wrap_before_or_operator_multicatch) {
 			for (Type type : types) {
 				if (this.wrapIndexes.isEmpty()) {
 					this.wrapIndexes.add(this.tm.firstIndexIn(type, -1));
 				} else {
 					this.wrapIndexes.add(this.tm.firstIndexBefore(type, TokenNameOR));
+					this.secondaryWrapIndexes.add(this.tm.firstIndexIn(type, -1));
 				}
 			}
 			this.wrapParentIndex = this.tm.firstIndexBefore(node, TokenNameLPAREN);
 			this.wrapGroupEnd = this.tm.lastIndexIn(types.get(types.size() - 1), -1);
 			handleWrap(this.options.alignment_for_union_type_in_multicatch);
 		} else {
-			handleArguments(types, this.options.alignment_for_union_type_in_multicatch);
+			prepareElementsList(types, TokenNameOR, TokenNameLPAREN);
+			handleWrap(this.options.alignment_for_union_type_in_multicatch);
 		}
 		return true;
 	}
@@ -554,16 +675,27 @@ public class WrapPreparator extends ASTVisitor {
 	 * wrap executor will fix their indentation if necessary.
 	 */
 	private void forceContinuousWrapping(ASTNode node, int parentIndex) {
+		int parentIndent = this.tm.get(parentIndex).getIndent();
+		int indentChange = -parentIndent;
+		int lineStart = this.tm.findFirstTokenInLine(parentIndex);
+		for (int i = parentIndex; i >= lineStart; i--) {
+			int align = this.tm.get(i).getAlign();
+			if (align > 0) {
+				indentChange = -2 * parentIndent + align;
+				break;
+			}
+		}
+
+		Token previous = null;
 		int from = this.tm.firstIndexIn(node, -1);
 		int to = this.tm.lastIndexIn(node, -1);
-		Token wrapParent = this.tm.get(parentIndex);
-		Token previous = null;
 		for (int i = from; i <= to; i++) {
 			Token token = this.tm.get(i);
 			if ((token.getLineBreaksBefore() > 0 || (previous != null && previous.getLineBreaksAfter() > 0))
 					&& token.getWrapPolicy() == null) {
-				int indent = (token.getIndent() - wrapParent.getIndent());
-				token.setWrapPolicy(new WrapPolicy(indent, parentIndex, true));
+				int extraIndent = token.getIndent() + indentChange;
+				token.setWrapPolicy(new WrapPolicy(WrapMode.FORCED, parentIndex, extraIndent));
+				token.setIndent(parentIndent + extraIndent);
 			}
 			previous = token;
 		}
@@ -571,24 +703,33 @@ public class WrapPreparator extends ASTVisitor {
 
 	private void handleVariableDeclarations(List<VariableDeclarationFragment> fragments) {
 		if (fragments.size() > 1) {
-			for (int i = 1; i < fragments.size(); i++)
-				this.wrapIndexes.add(this.tm.firstIndexIn(fragments.get(i), -1));
 			this.wrapParentIndex = this.tm.firstIndexIn(fragments.get(0), -1);
-			this.wrapGroupEnd = this.tm.lastIndexIn(fragments.get(fragments.size() - 1), -1);
+			prepareElementsList(fragments, TokenNameCOMMA, -1);
+			this.wrapIndexes.remove(0);
 			handleWrap(this.options.alignment_for_multiple_fields);
 		}
 	}
 
 	private void handleArguments(List<? extends ASTNode> arguments, int wrappingOption) {
-		for (ASTNode argument : arguments)
-			this.wrapIndexes.add(this.tm.firstIndexIn(argument, -1));
+		this.wrapPenalties.add(1 / PREFERRED);
+		prepareElementsList(arguments, TokenNameCOMMA, TokenNameLPAREN);
+		handleWrap(wrappingOption);
+	}
+
+	private void prepareElementsList(List<? extends ASTNode> elements, int separatorType, int wrapParentType) {
+		for (int i = 0; i < elements.size(); i++) {
+			ASTNode element = elements.get(i);
+			this.wrapIndexes.add(this.tm.firstIndexIn(element, -1));
+			if (i > 0)
+				this.secondaryWrapIndexes.add(this.tm.firstIndexBefore(element, separatorType));
+		}
 		// wrapIndexes may have been filled with additional values even if arguments is empty
 		if (!this.wrapIndexes.isEmpty()) {
 			Token firstToken = this.tm.get(this.wrapIndexes.get(0));
-			this.wrapParentIndex = this.tm.findIndex(firstToken.originalStart - 1, TokenNameLPAREN, false);
-			if (!arguments.isEmpty() && this.wrapGroupEnd < 0)
-				this.wrapGroupEnd = this.tm.lastIndexIn(arguments.get(arguments.size() - 1), -1);
-			handleWrap(wrappingOption, 1 / PREFERRED);
+			if (this.wrapParentIndex < 0)
+				this.wrapParentIndex = this.tm.findIndex(firstToken.originalStart - 1, wrapParentType, false);
+			if (!elements.isEmpty() && this.wrapGroupEnd < 0)
+				this.wrapGroupEnd = this.tm.lastIndexIn(elements.get(elements.size() - 1), -1);
 		}
 	}
 
@@ -604,6 +745,7 @@ public class WrapPreparator extends ASTVisitor {
 	private void handleWrap(int wrappingOption, ASTNode parentNode) {
 		doHandleWrap(wrappingOption, parentNode);
 		this.wrapIndexes.clear();
+		this.secondaryWrapIndexes.clear();
 		this.wrapPenalties.clear();
 		this.wrapParentIndex = this.wrapGroupEnd = -1;
 	}
@@ -634,17 +776,28 @@ public class WrapPreparator extends ASTVisitor {
 			boolean satisfied = false;
 			for (int index : this.wrapIndexes) {
 				Token token = this.tm.get(index);
-				if (token.getWrapPolicy().isTopPriority()) {
+				if (token.getWrapPolicy().wrapMode == WrapMode.TOP_PRIORITY) {
 					token.breakBefore();
 					satisfied = true;
 				}
 			}
 			if (!satisfied) {
-				boolean canWrapFirst = (wrappingOption & Alignment.M_NEXT_PER_LINE_SPLIT) != Alignment.M_NEXT_PER_LINE_SPLIT;
+				boolean canWrapFirst = (wrappingOption
+						& Alignment.M_NEXT_PER_LINE_SPLIT) != Alignment.M_NEXT_PER_LINE_SPLIT;
 				if (canWrapFirst)
 					this.tm.get(this.wrapIndexes.get(0)).breakBefore();
 			}
 		}
+
+		if (!this.secondaryWrapIndexes.isEmpty()) {
+			int optionNoAlignment = (wrappingOption & ~Alignment.SPLIT_MASK) | Alignment.M_NO_ALIGNMENT;
+			policy = getWrapPolicy(optionNoAlignment, 0, false, parentNode);
+			for (int index : this.secondaryWrapIndexes) {
+				Token token = this.tm.get(index);
+				if (token.getWrapPolicy() == null)
+					token.setWrapPolicy(policy);
+			}
+		}
 	}
 
 	private void setTokenWrapPolicy(int index, WrapPolicy policy, boolean wrapPreceedingComments) {
@@ -662,22 +815,11 @@ public class WrapPreparator extends ASTVisitor {
 
 		Token token = this.tm.get(index);
 		token.setWrapPolicy(policy);
-		if (this.options.join_wrapped_lines
-				&& (token.tokenType == TokenNameCOMMENT_BLOCK || token.tokenType == TokenNameCOMMENT_JAVADOC)) {
+
+		if (this.options.join_wrapped_lines && token.tokenType == TokenNameCOMMENT_BLOCK) {
 			// allow wrap preparator to decide if this comment should be wrapped
 			token.clearLineBreaksBefore();
 		}
-
-		// extend this policy to a token that is in the next line because of comments
-		for (int i = index + 1; i < this.tm.size(); i++) {
-			Token next = this.tm.get(i);
-			WrapPolicy policy2 = next.getWrapPolicy();
-			if (policy2 != null && policy2.isForced && policy2.extraIndent == 0) {
-				next.setWrapPolicy(policy);
-			} else if (next.tokenType != TokenNameCOMMENT_LINE && next.tokenType != TokenNameCOMMENT_BLOCK) {
-				break;
-			}
-		}
 	}
 
 	private WrapPolicy getWrapPolicy(int wrappingOption, float penaltyMultiplier, boolean isFirst, ASTNode parentNode) {
@@ -700,10 +842,12 @@ public class WrapPreparator extends ASTVisitor {
 			extraIndent = this.options.continuation_indentation_for_array_initializer;
 		}
 
+		WrapMode wrapMode = WrapMode.WHERE_NECESSARY;
 		boolean isTopPriority = false;
 		switch (wrappingOption & Alignment.SPLIT_MASK) {
 			case Alignment.M_NO_ALIGNMENT:
-				return null;
+				wrapMode = WrapMode.DISABLED;
+				break;
 			case Alignment.M_COMPACT_FIRST_BREAK_SPLIT:
 				isTopPriority = isFirst;
 				break;
@@ -722,14 +866,17 @@ public class WrapPreparator extends ASTVisitor {
 
 		if (isAlreadyWrapped)
 			isTopPriority = false; // to avoid triggering top priority wrapping
-		int topPriorityGroupEnd = isTopPriority ? this.wrapGroupEnd : -1;
+		if (isTopPriority)
+			wrapMode = WrapMode.TOP_PRIORITY;
 		extraIndent *= this.options.indentation_size;
-		return new WrapPolicy(extraIndent, this.wrapParentIndex, this.currentDepth, penaltyMultiplier, isFirst,
-				indentOnColumn, topPriorityGroupEnd, false);
+		return new WrapPolicy(wrapMode, this.wrapParentIndex, this.wrapGroupEnd, extraIndent, this.currentDepth,
+				penaltyMultiplier, isFirst, indentOnColumn);
 	}
 
-	public void finishUp(ASTNode astRoot) {
+	public void finishUp(ASTNode astRoot, IRegion[] regions) {
 		preserveExistingLineBreaks();
+		if (regions != null)
+			applyBreaksOutsideRegions(regions);
 		new WrapExecutor(this.tm, this.options).executeWraps();
 		this.fieldAligner.alignComments();
 		wrapComments();
@@ -748,7 +895,8 @@ public class WrapPreparator extends ASTVisitor {
 
 			@Override
 			protected boolean token(Token token, int index) {
-				boolean isBetweenImports = index > WrapPreparator.this.importsStart && index < WrapPreparator.this.importsEnd;
+				boolean isBetweenImports = index > WrapPreparator.this.importsStart
+						&& index < WrapPreparator.this.importsEnd;
 				int lineBreaks = getLineBreaksToPreserve(getPrevious(), token, isBetweenImports);
 				if (lineBreaks <= getLineBreaksBefore())
 					return true;
@@ -798,6 +946,30 @@ public class WrapPreparator extends ASTVisitor {
 		return Math.min(lineBreaks, toPreserve);
 	}
 
+	private void applyBreaksOutsideRegions(IRegion[] regions) {
+		String source = this.tm.getSource();
+		int previousRegionEnd = 0;
+		for (IRegion region : regions) {
+			int index = this.tm.findIndex(previousRegionEnd, -1, true);
+			Token token = this.tm.get(index);
+			if (this.tm.countLineBreaksBetween(source, previousRegionEnd,
+					Math.min(token.originalStart, region.getOffset())) > 0)
+				token.breakBefore();
+			for (index++; index < this.tm.size(); index++) {
+				Token next = this.tm.get(index);
+				if (next.originalStart > region.getOffset()) {
+					if (this.tm.countLineBreaksBetween(source, token.originalEnd, region.getOffset()) > 0)
+						next.breakBefore();
+					break;
+				}
+				if (this.tm.countLineBreaksBetween(token, next) > 0)
+					next.breakBefore();
+				token = next;
+			}
+			previousRegionEnd = region.getOffset() + region.getLength() - 1;
+		}
+	}
+
 	private void wrapComments() {
 		CommentWrapExecutor commentWrapper = new CommentWrapExecutor(this.tm, this.options);
 		boolean isNLSTagInLine = false;
commit f3886d8ab47e0b5dc32179a8d3e8db45c6fe8498
Author: Mateusz Matela <mateusz.matela@gmail.com>
Date:   Mon Dec 28 22:25:30 2015 +0100

    Follow-up on bug 477476 - Auto-formatter gets indentation wrong when used as post-save action

4	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_in.java
5	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_out.java
4	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_in.java
5	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_out.java
2	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
1	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_in.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_in.java
index b78fe42..0592d9f 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_in.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_in.java
@@ -93,5 +93,9 @@ bb//
 )//
 );
 		}
+
+		this.getWriter().println("aaaaa" + //
+				"bbbbbb" + //
+				"ccc");
 	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_out.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_out.java
index 04cdb3c..fb8df2c 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_out.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476a/A_out.java
@@ -93,5 +93,10 @@ public class Example //
 					)//
 			);
 		}
+
+		this.getWriter()
+		        .println("aaaaa" + //
+		                "bbbbbb" + //
+		                "ccc");
 	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_in.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_in.java
index 3899aff..84aa715 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_in.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_in.java
@@ -93,5 +93,9 @@ public class Example
 [#)#]
 [#);#]
 		}
+		
+		[#	this.getWriter().println("aaaaa" + //#]
+				[#		"bbbbbb" + //      #]
+						[#	"ccc");#]
 	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_out.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_out.java
index a946229..e9f0c66 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_out.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test477476b/A_out.java
@@ -94,5 +94,10 @@ public class Example
 					)
 			);
 		}
+		
+		this.getWriter()
+				.println("aaaaa" + //
+						"bbbbbb" + //
+						"ccc");
 	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
index 49272996..8b14811 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
@@ -425,7 +425,8 @@ public class WrapExecutor {
 
 		if ((!lineExceeded || firstPotentialWrap < 0) && lastIndex + 1 < this.tm.size()) {
 			Token nextLineToken = this.tm.get(lastIndex + 1);
-			if (nextLineToken.isWrappable() && (this.tm.get(lastIndex).isComment() || nextLineToken.isComment())) {
+			if ((nextLineToken.getWrapPolicy() != null && nextLineToken.getWrapPolicy().wrapMode != WrapMode.FORCED)
+					&& (this.tm.get(lastIndex).isComment() || nextLineToken.isComment())) {
 				// this might be a pre-existing wrap forced by a comment, calculate penalties as normal
 				bestIndent = getWrapIndent(nextLineToken);
 				bestNextWrap = lastIndex + 1;
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
index 509b104..1d24564 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
@@ -814,7 +814,7 @@ public class WrapPreparator extends ASTVisitor {
 
 		if (!this.secondaryWrapIndexes.isEmpty()) {
 			int optionNoAlignment = (wrappingOption & ~Alignment.SPLIT_MASK) | Alignment.M_NO_ALIGNMENT;
-			policy = getWrapPolicy(optionNoAlignment, 0, false, parentNode);
+			policy = getWrapPolicy(optionNoAlignment, 1, false, parentNode);
 			for (int index : this.secondaryWrapIndexes) {
 				Token token = this.tm.get(index);
 				if (token.getWrapPolicy() == null)
commit 10545bbf89db4e21cbdfaf0260ea872d78aa91e9
Author: Mateusz Matela <mateusz.matela@gmail.com>
Date:   Tue Dec 29 23:45:54 2015 +0100

    Follow-up on bug 477476 - Auto-formatter gets indentation wrong when used as post-save action

13	12	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
index 8b14811..2dd2528 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapExecutor.java
@@ -90,12 +90,13 @@ public class WrapExecutor {
 		}
 	}
 
-	private static class WrapRestartException extends Exception {
+	private static class WrapRestartThrowable extends Throwable {
 		private static final long serialVersionUID = -2980600077230803443L; // backward compatible
 
 		public final int topPriorityWrap;
 
-		public WrapRestartException(int topPriorityWrap) {
+		public WrapRestartThrowable(int topPriorityWrap) {
+			super(null, null, false, false);
 			this.topPriorityWrap = topPriorityWrap;
 		}
 	}
@@ -301,7 +302,7 @@ public class WrapExecutor {
 					this.wrapSearchResults.clear();
 					index = applyWraps(index, currentIndent);
 					break;
-				} catch (WrapRestartException e) {
+				} catch (WrapRestartThrowable e) {
 					handleTopPriorityWraps(e);
 				}
 			}
@@ -312,7 +313,7 @@ public class WrapExecutor {
 		this.tm.traverse(0, new NLSTagHandler());
 	}
 
-	private int applyWraps(int index, int indent) throws WrapRestartException {
+	private int applyWraps(int index, int indent) throws WrapRestartThrowable {
 		WrapInfo wrapInfo = findWrapsCached(index, indent).nextWrap;
 		Token token = this.tm.get(index);
 		index++;
@@ -360,7 +361,7 @@ public class WrapExecutor {
 		return index;
 	}
 
-	private WrapResult findWrapsCached(int startTokenIndex, int indent) throws WrapRestartException {
+	private WrapResult findWrapsCached(int startTokenIndex, int indent) throws WrapRestartThrowable {
 		this.wrapInfoTemp.wrapTokenIndex = startTokenIndex;
 		this.wrapInfoTemp.indent = indent;
 		WrapResult wrapResult = this.wrapSearchResults.get(this.wrapInfoTemp);
@@ -400,7 +401,7 @@ public class WrapExecutor {
 	 * The main algorithm that looks for optimal places to wrap.
 	 * Calls itself recursively to get results for wrapped sub-lines.  
 	 */
-	private WrapResult findWraps(int wrapTokenIndex, int indent) throws WrapRestartException {
+	private WrapResult findWraps(int wrapTokenIndex, int indent) throws WrapRestartThrowable {
 		final int lastIndex = this.lineAnalyzer.analyzeLine(wrapTokenIndex, indent);
 		final boolean lineExceeded = this.lineAnalyzer.lineExceeded;
 		final int lastPosition = this.lineAnalyzer.getLastPosition();
@@ -496,7 +497,7 @@ public class WrapExecutor {
 	}
 
 	private double getWrapPenalty(int lineStartIndex, int lineIndent, int wrapIndex, int wrapIndent,
-			WrapResult wrapResult) throws WrapRestartException {
+			WrapResult wrapResult) throws WrapRestartThrowable {
 		WrapPolicy wrapPolicy = null;
 		Token wrapToken = null;
 		if (wrapIndex < this.tm.size()) {
@@ -564,7 +565,7 @@ public class WrapExecutor {
 		return Math.exp(policy.structureDepth) * policy.penaltyMultiplier;
 	}
 
-	private void checkForceWrap(Token token, int currentIndent) throws WrapRestartException {
+	private void checkForceWrap(Token token, int currentIndent) throws WrapRestartThrowable {
 		// A token that will have smaller indent when wrapped than the current line indent,
 		// should be wrapped because it's a low depth token following some complex wraps of higher depth.
 		// This rule could not be implemented in getWrapPenalty() because a token's wrap indent may depend
@@ -573,19 +574,19 @@ public class WrapExecutor {
 			int indent = getWrapIndent(token);
 			if (indent < currentIndent) {
 				token.breakBefore();
-				throw new WrapRestartException(-1);
+				throw new WrapRestartThrowable(-1);
 			}
 		}
 	}
 
-	private void checkTopPriorityWraps(int wrapIndex) throws WrapRestartException {
+	private void checkTopPriorityWraps(int wrapIndex) throws WrapRestartThrowable {
 		WrapPolicy wrapPolicy = this.tm.get(wrapIndex).getWrapPolicy();
 		if (wrapPolicy != null && wrapPolicy.wrapMode == WrapMode.TOP_PRIORITY
 				&& !this.usedTopPriorityWraps.contains(wrapPolicy))
-			throw new WrapRestartException(wrapIndex);
+			throw new WrapRestartThrowable(wrapIndex);
 	}
 
-	private void handleTopPriorityWraps(WrapRestartException restartException) {
+	private void handleTopPriorityWraps(WrapRestartThrowable restartException) {
 		int wrapIndex = restartException.topPriorityWrap;
 		if (wrapIndex < 0)
 			return;
