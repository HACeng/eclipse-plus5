commit 792caf681810140ce615d98d3abfdde62639719c
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Aug 25 21:25:14 2013 +0200

    Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type
    annotations
    - annotation on outer type (QTR), incl. reset after detection
    - code cleanup

61	9	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
6	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
5	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
2	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
1	35	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
17	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
18	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 58d618f..a3e8696 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -29,7 +29,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	// Static initializer to specify tests subset using TESTS_* static variables
 	// All specified tests which do not belong to the class are skipped...
 	static {
-//			TESTS_NAMES = new String[] { "testArrayType_10" };
+//			TESTS_NAMES = new String[] { "testUnsupportedLocation" };
 //			TESTS_NUMBERS = new int[] { 561 };
 //			TESTS_RANGE = new int[] { 1, 2049 };
 	}
@@ -306,7 +306,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"B.java",
 				  "import org.eclipse.jdt.annotation.*;\n" +
 				  "public class B {\n" +
-				  "    public void foo(@NonNull A<Object>.@Nullable I<@NonNull String> ai) {\n" +
+				  "    public void foo(A<Object>.@Nullable I<@NonNull String> ai) {\n" +
 				  "            ai.foo(null); // problems: ai can be null, arg must not be null\n" +
 				  "    }\n" +
 				  "}\n"},
@@ -1074,7 +1074,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 					"public abstract class X1 {\n" +
 					"    public class Inner {}\n" +
 					"    public Object []@NonNull[] arrays(Object @NonNull[][] oa1) { return null; }\n" +
-					"    public void nesting(@NonNull Inner i1, @NonNull X1.@Nullable Inner i2) { }\n" +
+					"    public void nesting(@NonNull Inner i1, X1.@Nullable Inner i2) { }\n" +
 					"    public void wildcard1(List<@Nullable ? extends @NonNull X1> l) { }\n" + // contradiction
 					"    public void wildcard2(List<? super @NonNull X1> l) { }\n" +
 					"}\n"
@@ -1108,12 +1108,11 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"	x.arrays(a)[0] = null;\n" + 
 				"	^^^^^^^^^^^^^^\n" + 
 				"Null type mismatch: required \'Object @NonNull[]\' but the provided value is null\n" +
-// TODO(stephan): not reported due to Bug 414384 - [1.8] type annotation on abbreviated inner class is not marked as inner type
-//				"----------\n" + 
-//				"3. ERROR in Y1.java (at line 8)\n" + 
-//				"	x.nesting(null, null);\n" + 
-//				"	          ^^^^\n" + 
-//				"Null type mismatch: required \'@NonNull X1.Inner\' but the provided value is null\n" + 
+				"----------\n" + 
+				"2. ERROR in Y1.java (at line 7)\n" + 
+				"	x.nesting(null, null);\n" + 
+				"	          ^^^^\n" + 
+				"Null type mismatch: required \'X1.@NonNull Inner\' but the provided value is null\n" + 
 				"----------\n");
 	}
 
@@ -1498,4 +1497,57 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n");
 	}
 
+	// illegal for type declaration
+	public void testUnsupportedLocation01() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public @NonNull class X {}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 2)\n" + 
+			"	public @NonNull class X {}\n" + 
+			"	       ^^^^^^^^\n" + 
+			"The nullness annotation \'NonNull\' is not applicable at this location\n" + 
+			"----------\n");
+	}
+
+	// illegal for enclosing class (locations: field, argument, return type, local
+	public void testUnsupportedLocation02() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public class X {\n" +
+				"    class Inner {}\n" +
+				"    @NonNull X.Inner f;\n" +
+				"    @NonNull X.Inner foo(@NonNull X.Inner arg) {\n" +
+				"        @NonNull X.Inner local = arg;\n" +
+				"        return local;\n" +
+				"    }\n" +
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 4)\n" + 
+			"	@NonNull X.Inner f;\n" + 
+			"	^^^^^^^^\n" + 
+			"The nullness annotation \'NonNull\' is not applicable at this location\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 5)\n" + 
+			"	@NonNull X.Inner foo(@NonNull X.Inner arg) {\n" + 
+			"	^^^^^^^^\n" + 
+			"The nullness annotation \'NonNull\' is not applicable at this location\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 5)\n" + 
+			"	@NonNull X.Inner foo(@NonNull X.Inner arg) {\n" + 
+			"	                     ^^^^^^^^\n" + 
+			"The nullness annotation \'NonNull\' is not applicable at this location\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 6)\n" + 
+			"	@NonNull X.Inner local = arg;\n" + 
+			"	^^^^^^^^\n" + 
+			"The nullness annotation \'NonNull\' is not applicable at this location\n" + 
+			"----------\n");
+	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index 137282a..a7c4a61 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -20,7 +20,8 @@
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 401030 - [1.8][null] Null analysis support for lambda methods.
- *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis 
+ *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -651,15 +652,16 @@ public abstract class AbstractMethodDeclaration
 					if (this.binding.parameterNonNullness[i] != null) {
 						long nullAnnotationTagBit =  this.binding.parameterNonNullness[i].booleanValue()
 								? TagBits.AnnotationNonNull : TagBits.AnnotationNullable;
-						this.scope.validateNullAnnotation(nullAnnotationTagBit, this.arguments[i].type, this.arguments[i].annotations);
+						if (!this.scope.validateNullAnnotation(nullAnnotationTagBit, this.arguments[i].type, this.arguments[i].annotations))
+							this.binding.parameterNonNullness[i] = null;
 					}
 				}
 			}
 		} else {
 			int length = this.binding.parameters.length;
 			for (int i=0; i<length; i++) {
-				long nullAnnotationTagBit = this.binding.parameters[i].tagBits & TagBits.AnnotationNullMASK;
-				this.scope.validateNullAnnotation(nullAnnotationTagBit, this.arguments[i].type, this.arguments[i].annotations);
+				if (!this.scope.validateNullAnnotation(this.binding.parameters[i].tagBits, this.arguments[i].type, this.arguments[i].annotations))
+					this.binding.parameters[i] = this.binding.parameters[i].unannotated();
 			}			
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index fcf34c5..c49b4f6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -17,6 +17,7 @@
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409517 - [1.8][compiler] Type annotation problems on more elaborate array references
@@ -1017,8 +1018,10 @@ public abstract class Annotation extends Expression {
 							if (nullTagBits != 0) {
 								if (variable.type.isBaseType()) {
 									scope.problemReporter().illegalAnnotationForBaseType(this, variable.type);
-								} else {
-									variable.type = scope.environment().pushAnnotationIntoType(variable.type, variable.declaration.type, nullTagBits);
+								} else if (variable.declaration.type instanceof QualifiedTypeReference) {
+									scope.problemReporter().nullAnnotationUnsupportedLocation(this);
+								} else if (nullTagBits != (variable.type.tagBits & TagBits.AnnotationNullMASK)) {
+									variable.type = scope.environment().createAnnotatedType(variable.type, nullTagBits);
 									if ((variable.type.tagBits & TAGBITS_NULLABLE_OR_NONNULL) == TAGBITS_NULLABLE_OR_NONNULL) {
 										scope.problemReporter().contradictoryNullAnnotations(this);
 										variable.type = variable.type.unannotated();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index ce86994..3c988ae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -16,7 +16,8 @@
  *							bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
  *     Stephan Herrmann - Contribution for
  *							bug 401030 - [1.8][null] Null analysis support for lambda methods.
- *							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis 
+ *							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -349,8 +350,8 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		if (this.binding != null) {
 			int length = this.binding.parameters.length;
 			for (int i=0; i<length; i++) {
-				long nullAnnotationTagBit =  this.binding.returnType.tagBits & TagBits.AnnotationNullMASK;
-				this.scope.validateNullAnnotation(nullAnnotationTagBit, this.arguments[i].type, this.arguments[i].annotations);
+				if (!this.scope.validateNullAnnotation(this.binding.returnType.tagBits, this.arguments[i].type, this.arguments[i].annotations))
+					this.binding.returnType = this.binding.returnType.unannotated();
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index 83b9209..7122660 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -25,6 +25,7 @@
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
  *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
+ *							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *     Jesper S Moller - Contributions for
  *							Bug 378674 - "The method can be declared as static" is wrong
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -291,7 +292,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				}
 			}
 		}
-		scope.validateNullAnnotation(this.binding.tagBits, this.type, this.annotations);
+		if (!scope.validateNullAnnotation(this.binding.tagBits, this.type, this.annotations))
+			this.binding.tagBits &= ~TagBits.AnnotationNullMASK;
 	}
 
 	public void traverse(ASTVisitor visitor, BlockScope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 0e5cd7d..b162144 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -18,7 +18,8 @@
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
- *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis 
+ *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
@@ -354,13 +355,4 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 	public TypeParameter[] typeParameters() {
 	    return this.typeParameters;
 	}
-	
-	void validateNullAnnotations(long sourceLevel) {
-		super.validateNullAnnotations(sourceLevel);
-		// null-annotations on the return type?
-		if (this.binding != null && this.binding.returnType != null) {
-			long tagBits = (sourceLevel < ClassFileConstants.JDK1_8) ? this.binding.tagBits : this.binding.returnType.tagBits;
-			this.scope.validateNullAnnotation(tagBits, this.returnType, this.annotations);
-		}
-	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 03a327b..2b8dc4b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -20,6 +20,7 @@
  *								bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415291 - [1.8][null] differentiate type incompatibilities due to null annotations
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -33,8 +34,6 @@ import java.util.Set;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ClassFilePool;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
-import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
@@ -1028,39 +1027,6 @@ public TypeBinding createAnnotatedType(TypeBinding genericType, long annotationB
 }
 
 /**
- * Create an annotated type from 'type' by applying 'annotationBits' to its outermost enclosing type.
- * This is used for those locations where a null annotations was parsed as a declaration annotation
- * and later must be pushed into the type.
- * @param type
- * @param annotationBits
- */
-public TypeBinding pushAnnotationIntoType(TypeBinding type, TypeReference typeRef, long annotationBits) {
-	TypeBinding outermostType = type;
-	if (typeRef instanceof QualifiedTypeReference) {
-		int depth = typeRef.getAnnotatableLevels();
-		while (--depth > 0)
-			outermostType = outermostType.enclosingType();
-	}
-	if ((outermostType.tagBits & TagBits.AnnotationNullMASK) != annotationBits) {
-		if (type == outermostType)
-			return createAnnotatedType(type, annotationBits);
-		// types with true enclosingType() must be ReferenceBindings
-		return reWrap((ReferenceBinding) type, outermostType, (ReferenceBinding)createAnnotatedType(outermostType, annotationBits));
-	}
-	return type;
-}
-
-private ReferenceBinding reWrap(ReferenceBinding inner, TypeBinding outer, ReferenceBinding annotatedOuter) {
-	ReferenceBinding annotatedEnclosing =  (inner.enclosingType() == outer) 
-			? annotatedOuter
-			: reWrap(inner.enclosingType(), outer, annotatedOuter);
-	TypeBinding[] arguments = (inner instanceof ParameterizedTypeBinding)
-			? ((ParameterizedTypeBinding) inner).arguments 
-			: Binding.NO_TYPES;
-	return createParameterizedType((ReferenceBinding)inner.original(), arguments, inner.tagBits, annotatedEnclosing);	
-}
-
-/**
  * Note: annotationBits are exactly those tagBits from annotations on type parameters that are interpreted by the compiler, currently: null annotations.
  * typeArguments should never be Binding.NO_TYPES, but rather: null, if no type arguments are present (and only annotationBits are the reason for coming here).
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 42d0c44..f79f8c3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -20,6 +20,7 @@
  *								bug 405706 - Eclipse compiler fails to give compiler error when return type is a inferred generic
  *								Bug 408441 - Type mismatch using Arrays.asList with 3 or more implementations of an interface with the interface type as the last parameter
  *								Bug 413958 - Function override returning inherited Generic Type
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *  							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335
@@ -4466,14 +4467,28 @@ public abstract class Scope {
 		return visibleIndex == 1 ? visible[0] : mostSpecificMethodBinding(visible, visibleIndex, argumentTypes, allocationSite, allocationType);
 	}
 
-	public void validateNullAnnotation(long tagBits, TypeReference typeRef, Annotation[] annotations) {
+	public boolean validateNullAnnotation(long tagBits, TypeReference typeRef, Annotation[] annotations) {
 		long nullAnnotationTagBit = tagBits & (TagBits.AnnotationNullMASK);
 		if (nullAnnotationTagBit != 0) {
 			TypeBinding type = typeRef.resolvedType;
 			if (type != null && type.isBaseType()) {
-				problemReporter().illegalAnnotationForBaseType(typeRef, annotations, nullAnnotationTagBit);
+				// type annotations are *always* illegal for 'void' (already reported)
+				if (!(typeRef.resolvedType.id == TypeIds.T_void && compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8))
+					problemReporter().illegalAnnotationForBaseType(typeRef, annotations, nullAnnotationTagBit);
+				return false;
+			}
+			if (annotations != null && typeRef instanceof QualifiedTypeReference) {
+				// illegal @NonNull Outer.Inner:
+				for (int i = 0; i < annotations.length; i++) {
+					int id = annotations[i].resolvedType.id;
+					if (id == TypeIds.T_ConfiguredAnnotationNonNull || id == TypeIds.T_ConfiguredAnnotationNullable) {
+						problemReporter().nullAnnotationUnsupportedLocation(annotations[i]);
+						return false;
+					}
+				}
 			}
 		}
+		return true;
 	}
 	public static BlockScope typeAnnotationsResolutionScope(Scope scope) {
 		BlockScope resolutionScope = null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 8904629..685c1a0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -28,6 +28,7 @@
  *								bug 391376 - [1.8] check interaction of default methods with bridge methods and generics
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1535,12 +1536,13 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 						field.fillInDefaultNonNullness(fieldDecl, initializationScope);
 					}
 					// validate null annotation:
-					this.scope.validateNullAnnotation(field.tagBits, fieldDecl.type, fieldDecl.annotations);
+					if (!this.scope.validateNullAnnotation(field.tagBits, fieldDecl.type, fieldDecl.annotations))
+						field.tagBits &= ~TagBits.AnnotationNullMASK;
 				}
 				if (sourceLevel >= ClassFileConstants.JDK1_8 && !fieldType.isBaseType()) {
 					long nullTagBits = field.tagBits & TagBits.AnnotationNullMASK;
 					if (nullTagBits != 0 && nullTagBits != (fieldType.tagBits & TagBits.AnnotationNullMASK))
-						field.type = environment.pushAnnotationIntoType(fieldType, fieldDecl.type, nullTagBits);
+						field.type = environment.createAnnotatedType(fieldType, nullTagBits);
 					// do not reset field.tagBits, since more fields may need to share this information ("@NonNull Object o1, o2;")
 				}
 			}
@@ -1721,18 +1723,22 @@ public MethodBinding resolveTypesFor(MethodBinding method) {
 	}
 	CompilerOptions compilerOptions = this.scope.compilerOptions();
 	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled) {
-		if (compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
+		if (!method.isConstructor()) {
 			long nullTagBits = method.tagBits & TagBits.AnnotationNullMASK;
-			if (nullTagBits != (method.returnType.tagBits & TagBits.AnnotationNullMASK)) {
-				TypeReference returnTypeRef = ((MethodDeclaration)methodDecl).returnType;
-				if (method.returnType.isBaseType()) {
-					if (method.returnType.id != TypeIds.T_void)  // type annotations are *always* illegal for 'void'
-						this.scope.problemReporter().illegalAnnotationForBaseType(returnTypeRef, methodDecl.annotations, nullTagBits);
-				} else {
-					// annotation was mistakenly associated to the method, create the annotated type now:
-					method.returnType = this.scope.environment().pushAnnotationIntoType(method.returnType, returnTypeRef, nullTagBits);
+			TypeReference returnTypeRef = ((MethodDeclaration)methodDecl).returnType;
+			if (compilerOptions.sourceLevel < ClassFileConstants.JDK1_8) {
+				if (!this.scope.validateNullAnnotation(nullTagBits, returnTypeRef, methodDecl.annotations))
+					method.tagBits &= ~TagBits.AnnotationNullMASK;
+			} else {
+				if (nullTagBits != (method.returnType.tagBits & TagBits.AnnotationNullMASK)) {
+					if (!this.scope.validateNullAnnotation(nullTagBits, returnTypeRef, methodDecl.annotations)) {
+						method.returnType = method.returnType.unannotated();
+					} else {
+						// annotation was mistakenly associated to the method, create the annotated type now:
+						method.returnType = this.scope.environment().createAnnotatedType(method.returnType, nullTagBits);
+					}
+					method.tagBits &= ~TagBits.AnnotationNullMASK;
 				}
-				method.tagBits &= ~TagBits.AnnotationNullMASK;
 			}
 		}
 		createArgumentBindings(method, compilerOptions); // need annotations resolved already at this point
commit c67d112c20f07c2dcda11714ef23687a9781a753
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sat Aug 31 21:57:24 2013 +0200

    Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type
    annotations

5	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
125	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
8	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
19	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
25	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleTypeReference.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
38	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
5	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 9a1453c..a984a0b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -32,6 +32,7 @@
  *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *     Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -821,6 +822,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NotVisibleType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullAnnotationUnsupportedLocation", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
+		expectedProblemAttributes.put("NullAnnotationUnsupportedLocationAtType", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("NullExpressionReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NullLocalVariableInstanceofYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -1001,6 +1003,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("UnsafeElementTypeConversion", new ProblemAttributes(CategorizedProblem.CAT_UNCHECKED_RAW));
 		expectedProblemAttributes.put("UnsafeGenericArrayForVarargs", new ProblemAttributes(CategorizedProblem.CAT_UNCHECKED_RAW));
 		expectedProblemAttributes.put("UnsafeGenericCast", new ProblemAttributes(CategorizedProblem.CAT_UNCHECKED_RAW));
+		expectedProblemAttributes.put("UnsafeNullnessCast", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UnsafeRawConstructorInvocation", new ProblemAttributes(CategorizedProblem.CAT_UNCHECKED_RAW));
 		expectedProblemAttributes.put("UnsafeRawFieldAssignment", new ProblemAttributes(CategorizedProblem.CAT_UNCHECKED_RAW));
 		expectedProblemAttributes.put("UnsafeRawGenericConstructorInvocation", new ProblemAttributes(CategorizedProblem.CAT_UNCHECKED_RAW));
@@ -1611,6 +1614,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NotVisibleType", SKIP);
 		expectedProblemAttributes.put("NullableFieldReference", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_REFERENCE));
 		expectedProblemAttributes.put("NullAnnotationUnsupportedLocation", SKIP);
+		expectedProblemAttributes.put("NullAnnotationUnsupportedLocationAtType", SKIP);
 		expectedProblemAttributes.put("NullityMismatchingTypeAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("NullityMismatchTypeArgument", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("NullityUncheckedTypeAnnotationDetail", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
@@ -1791,6 +1795,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UnsafeElementTypeConversion", new ProblemAttributes(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION));
 		expectedProblemAttributes.put("UnsafeGenericArrayForVarargs", new ProblemAttributes(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION));
 		expectedProblemAttributes.put("UnsafeGenericCast", new ProblemAttributes(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION));
+		expectedProblemAttributes.put("UnsafeNullnessCast", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
 		expectedProblemAttributes.put("UnsafeRawConstructorInvocation", new ProblemAttributes(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION));
 		expectedProblemAttributes.put("UnsafeRawFieldAssignment", new ProblemAttributes(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION));
 		expectedProblemAttributes.put("UnsafeRawGenericConstructorInvocation", new ProblemAttributes(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 74fb0c4..7620800 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -29,7 +29,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	// Static initializer to specify tests subset using TESTS_* static variables
 	// All specified tests which do not belong to the class are skipped...
 	static {
-//			TESTS_NAMES = new String[] { "testBug416182" };
+//			TESTS_NAMES = new String[] { "testUnsupportedLocation" };
 //			TESTS_NUMBERS = new int[] { 561 };
 //			TESTS_RANGE = new int[] { 1, 2049 };
 	}
@@ -1888,7 +1888,130 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"The nullness annotation \'NonNull\' is not applicable at this location\n" + 
 			"----------\n");
 	}
-	
+
+	// illegal for cast & instanceof with scalar type
+	public void testUnsupportedLocation03() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public class X {\n" +
+				"    @NonNull X foo(X arg) {\n" +
+				"        if (!(arg instanceof @NonNull X))\n" +
+				"			return (@NonNull X)arg;\n" +
+				"        return arg;\n" +
+				"    }\n" +
+				"}\n"
+			},
+			"----------\n" + 
+			"1. WARNING in X.java (at line 4)\n" + 
+			"	if (!(arg instanceof @NonNull X))\n" + 
+			"	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The expression of type X is already an instance of type X\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 4)\n" + 
+			"	if (!(arg instanceof @NonNull X))\n" + 
+			"	                     ^^^^^^^^^^\n" + 
+			"Nullness annotations are not applicable at this location \n" + 
+			"----------\n" + 
+			"3. WARNING in X.java (at line 5)\n" + 
+			"	return (@NonNull X)arg;\n" + 
+			"	       ^^^^^^^^^^^^^^^\n" + 
+			"Null type safety: Unchecked cast from X to @NonNull X\n" + 
+			"----------\n");
+	}
+
+	// illegal for cast & instanceof with complex type
+	public void testUnsupportedLocation04() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"p/X.java",
+				"package p;\n" +
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"import java.util.*;\n" +
+				"public class X {\n" +
+				"    List<@NonNull X> parameterized(List<X> arg) {\n" +
+				"        if (!(arg instanceof List<@NonNull X>))\n" +
+				"			return (java.util.List<@NonNull X>)arg;\n" +
+				"        return arg;\n" +
+				"    }\n" +
+				"    X @NonNull[] arrays(X[] arg) {\n" +
+				"        if (!(arg instanceof X @NonNull[]))\n" +
+				"			return (p.X @NonNull[])arg;\n" +
+				"        return arg;\n" +
+				"    }\n" +
+				"	ArrayList<@NonNull String> foo(List<@NonNull String> l) {\n" + 
+				"		return (ArrayList<@NonNull String>) l;\n" + // OK 
+				"	}" +
+				"	ArrayList<@NonNull String> foo2(List<@NonNull String> l) {\n" + 
+				"		return (ArrayList<String>) l;\n" + // warn, TODO(stephan) with flow analysis (bug 415292) we might recover the original @NonNull...
+				"	}" +
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in p\\X.java (at line 6)\n" + 
+			"	if (!(arg instanceof List<@NonNull X>))\n" + 
+			"	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Cannot perform instanceof check against parameterized type List<X>. Use the form List<?> instead since further generic type information will be erased at runtime\n" + 
+			"----------\n" + 
+			"2. ERROR in p\\X.java (at line 6)\n" + 
+			"	if (!(arg instanceof List<@NonNull X>))\n" + 
+			"	                     ^^^^^^^^^^^^^^^^\n" + 
+			"Nullness annotations are not applicable at this location \n" + 
+			"----------\n" + 
+			"3. WARNING in p\\X.java (at line 7)\n" + 
+			"	return (java.util.List<@NonNull X>)arg;\n" + 
+			"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Null type safety: Unchecked cast from List<X> to List<@NonNull X>\n" + 
+			"----------\n" + 
+			"4. WARNING in p\\X.java (at line 11)\n" + 
+			"	if (!(arg instanceof X @NonNull[]))\n" + 
+			"	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The expression of type X[] is already an instance of type X[]\n" + 
+			"----------\n" + 
+			"5. ERROR in p\\X.java (at line 11)\n" + 
+			"	if (!(arg instanceof X @NonNull[]))\n" + 
+			"	                     ^^^^^^^^^^^^\n" + 
+			"Nullness annotations are not applicable at this location \n" + 
+			"----------\n" + 
+			"6. WARNING in p\\X.java (at line 12)\n" + 
+			"	return (p.X @NonNull[])arg;\n" + 
+			"	       ^^^^^^^^^^^^^^^^^^^\n" + 
+			"Null type safety: Unchecked cast from X[] to X @NonNull[]\n" + 
+			"----------\n" + 
+			"7. WARNING in p\\X.java (at line 18)\n" + 
+			"	return (ArrayList<String>) l;\n" + 
+			"	       ^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Null type safety (type annotations): The expression of type \'ArrayList<String>\' needs unchecked conversion to conform to \'ArrayList<@NonNull String>\'\n" + 
+			"----------\n");
+	}
+
+	// illegal for allocation expression
+	public void testUnsupportedLocation05() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public class X {\n" +
+				"	X x = new @NonNull X();\n" +
+				"	class Inner {}\n" +
+				"   Inner i = this.new @Nullable Inner();\n" +
+				"	java.util.List<@NonNull String> s = new java.util.ArrayList<@NonNull String>();\n" + // OK
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	X x = new @NonNull X();\n" + 
+			"	          ^^^^^^^^\n" + 
+			"The nullness annotation \'NonNull\' is not applicable at this location\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 5)\n" + 
+			"	Inner i = this.new @Nullable Inner();\n" + 
+			"	                   ^^^^^^^^^\n" + 
+			"The nullness annotation \'Nullable\' is not applicable at this location\n" + 
+			"----------\n");
+	}
+
 	public void testForeach() {
 		runNegativeTestWithLibs(
 			new String[] {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 5c18efb..fe1d19c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -186,8 +186,10 @@
  *									PotentialNullExpressionReference
  *									RedundantNullCheckAgainstNonNullType
  *									NullAnnotationUnsupportedLocation
+ *									NullAnnotationUnsupportedLocationAtType
  *									NullityMismatchTypeArgument
  *									ContradictoryNullAnnotationsOnBound
+ *									UnsafeNullnessCast
  *      Jesper S Moller  - added the following constants
  *									TargetTypeNotAFunctionalInterface
  *									OuterLocalMustBeEffectivelyFinal
@@ -1697,9 +1699,13 @@ void setSourceStart(int sourceStart);
 	/** @since 3.9 BETA_JAVA8 */
 	int NullAnnotationUnsupportedLocation = Internal + 960;
 	/** @since 3.9 BETA_JAVA8 */
-	int NullityMismatchTypeArgument = Internal + 961;
+	int NullAnnotationUnsupportedLocationAtType = Internal + 961;
 	/** @since 3.9 BETA_JAVA8 */
-	int ContradictoryNullAnnotationsOnBound = Internal + 962;
+	int NullityMismatchTypeArgument = Internal + 962;
+	/** @since 3.9 BETA_JAVA8 */
+	int ContradictoryNullAnnotationsOnBound = Internal + 963;
+	/** @since 3.9 BETA_JAVA8 */
+	int UnsafeNullnessCast = Internal + 964;
 
 	// Java 8 work
 	/** @since 3.9 BETA_JAVA8 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index e0b6548..45ed0b5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -22,6 +22,7 @@
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *							bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+ *							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *							bug 378674 - "The method can be declared as static" is wrong
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -302,6 +303,7 @@ public TypeBinding resolveType(BlockScope scope) {
 		this.resolvedType = scope.enclosingReceiverType();
 	} else {
 		this.resolvedType = this.type.resolveType(scope, true /* check bounds*/);
+		this.resolvedType = checkIllegalNullAnnotation(scope, this.resolvedType);
 		checkParameterizedAllocation: {
 			if (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()
 				ReferenceBinding currentType = (ReferenceBinding)this.resolvedType;
@@ -464,6 +466,23 @@ public TypeBinding resolveType(BlockScope scope) {
 	return allocationType;
 }
 
+/**
+ * Check if 'allocationType' illegally has a top-level null annotation.
+ * If so: report an error and return the unannotated variant.
+ */
+TypeBinding checkIllegalNullAnnotation(BlockScope scope, TypeBinding allocationType) {
+	if (allocationType != null) {
+		// only check top-level null annotation (annots on details are OK):
+		long nullTagBits = allocationType.tagBits & TagBits.AnnotationNullMASK;
+		if (nullTagBits != 0) {
+			Annotation annotation = this.type.findAnnotation(nullTagBits);
+			scope.problemReporter().nullAnnotationUnsupportedLocation(annotation);
+			return allocationType.unannotated();
+		}
+	}
+	return allocationType;
+}
+
 public TypeBinding[] inferElidedTypes(ReferenceBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope) {
 	/* Given the allocation type and the arguments to the constructor, see if we can synthesize a generic static factory
 	   method that would, given the argument types and the invocation site, manufacture a parameterized object of type allocationType.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
index cb344d2..40e8289 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
@@ -19,6 +19,7 @@
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 401017 - [compiler][null] casted reference to @Nullable field lacks a warning
  *								bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 415541 - [1.8][compiler] Type annotations in the body of static initializer get dropped
  *******************************************************************************/
@@ -75,7 +76,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
  * Complain if assigned expression is cast, but not actually used as such, e.g. Object o = (List) object;
  */
 public static void checkNeedForAssignedCast(BlockScope scope, TypeBinding expectedType, CastExpression rhs) {
-	if (scope.compilerOptions().getSeverity(CompilerOptions.UnnecessaryTypeCheck) == ProblemSeverities.Ignore) return;
+	CompilerOptions compilerOptions = scope.compilerOptions();
+	if (compilerOptions.getSeverity(CompilerOptions.UnnecessaryTypeCheck) == ProblemSeverities.Ignore) return;
 
 	TypeBinding castedExpressionType = rhs.expression.resolvedType;
 	//	int i = (byte) n; // cast still had side effect
@@ -83,6 +85,11 @@ public static void checkNeedForAssignedCast(BlockScope scope, TypeBinding expect
 	if (castedExpressionType == null || rhs.resolvedType.isBaseType()) return;
 	//if (castedExpressionType.id == T_null) return; // tolerate null expression cast
 	if (castedExpressionType.isCompatibleWith(expectedType, scope)) {
+		if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
+			// are null annotations compatible, too?
+			if (findNullTypeAnnotationMismatch(expectedType, castedExpressionType, -1) > 0)
+				return; // already reported unchecked cast (nullness), say no more.
+		}
 		scope.problemReporter().unnecessaryCast(rhs);
 	}
 }
@@ -527,17 +534,28 @@ public TypeBinding resolveType(BlockScope scope) {
 	}
 	if (castType != null) {
 		if (expressionType != null) {
-			boolean isLegal = checkCastTypesCompatibility(scope, castType, expressionType, this.expression);
+
+			// internally for type checking use the unannotated types:
+			TypeBinding unannotatedCastType = castType.unannotated();
+			int nullityMismatch = findNullTypeAnnotationMismatch(castType, expressionType, -1);
+			if (nullityMismatch > 0)
+				castType = unannotatedCastType; // problem exists, so use the unannotated type also externally
+			expressionType = expressionType.unannotated();
+
+			boolean isLegal = checkCastTypesCompatibility(scope, unannotatedCastType, expressionType, this.expression);
 			if (isLegal) {
-				this.expression.computeConversion(scope, castType, expressionType);
+				this.expression.computeConversion(scope, unannotatedCastType, expressionType);
 				if ((this.bits & ASTNode.UnsafeCast) != 0) { // unsafe cast
 					if (scope.compilerOptions().reportUnavoidableGenericTypeProblems
 							|| !(expressionType.isRawType() && this.expression.forcedToBeRaw(scope.referenceContext()))) {
 						scope.problemReporter().unsafeCast(this, scope);
 					}
+				} else if (nullityMismatch > 0) {
+					// report null annotation issue at medium priority
+					scope.problemReporter().unsafeNullnessCast(this, scope);
 				} else {
-					if (castType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){
-						scope.problemReporter().rawTypeReference(this.type, castType);
+					if (unannotatedCastType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){
+						scope.problemReporter().rawTypeReference(this.type, unannotatedCastType);
 					}
 					if ((this.bits & (ASTNode.UnnecessaryCast|ASTNode.DisableUnnecessaryCastCheck)) == ASTNode.UnnecessaryCast) { // unnecessary cast
 						if (!isIndirectlyUsed()) // used for generic type inference or boxing ?
@@ -545,8 +563,8 @@ public TypeBinding resolveType(BlockScope scope) {
 					}
 				}
 			} else { // illegal cast
-				if ((castType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error
-					scope.problemReporter().typeCastError(this, castType, expressionType);
+				if ((unannotatedCastType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error
+					scope.problemReporter().typeCastError(this, unannotatedCastType, expressionType);
 				}
 				this.bits |= ASTNode.DisableUnnecessaryCastCheck; // disable further secondary diagnosis
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
index a7e9e20..9b9f90b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
@@ -13,6 +13,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -88,6 +89,10 @@ public TypeBinding resolveType(BlockScope scope) {
 	this.constant = Constant.NotAConstant;
 	TypeBinding expressionType = this.expression.resolveType(scope);
 	TypeBinding checkedType = this.type.resolveType(scope, true /* check bounds*/);
+	if (expressionType != null && checkedType != null && findNullTypeAnnotationMismatch(checkedType, expressionType, -1) > 0) {
+		scope.problemReporter().nullAnnotationUnsupportedLocation(this.type);
+		checkedType = checkedType.unannotated();
+	}
 	if (expressionType == null || checkedType == null)
 		return null;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 9f67155..f6f84cf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -22,6 +22,7 @@
  *								bug 395977 - [compiler][resource] Resource leak warning behavior possibly incorrect for anonymous inner class
  *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
@@ -325,6 +326,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				hasError = true;
 			} else {
 				receiverType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingInstanceType);
+				receiverType = checkIllegalNullAnnotation(scope, receiverType);
 				if (receiverType != null && enclosingInstanceContainsCast) {
 					CastExpression.checkNeedForEnclosingInstanceCast(scope, this.enclosingInstance, enclosingInstanceType, receiverType);
 				}
@@ -335,6 +337,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				receiverType = scope.enclosingSourceType();
 			} else {
 				receiverType = this.type.resolveType(scope, true /* check bounds*/);
+				receiverType = checkIllegalNullAnnotation(scope, receiverType);
 				checkParameterizedAllocation: {
 					if (receiverType == null || !receiverType.isValidBinding()) break checkParameterizedAllocation;
 					if (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleTypeReference.java
index cd6fb0c..7bd756d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleTypeReference.java
@@ -11,6 +11,8 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -84,10 +86,11 @@ public class SingleTypeReference extends TypeReference {
 	}
 
 	public TypeBinding resolveTypeEnclosing(BlockScope scope, ReferenceBinding enclosingType) {
-		TypeBinding memberType = this.resolvedType = scope.getMemberType(this.token, enclosingType);
+		this.resolvedType = scope.getMemberType(this.token, enclosingType);
 		boolean hasError = false;
 		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391500
 		resolveAnnotations(scope);
+		TypeBinding memberType = this.resolvedType; // load after possible update in resolveAnnotations()
 		if (!memberType.isValidBinding()) {
 			hasError = true;
 			scope.problemReporter().invalidEnclosingType(this, memberType, enclosingType);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index 552bfb5..bbfe46f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -25,6 +25,7 @@
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
  *								Bug 415291 - [1.8][null] differentiate type incompatibilities due to null annotations
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *                          Bug 409250 - [1.8][compiler] Various loose ends in 308 code generation
@@ -179,7 +180,7 @@ protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, Flow
 }
 // return: severity: 0 = no problem; 1 = unchecked conversion wrt type detail; 2 = conflicting annotations
 // nullStatus: we are only interested in NULL or NON_NULL, -1 indicates that we are in a recursion, where flow info is ignored
-protected int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {
+protected static int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {
 	int severity = 0;
 	if (requiredType instanceof ArrayBinding) {
 		long[] requiredDimsTagBits = ((ArrayBinding)requiredType).nullTagBitsPerDimension;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 1ab24d3..0aea7d5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -43,6 +43,7 @@
  *								Bug 415291 - [1.8][null] differentiate type incompatibilities due to null annotations
  *								Bug 415850 - [1.8] Ensure RunJDTCoreTests can cope with null annotations enabled
  *								Bug 414380 - [compiler][internal] QualifiedNameReference#indexOfFirstFieldBinding does not point to the first field
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
@@ -390,6 +391,7 @@ public static int getIrritant(int problemID) {
 		case IProblem.NullityUncheckedTypeAnnotationDetail:
 		case IProblem.ReferenceExpressionParameterRequiredNonnullUnchecked:
 		case IProblem.ReferenceExpressionReturnNullRedefUnchecked:
+		case IProblem.UnsafeNullnessCast:
 			return CompilerOptions.NullUncheckedConversion;
 		case IProblem.RedundantNullAnnotation:
 		case IProblem.RedundantNullDefaultAnnotation:
@@ -5629,6 +5631,26 @@ public void nullAnnotationUnsupportedLocation(Annotation annotation) {
 	handle(IProblem.NullAnnotationUnsupportedLocation,
 		arguments, shortArguments, annotation.sourceStart, annotation.sourceEnd);
 }
+public void nullAnnotationUnsupportedLocation(TypeReference type) {
+	int sourceEnd = type.sourceEnd;
+	if (type instanceof ParameterizedSingleTypeReference) {
+		ParameterizedSingleTypeReference typeReference = (ParameterizedSingleTypeReference) type;
+		TypeReference[] typeArguments = typeReference.typeArguments;
+		if (typeArguments[typeArguments.length - 1].sourceEnd > typeReference.sourceEnd) {
+			sourceEnd = retrieveClosingAngleBracketPosition(typeReference.sourceEnd);
+		} else {
+			sourceEnd = type.sourceEnd;
+		}
+	} else if (type instanceof ParameterizedQualifiedTypeReference) {
+		ParameterizedQualifiedTypeReference typeReference = (ParameterizedQualifiedTypeReference) type;
+		sourceEnd = retrieveClosingAngleBracketPosition(typeReference.sourceEnd);
+	} else {
+		sourceEnd = type.sourceEnd;
+	}
+
+	handle(IProblem.NullAnnotationUnsupportedLocationAtType,
+		NoArgument, NoArgument, type.sourceStart, sourceEnd);
+}
 public void localVariableNullInstanceof(LocalVariableBinding local, ASTNode location) {
 	int severity = computeSeverity(IProblem.NullLocalVariableInstanceofYieldsFalse);
 	if (severity == ProblemSeverities.Ignore) return;
@@ -8022,6 +8044,22 @@ public void unsafeCast(CastExpression castExpression, Scope scope) {
 		castExpression.sourceStart,
 		castExpression.sourceEnd);
 }
+public void unsafeNullnessCast(CastExpression castExpression, Scope scope) {
+	TypeBinding castedExpressionType = castExpression.expression.resolvedType;
+	TypeBinding castExpressionResolvedType = castExpression.resolvedType;
+	this.handle(
+		IProblem.UnsafeNullnessCast,
+		new String[]{
+			new String(castedExpressionType.nullAnnotatedReadableName(this.options, false)),
+			new String(castExpressionResolvedType.nullAnnotatedReadableName(this.options, false))
+		},
+		new String[]{
+			new String(castedExpressionType.nullAnnotatedReadableName(this.options, true)),
+			new String(castExpressionResolvedType.nullAnnotatedReadableName(this.options, true))
+		},
+		castExpression.sourceStart,
+		castExpression.sourceEnd);
+}
 public void unsafeGenericArrayForVarargs(TypeBinding leafComponentType, ASTNode location) {
 	int severity = computeSeverity(IProblem.UnsafeGenericArrayForVarargs);
 	if (severity == ProblemSeverities.Ignore) return;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 5e504b5..21a55f6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -34,6 +34,7 @@
 #							bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
 #							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
 #							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
+#							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
 #		Jesper S Moller <jesper@selskabet.org> - Contributions for
 #							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
 #							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
@@ -786,8 +787,10 @@
 958 = Null type safety at method return type: Method descriptor {0} promises ''@{1} {2}'' but referenced method provides ''{3}{4}''
 959 = Redundant null check: comparing ''{0}'' against null
 960 = The nullness annotation ''{0}'' is not applicable at this location
-961 = Null constraint mismatch: The type ''{2}'' is not a valid substitute for the type parameter ''{0}'' which is constrained as ''@{1}''
-962 = This nullness annotation conflicts with a ''@{0}'' annotation which is effective on the same type parameter 
+961 = Nullness annotations are not applicable at this location 
+962 = Null constraint mismatch: The type ''{2}'' is not a valid substitute for the type parameter ''{0}'' which is constrained as ''@{1}''
+963 = This nullness annotation conflicts with a ''@{0}'' annotation which is effective on the same type parameter 
+964 = Null type safety: Unchecked cast from {0} to {1}
 
 # Java 8
 1001 = Syntax error, modifiers and annotations are not allowed for the lambda parameter {0} as its type is elided
commit cefc7f3f8677282aa49e610700500999ffcaffcb
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Feb 23 21:14:45 2014 +0100

    Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type
    annotations

128	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
5	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index cd44512..4f93557 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -767,8 +767,8 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	}
 	
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=403216#c9 
-	public void testBug403216_3() {
-		runConformTestWithLibs(
+	public void testBug403216_3a() {
+		runNegativeTestWithLibs(
 			new String[] {
 				"Test.java",
 				"import java.lang.annotation.ElementType;\n" + 
@@ -786,6 +786,33 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"@interface A {}\n"
 			},
 			getCompilerOptions(),
+			"----------\n" + 
+			"1. ERROR in Test.java (at line 9)\n" + 
+			"	public void foo( @A X. @NonNull Y this) {}\n" + 
+			"	                 ^^^^^^^^^^^^^^^^\n" + 
+			"Nullness annotations are not applicable at this location \n" + 
+			"----------\n");
+	}
+
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=403216#c9 
+	public void testBug403216_3b() {
+		runConformTestWithLibs(
+			new String[] {
+				"Test.java",
+				"import java.lang.annotation.ElementType;\n" + 
+				"import java.lang.annotation.Target;\n" +
+				"\n" + 
+				"public class Test {}\n" + 
+				"\n" + 
+				"class X {\n" + 
+				"	class Y {\n" + 
+				"		public void foo( @A X. @A Y this) {}\n" + 
+				"	}\n" + 
+				"}\n" + 
+				"@Target(value={ElementType.TYPE_USE})\n" + 
+				"@interface A {}\n"
+			},
+			getCompilerOptions(),
 			"");
 	}
 
@@ -2138,7 +2165,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n");
 	}
 
-	// illegal for cast & instanceof with scalar type
+	// illegal / unchecked for cast & instanceof with scalar type
 	public void testUnsupportedLocation03() {
 		runNegativeTestWithLibs(
 			new String[] {
@@ -2170,7 +2197,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n");
 	}
 
-	// illegal for cast & instanceof with complex type
+	// illegal / unchecked for cast & instanceof with complex type
 	public void testUnsupportedLocation04() {
 		runNegativeTestWithLibs(
 			new String[] {
@@ -2235,6 +2262,27 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n");
 	}
 
+	// illegal instanceof check with annotated type argument
+	public void testUnsupportedLocation04a() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"import java.util.*;\n" +
+				"public class X {\n" +
+				"	boolean instanceOf2(Object o) {\n" + 
+				"		return o instanceof List<@Nullable ?>;\n" + 
+				"	}\n" + 
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 5)\n" + 
+			"	return o instanceof List<@Nullable ?>;\n" + 
+			"	                    ^^^^^^^^^^^^^^^^^\n" + 
+			"Nullness annotations are not applicable at this location \n" + 
+			"----------\n");
+	}
+
 	// illegal for allocation expression
 	public void testUnsupportedLocation05() {
 		runNegativeTestWithLibs(
@@ -2261,6 +2309,82 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n");
 	}
 
+	// method receiver
+	public void testUnsupportedLocation06() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public class X {\n" +
+				"	void receiver(@Nullable X this, Object o) {}\n" + 
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	void receiver(@Nullable X this, Object o) {}\n" + 
+			"	              ^^^^^^^^^^^\n" + 
+			"Nullness annotations are not applicable at this location \n" + 
+			"----------\n");
+	}
+
+	// receiver type in method/constructor reference
+	public void testUnsupportedLocation07() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"import java.util.function.Supplier;\n" +
+				"public class X {\n" +
+				"	void consume(Supplier<Object> c) {}\n" + 
+				"	static Object supply() { return null; }\n" + 
+				"	void consumeSupplied() {\n" + 
+				"		consume(@NonNull X::supply);\n" + 
+				"		consume(@NonNull X::new);\n" + 
+				"	}\n" + 
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 7)\n" + 
+			"	consume(@NonNull X::supply);\n" + 
+			"	        ^^^^^^^^^^\n" + 
+			"Nullness annotations are not applicable at this location \n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 8)\n" + 
+			"	consume(@NonNull X::new);\n" + 
+			"	        ^^^^^^^^^^\n" + 
+			"Nullness annotations are not applicable at this location \n" + 
+			"----------\n");
+	}
+
+	// exceptions (throws & catch)
+	public void testUnsupportedLocation08() {
+		runNegativeTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"import java.io.*;\n" +
+				"public class X {\n" +
+				"	void throwsDecl() throws @Nullable IOException {}\n" + 
+				"	void excParam() {\n" + 
+				"		try {\n" + 
+				"			throwsDecl();\n" + 
+				"		} catch (@NonNull IOException ioe) {}\n" + 
+				"	}\n" + 
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 4)\n" + 
+			"	void throwsDecl() throws @Nullable IOException {}\n" + 
+			"	                         ^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Nullness annotations are not applicable at this location \n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 8)\n" + 
+			"	} catch (@NonNull IOException ioe) {}\n" + 
+			"	                  ^^^^^^^^^^^\n" + 
+			"Nullness annotations are not applicable at this location \n" + 
+			"----------\n");
+	}
+
 	public void testForeach() {
 		runNegativeTestWithLibs(
 			new String[] {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index 25326f7..186893e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -24,6 +24,7 @@
  *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *								Bug 403216 - [1.8][null] TypeReference#captureTypeAnnotations treats type annotations as type argument annotations
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -587,6 +588,10 @@ public abstract class AbstractMethodDeclaration
 		if (TypeBinding.notEquals(enclosingReceiver, resolvedReceiverType)) {
 			this.scope.problemReporter().illegalTypeForExplicitThis(this.receiver, enclosingReceiver);
 		}
+
+		if (resolvedReceiverType.hasNullTypeAnnotations()) {
+			this.scope.problemReporter().nullAnnotationUnsupportedLocation(this.receiver.type);
+		}
 	}
 	public void resolveJavadoc() {
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
index b46a2c4..e5567a4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
@@ -15,6 +15,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 409246 - [1.8][compiler] Type annotations on catch parameters not handled properly
  *******************************************************************************/
@@ -199,6 +200,9 @@ public class Argument extends LocalDeclaration {
 		}
 		resolveAnnotations(scope, this.annotations, this.binding, true);
 		Annotation.isTypeUseCompatible(this.type, scope, this.annotations);
+		if (this.type.resolvedType != null && this.type.resolvedType.hasNullTypeAnnotations()) {
+			scope.problemReporter().nullAnnotationUnsupportedLocation(this.type);
+		}
 
 		scope.addLocalVariable(this.binding);
 		this.binding.setConstant(Constant.NotAConstant);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
index 5f84c19..405e53f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
@@ -17,6 +17,7 @@
  *								Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -92,8 +93,10 @@ public TypeBinding resolveType(BlockScope scope) {
 	this.constant = Constant.NotAConstant;
 	TypeBinding expressionType = this.expression.resolveType(scope);
 	TypeBinding checkedType = this.type.resolveType(scope, true /* check bounds*/);
-	if (expressionType != null && checkedType != null && NullAnnotationMatching.analyse(checkedType, expressionType, -1).isAnyMismatch()) {
-		scope.problemReporter().nullAnnotationUnsupportedLocation(this.type);
+	if (expressionType != null && checkedType != null && checkedType.hasNullTypeAnnotations()) {
+		// don't complain if the entire operation is redundant anyway
+		if (!expressionType.isCompatibleWith(checkedType) || NullAnnotationMatching.analyse(checkedType, expressionType, -1).isAnyMismatch())
+			scope.problemReporter().nullAnnotationUnsupportedLocation(this.type);
 	}
 	if (expressionType == null || checkedType == null)
 		return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index de28ffa..d1c6a56 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -28,6 +28,7 @@
  *							Bug 427196 - [1.8][compiler] Compiler error for method reference to overloaded method
  *							Bug 427438 - [1.8][compiler] NPE at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:280)
  *							Bug 428264 - [1.8] method reference of generic class causes problems (wrong inference result or NPE)
+ *							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contribution for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -388,6 +389,10 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 			return this.resolvedType = null;
 		}
 		
+		if (this.lhs instanceof TypeReference && lhsType.hasNullTypeAnnotations()) {
+			scope.problemReporter().nullAnnotationUnsupportedLocation((TypeReference) this.lhs);
+		}
+
 		/* 15.28: "It is a compile-time error if a method reference of the form super :: NonWildTypeArgumentsopt Identifier or of the form 
 		   TypeName . super :: NonWildTypeArgumentsopt Identifier occurs in a static context.": This is nop since the primary when it resolves
 		   itself will complain automatically.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index fb6b282..83be251 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -33,6 +33,7 @@
  *								Bug 416172 - [1.8][compiler][null] null type annotation not evaluated on method return type
  *								Bug 417295 - [1.8[[null] Massage type annotated null analysis to gel well with deep encoded type bindings.
  *								Bug 426048 - [1.8] NPE in TypeVariableBinding.internalBoundCheck when parentheses are not balanced
+ *								Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
  *      Till Brychcy - Contributions for
@@ -1815,6 +1816,9 @@ public MethodBinding resolveTypesFor(MethodBinding method) {
 			if ((resolvedExceptionType.tagBits & TagBits.HasMissingType) != 0) {
 				method.tagBits |= TagBits.HasMissingType;
 			}
+			if (resolvedExceptionType.hasNullTypeAnnotations()) {
+				methodDecl.scope.problemReporter().nullAnnotationUnsupportedLocation(exceptionTypes[i]);
+			}
 			method.modifiers |= (resolvedExceptionType.modifiers & ExtraCompilerModifiers.AccGenericSignature);
 			method.thrownExceptions[count++] = resolvedExceptionType;
 		}
