commit dddbe243237309d1e5555ecd08561ad359b38809
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Mar 10 21:57:16 2016 +0100

    Bug 461268: [1.8][null] Invent a warning that protects against
    interpreting legacy return as @NonNull
    
    Change-Id: I10bb742b863b325d6b26f7a1ea6bb93d12e98fd2
    
    Change-Id: I4a4eb54646e9f035a46cacefbc96c89d63219dcf
    Also-by: Till Brychcy <register.eclipse@brychcy.de>

1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
4	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
5	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
179	18	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
138	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
109	53	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
9	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
14	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
52	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
53	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemSeverities.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
6	1	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
24	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
5	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
6	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
index 3a0a49a..189ebcd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractNullAnnotationTest.java
@@ -100,6 +100,7 @@ public abstract class AbstractNullAnnotationTest extends AbstractComparableTest
 			defaultOptions.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
 
 			defaultOptions.put(CompilerOptions.OPTION_PessimisticNullAnalysisForFreeTypeVariables, JavaCore.ERROR);
+			defaultOptions.put(CompilerOptions.OPTION_ReportNonNullTypeVariableFromLegacyInvocation, JavaCore.WARNING);
 			
 			// leave other new options at these defaults:
 //			defaultOptions.put(CompilerOptions.OPTION_ReportNullContractViolation, JavaCore.ERROR);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index a57d363..dfb1b92 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -2030,6 +2030,7 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral\" value=\"ignore\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped\" value=\"warning\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonnullTypeVariableFromLegacyInvocation\" value=\"warning\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict\" value=\"error\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullReference\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullSpecViolation\" value=\"error\"/>\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 6c58193..325dbb7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -837,6 +837,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NonNullMessageSendComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonNullSpecdFieldComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullTypeVariableFromLegacyMethod", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullMethodTypeVariableFromLegacyMethod", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -1668,6 +1670,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NonNullSpecdFieldComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("NonNullMessageSendComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("NonNullTypeVariableFromLegacyMethod", new ProblemAttributes(JavaCore.COMPILER_PB_NONNULL_TYPEVAR_FROM_LEGACY_INVOCATION));
+		expectedProblemAttributes.put("NonNullMethodTypeVariableFromLegacyMethod", new ProblemAttributes(JavaCore.COMPILER_PB_NONNULL_TYPEVAR_FROM_LEGACY_INVOCATION));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 74a17c9..f26dc8b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -8114,7 +8114,11 @@ public void testBug462790() {
 		"Null type safety: The expression of type \'T\' needs unchecked conversion to conform to \'@NonNull T\'\n" + 
 		"----------\n"
 		:
-		""));
+		"3. WARNING in EclipseBug.java (at line 10)\n" + 
+		"	return commandType.newInstance();\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Unsafe interpretation of method return type as \'@NonNull\' based on the receiver type \'@NonNull Class<T extends @NonNull String>\'. Type \'Class<T>\' doesn\'t seem to be designed with null type annotations in mind\n" + 
+		"----------\n"));
 }
 public void testBug459967_Enum_valueOf() {
 	runConformTestWithLibs(
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 01176fb..10dcdb7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -177,9 +177,16 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				  "@Target({METHOD,PARAMETER,LOCAL_VARIABLE,TYPE_USE})\n" +
 				  "public @interface Dummy {\n" +
 				  "}\n",
+				"p/List.java",
+				  "package p;\n" +
+				  "public interface List<T> {\n" +
+				  "	T get(int i);\n" + // avoid IProblem.NonNullTypeVariableFromLegacyMethod against unannotated j.u.List
+				  " void add(T e);\n" +
+				  " void add(int i, T e);\n" +
+				  "}\n",
 				"X.java",
 				  "import org.eclipse.jdt.annotation.*;\n" +
-				  "import java.util.List;\n" +
+				  "import p.List;\n" +
 				  "public class X {\n" +
 				  "    void foo(@Nullable List<@NonNull Object> l) {\n" +
 				  "        System.out.print(l.get(0).toString()); // problem: l may be null\n" +
@@ -189,7 +196,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				  "        System.out.print(l.get(0).toString()); // problem: l may be null\n" +
 				  "        l.add(0, null); // problem: cannot insert 'null' into this list\n" +
 				  "    }\n" +
-				  "    void bar2(@Dummy java.util.@Nullable List<java.lang.@NonNull Object> l2) {\n" +
+				  "    void bar2(@Dummy p.@Nullable List<java.lang.@NonNull Object> l2) {\n" +
 				  "        System.out.print(l2.get(0).toString()); // problem: l2 may be null\n" +
 				  "        l2.add(0, null); // problem: cannot insert 'null' into this list\n" +
 				  "    }\n" +
@@ -1313,9 +1320,16 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 		customOptions.put(JavaCore.COMPILER_PB_MISSING_SERIAL_VERSION, JavaCore.IGNORE);
 		runConformTestWithLibs(
 				new String[] {
+					"p/List.java",
+					"package p;\n" +
+					"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+					"public interface List<T> {\n" +
+					"	T get(int i);\n" + // avoid IProblem.NonNullTypeVariableFromLegacyMethod against unannotated j.u.List
+					"}\n",
 					"p/X1.java",
 					"package p;\n" +
-					"import java.util.*;\n" +
+					"import java.util.Map;\n" +
+					"import p.List;\n" +
 					"import org.eclipse.jdt.annotation.*;\n" +
 					"import static java.lang.annotation.ElementType.*;\n" +
 					"import java.lang.annotation.*;\n" +
@@ -2443,6 +2457,8 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 	
 	// poly-null method
 	public void testNullTypeInference1() {
+		Map compilerOptions = getCompilerOptions();
+		compilerOptions.put(CompilerOptions.OPTION_ReportNonNullTypeVariableFromLegacyInvocation, CompilerOptions.IGNORE);
 		runNegativeTestWithLibs(
 			new String[] {
 				"X.java",
@@ -2464,7 +2480,7 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 				"	}\n" +
 				"}\n"
 			},
-			getCompilerOptions(),
+			compilerOptions,
 			"----------\n" + 
 			"1. ERROR in X.java (at line 9)\n" + 
 			"	return polyNullMethod(strings).get(0);\n" + 
@@ -3083,6 +3099,11 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"	ls.add(null);\n" + 
 			"	       ^^^^\n" + 
 			"Null type mismatch: required \'@NonNull ? extends @NonNull String\' but the provided value is null\n" + 
+			"----------\n" + 
+			"3. WARNING in X.java (at line 10)\n" + 
+			"	@NonNull String s = ls.get(0);\n" + 
+			"	                    ^^^^^^^^^\n" + 
+			"Unsafe interpretation of method return type as \'@NonNull\' based on the receiver type \'List<@NonNull capture#of ? extends @NonNull String>\'. Type \'List<E>\' doesn\'t seem to be designed with null type annotations in mind\n" + 
 			"----------\n");
 	}
 
@@ -3405,12 +3426,17 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			},
 			getCompilerOptions(),
 			"----------\n" + 
-			"1. WARNING in X.java (at line 10)\n" + 
+			"1. WARNING in X.java (at line 6)\n" + 
+			"	return l.get(0);\n" + 
+			"	       ^^^^^^^^\n" + 
+			"Unsafe interpretation of method return type as \'@NonNull\' based on the receiver type \'@NonNull List<@NonNull T>\'. Type \'List<E>\' doesn\'t seem to be designed with null type annotations in mind\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 10)\n" + 
 			"	s.foo(new ArrayList<String>()); // (1)\n" + 
 			"	      ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
 			"Null type safety (type annotations): The expression of type \'ArrayList<String>\' needs unchecked conversion to conform to \'@NonNull List<@NonNull String>\', corresponding supertype is 'List<String>'\n" + 
 			"----------\n" + 
-			"2. ERROR in X.java (at line 11)\n" + 
+			"3. ERROR in X.java (at line 11)\n" + 
 			"	s.foo(null); // (2)\n" + 
 			"	      ^^^^\n" + 
 			"Null type mismatch: required \'@NonNull List<@NonNull String>\' but the provided value is null\n" + 
@@ -4409,27 +4435,32 @@ public void testTypeBounds1() {
 		"	        ^^^^\n" + 
 		"Null type mismatch: required \'? extends @NonNull A\' but the provided value is null\n" + 
 		"----------\n" + 
-		"2. ERROR in C.java (at line 15)\n" + 
+		"2. WARNING in C.java (at line 14)\n" + 
+		"	return la1.get(0); // OK\n" + 
+		"	       ^^^^^^^^^^\n" + 
+		"Unsafe interpretation of method return type as \'@NonNull\' based on the receiver type \'List<capture#of ? extends @NonNull A>\'. Type \'List<E>\' doesn\'t seem to be designed with null type annotations in mind\n" + 
+		"----------\n" + 
+		"3. ERROR in C.java (at line 15)\n" + 
 		"	la1 = lb2; // ERR2\n" + 
 		"	      ^^^\n" + 
 		"Null type mismatch (type annotations): required \'List<? extends @NonNull A>\' but this expression has type \'List<@Nullable B>\'\n" + 
 		"----------\n" + 
-		"3. ERROR in C.java (at line 17)\n" + 
+		"4. ERROR in C.java (at line 17)\n" + 
 		"	la2.add(null); // ERR3\n" + 
 		"	        ^^^^\n" + 
 		"Null type mismatch: required \'? extends @Nullable A\' but the provided value is null\n" + 
 		"----------\n" + 
-		"4. ERROR in C.java (at line 19)\n" + 
+		"5. ERROR in C.java (at line 19)\n" + 
 		"	return la2.get(0); // ERR4\n" + 
 		"	       ^^^^^^^^^^\n" + 
 		"Null type mismatch (type annotations): required \'@NonNull A\' but this expression has type \'capture#of ? extends @Nullable A\'\n" + 
 		"----------\n" + 
-		"5. ERROR in C.java (at line 25)\n" + 
+		"6. ERROR in C.java (at line 25)\n" + 
 		"	<T extends @Nullable A> T mExtends1(List<T> t) { return null; /*ERR5*/ }\n" + 
 		"	                                                        ^^^^\n" + 
 		"Null type mismatch: required \'T extends @Nullable A\' but the provided value is null\n" + 
 		"----------\n" + 
-		"6. ERROR in C.java (at line 26)\n" + 
+		"7. ERROR in C.java (at line 26)\n" + 
 		"	<T extends @NonNull A> T mExtends2(List<T> t) { return null; /*ERR6*/ }\n" + 
 		"	                                                       ^^^^\n" + 
 		"Null type mismatch: required \'T extends @NonNull A\' but the provided value is null\n" + 
@@ -4952,17 +4983,22 @@ public void testDefault07() {
 		},
 		getCompilerOptions(),
 		"----------\n" + 
-		"1. ERROR in X.java (at line 9)\n" + 
+		"1. WARNING in X.java (at line 8)\n" + 
+		"	@NonNull Number n = l.get(0); // OK\n" + 
+		"	                    ^^^^^^^^\n" + 
+		"Unsafe interpretation of method return type as \'@NonNull\' based on the receiver type \'List<capture#of ? extends @NonNull Number>\'. Type \'List<E>\' doesn\'t seem to be designed with null type annotations in mind\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 9)\n" + 
 		"	return null; // ERR\n" + 
 		"	       ^^^^\n" + 
 		"Null type mismatch: required \'T extends @NonNull Number\' but the provided value is null\n" + 
 		"----------\n" + 
-		"2. WARNING in X.java (at line 13)\n" + 
+		"3. WARNING in X.java (at line 13)\n" + 
 		"	@NonNull Number nnn = inner.process(Integer.valueOf(3), new ArrayList<@Nullable Integer>()); // WARN on 1. arg; ERR on 2. arg\n" + 
 		"	                                    ^^^^^^^^^^^^^^^^^^\n" + 
 		"Null type safety (type annotations): The expression of type \'Integer\' needs unchecked conversion to conform to \'@NonNull Integer\'\n" + 
 		"----------\n" + 
-		"3. ERROR in X.java (at line 13)\n" + 
+		"4. ERROR in X.java (at line 13)\n" + 
 		"	@NonNull Number nnn = inner.process(Integer.valueOf(3), new ArrayList<@Nullable Integer>()); // WARN on 1. arg; ERR on 2. arg\n" + 
 		"	                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
 		"Null type mismatch (type annotations): required \'List<? extends @NonNull Number>\' but this expression has type \'ArrayList<@Nullable Integer>\', corresponding supertype is \'List<@Nullable Integer>\'\n" + 
@@ -5976,6 +6012,8 @@ public void testTypeVariable18raw() {
 }
 // top-level annotation is overridden at use-site, details remain - parameterized type
 public void testTypeVariable19() {
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportNonNullTypeVariableFromLegacyInvocation, CompilerOptions.IGNORE);
 	runNegativeTestWithLibs(
 		new String[] {
 			"X.java",
@@ -6004,7 +6042,7 @@ public void testTypeVariable19() {
 			"	}\n" + 
 			"}\n"
 		},
-		getCompilerOptions(),
+		compilerOptions,
 		"----------\n" + 
 		"1. ERROR in X.java (at line 15)\n" + 
 		"	case 0 : return i1.get0().get(0).toUpperCase(); // problem at detail\n" + 
@@ -6672,7 +6710,17 @@ public void testBug441693other() {
 		},
 		getCompilerOptions(),
 		"----------\n" + 
-		"1. ERROR in Foo.java (at line 20)\n" + 
+		"1. WARNING in Foo.java (at line 17)\n" + 
+		"	return requireNonNull(foos).get(0);\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Unsafe interpretation of method return type as \'@NonNull\' based on the receiver type \'@NonNull List<capture#of ? extends @NonNull Foo>\'. Type \'List<E>\' doesn\'t seem to be designed with null type annotations in mind\n" + 
+		"----------\n" + 
+		"2. WARNING in Foo.java (at line 20)\n" + 
+		"	return requireNonNull(foos.get(0)).get(0);\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Unsafe interpretation of method return type as \'@NonNull\' based on the receiver type \'List<@NonNull Foo>\'. Type \'List<E>\' doesn\'t seem to be designed with null type annotations in mind\n" + 
+		"----------\n" + 
+		"3. ERROR in Foo.java (at line 20)\n" + 
 		"	return requireNonNull(foos.get(0)).get(0);\n" + 
 		"	                      ^^^^\n" + 
 		"Potential null pointer access: this expression has a \'@Nullable\' type\n" + 
@@ -8037,6 +8085,11 @@ public void testBug455180() {
     		"	@NonNull GenericType gt = cwru.method().get(0);\n" + 
     		"	         ^^^^^^^^^^^\n" + 
     		"GenericType is a raw type. References to generic type GenericType<T> should be parameterized\n" + 
+    		"----------\n" + 
+    		"2. WARNING in projB\\ClassThatImports.java (at line 7)\n" + 
+    		"	@NonNull GenericType gt = cwru.method().get(0);\n" + 
+    		"	                          ^^^^^^^^^^^^^^^^^^^^\n" + 
+    		"Unsafe interpretation of method return type as \'@NonNull\' based on the receiver type \'@NonNull List<@NonNull GenericType>\'. Type \'List<E>\' doesn\'t seem to be designed with null type annotations in mind\n" + 
     		"----------\n");
 }
 
@@ -8335,6 +8388,11 @@ public void testBug456584() {
 		"----------\n" + 
 		"1. WARNING in Test.java (at line 9)\n" + 
 		"	return Objects.requireNonNull(function.apply(input));\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Unsafe interpretation of method return type as \'@NonNull\' based on substitution \'T=@NonNull capture#of ? extends R\'. Declaring type \'Objects\' doesn\'t seem to be designed with null type annotations in mind\n" + 
+		"----------\n" + 
+		"2. WARNING in Test.java (at line 9)\n" + 
+		"	return Objects.requireNonNull(function.apply(input));\n" + 
 		"	                              ^^^^^^^^^^^^^^^^^^^^^\n" + 
 		"Null type safety: required \'@NonNull\' but this expression has type \'capture#2-of ? extends R\', a free type variable that may represent a \'@Nullable\' type\n" + 
 		"----------\n");
@@ -8951,6 +9009,8 @@ public void testBug481322a() {
 		"----------\n");
 }
 public void testBug477719() {
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportNonNullTypeVariableFromLegacyInvocation, CompilerOptions.IGNORE);
 	runConformTestWithLibs(
 		new String[] {
 			"X.java",
@@ -8965,7 +9025,7 @@ public void testBug477719() {
 			"	}\n" +
 			"}\n"
 		},
-		getCompilerOptions(),
+		compilerOptions,
 		"");
 }
 public void testBug482247() {
@@ -9584,9 +9644,14 @@ public void testBug484981d() {
 	customOptions.put(JavaCore.COMPILER_PB_MISSING_SERIAL_VERSION, JavaCore.IGNORE);
 	runNegativeTestWithLibs(
 			new String[] {
+				"p/List.java",
+				"package p;\n" +
+				"public interface List<T> {\n" +
+				"	T get(int i);\n" + // avoid IProblem.NonNullTypeVariableFromLegacyMethod against unannotated j.u.List
+				"}\n",
 				"p/X1.java",
 				"package p;\n" +
-				"import java.util.*;\n" +
+				"import java.util.Map;\n" +
 				"import org.eclipse.jdt.annotation.*;\n" +
 				"import static java.lang.annotation.ElementType.*;\n" +
 				"import java.lang.annotation.*;\n" +
@@ -11214,4 +11279,100 @@ public void testBug466556Loops() {
 		"----------\n"
 	);
 }
+public void testBug461268() {
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportNonNullTypeVariableFromLegacyInvocation, JavaCore.ERROR);
+	compilerOptions.put(CompilerOptions.OPTION_PessimisticNullAnalysisForFreeTypeVariables, JavaCore.IGNORE);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import java.util.List;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"	void test(List<@NonNull String> list) {\n" +
+			"		@NonNull String s = list.get(0);\n" +
+			"	}\n" +
+			"}\n"
+		},
+		compilerOptions,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	@NonNull String s = list.get(0);\n" + 
+		"	                    ^^^^^^^^^^^\n" + 
+		"Unsafe interpretation of method return type as \'@NonNull\' based on the receiver type \'List<@NonNull String>\'. Type \'List<E>\' doesn\'t seem to be designed with null type annotations in mind\n" + 
+		"----------\n");
+}
+public void testBug461268invoke() {
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportNonNullTypeVariableFromLegacyInvocation, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import java.util.Map;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"	void test(Map<Object, @NonNull String> map) {\n" +
+			"		map.get(this).length();\n" +
+			"	}\n" +
+			"}\n"
+		},
+		compilerOptions,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	map.get(this).length();\n" + 
+		"	^^^^^^^^^^^^^\n" + 
+		"Unsafe interpretation of method return type as \'@NonNull\' based on the receiver type \'Map<Object,@NonNull String>\'. Type \'Map<K,V>\' doesn\'t seem to be designed with null type annotations in mind\n" + 
+		"----------\n");
+}
+public void testBug461268nnbd() {
+	Map compilerOptions = getCompilerOptions();
+	compilerOptions.put(CompilerOptions.OPTION_ReportNonNullTypeVariableFromLegacyInvocation, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+			"test2/Container.java",
+			"package test2;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"\n" +
+			"@NonNullByDefault\n" +
+			"public class Container<T> {\n" +
+			"	public static <T> T getFrom(Container<T> container) {\n" +
+			"		return container.get();\n" +
+			"	}\n" +
+			"\n" +
+			"	private final T t;\n" +
+			"\n" +
+			"	public Container(T t) {\n" +
+			"		this.t = t;\n" +
+			"	}\n" +
+			"\n" +
+			"	private T get() {\n" + // we really mean 'T' unannotated, believe it due to @NonNullByDefault
+			"		return this.t;\n" +
+			"	}\n" +
+			"}\n",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+	runConformTestWithLibs(
+		new String[] {
+			"test/Test.java",
+			"package test;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"\n" +
+			"import test2.Container;\n" +
+			"\n" +
+			"@NonNullByDefault\n" +
+			"public class Test {\n" +
+			"	String f(Container<String> c) {\n" +
+			"		return Container.getFrom(c);\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
index 0b4fd05..defb870 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2014, 2015 GK Software AG, and others.
+ * Copyright (c) 2014, 2016 GK Software AG, and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -56,6 +56,7 @@ import org.eclipse.jdt.core.tests.util.AbstractCompilerTest;
 import org.eclipse.jdt.core.tests.util.Util;
 import org.eclipse.jdt.core.util.ExternalAnnotationUtil;
 import org.eclipse.jdt.core.util.ExternalAnnotationUtil.MergeStrategy;
+import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 import org.eclipse.jdt.internal.core.ClasspathAttribute;
 import org.osgi.framework.Bundle;
 
@@ -308,6 +309,43 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 		assertEquals("Number of problems", messages.length, nMatch);
 	}
 
+	protected void assertProblems(IProblem[] problems, String[] messages, int[] lines, int[] severities) throws CoreException {
+		int nMatch = 0;
+		for (int i = 0; i < problems.length; i++) {
+			for (int j = 0; j < messages.length; j++) {
+				if (messages[j] == null) continue;
+				if (problems[i].toString().equals(messages[j])
+						&& problems[i].getSourceLineNumber() == lines[j]) {
+					switch(severities[j] & ProblemSeverities.CoreSeverityMASK ) {
+					case ProblemSeverities.Error:
+						if (!problems[i].isError()) continue;
+						break;
+					case ProblemSeverities.Warning:
+						if (!problems[i].isWarning()) continue;
+						break;
+					case ProblemSeverities.Info:
+						if (!problems[i].isInfo()) continue;
+						break;
+					default:
+						throw new IllegalArgumentException("Bad severity expected: "+severities[j]);
+					}
+					messages[j] = null;
+					problems[i] = null;
+					nMatch++;
+					break;
+				}
+			}
+		}
+		for (int i = 0; i < problems.length; i++) {
+			if (problems[i] != null)
+				fail("Unexpected problem "+problems[i]+" at "+problems[i].getSourceLineNumber());
+		}
+		for (int i = 0; i < messages.length; i++) {
+			if (messages[i] != null)
+				System.err.println("Unmatched problem "+messages[i]);
+		}
+		assertEquals("Number of problems", messages.length, nMatch);
+	}
 	protected boolean hasJRE18() {
 		return ((AbstractCompilerTest.getPossibleComplianceLevels() & AbstractCompilerTest.F_1_8) != 0);
 	}
@@ -482,10 +520,11 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
 		IProblem[] problems = reconciled.getProblems();
 		assertProblems(problems, new String[] {
+				"Pb(980) Unsafe interpretation of method return type as '@NonNull' based on the receiver type 'Iterator<@NonNull capture#of ?>'. Type 'Iterator<E>' doesn't seem to be designed with null type annotations in mind",
 				"Pb(953) Null type mismatch (type annotations): required '@NonNull Object' but this expression has type '@Nullable capture#of ?'",
 				"Pb(953) Null type mismatch (type annotations): required '@NonNull CharSequence' but this expression has type '@Nullable capture#of ? extends CharSequence'",
 				"Pb(953) Null type mismatch (type annotations): required '@NonNull Object' but this expression has type '@Nullable capture#of ? super CharSequence'"
-			}, new int[] { 13, 16, 19 });
+			}, new int[] { 10, 13, 16, 19 });
 	}
 	
 	public void testLibsWithArrays() throws Exception {
@@ -1541,9 +1580,6 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 			IPackageFragment fragment = this.root.getPackageFragment("test1");
 			ICompilationUnit unit = fragment.getCompilationUnit("Reconcile3.java").getWorkingCopy(new NullProgressMonitor());
 			CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
-			for (IProblem iProblem : reconciled.getProblems()) {
-				System.out.println(iProblem);
-			}
 			assertProblems(reconciled.getProblems(), new String[] {
 					"Pb(964) Null constraint mismatch: The type '@Nullable B' is not a valid substitute for the type parameter '@NonNull R'",
 					"Pb(964) Null constraint mismatch: The type '@Nullable String' is not a valid substitute for the type parameter '@NonNull V'",
@@ -1552,4 +1588,101 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 			deleteProject("Lib");
 		}
 	}
+	
+	public void testFreeTypeVariableReturn() throws Exception {
+		myCreateJavaProject("TestLibs");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" + 
+				"public interface Lib1<T> {\n" + 
+				"	T get();\n" + 
+				"}\n"
+			}, null);
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	@NonNull String test0(Lib1<@Nullable String> lib) {\n" + 
+				"		return lib.get();\n" + 
+				"	}\n" + 
+				"	@NonNull String test1(Lib1<@NonNull String> lib) {\n" + 
+				"		return lib.get();\n" + 
+				"	}\n" + 
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		assertProblems(reconciled.getProblems(), new String[] {
+				"Pb(953) Null type mismatch (type annotations): required '@NonNull String' but this expression has type '@Nullable String'",
+				"Pb(980) Unsafe interpretation of method return type as '@NonNull' based on the receiver type 'Lib1<@NonNull String>'. Type 'Lib1<T>' doesn't seem to be designed with null type annotations in mind",
+		}, new int[] { 8, 11 });
+		// just mark that Lib1 now has null annotations:
+		createFileInProject("annots/libs", "Lib1.eea",
+				"class libs/Lib1\n" +
+				" <T:Ljava/lang/Object;>\n" + 
+				" <T:Ljava/lang/Object;>\n" + 
+				"\n");
+		reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		assertProblems(reconciled.getProblems(), new String[] {
+				"Pb(953) Null type mismatch (type annotations): required '@NonNull String' but this expression has type '@Nullable String'",
+		}, new int[] { 8 });
+	}
+	
+	public void testFreeTypeVariableReturnSeverities() throws Exception {
+		myCreateJavaProject("TestLibs");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" + 
+				"public interface Lib1<T> {\n" + 
+				"	T get();\n" + 
+				"}\n"
+			}, null);
+		this.currentProject = this.project;
+		addLibrary("lib2.jar", null, new String[] {
+				"/UnanntatedLib2/libs/Lib2.java",
+				"package libs;\n" + 
+				"\n" + 
+				"public interface Lib2<T> {\n" + 
+				"	T get();\n" + 
+				"}\n"				
+		}, "1.8");
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		fragment.createCompilationUnit("Lib3.java", 
+				"package tests;\n" +
+				"public interface Lib3<T> {\n" +
+				"	T get();\n" +
+				"}\n",
+				true, new NullProgressMonitor());
+		this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, new NullProgressMonitor());
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"import libs.Lib2;\n" + 
+				"import tests.Lib3;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	@NonNull String test1(Lib1<@NonNull String> lib) {\n" + 
+				"		return lib.get();\n" + // legacy, prepared for .eea but still not annotated (=> Warning)
+				"	}\n" + 
+				"	@NonNull String test2(Lib2<@NonNull String> lib) {\n" + 
+				"		return lib.get();\n" + // legacy, not prepared for .eea (=> Info)
+				"	}\n" + 
+				"	@NonNull String test3(Lib3<@NonNull String> lib) {\n" + 
+				"		return lib.get();\n" + // not legacy, is from the same project
+				"	}\n" + 
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		assertProblems(reconciled.getProblems(), new String[] {
+				"Pb(980) Unsafe interpretation of method return type as '@NonNull' based on the receiver type 'Lib1<@NonNull String>'. Type 'Lib1<T>' doesn't seem to be designed with null type annotations in mind",
+				"Pb(980) Unsafe interpretation of method return type as '@NonNull' based on the receiver type 'Lib2<@NonNull String>'. Type 'Lib2<T>' doesn't seem to be designed with null type annotations in mind",
+		}, new int[] { 10, 13 }, new int[] { ProblemSeverities.Warning, ProblemSeverities.Info } );
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index e02eb61..d4b4015 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1824,6 +1824,10 @@ void setSourceStart(int sourceStart);
 	int UninitializedFreeTypeVariableFieldHintMissingDefault = 978;
 	/** @since 3.12 */
 	int RequiredNonNullButProvidedFreeTypeVariable = TypeRelated + 979;
+	/** @since 3.12 */
+	int NonNullTypeVariableFromLegacyMethod = TypeRelated + 980;
+	/** @since 3.12 */
+	int NonNullMethodTypeVariableFromLegacyMethod = TypeRelated + 981;
 
 
 	// Java 8 work
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 966e309..86b41d3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -382,6 +382,10 @@ public boolean checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flow
 		} else {
 			scope.problemReporter().messageSendPotentialNullReference(this.binding, this);
 		}
+	} else if ((this.resolvedType.tagBits & TagBits.AnnotationNonNull) != 0) {
+		NullAnnotationMatching nonNullStatus = NullAnnotationMatching.okNonNullStatus(this);
+		if (nonNullStatus.wantToReport())
+			nonNullStatus.report(scope);
 	}
 	return true; // done all possible checking
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
index 588ac90..bed1a19 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
@@ -12,11 +12,14 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import org.eclipse.jdt.core.compiler.IProblem;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
+import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;
@@ -37,6 +40,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
+import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 
 /**
  * Performs matching of null type annotations.
@@ -45,10 +49,10 @@ import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
  */
 public class NullAnnotationMatching {
 	
-	public static final NullAnnotationMatching NULL_ANNOTATIONS_OK = new NullAnnotationMatching(0, FlowInfo.UNKNOWN, null);
-	public static final NullAnnotationMatching NULL_ANNOTATIONS_OK_NONNULL = new NullAnnotationMatching(0, FlowInfo.NON_NULL, null);
-	public static final NullAnnotationMatching NULL_ANNOTATIONS_UNCHECKED = new NullAnnotationMatching(1, FlowInfo.UNKNOWN, null);
-	public static final NullAnnotationMatching NULL_ANNOTATIONS_MISMATCH = new NullAnnotationMatching(2, FlowInfo.UNKNOWN, null);
+	public static final NullAnnotationMatching NULL_ANNOTATIONS_OK = new NullAnnotationMatching(Severity.OK, FlowInfo.UNKNOWN, null);
+	public static final NullAnnotationMatching NULL_ANNOTATIONS_OK_NONNULL = new NullAnnotationMatching(Severity.OK, FlowInfo.NON_NULL, null);
+	public static final NullAnnotationMatching NULL_ANNOTATIONS_UNCHECKED = new NullAnnotationMatching(Severity.UNCHECKED, FlowInfo.UNKNOWN, null);
+	public static final NullAnnotationMatching NULL_ANNOTATIONS_MISMATCH = new NullAnnotationMatching(Severity.MISMATCH, FlowInfo.UNKNOWN, null);
 
 	public enum CheckMode {
 		/** in this mode we check normal assignment compatibility. */
@@ -87,23 +91,44 @@ public class NullAnnotationMatching {
 		}
 	}
 
-	/** 0 = OK, 1 = unchecked, 2 = definite mismatch */
-	public final int severity;
+	private enum Severity {
+		/** No problem detected. */
+		OK,
+		/** No real problem, but could issue an {@link IProblem#NonNullTypeVariableFromLegacyMethod} or similar. */
+		LEGACY_WARNING,
+		/** Need unchecked conversion from unannotated to annotated. */
+		UNCHECKED,
+		/** Definite nullity mismatch. */
+		MISMATCH;
+
+		public Severity max(Severity severity) {
+			if (compareTo(severity) < 0)
+				return severity;
+			return this;
+		}
+	
+		public boolean isAnyMismatch() {
+			return compareTo(LEGACY_WARNING) > 0;
+		}
+	}
+
+	private final Severity severity;
 	
 	/** If non-null this field holds the supertype of the provided type which was used for direct matching. */
 	public final TypeBinding superTypeHint;
 	public final int nullStatus;
 	
-	public NullAnnotationMatching(int severity, int nullStatus, TypeBinding superTypeHint) {
+	NullAnnotationMatching(Severity severity, int nullStatus, TypeBinding superTypeHint) {
 		this.severity = severity;
 		this.superTypeHint = superTypeHint;
 		this.nullStatus = nullStatus;
 	}
 
-	public boolean isAnyMismatch()      { return this.severity != 0; }
-	public boolean isUnchecked()        { return this.severity == 1; }
-	public boolean isDefiniteMismatch() { return this.severity == 2; }
-	
+	public boolean isAnyMismatch()      { return this.severity.isAnyMismatch(); }
+	public boolean isUnchecked()        { return this.severity == Severity.UNCHECKED; }
+	public boolean isDefiniteMismatch() { return this.severity == Severity.MISMATCH; }
+	public boolean wantToReport() 		{ return this.severity == Severity.LEGACY_WARNING; }
+
 	public boolean isPotentiallyNullMismatch() {
 		return !isDefiniteMismatch() && this.nullStatus != -1 && (this.nullStatus & FlowInfo.POTENTIALLY_NULL) != 0;
 	}
@@ -137,8 +162,12 @@ public class NullAnnotationMatching {
 			if (annotationStatus.isAnyMismatch()) {
 				flowContext.recordNullityMismatch(currentScope, expression, providedType, var.type, flowInfo, nullStatus, annotationStatus);
 				hasReported = true;
-			} else if (annotationStatus.nullStatus != FlowInfo.UNKNOWN) {
-				return annotationStatus.nullStatus;
+			} else {
+				if (annotationStatus.wantToReport())
+					annotationStatus.report(currentScope);
+				if (annotationStatus.nullStatus != FlowInfo.UNKNOWN) {
+					return annotationStatus.nullStatus;
+				}
 			}
 		}
 		if (lhsTagBits == TagBits.AnnotationNonNull && nullStatus != FlowInfo.NON_NULL) {
@@ -181,12 +210,12 @@ public class NullAnnotationMatching {
 		if (!requiredType.enterRecursiveFunction())
 			return NullAnnotationMatching.NULL_ANNOTATIONS_OK;
 		try {
-			int severity = 0;
+			Severity severity = Severity.OK;
 			TypeBinding superTypeHint = null;
 			NullAnnotationMatching okStatus = NullAnnotationMatching.NULL_ANNOTATIONS_OK;
 			if (areSameTypes(requiredType, providedType, providedSubstitute)) {
 				if ((requiredType.tagBits & TagBits.AnnotationNonNull) != 0)
-					return NullAnnotationMatching.NULL_ANNOTATIONS_OK_NONNULL;
+					return okNonNullStatus(providedExpression);
 				return okStatus;
 			}
 			if (requiredType instanceof TypeVariableBinding && substitution != null && (mode == CheckMode.EXACT || mode == CheckMode.COMPATIBLE || mode == CheckMode.BOUND_SUPER_CHECK)) {
@@ -196,7 +225,7 @@ public class NullAnnotationMatching {
 					return NullAnnotationMatching.NULL_ANNOTATIONS_OK;
 				if (areSameTypes(requiredType, providedType, providedSubstitute)) {
 					if ((requiredType.tagBits & TagBits.AnnotationNonNull) != 0)
-						return NullAnnotationMatching.NULL_ANNOTATIONS_OK_NONNULL;
+						return okNonNullStatus(providedExpression);
 					return okStatus;
 				}
 			}
@@ -207,8 +236,8 @@ public class NullAnnotationMatching {
 					TypeBinding superClass = requiredType.superclass();
 					if (superClass != null && (superClass.hasNullTypeAnnotations() || substitution != null)) { // annotations may enter when substituting a nested type variable
 						NullAnnotationMatching status = analyse(superClass, providedType, null, substitution, nullStatus, providedExpression, CheckMode.BOUND_SUPER_CHECK);
-						severity = Math.max(severity, status.severity);
-						if (severity == 2)
+						severity = severity.max(status.severity);
+						if (severity == Severity.MISMATCH)
 							return new NullAnnotationMatching(severity, nullStatus, superTypeHint);
 					}
 					TypeBinding[] superInterfaces = requiredType.superInterfaces();
@@ -216,8 +245,8 @@ public class NullAnnotationMatching {
 						for (int i = 0; i < superInterfaces.length; i++) {
 							if (superInterfaces[i].hasNullTypeAnnotations() || substitution != null) { // annotations may enter when substituting a nested type variable
 								NullAnnotationMatching status = analyse(superInterfaces[i], providedType, null, substitution, nullStatus, providedExpression, CheckMode.BOUND_SUPER_CHECK);
-								severity = Math.max(severity, status.severity);
-								if (severity == 2)
+								severity = severity.max(status.severity);
+								if (severity == Severity.MISMATCH)
 									return new NullAnnotationMatching(severity, nullStatus, superTypeHint);
 							}
 						}
@@ -243,24 +272,24 @@ public class NullAnnotationMatching {
 							} else {
 								if (i > 0)
 									currentNullStatus = -1; // don't use beyond the outermost dimension
-								int dimSeverity = computeNullProblemSeverity(requiredBits, providedBits, currentNullStatus, i == 0 ? mode : mode.toDetail(), false);
-								if (i > 0 && dimSeverity == 1
+								Severity dimSeverity = computeNullProblemSeverity(requiredBits, providedBits, currentNullStatus, i == 0 ? mode : mode.toDetail(), false);
+								if (i > 0 && dimSeverity == Severity.UNCHECKED
 										&& providedExpression instanceof ArrayAllocationExpression
 										&& providedBits == 0 && requiredBits != 0)
 								{
 									Expression[] dimensions = ((ArrayAllocationExpression) providedExpression).dimensions;
 									Expression previousDim = dimensions[i-1];
 									if (previousDim instanceof IntLiteral && previousDim.constant.intValue() == 0) {
-										dimSeverity = 0; // element of empty dimension matches anything
+										dimSeverity = Severity.OK; // element of empty dimension matches anything
 										nullStatus = -1;
 										break;
 									}
 								}
-								severity = Math.max(severity, dimSeverity);
-								if (severity == 2)
+								severity = severity.max(dimSeverity);
+								if (severity == Severity.MISMATCH)
 									return NullAnnotationMatching.NULL_ANNOTATIONS_MISMATCH;
 							}
-							if (severity == 0)
+							if (severity == Severity.OK)
 								nullStatus = -1;
 						}
 					} else if (providedType.id == TypeIds.T_null) {
@@ -274,16 +303,16 @@ public class NullAnnotationMatching {
 					// at toplevel (having a nullStatus) nullable matches all
 				} else {
 					long providedBits = providedNullTagBits(providedType);
-					int s = computeNullProblemSeverity(requiredBits, providedBits, nullStatus, mode, requiredType.isTypeVariable());
-					severity = Math.max(severity, s);
-					if (severity == 0 && (providedBits & TagBits.AnnotationNonNull) != 0)
-						okStatus = NullAnnotationMatching.NULL_ANNOTATIONS_OK_NONNULL;
+					Severity s = computeNullProblemSeverity(requiredBits, providedBits, nullStatus, mode, requiredType.isTypeVariable());
+					severity = severity.max(s);
+					if (!severity.isAnyMismatch() && (providedBits & TagBits.AnnotationNonNull) != 0)
+						okStatus = okNonNullStatus(providedExpression);
 				}
-				if (severity < 2 && nullStatus != FlowInfo.NULL) {  // null value has no details
+				if (severity != Severity.MISMATCH && nullStatus != FlowInfo.NULL) {  // null value has no details
 					TypeBinding providedSuper = providedType.findSuperTypeOriginatingFrom(requiredType);
 					TypeBinding providedSubstituteSuper = providedSubstitute != null ? providedSubstitute.findSuperTypeOriginatingFrom(requiredType) : null;
-					if(severity == 1 && requiredType.isTypeVariable() && providedType.isTypeVariable() && (providedSuper == requiredType || providedSubstituteSuper == requiredType)) { //$IDENTITY-COMPARISON$
-						severity = 0;
+					if(severity == Severity.UNCHECKED && requiredType.isTypeVariable() && providedType.isTypeVariable() && (providedSuper == requiredType || providedSubstituteSuper == requiredType)) { //$IDENTITY-COMPARISON$
+						severity = Severity.OK;
 					}
 					if (providedSuper != providedType) //$IDENTITY-COMPARISON$
 						superTypeHint = providedSuper;
@@ -295,8 +324,8 @@ public class NullAnnotationMatching {
 							for (int i = 0; i < requiredArguments.length; i++) {
 								TypeBinding providedArgSubstitute = providedSubstitutes != null ? providedSubstitutes[i] : null;
 								NullAnnotationMatching status = analyse(requiredArguments[i], providedArguments[i], providedArgSubstitute, substitution, -1, providedExpression, mode.toDetail());
-								severity = Math.max(severity, status.severity);
-								if (severity == 2)
+								severity = severity.max(status.severity);
+								if (severity == Severity.MISMATCH)
 									return new NullAnnotationMatching(severity, nullStatus, superTypeHint);
 							}
 						}
@@ -306,17 +335,44 @@ public class NullAnnotationMatching {
 					if (requiredEnclosing != null && providedEnclosing != null) {
 						TypeBinding providedEnclSubstitute = providedSubstitute != null ? providedSubstitute.enclosingType() : null;
 						NullAnnotationMatching status = analyse(requiredEnclosing, providedEnclosing, providedEnclSubstitute, substitution, -1, providedExpression, mode);
-						severity = Math.max(severity, status.severity);
+						severity = severity.max(status.severity);
 					}
 				}
 			}
-			if (severity == 0)
+			if (!severity.isAnyMismatch())
 				return okStatus;
 			return new NullAnnotationMatching(severity, nullStatus, superTypeHint);
 		} finally {
 			requiredType.exitRecursiveFunction();
 		}
 	}
+	public void report(Scope scope) {
+		// nop
+	}
+	public static NullAnnotationMatching okNonNullStatus(final Expression providedExpression) {
+		if (providedExpression instanceof MessageSend) {
+			final MethodBinding method = ((MessageSend) providedExpression).binding;
+			if (method != null && method.isValidBinding()) {
+				MethodBinding originalMethod = method.original();
+				TypeBinding originalDeclaringClass = originalMethod.declaringClass;
+				if (originalDeclaringClass instanceof BinaryTypeBinding 
+						&& ((BinaryTypeBinding) originalDeclaringClass).externalAnnotationStatus.isPotentiallyUnannotatedLib()
+						&& originalMethod.returnType.isTypeVariable()
+						&& (originalMethod.returnType.tagBits & TagBits.AnnotationNullMASK) == 0)
+				{
+					final int severity = ((BinaryTypeBinding) originalDeclaringClass).externalAnnotationStatus == ExternalAnnotationStatus.NO_EEA_FILE
+												? ProblemSeverities.Warning : ProblemSeverities.Info; // reduce severity if not configured to for external annotations
+					return new NullAnnotationMatching(Severity.LEGACY_WARNING, FlowInfo.UNKNOWN, null) {
+						@Override
+						public void report(Scope scope) {
+							scope.problemReporter().nonNullTypeVariableInUnannotatedBinary(scope.environment(), method, providedExpression, severity);
+						}
+					};
+				}
+			}
+		}
+		return NullAnnotationMatching.NULL_ANNOTATIONS_OK_NONNULL;
+	}
 
 	/** Are both types identical wrt the unannotated type and any null type annotations? Only unstructured types and captures are considered. */
 	protected static boolean areSameTypes(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute) {
@@ -484,41 +540,41 @@ public class NullAnnotationMatching {
 	 * @param requiredIsTypeVariable is the required type a type variable (possibly: "free type variable")?
 	 * @return see {@link #severity} for interpretation of values
 	 */
-	private static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus, CheckMode mode, boolean requiredIsTypeVariable) {
+	private static Severity computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus, CheckMode mode, boolean requiredIsTypeVariable) {
 		if (requiredBits == providedBits)
-			return 0;
+			return Severity.OK;
 		if (requiredBits == 0) { 
 			switch (mode) {
 				case COMPATIBLE:
 				case BOUND_CHECK:
 				case BOUND_SUPER_CHECK:
 				case EXACT:
-					return 0;
+					return Severity.OK;
 				case OVERRIDE_RETURN:
 					if (providedBits == TagBits.AnnotationNonNull)
-						return 0; // covariant redefinition to nonnull is good
+						return Severity.OK; // covariant redefinition to nonnull is good
 					if (!requiredIsTypeVariable)
-						return 0; // refining an unconstrained non-TVB return to nullable is also legal
-					return 1;
+						return Severity.OK; // refining an unconstrained non-TVB return to nullable is also legal
+					return Severity.UNCHECKED;
 				case OVERRIDE:
-					return 1; // warn about dropped annotation
+					return Severity.UNCHECKED; // warn about dropped annotation
 			}
 		} else if (requiredBits == TagBits.AnnotationNullMASK) {
-			return 0; // OK since LHS accepts either
+			return Severity.OK; // OK since LHS accepts either
 		} else if (requiredBits == TagBits.AnnotationNonNull) {
 			switch (mode) {
 				case COMPATIBLE:
 				case BOUND_SUPER_CHECK:
 					if (nullStatus == FlowInfo.NON_NULL)
-						return 0; // OK by flow analysis
+						return Severity.OK; // OK by flow analysis
 					//$FALL-THROUGH$
 				case BOUND_CHECK:
 				case EXACT:
 				case OVERRIDE_RETURN:
 				case OVERRIDE:
 					if (providedBits == 0)
-						return 1;
-					return 2;
+						return Severity.UNCHECKED;
+					return Severity.MISMATCH;
 			}
 			
 		} else if (requiredBits == TagBits.AnnotationNullable) {
@@ -526,17 +582,17 @@ public class NullAnnotationMatching {
 				case COMPATIBLE:
 				case OVERRIDE_RETURN:
 				case BOUND_SUPER_CHECK:
-					return 0; // in these modes everything is compatible to nullable
+					return Severity.OK; // in these modes everything is compatible to nullable
 				case BOUND_CHECK:
 				case EXACT:
 					if (providedBits == 0)
-						return 1;
-					return 2;
+						return Severity.UNCHECKED;
+					return Severity.MISMATCH;
 				case OVERRIDE:
-					return 2;
+					return Severity.MISMATCH;
 			}
 		}
-		return 0; // shouldn't get here, requiredBits should be one of the listed cases
+		return Severity.OK; // shouldn't get here, requiredBits should be one of the listed cases
 	}
 
 	static class SearchContradictions extends TypeBindingVisitor {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index f1c4fee..52f0c52 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -40,6 +40,7 @@ package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.CheckMode;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.*;
 import org.eclipse.jdt.internal.compiler.flow.*;
@@ -214,11 +215,15 @@ protected void checkAgainstNullTypeAnnotation(BlockScope scope, TypeBinding requ
 }
 private void internalCheckAgainstNullTypeAnnotation(BlockScope scope, TypeBinding requiredType, Expression expression,
 		int nullStatus, FlowContext flowContext, FlowInfo flowInfo) {
-	NullAnnotationMatching annotationStatus = NullAnnotationMatching.analyse(requiredType, expression.resolvedType, nullStatus);
+	NullAnnotationMatching annotationStatus = NullAnnotationMatching.analyse(requiredType, expression.resolvedType, null, null, nullStatus, expression, CheckMode.COMPATIBLE);
 	if (annotationStatus.isDefiniteMismatch()) {
 		scope.problemReporter().nullityMismatchingTypeAnnotation(expression, expression.resolvedType, requiredType, annotationStatus);
-	} else if (annotationStatus.isUnchecked()) {
-		flowContext.recordNullityMismatch(scope, expression, expression.resolvedType, requiredType, flowInfo, nullStatus, annotationStatus);
+	} else {
+		if (annotationStatus.wantToReport())
+			annotationStatus.report(scope);
+		if (annotationStatus.isUnchecked()) {
+			flowContext.recordNullityMismatch(scope, expression, expression.resolvedType, requiredType, flowInfo, nullStatus, annotationStatus);
+		}
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index 6b09c8c..cf51258 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -34,6 +34,7 @@ import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
+import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class ClassFileReader extends ClassFileStruct implements IBinaryType {
@@ -67,6 +68,7 @@ public class ClassFileReader extends ClassFileStruct implements IBinaryType {
 	private int enclosingNameAndTypeIndex;
 	private char[] enclosingMethod;
 	private ExternalAnnotationProvider annotationProvider;
+	private ExternalAnnotationStatus externalAnnotationStatus = ExternalAnnotationStatus.NOT_EEA_CONFIGURED;
 
 private static String printTypeModifiers(int modifiers) {
 	java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream();
@@ -427,6 +429,7 @@ public interface ZipFileProducer { ZipFile produce() throws IOException; }
  *		this is unexpected.
  */
 public ZipFile setExternalAnnotationProvider(String basePath, String qualifiedBinaryTypeName, ZipFile zipFile, ZipFileProducer producer) throws IOException {
+	this.externalAnnotationStatus = ExternalAnnotationStatus.NO_EEA_FILE;
 	String qualifiedBinaryFileName = qualifiedBinaryTypeName + ExternalAnnotationProvider.ANNOTATION_FILE_SUFFIX;
 	if (zipFile == null) {
 		File annotationBase = new File(basePath);
@@ -434,6 +437,7 @@ public ZipFile setExternalAnnotationProvider(String basePath, String qualifiedBi
 			try {
 				String filePath = annotationBase.getAbsolutePath()+'/'+qualifiedBinaryFileName;
 				this.annotationProvider = new ExternalAnnotationProvider(new FileInputStream(filePath), String.valueOf(getName()));
+				this.externalAnnotationStatus = ExternalAnnotationStatus.TYPE_IS_ANNOTATED;
 			} catch (FileNotFoundException e) {
 				// expected, no need to report an error here
 			}
@@ -444,14 +448,22 @@ public ZipFile setExternalAnnotationProvider(String basePath, String qualifiedBi
 		zipFile = (producer != null ? producer.produce() : new ZipFile(annotationBase));
 	}
 	ZipEntry entry = zipFile.getEntry(qualifiedBinaryFileName);
-	if (entry != null)
+	if (entry != null) {
 		this.annotationProvider = new ExternalAnnotationProvider(zipFile.getInputStream(entry), String.valueOf(getName()));
+		this.externalAnnotationStatus = ExternalAnnotationStatus.TYPE_IS_ANNOTATED;
+	}
 	return zipFile;
 }
 public boolean hasAnnotationProvider() {
 	return this.annotationProvider != null;
 }
-
+public void markAsFromSource() {
+	this.externalAnnotationStatus = ExternalAnnotationStatus.FROM_SOURCE;
+}
+@Override
+public ExternalAnnotationStatus getExternalAnnotationStatus() {
+	return this.externalAnnotationStatus;
+}
 /**
  * Conditionally add external annotations to the mix.
  * If 'member' is given it must be either of IBinaryField or IBinaryMethod, in which case we're seeking annotations for that member.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
index 4d58e4f..092fe6c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,6 +15,7 @@
 package org.eclipse.jdt.internal.compiler.env;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 
 public interface IBinaryType extends IGenericType {
@@ -160,4 +161,9 @@ char[] sourceFileName();
  */
 ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWalker walker, Object member, LookupEnvironment environment);
 
+/**
+ * Answer whether a provider for external annotations is associated with this binary type.
+ */
+ExternalAnnotationStatus getExternalAnnotationStatus();
+
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 7093c8c..5ebc298 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -185,6 +185,7 @@ public class CompilerOptions {
 	public static final String OPTION_InheritNullAnnotations = "org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations";  //$NON-NLS-1$
 	public static final String OPTION_ReportNonnullParameterAnnotationDropped = "org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped";  //$NON-NLS-1$
 	public static final String OPTION_PessimisticNullAnalysisForFreeTypeVariables = "org.eclipse.jdt.core.compiler.problem.pessimisticNullAnalysisForFreeTypeVariables";  //$NON-NLS-1$
+	public static final String OPTION_ReportNonNullTypeVariableFromLegacyInvocation = "org.eclipse.jdt.core.compiler.problem.nonnullTypeVariableFromLegacyInvocation"; //$NON-NLS-1$
 	
 	/**
 	 * Possible values for configurable options
@@ -307,6 +308,7 @@ public class CompilerOptions {
 	public static final int NonnullParameterAnnotationDropped = IrritantSet.GROUP2 | ASTNode.Bit18;
 	public static final int UnusedExceptionParameter = IrritantSet.GROUP2 | ASTNode.Bit19;
 	public static final int PessimisticNullAnalysisForFreeTypeVariables = IrritantSet.GROUP2 | ASTNode.Bit20;
+	public static final int NonNullTypeVariableFromLegacyInvocation = IrritantSet.GROUP2 | ASTNode.Bit21;
 
 	// Severity level for handlers
 	/** 
@@ -707,6 +709,8 @@ public class CompilerOptions {
 				return OPTION_ReportNonnullParameterAnnotationDropped;
 			case PessimisticNullAnalysisForFreeTypeVariables:
 				return OPTION_PessimisticNullAnalysisForFreeTypeVariables;
+			case NonNullTypeVariableFromLegacyInvocation:
+				return OPTION_ReportNonNullTypeVariableFromLegacyInvocation;
 		}
 		return null;
 	}
@@ -971,6 +975,7 @@ public class CompilerOptions {
 			case MissingNonNullByDefaultAnnotation:
 			case NonnullParameterAnnotationDropped:
 			case PessimisticNullAnalysisForFreeTypeVariables:
+			case NonNullTypeVariableFromLegacyInvocation:
 				return "null"; //$NON-NLS-1$
 			case FallthroughCase :
 				return "fallthrough"; //$NON-NLS-1$
@@ -1213,6 +1218,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
 		optionsMap.put(OPTION_ReportUninternedIdentityComparison, this.complainOnUninternedIdentityComparison ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_PessimisticNullAnalysisForFreeTypeVariables, getSeverityString(PessimisticNullAnalysisForFreeTypeVariables));
+		optionsMap.put(OPTION_ReportNonNullTypeVariableFromLegacyInvocation, getSeverityString(NonNullTypeVariableFromLegacyInvocation));
 		return optionsMap;
 	}
 
@@ -1753,6 +1759,7 @@ public class CompilerOptions {
 			} else {
 				this.pessimisticNullAnalysisForFreeTypeVariablesEnabled = true;
 			}
+			if ((optionValue = optionsMap.get(OPTION_ReportNonNullTypeVariableFromLegacyInvocation)) != null) updateSeverity(NonNullTypeVariableFromLegacyInvocation, optionValue);
 		}
 
 		// Javadoc options
@@ -2021,6 +2028,7 @@ public class CompilerOptions {
 		buf.append("\n\t- resource should be handled by try-with-resources: ").append(getSeverityString(ExplicitlyClosedAutoCloseable)); //$NON-NLS-1$
 		buf.append("\n\t- Unused Type Parameter: ").append(getSeverityString(UnusedTypeParameter)); //$NON-NLS-1$
 		buf.append("\n\t- pessimistic null analysis for free type variables: ").append(getSeverityString(PessimisticNullAnalysisForFreeTypeVariables)); //$NON-NLS-1$
+		buf.append("\n\t- report unsafe nonnull return from legacy method: ").append(getSeverityString(NonNullTypeVariableFromLegacyInvocation)); //$NON-NLS-1$
 		return buf.toString();
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index e9993c2..54f524d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -116,7 +116,8 @@ public class IrritantSet {
 				|CompilerOptions.NullUncheckedConversion
 				|CompilerOptions.RedundantNullAnnotation
 				|CompilerOptions.NonnullParameterAnnotationDropped
-				|CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables);
+				|CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables
+				|CompilerOptions.NonNullTypeVariableFromLegacyInvocation);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
 		COMPILER_DEFAULT_ERRORS.set(
 				CompilerOptions.NullSpecViolation
@@ -136,7 +137,8 @@ public class IrritantSet {
 			.set(CompilerOptions.RedundantNullAnnotation)
 			.set(CompilerOptions.NonnullParameterAnnotationDropped)
 			.set(CompilerOptions.MissingNonNullByDefaultAnnotation)
-			.set(CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables);
+			.set(CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables)
+			.set(CompilerOptions.NonNullTypeVariableFromLegacyInvocation);
 
 		RESTRICTION.set(CompilerOptions.DiscouragedReference);
 		STATIC_ACCESS.set(CompilerOptions.NonStaticAccessToStatic);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 5d1f31f..a941b11 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -91,7 +91,23 @@ public class BinaryTypeBinding extends ReferenceBinding {
 
 	private ReferenceBinding containerAnnotationType;
 	int defaultNullness = 0;
-
+	public enum ExternalAnnotationStatus {
+		FROM_SOURCE,
+		NOT_EEA_CONFIGURED,
+		NO_EEA_FILE,
+		TYPE_IS_ANNOTATED;
+		public boolean isPotentiallyUnannotatedLib() {
+			switch (this) {
+				case FROM_SOURCE:
+				case TYPE_IS_ANNOTATED:
+					return false;
+				default:
+					return true;
+			}
+		}
+	}
+	public ExternalAnnotationStatus externalAnnotationStatus = ExternalAnnotationStatus.NOT_EEA_CONFIGURED; // unless proven differently
+	
 static Object convertMemberValue(Object binaryValue, LookupEnvironment env, char[][][] missingTypeNames, boolean resolveEnumConstants) {
 	if (binaryValue == null) return null;
 	if (binaryValue instanceof Constant)
@@ -419,6 +435,10 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 		}
 		ITypeAnnotationWalker walker = getTypeAnnotationWalker(binaryType.getTypeAnnotations(), Binding.NO_NULL_DEFAULT);
 		ITypeAnnotationWalker toplevelWalker = binaryType.enrichWithExternalAnnotationsFor(walker, null, this.environment);
+		this.externalAnnotationStatus = binaryType.getExternalAnnotationStatus();
+		if (this.externalAnnotationStatus.isPotentiallyUnannotatedLib() && this.defaultNullness != 0) {
+			this.externalAnnotationStatus = ExternalAnnotationStatus.TYPE_IS_ANNOTATED;
+		}
 		char[] typeSignature = binaryType.getGenericSignature(); // use generic signature even in 1.4
 		this.tagBits |= binaryType.getTagBits();
 		
@@ -484,6 +504,19 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 				this.tagBits |= TagBits.HasUnresolvedSuperinterfaces;
 			}
 		}
+		boolean canUseNullTypeAnnotations = this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled && this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;
+		if (canUseNullTypeAnnotations && this.externalAnnotationStatus.isPotentiallyUnannotatedLib()) {
+			if (this.superclass != null && this.superclass.hasNullTypeAnnotations()) {
+				this.externalAnnotationStatus = ExternalAnnotationStatus.TYPE_IS_ANNOTATED;
+			} else {
+				for (TypeBinding ifc : this.superInterfaces) {
+					if (ifc.hasNullTypeAnnotations()) {
+						this.externalAnnotationStatus = ExternalAnnotationStatus.TYPE_IS_ANNOTATED;
+						break;
+					}
+				}
+			}
+		}
 
 		if (needFieldsAndMethods) {
 			IBinaryField[] iFields = binaryType.getFields();
@@ -520,7 +553,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 						ITypeAnnotationWalker methodWalker = ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
 						if (sourceLevel < ClassFileConstants.JDK1_8)
 							methodWalker = binaryType.enrichWithExternalAnnotationsFor(methodWalker, iMethods[i], this.environment);
-						scanMethodForNullAnnotation(iMethods[i], this.methods[i], methodWalker);
+						scanMethodForNullAnnotation(iMethods[i], this.methods[i], methodWalker, canUseNullTypeAnnotations);
 					}
 				}
 			}
@@ -934,6 +967,8 @@ private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, bool
 		this.typeVariables = result;
 	for (int i = 0; i < rank; i++) {
 		initializeTypeVariable(result[i], result, wrapper, missingTypeNames, walker.toTypeParameterBounds(isClassTypeParameter, i));
+		if (this.externalAnnotationStatus.isPotentiallyUnannotatedLib() && result[i].hasNullTypeAnnotations())
+			this.externalAnnotationStatus = ExternalAnnotationStatus.TYPE_IS_ANNOTATED;
 	}
 	return result;
 }
@@ -1565,12 +1600,14 @@ private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBi
 			}
 		}
 	}
+	if (explicitNullness && this.externalAnnotationStatus.isPotentiallyUnannotatedLib())
+		this.externalAnnotationStatus = ExternalAnnotationStatus.TYPE_IS_ANNOTATED;
 	if (!explicitNullness && (this.tagBits & TagBits.AnnotationNonNullByDefault) != 0) {
 		fieldBinding.tagBits |= TagBits.AnnotationNonNull;
 	}
 }
 
-private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding, ITypeAnnotationWalker externalAnnotationWalker) {
+private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding, ITypeAnnotationWalker externalAnnotationWalker, boolean useNullTypeAnnotations) {
 	if (!isPrototype()) throw new IllegalStateException();
 	if (isEnum()) {
 		int purpose = 0;
@@ -1659,6 +1696,18 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 			}
 		}
 	}
+	if (useNullTypeAnnotations && this.externalAnnotationStatus.isPotentiallyUnannotatedLib()) {
+		if (methodBinding.returnType.hasNullTypeAnnotations()) {
+			this.externalAnnotationStatus = ExternalAnnotationStatus.TYPE_IS_ANNOTATED;
+		} else {
+			for (TypeBinding parameter : parameters) {
+				if (parameter.hasNullTypeAnnotations()) {
+					this.externalAnnotationStatus = ExternalAnnotationStatus.TYPE_IS_ANNOTATED;
+					break;
+				}
+			}
+		}
+	}
 }
 // pre: null annotation analysis is enabled
 private void scanTypeForNullDefaultAnnotation(IBinaryType binaryType, PackageBinding packageBinding) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 4fa6bf9..7c52b2d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -427,6 +427,10 @@ public static int getIrritant(int problemID) {
 		case IProblem.UninitializedFreeTypeVariableFieldHintMissingDefault:
 			return CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables;
 
+		case IProblem.NonNullTypeVariableFromLegacyMethod:
+		case IProblem.NonNullMethodTypeVariableFromLegacyMethod:
+			return CompilerOptions.NonNullTypeVariableFromLegacyInvocation;
+
 		case IProblem.ParameterLackingNonNullAnnotation:
 			return CompilerOptions.NonnullParameterAnnotationDropped;
 
@@ -659,6 +663,7 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.UnclosedCloseable :
 			case CompilerOptions.PotentiallyUnclosedCloseable :
 			case CompilerOptions.PessimisticNullAnalysisForFreeTypeVariables :
+			case CompilerOptions.NonNullTypeVariableFromLegacyInvocation :
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			
 			case CompilerOptions.OverriddenPackageDefaultMethod :
@@ -10006,7 +10011,54 @@ public void implicitObjectBoundNoNullDefault(TypeReference reference) {
 			ProblemSeverities.Warning,
 			reference.sourceStart, reference.sourceEnd);
 }
-
+public void nonNullTypeVariableInUnannotatedBinary(LookupEnvironment environment, MethodBinding method, Expression expression, int providedSeverity) {
+	TypeBinding declaredReturnType = method.original().returnType;
+	int severity = computeSeverity(IProblem.NonNullTypeVariableFromLegacyMethod);
+	if ((severity & ProblemSeverities.CoreSeverityMASK) == ProblemSeverities.Warning)
+		severity = providedSeverity; // leverage the greater precision from our caller
+	if (declaredReturnType instanceof TypeVariableBinding) { // paranoia check
+		TypeVariableBinding typeVariable = (TypeVariableBinding) declaredReturnType;
+		TypeBinding declaringClass = method.declaringClass;
+
+		char[][] nonNullName = this.options.nonNullAnnotationName;
+		String shortNonNullName = String.valueOf(nonNullName[nonNullName.length-1]);
+		
+		if (typeVariable.declaringElement instanceof ReferenceBinding) {
+			String[] arguments = new String[] {
+					shortNonNullName,
+					String.valueOf(declaringClass.nullAnnotatedReadableName(this.options, false)),
+					String.valueOf(declaringClass.original().readableName())};
+			String[] shortArguments = {
+					shortNonNullName,
+					String.valueOf(declaringClass.nullAnnotatedReadableName(this.options, true)),
+					String.valueOf(declaringClass.original().shortReadableName()) };
+			this.handle(IProblem.NonNullTypeVariableFromLegacyMethod,
+					arguments, 
+					shortArguments,
+					severity,
+					expression.sourceStart,
+					expression.sourceEnd);
+		} else if (typeVariable.declaringElement instanceof MethodBinding && method instanceof ParameterizedGenericMethodBinding) {
+			TypeBinding substitution = ((ParameterizedGenericMethodBinding) method).typeArguments[typeVariable.rank];
+			String[] arguments = new String[] {
+					shortNonNullName,
+					String.valueOf(typeVariable.readableName()),
+					String.valueOf(substitution.nullAnnotatedReadableName(this.options, false)),
+					String.valueOf(declaringClass.original().readableName())};
+			String[] shortArguments = {
+					shortNonNullName,
+					String.valueOf(typeVariable.shortReadableName()),
+					String.valueOf(substitution.nullAnnotatedReadableName(this.options, true)),
+					String.valueOf(declaringClass.original().shortReadableName()) };
+			this.handle(IProblem.NonNullMethodTypeVariableFromLegacyMethod,
+					arguments, 
+					shortArguments, 
+					severity,
+					expression.sourceStart,
+					expression.sourceEnd);			
+		}
+	}
+}
 public void dereferencingNullableExpression(Expression expression) {
 	if (expression instanceof MessageSend) {
 		MessageSend send = (MessageSend) expression;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemSeverities.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemSeverities.java
index 1ba865a..5bd21fa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemSeverities.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemSeverities.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -26,4 +26,6 @@ public interface ProblemSeverities {
 	final int Ignore = 256; // during handling only
 	final int InternalError = 512;  // always exposed, even when silent error handling policy is in effect.
 	final int Info = 1024; // When bit is set, the unit or project is not flagged.
+	
+	final int CoreSeverityMASK = Warning | Error | Info | Ignore;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 37672d6..280cdbc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -836,6 +836,8 @@
 977 = The field {0} may not have been initialized, whereas its type ''{1}'' is a free type variable that may represent a ''@{2}'' type
 978 = The field {0} may not have been initialized, whereas its type ''{1}'' is a free type variable that may represent a ''@{2}'' type. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
 979 = Null type safety: required ''@{0}'' but this expression has type ''{1}'', a free type variable that may represent a ''@{2}'' type
+980 = Unsafe interpretation of method return type as ''@{0}'' based on the receiver type ''{1}''. Type ''{2}'' doesn't seem to be designed with null type annotations in mind
+981 = Unsafe interpretation of method return type as ''@{0}'' based on substitution ''{1}={2}''. Declaring type ''{3}'' doesn't seem to be designed with null type annotations in mind
 
 
 # Java 8
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
index 385da47..b95eccd 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -27,6 +27,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
 import org.eclipse.jdt.internal.core.util.Util;
 
 /**
@@ -197,4 +198,8 @@ public char[] sourceFileName() {
 public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWalker walker, Object member, LookupEnvironment environment) {
 	return walker;
 }
+@Override
+public ExternalAnnotationStatus getExternalAnnotationStatus() {
+	return ExternalAnnotationStatus.NOT_EEA_CONFIGURED;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index be641c3..33a8e0d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1866,6 +1866,30 @@ public final class JavaCore extends Plugin {
 	 * @category CompilerOptionID
 	 */
 	public static final String COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED = JavaCore.PLUGIN_ID+".compiler.problem.nonnullParameterAnnotationDropped"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Reporting Unsafe NonNull Interpretation Of Type Variables.
+	 * <p>When enabled, the compiler will issue an error or a warning against a method call
+	 *    if all of the following hold:</p>
+	 * <ul>
+	 *    <li>The method's declared return type is a type variable without any null annotation.</li>
+	 *    <li>For the given invocation this type variable is substituted with a nonnull type.</li>
+	 *    <li>The type declaring the method is provided by a third-party library.</li>
+	 *    <li>No null annotations exist for this library type, neither in its class file nor using external annotations.</li>
+	 * </ul>
+	 * <p>This particular situation leverages the option to consistently substitute all occurrences of a type variable
+	 *  with a nonnull type, but it bears the risk that the library type may not be aware of null annotations thus lacking
+	 *  a necessary <code>@Nullable</code> annotation for a particular occurrence of a type variable.</p>   
+	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled and when
+	 *  the configured set of null annotations declares the target <code>TYPE_USE</code></p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nonnullTypeVariableFromLegacyInvocation"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "info", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 * @since 3.12
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_NONNULL_TYPEVAR_FROM_LEGACY_INVOCATION = JavaCore.PLUGIN_ID+".compiler.problem.nonnullTypeVariableFromLegacyInvocation"; //$NON-NLS-1$
 
 	/**
 	 * Compiler option ID: Setting Source Compatibility Mode.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index c01f34e..cef1ba4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -365,11 +365,14 @@ private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyIniti
 				if (entry != null) {
 					IProject project = javaProject.getProject();
 					IPath externalAnnotationPath = ClasspathEntry.getExternalAnnotationPath(entry, project, false); // unresolved for use in ExternalAnnotationTracker
-					if (externalAnnotationPath != null)
+					if (externalAnnotationPath != null) {
 						setupExternalAnnotationProvider(project, externalAnnotationPath, annotationZip, reader, 
 								entryName.substring(0, entryName.length() - SuffixConstants.SUFFIX_CLASS.length));
+					} else if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
+						reader.markAsFromSource();
+					}
 				}
-			} 
+			}
 			return reader;
 		}
 	} finally {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
index 881b964..932c049 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -26,6 +26,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
 import org.eclipse.jdt.internal.core.search.indexing.IIndexConstants;
 
 public class HierarchyBinaryType implements IBinaryType {
@@ -272,4 +273,8 @@ public String toString() {
 public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWalker walker, Object member, LookupEnvironment environment) {
 	return walker;
 }
+@Override
+public ExternalAnnotationStatus getExternalAnnotationStatus() {
+	return ExternalAnnotationStatus.NOT_EEA_CONFIGURED;
+}
 }
commit 963dd2c43e22726cc3e957f5eda1d6cc13f56745
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Mon Mar 28 13:40:41 2016 -0700

    Bug 461268 - Clean up the comments and computation of constants
    
    Refactor how the constants are computed in Database in order to make
    their function more clear.
    
    Change-Id: Ia7096d4119c683541ba86221046915527cca6e7c
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
25	15	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
index d26685d..786641b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/RawGrowableArray.java
@@ -127,7 +127,7 @@ public final class RawGrowableArray {
 
 			GROWABLE_BLOCK_HEADER_BYTES = type.size();
 
-			MAX_GROWABLE_SIZE = (Database.CHUNK_SIZE - Database.BLOCK_HEADER_SIZE - GROWABLE_BLOCK_HEADER_BYTES)
+			MAX_GROWABLE_SIZE = (Database.MAX_MALLOC_SIZE - GROWABLE_BLOCK_HEADER_BYTES)
 					/ Database.PTR_SIZE;
 		}
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
index 1de9ee7..569a3ee 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
@@ -54,17 +54,24 @@ import com.ibm.icu.text.MessageFormat;
  *
  * (1) where 2 <= m <= CHUNK_SIZE / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 1
  *
- * ===== block structure
+ * ===== block structure (for free/unused blocks)
  *
  * offset            content
  * 	                 _____________________________
- * 0                | size of block (negative indicates in use, positive unused) (2 bytes)
+ * 0                | size of block (positive indicates an unused block) (2 bytes)
  * PREV_OFFSET      | pointer to previous block (of same size) (only in free blocks)
  * NEXT_OFFSET      | pointer to next block (of same size) (only in free blocks)
+ * ...              | unused space
+ *
+ *====== block structure (for allocated blocks)
+ *
+ * offset            content
+ * 	                 _____________________________
+ * 0                | size of block (negative indicates the block is in use) (2 bytes)
+ * 2                | content of the struct 
  *
  */
 public class Database {
-	// Public for tests only, you shouldn't need these.
 	public static final int CHAR_SIZE = 2;
 	public static final int BYTE_SIZE = 1;
 	public static final int SHORT_SIZE = 2;
@@ -72,31 +79,30 @@ public class Database {
 	public static final int LONG_SIZE = 8;
 	public static final int CHUNK_SIZE = 1024 * 4;
 	public static final int OFFSET_IN_CHUNK_MASK= CHUNK_SIZE - 1;
-	public static final int BLOCK_HEADER_SIZE= 2;
+	public static final int BLOCK_HEADER_SIZE = SHORT_SIZE;
+
 	public static final int BLOCK_SIZE_DELTA_BITS = 3;
 	public static final int BLOCK_SIZE_DELTA= 1 << BLOCK_SIZE_DELTA_BITS;
-	public static final int MIN_BLOCK_DELTAS = 2;	// a block must at least be 2 + 2*4 bytes to link the free blocks.
+	
+	// Fields that are only used by free blocks
+	private static final int BLOCK_PREV_OFFSET = BLOCK_HEADER_SIZE;
+	private static final int BLOCK_NEXT_OFFSET = BLOCK_HEADER_SIZE + INT_SIZE;
+	private static final int FREE_BLOCK_HEADER_SIZE = BLOCK_NEXT_OFFSET + INT_SIZE;
+	
+	public static final int MIN_BLOCK_DELTAS = (FREE_BLOCK_HEADER_SIZE + BLOCK_SIZE_DELTA - 1) /
+			BLOCK_SIZE_DELTA; // Must be enough multiples of BLOCK_SIZE_DELTA in order to fit the free block header
 	public static final int MAX_BLOCK_DELTAS = CHUNK_SIZE / BLOCK_SIZE_DELTA;
 	public static final int MAX_MALLOC_SIZE = MAX_BLOCK_DELTAS * BLOCK_SIZE_DELTA - BLOCK_HEADER_SIZE;
 	public static final int PTR_SIZE = 4;  // size of a pointer in the database in bytes
 	public static final int STRING_SIZE = PTR_SIZE;
 	public static final int FLOAT_SIZE = INT_SIZE;
 	public static final int DOUBLE_SIZE = LONG_SIZE;
-	// The lower bound for TYPE_SIZE is 1 + PTR_SIZE, but a slightly larger space for types stored
-	// inline produces in a slightly smaller overall database size.
-	public static final int TYPE_SIZE = 2 + PTR_SIZE;  // size of a type in the database in bytes
-	public static final int VALUE_SIZE = 1 + PTR_SIZE;  // size of a value in the database in bytes
-	public static final int EVALUATION_SIZE = TYPE_SIZE;  // size of an evaluation in the database in bytes
-	public static final int ARGUMENT_SIZE = TYPE_SIZE;  // size of a template argument in the database in bytes
 	public static final long MAX_DB_SIZE= ((long) 1 << (Integer.SIZE + BLOCK_SIZE_DELTA_BITS));
 
 	public static final int VERSION_OFFSET = 0;
 	public static final int WRITE_NUMBER_OFFSET = (CHUNK_SIZE / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 2) * INT_SIZE;
 	public static final int DATA_AREA = WRITE_NUMBER_OFFSET + LONG_SIZE;
 
-	private static final int BLOCK_PREV_OFFSET = BLOCK_HEADER_SIZE;
-	private static final int BLOCK_NEXT_OFFSET = BLOCK_HEADER_SIZE + INT_SIZE;
-
 	private final File fLocation;
 	private final boolean fReadOnly;
 	private RandomAccessFile fFile;
@@ -149,6 +155,10 @@ public class Database {
 		}
 	}
 
+	private static int divideRoundingUp(int num, int den) {
+		return (num + den - 1) / den;
+	}
+
 	private void openFile() throws FileNotFoundException {
 		this.fFile = new RandomAccessFile(this.fLocation, this.fReadOnly ? "r" : "rw"); //$NON-NLS-1$ //$NON-NLS-2$
 	}
@@ -322,7 +332,7 @@ public class Database {
 		assert datasize >= 0;
 		assert datasize <= MAX_MALLOC_SIZE;
 
-		int needDeltas= (datasize + BLOCK_HEADER_SIZE + BLOCK_SIZE_DELTA - 1) / BLOCK_SIZE_DELTA;
+		int needDeltas= divideRoundingUp(datasize + BLOCK_HEADER_SIZE, BLOCK_SIZE_DELTA);
 		if (needDeltas < MIN_BLOCK_DELTAS) {
 			needDeltas= MIN_BLOCK_DELTAS;
 		}
commit d96bd93c6adc2f76563f4ea7621a8f74791fd85f
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Mon Mar 28 14:05:00 2016 -0700

    Bug 461268 - More cleanup of constants
    
    Change-Id: Ibebd10b4831b82f6448b8e1110d8e6d39ba622e7
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/BTreeTests.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/DatabaseTest.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
9	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/BTreeTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/BTreeTests.java
index f9ca84b..c550712 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/BTreeTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/BTreeTests.java
@@ -54,7 +54,7 @@ public class BTreeTests extends BaseTestCase {
 		pdom = DatabaseTestUtil.createEmptyPdom(getName());
 		db = pdom.getDB();
 		db.setExclusiveLock();
-		rootRecord = Database.DATA_AREA;
+		rootRecord = Database.DATA_AREA_OFFSET;
 		comparator = new BTMockRecordComparator();
 		btree = new BTree(pdom, rootRecord, degree, comparator);
 	}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/DatabaseTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/DatabaseTest.java
index 0c03db2..52771b7 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/DatabaseTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/DatabaseTest.java
@@ -203,7 +203,7 @@ public class DatabaseTest extends BaseTestCase {
 			}
 		};
 
-		BTree btree = new BTree(pdom, Database.DATA_AREA, comparator);
+		BTree btree = new BTree(pdom, Database.DATA_AREA_OFFSET, comparator);
 		for (int i = 0; i < names.length; ++i) {
 			String name = names[i];
 			long record = db.malloc(8);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
index e79031c..0178aa1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/pdom/SearchKeyTests.java
@@ -39,7 +39,7 @@ public class SearchKeyTests extends BaseTestCase {
 		}
 
 		public static TestSearchIndex getIndex(Nd pdom) {
-			return new TestSearchIndex(pdom, Database.DATA_AREA);
+			return new TestSearchIndex(pdom, Database.DATA_AREA_OFFSET);
 		}
 
 		public Element findName(String searchString) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
index 569a3ee..724ba9a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
@@ -100,8 +100,10 @@ public class Database {
 	public static final long MAX_DB_SIZE= ((long) 1 << (Integer.SIZE + BLOCK_SIZE_DELTA_BITS));
 
 	public static final int VERSION_OFFSET = 0;
-	public static final int WRITE_NUMBER_OFFSET = (CHUNK_SIZE / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 2) * INT_SIZE;
-	public static final int DATA_AREA = WRITE_NUMBER_OFFSET + LONG_SIZE;
+	private static final int MALLOC_TABLE_OFFSET = VERSION_OFFSET + INT_SIZE;
+	public static final int WRITE_NUMBER_OFFSET = MALLOC_TABLE_OFFSET
+			+ (CHUNK_SIZE / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 1) * INT_SIZE;
+	public static final int DATA_AREA_OFFSET = WRITE_NUMBER_OFFSET + LONG_SIZE;
 
 	private final File fLocation;
 	private final boolean fReadOnly;
@@ -437,14 +439,17 @@ public class Database {
 		}
 	}
 
+	/**
+	 * @param blocksize (must be a multiple of BLOCK_SIZE_DELTA)
+	 */
 	private long getFirstBlock(int blocksize) throws IndexException {
 		assert this.fLocked;
-		return this.fHeaderChunk.getFreeRecPtr((blocksize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 1) * INT_SIZE);
+		return this.fHeaderChunk.getFreeRecPtr(MALLOC_TABLE_OFFSET + (blocksize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS) * INT_SIZE);
 	}
 
 	private void setFirstBlock(int blocksize, long block) throws IndexException {
 		assert this.fExclusiveLock;
-		this.fHeaderChunk.putFreeRecPtr((blocksize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS + 1) * INT_SIZE, block);
+		this.fHeaderChunk.putFreeRecPtr(MALLOC_TABLE_OFFSET + (blocksize / BLOCK_SIZE_DELTA - MIN_BLOCK_DELTAS) * INT_SIZE, block);
 	}
 
 	private void removeBlock(Chunk chunk, int blocksize, long block) throws IndexException {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
index a882443..c93116e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/field/FieldSearchKey.java
@@ -61,7 +61,7 @@ public class FieldSearchKey<T> implements IField, IDestructableField {
 		cleanup(pdom, address);
 
 		Database db = pdom.getDB();
-		BTree btree = this.searchIndex.get(pdom, Database.DATA_AREA);
+		BTree btree = this.searchIndex.get(pdom, Database.DATA_AREA_OFFSET);
 		db.putRecPtr(address + this.offset, db.newString(newString).getRecord());
 		btree.insert(address);
 	}
@@ -86,7 +86,7 @@ public class FieldSearchKey<T> implements IField, IDestructableField {
 
 		if (isInIndex) {
 			// Remove this entry from the search index
-			this.searchIndex.get(pdom, Database.DATA_AREA).delete(address);
+			this.searchIndex.get(pdom, Database.DATA_AREA_OFFSET).delete(address);
 
 			get(pdom, address).delete();
 			pdom.getDB().putRecPtr(address + this.offset, 0);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index 1ce5bf7..592ecc9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -215,7 +215,7 @@ public class JavaIndex {
 	}
 
 	public static JavaIndex getIndex(Nd pdom) {
-		return new JavaIndex(pdom, Database.DATA_AREA);
+		return new JavaIndex(pdom, Database.DATA_AREA_OFFSET);
 	}
 
 	public static JavaIndex getIndex() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
index 5dc8737..d491ac5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdResourceFile.java
@@ -82,7 +82,7 @@ public class NdResourceFile extends NdTreeNode {
 
 			char[] filename = FILENAME.get(getNd(), this.address).getChars();
 
-			NdResourceFile result = JavaIndex.FILES.findBest(pdom, Database.DATA_AREA,
+			NdResourceFile result = JavaIndex.FILES.findBest(pdom, Database.DATA_AREA_OFFSET,
 					SearchCriteria.create(filename), new IResultRank() {
 						@Override
 						public long getRank(Nd testPdom, long testAddress) {
