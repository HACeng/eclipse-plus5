commit 6b2eaccbd1d9579997548e9877abcafa55f36650
Author: David Audel <daudel>
Date:   Thu Apr 12 09:23:36 2007 +0000

    HEAD - bug 177174

248	41	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
0	27	org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionCastIsParent1.java
0	5	org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionCastIsParent2.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
50	77	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
95	99	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
122	71	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
0	83	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
3	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
index 43e8eb7..fd8b776 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
@@ -2512,59 +2512,95 @@ public void testCompletionCaseInsensitivePackage() throws JavaModelException {
 
 
 public void testCompletionCastIsParent1() throws JavaModelException {
-	CompletionTestsRequestor requestor = new CompletionTestsRequestor();
-	ICompilationUnit cu= getCompilationUnit("Completion", "src", "", "CompletionCastIsParent1.java");
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/CompletionCastIsParent1.java.java",
+		"public class CompletionCastIsParent1 {\n"+
+		"	Object zzOb;\n"+
+		"	XX00 zz00;\n"+
+		"	XX01 zz01;\n"+
+		"	XX02 zz02;\n"+
+		"	XX10 zz10;\n"+
+		"	XX11 zz11;\n"+
+		"	XX12 zz12;\n"+
+		"	XX20 zz20;\n"+
+		"	XX21 zz21;\n"+
+		"	XX22 zz22;\n"+
+		"	\n"+
+		"	Object zzObM(){}\n"+
+		"	XX00 zz00M(){}\n"+
+		"	XX01 zz01M(){}\n"+
+		"	XX02 zz02M(){}\n"+
+		"	XX10 zz10M(){}\n"+
+		"	XX11 zz11M(){}\n"+
+		"	XX12 zz12M(){}\n"+
+		"	XX20 zz20M(){}\n"+
+		"	XX21 zz21M(){}\n"+
+		"	XX22 zz22M(){}\n"+
+		"	\n"+
+		"	XX11 foo() {\n"+
+		"		return (XX11)zz\n"+
+		"	}\n"+
+		"}\n");
 
-	String str = cu.getSource();
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	String str = this.workingCopies[0].getSource();
 	String completeBehind = "zz";
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
-	cu.codeComplete(cursorLocation, requestor);
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
-	assertEquals(
-		"element:zz00    completion:zz00    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz00M    completion:zz00M()    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz01    completion:zz01    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz01M    completion:zz01M()    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz02    completion:zz02    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz02M    completion:zz02M()    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz10    completion:zz10    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz10M    completion:zz10M()    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz11    completion:zz11    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz11M    completion:zz11M()    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz12    completion:zz12    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz12M    completion:zz12M()    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz20    completion:zz20    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz20M    completion:zz20M()    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz21    completion:zz21    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz21M    completion:zz21M()    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz22    completion:zz22    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zz22M    completion:zz22M()    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zzOb    completion:zzOb    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:zzObM    completion:zzObM()    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED+ R_NON_RESTRICTED),
-		requestor.getResults());
+	assertResults(
+			"zz00[FIELD_REF]{zz00, LCompletionCastIsParent1;, LXX00;, zz00, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz00M[METHOD_REF]{zz00M(), LCompletionCastIsParent1;, ()LXX00;, zz00M, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz02[FIELD_REF]{zz02, LCompletionCastIsParent1;, LXX02;, zz02, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz02M[METHOD_REF]{zz02M(), LCompletionCastIsParent1;, ()LXX02;, zz02M, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz10[FIELD_REF]{zz10, LCompletionCastIsParent1;, LXX10;, zz10, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz10M[METHOD_REF]{zz10M(), LCompletionCastIsParent1;, ()LXX10;, zz10M, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz12[FIELD_REF]{zz12, LCompletionCastIsParent1;, LXX12;, zz12, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz12M[METHOD_REF]{zz12M(), LCompletionCastIsParent1;, ()LXX12;, zz12M, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz20[FIELD_REF]{zz20, LCompletionCastIsParent1;, LXX20;, zz20, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz20M[METHOD_REF]{zz20M(), LCompletionCastIsParent1;, ()LXX20;, zz20M, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz22[FIELD_REF]{zz22, LCompletionCastIsParent1;, LXX22;, zz22, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz22M[METHOD_REF]{zz22M(), LCompletionCastIsParent1;, ()LXX22;, zz22M, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz01[FIELD_REF]{zz01, LCompletionCastIsParent1;, LXX01;, zz01, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz01M[METHOD_REF]{zz01M(), LCompletionCastIsParent1;, ()LXX01;, zz01M, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz21[FIELD_REF]{zz21, LCompletionCastIsParent1;, LXX21;, zz21, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz21M[METHOD_REF]{zz21M(), LCompletionCastIsParent1;, ()LXX21;, zz21M, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zzOb[FIELD_REF]{zzOb, LCompletionCastIsParent1;, Ljava.lang.Object;, zzOb, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zzObM[METHOD_REF]{zzObM(), LCompletionCastIsParent1;, ()Ljava.lang.Object;, zzObM, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz11[FIELD_REF]{zz11, LCompletionCastIsParent1;, LXX11;, zz11, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"zz11M[METHOD_REF]{zz11M(), LCompletionCastIsParent1;, ()LXX11;, zz11M, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
 }
 
 
 public void testCompletionCastIsParent2() throws JavaModelException {
-	CompletionTestsRequestor requestor = new CompletionTestsRequestor();
-	ICompilationUnit cu= getCompilationUnit("Completion", "src", "", "CompletionCastIsParent2.java");
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/CompletionCastIsParent2.java.java",
+		"public class CompletionCastIsParent2 {\n"+
+		"	XX11 foo() {\n"+
+		"		return (XX11)xx\n"+
+		"	}\n"+
+		"}\n");
 
-	String str = cu.getSource();
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	String str = this.workingCopies[0].getSource();
 	String completeBehind = "xx";
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
-	cu.codeComplete(cursorLocation, requestor);
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
-	assertEquals(
-		"element:XX00    completion:XX00    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:XX01    completion:XX01    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:XX02    completion:XX02    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:XX10    completion:XX10    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:XX11    completion:XX11    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:XX12    completion:XX12    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:XX20    completion:XX20    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:XX21    completion:XX21    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"\n" +
-		"element:XX22    completion:XX22    relevance:"+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED+ R_NON_RESTRICTED),
-		requestor.getResults());
+	assertResults(
+			"XX00[TYPE_REF]{XX00, , LXX00;, null, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"XX01[TYPE_REF]{XX01, , LXX01;, null, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"XX02[TYPE_REF]{XX02, , LXX02;, null, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"XX10[TYPE_REF]{XX10, , LXX10;, null, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"XX12[TYPE_REF]{XX12, , LXX12;, null, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"XX20[TYPE_REF]{XX20, , LXX20;, null, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"XX21[TYPE_REF]{XX21, , LXX21;, null, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"XX22[TYPE_REF]{XX22, , LXX22;, null, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+			"XX11[TYPE_REF]{XX11, , LXX11;, null, null, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_EXACT_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
 }
 
 public void testCompletionCatchArgumentName() throws JavaModelException {
@@ -15669,6 +15705,177 @@ public void testNameWithUnresolvedReferences011() throws JavaModelException {
 			"zzz1[LOCAL_VARIABLE_REF]{zzz1, null, Ljava.lang.Object;, zzz1, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
 			requestor.getResults());
 }
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177174
+public void testNameWithUnresolvedReferences012() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"   void foo() {\n" +
+			"      zzzlala = 0;\n" +
+			"      zzzlabel : {\n" +
+			"        /**/zzzla\n" +
+			"      }\n" +
+			"   }\n" +
+			"}\n");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "/**/zzzla";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	assertResults(
+			"zzzlala[LOCAL_VARIABLE_REF]{zzzlala, null, Ljava.lang.Object;, zzzlala, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177174
+public void testNameWithUnresolvedReferences013() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"   void foo() {\n" +
+			"      zzzlala = 0;\n" +
+			"      zzzlabel1 : {\n" +
+			"        /**/zzzla\n" +
+			"        {\n" +
+			"          break zzzlabel2;\n" +
+			"        }\n" +
+			"      }\n" +
+			"   }\n" +
+			"}\n");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "/**/zzzla";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	assertResults(
+			"zzzlala[LOCAL_VARIABLE_REF]{zzzlala, null, Ljava.lang.Object;, zzzlala, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177174
+public void testNameWithUnresolvedReferences014() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"   void foo() {\n" +
+			"      {\n" +
+			"        break;\n" +
+			"      }\n" +
+			"      zzznotlabel = 25;\n" +
+			"      {\n" +
+			"        /**/zzznotla\n" +
+			"      }\n" +
+			"   }\n" +
+			"}\n");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "/**/zzznotla";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	assertResults(
+			"zzznotlabel[LOCAL_VARIABLE_REF]{zzznotlabel, null, Ljava.lang.Object;, zzznotlabel, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177174
+public void testNameWithUnresolvedReferences015() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"   int foo() {\n" +
+			"      zzz1 = 0;\n" +
+			"      if (false) return (ZZZ2) var;\n" +
+			"      zz\n" +
+			"   }\n" +
+			"}\n");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "zz";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	assertResults(
+			"zzz1[LOCAL_VARIABLE_REF]{zzz1, null, Ljava.lang.Object;, zzz1, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177174
+public void testNameWithUnresolvedReferences016() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"   int foo() {\n" +
+			"      zzz1 = 0;\n" +
+			"      return (zzz2) zz;\n" +
+			"   }\n" +
+			"}\n");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "zz";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	assertResults(
+			"zzz1[LOCAL_VARIABLE_REF]{zzz1, null, Ljava.lang.Object;, zzz1, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177174
+public void testNameWithUnresolvedReferences017() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"   void foo() {\n" +
+			"      {\n" +
+			"         final int zzz1 = 0;\n" +
+			"         class Local {\n" +
+			"            void bar() {n" +
+			"               zzz1 = 24;\n" +
+			"               zzz2 = 24;\n" +
+			"            }\n" +
+			"         }\n" +
+			"      }\n" +
+			"      zz\n" +
+			"   }\n" +
+			"}\n");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "zz";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	assertResults(
+			"zzz2[LOCAL_VARIABLE_REF]{zzz2, null, Ljava.lang.Object;, zzz2, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
 public void testParameterNames1() throws CoreException, IOException {
 	Hashtable options = JavaCore.getOptions();
 	Object timeout = options.get(JavaCore.TIMEOUT_FOR_PARAMETER_NAME_FROM_ATTACHED_JAVADOC);
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionCastIsParent1.java b/org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionCastIsParent1.java
deleted file mode 100644
index 624689c..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionCastIsParent1.java
+++ /dev/null
@@ -1,27 +0,0 @@
-public class CompletionCastIsParent1 {
-	Object zzOb;
-	XX00 zz00;
-	XX01 zz01;
-	XX02 zz02;
-	XX10 zz10;
-	XX11 zz11;
-	XX12 zz12;
-	XX20 zz20;
-	XX21 zz21;
-	XX22 zz22;
-	
-	Object zzObM(){}
-	XX00 zz00M(){}
-	XX01 zz01M(){}
-	XX02 zz02M(){}
-	XX10 zz10M(){}
-	XX11 zz11M(){}
-	XX12 zz12M(){}
-	XX20 zz20M(){}
-	XX21 zz21M(){}
-	XX22 zz22M(){}
-	
-	XX11 foo() {
-		return (XX11)zz
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionCastIsParent2.java b/org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionCastIsParent2.java
deleted file mode 100644
index e72fef4..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/Completion/src/CompletionCastIsParent2.java
+++ /dev/null
@@ -1,5 +0,0 @@
-public class CompletionCastIsParent2 {
-	XX11 foo() {
-		return (XX11)xx
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 1c2c796..4b8f488 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -52,7 +52,9 @@ Eclipse SDK 3.3M7 - %date%
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=181727">181727</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=177174">177174</a>
+[assist] Wrong names are proposed as unresolved local variable
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=181727">181727</a>
 [perfs] JDT/Core performances tests last too long on slowest releng test boxes
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=180109">180109</a>
 [compiler] JDT Throws ClassCastException on incremental build
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 8061e2c..23e927d 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -220,6 +220,11 @@ public final class CompletionEngine
 	private final static char[] ON_DEMAND = ".*".toCharArray();  //$NON-NLS-1$
 	private final static char[] IMPORT_END = ";\n".toCharArray();  //$NON-NLS-1$
 	
+	private final static char[] JAVA_LANG_OBJECT_SIGNATURE = 
+		createTypeSignature(CharOperation.concatWith(JAVA_LANG, '.'), OBJECT);
+	private final static char[] JAVA_LANG_NAME =
+		CharOperation.concatWith(JAVA_LANG, '.');
+	
 	private final static int NONE = 0;
 	private final static int SUPERTYPE = 1;
 	private final static int SUBTYPE = 2;
@@ -629,6 +634,31 @@ public final class CompletionEngine
 		}
 		this.acceptedTypes = null; // reset
 	}
+	
+	public void acceptUnresolvedName(char[] name) {
+		int relevance = computeBaseRelevance();
+		relevance += computeRelevanceForResolution(false);
+		relevance += computeRelevanceForInterestingProposal();
+		relevance += computeRelevanceForCaseMatching(completionToken, name);
+		relevance += computeRelevanceForQualification(false);
+		relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for local variable
+		CompletionEngine.this.noProposal = false;
+		if(!CompletionEngine.this.requestor.isIgnored(CompletionProposal.LOCAL_VARIABLE_REF)) {
+			CompletionProposal proposal = CompletionEngine.this.createProposal(CompletionProposal.LOCAL_VARIABLE_REF, CompletionEngine.this.actualCompletionPosition);
+			proposal.setSignature(JAVA_LANG_OBJECT_SIGNATURE);
+			proposal.setPackageName(JAVA_LANG_NAME);
+			proposal.setTypeName(OBJECT);
+			proposal.setName(name);
+			proposal.setCompletion(name);
+			proposal.setFlags(Flags.AccDefault);
+			proposal.setReplaceRange(CompletionEngine.this.startPosition - CompletionEngine.this.offset, CompletionEngine.this.endPosition - CompletionEngine.this.offset);
+			proposal.setRelevance(relevance);
+			CompletionEngine.this.requestor.accept(proposal);
+			if(DEBUG) {
+				CompletionEngine.this.printDebug(proposal);
+			}
+		}
+	}
 
 	// this code is derived from MethodBinding#areParametersCompatibleWith(TypeBinding[])
 	private final boolean areParametersCompatibleWith(TypeBinding[] parameters, TypeBinding[] arguments, boolean isVarargs) {
@@ -892,7 +922,7 @@ public final class CompletionEngine
 					char[][] alreadyDefinedName = computeAlreadyDefinedName((BlockScope)scope, singleNameReference);
 					
 					findUnresolvedReference(
-							singleNameReference.sourceStart - 1,
+							singleNameReference.sourceStart,
 							singleNameReference.sourceEnd,
 							(BlockScope)scope,
 							alreadyDefinedName);
@@ -1449,7 +1479,7 @@ public final class CompletionEngine
 							char[][] alreadyDefinedName = computeAlreadyDefinedName((BlockScope)scope, FakeInvocationSite);
 							
 							findUnresolvedReference(
-									memberValuePair.sourceStart - 1,
+									memberValuePair.sourceStart,
 									memberValuePair.sourceEnd,
 									(BlockScope)scope,
 									alreadyDefinedName);
@@ -7111,16 +7141,11 @@ public final class CompletionEngine
 				type.resolvedType != null &&
 				type.resolvedType.problemId() == ProblemReasons.NoError){
 			
-			final int discouragedNamesCount = discouragedNames == null ? 0 : discouragedNames.length;
 			final ArrayList proposedNames = new ArrayList();
 			
 			UnresolvedReferenceNameFinder.UnresolvedReferenceNameRequestor nameRequestor = 
 				new UnresolvedReferenceNameFinder.UnresolvedReferenceNameRequestor() {
 					public void acceptName(char[] name) {
-						for (int i = 0; i < discouragedNamesCount; i++) {
-							if (CharOperation.equals(discouragedNames[i], name, false)) return;
-						}
-						
 						int relevance = computeBaseRelevance();
 						relevance += computeRelevanceForInterestingProposal();
 						relevance += computeRelevanceForCaseMatching(completionToken, name);
@@ -7159,6 +7184,7 @@ public final class CompletionEngine
 						completionToken,
 						md,
 						variable.declarationSourceEnd + 1,
+						discouragedNames,
 						nameRequestor);
 			} else if (referenceContext instanceof TypeDeclaration) {
 				TypeDeclaration typeDeclaration = (TypeDeclaration) referenceContext;
@@ -7175,6 +7201,7 @@ public final class CompletionEngine
 										initializer,
 										typeDeclaration.scope,
 										variable.declarationSourceEnd + 1,
+										discouragedNames,
 										nameRequestor);
 								break done;
 							}
@@ -7193,42 +7220,12 @@ public final class CompletionEngine
 	}
 	
 	private char[][] findUnresolvedReferenceAfter(int from, BlockScope scope, final char[][] discouragedNames) {
-		final int discouragedNamesCount = discouragedNames == null ? 0 : discouragedNames.length;
 		final ArrayList proposedNames = new ArrayList();
 		
 		UnresolvedReferenceNameFinder.UnresolvedReferenceNameRequestor nameRequestor = 
 			new UnresolvedReferenceNameFinder.UnresolvedReferenceNameRequestor() {
 				public void acceptName(char[] name) {
-					for (int i = 0; i < discouragedNamesCount; i++) {
-						if (CharOperation.equals(discouragedNames[i], name, false)) return;
-					}
-					
-					int relevance = computeBaseRelevance();
-					relevance += computeRelevanceForResolution(false);
-					relevance += computeRelevanceForInterestingProposal();
-					relevance += computeRelevanceForCaseMatching(completionToken, name);
-					relevance += computeRelevanceForQualification(false);
-					relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for local variable
-					CompletionEngine.this.noProposal = false;
-					if(!CompletionEngine.this.requestor.isIgnored(CompletionProposal.LOCAL_VARIABLE_REF)) {
-						CompletionProposal proposal = CompletionEngine.this.createProposal(CompletionProposal.LOCAL_VARIABLE_REF, CompletionEngine.this.actualCompletionPosition);
-						proposal.setSignature(
-							createTypeSignature(
-									CharOperation.concatWith(JAVA_LANG, '.'),
-									OBJECT));
-						proposal.setPackageName(CharOperation.concatWith(JAVA_LANG, '.'));
-						proposal.setTypeName(OBJECT);
-						proposal.setName(name);
-						proposal.setCompletion(name);
-						proposal.setFlags(Flags.AccDefault);
-						proposal.setReplaceRange(CompletionEngine.this.startPosition - CompletionEngine.this.offset, CompletionEngine.this.endPosition - CompletionEngine.this.offset);
-						proposal.setRelevance(relevance);
-						CompletionEngine.this.requestor.accept(proposal);
-						if(DEBUG) {
-							CompletionEngine.this.printDebug(proposal);
-						}
-					}
-					
+					CompletionEngine.this.acceptUnresolvedName(name);
 					proposedNames.add(name);
 				}
 			};
@@ -7244,6 +7241,7 @@ public final class CompletionEngine
 					md.scope.classScope(),
 					from,
 					md.bodyEnd,
+					discouragedNames,
 					nameRequestor);
 		} else if (referenceContext instanceof TypeDeclaration) {
 			TypeDeclaration typeDeclaration = (TypeDeclaration) referenceContext;
@@ -7261,6 +7259,7 @@ public final class CompletionEngine
 										typeDeclaration.scope,
 										from,
 										initializer.bodyEnd,
+										discouragedNames,
 										nameRequestor);
 							break done;
 						}
@@ -7277,8 +7276,8 @@ public final class CompletionEngine
 		return null;
 	}
 	
-	private void findUnresolvedReference(int beforeIndex, int afterIndex, BlockScope scope, char[][] discouragedNames) {
-		char[][] foundNames = findUnresolvedReferenceBefore(beforeIndex, scope, discouragedNames);
+	private void findUnresolvedReference(int completedNameStart, int completedNameEnd, BlockScope scope, char[][] discouragedNames) {
+		char[][] foundNames = findUnresolvedReferenceBefore(completedNameStart - 1, completedNameEnd, scope, discouragedNames);
 		if (foundNames != null && foundNames.length > 1) {
 			int discouragedNamesLength = discouragedNames.length;
 			int foundNamesLength = foundNames.length;
@@ -7286,46 +7285,16 @@ public final class CompletionEngine
 			System.arraycopy(discouragedNames, 0, discouragedNames = new char[newLength][], 0, discouragedNamesLength);
 			System.arraycopy(foundNames, 0, discouragedNames, discouragedNamesLength, foundNamesLength);
 		}
-		findUnresolvedReferenceAfter(afterIndex, scope, discouragedNames);
+		findUnresolvedReferenceAfter(completedNameEnd + 1, scope, discouragedNames);
 	}
 	
-	private char[][] findUnresolvedReferenceBefore(int to, BlockScope scope, final char[][] discouragedNames) {
-		final int discouragedNamesCount = discouragedNames == null ? 0 : discouragedNames.length;
+	private char[][] findUnresolvedReferenceBefore(int recordTo, int parseTo, BlockScope scope, final char[][] discouragedNames) {
 		final ArrayList proposedNames = new ArrayList();
 		
 		UnresolvedReferenceNameFinder.UnresolvedReferenceNameRequestor nameRequestor = 
 			new UnresolvedReferenceNameFinder.UnresolvedReferenceNameRequestor() {
 				public void acceptName(char[] name) {
-					for (int i = 0; i < discouragedNamesCount; i++) {
-						if (CharOperation.equals(discouragedNames[i], name, false)) return;
-					}
-					
-					int relevance = computeBaseRelevance();
-					relevance += computeRelevanceForResolution(false);
-					relevance += computeRelevanceForInterestingProposal();
-					relevance += computeRelevanceForCaseMatching(completionToken, name);
-					relevance += computeRelevanceForQualification(false);
-					relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for local variable
-					CompletionEngine.this.noProposal = false;
-					if(!CompletionEngine.this.requestor.isIgnored(CompletionProposal.LOCAL_VARIABLE_REF)) {
-						CompletionProposal proposal = CompletionEngine.this.createProposal(CompletionProposal.LOCAL_VARIABLE_REF, CompletionEngine.this.actualCompletionPosition);
-						proposal.setSignature(
-							createTypeSignature(
-									CharOperation.concatWith(JAVA_LANG, '.'),
-									OBJECT));
-						proposal.setPackageName(CharOperation.concatWith(JAVA_LANG, '.'));
-						proposal.setTypeName(OBJECT);
-						proposal.setName(name);
-						proposal.setCompletion(name);
-						proposal.setFlags(Flags.AccDefault);
-						proposal.setReplaceRange(CompletionEngine.this.startPosition - CompletionEngine.this.offset, CompletionEngine.this.endPosition - CompletionEngine.this.offset);
-						proposal.setRelevance(relevance);
-						CompletionEngine.this.requestor.accept(proposal);
-						if(DEBUG) {
-							CompletionEngine.this.printDebug(proposal);
-						}
-					}
-					
+					CompletionEngine.this.acceptUnresolvedName(name);
 					proposedNames.add(name);
 				}
 			};
@@ -7345,7 +7314,9 @@ public final class CompletionEngine
 					md.scope,
 					md.scope.classScope(),
 					md.bodyStart,
-					to,
+					recordTo,
+					parseTo,
+					discouragedNames,
 					nameRequestor);
 		} else if (referenceContext instanceof TypeDeclaration) {
 			TypeDeclaration typeDeclaration = (TypeDeclaration) referenceContext;
@@ -7357,8 +7328,8 @@ public final class CompletionEngine
 					for (int i = 0; i < fields.length; i++) {
 						if (fields[i] instanceof Initializer) {
 							Initializer initializer = (Initializer) fields[i];
-							if (initializer.block.sourceStart <= to &&
-									to < initializer.bodyEnd) {
+							if (initializer.block.sourceStart <= recordTo &&
+									recordTo < initializer.bodyEnd) {
 					
 								UnresolvedReferenceNameFinder nameFinder = new UnresolvedReferenceNameFinder(this);
 								nameFinder.findBefore(
@@ -7366,7 +7337,9 @@ public final class CompletionEngine
 										typeDeclaration.scope,
 										typeDeclaration.scope,
 										initializer.block.sourceStart,
-										to,
+										recordTo,
+										parseTo,
+										discouragedNames,
 										nameRequestor);
 								break done;
 							}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
index 2bc8f68..58e4820 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/UnresolvedReferenceNameFinder.java
@@ -34,7 +34,7 @@ import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	private static final int MAX_LINE_COUNT = 100;
-	private static final int FAKE_BLOCKS_COUNT = 50;
+	private static final int FAKE_BLOCKS_COUNT = 20;
 	
 	public static interface UnresolvedReferenceNameRequestor {
 		public void acceptName(char[] name);
@@ -42,6 +42,7 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	
 	private UnresolvedReferenceNameRequestor requestor;
 	
+	private CompletionEngine completionEngine;
 	private CompletionParser parser;
 	private CompletionScanner completionScanner;
 	
@@ -55,6 +56,7 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	private SimpleSetOfCharArray acceptedNames = new SimpleSetOfCharArray();
 	
 	public UnresolvedReferenceNameFinder(CompletionEngine completionEngine) {
+		this.completionEngine = completionEngine;
 		this.parser = completionEngine.parser;
 		this.completionScanner = (CompletionScanner) parser.scanner;
 	} 
@@ -62,6 +64,9 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	private void acceptName(char[] name) {
 		// the null check is added to fix bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=166570
 		if (name == null) return;
+						
+		if (!CharOperation.prefixEquals(this.completionEngine.completionToken, name, false /* ignore case */)
+				&& !(this.completionEngine.options.camelCaseMatch && CharOperation.camelCaseMatch(this.completionEngine.completionToken, name))) return;
 		
 		if (acceptedNames.includes(name)) return;
 		
@@ -71,18 +76,39 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 		this.requestor.acceptName(name);
 	}
 	
-	public void find(char[] startWith, Initializer initializer, ClassScope scope, int from, UnresolvedReferenceNameRequestor nameRequestor) {
-		MethodDeclaration fakeMethod = this.findAfter(startWith, scope, from, initializer.bodyEnd, MAX_LINE_COUNT, false, nameRequestor);
+	public void find(
+			char[] startWith,
+			Initializer initializer,
+			ClassScope scope,
+			int from,
+			char[][] discouragedNames,
+			UnresolvedReferenceNameRequestor nameRequestor) {
+		MethodDeclaration fakeMethod = 
+			this.findAfter(startWith, scope, from, initializer.bodyEnd, MAX_LINE_COUNT, false, discouragedNames, nameRequestor);
 		if (fakeMethod != null) fakeMethod.traverse(this, scope);
 	}
 	
-	public void find(char[] startWith, AbstractMethodDeclaration methodDeclaration, int from, UnresolvedReferenceNameRequestor nameRequestor) {
-		MethodDeclaration fakeMethod = this.findAfter(startWith, methodDeclaration.scope, from, methodDeclaration.bodyEnd, MAX_LINE_COUNT, false, nameRequestor);
+	public void find(
+			char[] startWith,
+			AbstractMethodDeclaration methodDeclaration,
+			int from,
+			char[][] discouragedNames,
+			UnresolvedReferenceNameRequestor nameRequestor) {
+		MethodDeclaration fakeMethod = 
+			this.findAfter(startWith, methodDeclaration.scope, from, methodDeclaration.bodyEnd, MAX_LINE_COUNT, false, discouragedNames, nameRequestor);
 		if (fakeMethod != null) fakeMethod.traverse(this, methodDeclaration.scope.classScope());
 	}
 	
-	public void findAfter(char[] startWith, Scope scope, ClassScope classScope, int from, int to, UnresolvedReferenceNameRequestor nameRequestor) {
-		MethodDeclaration fakeMethod = this.findAfter(startWith, scope, from, to, MAX_LINE_COUNT / 2, true, nameRequestor);
+	public void findAfter(
+			char[] startWith,
+			Scope scope,
+			ClassScope classScope,
+			int from,
+			int to,
+			char[][] discouragedNames,
+			UnresolvedReferenceNameRequestor nameRequestor) {
+		MethodDeclaration fakeMethod =
+			this.findAfter(startWith, scope, from, to, MAX_LINE_COUNT / 2, true, discouragedNames, nameRequestor);
 		if (fakeMethod != null) fakeMethod.traverse(this, classScope);
 	}
 	
@@ -93,15 +119,13 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 			int to,
 			int maxLineCount,
 			boolean outsideEnclosingBlock,
+			char[][] discouragedNames,
 			UnresolvedReferenceNameRequestor nameRequestor) {
 		this.requestor = nameRequestor;
 		
 		// reinitialize completion scanner to be usable as a normal scanner
 		this.completionScanner.cursorLocation = 0;
 		
-		// reinitialize completionIdentifier
-		this.completionScanner.prefix = startWith;
-		
 		if (!outsideEnclosingBlock) {
 			// compute location of the end of the current block
 			this.completionScanner.resetTo(from + 1, to);
@@ -121,7 +145,7 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 			end = maxEnd < to ? maxEnd : to;
 		}
 		
-		this.completionScanner.startRecordingIdentifiers();
+		this.parser.startRecordingIdentifiers(from, end);
 		
 		MethodDeclaration fakeMethod = this.parser.parseSomeStatements(
 				from,
@@ -129,9 +153,9 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 				outsideEnclosingBlock ? FAKE_BLOCKS_COUNT : 0,
 				s.compilationUnitScope().referenceContext);
 		
-		this.completionScanner.stopRecordingIdentifiers();
+		this.parser.stopRecordingIdentifiers();
 		
-		if(!this.initPotentialNamesTables()) return null;
+		if(!this.initPotentialNamesTables(discouragedNames)) return null;
 		
 		this.parentsPtr = -1;
 		this.parents = new ASTNode[10];
@@ -139,8 +163,17 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 		return fakeMethod;
 	}
 	
-	public void findBefore(char[] startWith, Scope scope, ClassScope classScope, int from, int to, UnresolvedReferenceNameRequestor nameRequestor) {
-		MethodDeclaration fakeMethod = this.findBefore(startWith, scope, from, to, MAX_LINE_COUNT / 2, nameRequestor);
+	public void findBefore(
+			char[] startWith,
+			Scope scope,
+			ClassScope classScope,
+			int from,
+			int recordTo,
+			int parseTo,
+			char[][] discouragedNames,
+			UnresolvedReferenceNameRequestor nameRequestor) {
+		MethodDeclaration fakeMethod =
+			this.findBefore(startWith, scope, from, recordTo, parseTo, MAX_LINE_COUNT / 2, discouragedNames, nameRequestor);
 		if (fakeMethod != null) fakeMethod.traverse(this, classScope);
 	}
 	
@@ -148,20 +181,19 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 			char[] startWith,
 			Scope s,
 			int from,
-			int to,
+			int recordTo,
+			int parseTo,
 			int maxLineCount,
+			char[][] discouragedNames,
 			UnresolvedReferenceNameRequestor nameRequestor) {
 		this.requestor = nameRequestor;
 		
 		// reinitialize completion scanner to be usable as a normal scanner
 		this.completionScanner.cursorLocation = 0;
 		
-		// reinitialize completionIdentifier
-		this.completionScanner.prefix = startWith;
-		
 		int minStart =
 			this.completionScanner.getLineStart(
-					Util.getLineNumber(to, this.completionScanner.lineEnds, 0, this.completionScanner.linePtr) - maxLineCount);
+					Util.getLineNumber(recordTo, this.completionScanner.lineEnds, 0, this.completionScanner.linePtr) - maxLineCount);
 		
 		int start;
 		int fakeBlocksCount;
@@ -173,17 +205,17 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 			fakeBlocksCount = FAKE_BLOCKS_COUNT;
 		}
 		
-		this.completionScanner.startRecordingIdentifiers();
+		this.parser.startRecordingIdentifiers(start, recordTo);
 		
 		MethodDeclaration fakeMethod = this.parser.parseSomeStatements(
 				start,
-				to,
+				parseTo,
 				fakeBlocksCount,
 				s.compilationUnitScope().referenceContext);
 		
-		this.completionScanner.stopRecordingIdentifiers();
+		this.parser.stopRecordingIdentifiers();
 		
-		if(!this.initPotentialNamesTables()) return null;
+		if(!this.initPotentialNamesTables(discouragedNames)) return null;
 		
 		this.parentsPtr = -1;
 		this.parents = new ASTNode[10];
@@ -191,47 +223,34 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 		return fakeMethod;
 	}
 	
-	private boolean initPotentialNamesTables() {
-		char[][] pvns = this.completionScanner.potentialVariableNames;
-		int[] pvnss = this.completionScanner.potentialVariableNameStarts;
-		int pvnsPtr = this.completionScanner.potentialVariableNamesPtr;
+	private boolean initPotentialNamesTables(char[][] discouragedNames) {
+		char[][] pvns = this.parser.potentialVariableNames;
+		int[] pvnss = this.parser.potentialVariableNameStarts;
+		int pvnsPtr = this.parser.potentialVariableNamesPtr;
 		
 		if (pvnsPtr < 0) return false; // there is no potential names
 		
-		// remove null
+		// remove null and discouragedNames
+		int discouragedNamesCount = discouragedNames == null ? 0 : discouragedNames.length;
 		int j = -1;
-		for (int i = 0; i <= pvnsPtr; i++) {
-			if (pvns[i] != null) {
-				char[] temp = pvns[i];
-				pvns[i] = null;
-				pvns[++j] = temp;
-				pvnss[j] = pvnss[i];
-				
-			}
-		}
-		pvnsPtr = j;
-		
-		if (pvnsPtr < 0) return false; // there is no potential names
-		
-		if (pvnsPtr > 0) {
-			// sort by position
-			quickSort(pvnss, pvns, 0, pvnsPtr);
+		next : for (int i = 0; i <= pvnsPtr; i++) {
+			char[] temp = pvns[i];
 			
-			// remove double
-			j = 0;
-			for (int i = 1; i <= pvnsPtr; i++) {
-				if (pvnss[i] != pvnss[j]) {
-					char[] temp = pvns[i];
-					pvns[i] = null;
-					pvns[++j] = temp;
-					pvnss[j] = pvnss[i];
-				} else {
-					pvns[i] = null;
+			if (temp == null) continue next;
+			
+			for (int k = 0; k < discouragedNamesCount; k++) {
+				if (CharOperation.equals(temp, discouragedNames[k], false)) {
+					continue next;
 				}
 			}
 			
-			pvnsPtr = j;
+			pvns[i] = null;
+			pvns[++j] = temp;
+			pvnss[j] = pvnss[i];
 		}
+		pvnsPtr = j;
+		
+		if (pvnsPtr < 0) return false; // there is no potential names
 		
 		this.potentialVariableNames = pvns;
 		this.potentialVariableNameStarts = pvnss;
@@ -240,38 +259,6 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 		return true;
 	}
 	
-	private static void quickSort(int[] list1, char[][] list2, int left, int right) {
-		int original_left= left;
-		int original_right= right;
-		int mid= list1[left + (right - left) / 2];
-		do {
-			while (list1[left] < mid) {
-				left++;
-			}
-			while (mid < list1[right]) {
-				right--;
-			}
-			if (left <= right) {
-				int tmp1= list1[left];
-				list1[left]= list1[right];
-				list1[right]= tmp1;
-				
-				char[] tmp2= list2[left];
-				list2[left]= list2[right];
-				list2[right]= tmp2;
-				
-				left++;
-				right--;
-			}
-		} while (left <= right);
-		if (original_left < right) {
-			quickSort(list1, list2, original_left, right);
-		}
-		if (left < original_right) {
-			quickSort(list1, list2, left, original_right);
-		}
-	}
-	
 	private void popParent() {
 		this.parentsPtr--;
 	}
@@ -302,11 +289,23 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	} 
 	
 	public boolean visit(Block block, BlockScope blockScope) {
+		ASTNode enclosingDeclaration = getEnclosingDeclaration();
+		removeLocals(block.statements, enclosingDeclaration.sourceStart, block.sourceEnd);
 		pushParent(block);
 		return true;
 	}
 	
 	public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope classScope) {
+		if (!constructorDeclaration.isDefaultConstructor && !constructorDeclaration.isClinit()) {
+			removeLocals(
+					constructorDeclaration.arguments,
+					constructorDeclaration.declarationSourceStart,
+					constructorDeclaration.declarationSourceEnd);
+			removeLocals(
+					constructorDeclaration.statements,
+					constructorDeclaration.declarationSourceStart,
+					constructorDeclaration.declarationSourceEnd);
+		}
 		pushParent(constructorDeclaration);
 		return true;
 	}
@@ -322,6 +321,14 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	}
 	
 	public boolean visit(MethodDeclaration methodDeclaration, ClassScope classScope) {
+		removeLocals(
+				methodDeclaration.arguments,
+				methodDeclaration.declarationSourceStart,
+				methodDeclaration.declarationSourceEnd);
+		removeLocals(
+				methodDeclaration.statements,
+				methodDeclaration.declarationSourceStart,
+				methodDeclaration.declarationSourceEnd);
 		pushParent(methodDeclaration);
 		return true;
 	}
@@ -339,8 +346,6 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	}
 	
 	public void endVisit(Block block, BlockScope blockScope) {
-		ASTNode enclosingDeclaration = getEnclosingDeclaration();
-		removeLocals(block.statements, enclosingDeclaration.sourceStart, block.sourceEnd);
 		popParent();
 	}
 	
@@ -375,14 +380,6 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	}
 	
 	public void endVisit(MethodDeclaration methodDeclaration, ClassScope classScope) {
-		removeLocals(
-				methodDeclaration.arguments,
-				methodDeclaration.declarationSourceStart,
-				methodDeclaration.declarationSourceEnd);
-		removeLocals(
-				methodDeclaration.statements,
-				methodDeclaration.declarationSourceStart,
-				methodDeclaration.declarationSourceEnd);
 		endVisitPreserved(
 				methodDeclaration.bodyStart,
 				methodDeclaration.bodyEnd);
@@ -390,7 +387,6 @@ public class UnresolvedReferenceNameFinder extends ASTVisitor {
 	}
 	
 	public void endVisit(TypeDeclaration typeDeclaration, BlockScope blockScope) {
-		removeFields(typeDeclaration);
 		endVisitRemoved(typeDeclaration.sourceStart, typeDeclaration.declarationSourceEnd);
 		popParent();
 	}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
index e103acc..441e903 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
@@ -28,7 +28,6 @@ import org.eclipse.jdt.internal.compiler.parser.*;
 import org.eclipse.jdt.internal.compiler.problem.*;
 import org.eclipse.jdt.internal.compiler.util.Util;
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.core.compiler.InvalidInputException;
 import org.eclipse.jdt.internal.codeassist.impl.*;
 
 public class CompletionParser extends AssistParser {
@@ -141,12 +140,62 @@ public class CompletionParser extends AssistParser {
 	int labelPtr = -1;
 
 	boolean isAlreadyAttached;
+	
+	public boolean record = false;
+	public boolean skipRecord = false;
+	public int recordFrom;
+	public int recordTo;
+	public int potentialVariableNamesPtr; 
+	public char[][] potentialVariableNames;
+	public int[] potentialVariableNameStarts;
+	public int[] potentialVariableNameEnds;
+	
 public CompletionParser(ProblemReporter problemReporter) {
 	super(problemReporter);
 	this.reportSyntaxErrorIsRequired = false;
-	this.javadocParser = new CompletionJavadocParser(this);
 	this.javadocParser.checkDocComment = true;
 }
+private void addPotentialName(char[] potentialVariableName, int start, int end) {
+	int length = this.potentialVariableNames.length;
+	if (this.potentialVariableNamesPtr >= length - 1) {
+		System.arraycopy(
+				this.potentialVariableNames, 
+				0,
+				this.potentialVariableNames = new char[length * 2][],
+				0,
+				length);
+		System.arraycopy(
+				this.potentialVariableNameStarts,
+				0,
+				this.potentialVariableNameStarts = new int[length * 2],
+				0,
+				length);
+		System.arraycopy(
+				this.potentialVariableNameEnds,
+				0,
+				this.potentialVariableNameEnds = new int[length * 2],
+				0,
+				length);
+	}
+	this.potentialVariableNames[++this.potentialVariableNamesPtr] = potentialVariableName;
+	this.potentialVariableNameStarts[this.potentialVariableNamesPtr] = start;
+	this.potentialVariableNameEnds[this.potentialVariableNamesPtr] = end;
+}
+public void startRecordingIdentifiers(int from, int to) {
+	this.record = true;
+	this.skipRecord = false;
+	this.recordFrom = from;
+	this.recordTo = to;
+	
+	this.potentialVariableNamesPtr = -1; 
+	this.potentialVariableNames = new char[10][];
+	this.potentialVariableNameStarts = new int[10];
+	this.potentialVariableNameEnds = new int[10];
+}
+public void stopRecordingIdentifiers() {
+	this.record = true;
+	this.skipRecord = false;
+}
 public char[] assistIdentifier(){
 	return ((CompletionScanner)scanner).completionIdentifier;
 }
@@ -2193,7 +2242,23 @@ protected void consumeInsideCastExpressionLL1() {
 	if(topKnownElementKind(COMPLETION_OR_ASSIST_PARSER) == K_PARAMETERIZED_CAST) {
 		popElement(K_PARAMETERIZED_CAST);
 	}
-	super.consumeInsideCastExpressionLL1();
+	if (!this.record) {
+		super.consumeInsideCastExpressionLL1();
+	} else {
+		boolean temp = this.skipRecord;
+		try {
+			this.skipRecord = true;
+			super.consumeInsideCastExpressionLL1();
+			if (this.record) {
+				Expression typeReference = this.expressionStack[this.expressionPtr];
+				if (!isAlreadyPotentialName(typeReference.sourceStart)) {
+					this.addPotentialName(null, typeReference.sourceStart, typeReference.sourceEnd);
+				}
+			}
+		} finally {
+			this.skipRecord = temp;
+		}
+	}
 	pushOnElementStack(K_CAST_STATEMENT);
 }
 protected void consumeInsideCastExpressionWithQualifiedGenerics() {
@@ -2594,6 +2659,16 @@ protected void consumeSingleMemberAnnotation() {
 	this.popElement(K_BETWEEN_ANNOTATION_NAME_AND_RPAREN);
 	super.consumeSingleMemberAnnotation();
 }
+protected void consumeStatementBreakWithLabel() {
+	super.consumeStatementBreakWithLabel();
+	if (this.record) {
+		ASTNode breakStatement = this.astStack[this.astPtr];
+		if (!isAlreadyPotentialName(breakStatement.sourceStart)) {
+			this.addPotentialName(null, breakStatement.sourceStart, breakStatement.sourceEnd);
+		}
+	}
+	
+}
 protected void consumeStatementLabel() {
 	this.popElement(K_LABEL);
 	super.consumeStatementLabel();
@@ -3622,13 +3697,33 @@ protected TypeReference getTypeReferenceForGenericType(int dim,	int identifierLe
 
 	return ref;
 }
+protected NameReference getUnspecifiedReference() {
+	NameReference nameReference = super.getUnspecifiedReference();
+	if (this.record) {
+		recordReference(nameReference);
+	}
+	return nameReference;
+}
 protected NameReference getUnspecifiedReferenceOptimized() {
 	if (this.identifierLengthStack[this.identifierLengthPtr] > 1) { // reducing a qualified name
 		// potential receiver is being poped, so reset potential receiver
 		this.invocationType = NO_RECEIVER;
 		this.qualifier = -1;
 	}
-	return super.getUnspecifiedReferenceOptimized();
+	NameReference nameReference = super.getUnspecifiedReferenceOptimized();
+	if (this.record) {
+		recordReference(nameReference);
+	}
+	return nameReference;
+}
+private boolean isAlreadyPotentialName(int identifierStart) {
+	if (this.potentialVariableNamesPtr < 0) return false;
+	
+	return identifierStart <= this.potentialVariableNameEnds[this.potentialVariableNamesPtr];
+}
+protected int indexOfAssistIdentifier(boolean useGenericsStack) {
+	if (this.record) return -1; // when names are recorded there is no assist identifier
+	return super.indexOfAssistIdentifier(useGenericsStack);
 }
 public void initialize() {
 	super.initialize();
@@ -3868,73 +3963,6 @@ private void pushCompletionOnMemberAccessOnExpressionStack(boolean isSuperAccess
 		expressionStack[expressionPtr] = fr;
 	}
 }
-protected boolean moveRecoveryCheckpoint() {
-	CompletionScanner completionScanner = (CompletionScanner) this.scanner;
-	boolean recordIdentifers = completionScanner.record;
-	if (!recordIdentifers) {
-		return super.moveRecoveryCheckpoint();
-	}
-
-	completionScanner.record = false;
-
-	int pos = this.lastCheckPoint;
-	int curTok = completionScanner.lastUsedToken;
-	int curTokStart = completionScanner.lastUsedTokenStart;
-
-	/* reset this.scanner, and move checkpoint by one token */
-	this.scanner.startPosition = pos;
-	this.scanner.currentPosition = pos;
-	this.scanner.diet = false; // quit jumping over method bodies
-
-	completionScanner.currentToken = curTok;
-	completionScanner.currentTokenStart = curTokStart;
-
-	/* if about to restart, then no need to shift token */
-	if (this.restartRecovery){
-		this.lastIgnoredToken = -1;
-		this.scanner.insideRecovery = true;
-		completionScanner.record = true;
-		return true;
-	}
-
-	/* protect against shifting on an invalid token */
-	this.lastIgnoredToken = this.nextIgnoredToken;
-	this.nextIgnoredToken = -1;
-	do {
-		try {
-			this.nextIgnoredToken = this.scanner.getNextToken();
-			if(this.scanner.currentPosition == this.scanner.startPosition){
-				this.scanner.currentPosition++; // on fake completion identifier
-				this.nextIgnoredToken = -1;
-			}
-
-		} catch(InvalidInputException e){
-			pos = this.scanner.currentPosition;
-		}
-	} while (this.nextIgnoredToken < 0);
-
-	if (this.nextIgnoredToken == TokenNameEOF) { // no more recovery after this point
-		if (this.currentToken == TokenNameEOF) { // already tried one iteration on EOF
-			completionScanner.record = true;
-			return false;
-		}
-	}
-	this.lastCheckPoint = this.scanner.currentPosition;
-	completionScanner.lastUsedToken = this.nextIgnoredToken;
-	completionScanner.lastUsedTokenStart = this.lastCheckPoint;
-
-	/* reset this.scanner again to previous checkpoint location*/
-	this.scanner.startPosition = pos;
-	this.scanner.currentPosition = pos;
-	this.scanner.commentPtr = -1;
-	this.scanner.foundTaskCount = 0;
-
-	completionScanner.currentToken = curTok;
-	completionScanner.currentTokenStart = curTokStart;
-	completionScanner.record = true;
-
-	return true;
-}
 public void recordCompletionOnReference(){
 
 	if (currentElement instanceof RecoveredType){
@@ -3951,6 +3979,25 @@ public void recordCompletionOnReference(){
 	if (!diet) return; // only record references attached to types
 
 }
+private void recordReference(NameReference nameReference) {
+	if (!this.skipRecord &&
+			this.recordFrom <= nameReference.sourceStart &&
+			nameReference.sourceEnd <= this.recordTo &&
+			!isAlreadyPotentialName(nameReference.sourceStart)) {
+		char[] token;
+		if (nameReference instanceof SingleNameReference) {
+			token = ((SingleNameReference) nameReference).token;
+		} else {
+			token = ((QualifiedNameReference) nameReference).tokens[0];
+		}
+		
+		// Most of the time a name which start with an uppercase is a type name.
+		// As we don't want to resolve names to avoid to slow down performances then this name will be ignored
+		if (Character.isUpperCase(token[0])) return;
+		
+		addPotentialName(token, nameReference.sourceStart, nameReference.sourceEnd);
+	}
+}
 public void recoveryExitFromVariable() {
 	if(currentElement != null && currentElement instanceof RecoveredLocalVariable) {
 		RecoveredElement oldElement = currentElement;
@@ -4123,6 +4170,10 @@ protected LocalDeclaration createLocalDeclaration(char[] assistName, int sourceS
 	}
 }
 
+protected JavadocParser createJavadocParser() {
+	return new CompletionJavadocParser(this);
+}
+
 protected FieldDeclaration createFieldDeclaration(char[] assistName, int sourceStart, int sourceEnd) {
 	if (this.indexOfAssistIdentifier() < 0 || (currentElement instanceof RecoveredUnit && ((RecoveredUnit)currentElement).typeCount == 0)) {
 		return super.createFieldDeclaration(assistName, sourceStart, sourceEnd);
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
index 7d6c7b9..cdafc76 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionScanner.java
@@ -40,16 +40,6 @@ public class CompletionScanner extends Scanner {
 
 	public static final char[] EmptyCompletionIdentifier = {};
 	
-	public boolean record = false;
-	public char[] prefix;
-	public int currentToken;
-	public int currentTokenStart;
-	public int lastUsedToken;
-	public int lastUsedTokenStart;
-	public int potentialVariableNamesPtr; 
-	public char[][] potentialVariableNames;
-	public int[] potentialVariableNameStarts;
-	
 public CompletionScanner(long sourceLevel) {
 	super(
 		false /*comment*/, 
@@ -60,25 +50,6 @@ public CompletionScanner(long sourceLevel) {
 		null/*taskPriorities*/,
 		true/*taskCaseSensitive*/);
 }
-private void addPotentialName(char[] name, int start) {
-	int length = this.potentialVariableNames.length;
-	if (this.potentialVariableNamesPtr >= length - 1) {
-		System.arraycopy(
-				this.potentialVariableNames, 
-				0,
-				this.potentialVariableNames = new char[length * 2][],
-				0,
-				length);
-		System.arraycopy(
-				this.potentialVariableNameStarts,
-				0,
-				this.potentialVariableNameStarts = new int[length * 2],
-				0,
-				length);
-	}
-	this.potentialVariableNames[++this.potentialVariableNamesPtr] = name;
-	this.potentialVariableNameStarts[this.potentialVariableNamesPtr] = start;
-}
 /* 
  * Truncate the current identifier if it is containing the cursor location. Since completion is performed
  * on an identifier prefix.
@@ -131,32 +102,6 @@ public char[] getCurrentTokenSourceString() {
 	return super.getCurrentTokenSourceString();
 }
 public int getNextToken() throws InvalidInputException {
-	int nextToken = this.getNextToken0();
-	if (this.record) {
-		switch (nextToken) {
-			case TokenNameIdentifier:
-				if (this.currentToken != TokenNameDOT) {
-					char[] identifier = this.getCurrentIdentifierSource();
-					if (!Character.isUpperCase(identifier[0]) && 
-							CharOperation.prefixEquals(this.prefix, identifier, true)) {
-						this.addPotentialName(identifier, this.startPosition);
-					}
-				}
-				break;
-			case TokenNameLPAREN :
-			case TokenNameLBRACE :
-				if (this.currentToken == TokenNameIdentifier) {
-					this.removePotentialNamesAt(this.currentTokenStart);
-					
-				}
-				break;
-		}
-	}
-	this.currentToken = nextToken;
-	this.currentTokenStart = this.startPosition;
-	return nextToken;
-}
-private int getNextToken0() throws InvalidInputException {
 
 	this.wasAcr = false;
 	this.unicodeCharSize = 0;
@@ -868,23 +813,6 @@ public final void getNextUnicodeChar() throws InvalidInputException {
 public final void jumpOverBlock() {
 	this.jumpOverMethodBody();
 }
-public void removePotentialNamesAt(int position) {
-	for (int i = 0; i <= this.potentialVariableNamesPtr; i++) {
-		int namePosition = this.potentialVariableNameStarts[i];
-		if (namePosition == position) {
-			this.potentialVariableNames[i] = null;
-		}
-	}
-}
-public void resetTo(int begin, int end) {
-	if (this.record) {
-		this.currentToken = -1;
-		this.currentTokenStart = 0;
-		this.lastUsedToken = -1;
-		this.lastUsedTokenStart = 0;
-	}
-	super.resetTo(begin, end);
-}
 ///*
 // * In case we actually read a keyword, but the cursor is located inside,
 // * we pretend we read an identifier.
@@ -919,15 +847,4 @@ public int scanNumber(boolean dotPrefix) throws InvalidInputException {
 	}
 	return token;
 }
-
-public void startRecordingIdentifiers() {
-	this.record = true;
-	
-	this.potentialVariableNamesPtr = -1; 
-	this.potentialVariableNames = new char[10][];
-	this.potentialVariableNameStarts = new int[10];
-}
-public void stopRecordingIdentifiers() {
-	this.record = true;
-}
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
index 1f8e5c3..272a2e6 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
@@ -52,7 +52,6 @@ public class SelectionParser extends AssistParser {
 	
 public SelectionParser(ProblemReporter problemReporter) {
 	super(problemReporter);
-	this.javadocParser = new SelectionJavadocParser(this);
 	this.javadocParser.checkDocComment = true;
 }
 public char[] assistIdentifier(){
@@ -968,6 +967,9 @@ public ImportReference createAssistImportReference(char[][] tokens, long[] posit
 public ImportReference createAssistPackageReference(char[][] tokens, long[] positions){
 	return new SelectionOnPackageReference(tokens, positions);
 }
+protected JavadocParser createJavadocParser() {
+	return new SelectionJavadocParser(this);
+}
 protected LocalDeclaration createLocalDeclaration(char[] assistName,int sourceStart,int sourceEnd) {
 	if (this.indexOfAssistIdentifier() < 0) {
 		return super.createLocalDeclaration(assistName, sourceStart, sourceEnd);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index 8350229..5d9d2b5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -879,7 +879,7 @@ public Parser(ProblemReporter problemReporter, boolean optimizeStringLiterals) {
 	this.variablesCounter = new int[30];
 	
 	// javadoc support
-	this.javadocParser = new JavadocParser(this);
+	this.javadocParser = createJavadocParser();
 }
 protected void annotationRecoveryCheckPoint(int start, int end) {
 	if(this.lastCheckPoint > start && this.lastCheckPoint < end) {
@@ -7808,7 +7808,9 @@ protected TypeReference copyDims(TypeReference typeRef, int dim) {
 protected FieldDeclaration createFieldDeclaration(char[] fieldDeclarationName, int sourceStart, int sourceEnd) {
 	return new FieldDeclaration(fieldDeclarationName, sourceStart, sourceEnd);
 }
-
+protected JavadocParser createJavadocParser() {
+	return new JavadocParser(this);
+}
 protected LocalDeclaration createLocalDeclaration(char[] localDeclarationName, int sourceStart, int sourceEnd) {
 	return new LocalDeclaration(localDeclarationName, sourceStart, sourceEnd);
 }
