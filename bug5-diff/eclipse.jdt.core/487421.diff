commit b637f200e7688ed962e24c55c85d7ead1bbbd786
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Jul 4 11:26:00 2016 +0530

    Bug 487421 - [1.9][batch] Support Java 9 options in command line
    compiler

1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
6	2	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
5	0	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
2	0	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
444	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
6	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
98	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
6	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathLocation.java
4	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/CompilationUnit.java
25	6	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileFinder.java
24	4	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
228	6	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
136	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
5	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
11	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
15	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
1	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
2	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
13	15	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
0	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
0	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
0	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
0	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
index 6ac10f8..00271fe 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
@@ -555,7 +555,7 @@ public class ElementsImpl implements Elements {
 	public PackageElement getPackageElement(CharSequence name) {
 		LookupEnvironment le = _env.getLookupEnvironment();
 		if (name.length() == 0) {
-			return new PackageElementImpl(_env, le.defaultPackage);
+			return new PackageElementImpl(_env, le.getDefaultPackage(null));
 		}
 		char[] packageName = name.toString().toCharArray();
 		PackageBinding packageBinding = le.createPackage(CharOperation.splitOn('.', packageName));
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
index 63538fe..af22bc8 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2014 IBM Corporation and others.
+ * Copyright (c) 2007, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -130,7 +134,7 @@ public class ErrorTypeElement extends TypeElementImpl {
 	 */
 	@Override
 	public Element getEnclosingElement() {
-		return this._env.getFactory().newPackageElement(this._env.getLookupEnvironment().defaultPackage);
+		return this._env.getFactory().newPackageElement(this._env.getLookupEnvironment().getDefaultPackage(null));
 	}
 
 	/* (non-Javadoc)
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
index 16a22d5..6a17f7c 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
@@ -138,6 +138,11 @@ public class ClasspathJsr199 extends ClasspathLocation {
 	}
 
 	@Override
+	public void acceptModule(IModule mod) {
+		this.module = mod;
+	}
+
+	@Override
 	public boolean isPackage(String aQualifiedPackageName) {
 		String qualifiedPackageName = File.separatorChar == '/' ? aQualifiedPackageName : aQualifiedPackageName.replace(
 				File.separatorChar, '/');
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
index 80a391a..6a3169a 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseCompilerImpl.java
@@ -409,6 +409,8 @@ public class EclipseCompilerImpl extends Main {
 			String sourcepathClasspathArg,
 			ArrayList sourcepathClasspaths,
 			ArrayList classpaths,
+			String modulePaths,
+			String moduleSourcepaths,
 			ArrayList extdirsClasspaths,
 			ArrayList endorsedDirClasspaths,
 			String customEncoding) {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index d0ff9ed..44c142b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -11070,6 +11070,7 @@ public void test279_sourcepath_vs_classpath() throws IOException, InterruptedExc
 		},
 		"\"" + OUTPUT_DIR +  File.separator + "Y.java\""
 		+ " -sourcepath \"" + OUTPUT_DIR + File.separator + "src2[?**/*]" + "\""
+		+ " -modulesourcepath \"" + OUTPUT_DIR + File.separator + "src2" + "\""
 		+ " -classpath \"" + OUTPUT_DIR + File.separator + "bin1" + "\""
 		+ " -proc:none -d \"" + OUTPUT_DIR + "\"",
 		"",
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
new file mode 100644
index 0000000..ca16044
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -0,0 +1,444 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+
+import org.eclipse.jdt.core.tests.util.Util;
+
+import junit.framework.Test;
+
+public class ModuleCompilationTests extends BatchCompilerTest {
+
+	static {
+//		 TESTS_NAMES = new String[] { "test001" };
+		// TESTS_NUMBERS = new int[] { 1 };
+		// TESTS_RANGE = new int[] { 298, -1 };
+	}
+
+	public ModuleCompilationTests(String name) {
+		super(name);
+	}
+
+	public static Test suite() {
+		return buildMinimalComplianceTestSuite(testClass(), F_9);
+	}
+
+	public static Class testClass() {
+		return ModuleCompilationTests.class;
+	}
+
+	protected void writeFile(String directoryName, String fileName, String source) {
+		File directory = new File(directoryName);
+		if (!directory.exists()) {
+			if (!directory.mkdirs()) {
+				System.out.println("Could not create " + directoryName);
+				return;
+			}
+		}
+		String filePath = directory.getAbsolutePath() + File.separator + fileName;
+		try {
+			BufferedWriter writer = new BufferedWriter(new FileWriter(filePath));
+			writer.write(source);
+			writer.flush();
+			writer.close();
+		} catch (IOException e) {
+			e.printStackTrace();
+			return;
+		}
+	}
+
+	public void test001() {
+		this.runNegativeTest(
+			new String[] {
+				"p/X.java",
+				"package p;\n" +
+				"public class X {\n" +
+				"	public static void main(String[] args) {\n" +
+				"     java.sql.Connection con = null;\n" +
+				"	}\n" +
+				"}",
+				"module-info.java",
+				"module mod.one { \n" +
+				"	requires java.base;\n" +
+				"}"
+	        },
+			"\"" + OUTPUT_DIR +  File.separator + "module-info.java\" "
+	        + "\"" + OUTPUT_DIR +  File.separator + "p/X.java\"",
+	        "",
+	        "----------\n" + 
+    		"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 4)\n" + 
+    		"	java.sql.Connection con = null;\n" + 
+    		"	^^^^^^^^^^^^^^^^^^^\n" + 
+    		"java.sql.Connection cannot be resolved to a type\n" + 
+    		"----------\n" + 
+    		"1 problem (1 error)\n",
+	        true);
+	}
+	public void test002() {
+		this.runConformTest(
+			new String[] {
+				"p/X.java",
+				"package p;\n" +
+				"public class X {\n" +
+				"	public static void main(String[] args) {\n" +
+				"     java.sql.Connection con = null;\n" +
+				"     System.out.println(con);\n" +
+				"	}\n" +
+				"}",
+				"module-info.java",
+				"module mod.one { \n" +
+				"	requires java.base;\n" +
+				"	requires java.sql;\n" +
+				"}"
+	        },
+			"\"" + OUTPUT_DIR +  File.separator + "module-info.java\" "
+	        + "\"" + OUTPUT_DIR +  File.separator + "p/X.java\"",
+	        "",
+	        "",
+	        true);
+	}
+	public void test003() {
+		this.runConformTest(
+			new String[] {
+				"p/X.java",
+				"package p;\n" +
+				"public class X {\n" +
+				"	public static void main(String[] args) {\n" +
+				"     java.sql.Connection con = null;\n" +
+				"     System.out.println(con);\n" +
+				"	}\n" +
+				"}",
+	        },
+	        "\"" + OUTPUT_DIR +  File.separator + "p/X.java\"",
+	        "",
+	        "",
+	        true);
+	}
+	public void test004() {
+		this.runConformTest(
+			new String[] {
+				"module-info.java",
+				"module mod.one { \n" +
+				"	requires java.base;\n" +
+				"	requires java.sql;\n" +
+				"}"
+	        },
+			"\"" + OUTPUT_DIR +  File.separator + "module-info.java\"",
+	        "",
+	        "",
+	        true);
+		String fileName = OUTPUT_DIR + File.separator + "module-info.class";
+		assertTrue("Missing modul-info.class: " + fileName, (new File(fileName)).exists());
+	}
+	public void test005() {
+		String out = "bin";
+		this.runConformTest(
+			new String[] {
+				"p/X.java",
+				"package p;\n" +
+				"public class X {\n" +
+				"	java.sql.Connection con;\n" +
+				"}",
+				"module-info.java",
+				"module mod.one { \n" +
+				"	requires java.base;\n" +
+				"	requires java.sql;\n" +
+				"	requires java.desktop;\n" +
+				"}",
+				"q/Y.java",
+				"package q;\n" +
+				"public class Y {\n" +
+				"   java.awt.Image image;\n" +
+				"}"
+	        },
+			"\"" + OUTPUT_DIR + File.separator + "module-info.java\" "
+			+ "\"" + OUTPUT_DIR + File.separator + "q/Y.java\" "
+	        + "\"" + OUTPUT_DIR + File.separator + "p/X.java\" "
+	        + "-d " + OUTPUT_DIR + File.separator + out,
+	        "",
+	        "",
+	        true);
+		String fileName = OUTPUT_DIR + File.separator + out + File.separator + "module-info.class";
+		assertTrue("Missing modul-info.class: " + fileName, (new File(fileName)).exists());
+	}
+	public void test006() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires java.sql;\n" +
+						"	requires java.desktop;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	java.sql.Connection con;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+						"package q;\n" +
+						"public class Y {\n" +
+						"   java.awt.Image image;\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+			buffer.append("-d " + OUTPUT_DIR + File.separator + out );
+			buffer.append(" -9 ");
+		buffer.append(" -classpath \"")
+		.append(Util.getJavaClassLibsAsString())
+		.append("\" ");
+		buffer.append(" -modulesourcepath " + "\"" + directory + "\"");
+		runConformTest(new String[]{}, buffer.toString(), "", "", false);
+	}
+	public void test007() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	requires java.base;\n" +
+						"	requires mod.one;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+						"package q;\n" +
+						"public class Y {\n" +
+						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"}");
+		
+		StringBuffer buffer = new StringBuffer();
+			buffer.append("-d " + OUTPUT_DIR + File.separator + out );
+			buffer.append(" -9 ");
+		buffer.append(" -classpath \"")
+		.append(Util.getJavaClassLibsAsString())
+		.append("\" ");
+		buffer.append(" -modulesourcepath " + "\"" + directory + "\"");
+		
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 3)\n" + 
+				"	java.sql.Connection con = p.X.getConnection();\n" + 
+				"	                          ^^^\n" + 
+				"The type p.X is not visible\n" + 
+				"----------\n" + 
+				"1 problem (1 error)\n",
+				false);
+	}
+	public void test008() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports p;\n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	requires java.base;\n" +
+						"	requires mod.one;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+						"package q;\n" +
+						"public class Y {\n" +
+						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"");
+
+		runConformTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"",
+				false);
+	}
+	public void test009() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports p;\n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	requires java.base;\n" +
+						"	requires mod.one;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+						"package q;\n" +
+						"public class Y {\n" +
+						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"");
+
+		runConformTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"",
+				false);
+	}
+	public void test010() {
+		Util.flushDirectoryContent(new File(OUTPUT_DIR));
+		String outDir = OUTPUT_DIR + File.separator + "bin";
+		String srcDir = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = srcDir + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports p;\n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+
+		moduleLoc = srcDir + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	exports q;\n" +
+						"	requires java.base;\n" +
+						"	requires mod.one;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+						"package q;\n" +
+						"public class Y {\n" +
+						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+			buffer.append("-d " + outDir )
+			.append(" -9 ")
+			.append(" -modulepath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + srcDir + "\"");
+
+		runConformTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"",
+				false);
+
+		File modDir = new File(OUTPUT_DIR + File.separator + "mod");
+		String fileName = modDir + File.separator + "mod.one.jar";
+		try {
+			Util.zip(new File(outDir + File.separator + "mod.one"), 
+								fileName);
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+		if (!modDir.exists()) {
+			if (!modDir.mkdirs()) {
+				fail("Coult not create folder " + modDir);
+			}
+		}
+		File mod2 = new File(modDir, "mod.two");
+		if (!mod2.mkdir()) {
+			fail("Coult not create folder " + mod2);
+		}
+		Util.copy(outDir + File.separator + "mod.two", mod2.getAbsolutePath());
+
+		Util.flushDirectoryContent(new File(outDir));
+		Util.flushDirectoryContent(new File(srcDir));
+		moduleLoc = srcDir + File.separator + "mod.three";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.three { \n" +
+						"	requires mod.one;\n" +
+						"	requires mod.two;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "Z.java", 
+						"package r;\n" +
+						"public class Z extends Object {\n" +
+						"	p.X x = null;\n" +
+						"	q.Y y = null;\n" +
+						"}");
+
+		buffer = new StringBuffer();
+			buffer.append("-d " + outDir )
+			.append(" -9 ")
+			.append(" -modulepath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append(modDir.getAbsolutePath())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + srcDir + "\"");
+
+		runConformTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"",
+				false);
+	}
+}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
index c467427..0e8e07b 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
@@ -70,6 +70,9 @@ ClasspathDirectory(File directory, String encoding, int mode,
 	this.directoryCache = new Hashtable(11);
 	this.encoding = encoding;
 }
+public void acceptModule(IModule mod) {
+	this.module = mod;
+}
 String[] directoryList(String qualifiedPackageName) {
 	String[] dirList = (String[]) this.directoryCache.get(qualifiedPackageName);
 	if (dirList == this.missingPackageHolder) return null; // package exists in another classpath directory or jar
@@ -297,7 +300,9 @@ public int getMode() {
 }
 @Override
 public IModule getModule(char[] moduleName) {
-	// TODO Auto-generated method stub
+	if (this.module != null && CharOperation.equals(moduleName,  this.module.name())) {
+		return this.module;
+	}
 	return null;
 }
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index 3cdc0d6..940c69d 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -21,9 +21,11 @@ import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.file.FileVisitResult;
+import java.nio.file.Path;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
 import java.util.Enumeration;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -51,6 +53,7 @@ protected File file;
 protected ZipFile zipFile;
 protected ZipFile annotationZipFile;
 protected boolean closeZipFileAtEnd;
+private static HashMap<String, Set<IModule>> ModulesCache = new HashMap<>();
 private Set<String> packageCache;
 protected List<String> annotationPaths;
 protected boolean isJrt;
@@ -230,11 +233,83 @@ protected void addTypeName(final ArrayList answers, String fileName, int last, c
 	}
 }
 public void initialize() throws IOException {
-	if (this.zipFile == null && !this.isJrt) {
+	if (this.zipFile == null) {
 		this.zipFile = new ZipFile(this.file);
+		if (this.isJrt) {
+			 loadModules();
+		}
 	}
 }
+public void acceptModule(IModule mod) {
+	if (this.isJrt) 
+		return;
+	this.module = mod;
+}
+public void loadModules() {
+	Set<IModule> cache = ModulesCache.get(this.file);
+
+	if (cache == null) {
+		try {
+			org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(this.file,
+					new org.eclipse.jdt.internal.compiler.util.JRTUtil.JrtFileVisitor<Path>() {
+
+				@Override
+				public FileVisitResult visitPackage(Path dir, Path mod, BasicFileAttributes attrs)
+						throws IOException {
+					return FileVisitResult.CONTINUE;
+				}
+
+				@Override
+				public FileVisitResult visitFile(Path f, Path mod, BasicFileAttributes attrs)
+						throws IOException {
+					return FileVisitResult.CONTINUE;
+				}
 
+				@Override
+				public FileVisitResult visitModule(Path mod) throws IOException {
+					try {
+						ClasspathJar.this.acceptModule(JRTUtil.getClassfileContent(ClasspathJar.this.file, MODULE_INFO_CLASS, mod.toString()));
+					} catch (ClassFormatException e) {
+						e.printStackTrace();
+					}
+					return FileVisitResult.SKIP_SUBTREE;
+				}
+			}, JRTUtil.NOTIFY_MODULES);
+		} catch (IOException e) {
+			// TODO: BETA_JAVA9 Should report better
+		}
+	}
+}
+void acceptModule(ClassFileReader reader) {
+	if (reader != null) {
+		if (this.isJrt) {
+			IModule moduleDecl = reader.getModuleDeclaration();
+			if (moduleDecl != null) {
+				Set<IModule> cache = ModulesCache.get(this.file);
+				if (cache == null) {
+					ModulesCache.put(new String(moduleDecl.name()), cache = new HashSet<IModule>());
+				}
+				cache.add(moduleDecl);
+			}
+		} else {
+			this.module = reader.getModuleDeclaration();
+		}
+	}
+	
+}
+void acceptModule(byte[] content) {
+	if (content == null) 
+		return;
+	ClassFileReader reader = null;
+	try {
+		reader = new ClassFileReader(content, MODULE_INFO_CLASS.toCharArray(), null);
+	} catch (ClassFormatException e) {
+		e.printStackTrace();
+	}
+	if (reader != null) {
+		acceptModule(reader);
+	}
+}
 protected void addToPackageCache(String fileName, boolean endsWithSep) {
 	int last = endsWithSep ? fileName.length() : fileName.lastIndexOf('/');
 	while (last > 0) {
@@ -339,7 +414,28 @@ public int getMode() {
 
 @Override
 public IModule getModule(char[] moduleName) {
-	// TODO Auto-generated method stub
+	if (this.isJrt) {
+		Set<IModule> modules = ModulesCache.get(new String(moduleName));
+		if (modules != null) {
+			for (IModule mod : modules) {
+				if (CharOperation.equals(mod.name(), moduleName))
+						return mod;
+			}
+		}
+	} else if (this.module != null && CharOperation.equals(moduleName,  this.module.name())) {
+		return this.module;
+	}
 	return null;
 }
+@Override
+public boolean servesModule(IModule mod) {
+	if (!this.isJrt) {
+		return super.servesModule(mod);
+	}
+	if (mod == null) 
+		return false;
+	if (mod == ModuleEnvironment.UNNAMED_MODULE)
+		return true;
+	return ModulesCache.containsKey(new String(mod.name()));
+}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathLocation.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathLocation.java
index 926014e..df36a24 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathLocation.java
@@ -107,6 +107,12 @@ public abstract class ClasspathLocation implements FileSystem.Classpath,
 	public String getPath() {
 		return this.path;
 	}
+	public String getDestinationPath() {
+		return this.destinationPath;
+	}
+	public IModule getModule() {
+		return this.module;
+	}
 	public boolean servesModule(IModule mod) {
 		if (mod == null) 
 			return false;
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/CompilationUnit.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/CompilationUnit.java
index 4e4befb..04bc341 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/CompilationUnit.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/CompilationUnit.java
@@ -43,11 +43,13 @@ public CompilationUnit(char[] contents, String fileName, String encoding) {
 }
 public CompilationUnit(char[] contents, String fileName, String encoding,
 		String destinationPath) {
-	this(contents, fileName, encoding, destinationPath, false);
+	this(contents, fileName, encoding, destinationPath, false, null);
 }
 public CompilationUnit(char[] contents, String fileName, String encoding,
-		String destinationPath, boolean ignoreOptionalProblems) {
+		String destinationPath, boolean ignoreOptionalProblems, String modName) {
 	this.contents = contents;
+	if (modName != null)
+		this.module = modName.toCharArray();
 	char[] fileNameCharArray = fileName.toCharArray();
 	switch(File.separatorChar) {
 		case '/' :
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileFinder.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileFinder.java
index f707fc0..d561cb1 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileFinder.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileFinder.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -12,18 +16,26 @@ package org.eclipse.jdt.internal.compiler.batch;
 
 import java.io.File;
 import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
 
-@SuppressWarnings({"rawtypes", "unchecked"})
 public class FileFinder {
 
+/**
+ * Although the file finder is meant to be generic for any file name patters,
+ * at the moment it is used only for *.java files. This method handles the 
+ * module-info.java in a special way by always placing it as the first element
+ * of the resulting array.
+ */
 public static String[] find(File f, String pattern) {
-	ArrayList files = new ArrayList();
+	List<String> files = new ArrayList<>();
 	find0(f, pattern, files);
 	String[] result = new String[files.size()];
 	files.toArray(result);
 	return result;
 }
-private static void find0(File f, String pattern, ArrayList collector) {
+private static void find0(File f, String pattern, List<String> collector) {
 	if (f.isDirectory()) {
 		String[] files = f.list();
 		if (files == null) return;
@@ -32,8 +44,15 @@ private static void find0(File f, String pattern, ArrayList collector) {
 			if (current.isDirectory()) {
 				find0(current, pattern, collector);
 			} else {
-				if (current.getName().toUpperCase().endsWith(pattern)) {
-					collector.add(current.getAbsolutePath());
+				String name = current.getName().toLowerCase();
+				if (name.endsWith(pattern)) {
+					// NOTE: This handles only the lower case name. Check with the spec about
+					// Naming of the module descriptor before making this code code insensitive.
+					if (name.endsWith(IModuleLocation.MODULE_INFO_JAVA)) {
+						collector.add(0, current.getAbsolutePath());
+					} else {
+						collector.add(current.getAbsolutePath());
+					}
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
index d1ae473..306052e 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
@@ -83,6 +83,9 @@ public class FileSystem extends ModuleEnvironment implements SuffixConstants {
 		 * @param qualifiedTypeName type name in qualified /-separated notation.
 		 */
 		boolean hasAnnotationFileFor(String qualifiedTypeName);
+		public void acceptModule(IModule module);
+		public String getDestinationPath();
+		public IModule getModule();
 	}
 	public interface ClasspathSectionProblemReporter {
 		void invalidClasspathSection(String jarFilePath);
@@ -117,6 +120,9 @@ public class FileSystem extends ModuleEnvironment implements SuffixConstants {
 	}
 
 	protected Classpath[] classpaths;
+	// Used only in single-module mode when the module descriptor is
+	// provided via command lin.
+	protected IModule module;
 	Set knownFileNames;
 	protected boolean annotationsFromClasspath; // should annotation files be read from the classpath (vs. explicit separate path)?
 	private static HashMap<File, Classpath> JRT_CLASSPATH_CACHE = null;
@@ -155,7 +161,7 @@ protected FileSystem(Classpath[] paths, String[] initialFileNames, boolean annot
 			classpath.initialize();
 			this.classpaths[counter++] = classpath;
 		} catch(IOException | IllegalArgumentException exception) {
-			// JRE 9 could through an IAE if the linked JAR paths have invalid chars, such as ":"
+			// JRE 9 could throw an IAE if the linked JAR paths have invalid chars, such as ":"
 			// ignore
 		}
 	}
@@ -189,7 +195,7 @@ public static Classpath getClasspath(String classpathName, String encoding,
 		}
 	} else {
 		int format = Util.archiveFormat(classpathName);
-		if (format > -1) {
+		if (format >= Util.ZIP_FILE) {
 			if (isSourceOnly) {
 				// source only mode
 				result = new ClasspathSourceJar(file, true, accessRuleSet,
@@ -207,6 +213,11 @@ public static Classpath getClasspath(String classpathName, String encoding,
 					}
 					if (result == null) {
 						result = new ClasspathJar(file, true, accessRuleSet, null, true);
+						try {
+							result.initialize();
+						} catch (IOException e) {
+							// Broken entry, but let clients have it anyway.
+						}
 						JRT_CLASSPATH_CACHE.put(file, result);
 					}
 				} else {
@@ -453,7 +464,16 @@ public boolean isPackage(char[][] compoundName, char[] packageName, IModule[] mo
 }
 @Override
 public IModule getModule(char[] name) {
-	// TODO Auto-generated method stub
-	return null;
+	if (name == null)
+		return null;
+	if (this.module != null && CharOperation.equals(name, this.module.name())) {
+		return this.module;
+	}
+	IModule mod = null;
+	for (int i = 0, l = this.classpaths.length; i < l; i++) {
+		if ((mod = this.classpaths[i].getModule(name)) != null)
+			break;
+	}
+	return mod;
 }
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 59bb297..0ecd1d5 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -78,16 +78,23 @@ import org.eclipse.jdt.internal.compiler.Compiler;
 import org.eclipse.jdt.internal.compiler.ICompilerRequestor;
 import org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;
 import org.eclipse.jdt.internal.compiler.IProblemFactory;
+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.env.AccessRule;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.CompilerStats;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.eclipse.jdt.internal.compiler.parser.Parser;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
@@ -1319,6 +1326,8 @@ public class Main implements ProblemSeverities, SuffixConstants {
 	/* Bundle containing messages */
 	public ResourceBundle bundle;
 	protected FileSystem.Classpath[] checkedClasspaths;
+	// For single module mode
+	protected IModule module;
 	// paths to external annotations:
 	protected List<String> annotationPaths;
 	protected boolean annotationsFromClasspath;
@@ -1341,6 +1350,7 @@ public class Main implements ProblemSeverities, SuffixConstants {
 	public String[] encodings;
 	public int exportedClassFilesCounter;
 	public String[] filenames;
+	public String[] modNames;
 	public String[] classNames;
 	// overrides of destinationPath on a directory argument basis
 	public int globalErrorsCount;
@@ -1788,10 +1798,14 @@ public void configure(String[] argv) {
 	final int INSIDE_CLASS_NAMES = 20;
 	final int INSIDE_WARNINGS_PROPERTIES = 21;
 	final int INSIDE_ANNOTATIONPATH_start = 22;
+	final int INSIDE_MODULEPATH_start = 23;
+	final int INSIDE_MODULESOURCEPATH_start = 24;
 
 	final int DEFAULT = 0;
 	ArrayList bootclasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
 	String sourcepathClasspathArg = null;
+	String modulepathArg = null;
+	String moduleSourcepathArg = null;
 	ArrayList sourcepathClasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
 	ArrayList classpaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
 	ArrayList extdirsClasspaths = null;
@@ -1817,6 +1831,7 @@ public void configure(String[] argv) {
 	String customDestinationPath = null;
 	String currentSourceDirectory = null;
 	String currentArg = Util.EMPTY_STRING;
+	String moduleName = null;
 	
 	Set specifiedEncodings = null;
 
@@ -1948,9 +1963,21 @@ public void configure(String[] argv) {
 				}
 
 				if (currentArg.endsWith(SuffixConstants.SUFFIX_STRING_java)) {
+					if (moduleName == null) {
+						// If the module-info.java was supplied via command line, that will be the
+						// de facto module for the other source files supplied via command line.
+						// TODO: This needs revisit in case a source file specified in command line is
+						// part of a -modulesourcepath
+						IModule mod = extractModuleDesc(currentArg, getNewParser());
+						if (mod != null) {
+							moduleName = new String(mod.name());
+							this.module = mod;
+						}
+					}
 					if (this.filenames == null) {
 						this.filenames = new String[argCount - index];
 						this.encodings = new String[argCount - index];
+						this.modNames = new String[argCount - index];
 						this.destinationPaths = new String[argCount - index];
 					} else if (filesCount == this.filenames.length) {
 						int length = this.filenames.length;
@@ -1972,8 +1999,15 @@ public void configure(String[] argv) {
 							(this.destinationPaths = new String[length + argCount - index]),
 							0,
 							length);
+						System.arraycopy(
+								this.modNames,
+								0,
+								(this.modNames = new String[length + argCount - index]),
+								0,
+								length);
 					}
 					this.filenames[filesCount] = currentArg;
+					this.modNames[filesCount] = moduleName;
 					this.encodings[filesCount++] = customEncoding;
 					// destination path cannot be specified upon an individual file
 					customEncoding = null;
@@ -2112,6 +2146,14 @@ public void configure(String[] argv) {
 					mode = INSIDE_BOOTCLASSPATH_start;
 					continue;
 				}
+				if (currentArg.equals("-modulepath") || currentArg.equals("-cp")) { //$NON-NLS-1$ //$NON-NLS-2$
+					mode = INSIDE_MODULEPATH_start;
+					continue;
+				}
+				if (currentArg.equals("-modulesourcepath")) { //$NON-NLS-1$
+					mode = INSIDE_MODULESOURCEPATH_start;
+					continue;
+				}
 				if (currentArg.equals("-sourcepath")) {//$NON-NLS-1$
 					if (sourcepathClasspathArg != null) {
 						StringBuffer errorMessage = new StringBuffer();
@@ -2614,6 +2656,18 @@ public void configure(String[] argv) {
 				setDestinationPath(currentArg.equals(NONE) ? NONE : currentArg);
 				mode = DEFAULT;
 				continue;
+			case INSIDE_MODULEPATH_start:
+				mode = DEFAULT;
+				String[] modulepaths = new String[1];
+				index += processPaths(newCommandLineArgs, index, currentArg, modulepaths);
+				modulepathArg = modulepaths[0];
+				continue;
+			case INSIDE_MODULESOURCEPATH_start:
+				mode = DEFAULT;
+				String[] moduleSourcepaths = new String[1];
+				index += processPaths(newCommandLineArgs, index, currentArg, moduleSourcepaths);
+				moduleSourcepathArg = moduleSourcepaths[0];
+				continue;
 			case INSIDE_CLASSPATH_start:
 				mode = DEFAULT;
 				index += processPaths(newCommandLineArgs, index, currentArg, classpaths);
@@ -2730,7 +2784,7 @@ public void configure(String[] argv) {
 			throw new IllegalArgumentException(
 				this.bind("configure.unrecognizedOption", currentSourceDirectory)); //$NON-NLS-1$
 		}
-		String[] result = FileFinder.find(dir, SuffixConstants.SUFFIX_STRING_JAVA);
+		String[] result = FileFinder.find(dir, SuffixConstants.SUFFIX_STRING_java);
 		if (NONE.equals(customDestinationPath)) {
 			customDestinationPath = NONE; // ensure == comparison
 		}
@@ -2755,10 +2809,17 @@ public void configure(String[] argv) {
 				(this.destinationPaths = new String[length + filesCount]),
 				0,
 				filesCount);
+			System.arraycopy(
+					this.modNames,
+					0,
+					(this.modNames = new String[length + filesCount]),
+					0,
+					filesCount);
 			System.arraycopy(result, 0, this.filenames, filesCount, length);
 			for (int i = 0; i < length; i++) {
 				this.encodings[filesCount + i] = customEncoding;
 				this.destinationPaths[filesCount + i] = customDestinationPath;
+				this.modNames[filesCount + i] = moduleName;
 			}
 			filesCount += length;
 			customEncoding = null;
@@ -2769,6 +2830,7 @@ public void configure(String[] argv) {
 			filesCount = this.filenames.length;
 			this.encodings = new String[filesCount];
 			this.destinationPaths = new String[filesCount];
+			this.modNames = new String[filesCount];
 			for (int i = 0; i < filesCount; i++) {
 				this.encodings[i] = customEncoding;
 				this.destinationPaths[i] = customDestinationPath;
@@ -2815,8 +2877,9 @@ public void configure(String[] argv) {
 			CompilerOptions.OPTION_ReportMissingJavadocTagsVisibility,
 			CompilerOptions.PRIVATE);
 	}
-
-	if (printUsageRequired || (filesCount == 0 && classCount == 0)) {
+	// We don't add the source files from -modulesourcepath yet to the final list. So,
+	// don't report it if that's the case.
+	if (printUsageRequired || (filesCount == 0 && classCount == 0 && moduleSourcepathArg == null)) {
 		if (usageSection ==  null) {
 			printUsage(); // default
 		} else {
@@ -2874,6 +2937,8 @@ public void configure(String[] argv) {
 			sourcepathClasspathArg,
 			sourcepathClasspaths,
 			classpaths,
+			modulepathArg,
+			moduleSourcepathArg,
 			extdirsClasspaths,
 			endorsedDirClasspaths,
 			customEncoding);
@@ -2891,6 +2956,32 @@ public void configure(String[] argv) {
 		this.pendingErrors = null;
 	}
 }
+private Parser getNewParser() {
+	return new Parser(new ProblemReporter(getHandlingPolicy(), 
+			new CompilerOptions(this.options), getProblemFactory()), false);
+}
+private IModule extractModuleDesc(String fileName, Parser parser) {
+	IModule mod = null;
+	if (fileName.toLowerCase().endsWith(IModuleLocation.MODULE_INFO_JAVA)) {
+		
+		ICompilationUnit cu = new CompilationUnit(null, fileName, null);
+		CompilationResult compilationResult = new CompilationResult(cu, 0, 1, 10);
+		CompilationUnitDeclaration unit = parser.parse(cu, compilationResult);
+		if (unit.isModuleInfo() && unit.moduleDeclaration != null) {
+			mod = ModuleEnvironment.createModule(unit.moduleDeclaration);
+		}
+	} else if (fileName.toLowerCase().endsWith(IModuleLocation.MODULE_INFO_CLASS)) {
+		try {
+			ClassFileReader reader = ClassFileReader.read(fileName); // Check the absolute path?
+			mod = reader.getModuleDeclaration();
+		} catch (ClassFormatException | IOException e) {
+			e.printStackTrace();
+			throw new IllegalArgumentException(
+					this.bind("configure.invalidModuleDescriptor", fileName)); //$NON-NLS-1$
+		}
+	}
+	return mod;
+}
 
 private static char[][] decodeIgnoreOptionalProblemsFromFolders(String folders) {
 	StringTokenizer tokenizer = new StringTokenizer(folders, File.pathSeparator);
@@ -3068,7 +3159,8 @@ public CompilationUnit[] getCompilationUnits() {
 			fileName = this.filenames[i];
 		}
 		units[i] = new CompilationUnit(null, fileName, encoding, this.destinationPaths[i],
-				shouldIgnoreOptionalProblems(this.ignoreOptionalProblemsFromFolders, fileName.toCharArray()));
+				shouldIgnoreOptionalProblems(this.ignoreOptionalProblemsFromFolders, fileName.toCharArray()), 
+				this.modNames[i]);
 	}
 	return units;
 }
@@ -3104,8 +3196,10 @@ public File getJavaHome() {
 }
 
 public FileSystem getLibraryAccess() {
-	return new FileSystem(this.checkedClasspaths, this.filenames, 
+	FileSystem nameEnvironment = new FileSystem(this.checkedClasspaths, this.filenames, 
 					this.annotationsFromClasspath && CompilerOptions.ENABLED.equals(this.options.get(CompilerOptions.OPTION_AnnotationBasedNullAnalysis)));
+	nameEnvironment.module = this.module;
+	return nameEnvironment;
 }
 
 /*
@@ -3142,7 +3236,113 @@ protected ArrayList handleBootclasspath(ArrayList bootclasspaths, String customE
 	}
 	return bootclasspaths;
 }
+protected ArrayList handleModulepath(String arg) {
+	ArrayList<String> modulePaths = processModulePathEntries(arg);
+	final int classpathsSize;
+	if ((modulePaths != null && modulePaths.size() > 0)
+		&& ((classpathsSize = modulePaths.size()) != 0)) {
+		String[] paths = new String[classpathsSize];
+		modulePaths.toArray(paths);
+		modulePaths.clear();
+		for (int i = 0; i < paths.length; i++) {
+			File dir = new File(paths[i]);
+			if (dir.isDirectory()) {
+			modulePaths =
+					(ArrayList) ModuleFinder.findModules(dir, null, getNewParser(), this.options, false);
+			}
+		}
+	}
+	// TODO: What about chained jars from MANIFEST.MF? Check with spec
+	return modulePaths;
+}
+protected ArrayList handleModuleSourcepath(String arg) {
+	ArrayList<String> modulePaths = processModulePathEntries(arg);
+	final int classpathsSize;
+	if ((modulePaths != null)
+		&& ((classpathsSize = modulePaths.size()) != 0)) {
 
+		if (this.destinationPath == null) {
+			addPendingErrors(this.bind("configure.missingDestinationPath"));//$NON-NLS-1$
+		}
+		String[] paths = new String[modulePaths.size()];
+		modulePaths.toArray(paths);
+		// We reuse the same List to store <Classpath>, which earlier contained <String>
+		modulePaths.clear();
+		for (int i = 0; i < classpathsSize; i++) {
+			processPathEntries(DEFAULT_SIZE_CLASSPATH, modulePaths, paths[i],
+					null, false, true);
+		}
+//		Parser parser = getNewParser();
+		for (int i = 0; i < paths.length; i++) {
+			File dir = new File(paths[i]);
+			if (dir.isDirectory()) {
+//				List<String> mods = ModuleFinder.findFolders(dir);
+				// 1. Create FileSystem.Classpath for each module
+				// 2. Iterator each module in case of directory for source files and add to this.fileNames
+
+				modulePaths =
+						(ArrayList) ModuleFinder.findModules(dir, this.destinationPath, getNewParser(), this.options, true);
+				
+				for (Object obj : modulePaths) {
+					Classpath classpath = (Classpath) obj;
+					File modLocation = new File(classpath.getPath());
+					String[] result = FileFinder.find(modLocation, SuffixConstants.SUFFIX_STRING_java);
+					String destPath = classpath.getDestinationPath();
+					String moduleName = new String(classpath.getModule().name());
+
+					// Add them to this.filenames
+					if (this.filenames != null) {
+						int filesCount = this.filenames.length;
+						// some source files were specified explicitly
+						int length = result.length;
+						System.arraycopy(
+							this.filenames,
+							0,
+							(this.filenames = new String[length + filesCount]),
+							0,
+							filesCount);
+						System.arraycopy(
+							this.encodings,
+							0,
+							(this.encodings = new String[length + filesCount]),
+							0,
+							filesCount);
+						System.arraycopy(
+							this.destinationPaths,
+							0,
+							(this.destinationPaths = new String[length + filesCount]),
+							0,
+							filesCount);
+						System.arraycopy(
+								this.modNames,
+								0,
+								(this.modNames = new String[length + filesCount]),
+								0,
+								filesCount);
+						System.arraycopy(result, 0, this.filenames, filesCount, length);
+						for (int j = 0; j < length; j++) {
+							this.modNames[filesCount + j] = moduleName;
+							this.destinationPaths[filesCount + j] = destPath;
+						}
+						filesCount += length;
+					} else {
+						this.filenames = result;
+						int filesCount = this.filenames.length;
+						this.encodings = new String[filesCount];
+						this.destinationPaths = new String[filesCount];
+						this.modNames = new String[filesCount];
+						for (int j = 0; j < filesCount; j++) {
+							this.destinationPaths[j] = destPath;
+							this.modNames[j] = moduleName;
+						}
+					}
+				}
+			}
+		}
+		
+	}
+	return modulePaths;
+}
 /*
  * External API
  */
@@ -4199,6 +4399,10 @@ public void performCompilation() {
 	try {
 		this.logger.startLoggingSources();
 		this.batchCompiler.compile(getCompilationUnits());
+	} catch (Exception e) {
+		// In the unlikely case of an exception, trouble shooting becomes extremely
+		// difficult. So, handle it here.
+		e.printStackTrace();
 	} finally {
 		this.logger.endLoggingSources();
 	}
@@ -4259,6 +4463,16 @@ private ReferenceBinding[] processClassNames(LookupEnvironment environment) {
 	}
 	return referenceBindings;
 }
+private ArrayList<String> processModulePathEntries(String arg) {
+	ArrayList<String> paths = new ArrayList<>();
+	if (arg == null)
+		return paths;
+	StringTokenizer tokenizer = new StringTokenizer(arg, File.pathSeparator, false);
+	while (tokenizer.hasMoreTokens()) {
+		paths.add(tokenizer.nextToken());
+	}
+	return paths;
+}
 /*
  * External API
  */
@@ -4599,6 +4813,8 @@ protected void setPaths(ArrayList bootclasspaths,
 		String sourcepathClasspathArg,
 		ArrayList sourcepathClasspaths,
 		ArrayList classpaths,
+		String modulePath,
+		String moduleSourcepath,
 		ArrayList extdirsClasspaths,
 		ArrayList endorsedDirClasspaths,
 		String customEncoding) {
@@ -4608,9 +4824,13 @@ protected void setPaths(ArrayList bootclasspaths,
 
 	classpaths = handleClasspath(classpaths, customEncoding);
 
+	List modulePaths = handleModulepath(modulePath);
+
+	List moduleSourcepaths = handleModuleSourcepath(moduleSourcepath);
+
 	if (sourcepathClasspathArg != null) {
 		processPathEntries(DEFAULT_SIZE_CLASSPATH, sourcepathClasspaths,
-			sourcepathClasspathArg, customEncoding, true, false);
+			sourcepathClasspathArg, null, true, false);
 	}
 
 	/*
@@ -4635,6 +4855,8 @@ protected void setPaths(ArrayList bootclasspaths,
 	bootclasspaths.addAll(extdirsClasspaths);
 	bootclasspaths.addAll(sourcepathClasspaths);
 	bootclasspaths.addAll(classpaths);
+	bootclasspaths.addAll(modulePaths);
+	bootclasspaths.addAll(moduleSourcepaths);
 	classpaths = bootclasspaths;
 	classpaths = FileSystem.ClasspathNormalizer.normalize(classpaths);
 	this.checkedClasspaths = new FileSystem.Classpath[classpaths.size()];
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
new file mode 100644
index 0000000..c9dd31f
--- /dev/null
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
@@ -0,0 +1,136 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.batch;
+
+import java.io.File;
+import java.io.FilenameFilter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.zip.ZipFile;
+
+import org.eclipse.jdt.internal.compiler.CompilationResult;
+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment;
+import org.eclipse.jdt.internal.compiler.parser.Parser;
+import org.eclipse.jdt.internal.compiler.util.Util;
+
+public class ModuleFinder {
+
+	protected static List<FileSystem.Classpath> findModules(File f, String destinationPath, Parser parser, Map<String, String> options, boolean sourceOnly) {
+		List<FileSystem.Classpath> collector = new ArrayList<>();
+		if (f.isDirectory()) {
+			File[] files = f.listFiles();
+			if (files == null) 
+				return Collections.EMPTY_LIST;
+			for (final File file : files) {
+				IModule module = null;
+				if (file.isDirectory()) {
+					String[] list = file.list(new FilenameFilter() {
+						@Override
+						public boolean accept(File dir, String name) {
+							if (dir == file 
+									&& (name.equalsIgnoreCase(IModuleLocation.MODULE_INFO_CLASS) ||
+											name.equalsIgnoreCase(IModuleLocation.MODULE_INFO_JAVA))) {
+								return true;
+							}
+							return false;
+						}
+					});
+					if (list.length > 0) {
+						String fileName = list[0];
+						switch (fileName) {
+							case IModuleLocation.MODULE_INFO_CLASS:
+								module = ModuleFinder.extractModuleFromClass(new File(file, fileName));
+								break;
+							case IModuleLocation.MODULE_INFO_JAVA:
+								module = ModuleFinder.extractModuleFromSource(new File(file, fileName), parser);
+								break;
+						}
+					}
+				} else if (isJar(file)){
+					module = extractModuleFromJar(file);
+				}
+				if (module != null) {
+					FileSystem.Classpath modulePath = FileSystem.getClasspath(
+							file.getAbsolutePath(),
+							null,
+							sourceOnly,
+							null,
+							destinationPath == null ? null : (destinationPath + File.separator + file.getName()), 
+							options);
+					modulePath.acceptModule(module);
+					collector.add(modulePath);
+				}
+			}
+		}
+		return collector;
+	}
+	private static boolean isJar(File file) {
+		int format = Util.archiveFormat(file.getAbsolutePath());
+		return format >= Util.ZIP_FILE;
+	}
+	private static IModule extractModuleFromJar(File file) {
+		ZipFile zipFile = null;
+		try {
+			zipFile = new ZipFile(file);
+			ClassFileReader reader = ClassFileReader.read(zipFile, IModuleLocation.MODULE_INFO_CLASS);
+			return getModule(reader);
+		} catch (ClassFormatException | IOException e) {
+			e.printStackTrace();
+		} finally {
+			if (zipFile != null) {
+				try {
+					zipFile.close();
+				} catch (IOException e) {
+					// Nothing much to do here
+				}
+			}
+		}
+		return null;
+	}
+	private static IModule extractModuleFromClass(File classfilePath) {
+		ClassFileReader reader;
+		try {
+			reader = ClassFileReader.read(classfilePath);
+			return getModule(reader);
+		} catch (ClassFormatException | IOException e) {
+			e.printStackTrace();
+		}
+		return null;
+	}
+	private static IModule getModule(ClassFileReader classfile) {
+		if (classfile != null) {
+			return classfile.getModuleDeclaration();
+		}
+		return null;
+	}
+	private static IModule extractModuleFromSource(File file, Parser parser) {
+		ICompilationUnit cu = new CompilationUnit(null, file.getAbsolutePath(), null);
+		CompilationResult compilationResult = new CompilationResult(cu, 0, 1, 10);
+		CompilationUnitDeclaration unit = parser.parse(cu, compilationResult);
+		if (unit.isModuleInfo() && unit.moduleDeclaration != null) {
+			return ModuleEnvironment.createModule(unit.moduleDeclaration);
+		}
+		return null;
+	}
+}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index f15425d..b1f22f5 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -1,5 +1,5 @@
 ###############################################################################
-# Copyright (c) 2000, 2015 IBM Corporation and others.
+# Copyright (c) 2000, 2016 IBM Corporation and others.
 # All rights reserved. This program and the accompanying materials
 # are made available under the terms of the Eclipse Public License v1.0
 # which accompanies this distribution, and is available at
@@ -63,6 +63,9 @@ configure.duplicateSource = duplicate source compliance setting specification: {
 configure.duplicateTarget = duplicate target compliance setting specification: {0}
 configure.source = source level should be comprised in between ''1.3'' and ''1.8'' (or ''5'', ''5.0'', ..., ''8'' or ''8.0''): {0}
 configure.duplicateOutputPath = duplicate output path specification: {0}
+configure.duplicateModulePath = duplicate module path specification: {0}
+configure.duplicateModuleSourcepath = duplicate source module path specification: {0}
+configure.invalidModuleDescriptor = Cannot open the module descriptor from {0}
 configure.duplicateBootClasspath = duplicate bootclasspath specification: {0}
 configure.duplicateExtDirs = duplicate extdirs specification: {0}
 configure.duplicateSourcepath = duplicate sourcepath specification: {0}
@@ -97,6 +100,7 @@ configure.invalidTaskTag ={0} is an invalid task tag
 configure.incorrectExtDirsEntry = incorrect ext dir entry; {0} must be a directory
 configure.incorrectEndorsedDirsEntry = incorrect endorsed dir entry; {0} must be a directory
 configure.duplicateEndorsedDirs = duplicate endorseddirs specification: {0}
+configure.missingDestinationPath = destination path must be provided with module source path
 configure.incorrectDestinationPathEntry = incorrect destination path entry: {0}
 configure.unexpectedBracket = unexpected bracket: {0}
 configure.unexpectedDestinationPathEntry = unexpected destination path entry in {0} option
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
index 013d622..c0b5dba 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
@@ -19,6 +19,10 @@ package org.eclipse.jdt.internal.compiler.env;
  * location could contain a module either in the form of module-info.java or module-info.class.
  */
 public interface IModuleLocation {
+
+	public static final String MODULE_INFO_JAVA = "module-info.java"; //$NON-NLS-1$
+	public static final String MODULE_INFO_CLASS = "module-info.class"; //$NON-NLS-1$
+
 	/**
 	 * Find class with the given type name and qualified package name from the given module. Clients can also use
 	 * servesModule() before invoking this for performance implications.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index b3c550d..e9fd44f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -91,6 +91,7 @@ void buildFieldsAndMethods() {
 		this.topLevelTypes[i].scope.buildFieldsAndMethods();
 }
 void buildTypeBindings(AccessRestriction accessRestriction) {
+	char[] modName = module();
 	this.topLevelTypes = new SourceTypeBinding[0]; // want it initialized if the package cannot be resolved
 	boolean firstIsSynthetic = false;
 	if (this.referenceContext.compilationResult.compilationUnit != null) {
@@ -109,14 +110,14 @@ void buildTypeBindings(AccessRestriction accessRestriction) {
 	}
 	if (this.currentPackageName == CharOperation.NO_CHAR_CHAR) {
 		// environment default package is never null
-		this.fPackage = this.environment.defaultPackage;
+		this.fPackage = this.environment.getDefaultPackage(modName);
 	} else {
-		if ((this.fPackage = this.environment.createPackage(this.currentPackageName, module())) == null) {
+		if ((this.fPackage = this.environment.createPackage(this.currentPackageName, modName)) == null) {
 			if (this.referenceContext.currentPackage != null) {
 				problemReporter().packageCollidesWithType(this.referenceContext); // only report when the unit has a package statement
 			}
 			// ensure fPackage is not null
-			this.fPackage = this.environment.defaultPackage;
+			this.fPackage = this.environment.getDefaultPackage(modName);
 			return;
 		} else if (this.referenceContext.isPackageInfo()) {
 			// resolve package annotations now if this is "package-info.java".
@@ -159,7 +160,7 @@ void buildTypeBindings(AccessRestriction accessRestriction) {
 				problemReporter().duplicateTypes(this.referenceContext, typeDecl);
 			continue nextType;
 		}
-		if (this.fPackage != this.environment.defaultPackage && this.fPackage.getPackage(typeDecl.name, module()) != null) {
+		if (this.fPackage != this.environment.getDefaultPackage(modName) && this.fPackage.getPackage(typeDecl.name, module()) != null) {
 			// if a package exists, it must be a valid package - cannot be a NotFound problem package
 			// this is now a warning since a package does not really 'exist' until it contains a type, see JLS v2, 7.4.3
 			problemReporter().typeCollidesWithPackage(this.referenceContext, typeDecl);
@@ -466,13 +467,13 @@ public Binding findImport(char[][] compoundName, boolean findStaticImports, bool
 }
 private Binding findImport(char[][] compoundName, int length) {
 	recordQualifiedReference(compoundName);
-
-	Binding binding = this.environment.getTopLevelPackage(compoundName[0], module());
+	char[] modName = module();
+	Binding binding = this.environment.getTopLevelPackage(compoundName[0], modName);
 	int i = 1;
 	foundNothingOrType: if (binding != null) {
 		PackageBinding packageBinding = (PackageBinding) binding;
 		while (i < length) {
-			binding = packageBinding.getTypeOrPackage(compoundName[i++], module());
+			binding = packageBinding.getTypeOrPackage(compoundName[i++], modName);
 			if (binding == null || !binding.isValidBinding()) {
 				binding = null;
 				break foundNothingOrType;
@@ -489,7 +490,8 @@ private Binding findImport(char[][] compoundName, int length) {
 	if (binding == null) {
 		if (compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)
 			return new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, i), null, ProblemReasons.NotFound);
-		type = findType(compoundName[0], this.environment.defaultPackage, this.environment.defaultPackage);
+		PackageBinding defaultPackage = this.environment.getDefaultPackage(modName);
+		type = findType(compoundName[0], defaultPackage, defaultPackage);
 		if (type == null || !type.isValidBinding())
 			return new ProblemReferenceBinding(CharOperation.subarray(compoundName, 0, i), null, ProblemReasons.NotFound);
 		i = 1; // reset to look for member types inside the default package type
@@ -518,7 +520,7 @@ private Binding findSingleImport(char[][] compoundName, int mask, boolean findSt
 		// the name cannot be a package
 		if (compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)
 			return new ProblemReferenceBinding(compoundName, null, ProblemReasons.NotFound);
-		ReferenceBinding typeBinding = findType(compoundName[0], this.environment.defaultPackage, this.fPackage);
+		ReferenceBinding typeBinding = findType(compoundName[0], this.environment.getDefaultPackage(module()), this.fPackage);
 		if (typeBinding == null)
 			return new ProblemReferenceBinding(compoundName, null, ProblemReasons.NotFound);
 		return typeBinding;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index d44a305..362dd3f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -71,7 +71,8 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 	 */
 	private Map accessRestrictions;
 	ImportBinding[] defaultImports;
-	public PackageBinding defaultPackage;
+	private PackageBinding defaultPackage;
+	private HashtableOfPackage defaultPackages;
 	HashtableOfPackage knownPackages;
 	private int lastCompletedUnitIndex = -1;
 	private int lastUnitIndex = -1;
@@ -141,6 +142,7 @@ public LookupEnvironment(ITypeRequestor typeRequestor, CompilerOptions globalOpt
 	this.defaultPackage = new PackageBinding(this); // assume the default package always exists
 	this.defaultImports = null;
 	this.nameEnvironment = nameEnvironment;
+	this.defaultPackages = new HashtableOfPackage();
 	this.knownPackages = new HashtableOfPackage();
 	this.uniqueParameterizedGenericMethodBindings = new SimpleLookupTable(3);
 	this.uniquePolymorphicMethodBindings = new SimpleLookupTable(3);
@@ -806,6 +808,18 @@ public MissingTypeBinding createMissingType(PackageBinding packageBinding, char[
 	return missingType;
 }
 
+public PackageBinding getDefaultPackage(char[] module) {
+	if (module == null || module.length == 0 || module == ModuleEnvironment.UNNAMED) {
+		return this.defaultPackage;
+	} else {
+		PackageBinding pack = this.defaultPackages.get(module);
+		if (pack == null) {
+			pack = new PackageBinding(this);
+			this.defaultPackages.put(module, pack);
+		}
+		return pack;
+	}
+}
 public PackageBinding createPackage(char[][] compoundName) {
 	return createPackage(compoundName, null);
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
index 6313669..4a7887c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
@@ -86,7 +86,7 @@ public abstract class ModuleEnvironment implements INameEnvironmentExtension {
 	private NameEnvironmentAnswer findTypeWorker(char[] typeName, char[][] packageName, char[] client, boolean searchSecondaryTypes) {
 		NameEnvironmentAnswer answer = findType(typeName, packageName, getVisibleModules(client), searchSecondaryTypes);
 		char[] module = null;
-		if(answer == null || (module = answer.moduleName()) == null || 
+		if(answer == null || (module = answer.moduleName()) == null || client == null ||
 				CharOperation.equals(module, JRTUtil.JAVA_BASE_CHAR)) {
 			return answer;
 		}
@@ -119,16 +119,6 @@ public abstract class ModuleEnvironment implements INameEnvironmentExtension {
 
 	public abstract boolean isPackage(char[][] parentPackageName, char[] packageName, IModule[] module);
 
-//	public abstract IModule getModule(String name);
-//	{
-////		IModule mod = this.modulesCache.get(name);
-////		if (mod == null) {
-////			
-////		}
-////		return mod;
-//		for ()
-//	}
-
 	public boolean isPackageVisible(char[] packageName, char[] sourceName, char[] clientName) {
 		boolean clientIsUnnamed = clientName == null || clientName == UNNAMED;
 		if (clientIsUnnamed)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
index 7004933..1a78a6e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
@@ -174,12 +174,10 @@ class JrtFileSystem {
 	void initialize(File jrt) throws IOException {
 		URL url = null;
 		if (jrt.toString().endsWith(JRTUtil.JRT_FS_JAR)) {
-			url = jrt.toPath().toUri().toURL();
+			String jdkHome = jrt.getParent();
+			url = Paths.get(jdkHome).toUri().toURL();
 		} else if (jrt.isDirectory()) {
 			url = jrt.toPath().toUri().toURL();
-		} else {
-			String jdkHome = jrt.getParentFile().getParentFile().getParent();
-			url = Paths.get(jdkHome, JRTUtil.JRT_FS_JAR).toUri().toURL();
 		}
 		JRTUtil.MODULE_TO_LOAD = System.getProperty("modules.to.load"); //$NON-NLS-1$
 		URLClassLoader loader = new URLClassLoader(new URL[] { url });
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
index 7460fd4..c0b4ecc 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
@@ -614,8 +614,19 @@ public class JavaProject
 				if (referringEntry != null  && !resolvedEntry.isExported())
 					return;
 				Object target = JavaModel.getTarget(entryPath, true/*check existency*/);
-				if (target == null)
-					return;
+				if (target == null || JavaModelManager.isJrt(entryPath)) {
+					PerProjectInfo info = getPerProjectInfo();
+					if (info.jrtRoots == null || !info.jrtRoots.containsKey(entryPath)) {
+						ObjectVector imageRoots = new ObjectVector();
+						loadModulesInJimage(entryPath, imageRoots, rootToResolvedEntries, resolvedEntry, referringEntry);
+						info.setJrtPackageRoots(entryPath, imageRoots);
+						accumulatedRoots.addAll(imageRoots);
+						rootIDs.add(rootID);
+					} else {
+						accumulatedRoots.addAll(info.jrtRoots.get(entryPath));
+					}
+					break;
+				}
 
 				if (target instanceof IResource){
 					// internal target
@@ -623,20 +634,7 @@ public class JavaProject
 				} else if (target instanceof File) {
 					// external target
 					if (JavaModel.isFile(target)) {
-						if (JavaModel.isJimage((File) target)) {
-							PerProjectInfo info = getPerProjectInfo();
-							if (info.jrtRoots == null || !info.jrtRoots.containsKey(entryPath)) {
-								ObjectVector imageRoots = new ObjectVector();
-								loadModulesInJimage(entryPath, imageRoots, rootToResolvedEntries, resolvedEntry, referringEntry);
-								info.setJrtPackageRoots(entryPath, imageRoots);
-								accumulatedRoots.addAll(imageRoots);
-								rootIDs.add(rootID);
-							} else {
-								accumulatedRoots.addAll(info.jrtRoots.get(entryPath));
-							}
-						} else {
 							root = new JarPackageFragmentRoot(entryPath, this);
-						}
 					} else if (((File) target).isDirectory()) {
 						root = new ExternalPackageFragmentRoot(entryPath, this);
 					}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
index b53cbb5..c11e270 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
@@ -23,6 +23,7 @@ import org.eclipse.jdt.internal.compiler.*;
 import org.eclipse.jdt.internal.compiler.Compiler;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
+import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.problem.*;
@@ -236,7 +237,7 @@ protected void addAllSourceFiles(final ArrayList sourceFiles) throws CoreExcepti
 								SourceFile unit = new SourceFile((IFile) resource, sourceLocation);
 								String complianceLevel = AbstractImageBuilder.this.javaBuilder.javaProject.getOption(JavaCore.COMPILER_COMPLIANCE, true);
 								if (CompilerOptions.versionToJdkLevel(complianceLevel) >= ClassFileConstants.JDK9 &&
-										resource.getName().equalsIgnoreCase(ClasspathLocation.MODULE_INFO_JAVA)) {
+										resource.getName().equalsIgnoreCase(IModuleLocation.MODULE_INFO_JAVA)) {
 									sourceLocation.acceptModuleInfo(unit, AbstractImageBuilder.this.compiler.parser);
 								}
 								sourceFiles.add(unit);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
index df40727..85283f6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
@@ -133,9 +133,6 @@ String[] directoryList(String qualifiedPackageName) {
 }
 void acceptModule(ClassFileReader classfile) {
 	if (classfile != null) {
-//		if ((this.module = classfile.getModuleDeclaration()) != null) {
-//			this.env.acceptModule(this.module, this);
-//		}
 		this.module = classfile.getModuleDeclaration();
 	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
index 6f43210..d42aa07 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
@@ -261,7 +261,6 @@ public boolean servesModule(IModule mod) {
 }
 @Override
 public IModule getModule(char[] moduleName) {
-	// 
 	Set<IModule> modules = ModulesCache.get(this.zipFilename);
 	if (modules != null) {
 		for (IModule mod : modules) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
index ab1e17b..b52e473 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
@@ -26,9 +26,6 @@ import org.eclipse.jdt.internal.compiler.util.Util;
 
 public abstract class ClasspathLocation implements IModuleLocation {
 
-	protected static final String MODULE_INFO_JAVA = "MODULE-INFO.JAVA"; //$NON-NLS-1$
-	protected static final String MODULE_INFO_CLASS = "module-info.class"; //$NON-NLS-1$
-
 	static ClasspathLocation forSourceFolder(IContainer sourceFolder, IContainer outputFolder,
 			char[][] inclusionPatterns, char[][] exclusionPatterns, boolean ignoreOptionalProblems,
 			INameEnvironment env) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index b9bb425..f246ba4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -409,7 +409,6 @@ void setNames(String[] typeNames, SourceFile[] additionalFiles) {
 
 @Override
 public IModule getModule(char[] name) {
-	// 
 	if (name == null)
 		return null;
 	IModule module = null;
commit f81497cf3f12c283b35bf7d81ebf758cd023c11d
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Jul 4 20:29:38 2016 +0530

    Bug 487421 - Remove irrelevant changes to the JRTUtil
    and add the new tests to TestAll

5	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index 03300eb..0576a3e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contributions for
@@ -154,6 +158,7 @@ public static Test suite() {
 
 	ArrayList since_9 = new ArrayList();
 	since_9.add(Unicode9Test.class);
+	since_9.add(ModuleCompilationTests.class);
 	
 	// Build final test suite
 	TestSuite all = new TestSuite(TestAll.class.getName());
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
index 1a78a6e..7004933 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
@@ -174,10 +174,12 @@ class JrtFileSystem {
 	void initialize(File jrt) throws IOException {
 		URL url = null;
 		if (jrt.toString().endsWith(JRTUtil.JRT_FS_JAR)) {
-			String jdkHome = jrt.getParent();
-			url = Paths.get(jdkHome).toUri().toURL();
+			url = jrt.toPath().toUri().toURL();
 		} else if (jrt.isDirectory()) {
 			url = jrt.toPath().toUri().toURL();
+		} else {
+			String jdkHome = jrt.getParentFile().getParentFile().getParent();
+			url = Paths.get(jdkHome, JRTUtil.JRT_FS_JAR).toUri().toURL();
 		}
 		JRTUtil.MODULE_TO_LOAD = System.getProperty("modules.to.load"); //$NON-NLS-1$
 		URLClassLoader loader = new URLClassLoader(new URL[] { url });
commit 0171d3fa20410a884ea6de07ec393bc179fb73bd
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Jul 11 13:55:46 2016 +0530

    Bug 487421 - Annotation processing manager in batch compilation mode
    keeps opened JAR files longer than necessary.
    
    Tests are present in the form of ModuleCompilationTests.

18	2	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchAnnotationProcessorManager.java
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchAnnotationProcessorManager.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchAnnotationProcessorManager.java
index 67cc77c..2b195ff 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchAnnotationProcessorManager.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchAnnotationProcessorManager.java
@@ -1,15 +1,21 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2015 IBM Corporation and others.
+ * Copyright (c) 2005, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.apt.dispatch;
 
+import java.io.IOException;
+import java.net.URLClassLoader;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -232,5 +238,15 @@ public class BatchAnnotationProcessorManager extends BaseAnnotationProcessorMana
 		_commandLineProcessors = null;
 		_commandLineProcessorIter = null;
 	}
-
+	@Override
+	public void reset() {
+		super.reset();
+		if (this._procLoader instanceof URLClassLoader) {
+			try {
+				((URLClassLoader) this._procLoader).close();
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+		}
+	}
 }
commit d3394ebb2b5509b3855ea69e34563e28e02dfb91
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Tue Jul 12 14:25:42 2016 +0530

    Bug 487421 - Adding fix + Test for scenarios that use modules as plain
    old JAR.

90	7	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
3	4	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
2	3	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
10	10	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
8	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
15	13	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
6	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index 6da08ea..4e4c0eb 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -346,10 +346,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 				"",
 				false);
 	}
-	public void test010() {
-		Util.flushDirectoryContent(new File(OUTPUT_DIR));
-		String outDir = OUTPUT_DIR + File.separator + "bin";
-		String srcDir = OUTPUT_DIR + File.separator + "src";
+	private void createReusableModules(String srcDir, String outDir, File modDir) {
 		String moduleLoc = srcDir + File.separator + "mod.one";
 		writeFile(moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
@@ -392,7 +389,6 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 				"",
 				false);
 
-		File modDir = new File(OUTPUT_DIR + File.separator + "mod");
 		String fileName = modDir + File.separator + "mod.one.jar";
 		try {
 			Util.zip(new File(outDir + File.separator + "mod.one"), 
@@ -413,7 +409,14 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 
 		Util.flushDirectoryContent(new File(outDir));
 		Util.flushDirectoryContent(new File(srcDir));
-		moduleLoc = srcDir + File.separator + "mod.three";
+	}
+	public void test010() {
+		Util.flushDirectoryContent(new File(OUTPUT_DIR));
+		String outDir = OUTPUT_DIR + File.separator + "bin";
+		String srcDir = OUTPUT_DIR + File.separator + "src";
+		File modDir = new File(OUTPUT_DIR + File.separator + "mod");
+		createReusableModules(srcDir, outDir, modDir);
+		String moduleLoc = srcDir + File.separator + "mod.three";
 		writeFile(moduleLoc, "module-info.java", 
 						"module mod.three { \n" +
 						"	requires mod.one;\n" +
@@ -426,7 +429,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 						"	q.Y y = null;\n" +
 						"}");
 
-		buffer = new StringBuffer();
+		StringBuffer buffer = new StringBuffer();
 			buffer.append("-d " + outDir )
 			.append(" -9 ")
 			.append(" -modulepath \"")
@@ -461,4 +464,84 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 	        "",
 	        true);
 	}
+	// Modules used as regular -classpath (as opposed to -modulepath) and module-info referencing
+	// those modules are reported as missing.
+	public void test012() {
+		Util.flushDirectoryContent(new File(OUTPUT_DIR));
+		String outDir = OUTPUT_DIR + File.separator + "bin";
+		String srcDir = OUTPUT_DIR + File.separator + "src";
+		File modDir = new File(OUTPUT_DIR + File.separator + "mod");
+		createReusableModules(srcDir, outDir, modDir);
+		String moduleLoc = srcDir + File.separator + "mod.three";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.three { \n" +
+						"	requires mod.one;\n" +
+						"	requires mod.two;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "Z.java", 
+						"package r;\n" +
+						"public class Z extends Object {\n" +
+						"	p.X x = null;\n" +
+						"	q.Y y = null;\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+			buffer.append("-d " + outDir )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append(modDir + File.separator + "mod.one.jar").append(File.pathSeparator)
+			.append(modDir + File.separator + "mod.two").append(File.pathSeparator)
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + srcDir + "\"");
+
+		runNegativeTest(new String[]{},
+				buffer.toString(), 
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/module-info.java (at line 2)\n" + 
+				"	requires mod.one;\n" + 
+				"	         ^^^^^^^\n" + 
+				"mod.one cannot be resolved to a module\n" + 
+				"----------\n" + 
+				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/module-info.java (at line 3)\n" + 
+				"	requires mod.two;\n" + 
+				"	         ^^^^^^^\n" + 
+				"mod.two cannot be resolved to a module\n" + 
+				"----------\n" + 
+				"2 problems (2 errors)\n",
+				false);
+	}
+	// Modules used as regular -classpath as opposed to -modulepath. The files being compiled
+	// aren't part of any modules (i.e. module-info is missing). The files should be able to
+	// reference the types from referenced classpath.
+	public void test013() {
+		Util.flushDirectoryContent(new File(OUTPUT_DIR));
+		String outDir = OUTPUT_DIR + File.separator + "bin";
+		String srcDir = OUTPUT_DIR + File.separator + "src";
+		File modDir = new File(OUTPUT_DIR + File.separator + "mod");
+		createReusableModules(srcDir, outDir, modDir);
+		String moduleLoc = srcDir + File.separator + "mod.three";
+		writeFile(moduleLoc + File.separator + "p", "Z.java", 
+						"package r;\n" +
+						"public class Z extends Object {\n" +
+						"	p.X x = null;\n" +
+						"	q.Y y = null;\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+			buffer.append("-d " + outDir )
+			.append(" -9")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append(modDir + File.separator + "mod.one.jar").append(File.pathSeparator)
+			.append(modDir + File.separator + "mod.two").append(File.pathSeparator)
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + srcDir + "\"");
+		runConformTest(new String[]{},
+				buffer.toString(), 
+				"",
+				"",
+				false);
+	}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index 940c69d..e65a491 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -233,11 +233,10 @@ protected void addTypeName(final ArrayList answers, String fileName, int last, c
 	}
 }
 public void initialize() throws IOException {
-	if (this.zipFile == null) {
+	if (this.isJrt) {
+		loadModules();
+	} else if (this.zipFile == null) {
 		this.zipFile = new ZipFile(this.file);
-		if (this.isJrt) {
-			 loadModules();
-		}
 	}
 }
 public void acceptModule(IModule mod) {
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 0ecd1d5..290a421 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -3276,19 +3276,18 @@ protected ArrayList handleModuleSourcepath(String arg) {
 		for (int i = 0; i < paths.length; i++) {
 			File dir = new File(paths[i]);
 			if (dir.isDirectory()) {
-//				List<String> mods = ModuleFinder.findFolders(dir);
 				// 1. Create FileSystem.Classpath for each module
 				// 2. Iterator each module in case of directory for source files and add to this.fileNames
 
 				modulePaths =
 						(ArrayList) ModuleFinder.findModules(dir, this.destinationPath, getNewParser(), this.options, true);
-				
 				for (Object obj : modulePaths) {
 					Classpath classpath = (Classpath) obj;
 					File modLocation = new File(classpath.getPath());
 					String[] result = FileFinder.find(modLocation, SuffixConstants.SUFFIX_STRING_java);
 					String destPath = classpath.getDestinationPath();
-					String moduleName = new String(classpath.getModule().name());
+					IModule mod = classpath.getModule();
+					String moduleName = mod == null ? null : new String(mod.name());
 
 					// Add them to this.filenames
 					if (this.filenames != null) {
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
index c9dd31f..ff9495d 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
@@ -70,17 +70,17 @@ public class ModuleFinder {
 				} else if (isJar(file)){
 					module = extractModuleFromJar(file);
 				}
-				if (module != null) {
-					FileSystem.Classpath modulePath = FileSystem.getClasspath(
-							file.getAbsolutePath(),
-							null,
-							sourceOnly,
-							null,
-							destinationPath == null ? null : (destinationPath + File.separator + file.getName()), 
-							options);
-					modulePath.acceptModule(module);
+				FileSystem.Classpath modulePath = FileSystem.getClasspath(
+						file.getAbsolutePath(),
+						null,
+						sourceOnly,
+						null,
+						destinationPath == null ? null : (destinationPath + File.separator + file.getName()), 
+						options);
+				if (modulePath != null)
 					collector.add(modulePath);
-				}
+				if (module != null)
+					modulePath.acceptModule(module);
 			}
 		}
 		return collector;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
index 0279e6e..494e270 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
@@ -327,5 +327,12 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 		}
 		return null;
 	}
-
+//	@Override
+//	public boolean isModule() {
+//	 	try {
+//	 		return ((PackageFragmentRootInfo) getElementInfo()).isModule(resource(), this);
+//	 	} catch (JavaModelException e) {
+//	 		return false;
+//	 	}
+//	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
index c0b4ecc..7460fd4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
@@ -614,19 +614,8 @@ public class JavaProject
 				if (referringEntry != null  && !resolvedEntry.isExported())
 					return;
 				Object target = JavaModel.getTarget(entryPath, true/*check existency*/);
-				if (target == null || JavaModelManager.isJrt(entryPath)) {
-					PerProjectInfo info = getPerProjectInfo();
-					if (info.jrtRoots == null || !info.jrtRoots.containsKey(entryPath)) {
-						ObjectVector imageRoots = new ObjectVector();
-						loadModulesInJimage(entryPath, imageRoots, rootToResolvedEntries, resolvedEntry, referringEntry);
-						info.setJrtPackageRoots(entryPath, imageRoots);
-						accumulatedRoots.addAll(imageRoots);
-						rootIDs.add(rootID);
-					} else {
-						accumulatedRoots.addAll(info.jrtRoots.get(entryPath));
-					}
-					break;
-				}
+				if (target == null)
+					return;
 
 				if (target instanceof IResource){
 					// internal target
@@ -634,7 +623,20 @@ public class JavaProject
 				} else if (target instanceof File) {
 					// external target
 					if (JavaModel.isFile(target)) {
+						if (JavaModel.isJimage((File) target)) {
+							PerProjectInfo info = getPerProjectInfo();
+							if (info.jrtRoots == null || !info.jrtRoots.containsKey(entryPath)) {
+								ObjectVector imageRoots = new ObjectVector();
+								loadModulesInJimage(entryPath, imageRoots, rootToResolvedEntries, resolvedEntry, referringEntry);
+								info.setJrtPackageRoots(entryPath, imageRoots);
+								accumulatedRoots.addAll(imageRoots);
+								rootIDs.add(rootID);
+							} else {
+								accumulatedRoots.addAll(info.jrtRoots.get(entryPath));
+							}
+						} else {
 							root = new JarPackageFragmentRoot(entryPath, this);
+						}
 					} else if (((File) target).isDirectory()) {
 						root = new ExternalPackageFragmentRoot(entryPath, this);
 					}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
index 7e5205d..b750137 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
@@ -93,6 +93,12 @@ public class NameLookup implements SuffixConstants {
 			return otherAnswer.restriction != null
 				&& this.restriction.getProblemId() < otherAnswer.restriction.getProblemId();
 		}
+		public String toString() {
+			StringBuilder builder = new StringBuilder(this.type.toString());
+			builder.append("from ") //$NON-NLS-1$
+			.append(this.module);
+			return builder.toString();
+		}
 	}
 
 	// TODO (jerome) suppress the accept flags (qualified name is sufficient to find a type)
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
index d42aa07..5494ca0 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
@@ -199,7 +199,7 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 					// don't let error on annotations fail class reading
 				}
 			}
-			return new NameEnvironmentAnswer(reader, null, mod.name());
+			return new NameEnvironmentAnswer(reader, null, reader.moduleName);
 		}
 	} catch (IOException e) { // treat as if class file is missing
 	} catch (ClassFormatException e) { // treat as if class file is missing
commit f0f641b3af283f3c43e564deb03410e086ca0ff5
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Jul 25 15:39:47 2016 +0530

    Bug 487421 - Added support for --add-exports and --add-reads

4	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/Compliance_1_5.java
382	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
72	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
69	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
112	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
7	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
15	18	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 44c142b..3c6c7f7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1623,6 +1623,10 @@ public void test012(){
         "                       jar file are put in the user.dir folder in case no\n" +
         "                       general ''-d'' option is specified. ZIP archives cannot\n" +
         "                       override the general ''-d'' option\n" +
+        "    -modulesourcepath <directories separated by " + File.pathSeparator + ">\n" +
+        "                       specify where to find source files for multiple modules\n" +
+        "    -mp -modulepath <directories separated by " + File.pathSeparator + ">\n" +
+        "                       specify where to find application modules\n" +
         "    -extdirs <directories separated by " + File.pathSeparator + ">\n" +
         "                       specify location for extension ZIP archives\n" +
         "    -endorseddirs <directories separated by " + File.pathSeparator + ">\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/Compliance_1_5.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/Compliance_1_5.java
index 556695c..30e90c6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/Compliance_1_5.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/Compliance_1_5.java
@@ -2972,7 +2972,7 @@ public void test088() {
 		"Type null of the last argument to method getMethod(String, Class...) doesn't exactly match the vararg parameter type. Cast to Class[] to confirm the non-varargs invocation, or pass individual arguments of type Class for a varargs invocation.\n" +
 		"----------\n";
 	String javaVersion = System.getProperty("java.version");
-	if (isJRELevel(AbstractCompilerTest.F_1_6|AbstractCompilerTest.F_1_7|AbstractCompilerTest.F_1_8)
+	if (isJRELevel(AbstractCompilerTest.F_1_6|AbstractCompilerTest.F_1_7|AbstractCompilerTest.F_1_8|AbstractCompilerTest.F_9)
 			|| (AbstractCompilerTest.getPossibleComplianceLevels() == AbstractCompilerTest.F_1_5
 				&& javaVersion.indexOf("1.5") == -1)) {
 		errorMessage =
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index 5a0054c..424697b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -26,7 +26,7 @@ import junit.framework.Test;
 public class ModuleCompilationTests extends BatchCompilerTest {
 
 	static {
-//		 TESTS_NAMES = new String[] { "test001" };
+//		 TESTS_NAMES = new String[] { "test022" };
 		// TESTS_NUMBERS = new int[] { 1 };
 		// TESTS_RANGE = new int[] { 298, -1 };
 	}
@@ -432,7 +432,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		StringBuffer buffer = new StringBuffer();
 			buffer.append("-d " + outDir )
 			.append(" -9 ")
-			.append(" -modulepath \"")
+			.append(" -mp \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append(modDir.getAbsolutePath())
 			.append("\" ")
@@ -596,4 +596,384 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		String expectedOutput = "// Compiled from X.java (version 9 : 53.0, super bit)";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput);
 	}
+	public void test014() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	requires java.base;\n" +
+						"	requires mod.one;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+						"package q;\n" +
+						"public class Y {\n" +
+						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --add-exports mod.one/p=mod.two");
+
+		runConformTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"",
+				false);
+	}
+	public void test015() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	requires java.base;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+						"package q;\n" +
+						"public class Y {\n" +
+						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --add-exports mod.one/p=mod.two");
+
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 3)\n" + 
+				"	java.sql.Connection con = p.X.getConnection();\n" + 
+				"	                          ^^^\n" + 
+				"The type p.X is not visible\n" + 
+				"----------\n" + 
+				"1 problem (1 error)\n",
+				false);
+	}
+	public void test016() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	requires java.base;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+						"package q;\n" +
+						"public class Y {\n" +
+						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --add-exports mod.one/p=mod.two")
+			.append(" --add-reads mod.two=mod.one");
+
+		runConformTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"",
+				false);
+	}
+	public void test017() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	requires java.base;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+						"package q;\n" +
+						"public class Y {\n" +
+						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --add-exports mod.one/p=mod.three")
+			.append(" --add-reads mod.two=mod.one");
+
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 3)\n" + 
+				"	java.sql.Connection con = p.X.getConnection();\n" + 
+				"	                          ^^^\n" + 
+				"The type p.X is not visible\n" + 
+				"----------\n" + 
+				"1 problem (1 error)\n",
+				false);
+	}
+	public void test018() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	requires java.base;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+						"package q;\n" +
+						"public class Y {\n" +
+						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"}");
+		moduleLoc = directory + File.separator + "mod.three";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.three { \n" +
+						"	requires java.base;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "r", "Z.java", 
+						"package r;\n" +
+						"public class Z {\n" +
+						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"}");
+
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --add-exports mod.one/p=mod.two,mod.three")
+			.append(" --add-reads mod.two=mod.one")
+			.append(" --add-reads mod.three=mod.one");
+
+		runConformTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"",
+				false);
+	}
+	/*
+	 * Unnamed module tries to access a type from an unexported package successfully. 
+	 */
+	public void test019() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public abstract class X extends sun.management.FileSystem {\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -sourcepath " + "\"" + moduleLoc + "\" ")
+			.append(moduleLoc + File.separator + "p" + File.separator + "X.java");
+
+		runConformTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"",
+				false);
+	}
+	public void test020() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --add-exports mod.one=mod.two,mod.three");
+
+		runNegativeTest(new String[]{}, 
+				buffer.toString(),
+				"",
+				"incorrectly formatted option: --add-exports mod.one=mod.two,mod.three\r\n",
+				false);
+	}
+	public void test021() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --add-reads mod.one/mod.two");
+
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"incorrectly formatted option: --add-reads mod.one/mod.two\r\n",
+				false);
+	}
+	public void test022() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "p", "X.java", 
+						"package p;\n" +
+						"public class X {\n" +
+						"	public static java.sql.Connection getConnection() {\n" +
+						"		return null;\n" +
+						"	}\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --add-exports mod.one/p=mod.three")
+			.append(" --add-exports mod.one/p=mod.three");
+
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"can specify a package in a module only once with --add-export\n",
+				false);
+	}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
index 306052e..b4f865f 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
@@ -32,6 +32,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
 import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.util.JRTUtil;
@@ -40,6 +41,13 @@ import org.eclipse.jdt.internal.compiler.util.Util;
 
 @SuppressWarnings({ "rawtypes", "unchecked" })
 public class FileSystem extends ModuleEnvironment implements SuffixConstants {
+	/**
+	 * A <code>Classpath<code>, even though an IModuleLocation, can represent a plain
+	 * classpath location too. The FileSystem tells the Classpath whether to behave as a module or regular class
+	 * path via {@link Classpath#acceptModule(IModule)}.
+	 *
+	 * Sub types of classpath are responsible for appropriate behavior based on this.
+	 */
 	public interface Classpath extends IModuleLocation {
 		char[][][] findTypeNames(String qualifiedPackageName, IModule module);
 		/**
@@ -83,6 +91,11 @@ public class FileSystem extends ModuleEnvironment implements SuffixConstants {
 		 * @param qualifiedTypeName type name in qualified /-separated notation.
 		 */
 		boolean hasAnnotationFileFor(String qualifiedTypeName);
+		/**
+		 * Accepts to represent a module location with the given module description.
+		 *
+		 * @param module
+		 */
 		public void acceptModule(IModule module);
 		public String getDestinationPath();
 		public IModule getModule();
@@ -123,6 +136,8 @@ public class FileSystem extends ModuleEnvironment implements SuffixConstants {
 	// Used only in single-module mode when the module descriptor is
 	// provided via command lin.
 	protected IModule module;
+	protected Map<String, IPackageExport[]> addonExports;
+	protected Map<String, String[]> addonReads;
 	Set knownFileNames;
 	protected boolean annotationsFromClasspath; // should annotation files be read from the classpath (vs. explicit separate path)?
 	private static HashMap<File, Classpath> JRT_CLASSPATH_CACHE = null;
@@ -462,6 +477,63 @@ public boolean isPackage(char[][] compoundName, char[] packageName, IModule[] mo
 	}
 	return false;
 }
+void addReads(String source, String target) {
+	if (this.addonReads == null) {
+		this.addonReads = new HashMap<>();
+	}
+	String[] existing = this.addonReads.get(source);
+	if (existing == null || existing.length == 0) {
+		existing = new String[1];
+		existing[0] = target;
+		this.addonReads.put(new String(source), existing);
+	} else {
+		String[] updated = new String[existing.length + 1];
+		System.arraycopy(existing, 0, updated, 0, 1);
+		updated[existing.length] = target;
+		this.addonReads.put(source, updated);
+	}
+}
+void setAddonExports(Map<String, IPackageExport[]> exports) {
+	this.addonExports = exports;
+}
+@Override
+protected void collectAllVisibleModules(IModule mod, Set<IModule> targets, boolean onlyPublic) {
+	if (mod != null && this.addonReads != null) {
+		String[] reads = this.addonReads.get(new String(mod.name()));
+		if (reads != null) {
+			for (String read : reads) {
+				IModule refModule = getModule(read.toCharArray());
+				if (refModule != null) {
+					targets.add(refModule);
+				}
+			}
+		}
+	}
+	super.collectAllVisibleModules(mod,  targets, onlyPublic);
+}
+@Override
+protected boolean isPackageExportedTo(IModule mod, char[] pack, IModule client) {
+	if (this.addonExports != null) {
+		IPackageExport[] export = this.addonExports.get(new String(mod.name()));
+		if (export != null) {
+			for (IPackageExport iPackageExport : export) {
+				if (CharOperation.equals(iPackageExport.name(), pack)) {
+					char[][] exportedTo = iPackageExport.exportedTo();
+					if (exportedTo == null || exportedTo.length == 0) {
+						// Continue. Spec doesn't say whether exported can't be universal (i.e. without to any specific module)
+					}
+					for (char[] cs : exportedTo) {
+						if (CharOperation.equals(cs, client.name())) {
+							return true;
+						}
+					}
+
+				}
+			}
+		}
+	}
+	return super.isPackageExportedTo(mod, pack, client);
+}
 @Override
 public IModule getModule(char[] name) {
 	if (name == null)
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index b5ad792..6c00d92 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -52,6 +52,7 @@ import java.text.DateFormat;
 import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.Date;
 import java.util.HashMap;
@@ -89,6 +90,7 @@ import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
+import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.CompilerStats;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
@@ -1332,6 +1334,9 @@ public class Main implements ProblemSeverities, SuffixConstants {
 	protected List<String> annotationPaths;
 	protected boolean annotationsFromClasspath;
 
+	private List<String> addonExports = Collections.EMPTY_LIST;
+	private List<String> addonReads = Collections.EMPTY_LIST;
+
 	public Locale compilerLocale;
 	public CompilerOptions compilerOptions; // read-only
 	public CompilationProgress progress;
@@ -1800,6 +1805,8 @@ public void configure(String[] argv) {
 	final int INSIDE_ANNOTATIONPATH_start = 22;
 	final int INSIDE_MODULEPATH_start = 23;
 	final int INSIDE_MODULESOURCEPATH_start = 24;
+	final int INSIDE_ADD_EXPORTS = 25;
+	final int INSIDE_ADD_READS = 26;
 
 	final int DEFAULT = 0;
 	ArrayList bootclasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
@@ -2146,7 +2153,7 @@ public void configure(String[] argv) {
 					mode = INSIDE_BOOTCLASSPATH_start;
 					continue;
 				}
-				if (currentArg.equals("-modulepath") || currentArg.equals("-cp")) { //$NON-NLS-1$ //$NON-NLS-2$
+				if (currentArg.equals("-modulepath") || currentArg.equals("-mp")) { //$NON-NLS-1$ //$NON-NLS-2$
 					mode = INSIDE_MODULEPATH_start;
 					continue;
 				}
@@ -2154,6 +2161,14 @@ public void configure(String[] argv) {
 					mode = INSIDE_MODULESOURCEPATH_start;
 					continue;
 				}
+				if (currentArg.equals("--add-exports")) { //$NON-NLS-1$
+					mode = INSIDE_ADD_EXPORTS;
+					continue;
+				}
+				if (currentArg.equals("--add-reads")) { //$NON-NLS-1$
+					mode = INSIDE_ADD_READS;
+					continue;
+				}
 				if (currentArg.equals("-sourcepath")) {//$NON-NLS-1$
 					if (sourcepathClasspathArg != null) {
 						StringBuffer errorMessage = new StringBuffer();
@@ -2672,6 +2687,21 @@ public void configure(String[] argv) {
 				index += processPaths(newCommandLineArgs, index, currentArg, moduleSourcepaths);
 				moduleSourcepathArg = moduleSourcepaths[0];
 				continue;
+			case INSIDE_ADD_EXPORTS:
+				mode = DEFAULT;
+				// TODO: better to validate the option before processing it further?
+				if (this.addonExports == Collections.EMPTY_LIST) {
+					this.addonExports = new ArrayList<>();
+				}
+				this.addonExports.add(currentArg);
+				continue;
+			case INSIDE_ADD_READS:
+				mode = DEFAULT;
+				if (this.addonReads == Collections.EMPTY_LIST) {
+					this.addonReads = new ArrayList<>();
+				}
+				this.addonReads.add(currentArg);
+				continue;
 			case INSIDE_CLASSPATH_start:
 				mode = DEFAULT;
 				index += processPaths(newCommandLineArgs, index, currentArg, classpaths);
@@ -3203,6 +3233,7 @@ public FileSystem getLibraryAccess() {
 	FileSystem nameEnvironment = new FileSystem(this.checkedClasspaths, this.filenames, 
 					this.annotationsFromClasspath && CompilerOptions.ENABLED.equals(this.options.get(CompilerOptions.OPTION_AnnotationBasedNullAnalysis)));
 	nameEnvironment.module = this.module;
+	processAddonModuleOptions(nameEnvironment);
 	return nameEnvironment;
 }
 
@@ -3240,6 +3271,43 @@ protected ArrayList handleBootclasspath(ArrayList bootclasspaths, String customE
 	}
 	return bootclasspaths;
 }
+private void processAddonModuleOptions(FileSystem env) {
+	Map<String, IPackageExport[]> exports = new HashMap<>();
+	for (String option : this.addonExports) {
+		IModule mod = ModuleFinder.extractAddonExport(option);
+		if (mod != null) {
+			String modName = new String(mod.name());
+			IPackageExport export = mod.exports()[0];
+			IPackageExport[] existing = exports.get(modName);
+			if (existing == null) {
+				existing = new IPackageExport[1];
+				existing[0] = export;
+				exports.put(modName, existing);
+			} else {
+				for (IPackageExport iPackageExport : existing) {
+					if (CharOperation.equals(iPackageExport.name(), export.name())) {
+						throw new IllegalArgumentException(this.bind("configure.duplicateExport")); //$NON-NLS-1$
+					}
+				}
+				IPackageExport[] updated = new IPackageExport[existing.length + 1];
+				System.arraycopy(existing, 0, updated, 0, existing.length);
+				updated[existing.length] = export;
+				exports.put(new String(modName), updated);
+			}
+			env.setAddonExports(exports);
+		} else {
+			throw new IllegalArgumentException(this.bind("configure.invalidModuleOption", "--add-exports " + option)); //$NON-NLS-1$ //$NON-NLS-2$
+		}
+	}
+	for (String option : this.addonReads) {
+		String[] result = ModuleFinder.extractAddonRead(option);
+		if (result != null && result.length == 2) {
+			env.addReads(result[0], result[1]);
+		} else {
+			throw new IllegalArgumentException(this.bind("configure.invalidModuleOption", "--add-reads " + option)); //$NON-NLS-1$ //$NON-NLS-2$
+		}
+	}
+}
 protected ArrayList handleModulepath(String arg) {
 	ArrayList<String> modulePaths = processModulePathEntries(arg);
 	final int classpathsSize;
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
index ff9495d..f9d9983 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ModuleFinder.java
@@ -21,6 +21,7 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.StringTokenizer;
 import java.util.zip.ZipFile;
 
 import org.eclipse.jdt.internal.compiler.CompilationResult;
@@ -29,6 +30,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
 import org.eclipse.jdt.internal.compiler.env.IModuleLocation;
 import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
@@ -85,6 +87,116 @@ public class ModuleFinder {
 		}
 		return collector;
 	}
+	/**
+	 * Extracts the single reads clause from the given
+	 * command line option (--add-reads). The result is a String[] with two
+	 * element, first being the source module and second being the target module.
+	 * The expected format is: 
+	 *  --add-reads <source-module>=<target-module>
+	 * @param option
+	 * @return a String[] with source and target module of the "reads" clause. 
+	 */
+	protected static String[] extractAddonRead(String option) {
+		StringTokenizer tokenizer = new StringTokenizer(option, "="); //$NON-NLS-1$
+		String source = null;
+		String target = null;
+		if (tokenizer.hasMoreTokens()) {
+			source = tokenizer.nextToken();
+		} else {
+			// Handle error
+			return null;
+		}
+		if (tokenizer.hasMoreTokens()) {
+			target = tokenizer.nextToken();
+		} else {
+			// Handle error
+			return null;
+		}
+ 		return new String[]{source, target};
+	}
+	/**
+	 * Parses the --add-exports command line option and returns the package export definitions
+	 * in the form of an IModule. Note the IModule returned only holds this specific exports-to
+	 * clause and can't by itself be used as a module description.
+	 *
+	 * The expected format is:
+	 *   --add-exports <source-module>/<package>=<target-module>(,<target-module>)*
+	 * @param option
+	 * @return a dummy module object with package exports
+	 */
+	protected static IModule extractAddonExport(String option) {
+		StringTokenizer tokenizer = new StringTokenizer(option, "/"); //$NON-NLS-1$
+		String source = null;
+		String pack = null;
+		List<String> targets = new ArrayList<>();
+		if (tokenizer.hasMoreTokens()) {
+			source = tokenizer.nextToken("/"); //$NON-NLS-1$
+		} else {
+			// Handle error
+			return null;
+		}
+		if (tokenizer.hasMoreTokens()) {
+			pack = tokenizer.nextToken("/="); //$NON-NLS-1$
+		} else {
+			// Handle error
+			return null;
+		}
+		while (tokenizer.hasMoreTokens()) {
+			targets.add(tokenizer.nextToken("=,")); //$NON-NLS-1$
+		}
+		PackageExport export = new PackageExport(pack.toCharArray());
+		export.exportedTo = new char[targets.size()][];
+		for(int i = 0; i < export.exportedTo.length; i++) {
+			export.exportedTo[i] = targets.get(i).toCharArray();
+		}
+		return new Module(source.toCharArray(), export);
+	}
+
+	static class PackageExport implements IPackageExport {
+		char[] name;
+		char[][] exportedTo;
+		PackageExport(char[] name) {
+			this.name = name;
+		}
+		@Override
+		public char[] name() {
+			return this.name;
+		}
+		@Override
+		public char[][] exportedTo() {
+			return this.exportedTo;
+		}
+	}
+	
+	static class Module implements IModule {
+		char[] name;
+		IPackageExport[] export;
+		Module(char[] name, IPackageExport export) {
+			this.name = name;
+			this.export = new IPackageExport[]{export};
+		}
+		@Override
+		public char[] name() {
+			return this.name;
+		}
+		@Override
+		public IModuleReference[] requires() {
+			return null;
+		}
+		@Override
+		public IPackageExport[] exports() {
+			return this.export;
+		}
+		@Override
+		public char[][] uses() {
+			return null;
+		}
+		@Override
+		public IService[] provides() {
+			return null;
+		}
+	}
+	
 	private static boolean isJar(File file) {
 		int format = Util.archiveFormat(file.getAbsolutePath());
 		return format >= Util.ZIP_FILE;
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index b1f22f5..13bba63 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -65,7 +65,9 @@ configure.source = source level should be comprised in between ''1.3'' and ''1.8
 configure.duplicateOutputPath = duplicate output path specification: {0}
 configure.duplicateModulePath = duplicate module path specification: {0}
 configure.duplicateModuleSourcepath = duplicate source module path specification: {0}
-configure.invalidModuleDescriptor = Cannot open the module descriptor from {0}
+configure.invalidModuleDescriptor = cannot open the module descriptor from {0}
+configure.invalidModuleOption = incorrectly formatted option: {0}
+configure.duplicateExport = can specify a package in a module only once with --add-export
 configure.duplicateBootClasspath = duplicate bootclasspath specification: {0}
 configure.duplicateExtDirs = duplicate extdirs specification: {0}
 configure.duplicateSourcepath = duplicate sourcepath specification: {0}
@@ -175,6 +177,10 @@ misc.usage = {1} {2}\n\
 \                       jar file are put in the user.dir folder in case no\n\
 \                       general ''-d'' option is specified. ZIP archives cannot\n\
 \                       override the general ''-d'' option\n\
+\    -modulesourcepath <directories separated by {0}>\n\
+\                       specify where to find source files for multiple modules\n\
+\    -mp -modulepath <directories separated by {0}>\n\
+\                       specify where to find application modules\n\
 \    -extdirs <directories separated by {0}>\n\
 \                       specify location for extension ZIP archives\n\
 \    -endorseddirs <directories separated by {0}>\n\
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
index 4a7887c..5923b4a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
@@ -132,31 +132,28 @@ public abstract class ModuleEnvironment implements INameEnvironmentExtension {
 		IModule source = getModule(sourceName);
 		IModule client = getModule(clientName);
 		if (client != null) {
-			IModule.IModuleReference[] requires = client.requires();
-			if (requires != null && requires.length > 0) {
-				for (IModule.IModuleReference ref : requires) {
-					IModule refModule = getModule(ref.name());
-					if (refModule == null) 
-						continue;
-					if (refModule == source && isPackageExportedTo(refModule, packageName, client)) {
-						return true;
-					}
 					Set<IModule> set = new LinkedHashSet<>();
-					collectAllVisibleModules(refModule, set, true);
+					collectAllVisibleModules(client, set, false);
 					IModule[] targets = set.toArray(new IModule[set.size()]);
 					for (IModule iModule : targets) {
 						if (iModule == source && isPackageExportedTo(iModule, packageName, client)) {
 							return true;
 						}
 					}
-				}
-			}
 			return false;
 		}
 		return true;
 	}
-
-	private boolean isPackageExportedTo(IModule module, char[] pack, IModule client) {
+	/**
+	 * Tells whether the given module exports the given package to the specified client
+	 * module.
+	 *
+	 * @param module module whose exports being checked
+	 * @param pack package being exported
+	 * @param client requesting module
+	 * @return whether or not the specified package is exported from the module to the client
+	 */
+	protected boolean isPackageExportedTo(IModule module, char[] pack, IModule client) {
 		IModule.IPackageExport[] exports = module.exports();
 		if (exports != null && exports.length > 0) {
 			for (IModule.IPackageExport iPackageExport : exports) {
@@ -195,7 +192,7 @@ public abstract class ModuleEnvironment implements INameEnvironmentExtension {
 		return targets;
 	}
 
-	private void collectAllVisibleModules(IModule module, Set<IModule> targets, boolean onlyPublic) {
+	protected void collectAllVisibleModules(IModule module, Set<IModule> targets, boolean onlyPublic) {
 		if (module != null) {
 			IModule.IModuleReference[] requires = module.requires();
 			if (requires != null && requires.length > 0) {
@@ -203,8 +200,8 @@ public abstract class ModuleEnvironment implements INameEnvironmentExtension {
 					IModule refModule = getModule(ref.name());
 					if (refModule != null) {
 						if (!onlyPublic || ref.isPublic()) {
-						targets.add(refModule);
-						collectAllVisibleModules(refModule, targets, true);
+							targets.add(refModule);
+							collectAllVisibleModules(refModule, targets, true);
 						}
 					}
 				}
@@ -317,7 +314,7 @@ public abstract class ModuleEnvironment implements INameEnvironmentExtension {
 		ser.with = CharOperation.concatWith(with.getTypeName(), '.');
 		return ser;
 	}
-	static class Module implements IModule {
+	protected static class Module implements IModule {
 		char[] name;
 		ModuleReferenceImpl[] requires;
 		PackageExport[] exports;
commit 0dff5b553b17731a5729d0dfa1913bcb444b32d9
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Aug 1 11:49:57 2016 +0530

    Bug 487421 - [1.9][batch] Support Java 9 options in command line
    compiler
    
    Adding -system option plus tests.

0	3	org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/BatchTestUtils.java
7	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
140	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
23	5	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
12	6	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
42	14	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
diff --git a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/BatchTestUtils.java b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/BatchTestUtils.java
index 443ea10..98eba96 100644
--- a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/BatchTestUtils.java
+++ b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/BatchTestUtils.java
@@ -278,14 +278,11 @@ public class BatchTestUtils {
 		if (c == null) {
 			junit.framework.TestCase.assertTrue("Eclipse compiler is not available", false);
 		}
-		int compilerCounter = 0;
 		for (JavaCompiler javaCompiler : javaCompilerLoader) {
-			compilerCounter++;
 			if (c.isInstance(javaCompiler)) {
 				_eclipseCompiler = javaCompiler;
 			}
 		}
-		junit.framework.TestCase.assertEquals("Only one compiler available", 1, compilerCounter);
 		junit.framework.TestCase.assertNotNull("No Eclipse compiler found", _eclipseCompiler);
 	}
 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 3c6c7f7..5367cbe 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1623,10 +1623,6 @@ public void test012(){
         "                       jar file are put in the user.dir folder in case no\n" +
         "                       general ''-d'' option is specified. ZIP archives cannot\n" +
         "                       override the general ''-d'' option\n" +
-        "    -modulesourcepath <directories separated by " + File.pathSeparator + ">\n" +
-        "                       specify where to find source files for multiple modules\n" +
-        "    -mp -modulepath <directories separated by " + File.pathSeparator + ">\n" +
-        "                       specify where to find application modules\n" +
         "    -extdirs <directories separated by " + File.pathSeparator + ">\n" +
         "                       specify location for extension ZIP archives\n" +
         "    -endorseddirs <directories separated by " + File.pathSeparator + ">\n" +
@@ -1641,6 +1637,13 @@ public void test012(){
         "                       If multiple default encodings are specified, the last\n" + 
         "                       one will be used.\n" + 
         " \n" +
+        " Module compilation options:\n" +
+        "   These options are meaningful only in Java 9 environment or later.\n" +
+        "    -modulesourcepath <directories separated by ;>\n" +
+        "                       specify where to find source files for multiple modules\n" +
+        "    -mp -modulepath <directories separated by ;>\n" +
+        "                       specify where to find application modules\n" +
+        "    -system <jdk>      Override location of system modules \n" +
         " Compliance options:\n" +
         "    -1.3               use 1.3 compliance (-source 1.3 -target 1.1)\n" +
         "    -1.4             + use 1.4 compliance (-source 1.3 -target 1.2)\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index 424697b..259309f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -976,4 +976,144 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 				"can specify a package in a module only once with --add-export\n",
 				false);
 	}
+	public void test023() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append("\"" + OUTPUT_DIR +  File.separator + "module-info.java\" ")
+			.append(" -extdirs " + OUTPUT_DIR + File.separator + "src");
+
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"option -extdirs not supported at compliance level 9 and above\n",
+				false);
+	}
+	public void test024() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" \"" + OUTPUT_DIR +  File.separator + "module-info.java\" ")
+			.append(" -bootclasspath " + OUTPUT_DIR + File.separator + "src");
+
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"option -bootclasspath not supported at compliance level 9 and above\n",
+				false);
+	}
+	public void test025() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append("\"" + OUTPUT_DIR +  File.separator + "module-info.java\" ")
+			.append(" -endorseddirs " + OUTPUT_DIR + File.separator + "src");
+
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"option -endorseddirs not supported at compliance level 9 and above\n",
+				false);
+	}
+	public void test026() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"	requires public java.sql;\n" +
+						"}");
+		String javaHome = System.getProperty("java.home");
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -system \"").append(javaHome).append("\"")
+			.append(" \"" + moduleLoc +  File.separator + "module-info.java\" ");
+
+		runConformTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"",
+				false);
+	}
+	public void test027() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	requires java.base;\n" +
+						"}");
+		String javaHome = System.getProperty("java.home");
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -system \"").append(javaHome).append(File.separator)
+			.append("lib\"")
+			.append(" \"" + moduleLoc +  File.separator + "module-info.java\" ");
+
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"----------\n"+
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/module-info.java (at line 1)\n"+
+				"	module mod.one { \n"+
+				"	^\n"+
+				"The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files\n"+
+				"----------\n"+
+				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/module-info.java (at line 2)\n"+
+				"	requires java.base;\n"+
+				"	         ^^^^^^^^^\n"+
+				"java.base cannot be resolved to a module\n"+
+				"----------\n"+
+				"2 problems (2 errors)\n",
+				false);
+	}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 6c00d92..f1cd5fb 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -1807,6 +1807,7 @@ public void configure(String[] argv) {
 	final int INSIDE_MODULESOURCEPATH_start = 24;
 	final int INSIDE_ADD_EXPORTS = 25;
 	final int INSIDE_ADD_READS = 26;
+	final int INSIDE_SYSTEM = 27;
 
 	final int DEFAULT = 0;
 	ArrayList bootclasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
@@ -2153,6 +2154,10 @@ public void configure(String[] argv) {
 					mode = INSIDE_BOOTCLASSPATH_start;
 					continue;
 				}
+				if (currentArg.equals("-system")) { //$NON-NLS-1$
+					mode = INSIDE_SYSTEM;
+					continue;
+				}
 				if (currentArg.equals("-modulepath") || currentArg.equals("-mp")) { //$NON-NLS-1$ //$NON-NLS-2$
 					mode = INSIDE_MODULEPATH_start;
 					continue;
@@ -2675,6 +2680,11 @@ public void configure(String[] argv) {
 				setDestinationPath(currentArg.equals(NONE) ? NONE : currentArg);
 				mode = DEFAULT;
 				continue;
+			case INSIDE_SYSTEM:
+				mode = DEFAULT;
+				this.javaHomeCache = new File(currentArg);
+				this.javaHomeChecked = true;
+				continue;
 			case INSIDE_MODULEPATH_start:
 				mode = DEFAULT;
 				String[] modulepaths = new String[1];
@@ -3262,7 +3272,7 @@ protected ArrayList handleBootclasspath(ArrayList bootclasspaths, String customE
 	} else {
 		bootclasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
 		try {
-			Util.collectRunningVMBootclasspath(bootclasspaths);
+			Util.collectVMBootclasspath(bootclasspaths, this.javaHomeCache);
 		} catch(IllegalStateException e) {
 			this.logger.logWrongJDK();
 			this.proceed = false;
@@ -4470,10 +4480,6 @@ public void performCompilation() {
 	try {
 		this.logger.startLoggingSources();
 		this.batchCompiler.compile(getCompilationUnits());
-	} catch (Exception e) {
-		// In the unlikely case of an exception, trouble shooting becomes extremely
-		// difficult. So, handle it here.
-		e.printStackTrace();
 	} finally {
 		this.logger.endLoggingSources();
 	}
@@ -4890,6 +4896,18 @@ protected void setPaths(ArrayList bootclasspaths,
 		ArrayList endorsedDirClasspaths,
 		String customEncoding) {
 
+	Object version = this.options.get(CompilerOptions.OPTION_Compliance);
+	if (CompilerOptions.VERSION_9.equals(version)) {
+		if (bootclasspaths != null && bootclasspaths.size() > 0)
+			throw new IllegalArgumentException(
+				this.bind("configure.unsupportedOption", "-bootclasspath")); //$NON-NLS-1$ //$NON-NLS-2$
+		if (extdirsClasspaths != null && extdirsClasspaths.size() > 0)
+			throw new IllegalArgumentException(
+				this.bind("configure.unsupportedOption", "-extdirs")); //$NON-NLS-1$ //$NON-NLS-2$
+		if (endorsedDirClasspaths != null && endorsedDirClasspaths.size() > 0)
+			throw new IllegalArgumentException(
+				this.bind("configure.unsupportedOption", "-endorseddirs")); //$NON-NLS-1$ //$NON-NLS-2$
+	}
 	// process bootclasspath, classpath and sourcepaths
  	bootclasspaths = handleBootclasspath(bootclasspaths, customEncoding);
 
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index 13bba63..5554499 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -61,7 +61,9 @@ configure.duplicateMaxProblems = duplicate max problems specification: {0}
 configure.duplicateCompliance = duplicate compliance setting specification: {0}
 configure.duplicateSource = duplicate source compliance setting specification: {0}
 configure.duplicateTarget = duplicate target compliance setting specification: {0}
-configure.source = source level should be comprised in between ''1.3'' and ''1.8'' (or ''5'', ''5.0'', ..., ''8'' or ''8.0''): {0}
+configure.source = source level should be comprised in between ''1.3'' and ''1.9'' (or ''5'', ''5.0'', ..., ''9'' or ''9.0''): {0}
+configure.invalidSystem = invalid location for system libraries
+configure.unsupportedOption = option {0} not supported at compliance level 9 and above
 configure.duplicateOutputPath = duplicate output path specification: {0}
 configure.duplicateModulePath = duplicate module path specification: {0}
 configure.duplicateModuleSourcepath = duplicate source module path specification: {0}
@@ -75,7 +77,7 @@ configure.invalidDebugOption = invalid debug option: {0}
 configure.invalidWarningConfiguration = invalid warning configuration: ''{0}''
 configure.invalidWarning = invalid warning token: ''{0}''. Ignoring warning and compiling
 configure.invalidWarningOption = invalid warning option: ''{0}''. Must specify a warning token
-configure.targetJDK = target level should be comprised in between ''1.1'' and ''1.8'' (or ''5'', ''5.0'', ..., ''8'' or ''8.0'') or cldc1.1: {0}
+configure.targetJDK = target level should be comprised in between ''1.1'' and ''1.9'' (or ''5'', ''5.0'', ..., ''9'' or ''9.0'') or cldc1.1: {0}
 configure.incompatibleTargetForSource = Target level ''{0}'' is incompatible with source level ''{1}''. A target level ''{1}'' or better is required
 configure.incompatibleTargetForGenericSource = Target level ''{0}'' is incompatible with source level ''{1}''. A source level ''1.5'' or better is required
 configure.incompatibleComplianceForSource = Compliance level ''{0}'' is incompatible with source level ''{1}''. A compliance level ''{1}'' or better is required
@@ -177,10 +179,6 @@ misc.usage = {1} {2}\n\
 \                       jar file are put in the user.dir folder in case no\n\
 \                       general ''-d'' option is specified. ZIP archives cannot\n\
 \                       override the general ''-d'' option\n\
-\    -modulesourcepath <directories separated by {0}>\n\
-\                       specify where to find source files for multiple modules\n\
-\    -mp -modulepath <directories separated by {0}>\n\
-\                       specify where to find application modules\n\
 \    -extdirs <directories separated by {0}>\n\
 \                       specify location for extension ZIP archives\n\
 \    -endorseddirs <directories separated by {0}>\n\
@@ -195,6 +193,14 @@ misc.usage = {1} {2}\n\
 \                       If multiple default encodings are specified, the last\n\
 \                       one will be used.\n\
 \ \n\
+\ Module compilation options:\n\
+\   These options are meaningful only in Java 9 environment or later.\n\
+\    -modulesourcepath <directories separated by {0}>\n\
+\                       specify where to find source files for multiple modules\n\
+\    -mp -modulepath <directories separated by {0}>\n\
+\                       specify where to find application modules\n\
+\    -system <jdk>      Override location of system modules\
+\ \n\
 \ Compliance options:\n\
 \    -1.3               use 1.3 compliance (-source 1.3 -target 1.1)\n\
 \    -1.4             + use 1.4 compliance (-source 1.3 -target 1.2)\n\
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 47f8af4..9948fdc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -22,6 +22,7 @@ import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
+import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -31,6 +32,7 @@ import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Properties;
 import java.util.StringTokenizer;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
@@ -1142,33 +1144,57 @@ public class Util implements SuffixConstants {
 		return null;
 	}
 
-	public static void collectRunningVMBootclasspath(List bootclasspaths) {
-		for (String filePath : collectFilesNames()) {
+	public static void collectVMBootclasspath(List bootclasspaths, File javaHome) {
+		for (String filePath : collectFilesNames(javaHome)) {
 			FileSystem.Classpath currentClasspath = FileSystem.getClasspath(filePath, null, null, null);
 			if (currentClasspath != null) {
 				bootclasspaths.add(currentClasspath);
 			}
 		}
 	}
-
+	public static void collectRunningVMBootclasspath(List bootclasspaths) {
+		collectVMBootclasspath(bootclasspaths, null);
+	}
+	private static String getJavaVersion(File javaHome) {
+		File release = new File(javaHome, "release"); //$NON-NLS-1$
+		Properties prop = new Properties();
+		try {
+			prop.load(new FileReader(release));
+			String ver = prop.getProperty("JAVA_VERSION"); //$NON-NLS-1$
+			if (ver != null)
+				ver = ver.replace("\"", "");  //$NON-NLS-1$//$NON-NLS-2$
+			return ver;
+		} catch (IOException e) {
+			// Nothing can be done.
+		}
+		return null;
+	}
 	public static List<String> collectFilesNames() {
+		return collectFilesNames(null);
+	}
+	public static List<String> collectFilesNames(File javaHome) {
 		/* no bootclasspath specified
 		 * we can try to retrieve the default librairies of the VM used to run
 		 * the batch compiler
 		 */
-		String javaversion = System.getProperty("java.version");//$NON-NLS-1$
+		String javaversion = null;
+		if (javaHome != null) {
+			javaversion = getJavaVersion(javaHome);
+		} else {
+			javaversion = System.getProperty("java.version"); //$NON-NLS-1$
+		}
 		if (javaversion != null && javaversion.equalsIgnoreCase("1.1.8")) { //$NON-NLS-1$
 			throw new IllegalStateException();
 		}
-		if (javaversion.length() > 3) {
-			long jdkLevel = CompilerOptions.versionToJdkLevel(javaversion.substring(0, 3));
-			if (jdkLevel >= ClassFileConstants.JDK9) {
-				List<String> filePaths = new ArrayList<>();
-				final File javaHome = getJavaHome();
-				if (javaHome != null) {
-					filePaths.add((new File(javaHome, "/" + JRTUtil.JRT_FS_JAR)).getAbsolutePath()); //$NON-NLS-1$
-					return filePaths;
-				}
+		long jdkLevel = CompilerOptions.versionToJdkLevel(javaversion);
+		if (jdkLevel >= ClassFileConstants.JDK9) {
+			List<String> filePaths = new ArrayList<>();
+			if (javaHome == null) {
+				javaHome = getJavaHome();
+			}
+			if (javaHome != null) {
+				filePaths.add((new File(javaHome, "/" + JRTUtil.JRT_FS_JAR)).getAbsolutePath()); //$NON-NLS-1$
+				return filePaths;
 			}
 		}
 
@@ -1193,7 +1219,9 @@ public class Util implements SuffixConstants {
 			}
 		} else {
 			// try to get all jars inside the lib folder of the java home
-			final File javaHome = getJavaHome();
+			if (javaHome == null) {
+				javaHome = getJavaHome();
+			}
 			if (javaHome != null) {
 				File[] directoriesToCheck = null;
 				if (System.getProperty("os.name").startsWith("Mac")) {//$NON-NLS-1$//$NON-NLS-2$
commit e088b5b266e8b35592a5a4c7a52265ff5268abab
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Fri Mar 10 12:25:17 2017 +0530

    Bug 487421 - [1.9][batch] Support Java 9 options in command line
    compiler
    
    Update the module-path and module-source-path parameter names.
    
    Change-Id: I2d41fa7c96285c2a0fa07e77e496c1916037187d
    Signed-off-by: Jay Arthanareeswaran <jarthana@in.ibm.com>

3	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/EclipseFileManager.java
3	3	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java
4	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
47	42	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java
1	10	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
3	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
5	5	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
3	3	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
8	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
18	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
45	4	org.eclipse.jdt.core/scripts/ecj.1
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/EclipseFileManager.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/EclipseFileManager.java
index d50afb0..d689a24 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/EclipseFileManager.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/EclipseFileManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2016 IBM Corporation and others.
+ * Copyright (c) 2006, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -260,8 +260,8 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			return null;
 		}
 
-		for (String fileName : org.eclipse.jdt.internal.compiler.util.Util.collectFilesNames()) {
-			files.add(new File(fileName));
+		for (FileSystem.Classpath classpath : org.eclipse.jdt.internal.compiler.util.Util.collectFilesNames()) {
+			files.add(new File(classpath.getPath()));
 		}
 		return files;
 	}
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java
index 8e84b27..3fb1122 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/tool/EclipseFileManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2015 IBM Corporation and others.
+ * Copyright (c) 2006, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -262,8 +262,8 @@ public class EclipseFileManager implements StandardJavaFileManager {
 			return null;
 		}
 
-		for (String fileName : org.eclipse.jdt.internal.compiler.util.Util.collectFilesNames()) {
-			files.add(new File(fileName));
+		for (FileSystem.Classpath classpath : org.eclipse.jdt.internal.compiler.util.Util.collectFilesNames()) {
+			files.add(new File(classpath.getPath()));
 		}
 		return files;
 	}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 4553436..390329b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -629,11 +629,11 @@ public void test012(){
         " \n" +
         " Module compilation options:\n" +
         "   These options are meaningful only in Java 9 environment or later.\n" +
-        "    -modulesourcepath <directories separated by " + File.pathSeparator + ">\n" +
+        "    --module-source-path <directories separated by " + File.pathSeparator + ">\n" +
         "                       specify where to find source files for multiple modules\n" +
-        "    -mp -modulepath <directories separated by " + File.pathSeparator + ">\n" +
+        "    -p --module-path <directories separated by " + File.pathSeparator + ">\n" +
         "                       specify where to find application modules\n" +
-        "    -system <jdk>      Override location of system modules \n" +
+        "    --system <jdk>      Override location of system modules \n" +
         " Compliance options:\n" +
         "    -1.3               use 1.3 compliance (-source 1.3 -target 1.1)\n" +
         "    -1.4             + use 1.4 compliance (-source 1.3 -target 1.2)\n" +
@@ -10067,7 +10067,7 @@ public void test279_sourcepath_vs_classpath() throws IOException, InterruptedExc
 		},
 		"\"" + OUTPUT_DIR +  File.separator + "Y.java\""
 		+ " -sourcepath \"" + OUTPUT_DIR + File.separator + "src2[?**/*]" + "\""
-		+ " -modulesourcepath \"" + OUTPUT_DIR + File.separator + "src2" + "\""
+		+ " --module-source-path \"" + OUTPUT_DIR + File.separator + "src2" + "\""
 		+ " -classpath \"" + OUTPUT_DIR + File.separator + "bin1" + "\""
 		+ " -proc:none -d \"" + OUTPUT_DIR + "\"",
 		"",
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index 26f1d41..b6768ae 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -207,7 +207,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		buffer.append(" -classpath \"")
 		.append(Util.getJavaClassLibsAsString())
 		.append("\" ");
-		buffer.append(" -modulesourcepath " + "\"" + directory + "\"");
+		buffer.append(" --module-source-path " + "\"" + directory + "\"");
 		runConformTest(new String[]{}, buffer.toString(), "", "", false);
 	}
 	public void test007() {
@@ -246,7 +246,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		buffer.append(" -classpath \"")
 		.append(Util.getJavaClassLibsAsString())
 		.append("\" ");
-		buffer.append(" -modulesourcepath " + "\"" + directory + "\"");
+		buffer.append(" --module-source-path " + "\"" + directory + "\"");
 		
 		runNegativeTest(new String[]{}, 
 				buffer.toString(), 
@@ -298,7 +298,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"");
+			.append(" --module-source-path " + "\"" + directory + "\"");
 
 		runConformTest(new String[]{}, 
 				buffer.toString(), 
@@ -314,12 +314,12 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		String moduleLoc = directory + File.separator + "mod.one";
 		writeFile(moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
-						"	exports p;\n" +
+						"	exports p.q;\n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
-						"package p;\n" +
+		writeFile(moduleLoc + File.separator + "p" + File.separator + "q", "X.java", 
+						"package p.q;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
 						"		return null;\n" +
@@ -331,19 +331,20 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 						"	requires java.base;\n" +
 						"	requires mod.one;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
-						"package q;\n" +
+		writeFile(moduleLoc + File.separator + "q" + File.separator + "r", "Y.java", 
+						"package q.r;\n" +
 						"public class Y {\n" +
-						"   java.sql.Connection con = p.X.getConnection();\n" +
+						"   java.sql.Connection con = p.q.X.getConnection();\n" +
 						"}");
 
 		StringBuffer buffer = new StringBuffer();
 		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
 			.append(" -9 ")
+			.append("--system ").append("C:\\Java\\jdk-9-ea+153")
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"");
+			.append(" --module-source-path " + "\"" + directory + "\"");
 
 		runConformTest(new String[]{}, 
 				buffer.toString(), 
@@ -385,7 +386,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		StringBuffer buffer = new StringBuffer();
 		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
 			.append(" -9 ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"");
+			.append(" --module-source-path " + "\"" + directory + "\"");
 
 		runConformTest(new String[]{}, 
 				buffer.toString(), 
@@ -433,10 +434,10 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		StringBuffer buffer = new StringBuffer();
 			buffer.append("-d " + outDir )
 			.append(" -9 ")
-			.append(" -modulepath \"")
+			.append(" --module-path \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + srcDir + "\"");
+			.append(" --module-source-path " + "\"" + srcDir + "\"");
 
 		runConformTest(new String[]{}, 
 				buffer.toString(), 
@@ -487,11 +488,11 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		StringBuffer buffer = new StringBuffer();
 			buffer.append("-d " + outDir )
 			.append(" -9 ")
-			.append(" -mp \"")
+			.append(" -p \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append(modDir.getAbsolutePath())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + srcDir + "\"");
+			.append(" --module-source-path " + "\"" + srcDir + "\"");
 
 		runConformTest(new String[]{}, 
 				buffer.toString(), 
@@ -519,7 +520,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 	        "",
 	        true);
 	}
-	// Modules used as regular -classpath (as opposed to -modulepath) and module-info referencing
+	// Modules used as regular -classpath (as opposed to --module-path) and module-info referencing
 	// those modules are reported as missing.
 	public void test012() {
 		Util.flushDirectoryContent(new File(OUTPUT_DIR));
@@ -546,7 +547,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(modDir + File.separator + "mod.one.jar").append(File.pathSeparator)
 			.append(modDir + File.separator + "mod.two").append(File.pathSeparator)
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + srcDir + "\"");
+			.append(" --module-source-path " + "\"" + srcDir + "\"");
 
 		runNegativeTest(new String[]{},
 				buffer.toString(), 
@@ -565,7 +566,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 				"2 problems (2 errors)\n",
 				false);
 	}
-	// Modules used as regular -classpath as opposed to -modulepath. The files being compiled
+	// Modules used as regular -classpath as opposed to --module-path. The files being compiled
 	// aren't part of any modules (i.e. module-info is missing). The files should be able to
 	// reference the types from referenced classpath.
 	public void test013() {
@@ -590,7 +591,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(modDir + File.separator + "mod.one.jar").append(File.pathSeparator)
 			.append(modDir + File.separator + "mod.two").append(File.pathSeparator)
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + srcDir + "\"");
+			.append(" --module-source-path " + "\"" + srcDir + "\"");
 		runConformTest(new String[]{},
 				buffer.toString(), 
 				"",
@@ -685,7 +686,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two");
 
 		runConformTest(new String[]{}, 
@@ -730,7 +731,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two");
 
 		runNegativeTest(new String[]{}, 
@@ -780,7 +781,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two")
 			.append(" --add-reads mod.two=mod.one");
 
@@ -825,7 +826,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.three")
 			.append(" --add-reads mod.two=mod.one");
 
@@ -887,7 +888,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two,mod.three")
 			.append(" --add-reads mod.two=mod.one")
 			.append(" --add-reads mod.three=mod.one");
@@ -909,7 +910,11 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		String moduleLoc = directory + File.separator + "mod.one";
 		writeFile(moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
-						"public abstract class X extends sun.management.FileSystem {\n" +
+						"public abstract class X extends com.sun.security.ntlm.Server {\n" +
+						"	//public X() {}\n" +
+						"	public X(String arg0, String arg1) throws com.sun.security.ntlm.NTLMException {\n" +
+						"		super(arg0, arg1);\n" +
+						"	}\n" +
 						"}");
 
 		StringBuffer buffer = new StringBuffer();
@@ -952,7 +957,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one=mod.two,mod.three");
 
 		runNegativeTest(new String[]{}, 
@@ -986,7 +991,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-reads mod.one/mod.two");
 
 		runNegativeTest(new String[]{}, 
@@ -1020,7 +1025,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.three")
 			.append(" --add-exports mod.one/p=mod.three");
 
@@ -1126,7 +1131,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		StringBuffer buffer = new StringBuffer();
 		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
 			.append(" -9 ")
-			.append(" -system \"").append(javaHome).append("\"")
+			.append(" --system \"").append(javaHome).append("\"")
 			.append(" \"" + moduleLoc +  File.separator + "module-info.java\" ");
 
 		runConformTest(new String[]{}, 
@@ -1149,7 +1154,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		StringBuffer buffer = new StringBuffer();
 		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
 			.append(" -9 ")
-			.append(" -system \"").append(javaHome).append(File.separator)
+			.append(" --system \"").append(javaHome).append(File.separator)
 			.append("lib\"")
 			.append(" \"" + moduleLoc +  File.separator + "module-info.java\" ");
 
@@ -1195,11 +1200,11 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 		StringBuffer buffer = new StringBuffer();
 		buffer.append("-d " + outDir )
 		.append(" -9 ")
-		.append(" -mp \"")
+		.append(" -p \"")
 		.append(Util.getJavaClassLibsAsString())
 		.append(modDir.getAbsolutePath())
 		.append("\" ")
-		.append(" -modulesourcepath " + "\"" + srcDir + "\"");
+		.append(" --module-source-path " + "\"" + srcDir + "\"");
 
 		runNegativeTest(new String[]{},
 				buffer.toString(), 
@@ -1248,7 +1253,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two,mod.three")
 			.append(" --add-reads mod.two=mod.one");
 
@@ -1300,7 +1305,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two,mod.three")
 			.append(" --add-reads mod.two=mod.one");
 
@@ -1357,7 +1362,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"")
+			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two,mod.three")
 			.append(" --add-reads mod.two=mod.one");
 
@@ -1400,7 +1405,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"");
+			.append(" --module-source-path " + "\"" + directory + "\"");
 
 		runConformTest(new String[]{}, 
 			buffer.toString(), 
@@ -1449,7 +1454,7 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append(LIB_DIR).append(File.separator).append("lib1.jar").append(File.pathSeparator).append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"");
+			.append(" --module-source-path " + "\"" + directory + "\"");
 		runNegativeTest(new String[]{}, 
 				buffer.toString(), 
 				"",
@@ -1503,9 +1508,9 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -9 ")
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString()).append("\" ")
-			.append("-mp \"")
+			.append("-p \"")
 			.append(LIB_DIR).append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"");
+			.append(" --module-source-path " + "\"" + directory + "\"");
 		runNegativeTest(new String[]{}, 
 				buffer.toString(), 
 				"",
@@ -1560,9 +1565,9 @@ public class ModuleCompilationTests extends BatchCompilerTest {
 			.append(" -9 ")
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString()).append("\" ")
-			.append("-mp \"")
+			.append("-p \"")
 			.append(LIB_DIR).append("\" ")
-			.append(" -modulesourcepath " + "\"" + directory + "\"");
+			.append(" --module-source-path " + "\"" + directory + "\"");
 		runConformTest(new String[]{}, 
 				buffer.toString(), 
 				"",
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java
index 15daa9e..d9ab9b3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/util/Util.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -733,7 +733,7 @@ public static String[] getJavaClassLibs() {
 	if (jdkLevel >= ClassFileConstants.JDK9) {
 		String jreDir = getJREDirectory();
 		return new String[] {
-				toNativePath(jreDir + "/jrt-fs.jar")
+				toNativePath(jreDir + "/lib/jrt-fs.jar")
 		};
 	}
 
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
index 9236663..c40a0bb 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
@@ -51,7 +51,6 @@ import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class ClasspathJrt extends ClasspathLocation implements IMultiModuleEntry, IModuleEnvironment {
 	protected File file;
-	protected ZipFile zipFile;
 	protected ZipFile annotationZipFile;
 	protected boolean closeZipFileAtEnd;
 	private static HashMap<String, Set<IModule>> ModulesCache = new HashMap<>();
@@ -303,14 +302,6 @@ public class ClasspathJrt extends ClasspathLocation implements IMultiModuleEntry
 //	}
 	public void reset() {
 		if (this.closeZipFileAtEnd) {
-			if (this.zipFile != null) {
-				try {
-					this.zipFile.close();
-				} catch(IOException e) {
-					// ignore
-				}
-				this.zipFile = null;
-			}
 			if (this.annotationZipFile != null) {
 				try {
 					this.annotationZipFile.close();
@@ -326,7 +317,7 @@ public class ClasspathJrt extends ClasspathLocation implements IMultiModuleEntry
 		}
 	}
 	public String toString() {
-		return "Classpath for jar file " + this.file.getPath(); //$NON-NLS-1$
+		return "Classpath for JRT System " + this.file.getPath(); //$NON-NLS-1$
 	}
 	public char[] normalizedPath() {
 		if (this.normalizedPath == null) {
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
index e97e9b4..695a309 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
@@ -198,6 +198,9 @@ public static Classpath getClasspath(String classpathName, String encoding, Acce
 public static Classpath getClasspath(String classpathName, String encoding, AccessRuleSet accessRuleSet, Map options) {
 	return getClasspath(classpathName, encoding, false, accessRuleSet, null, options);
 }
+public static Classpath getJrtClasspath(String jdkHome, String encoding, AccessRuleSet accessRuleSet, Map options) {
+	return new ClasspathJrt(new File(convertPathSeparators(jdkHome)), true, accessRuleSet, null);
+}
 public static Classpath getClasspath(String classpathName, String encoding,
 		boolean isSourceOnly, AccessRuleSet accessRuleSet,
 		String destinationPath, Map options) {
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 7b161f5..5c5c53f 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -2002,7 +2002,7 @@ public void configure(String[] argv) {
 						// If the module-info.java was supplied via command line, that will be the
 						// de facto module for the other source files supplied via command line.
 						// TODO: This needs revisit in case a source file specified in command line is
-						// part of a -modulesourcepath
+						// part of a --module-source-path
 						IModule mod = extractModuleDesc(currentArg, getNewParser());
 						if (mod != null) {
 							moduleName = new String(mod.name());
@@ -2181,15 +2181,15 @@ public void configure(String[] argv) {
 					mode = INSIDE_BOOTCLASSPATH_start;
 					continue;
 				}
-				if (currentArg.equals("-system")) { //$NON-NLS-1$
+				if (currentArg.equals("--system")) { //$NON-NLS-1$
 					mode = INSIDE_SYSTEM;
 					continue;
 				}
-				if (currentArg.equals("-modulepath") || currentArg.equals("-mp")) { //$NON-NLS-1$ //$NON-NLS-2$
+				if (currentArg.equals("--module-path") || currentArg.equals("-p")) { //$NON-NLS-1$ //$NON-NLS-2$
 					mode = INSIDE_MODULEPATH_start;
 					continue;
 				}
-				if (currentArg.equals("-modulesourcepath")) { //$NON-NLS-1$
+				if (currentArg.equals("--module-source-path")) { //$NON-NLS-1$
 					mode = INSIDE_MODULESOURCEPATH_start;
 					continue;
 				}
@@ -2948,7 +2948,7 @@ public void configure(String[] argv) {
 			CompilerOptions.OPTION_ReportMissingJavadocTagsVisibility,
 			CompilerOptions.PRIVATE);
 	}
-	// We don't add the source files from -modulesourcepath yet to the final list. So,
+	// We don't add the source files from --module-source-path yet to the final list. So,
 	// don't report it if that's the case.
 	if (printUsageRequired || (filesCount == 0 && classCount == 0 && moduleSourcepathArg == null)) {
 		if (usageSection ==  null) {
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index 7bcf1c6..c3d24e6 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -201,11 +201,11 @@ misc.usage = {1} {2}\n\
 \ \n\
 \ Module compilation options:\n\
 \   These options are meaningful only in Java 9 environment or later.\n\
-\    -modulesourcepath <directories separated by {0}>\n\
+\    --module-source-path <directories separated by {0}>\n\
 \                       specify where to find source files for multiple modules\n\
-\    -mp -modulepath <directories separated by {0}>\n\
+\    -p --module-path <directories separated by {0}>\n\
 \                       specify where to find application modules\n\
-\    -system <jdk>      Override location of system modules\
+\    --system <jdk>      Override location of system modules\
 \ \n\
 \ Compliance options:\n\
 \    -1.3               use 1.3 compliance (-source 1.3 -target 1.1)\n\
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
index 34f200e..d010a7c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015, 2016 IBM Corporation.
+ * Copyright (c) 2015, 2017 IBM Corporation.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -18,8 +18,6 @@ import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URI;
-import java.net.URL;
-import java.net.URLClassLoader;
 import java.nio.file.DirectoryStream;
 import java.nio.file.FileSystem;
 import java.nio.file.FileSystems;
@@ -27,7 +25,6 @@ import java.nio.file.FileVisitResult;
 import java.nio.file.FileVisitor;
 import java.nio.file.Files;
 import java.nio.file.NoSuchFileException;
-import java.nio.file.Paths;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -181,19 +178,18 @@ class JrtFileSystem {
 		initialize(jrt);
 	}
 	void initialize(File jrt) throws IOException {
-		URL url = null;
+		String jdkHome = null;
 		if (jrt.toString().endsWith(JRTUtil.JRT_FS_JAR)) {
-			url = jrt.toPath().toUri().toURL();
+			jdkHome = jrt.getParentFile().getParent();
 		} else if (jrt.isDirectory()) {
-			url = jrt.toPath().toUri().toURL();
+			jdkHome = jrt.toPath().toString();
 		} else {
-			String jdkHome = jrt.getParentFile().getParentFile().getParent();
-			url = Paths.get(jdkHome, JRTUtil.JRT_FS_JAR).toUri().toURL();
+			return;
 		}
 		JRTUtil.MODULE_TO_LOAD = System.getProperty("modules.to.load"); //$NON-NLS-1$
-		URLClassLoader loader = new URLClassLoader(new URL[] { url });
-		HashMap<String, ?> env = new HashMap<>();
-		this.jrtSystem = FileSystems.newFileSystem(JRTUtil.JRT_URI, env, loader);
+		HashMap<String, String> env = new HashMap<>();
+		env.put("java.home", jdkHome); //$NON-NLS-1$
+		this.jrtSystem = FileSystems.newFileSystem(JRTUtil.JRT_URI, env);
 		walkModuleImage(null, true, 0 /* doesn't matter */);
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 3d53757..8b92c69 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -33,6 +33,7 @@ import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Properties;
+import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
@@ -41,6 +42,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.batch.FileSystem;
+import org.eclipse.jdt.internal.compiler.batch.FileSystem.Classpath;
 import org.eclipse.jdt.internal.compiler.batch.Main;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
@@ -1158,12 +1160,8 @@ public class Util implements SuffixConstants {
 	}
 
 	public static void collectVMBootclasspath(List bootclasspaths, File javaHome) {
-		for (String filePath : collectFilesNames(javaHome)) {
-			FileSystem.Classpath currentClasspath = FileSystem.getClasspath(filePath, null, null, null);
-			if (currentClasspath != null) {
-				bootclasspaths.add(currentClasspath);
-			}
-		}
+		List<Classpath> classpaths = collectFilesNames(javaHome);
+		bootclasspaths.addAll(classpaths);
 	}
 	public static void collectRunningVMBootclasspath(List bootclasspaths) {
 		collectVMBootclasspath(bootclasspaths, null);
@@ -1182,10 +1180,10 @@ public class Util implements SuffixConstants {
 		}
 		return null;
 	}
-	public static List<String> collectFilesNames() {
+	public static List<FileSystem.Classpath> collectFilesNames() {
 		return collectFilesNames(null);
 	}
-	public static List<String> collectFilesNames(File javaHome) {
+	public static List<FileSystem.Classpath> collectFilesNames(File javaHome) {
 		/* no bootclasspath specified
 		 * we can try to retrieve the default librairies of the VM used to run
 		 * the batch compiler
@@ -1201,12 +1199,12 @@ public class Util implements SuffixConstants {
 		}
 		long jdkLevel = CompilerOptions.versionToJdkLevel(javaversion);
 		if (jdkLevel >= ClassFileConstants.JDK9) {
-			List<String> filePaths = new ArrayList<>();
+			List<FileSystem.Classpath> filePaths = new ArrayList<>();
 			if (javaHome == null) {
 				javaHome = getJavaHome();
 			}
 			if (javaHome != null) {
-				filePaths.add((new File(javaHome, "/" + JRTUtil.JRT_FS_JAR)).getAbsolutePath()); //$NON-NLS-1$
+				filePaths.add(FileSystem.getJrtClasspath(javaHome.getAbsolutePath(), null, null, null));
 				return filePaths;
 			}
 		}
@@ -1224,7 +1222,7 @@ public class Util implements SuffixConstants {
 				bootclasspathProperty = System.getProperty("org.apache.harmony.boot.class.path"); //$NON-NLS-1$
 			}
 		}
-		List<String> filePaths = new ArrayList<>();
+		Set<String> filePaths = new HashSet<>();
 		if ((bootclasspathProperty != null) && (bootclasspathProperty.length() != 0)) {
 			StringTokenizer tokenizer = new StringTokenizer(bootclasspathProperty, File.pathSeparator);
 			while (tokenizer.hasMoreTokens()) {
@@ -1260,7 +1258,14 @@ public class Util implements SuffixConstants {
 				}
 			}
 		}
-		return filePaths;
+		List<FileSystem.Classpath> classpaths = new ArrayList<>();
+		for (String filePath : filePaths) {
+			FileSystem.Classpath currentClasspath = FileSystem.getClasspath(filePath, null, null, null);
+			if (currentClasspath != null) {
+				classpaths.add(currentClasspath);
+			}
+		}
+		return classpaths;
 	}
 	public static int getParameterCount(char[] methodSignature) {
 		try {
diff --git a/org.eclipse.jdt.core/scripts/ecj.1 b/org.eclipse.jdt.core/scripts/ecj.1
index 1461b12..69f5a9c 100644
--- a/org.eclipse.jdt.core/scripts/ecj.1
+++ b/org.eclipse.jdt.core/scripts/ecj.1
@@ -1,7 +1,13 @@
-.TH ecj 1 "10 August 2015"
+.TH ecj "13 March 2017"
 .LP
 .SH NAME
 ecj \- the eclipse JDT Batch Compiler
+
+.B IMPORTANT :  This is the BETA version for Java 9.
+.B This is an implementation of an early-draft specification developed under the Java
+.B  Community Process (JCP) and is made available for testing and evaluation purposes only.
+.B The code is not compatible with any specification of the JCP.
+
 .SH SYNOPSIS
 .B ecj [OPTION]... [SOURCEFILE]...
 .B ...
@@ -16,6 +22,11 @@ annotations processing support, a 1.6 VM is required.
 Here is a summary of all the options, grouped by type.  Explanations are in the \fBOPTIONS\fR section.
 .sp
 .ul
+Module Options
+.sp
+.B -p|--module-path \--module-source-path \--system
+.sp
+.ul
 ClassPath Options
 .sp
 .B \-bootclasspath \-cp|\-classpath \-extdirs \-endorseddirs \-sourcepath \-d \-encoding
@@ -23,7 +34,7 @@ ClassPath Options
 .ul
 Compliance Options
 .sp
-.B \-target \-1.3 \-1.4 \-1.5 \-1.6 \-1.7 \-1.8 \-source 
+.B \-target \-1.3 \-1.4 \-1.5 \-1.6 \-1.7 \-1.8 \1.9 \-source 
 .sp
 .ul
 Warning Options
@@ -58,6 +69,23 @@ Helping Options
 .SH OPTIONS
 .sp
 .ul
+Module Options (Supported from 9 onwards)
+
+.B
+.IP  "-p|--module-path <dir 1>;<dir 2>;...;<dir P>" 
+This is a list of directories where application modules can be found. Entries are separated by the platform path separator.
+
+.B
+.IP  "--module-source-path <dir 1>;<dir 2>;...;<dir P>" 
+This is a list of directories where source files for modules can be found. Entries are separated by the platform path separator.
+
+
+.B
+.IP  "--system <jdk>"
+ Override location of system modules.
+
+.P
+.ul
 ClassPath Options
 
 .B
@@ -112,7 +140,7 @@ All source files will be read using Cp1252 encoding. X.java is the only file ins
 Compliance Options
 
 .B
-.IP "\-target 1.1 to 1.8 (or 8, 8.0, etc.)"
+.IP "\-target 1.1 to 1.9 (or 9, 9.0, etc.)"
 This specifies the .class file target setting. The possible value are: 
 .br
 .B 1.1
@@ -138,6 +166,9 @@ This specifies the .class file target setting. The possible value are:
 .br
 .B 1.8, 8 or 8.0
 (major version: 52 minor: 0)
+.br
+.B 1.9, 9 or 9.0
+(major version: 53 minor: 0)
 
 Defaults are: 
 .br
@@ -152,6 +183,8 @@ Defaults are:
 1.7 in \-1.7 mode
 .br
 1.8 in \-1.8 mode
+.br
+1.9 in \-1.9 mode
 clcd1.1 can be used to generate the StackMap attribute.
 
 .B
@@ -179,7 +212,11 @@ Set compliance level to 1.7. Implicit \-source 1.7 \-target 1.7.
 Set compliance level to 1.8. Implicit \-source 1.8 \-target 1.8.
 
 .B
-.IP "\-source 1.1 to 1.8 (or 8, 8.0, etc.)"
+.IP \-1.9
+Set compliance level to 1.9. Implicit \-source 1.9\-target 1.9.
+
+.B
+.IP "\-source 1.1 to 1.9 (or 9, 9.0, etc.)"
 This is used to specify the source level expected by the compiler.
 The possible value are: 
 .br
@@ -194,6 +231,8 @@ The possible value are:
 .B 1.7, 7 or 7.0
 .br
 .B 1.8, 8 or 8.0
+.br
+.B 1.9, 9 or 9.0
 
 Defaults are: 
 .br
@@ -209,6 +248,8 @@ Defaults are:
 .br
 1.8 in \-1.8 mode
 .br
+1.9 in \-1.9 mode
+.br
 In 1.4, assert is treated as a keyword. In 1.5 and 1.6, enum and assert are treated as keywords.
 
 .P
commit 2958c3a7b3d5e041ebfe4bfc2dcccbfd562fe671
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Tue Mar 14 12:55:35 2017 +0530

    Bug 487421 - Fix Regression caused by
    e088b5b266e8b35592a5a4c7a52265ff5268abab
    
    JDK 8 needs support of class loader based initialization of JRT
    provider.
    
    Change-Id: I78a9b9b5e3c538fa1cea63009226e609cb7ea750
    Signed-off-by: Jay Arthanareeswaran <jarthana@in.ibm.com>

30	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
index d010a7c..4ff89f2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
@@ -18,6 +18,8 @@ import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URI;
+import java.net.URL;
+import java.net.URLClassLoader;
 import java.nio.file.DirectoryStream;
 import java.nio.file.FileSystem;
 import java.nio.file.FileSystems;
@@ -25,6 +27,7 @@ import java.nio.file.FileVisitResult;
 import java.nio.file.FileVisitor;
 import java.nio.file.Files;
 import java.nio.file.NoSuchFileException;
+import java.nio.file.Paths;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -178,18 +181,35 @@ class JrtFileSystem {
 		initialize(jrt);
 	}
 	void initialize(File jrt) throws IOException {
-		String jdkHome = null;
-		if (jrt.toString().endsWith(JRTUtil.JRT_FS_JAR)) {
-			jdkHome = jrt.getParentFile().getParent();
-		} else if (jrt.isDirectory()) {
-			jdkHome = jrt.toPath().toString();
+		String javaVersion = System.getProperty("java.version"); //$NON-NLS-1$
+		if (javaVersion != null && javaVersion.startsWith("1.8")) { //$NON-NLS-1$
+			URL url = null;
+			if (jrt.toString().endsWith(JRTUtil.JRT_FS_JAR)) {
+				url = jrt.toPath().toUri().toURL();
+			} else if (jrt.isDirectory()) {
+				url = jrt.toPath().toUri().toURL();
+			} else {
+				String jdkHome = jrt.getParentFile().getParentFile().getParent();
+				url = Paths.get(jdkHome, JRTUtil.JRT_FS_JAR).toUri().toURL();
+			}
+			JRTUtil.MODULE_TO_LOAD = System.getProperty("modules.to.load"); //$NON-NLS-1$
+			URLClassLoader loader = new URLClassLoader(new URL[] { url });
+			HashMap<String, ?> env = new HashMap<>();
+			this.jrtSystem = FileSystems.newFileSystem(JRTUtil.JRT_URI, env, loader);
 		} else {
-			return;
+			String jdkHome = null;
+			if (jrt.toString().endsWith(JRTUtil.JRT_FS_JAR)) {
+				jdkHome = jrt.getParentFile().getParent();
+			} else if (jrt.isDirectory()) {
+				jdkHome = jrt.toPath().toString();
+			} else {
+				return;
+			}
+			JRTUtil.MODULE_TO_LOAD = System.getProperty("modules.to.load"); //$NON-NLS-1$
+			HashMap<String, String> env = new HashMap<>();
+			env.put("java.home", jdkHome); //$NON-NLS-1$
+			this.jrtSystem = FileSystems.newFileSystem(JRTUtil.JRT_URI, env);
 		}
-		JRTUtil.MODULE_TO_LOAD = System.getProperty("modules.to.load"); //$NON-NLS-1$
-		HashMap<String, String> env = new HashMap<>();
-		env.put("java.home", jdkHome); //$NON-NLS-1$
-		this.jrtSystem = FileSystems.newFileSystem(JRTUtil.JRT_URI, env);
 		walkModuleImage(null, true, 0 /* doesn't matter */);
 	}
 
commit f84e7124e130abc28dd92f24273a0b0bbf2efb4f
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Thu Mar 16 11:07:52 2017 +0530

    Bug 487421 - Running ECJ with JRE 8 with --system doesn't work.
    
    Change-Id: I8b299b721be5b51c5bff90abca49610ee0d42559
    Signed-off-by: Jay Arthanareeswaran <jarthana@in.ibm.com>

12	19	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
index 4ff89f2..635ea4e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
@@ -181,31 +181,24 @@ class JrtFileSystem {
 		initialize(jrt);
 	}
 	void initialize(File jrt) throws IOException {
+		URL jrtPath = null;
+		String jdkHome = null;
+		if (jrt.toString().endsWith(JRTUtil.JRT_FS_JAR)) {
+			jrtPath = jrt.toPath().toUri().toURL();
+			jdkHome = jrt.getParentFile().getParent();
+		} else {
+			jdkHome = jrt.toPath().toString();
+			jrtPath = Paths.get(jdkHome, "lib", JRTUtil.JRT_FS_JAR).toUri().toURL(); //$NON-NLS-1$
+
+		}
+		JRTUtil.MODULE_TO_LOAD = System.getProperty("modules.to.load"); //$NON-NLS-1$
 		String javaVersion = System.getProperty("java.version"); //$NON-NLS-1$
 		if (javaVersion != null && javaVersion.startsWith("1.8")) { //$NON-NLS-1$
-			URL url = null;
-			if (jrt.toString().endsWith(JRTUtil.JRT_FS_JAR)) {
-				url = jrt.toPath().toUri().toURL();
-			} else if (jrt.isDirectory()) {
-				url = jrt.toPath().toUri().toURL();
-			} else {
-				String jdkHome = jrt.getParentFile().getParentFile().getParent();
-				url = Paths.get(jdkHome, JRTUtil.JRT_FS_JAR).toUri().toURL();
-			}
 			JRTUtil.MODULE_TO_LOAD = System.getProperty("modules.to.load"); //$NON-NLS-1$
-			URLClassLoader loader = new URLClassLoader(new URL[] { url });
+			URLClassLoader loader = new URLClassLoader(new URL[] { jrtPath });
 			HashMap<String, ?> env = new HashMap<>();
 			this.jrtSystem = FileSystems.newFileSystem(JRTUtil.JRT_URI, env, loader);
 		} else {
-			String jdkHome = null;
-			if (jrt.toString().endsWith(JRTUtil.JRT_FS_JAR)) {
-				jdkHome = jrt.getParentFile().getParent();
-			} else if (jrt.isDirectory()) {
-				jdkHome = jrt.toPath().toString();
-			} else {
-				return;
-			}
-			JRTUtil.MODULE_TO_LOAD = System.getProperty("modules.to.load"); //$NON-NLS-1$
 			HashMap<String, String> env = new HashMap<>();
 			env.put("java.home", jdkHome); //$NON-NLS-1$
 			this.jrtSystem = FileSystems.newFileSystem(JRTUtil.JRT_URI, env);
commit 04e5b72b76c9c3cf92b8c099edaf573c63990499
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Jul 6 14:33:51 2017 +0200

    Bug 487421: [1.9][batch] Support Java 9 options in command line compiler

1	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 5346c36..76f2739 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -5065,7 +5065,7 @@ protected void setPaths(ArrayList bootclasspaths,
 
 	if (sourcepathClasspathArg != null) {
 		processPathEntries(DEFAULT_SIZE_CLASSPATH, sourcepathClasspaths,
-			sourcepathClasspathArg, null, true, false); // FIXME(SHMOD): why null encoding??
+			sourcepathClasspathArg, customEncoding, true, false);
 	}
 
 	/*
commit c6de82d80e5dddd0bfa118ef302440e643313501
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Aug 3 14:51:55 2017 +0200

    Bug 487421: [1.9][batch] Support Java 9 options in command line compiler
    - 1. steps towards back-to-back testing
    
    Change-Id: If4f7702e9e0e7e5f0f83b725063377a1bc173d1b

36	33	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
0	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
627	338	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
41	60	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
2	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
3	21	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
index 4db01e8..1c4a2a3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -120,27 +120,7 @@ static class JavacCompiler {
 				+ "bin" + File.separator + JAVAC_NAME).getCanonicalPath();
 		// WORK don't need JAVAC_NAME any more; suppress this as we work towards code cleanup
 		if (rawVersion == null) {
-			Process fetchVersionProcess = null;
-			try {
-				fetchVersionProcess = Runtime.getRuntime().exec(this.javacPathName
-						+ " -version", null, null);
-		        Logger versionLogger = new Logger(fetchVersionProcess.getErrorStream(), "");
-		        versionLogger.start();
-				fetchVersionProcess.waitFor();
-				versionLogger.join();  // make sure we get the whole output
-				rawVersion = versionLogger.buffer.toString();
-				int eol = rawVersion.indexOf('\n');
-				if (eol != -1) {
-					rawVersion = rawVersion.substring(0, eol);
-				}
-				if (rawVersion.startsWith("javac ")) {
-					rawVersion = rawVersion.substring(6, rawVersion.length());
-				}
-			} finally {
-				if (fetchVersionProcess != null) {
-					fetchVersionProcess.destroy(); // closes process streams
-				}
-			}
+			rawVersion = getVersion(this.javacPathName);
 		}
 		if (rawVersion.indexOf("1.4") != -1 ||
 				this.javacPathName.indexOf("1.4") != -1
@@ -166,6 +146,35 @@ static class JavacCompiler {
 		StringBuffer classpathBuffer = new StringBuffer(" -classpath ");
 		this.classpath = classpathBuffer.toString();
 	}
+	static String getVersion(String javacPathName) throws IOException, InterruptedException {
+		Process fetchVersionProcess = null;
+		try {
+			fetchVersionProcess = Runtime.getRuntime().exec(javacPathName + " -version", null, null);
+		    Logger versionStdErrLogger = new Logger(fetchVersionProcess.getErrorStream(), ""); // for javac <= 1.8
+		    Logger versionStdOutLogger = new Logger(fetchVersionProcess.getInputStream(), ""); // for javac >= 9
+		    versionStdErrLogger.start();
+		    versionStdOutLogger.start();
+			fetchVersionProcess.waitFor();
+			// make sure we get the whole output
+			versionStdErrLogger.join();
+			versionStdOutLogger.join();
+			String loggedVersion = versionStdErrLogger.buffer.toString();
+			if (loggedVersion.isEmpty())
+				loggedVersion = versionStdOutLogger.buffer.toString();
+			int eol = loggedVersion.indexOf('\n');
+			if (eol != -1) {
+				loggedVersion = loggedVersion.substring(0, eol);
+			}
+			if (loggedVersion.startsWith("javac ")) {
+				loggedVersion = loggedVersion.substring(6, loggedVersion.length());
+			}
+			return loggedVersion;
+		} finally {
+			if (fetchVersionProcess != null) {
+				fetchVersionProcess.destroy(); // closes process streams
+			}
+		}
+	}
 	// projects known raw versions to minors; minors should grow with time, so
 	// that before and after relationships be easy to implement upon compilers
 	// of the same version; two latest digits are used for variants into levels
@@ -224,6 +233,9 @@ static class JavacCompiler {
 		long result = 0L;
 		// WORK classpath should depend on the compiler, not on the default runtime
 		try {
+			if (!directory.exists()) {
+				directory.mkdir();
+			}
 			StringBuffer cmdLine = new StringBuffer(this.javacPathName);
 			cmdLine.append(this.classpath);
 			cmdLine.append(". ");
@@ -3187,7 +3199,7 @@ protected void runNegativeTest(
 					// WORK simplify jdk.root out
 					String jdkRootDirectory = System.getProperty("jdk.root");
 					if (jdkRootDirectory == null)
-					  jdkRootDirPath = (new Path(Util.getJREDirectory())).removeLastSegments(1);
+						jdkRootDirPath = (new Path(Util.getJREDirectory())).removeLastSegments(1);
 					else
 						jdkRootDirPath = new Path(jdkRootDirectory);
 
@@ -3198,16 +3210,7 @@ protected void runNegativeTest(
 							append("bin").append(JAVAC_NAME).toString());
 					cmdLineHeader.append(" -classpath . ");
 					  // start with the current directory which contains the source files
-					Process compileProcess = Runtime.getRuntime().exec(
-						cmdLineHeader.toString() + " -version", null, null);
-			        Logger versionLogger = new Logger(compileProcess.getErrorStream(), "");
-			        // PREMATURE implement consistent error policy
-			        versionLogger.start();
-			        compileProcess.waitFor();
-					versionLogger.join(); // make sure we get the whole output
-					String version = versionLogger.buffer.toString();
-					int eol = version.indexOf('\n');
-					version = version.substring(0, eol);
+					String version = JavacCompiler.getVersion(cmdLineHeader.toString());
 					cmdLineHeader.append(" -d ");
 					cmdLineHeader.append(JAVAC_OUTPUT_DIR_NAME.indexOf(" ") != -1 ? "\"" + JAVAC_OUTPUT_DIR_NAME + "\"" : JAVAC_OUTPUT_DIR_NAME);
 					cmdLineHeader.append(" -source 1.5 -deprecation -Xlint "); // enable recommended warnings
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index a61bd01..d0079a7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -10082,7 +10082,6 @@ public void test279_sourcepath_vs_classpath() throws IOException, InterruptedExc
 		},
 		"\"" + OUTPUT_DIR +  File.separator + "Y.java\""
 		+ " -sourcepath \"" + OUTPUT_DIR + File.separator + "src2[?**/*]" + "\""
-		+ " --module-source-path \"" + OUTPUT_DIR + File.separator + "src2" + "\""
 		+ " -classpath \"" + OUTPUT_DIR + File.separator + "bin1" + "\""
 		+ " -proc:none -d \"" + OUTPUT_DIR + "\"",
 		"",
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index 9ff2d42..b15532a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -18,16 +18,29 @@ import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.nio.file.DirectoryNotEmptyException;
+import java.nio.file.FileSystems;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.tests.util.Util;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 
+import junit.framework.AssertionFailedError;
 import junit.framework.Test;
 
 public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 
 	static {
-//		 TESTS_NAMES = new String[] { "test035" };
+//		 TESTS_NAMES = new String[] { "test013" };
 		// TESTS_NUMBERS = new int[] { 1 };
 		// TESTS_RANGE = new int[] { 298, -1 };
 	}
@@ -44,6 +57,11 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		return ModuleCompilationTests.class;
 	}
 
+	protected void writeFileCollecting(List<String> collectedFiles, String directoryName, String fileName, String source) {
+		writeFile(directoryName, fileName, source);
+		collectedFiles.add(directoryName+File.separator+fileName);
+	}
+
 	protected void writeFile(String directoryName, String fileName, String source) {
 		File directory = new File(directoryName);
 		if (!directory.exists()) {
@@ -63,9 +81,189 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			return;
 		}
 	}
+	
+	void runConformModuleTest(List<String> testFileNames, StringBuffer commandLine,
+			String expectedFailureOutOutputString, String expectedFailureErrOutputString,
+			boolean shouldFlushOutputDirectory)
+	{
+		runConformModuleTest(testFileNames, commandLine,
+				expectedFailureOutOutputString, expectedFailureErrOutputString, shouldFlushOutputDirectory, OUTPUT_DIR);
+	}
+
+	void runConformModuleTest(List<String> testFileNames, StringBuffer commandLine,
+			String expectedFailureOutOutputString, String expectedFailureErrOutputString,
+			boolean shouldFlushOutputDirectory, String output)
+	{
+		for (String file : testFileNames)
+			commandLine.append(" \"").append(file).append("\"");
+		runConformModuleTest(new String[0], commandLine.toString(),
+				expectedFailureOutOutputString, expectedFailureErrOutputString, shouldFlushOutputDirectory, output);
+	}
+
+	Set<String> runConformModuleTest(String[] testFiles, String commandLine,
+			String expectedFailureOutOutputString, String expectedFailureErrOutputString,
+			boolean shouldFlushOutputDirectory)
+	{
+		return runConformModuleTest(testFiles, commandLine, expectedFailureErrOutputString, expectedFailureErrOutputString, shouldFlushOutputDirectory, OUTPUT_DIR);
+	}
+
+	Set<String> runConformModuleTest(String[] testFiles, String commandLine,
+			String expectedFailureOutOutputString, String expectedFailureErrOutputString,
+			boolean shouldFlushOutputDirectory, String output)
+	{
+		this.runConformTest(testFiles, commandLine, expectedFailureOutOutputString, expectedFailureErrOutputString, shouldFlushOutputDirectory);
+		if (RUN_JAVAC) {
+			File outputDir = new File(output);
+			final Set<String> outFiles = new HashSet<>();
+			walkOutFiles(output, outFiles, true);
+			String[] testFileNames = new String[testFiles.length/2];
+			for (int i = 0; i < testFileNames.length; i++) {
+				testFileNames[i] = testFiles[i*2];
+			}
+			for (Object comp : javacCompilers) {
+				JavacCompiler javacCompiler = (JavacCompiler) comp;
+				if (javacCompiler.compliance < ClassFileConstants.JDK9)
+					continue;
+				commandLine = commandLine.replace(" -9", " -source 9");
+				StringBuffer log = new StringBuffer();
+				try {
+					long compileResult = javacCompiler.compile(
+											outputDir, /* directory */
+											commandLine /* options */,
+											testFileNames /* source file names */,
+											log);
+					if (compileResult != 0) {
+						System.err.println("Previous error was from "+testName());
+						fail("Unexpected error from javac");
+					}
+				} catch (IOException | InterruptedException e) {
+					e.printStackTrace();
+					throw new AssertionFailedError(e.getMessage());
+				}
+				final Set<String> expectedFiles = new HashSet<>(outFiles);
+				walkOutFiles(output, expectedFiles, false);
+				for (String missingFile : expectedFiles)
+					System.err.println("Missing output file from javac:    "+missingFile);
+			}
+			return outFiles;
+		}
+		return null;
+	}
+
+	void runNegativeModuleTest(List<String> testFileNames, StringBuffer commandLine,
+			String expectedFailureOutOutputString, String expectedFailureErrOutputString,
+			boolean shouldFlushOutputDirectory, String javacErrorMatch) {
+		runNegativeModuleTest(testFileNames, commandLine, expectedFailureOutOutputString,
+				expectedFailureErrOutputString, shouldFlushOutputDirectory, javacErrorMatch, OUTPUT_DIR);
+	}
+
+	void runNegativeModuleTest(List<String> testFileNames, StringBuffer commandLine,
+			String expectedFailureOutOutputString, String expectedFailureErrOutputString,
+			boolean shouldFlushOutputDirectory, String javacErrorMatch, String output)
+	{
+		for (String file : testFileNames)
+			commandLine.append(" \"").append(file).append("\"");
+		runNegativeModuleTest(new String[0], commandLine.toString(),
+				expectedFailureOutOutputString, expectedFailureErrOutputString, shouldFlushOutputDirectory, javacErrorMatch, output);
+	}
+	void runNegativeModuleTest(String[] testFiles, String commandLine,
+			String expectedFailureOutOutputString, String expectedFailureErrOutputString,
+			boolean shouldFlushOutputDirectory, String javacErrorMatch) {
+		runNegativeModuleTest(testFiles, commandLine, expectedFailureOutOutputString, expectedFailureErrOutputString,
+				shouldFlushOutputDirectory, javacErrorMatch, OUTPUT_DIR);
+	}
+
+	void runNegativeModuleTest(String[] testFiles, String commandLine,
+			String expectedFailureOutOutputString, String expectedFailureErrOutputString,
+			boolean shouldFlushOutputDirectory, String javacErrorMatch, String output)
+	{
+		this.runNegativeTest(testFiles, commandLine, expectedFailureOutOutputString, expectedFailureErrOutputString, shouldFlushOutputDirectory);
+		if (RUN_JAVAC) {
+			String[] testFileNames = new String[testFiles.length/2];
+			for (int i = 0; i < testFileNames.length; i++) {
+				testFileNames[i] = testFiles[i*2];
+			}
+			File outputDir = new File(OUTPUT_DIR);
+			final Set<String> outFiles = new HashSet<>();
+			walkOutFiles(output, outFiles, true);
+			for (Object comp : javacCompilers) {
+				JavacCompiler javacCompiler = (JavacCompiler) comp;
+				if (javacCompiler.compliance < ClassFileConstants.JDK9)
+					continue;
+				commandLine = commandLine.replace(" -9", " -source 9");
+				StringBuffer log = new StringBuffer();
+				try {
+					long compileResult = javacCompiler.compile(
+											outputDir, /* directory */
+											commandLine /* options */,
+											testFileNames /* source file names */,
+											log);
+					if (compileResult == 0) {
+						System.err.println("Previous error was from "+testName());
+						fail(testName()+": Unexpected success from javac");
+					}
+					if (!log.toString().contains(javacErrorMatch)) {
+						System.err.println(testName()+": Error match " + javacErrorMatch + " not found in \n"+log.toString());
+						fail("Expected error match not found: "+javacErrorMatch);
+					}
+				} catch (IOException | InterruptedException e) {
+					e.printStackTrace();
+					throw new AssertionFailedError(e.getMessage());
+				}
+				final Set<String> expectedFiles = new HashSet<>(outFiles);
+				walkOutFiles(output, expectedFiles, false);
+				for (String missingFile : expectedFiles)
+					System.err.println("Missing output file from javac:    "+missingFile);
+			}
+		}
+	}
+	
+	private void walkOutFiles(final String outputLocation, final Set<String> fileNames, boolean add) {
+		if (!(new File(outputLocation)).exists()) 
+			return;
+		try {
+			Files.walkFileTree(FileSystems.getDefault().getPath(outputLocation), new SimpleFileVisitor<Path>() {
+				@Override
+				public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
+					if (file.toString().endsWith(".class")) {
+						if (add) {
+							fileNames.add(file.toString());
+						} else {
+							if (!fileNames.remove(file.toString()))
+								System.err.println("Unexpected output file from javac: "+file.toString());
+						}
+						Files.delete(file);
+					}
+					return FileVisitResult.CONTINUE;
+				}
+				@Override
+				public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
+					if (!dir.toString().equals(outputLocation)) {
+						try {
+							Files.delete(dir);
+						} catch (DirectoryNotEmptyException ex) {
+							// expected
+						}
+					}
+			        return FileVisitResult.CONTINUE;
+				}
+			});
+		} catch (IOException e) {
+			e.printStackTrace();
+			throw new AssertionFailedError(e.getMessage());
+		}
+	}
+
+	private void assertClassFile(String msg, String fileName, Set<String> classFiles) {
+		if (classFiles != null) {
+			assertTrue(msg, classFiles.contains(fileName));
+		} else {
+			assertTrue(msg, (new File(fileName).exists()));
+		}
+	}
 
 	public void test001() {
-		this.runNegativeTest(
+		runNegativeModuleTest(
 			new String[] {
 				"p/X.java",
 				"package p;\n" +
@@ -89,10 +287,11 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
     		"java.sql cannot be resolved to a type\n" + 
     		"----------\n" + 
     		"1 problem (1 error)\n",
-	        true);
+	        true,
+	        "package java.sql" /* match for javac error */);
 	}
 	public void test002() {
-		this.runConformTest(
+		runConformModuleTest(
 			new String[] {
 				"p/X.java",
 				"package p;\n" +
@@ -115,7 +314,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 	        true);
 	}
 	public void test003() {
-		this.runConformTest(
+		runConformModuleTest(
 			new String[] {
 				"p/X.java",
 				"package p;\n" +
@@ -132,7 +331,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 	        true);
 	}
 	public void test004() {
-		this.runConformTest(
+		Set<String> classFiles = runConformModuleTest(
 			new String[] {
 				"module-info.java",
 				"module mod.one { \n" +
@@ -140,16 +339,15 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"	requires java.sql;\n" +
 				"}"
 	        },
-			"-9 \"" + OUTPUT_DIR +  File.separator + "module-info.java\"",
+			" -9 \"" + OUTPUT_DIR +  File.separator + "module-info.java\"",
 	        "",
 	        "",
 	        true);
 		String fileName = OUTPUT_DIR + File.separator + "module-info.class";
-		assertTrue("Missing modul-info.class: " + fileName, (new File(fileName)).exists());
+		assertClassFile("Missing modul-info.class: " + fileName, fileName, classFiles);
 	}
 	public void test005() {
-		String out = "bin";
-		this.runConformTest(
+		Set<String> classFiles = runConformModuleTest(
 			new String[] {
 				"p/X.java",
 				"package p;\n" +
@@ -168,15 +366,15 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"   java.awt.Image image;\n" +
 				"}"
 	        },
-			"-9 \"" + OUTPUT_DIR + File.separator + "module-info.java\" "
+			" -9 \"" + OUTPUT_DIR + File.separator + "module-info.java\" "
 			+ "\"" + OUTPUT_DIR + File.separator + "q/Y.java\" "
 	        + "\"" + OUTPUT_DIR + File.separator + "p/X.java\" "
-	        + "-d " + OUTPUT_DIR + File.separator + out,
+	        + "-d " + OUTPUT_DIR ,
 	        "",
 	        "",
 	        true);
-		String fileName = OUTPUT_DIR + File.separator + out + File.separator + "module-info.class";
-		assertTrue("Missing modul-info.class: " + fileName, (new File(fileName)).exists());
+		String fileName = OUTPUT_DIR  + File.separator + "module-info.class";
+		assertClassFile("Missing modul-info.class: " + fileName, fileName, classFiles);
 	}
 	public void test006() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -184,31 +382,32 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires java.sql;\n" +
 						"	requires java.desktop;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	java.sql.Connection con;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   java.awt.Image image;\n" +
 						"}");
 
 		StringBuffer buffer = new StringBuffer();
-			buffer.append("-d " + OUTPUT_DIR + File.separator + out );
-			buffer.append(" -9 ");
-		buffer.append(" -classpath \"")
-		.append(Util.getJavaClassLibsAsString())
-		.append("\" ");
-		buffer.append(" --module-source-path " + "\"" + directory + "\"");
-		runConformTest(new String[]{}, buffer.toString(), "", "", false);
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+		runConformModuleTest(files, buffer, "", "", false);
 	}
 	public void test007() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -216,12 +415,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -229,27 +429,26 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"	requires mod.one;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   java.sql.Connection con = p.X.getConnection();\n" +
 						"}");
 		
 		StringBuffer buffer = new StringBuffer();
-			buffer.append("-d " + OUTPUT_DIR + File.separator + out );
-			buffer.append(" -9 ");
-		buffer.append(" -classpath \"")
-		.append(Util.getJavaClassLibsAsString())
-		.append("\" ");
-		buffer.append(" --module-source-path " + "\"" + directory + "\"");
-		
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 3)\n" + 
@@ -258,7 +457,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"The type p.X is not accessible\n" + 
 				"----------\n" + 
 				"1 problem (1 error)\n",
-				false);
+				false,
+				"p.X");
 	}
 	public void test008() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -266,13 +466,14 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	exports p;\n" +
 						"	requires mod.two;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"import q.Y;\n" +
 						"public class X {\n" +
@@ -281,12 +482,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	exports q;\n" +
 						"	requires java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   public static java.sql.Connection con = null;\n" +
@@ -300,8 +501,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files,
+				buffer, 
 				"",
 				"",
 				false);
@@ -312,13 +513,14 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	exports p.q;\n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p" + File.separator + "q", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "q", "X.java", 
 						"package p.q;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -326,31 +528,35 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"	requires mod.one;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q" + File.separator + "r", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q" + File.separator + "r", "Y.java", 
 						"package q.r;\n" +
 						"public class Y {\n" +
 						"   java.sql.Connection con = p.q.X.getConnection();\n" +
 						"}");
+		
+		String systemDirectory = OUTPUT_DIR+File.separator+"system";
+		writeFile(systemDirectory, "readme.txt", "Not a valid system");
 
 		StringBuffer buffer = new StringBuffer();
 		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
 			.append(" -9 ")
-			.append("--system ").append("C:\\Java\\jdk-9-ea+153")
+			.append("--system ").append(systemDirectory)
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
-				"",
+		runNegativeModuleTest(files, 
+				buffer, 
 				"",
-				false);
+				"invalid location for system libraries: ---OUTPUT_DIR_PLACEHOLDER---/system\n",
+				false,
+				"system");
 	}
 	public void test009() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -358,13 +564,14 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	exports p;\n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -372,12 +579,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"	requires mod.one;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   java.sql.Connection con = p.X.getConnection();\n" +
@@ -388,6 +595,27 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" -9 ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
+		runConformModuleTest(files, 
+				buffer,
+				"",
+				"",
+				false);
+	}
+	private void createUnnamedLibrary(String unnamedLoc, String unnamedBin) {
+		writeFile(unnamedLoc + File.separator + "s" + File.separator + "t", "Tester.java", 
+				"package s.t;\n" +
+				"public class Tester {\n" +
+				"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + unnamedBin)
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\"")
+			.append(" -sourcepath \"" + unnamedLoc + "\" ")
+			.append(unnamedLoc + File.separator + "s" + File.separator + "t" + File.separator + "Tester.java");
+
 		runConformTest(new String[]{}, 
 				buffer.toString(), 
 				"",
@@ -396,13 +624,14 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 	}
 	private void createReusableModules(String srcDir, String outDir, File modDir) {
 		String moduleLoc = srcDir + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	exports p;\n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -410,7 +639,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		// This one is not exported (i.e. internal to this module)
-		writeFile(moduleLoc + File.separator + "p1", "X1.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p1", "X1.java", 
 				"package p1;\n" +
 				"public class X1 {\n" +
 				"	public static java.sql.Connection getConnection() {\n" +
@@ -419,13 +648,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"}");
 
 		moduleLoc = srcDir + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	exports q;\n" +
 						"	requires java.base;\n" +
 						"	requires mod.one;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   java.sql.Connection con = p.X.getConnection();\n" +
@@ -438,6 +667,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + srcDir + "\"");
+		for (String fileName : files)
+			buffer.append(" \"").append(fileName).append("\"");
 
 		runConformTest(new String[]{}, 
 				buffer.toString(), 
@@ -473,12 +704,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		File modDir = new File(OUTPUT_DIR + File.separator + "mod");
 		createReusableModules(srcDir, outDir, modDir);
 		String moduleLoc = srcDir + File.separator + "mod.three";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.three { \n" +
 						"	requires mod.one;\n" +
 						"	requires mod.two;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "r", "Z.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "r", "Z.java", 
 						"package r;\n" +
 						"public class Z extends Object {\n" +
 						"	p.X x = null;\n" +
@@ -494,15 +726,15 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + srcDir + "\"");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files, 
+				buffer, 
 				"",
 				"",
-				false);
+				false, outDir);
 	}
 	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=487421
 	public void test011() {
-		this.runConformTest(
+		runConformModuleTest(
 			new String[] {
 				"p/X.java",
 				"package p;\n" +
@@ -514,7 +746,7 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"	requires java.base;\n" +
 				"}"
 	        },
-			"-9 \"" + OUTPUT_DIR +  File.separator + "module-info.java\" "
+			" -9 \"" + OUTPUT_DIR +  File.separator + "module-info.java\" "
 	        + "\"" + OUTPUT_DIR +  File.separator + "p/X.java\"",
 	        "",
 	        "",
@@ -529,12 +761,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		File modDir = new File(OUTPUT_DIR + File.separator + "mod");
 		createReusableModules(srcDir, outDir, modDir);
 		String moduleLoc = srcDir + File.separator + "mod.three";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.three { \n" +
 						"	requires mod.one;\n" +
 						"	requires mod.two;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "r", "Z.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "r", "Z.java", 
 						"package r;\n" +
 						"public class Z extends Object {\n" +
 						"}");
@@ -549,8 +782,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + srcDir + "\"");
 
-		runNegativeTest(new String[]{},
-				buffer.toString(), 
+		runNegativeModuleTest(files,
+				buffer,
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/module-info.java (at line 2)\n" + 
@@ -564,7 +797,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"mod.two cannot be resolved to a module\n" + 
 				"----------\n" + 
 				"2 problems (2 errors)\n",
-				false);
+				false,
+				"module");
 	}
 	// Modules used as regular -classpath as opposed to --module-path. The files being compiled
 	// aren't part of any modules (i.e. module-info is missing). The files should be able to
@@ -576,7 +810,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		File modDir = new File(OUTPUT_DIR + File.separator + "mod");
 		createReusableModules(srcDir, outDir, modDir);
 		String moduleLoc = srcDir + File.separator + "mod.three";
-		writeFile(moduleLoc + File.separator + "p", "Z.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "Z.java", 
 						"package r;\n" +
 						"public class Z extends Object {\n" +
 						"	p.X x = null;\n" +
@@ -592,11 +827,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(modDir + File.separator + "mod.two").append(File.pathSeparator)
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + srcDir + "\"");
-		runConformTest(new String[]{},
-				buffer.toString(), 
+		runConformModuleTest(files,
+				buffer, 
 				"",
 				"",
-				false);
+				false,
+				outDir);
 	}
 	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=495500
 	//-source 9
@@ -625,11 +861,11 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"public class X {\n" +
 				"}",
 			},
-	"\"" + OUTPUT_DIR +  File.separator + "X.java\""
-	+ " -9 -source 8 -target 9 -d \"" + OUTPUT_DIR + "\"",
-	"",
-	"",
-	true);
+			"\"" + OUTPUT_DIR +  File.separator + "X.java\""
+			+ " -9 -source 8 -target 9 -d \"" + OUTPUT_DIR + "\"",
+			"",
+			"",
+			true);
 		String expectedOutput = "// Compiled from X.java (version 9 : 53.0, super bit)";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput);
 	}
@@ -642,26 +878,30 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"public class X {\n" +
 				"}",
 			},
-	"\"" + OUTPUT_DIR +  File.separator + "X.java\""
-	+ " -9 -source 9 -target 9 -d \"" + OUTPUT_DIR + "\"",
-	"",
-	"",
-	true);
+			"\"" + OUTPUT_DIR +  File.separator + "X.java\""
+			+ " -9 -source 9 -target 9 -d \"" + OUTPUT_DIR + "\"",
+			"",
+			"",
+			true);
 		String expectedOutput = "// Compiled from X.java (version 9 : 53.0, super bit)";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput);
 	}
+	/*
+	 * Test add-exports grants visibility to another module
+	 */
 	public void test014() {
 		File outputDirectory = new File(OUTPUT_DIR);
 		Util.flushDirectoryContent(outputDirectory);
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -669,12 +909,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"	requires mod.one;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   java.sql.Connection con = p.X.getConnection();\n" +
@@ -689,24 +929,28 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files,
+				buffer,
 				"",
 				"",
 				false);
 	}
+	/*
+	 * Test with --add-exports, without a "requires", the packages are seen by the target module
+	 */
 	public void test015() {
 		File outputDirectory = new File(OUTPUT_DIR);
 		Util.flushDirectoryContent(outputDirectory);
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -714,12 +958,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"	requires java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   java.sql.Connection con = p.X.getConnection();\n" +
@@ -733,18 +977,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one/p=mod.two");
-
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files,
+				buffer,
 				"",
-				"----------\n" + 
-				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 3)\n" + 
-				"	java.sql.Connection con = p.X.getConnection();\n" + 
-				"	                          ^\n" + 
-				"p cannot be resolved\n" + 
-				"----------\n" + 
-				"1 problem (1 error)\n",
-				false);
+				"",
+				false,
+				OUTPUT_DIR + File.separator + out);
 	}
 	public void test016() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -752,12 +990,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -765,11 +1004,11 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   java.sql.Connection con = p.X.getConnection();\n" +
@@ -785,8 +1024,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --add-exports mod.one/p=mod.two")
 			.append(" --add-reads mod.two=mod.one");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files, 
+				buffer,
 				"",
 				"",
 				false);
@@ -797,12 +1036,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -810,11 +1050,11 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   java.sql.Connection con = p.X.getConnection();\n" +
@@ -830,8 +1070,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --add-exports mod.one/p=mod.three")
 			.append(" --add-reads mod.two=mod.one");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 3)\n" + 
@@ -840,7 +1080,9 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"The type p.X is not accessible\n" + 
 				"----------\n" + 
 				"1 problem (1 error)\n",
-				false);
+				false,
+				"visible",
+				OUTPUT_DIR + File.separator + out);
 	}
 	public void test018() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -848,12 +1090,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -861,21 +1104,21 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   java.sql.Connection con = p.X.getConnection();\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.three";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.three { \n" +
 						"	requires java.base;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "r", "Z.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "r", "Z.java", 
 						"package r;\n" +
 						"public class Z {\n" +
 						"   java.sql.Connection con = p.X.getConnection();\n" +
@@ -893,8 +1136,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --add-reads mod.two=mod.one")
 			.append(" --add-reads mod.three=mod.one");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files, 
+				buffer,
 				"",
 				"",
 				false);
@@ -908,7 +1151,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public abstract class X extends com.sun.security.ntlm.Server {\n" +
 						"	//public X() {}\n" +
@@ -924,11 +1168,10 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
 			.append(" -sourcepath " + "\"" + moduleLoc + "\" ")
-			.append(" --add-exports java.base/com.sun.security.ntlm=ALL-UNNAMED ")
-			.append(moduleLoc + File.separator + "p" + File.separator + "X.java");
+			.append(" --add-exports java.base/com.sun.security.ntlm=ALL-UNNAMED ");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files, 
+				buffer,
 				"",
 				"",
 				false);
@@ -942,17 +1185,17 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String unnamedLoc = directory + File.separator + "nomodule";
-		writeFile(unnamedLoc + File.separator + "s" + File.separator + "t", "Tester.java", 
-						"package s.t;\n" +
-						"public class Tester {\n" +
-						"}");
+		String unnamedBin = OUTPUT_DIR + File.separator + "un_bin";
+		String moduleLoc = directory + File.separator + "mod" + File.separator + "mod.one";
 
-		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		createUnnamedLibrary(unnamedLoc, unnamedBin);
+
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one {\n" +
 						"	exports p.q;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p" + File.separator + "q", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "q", "X.java", 
 						"package p.q;\n" +
 						"public abstract class X {\n" +
 						"	s.t.Tester t;\n" +
@@ -963,17 +1206,19 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" -9 ")
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
+			.append(unnamedBin + File.pathSeparator)
 			.append("\"")
-			.append(" -sourcepath \"" + unnamedLoc + "\"")
-			.append(" --module-source-path \"" + directory + "\" ")
+			.append(" --module-source-path \"" + directory + File.separator + "mod" + "\" ")
 			.append(" --add-reads mod.one=ALL-UNNAMED ");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files, 
+				buffer, 
 				"",
 				"",
-				false);
+				false,
+				OUTPUT_DIR + File.separator + out);
 	}
+
 	/*
 	 * Can only import from a package that contains compilation units (from the unnamed module)
 	 */
@@ -983,17 +1228,17 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String unnamedLoc = directory + File.separator + "nomodule";
-		writeFile(unnamedLoc + File.separator + "s" + File.separator + "t", "Tester.java", 
-						"package s.t;\n" +
-						"public class Tester {\n" +
-						"}");
+		String unnamedBin = OUTPUT_DIR + File.separator + "un_bin";
+
+		createUnnamedLibrary(unnamedLoc, unnamedBin);
 
+		List<String> files = new ArrayList<>(); 
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one {\n" +
 						"	exports p.q;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p" + File.separator + "q", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p" + File.separator + "q", "X.java", 
 						"package p.q;\n" +
 						"import s.*;\n" +
 						"import s.t.*;\n" +
@@ -1005,13 +1250,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" -9 ")
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
+			.append(unnamedBin + File.pathSeparator)
 			.append("\"")
-			.append(" -sourcepath \"" + unnamedLoc + "\"")
 			.append(" --module-source-path \"" + directory + "\" ")
 			.append(" --add-reads mod.one=ALL-UNNAMED ");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer, 
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/q/X.java (at line 2)\n" + 
@@ -1020,7 +1265,9 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"The package s is not accessible\n" + 
 				"----------\n" + 
 				"1 problem (1 error)\n",
-				false);
+				false,
+				"package s",
+				 OUTPUT_DIR + File.separator + out);
 	}
 	public void test020() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1028,12 +1275,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -1050,11 +1298,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-exports mod.one=mod.two,mod.three");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(),
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"incorrectly formatted option: --add-exports mod.one=mod.two,mod.three\n",
-				false);
+				false,
+				"option");
 	}
 	public void test021() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1062,12 +1311,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -1084,11 +1334,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --module-source-path " + "\"" + directory + "\"")
 			.append(" --add-reads mod.one/mod.two");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"incorrectly formatted option: --add-reads mod.one/mod.two\n",
-				false);
+				false,
+				"option");
 	}
 	public void test022() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1096,12 +1347,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -1119,11 +1371,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --add-exports mod.one/p=mod.three")
 			.append(" --add-exports mod.one/p=mod.three");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"can specify a package in a module only once with --add-export\n",
-				false);
+				false,
+				"export");
 	}
 	public void test023() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1131,7 +1384,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
@@ -1143,14 +1397,15 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append("\"" + OUTPUT_DIR +  File.separator + "module-info.java\" ")
+			.append("\"" + moduleLoc +  File.separator + "module-info.java\" ")
 			.append(" -extdirs " + OUTPUT_DIR + File.separator + "src");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"option -extdirs not supported at compliance level 9 and above\n",
-				false);
+				false,
+				"extdirs");
 	}
 	public void test024() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1158,7 +1413,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
@@ -1170,14 +1426,15 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append(" \"" + OUTPUT_DIR +  File.separator + "module-info.java\" ")
+			.append(" \"" + moduleLoc +  File.separator + "module-info.java\" ")
 			.append(" -bootclasspath " + OUTPUT_DIR + File.separator + "src");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"option -bootclasspath not supported at compliance level 9 and above\n",
-				false);
+				false,
+				"not allowed"); // when specifying -bootclasspath javac answers: "option --boot-class-path not allowed with target 1.9" (two bugs)
 	}
 	public void test025() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1185,7 +1442,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
@@ -1197,14 +1455,15 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" -classpath \"")
 			.append(Util.getJavaClassLibsAsString())
 			.append("\" ")
-			.append("\"" + OUTPUT_DIR +  File.separator + "module-info.java\" ")
+			.append("\"" + moduleLoc +  File.separator + "module-info.java\" ")
 			.append(" -endorseddirs " + OUTPUT_DIR + File.separator + "src");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"option -endorseddirs not supported at compliance level 9 and above\n",
-				false);
+				false,
+				"endorseddirs");
 	}
 	public void test026() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1212,7 +1471,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires transitive java.sql;\n" +
@@ -1224,47 +1484,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --system \"").append(javaHome).append("\"")
 			.append(" \"" + moduleLoc +  File.separator + "module-info.java\" ");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(new String[0], 
+				buffer.toString(),
 				"",
 				"",
 				false);
 	}
-	public void test027() {
-		File outputDirectory = new File(OUTPUT_DIR);
-		Util.flushDirectoryContent(outputDirectory);
-		String out = "bin";
-		String directory = OUTPUT_DIR + File.separator + "src";
-		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
-						"module mod.one { \n" +
-						"	requires java.base;\n" +
-						"}");
-		String javaHome = System.getProperty("java.home");
-		StringBuffer buffer = new StringBuffer();
-		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
-			.append(" -9 ")
-			.append(" --system \"").append(javaHome).append(File.separator)
-			.append("lib\"")
-			.append(" \"" + moduleLoc +  File.separator + "module-info.java\" ");
-
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
-				"",
-				"----------\n"+
-				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/module-info.java (at line 1)\n"+
-				"	module mod.one { \n"+
-				"	^\n"+
-				"The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files\n"+
-				"----------\n"+
-				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/module-info.java (at line 2)\n"+
-				"	requires java.base;\n"+
-				"	         ^^^^^^^^^\n"+
-				"java.base cannot be resolved to a module\n"+
-				"----------\n"+
-				"2 problems (2 errors)\n",
-				false);
-	}
 	/**
 	 * Mixed case of exported and non exported packages being referred to in another module
 	 */
@@ -1275,12 +1500,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		File modDir = new File(OUTPUT_DIR + File.separator + "mod");
 		createReusableModules(srcDir, outDir, modDir);
 		String moduleLoc = srcDir + File.separator + "mod.three";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.three { \n" +
 						"	requires mod.one;\n" +
 						"	requires mod.two;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "r", "Z.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "r", "Z.java", 
 						"package r;\n" +
 						"public class Z extends Object {\n" +
 						"	p.X x = null;\n" +
@@ -1296,8 +1522,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		.append("\" ")
 		.append(" --module-source-path " + "\"" + srcDir + "\"");
 
-		runNegativeTest(new String[]{},
-				buffer.toString(), 
+		runNegativeModuleTest(files,
+				buffer,
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/r/Z.java (at line 4)\n"+
@@ -1306,7 +1532,9 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"The type p1.X1 is not accessible\n" + 
 				"----------\n" + 
 				"1 problem (1 error)\n",
-				false);
+				false,
+				"visible", 
+				outDir);
 	}
 	public void test029() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1314,12 +1542,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -1327,11 +1556,11 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"public class Y {\n" +
 						"   java.sql.Connection con = p.X.getConnection();\n" +
@@ -1347,8 +1576,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --add-exports mod.one/p=mod.two,mod.three")
 			.append(" --add-reads mod.two=mod.one");
 
-		runNegativeTest(new String[]{}, 
-			buffer.toString(), 
+		runNegativeModuleTest(files, 
+			buffer,
 			"",
 			"----------\n"+
 			"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 3)\n"+
@@ -1357,7 +1586,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			"The type java.sql.Connection is not accessible\n"+
 			"----------\n"+
 			"1 problem (1 error)\n",
-			false);
+			false,
+			"visible");
 	}
 	public void test030() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1365,12 +1595,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -1378,11 +1609,11 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"import java.sql.*;\n" +
 						"public class Y {\n" +
@@ -1399,8 +1630,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --add-exports mod.one/p=mod.two,mod.three")
 			.append(" --add-reads mod.two=mod.one");
 
-		runNegativeTest(new String[]{}, 
-			buffer.toString(), 
+		runNegativeModuleTest(files, 
+			buffer,
 			"",
 			"----------\n"+
 			"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 2)\n"+
@@ -1414,7 +1645,9 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			"Connection cannot be resolved to a type\n"+
 			"----------\n"+
 			"2 problems (2 errors)\n",
-			false);
+			false,
+			"visible",
+			OUTPUT_DIR + File.separator + out);
 	}
 	public void test031() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1422,12 +1655,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X {\n" +
 						"	public static java.sql.Connection getConnection() {\n" +
@@ -1435,11 +1669,11 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"	}\n" +
 						"}");
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires java.base;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "q", "Y.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "q", "Y.java", 
 						"package q;\n" +
 						"import java.sql.Connection;\n" +
 						"public class Y {\n" +
@@ -1456,8 +1690,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(" --add-exports mod.one/p=mod.two,mod.three")
 			.append(" --add-reads mod.two=mod.one");
 
-		runNegativeTest(new String[]{}, 
-			buffer.toString(), 
+		runNegativeModuleTest(files, 
+			buffer,
 			"",
 			"----------\n"+
 			"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/q/Y.java (at line 2)\n"+
@@ -1471,7 +1705,9 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			"Connection cannot be resolved to a type\n"+
 			"----------\n"+
 			"2 problems (2 errors)\n",
-			false);
+			false,
+			"visible",
+			OUTPUT_DIR + File.separator + out);
 	}
 	public void test032() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -1479,11 +1715,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"}");
-		writeFile(moduleLoc, "X.java", 
+		writeFileCollecting(files, moduleLoc, "X.java", 
 						"public class X {\n" +
 						"	public static class Inner {\n" +
 						"	}\n" +
@@ -1497,11 +1734,12 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runConformTest(new String[]{}, 
-			buffer.toString(), 
+		runConformModuleTest(files, 
+			buffer,
 			"",
 			"",
-			false);
+			false,
+			OUTPUT_DIR + File.separator + out);
 	}
 	/**
 	 * Test that a module can't access types/packages in a plain Jar put in classpath
@@ -1528,12 +1766,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X extends a.A {\n" +
 						"}");
@@ -1545,8 +1784,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append(Util.getJavaClassLibsAsString())
 			.append(LIB_DIR).append(File.separator).append("lib1.jar").append(File.pathSeparator).append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/X.java (at line 2)\n" + 
@@ -1555,7 +1794,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"a cannot be resolved to a type\n" + 
 				"----------\n" + 
 				"1 problem (1 error)\n",
-				false);
+				false,
+				"package a does not exist");
 	}
 	/**
 	 * Test that a module can't access types/packages in a plain Jar put in modulepath
@@ -1583,12 +1823,13 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires java.sql;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X extends a.A {\n" +
 						"}");
@@ -1601,8 +1842,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("-p \"")
 			.append(LIB_DIR).append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.one/p/X.java (at line 2)\n" + 
@@ -1611,7 +1852,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"a cannot be resolved to a type\n" + 
 				"----------\n" + 
 				"1 problem (1 error)\n",
-				false);
+				false,
+				"does not read");
 	}
 	/**
 	 * Test that a module can access types/packages in a plain Jar put in modulepath
@@ -1639,13 +1881,14 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	requires java.base;\n" +
 						"	requires java.sql;\n" +
 						"	requires lib1;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p", "X.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p", "X.java", 
 						"package p;\n" +
 						"public class X extends a.A {\n" +
 						"}");
@@ -1658,8 +1901,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("-p \"")
 			.append(LIB_DIR).append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files, 
+				buffer,
 				"",
 				"",
 				false);
@@ -1671,27 +1914,28 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String directory = OUTPUT_DIR + File.separator + "src";
 		
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	exports pm;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "impl", "Other.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "impl", "Other.java", 
 						"package impl;\n" +
 						"public class Other {\n" +
 						"    public void privateMethod() {}" + 
 						"}\n");
-		writeFile(moduleLoc + File.separator + "pm", "C1.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "C1.java", 
 						"package pm;\n" +
 						"import impl.Other;\n" + 
 						"public class C1 extends Other {\n" + 
 						"}\n");
 
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires mod.one;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "po", "Client.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "po", "Client.java", 
 						"package po;\n" + 
 						"import pm.C1;\n" + 
 						"public class Client {\n" + 
@@ -1708,8 +1952,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files, 
+				buffer,
 				"",
 				"",
 				false);
@@ -1722,15 +1966,16 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String directory = OUTPUT_DIR + File.separator + "src";
 		
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	exports pm;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "impl", "Other.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "impl", "Other.java", 
 						"package impl;\n" +
 						"public class Other {\n" +
 						"}\n");
-		writeFile(moduleLoc + File.separator + "pm", "C1.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "C1.java", 
 						"package pm;\n" +
 						"import impl.Other;\n" + 
 						"public class C1 extends Other {\n" +
@@ -1738,15 +1983,15 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 						"}\n");
 
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires mod.one;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "impl", "Other.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "impl", "Other.java", 
 						"package impl;\n" +
 						"public class Other {\n" +
 						"}\n");
-		writeFile(moduleLoc + File.separator + "po", "Client.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "po", "Client.java", 
 						"package po;\n" + 
 						"import pm.C1;\n" + 
 						"public class Client {\n" + 
@@ -1763,8 +2008,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files, 
+				buffer,
 				"",
 				"",
 				false);
@@ -1781,36 +2026,37 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String directory = OUTPUT_DIR + File.separator + "src";
 		
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	exports pm;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "impl", "SomeImpl.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "impl", "SomeImpl.java", 
 						"package impl;\n" +
 						"public class SomeImpl {\n" +
 						"}\n");
-		writeFile(moduleLoc + File.separator + "pm", "C1.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "C1.java", 
 						"package pm;\n" +
 						"import impl.SomeImpl;\n" + 
 						"public class C1 {\n" +
 						"	public void m1(SomeImpl o) {}\n" + 
 						"}\n");
-		writeFile(moduleLoc + File.separator + "pm", "Other.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "Other.java", 
 						"package pm;\n" +
 						"import impl.SomeImpl;\n" + 
 						"public class Other extends SomeImpl {\n" +
 						"}\n");
 
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires mod.one;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "impl", "SomeImpl.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "impl", "SomeImpl.java", 
 						"package impl;\n" +
 						"public class SomeImpl {\n" + // pseudo-conflict to same named, but inaccessible class from mod.one
 						"}\n");
-		writeFile(moduleLoc + File.separator + "po", "Client.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "po", "Client.java", 
 						"package po;\n" + 
 						"import pm.C1;\n" + 
 						"import pm.Other;\n" +
@@ -1831,8 +2077,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/po/Client.java (at line 8)\n" + 
@@ -1841,7 +2087,9 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"The method m1(impl.SomeImpl) in the type C1 is not applicable for the arguments (impl.SomeImpl)\n" + 
 				"----------\n" + 
 				"1 problem (1 error)\n",
-				false);
+				false,
+				"incompatible",
+				OUTPUT_DIR + File.separator + out);
 	}
 
 	// conflict even without any reference to the conflicting package
@@ -1853,53 +2101,54 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String directory = OUTPUT_DIR + File.separator + "src";
 
 		String moduleLoc = directory + File.separator + "mod.x";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.x { \n" +
 						"	exports pm;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "pm", "C1x.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "C1x.java", 
 						"package pm;\n" +
 						"public class C1x {\n" +
 						"}\n");
 		
 		moduleLoc = directory + File.separator + "mod.y";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.y { \n" +
 						"	requires transitive mod.x;\n" +
 						"}");
 		
 		moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	exports pm;\n" +
 						"	exports p2;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "pm", "C1.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "C1.java", 
 						"package pm;\n" +
 						"public class C1 {\n" +
 						"}\n");
-		writeFile(moduleLoc + File.separator + "p2", "C2.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p2", "C2.java", 
 						"package p2;\n" +
 						"public class C2 {\n" +
 						"}\n");
 
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	exports pm;\n" +
 						"	exports p2.sub;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "pm", "C3.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "C3.java", 
 						"package pm;\n" +
 						"public class C3 {\n" +
 						"}\n");
-		writeFile(moduleLoc + File.separator + "p2" + File.separator + "sub", "C4.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p2" + File.separator + "sub", "C4.java", 
 						"package p2.sub;\n" +
 						"public class C4 {\n" +
 						"}\n");
 
 		moduleLoc = directory + File.separator + "mod.three";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.three { \n" +
 						"	requires mod.one;\n" +
 						"	requires mod.two;\n" +
@@ -1914,8 +2163,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/module-info.java (at line 2)\n" + 
@@ -1934,7 +2183,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"The package pm is accessible from more than one module: mod.one, mod.two, mod.x\n" + 
 				"----------\n" + 
 				"3 problems (3 errors)\n",
-				false);
+				false,
+				"reads package pm");
 	}
 
 	public void testPackageConflict1() {
@@ -1944,42 +2194,43 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String directory = OUTPUT_DIR + File.separator + "src";
 		
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	exports pm;\n" +
 						"	exports p2;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "pm", "C1.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "C1.java", 
 						"package pm;\n" +
 						"public class C1 {\n" +
 						"}\n");
-		writeFile(moduleLoc + File.separator + "p2", "C2.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p2", "C2.java", 
 						"package p2;\n" +
 						"public class C2 {\n" +
 						"}\n");
 
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	exports pm;\n" +
 						"	exports p2.sub;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "pm", "C3.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "C3.java", 
 						"package pm;\n" +
 						"public class C3 {\n" +
 						"}\n");
-		writeFile(moduleLoc + File.separator + "p2" + File.separator + "sub", "C4.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p2" + File.separator + "sub", "C4.java", 
 						"package p2.sub;\n" +
 						"public class C4 {\n" +
 						"}\n");
 
 		moduleLoc = directory + File.separator + "mod.three";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.three { \n" +
 						"	requires mod.one;\n" +
 						"	requires mod.two;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "po", "Client.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "po", "Client.java", 
 						"package po;\n" + 
 						"import pm.*;\n" +
 						"import pm.C3;\n" +
@@ -1999,8 +2250,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/module-info.java (at line 2)\n" + 
@@ -2030,7 +2281,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"The package pm is accessible from more than one module: mod.one, mod.two\n" + 
 				"----------\n" + 
 				"5 problems (5 errors)\n",
-				false);
+				false,
+				"reads package pm");
 	}
 	// conflict foreign<->local package
 	public void testPackageConflict3() {
@@ -2039,22 +2291,23 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 
+		List<String> files = new ArrayList<>(); 
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"	exports pm;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "pm", "C1.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "C1.java", 
 						"package pm;\n" +
 						"public class C1 {\n" +
 						"}\n");
 
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	requires mod.one;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "pm", "C3.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "pm", "C3.java", 
 						"package pm;\n" +
 						"public class C3 {\n" +
 						"}\n");
@@ -2067,8 +2320,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runNegativeTest(new String[]{},
-				buffer.toString(), 
+		runNegativeModuleTest(files,
+				buffer, 
 				"",
 				"----------\n" + 
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/pm/C3.java (at line 1)\n" + 
@@ -2077,7 +2330,9 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"The package pm conflicts with a package accessible from another module: mod.one\n" + 
 				"----------\n" + 
 				"1 problem (1 error)\n",
-				false);
+				false,
+				"",
+				OUTPUT_DIR + File.separator + out);
 	}
 	public void testPackageTypeConflict1() {
 		File outputDirectory = new File(OUTPUT_DIR);
@@ -2086,31 +2341,32 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String directory = OUTPUT_DIR + File.separator + "src";
 		
 		String moduleLoc = directory + File.separator + "mod.one";
-		writeFile(moduleLoc, "module-info.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.one { \n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p1" + File.separator + "p2", "t3.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p1" + File.separator + "p2", "t3.java", 
 						"package p1.p2;\n" +
 						"public class t3 {\n" +
 						"}\n");
 
 		moduleLoc = directory + File.separator + "mod.two";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.two { \n" +
 						"	exports p1.p2.t3;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "p1" + File.separator + "p2" + File.separator + "t3", "t4.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "p1" + File.separator + "p2" + File.separator + "t3", "t4.java", 
 						"package p1.p2.t3;\n" +
 						"public class t4 {\n" +
 						"}\n");
 
 		moduleLoc = directory + File.separator + "mod.three";
-		writeFile(moduleLoc, "module-info.java", 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
 						"module mod.three { \n" +
 						"	requires mod.one;\n" +
 						"	requires mod.two;\n" +
 						"}");
-		writeFile(moduleLoc + File.separator + "po", "Client.java", 
+		writeFileCollecting(files, moduleLoc + File.separator + "po", "Client.java", 
 						"package po;\n" + 
 						"public class Client {\n" + 
 						"	 p1.p2.t3.t4 f;\n" + // no conflict mod.one/p1.p2.t3 <-> mod.two/p1.p2.t3
@@ -2124,8 +2380,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runConformTest(new String[]{}, 
-				buffer.toString(), 
+		runConformModuleTest(files, 
+				buffer,
 				"",
 				"",
 				false);
@@ -2137,7 +2393,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 		String out = "bin";
 		String directory = OUTPUT_DIR + File.separator + "src";
 		
-		writeFile(directory + File.separator + "test", "Test.java", 
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, directory + File.separator + "test", "Test.java", 
 						"package test;\n" + 
 						"\n" + 
 						"public class Test implements org.eclipse.SomeInterface {\n" + 
@@ -2151,8 +2408,8 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 			.append("\" ")
 			.append(" --module-source-path " + "\"" + directory + "\"");
 
-		runNegativeTest(new String[]{}, 
-				buffer.toString(), 
+		runNegativeModuleTest(files, 
+				buffer,
 				"",
 				"----------\n" +
 				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/test/Test.java (at line 3)\n" +
@@ -2161,6 +2418,38 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"org.eclipse cannot be resolved to a type\n" +
 				"----------\n" +
 				"1 problem (1 error)\n",
-				false);
+				false,
+				"not in a module");
+	}
+	public void testMixedSourcepath() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+		String moduleLoc = directory + File.separator + "mod" + File.separator + "mod.one";
+
+		List<String> files = new ArrayList<>(); 
+		writeFileCollecting(files, moduleLoc, "module-info.java", 
+						"module mod.one {\n" +
+						"	exports p.q;\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\"")
+			.append(" -sourcepath \"" + directory + "\" ")
+			.append(" --module-source-path \"" + directory + File.separator + "mod" + "\" ")
+			.append(" --add-reads mod.one=ALL-UNNAMED ");
+
+		runNegativeModuleTest(files, 
+				buffer, 
+				"",
+				"cannot specify both -source-path and --module-source-path\n",
+				false,
+				"cannot specify both",
+				OUTPUT_DIR + File.separator + out);
 	}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index b9a1570..4e0caaf 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -38,6 +38,7 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
+import java.io.FileReader;
 import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.InputStreamReader;
@@ -48,6 +49,8 @@ import java.io.StringReader;
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Field;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.text.DateFormat;
 import java.text.MessageFormat;
 import java.util.ArrayList;
@@ -2192,6 +2195,9 @@ public void configure(String[] argv) {
 					continue;
 				}
 				if (currentArg.equals("--module-source-path")) { //$NON-NLS-1$
+					if (sourcepathClasspathArg != null) {
+						throw new IllegalArgumentException(this.bind("configure.OneOfModuleOrSourcePath")); //$NON-NLS-1$
+					}
 					mode = INSIDE_MODULESOURCEPATH_start;
 					continue;
 				}
@@ -2214,6 +2220,9 @@ public void configure(String[] argv) {
 						throw new IllegalArgumentException(
 							this.bind("configure.duplicateSourcepath", errorMessage.toString())); //$NON-NLS-1$
 					}
+					if (moduleSourcepathArg != null) {
+						throw new IllegalArgumentException(this.bind("configure.OneOfModuleOrSourcePath")); //$NON-NLS-1$
+					}
 					mode = INSIDE_SOURCE_PATH_start;
 					continue;
 				}
@@ -2764,8 +2773,7 @@ public void configure(String[] argv) {
 				continue;
 			case INSIDE_SYSTEM:
 				mode = DEFAULT;
-				this.javaHomeCache = new File(currentArg);
-				this.javaHomeChecked = true;
+				setJavaHome(currentArg);
 				continue;
 			case INSIDE_MODULEPATH_start:
 				mode = DEFAULT;
@@ -3003,9 +3011,7 @@ public void configure(String[] argv) {
 			CompilerOptions.OPTION_ReportMissingJavadocTagsVisibility,
 			CompilerOptions.PRIVATE);
 	}
-	// We don't add the source files from --module-source-path yet to the final list. So,
-	// don't report it if that's the case.
-	if (printUsageRequired || (filesCount == 0 && classCount == 0 && moduleSourcepathArg == null)) {
+	if (printUsageRequired || (filesCount == 0 && classCount == 0)) {
 		if (usageSection ==  null) {
 			printUsage(); // default
 		} else {
@@ -3336,7 +3342,19 @@ public IErrorHandlingPolicy getHandlingPolicy() {
 		}
 	};
 }
-
+private void setJavaHome(String javaHome) {
+	File release = new File(javaHome, "release"); //$NON-NLS-1$
+	Properties prop = new Properties();
+	try {
+		prop.load(new FileReader(release));
+		String ver = prop.getProperty("JAVA_VERSION"); //$NON-NLS-1$
+		if (ver != null)
+			ver = ver.replace("\"", "");  //$NON-NLS-1$//$NON-NLS-2$
+	} catch (IOException e) {
+		throw new IllegalArgumentException(this.bind("configure.invalidSystem", this.javaHomeCache.toString())); //$NON-NLS-1$
+	}
+	this.javaHomeChecked = true;
+}
 /*
  * External API
  */
@@ -3379,9 +3397,7 @@ protected ArrayList<Classpath> handleBootclasspath(ArrayList<String> bootclasspa
 		try {
 			Util.collectVMBootclasspath(result, this.javaHomeCache);
 		} catch(IllegalStateException e) {
-			this.logger.logWrongJDK();
-			this.proceed = false;
-			return null;
+			throw new IllegalArgumentException(this.bind("configure.invalidSystem", this.javaHomeCache.toString())); //$NON-NLS-1$
 		}
 	}
 	return result;
@@ -3455,60 +3471,25 @@ protected ArrayList<FileSystem.Classpath> handleModuleSourcepath(String arg) {
 				// 1. Create FileSystem.Classpath for each module
 				// 2. Iterator each module in case of directory for source files and add to this.fileNames
 
-				result =
-						(ArrayList<Classpath>) ModuleFinder.findModules(dir, this.destinationPath, getNewParser(), this.options, false);
-				for (Object obj : result) {
-					Classpath classpath = (Classpath) obj;
-					File modLocation = new File(classpath.getPath());
-					String[] files = FileFinder.find(modLocation, SuffixConstants.SUFFIX_STRING_java);
+				List<Classpath> modules = ModuleFinder.findModules(dir, this.destinationPath, getNewParser(), this.options, false);
+				for (Classpath classpath : modules) {
+					result.add(classpath);
+					Path modLocation = Paths.get(classpath.getPath()).toAbsolutePath();
 					String destPath = classpath.getDestinationPath();
 					IModule mod = classpath.getModule();
 					String moduleName = mod == null ? null : new String(mod.name());
-
-					// Add them to this.filenames
-					if (this.filenames != null) {
-						int filesCount = this.filenames.length;
-						// some source files were specified explicitly
-						int length = files.length;
-						System.arraycopy(
-							this.filenames,
-							0,
-							(this.filenames = new String[length + filesCount]),
-							0,
-							filesCount);
-						System.arraycopy(
-							this.encodings,
-							0,
-							(this.encodings = new String[length + filesCount]),
-							0,
-							filesCount);
-						System.arraycopy(
-							this.destinationPaths,
-							0,
-							(this.destinationPaths = new String[length + filesCount]),
-							0,
-							filesCount);
-						System.arraycopy(
-								this.modNames,
-								0,
-								(this.modNames = new String[length + filesCount]),
-								0,
-								filesCount);
-						System.arraycopy(files, 0, this.filenames, filesCount, length);
-						for (int j = 0; j < length; j++) {
-							this.modNames[filesCount + j] = moduleName;
-							this.destinationPaths[filesCount + j] = destPath;
-						}
-						filesCount += length;
-					} else {
-						this.filenames = files;
-						int filesCount = this.filenames.length;
-						this.encodings = new String[filesCount];
-						this.destinationPaths = new String[filesCount];
-						this.modNames = new String[filesCount];
-						for (int j = 0; j < filesCount; j++) {
-							this.destinationPaths[j] = destPath;
-							this.modNames[j] = moduleName;
+					for(int j = 0; j < this.filenames.length; j++) {
+						Path filePath;
+						try {
+							// Get canonical path just as the classpath location is stored with the same.
+							// To avoid mismatch of /USER_JAY and /USE~1 in windows systems.
+							filePath = new File(this.filenames[j]).getCanonicalFile().toPath();
+							if (filePath.startsWith(modLocation)) {
+								this.modNames[j] = moduleName;
+								this.destinationPaths[j] = destPath;
+							}
+						} catch (IOException e) {
+							// Files doesn't exist and perhaps doesn't belong in a module, move on to other files
 						}
 					}
 				}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index dc47911..35898b4 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -65,7 +65,7 @@ configure.duplicateCompliance = duplicate compliance setting specification: {0}
 configure.duplicateSource = duplicate source compliance setting specification: {0}
 configure.duplicateTarget = duplicate target compliance setting specification: {0}
 configure.source = source level should be comprised in between ''1.3'' and ''1.9'' (or ''5'', ''5.0'', ..., ''9'' or ''9.0''): {0}
-configure.invalidSystem = invalid location for system libraries
+configure.invalidSystem = invalid location for system libraries: {0}
 configure.unsupportedOption = option {0} not supported at compliance level 9 and above
 configure.duplicateOutputPath = duplicate output path specification: {0}
 configure.duplicateModulePath = duplicate module path specification: {0}
@@ -73,6 +73,7 @@ configure.duplicateModuleSourcepath = duplicate source module path specification
 configure.invalidModuleDescriptor = cannot open the module descriptor from {0}
 configure.invalidModuleOption = incorrectly formatted option: {0}
 configure.duplicateExport = can specify a package in a module only once with --add-export
+configure.OneOfModuleOrSourcePath = cannot specify both -source-path and --module-source-path
 configure.duplicateBootClasspath = duplicate bootclasspath specification: {0}
 configure.duplicateExtDirs = duplicate extdirs specification: {0}
 configure.duplicateSourcepath = duplicate sourcepath specification: {0}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 7cc7720..1ee4beb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -791,7 +791,7 @@ public class CompilerOptions {
 		String version = versionID;
 		// verification is optimized for all versions with same length and same "1." prefix
 		if (version != null && version.length() > 0) {
-			if (version.length() == 3 && version.charAt(0) == '1' && version.charAt(1) == '.') {
+			if (version.length() >= 3 && version.charAt(0) == '1' && version.charAt(1) == '.') {
 				switch (version.charAt(2)) {
 					case '1':
 						return ClassFileConstants.JDK1_1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 7929313..a388ce5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -22,7 +22,6 @@ import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
-import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -32,7 +31,6 @@ import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.zip.ZipEntry;
@@ -1167,26 +1165,9 @@ public class Util implements SuffixConstants {
 		collectVMBootclasspath(bootclasspaths, null);
 	}
 	public static long getJDKLevel(File javaHome) {
-		String version = getJavaVersion(javaHome);
+		String version = System.getProperty("java.version"); //$NON-NLS-1$
 		return CompilerOptions.versionToJdkLevel(version);
 	}
-	public static String getJavaVersion(File javaHome) {
-		if (javaHome == null) {
-			return System.getProperty("java.version"); //$NON-NLS-1$
-		}
-		File release = new File(javaHome, "release"); //$NON-NLS-1$
-		Properties prop = new Properties();
-		try {
-			prop.load(new FileReader(release));
-			String ver = prop.getProperty("JAVA_VERSION"); //$NON-NLS-1$
-			if (ver != null)
-				ver = ver.replace("\"", "");  //$NON-NLS-1$//$NON-NLS-2$
-			return ver;
-		} catch (IOException e) {
-			// Nothing can be done.
-		}
-		return null;
-	}
 	public static List<FileSystem.Classpath> collectFilesNames() {
 		return collectPlatformLibraries(null);
 	}
@@ -1196,7 +1177,8 @@ public class Util implements SuffixConstants {
 		 * the batch compiler
 		 */
 		String javaversion = null;
-		javaversion = getJavaVersion(javaHome);
+		javaversion = System.getProperty("java.version"); //$NON-NLS-1$
+		// Surely, this ain't required anymore?
 		if (javaversion != null && javaversion.equalsIgnoreCase("1.1.8")) { //$NON-NLS-1$
 			throw new IllegalStateException();
 		}
commit 3d0993820a456232c1e7c47f10db9652149baf69
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Fri Aug 11 20:27:52 2017 +0200

    Bug 487421: [1.9][batch] Support Java 9 options in command line compiler
    - fix setJavaHome() (both positive & negative case)
    
    Change-Id: I61f4371453068c44c0da6bdbf462a52b45df93c1

3	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 4e0caaf..bdf1f8c 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -3350,10 +3350,11 @@ private void setJavaHome(String javaHome) {
 		String ver = prop.getProperty("JAVA_VERSION"); //$NON-NLS-1$
 		if (ver != null)
 			ver = ver.replace("\"", "");  //$NON-NLS-1$//$NON-NLS-2$
+		this.javaHomeCache = new File(javaHome);
+		this.javaHomeChecked = true;
 	} catch (IOException e) {
-		throw new IllegalArgumentException(this.bind("configure.invalidSystem", this.javaHomeCache.toString())); //$NON-NLS-1$
+		throw new IllegalArgumentException(this.bind("configure.invalidSystem", javaHome)); //$NON-NLS-1$
 	}
-	this.javaHomeChecked = true;
 }
 /*
  * External API
