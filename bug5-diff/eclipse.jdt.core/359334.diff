commit e18b8152863f75de59815219afe0ab3ec946a798
Author: Stephan Herrmann <sherrmann>
Date:   Fri Sep 30 01:46:43 2011 +0200

    HEAD - Fixed bug 359334: Analysis for resource leak warnings does not
    consider exceptions as method exit points

40	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EmptyStatement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
index be3fcc3..542911f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *     							bug 358827 - [1.7] exception analysis for t-w-r spoils null analysis
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *     							bug 359334 - Analysis for resource leak warnings does not consider exceptions as method exit points
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -4942,6 +4943,45 @@ public void test056zzz() {
 		true,
 		options);
 }
+// Bug 359334 - Analysis for resource leak warnings does not consider exceptions as method exit points
+public void test056throw1() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_DEAD_CODE, CompilerOptions.ERROR);
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.io.FileReader;\n" +
+			"public class X {\n" +
+			"    void foo2(boolean a, boolean b, boolean c) throws Exception {\n" +
+			"        FileReader reader = new FileReader(\"file\");\n" +
+			"        if(a)\n" +
+			"            throw new Exception();    //warning 1\n" +
+			"        else if (b)\n" +
+			"            reader.close();\n" +
+			"        else if(c)\n" +
+			"            throw new Exception();    //warning 2\n" +
+			"        reader.close();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" +
+		"	throw new Exception();    //warning 1\n" +
+		"	^^^^^^^^^^^^^^^^^^^^^^\n" +
+		"Resource leak: \'reader\' is not closed at this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 10)\n" +
+		"	throw new Exception();    //warning 2\n" +
+		"	^^^^^^^^^^^^^^^^^^^^^^\n" +
+		"Resource leak: \'reader\' is not closed at this location\n" +
+		"----------\n",
+		null,
+		true,
+		options);	
+}
 public static Class testClass() {
 	return TryWithResourcesStatementTest.class;
 }
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 2066a8c..26db9ea 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -52,7 +52,9 @@ Eclipse SDK 3.8.0 - %date% - 3.8.0 M3
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=359362">359362</a>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=359334">359334</a>
+Analysis for resource leak warnings does not consider exceptions as method exit points
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=359362">359362</a>
 FUP of bug 349326: Resource leak on non-Closeable resource.
 <br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=348186">348186</a>
 [compiler] Improve wording for the warning for masked/hidden catch block
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
index f446ce9..6a80298 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
@@ -33,12 +33,12 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	int complaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0 ? Statement.COMPLAINED_FAKE_REACHABLE : Statement.NOT_COMPLAINED;
 	for (int i = 0, max = this.statements.length; i < max; i++) {
 		Statement stat = this.statements[i];
-		if ((complaintLevel = stat.complainIfUnreachable(flowInfo, flowContext, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
+		if ((complaintLevel = stat.complainIfUnreachable(flowInfo, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
 			flowInfo = stat.analyseCode(this.scope, flowContext, flowInfo);
 		}
 	}
 	if (this.explicitDeclarations > 0) // if block has its own scope analyze tracking vars now:
-		this.scope.checkUnclosedCloseables(flowInfo, flowContext, null);
+		this.scope.checkUnclosedCloseables(flowInfo, null);
 	return flowInfo;
 }
 /**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 9ff71db..5907c61 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -66,7 +66,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 				trueFlowInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 			}
 			if (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {
-				this.valueIfTrue.complainIfUnreachable(trueFlowInfo, flowContext, currentScope, initialComplaintLevel, false);
+				this.valueIfTrue.complainIfUnreachable(trueFlowInfo, currentScope, initialComplaintLevel, false);
 			}
 		}
 		this.trueInitStateIndex = currentScope.methodScope().recordInitializationStates(trueFlowInfo);
@@ -79,7 +79,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 				falseFlowInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 			}
 			if (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {
-				this.valueIfFalse.complainIfUnreachable(falseFlowInfo, flowContext, currentScope, initialComplaintLevel, true);
+				this.valueIfFalse.complainIfUnreachable(falseFlowInfo, currentScope, initialComplaintLevel, true);
 			}
 		}
 		this.falseInitStateIndex = currentScope.methodScope().recordInitializationStates(falseFlowInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
index 99def1c..d8e3818 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
@@ -153,7 +153,7 @@ public void analyseCode(ClassScope classScope, InitializationFlowContext initial
 			int complaintLevel = (nonStaticFieldInfoReachMode & FlowInfo.UNREACHABLE) == 0 ? Statement.NOT_COMPLAINED : Statement.COMPLAINED_FAKE_REACHABLE;
 			for (int i = 0, count = this.statements.length; i < count; i++) {
 				Statement stat = this.statements[i];
-				if ((complaintLevel = stat.complainIfUnreachable(flowInfo, constructorContext, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
+				if ((complaintLevel = stat.complainIfUnreachable(flowInfo, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
 					flowInfo = stat.analyseCode(this.scope, constructorContext, flowInfo);
 				}
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EmptyStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EmptyStatement.java
index b74fded..904e564 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EmptyStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EmptyStatement.java
@@ -30,12 +30,12 @@ public class EmptyStatement extends Statement {
 	}
 
 	// Report an error if necessary
-	public int complainIfUnreachable(FlowInfo flowInfo, FlowContext flowContext, BlockScope scope, int complaintLevel, boolean endOfBlock) {
+	public int complainIfUnreachable(FlowInfo flowInfo, BlockScope scope, int complaintLevel, boolean endOfBlock) {
 		// before 1.4, empty statements are tolerated anywhere
 		if (scope.compilerOptions().complianceLevel < ClassFileConstants.JDK1_4) {
 			return complaintLevel;
 		}
-		return super.complainIfUnreachable(flowInfo, flowContext, scope, complaintLevel, endOfBlock);
+		return super.complainIfUnreachable(flowInfo, scope, complaintLevel, endOfBlock);
 	}
 
 	public void generateCode(BlockScope currentScope, CodeStream codeStream){
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
index e816169..75ca5bf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
@@ -140,7 +140,7 @@ public class ForStatement extends Statement {
 						actionInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 					}
 				}
-			if (this.action.complainIfUnreachable(actionInfo, flowContext, this.scope, initialComplaintLevel, true) < Statement.COMPLAINED_UNREACHABLE) {
+			if (this.action.complainIfUnreachable(actionInfo, this.scope, initialComplaintLevel, true) < Statement.COMPLAINED_UNREACHABLE) {
 				actionInfo = this.action.analyseCode(this.scope, loopingContext, actionInfo).unconditionalInits();
 			}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
index 6d8e62d..44d3b61 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
@@ -100,7 +100,7 @@ public class ForeachStatement extends Statement {
 		if (!(this.action == null || (this.action.isEmptyBlock()
 				&& currentScope.compilerOptions().complianceLevel <= ClassFileConstants.JDK1_3))) {
 
-			if (this.action.complainIfUnreachable(actionInfo, flowContext, this.scope, initialComplaintLevel, true) < Statement.COMPLAINED_UNREACHABLE) {
+			if (this.action.complainIfUnreachable(actionInfo, this.scope, initialComplaintLevel, true) < Statement.COMPLAINED_UNREACHABLE) {
 				actionInfo = this.action.analyseCode(this.scope, loopingContext, actionInfo).unconditionalCopy();
 			}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index 2b9c876..a70662c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -91,7 +91,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		this.thenInitStateIndex = currentScope.methodScope().recordInitializationStates(thenFlowInfo);
 		if (isConditionOptimizedFalse || ((this.bits & ASTNode.IsThenStatementUnreachable) != 0)) {
 			if (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {
-				this.thenStatement.complainIfUnreachable(thenFlowInfo, flowContext, currentScope, initialComplaintLevel, false);
+				this.thenStatement.complainIfUnreachable(thenFlowInfo, currentScope, initialComplaintLevel, false);
 			} else {
 				// its a known coding pattern which should be tolerated by dead code analysis
 				// according to isKnowDeadCodePattern()
@@ -117,7 +117,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		this.elseInitStateIndex = currentScope.methodScope().recordInitializationStates(elseFlowInfo);
 		if (isConditionOptimizedTrue || ((this.bits & ASTNode.IsElseStatementUnreachable) != 0)) {
 			if (!isKnowDeadCodePattern(this.condition) || currentScope.compilerOptions().reportDeadCodeInTrivialIfStatement) {
-				this.elseStatement.complainIfUnreachable(elseFlowInfo, flowContext, currentScope, initialComplaintLevel, false);
+				this.elseStatement.complainIfUnreachable(elseFlowInfo, currentScope, initialComplaintLevel, false);
 			} else {
 				// its a known coding pattern which should be tolerated by dead code analysis
 				// according to isKnowDeadCodePattern()
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index ab7e7f6..5fa2895 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -101,7 +101,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 				int complaintLevel = (flowInfo.reachMode() & FlowInfo.UNREACHABLE) == 0 ? Statement.NOT_COMPLAINED : Statement.COMPLAINED_FAKE_REACHABLE;
 				for (int i = 0, count = this.statements.length; i < count; i++) {
 					Statement stat = this.statements[i];
-					if ((complaintLevel = stat.complainIfUnreachable(flowInfo, methodContext, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
+					if ((complaintLevel = stat.complainIfUnreachable(flowInfo, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
 						flowInfo = stat.analyseCode(this.scope, methodContext, flowInfo);
 					}
 				}
@@ -135,7 +135,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 				}
 					
 			}
-			this.scope.checkUnclosedCloseables(flowInfo, methodContext, null/*don't report against a specific location*/);
+			this.scope.checkUnclosedCloseables(flowInfo, null/*don't report against a specific location*/);
 		} catch (AbortMethod e) {
 			this.ignoreFurtherInvestigation = true;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 1be2ead..c1f3c4d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -114,7 +114,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			this.expression.bits |= ASTNode.IsReturnedValue;
 		}
 	}
-	currentScope.checkUnclosedCloseables(flowInfo, null/*ignore exception exits from flowContext*/, this);
+	currentScope.checkUnclosedCloseables(flowInfo, this);
 	return FlowInfo.DEAD_END;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index fb056b6..a6c1b75 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -72,7 +72,7 @@ public void branchChainTo(BranchLabel label) {
 
 // Report an error if necessary (if even more unreachable than previously reported
 // complaintLevel = 0 if was reachable up until now, 1 if fake reachable (deadcode), 2 if fatal unreachable (error)
-public int complainIfUnreachable(FlowInfo flowInfo, FlowContext flowContext, BlockScope scope, int previousComplaintLevel, boolean endOfBlock) {
+public int complainIfUnreachable(FlowInfo flowInfo, BlockScope scope, int previousComplaintLevel, boolean endOfBlock) {
 	if ((flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0) {
 		if ((flowInfo.reachMode() & FlowInfo.UNREACHABLE_OR_DEAD) != 0)
 			this.bits &= ~ASTNode.IsReachable;
@@ -80,14 +80,14 @@ public int complainIfUnreachable(FlowInfo flowInfo, FlowContext flowContext, Blo
 			if (previousComplaintLevel < COMPLAINED_UNREACHABLE) {
 				scope.problemReporter().unreachableCode(this);
 				if (endOfBlock)
-					scope.checkUnclosedCloseables(flowInfo, flowContext, null);
+					scope.checkUnclosedCloseables(flowInfo, null);
 			}
 			return COMPLAINED_UNREACHABLE;
 		} else {
 			if (previousComplaintLevel < COMPLAINED_FAKE_REACHABLE) {
 				scope.problemReporter().fakeReachable(this);
 				if (endOfBlock)
-					scope.checkUnclosedCloseables(flowInfo, flowContext, null);
+					scope.checkUnclosedCloseables(flowInfo, null);
 			}
 			return COMPLAINED_FAKE_REACHABLE;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
index 21c1ca0..609a8a5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
@@ -101,7 +101,7 @@ public class SwitchStatement extends Statement {
 					} else {
 						fallThroughState = FALLTHROUGH; // reset below if needed
 					}
-					if ((complaintLevel = statement.complainIfUnreachable(caseInits, flowContext, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
+					if ((complaintLevel = statement.complainIfUnreachable(caseInits, this.scope, complaintLevel, true)) < Statement.COMPLAINED_UNREACHABLE) {
 						caseInits = statement.analyseCode(this.scope, switchContext, caseInits);
 						if (caseInits == FlowInfo.DEAD_END) {
 							fallThroughState = ESCAPING;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
index 7e3d4c2..1d83852 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 359334 - Analysis for resource leak warnings does not consider exceptions as method exit points
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -35,6 +36,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	this.exception.checkNPE(currentScope, flowContext, flowInfo);
 	// need to check that exception thrown is actually caught somewhere
 	flowContext.checkExceptionHandlers(this.exceptionType, this, flowInfo, currentScope);
+	currentScope.checkUnclosedCloseables(flowInfo, this);
 	return FlowInfo.DEAD_END;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
index 8ead6d4..e35ea9c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
@@ -115,7 +115,7 @@ public class WhileStatement extends Statement {
 				currentScope.methodScope().recordInitializationStates(
 					condInfo.initsWhenTrue());
 
-			if (this.action.complainIfUnreachable(actionInfo, flowContext, currentScope, initialComplaintLevel, true) < Statement.COMPLAINED_UNREACHABLE) {
+			if (this.action.complainIfUnreachable(actionInfo, currentScope, initialComplaintLevel, true) < Statement.COMPLAINED_UNREACHABLE) {
 				actionInfo = this.action.analyseCode(currentScope, loopingContext, actionInfo);
 			}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
index 0ca801d..f4e2ae3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
@@ -18,7 +18,6 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.*;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.CodeStream;
-import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
@@ -988,11 +987,11 @@ public void removeTrackingVar(FakedTrackingVariable trackingVariable) {
  * At the end of a block check the closing-status of all tracked closeables that are declared in this block.
  * Also invoked when entering unreachable code.
  */
-public void checkUnclosedCloseables(FlowInfo flowInfo, FlowContext flowContext, ASTNode location) {
+public void checkUnclosedCloseables(FlowInfo flowInfo, ASTNode location) {
 	if (this.trackingVariables == null) {
 		// at a method return we also consider enclosing scopes
 		if (location != null && this.parent instanceof BlockScope)
-			((BlockScope) this.parent).checkUnclosedCloseables(flowInfo, flowContext, location);
+			((BlockScope) this.parent).checkUnclosedCloseables(flowInfo, location);
 		return;
 	}
 	if (location != null && flowInfo.reachMode() != 0) return;
commit 9d00e6aaf0f2f4598b676da2bb31ba68b6d40cc8
Author: Stephan Herrmann <sherrmann>
Date:   Sat Oct 1 23:46:57 2011 +0200

    HEAD - Fixed bug 359334: Analysis for resource leak warnings does not
    consider exceptions as method exit points

195	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
36	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
index 542911f..07ea7f0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
@@ -23,7 +23,7 @@ import junit.framework.Test;
 public class TryWithResourcesStatementTest extends AbstractRegressionTest {
 
 static {
-//	TESTS_NAMES = new String[] { "test056zz"};
+//	TESTS_NAMES = new String[] { "test056throw"};
 //	TESTS_NUMBERS = new int[] { 50 };
 //	TESTS_RANGE = new int[] { 11, -1 };
 }
@@ -4944,6 +4944,7 @@ public void test056zzz() {
 		options);
 }
 // Bug 359334 - Analysis for resource leak warnings does not consider exceptions as method exit points
+// explicit throw is a true method exit here
 public void test056throw1() {
 	Map options = getCompilerOptions();
 	options.put(JavaCore.COMPILER_PB_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
@@ -4982,6 +4983,199 @@ public void test056throw1() {
 		true,
 		options);	
 }
+// Bug 359334 - Analysis for resource leak warnings does not consider exceptions as method exit points
+// close() within finally provides protection for throw
+public void test056throw2() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_DEAD_CODE, CompilerOptions.ERROR);
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.io.FileReader;\n" +
+			"public class X {\n" +
+			"    void foo1() throws Exception {\n" + 
+			"        FileReader reader = new FileReader(\"file\"); // propose t-w-r\n" + 
+			"        try {\n" + 
+			"            reader.read();\n" + 
+			"            return;\n" + 
+			"        } catch (Exception e) {\n" + 
+			"            throw new Exception();\n" + 
+			"        } finally {\n" + 
+			"            reader.close();\n" + 
+			"        }\n" + 
+			"    }\n" + 
+			"\n" + 
+			"    void foo2() throws Exception {\n" + 
+			"        FileReader reader = new FileReader(\"file\"); // propose t-w-r\n" + 
+			"        try {\n" + 
+			"            reader.read();\n" + 
+			"            throw new Exception(); // should not warn here\n" + 
+			"        } catch (Exception e) {\n" + 
+			"            throw new Exception();\n" + 
+			"        } finally {\n" + 
+			"            reader.close();\n" + 
+			"        }\n" + 
+			"    }\n" + 
+			"\n" + 
+			"    void foo3() throws Exception {\n" + 
+			"        FileReader reader = new FileReader(\"file\"); // propose t-w-r\n" + 
+			"        try {\n" + 
+			"            reader.read();\n" + 
+			"            throw new Exception();\n" + 
+			"        } finally {\n" + 
+			"            reader.close();\n" + 
+			"        }\n" + 
+			"    }\n" + 
+			"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	FileReader reader = new FileReader(\"file\"); // propose t-w-r\n" +
+		"	           ^^^^^^\n" +
+		"Resource \'reader\' should be managed by try-with-resource\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 16)\n" +
+		"	FileReader reader = new FileReader(\"file\"); // propose t-w-r\n" +
+		"	           ^^^^^^\n" +
+		"Resource \'reader\' should be managed by try-with-resource\n" +
+		"----------\n" +
+		"3. ERROR in X.java (at line 28)\n" +
+		"	FileReader reader = new FileReader(\"file\"); // propose t-w-r\n" +
+		"	           ^^^^^^\n" +
+		"Resource \'reader\' should be managed by try-with-resource\n" +
+		"----------\n",
+		null,
+		true,
+		options);	
+}
+// Bug 359334 - Analysis for resource leak warnings does not consider exceptions as method exit points
+// close() nested within finally provides protection for throw
+public void test056throw3() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_DEAD_CODE, CompilerOptions.ERROR);
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.io.FileReader;\n" +
+			"public class X {\n" +
+			"    void foo2x() throws Exception {\n" + 
+			"        FileReader reader = new FileReader(\"file\"); // propose t-w-r\n" + 
+			"        try {\n" + 
+			"            reader.read();\n" + 
+			"            throw new Exception(); // should not warn here\n" + 
+			"        } catch (Exception e) {\n" + 
+			"            throw new Exception();\n" + 
+			"        } finally {\n" +
+			"            if (reader != null)\n" +
+			"                 try {\n" + 
+			"                     reader.close();\n" +
+			"                 } catch (java.io.IOException io) {}\n" + 
+			"        }\n" + 
+			"    }\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	FileReader reader = new FileReader(\"file\"); // propose t-w-r\n" + 
+		"	           ^^^^^^\n" + 
+		"Resource \'reader\' should be managed by try-with-resource\n" + 
+		"----------\n",
+		null,
+		true,
+		options);	
+}
+// Bug 359334 - Analysis for resource leak warnings does not consider exceptions as method exit points
+// additional boolean should shed doubt on whether we reach the close() call
+public void test056throw4() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_DEAD_CODE, CompilerOptions.ERROR);
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.io.FileReader;\n" +
+			"public class X {\n" +
+			"    void foo2x(boolean b) throws Exception {\n" + 
+			"        FileReader reader = new FileReader(\"file\");\n" + 
+			"        try {\n" + 
+			"            reader.read();\n" + 
+			"            throw new Exception(); // should warn here\n" + 
+			"        } catch (Exception e) {\n" + 
+			"            throw new Exception(); // should warn here\n" + 
+			"        } finally {\n" +
+			"            if (reader != null && b)\n" + // this condition is too strong to protect reader
+			"                 try {\n" + 
+			"                     reader.close();\n" +
+			"                 } catch (java.io.IOException io) {}\n" + 
+			"        }\n" + 
+			"    }\n" + 
+			"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 7)\n" +
+		"	throw new Exception(); // should warn here\n" +
+		"	^^^^^^^^^^^^^^^^^^^^^^\n" +
+		"Potential resource leak: \'reader\' may not be closed at this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 9)\n" +
+		"	throw new Exception(); // should warn here\n" +
+		"	^^^^^^^^^^^^^^^^^^^^^^\n" +
+		"Potential resource leak: \'reader\' may not be closed at this location\n" +
+		"----------\n",
+		null,
+		true,
+		options);	
+}
+// Bug 359334 - Analysis for resource leak warnings does not consider exceptions as method exit points
+// similar to test056throw3() but indirectly calling close(), so doubts remain.
+public void test056throw5() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE, CompilerOptions.ERROR);
+	options.put(JavaCore.COMPILER_PB_DEAD_CODE, CompilerOptions.ERROR);
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.io.FileReader;\n" +
+			"public class X {\n" +
+			"    void foo2x() throws Exception {\n" +
+			"        FileReader reader = new FileReader(\"file\");\n" +
+			"        try {\n" +
+			"            reader.read();\n" +
+			"            throw new Exception(); // should warn 'may not' here\n" +
+			"        } catch (Exception e) {\n" +
+			"            throw new Exception(); // should warn 'may not' here\n" +
+			"        } finally {\n" +
+			"            doClose(reader);\n" +
+			"        }\n" +
+			"    }\n" +
+			"    void doClose(FileReader r) { try { r.close(); } catch (java.io.IOException ex) {}}\n" + 
+			"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 7)\n" +
+		"	throw new Exception(); // should warn \'may not\' here\n" +
+		"	^^^^^^^^^^^^^^^^^^^^^^\n" +
+		"Potential resource leak: \'reader\' may not be closed at this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 9)\n" +
+		"	throw new Exception(); // should warn \'may not\' here\n" +
+		"	^^^^^^^^^^^^^^^^^^^^^^\n" +
+		"Potential resource leak: \'reader\' may not be closed at this location\n" +
+		"----------\n",
+		null,
+		true,
+		options);	
+}
 public static Class testClass() {
 	return TryWithResourcesStatementTest.class;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
index 6a80298..90b2f96 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
@@ -38,7 +38,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 	}
 	if (this.explicitDeclarations > 0) // if block has its own scope analyze tracking vars now:
-		this.scope.checkUnclosedCloseables(flowInfo, null);
+		this.scope.checkUnclosedCloseables(flowInfo, null, null);
 	return flowInfo;
 }
 /**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
index 10bebc4..ee13047 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FakedTrackingVariable.java
@@ -167,7 +167,7 @@ public class FakedTrackingVariable extends LocalDeclaration {
 		this.globalClosingState |= CLOSE_SEEN;
 //TODO(stephan): this might be useful, but I could not find a test case for it: 
 //		if (flowContext.initsOnFinally != null)
-//			flowContext.initsOnFinally.markAsDefinitelyNonNull(this.binding);		
+//			flowContext.initsOnFinally.markAsDefinitelyNonNull(this.binding);
 	}
 
 	/** Mark that this resource is closed from a nested method (inside a local class). */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 5fa2895..5b60ba3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -135,7 +135,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 				}
 					
 			}
-			this.scope.checkUnclosedCloseables(flowInfo, null/*don't report against a specific location*/);
+			this.scope.checkUnclosedCloseables(flowInfo, null/*don't report against a specific location*/, null);
 		} catch (AbortMethod e) {
 			this.ignoreFurtherInvestigation = true;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index c1f3c4d..ca1e277 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -114,7 +114,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			this.expression.bits |= ASTNode.IsReturnedValue;
 		}
 	}
-	currentScope.checkUnclosedCloseables(flowInfo, this);
+	currentScope.checkUnclosedCloseables(flowInfo, this, currentScope);
 	return FlowInfo.DEAD_END;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index a6c1b75..99d0fcb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -80,14 +80,14 @@ public int complainIfUnreachable(FlowInfo flowInfo, BlockScope scope, int previo
 			if (previousComplaintLevel < COMPLAINED_UNREACHABLE) {
 				scope.problemReporter().unreachableCode(this);
 				if (endOfBlock)
-					scope.checkUnclosedCloseables(flowInfo, null);
+					scope.checkUnclosedCloseables(flowInfo, null, null);
 			}
 			return COMPLAINED_UNREACHABLE;
 		} else {
 			if (previousComplaintLevel < COMPLAINED_FAKE_REACHABLE) {
 				scope.problemReporter().fakeReachable(this);
 				if (endOfBlock)
-					scope.checkUnclosedCloseables(flowInfo, null);
+					scope.checkUnclosedCloseables(flowInfo, null, null);
 			}
 			return COMPLAINED_FAKE_REACHABLE;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
index 1d83852..7c06835 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
@@ -36,7 +36,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	this.exception.checkNPE(currentScope, flowContext, flowInfo);
 	// need to check that exception thrown is actually caught somewhere
 	flowContext.checkExceptionHandlers(this.exceptionType, this, flowInfo, currentScope);
-	currentScope.checkUnclosedCloseables(flowInfo, this);
+	currentScope.checkUnclosedCloseables(flowInfo, this, currentScope);
 	return FlowInfo.DEAD_END;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index a23c2b7..e1ff80d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -11,6 +11,7 @@
  *     							bug 332637 - Dead Code detection removing code that isn't dead
  *     							bug 358827 - [1.7] exception analysis for t-w-r spoils null analysis
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *     							bug 359334 - Analysis for resource leak warnings does not consider exceptions as method exit points
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -238,6 +239,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		if (subInfo == FlowInfo.DEAD_END) {
 			this.bits |= ASTNode.IsSubRoutineEscaping;
 			this.scope.problemReporter().finallyMustCompleteNormally(this.finallyBlock);
+		} else {
+			// for resource analysis we need the finallyInfo in these nested scopes:
+			FlowInfo finallyInfo = subInfo.copy();
+			this.tryBlock.scope.finallyInfo = finallyInfo;
+			if (this.catchBlocks != null) {
+				for (int i = 0; i < this.catchBlocks.length; i++)
+					this.catchBlocks[i].scope.finallyInfo = finallyInfo;
+			}
 		}
 		this.subRoutineInits = subInfo;
 		// process the try block in a context handling the local exceptions.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
index f4e2ae3..c93c9d9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 349326 - [1.7] new warning for missing try-with-resources
+ *     Stephan Herrmann - Contributions for
+ *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 359334 - Analysis for resource leak warnings does not consider exceptions as method exit points
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -964,6 +966,8 @@ public void resetEnclosingMethodStaticFlag() {
 }
 
 private List trackingVariables; // can be null if no resources are tracked
+/** Used only during analyseCode and only for checking if a resource was closed in a finallyBlock. */
+public FlowInfo finallyInfo;
 /**
  * Register a tracking variable and compute its id.
  */
@@ -975,7 +979,7 @@ public int registerTrackingVariable(FakedTrackingVariable fakedTrackingVariable)
 	return outerMethodScope.analysisIndex + (outerMethodScope.trackVarCount++);
 	
 }
-/** When no longer interested in this tracking variable remove it. */
+/** When are no longer interested in this tracking variable - remove it. */
 public void removeTrackingVar(FakedTrackingVariable trackingVariable) {
 	if (this.trackingVariables != null)
 		if (this.trackingVariables.remove(trackingVariable))
@@ -987,11 +991,11 @@ public void removeTrackingVar(FakedTrackingVariable trackingVariable) {
  * At the end of a block check the closing-status of all tracked closeables that are declared in this block.
  * Also invoked when entering unreachable code.
  */
-public void checkUnclosedCloseables(FlowInfo flowInfo, ASTNode location) {
+public void checkUnclosedCloseables(FlowInfo flowInfo, ASTNode location, BlockScope locationScope) {
 	if (this.trackingVariables == null) {
 		// at a method return we also consider enclosing scopes
 		if (location != null && this.parent instanceof BlockScope)
-			((BlockScope) this.parent).checkUnclosedCloseables(flowInfo, location);
+			((BlockScope) this.parent).checkUnclosedCloseables(flowInfo, location, locationScope);
 		return;
 	}
 	if (location != null && flowInfo.reachMode() != 0) return;
@@ -1000,14 +1004,12 @@ public void checkUnclosedCloseables(FlowInfo flowInfo, ASTNode location) {
 		if (location != null && trackingVar.originalBinding != null && flowInfo.isDefinitelyNull(trackingVar.originalBinding))
 			continue; // reporting against a specific location, resource is null at this flow, don't complain
 		int status = getNullStatusAggressively(trackingVar.binding, flowInfo);
+		// try to improve info if a close() inside finally was observed:
+		if (locationScope != null) // only check at method exit points
+			status = locationScope.mergeCloseStatus(status, trackingVar.binding, this);
 		if (status == FlowInfo.NULL) {
 			// definitely unclosed: highest priority
 			reportResourceLeak(trackingVar, location, status);
-			if (location == null) {
-				// definitely done with this trackingVar, remove it
-				this.trackingVariables.remove(trackingVar);
-				i--; // ... but don't disturb the enclosing loop.
-			}
 			continue;
 		}
 		if (location == null) // at end of block and not definitely unclosed
@@ -1025,7 +1027,32 @@ public void checkUnclosedCloseables(FlowInfo flowInfo, ASTNode location) {
 				trackingVar.reportExplicitClosing(problemReporter());
 		}
 	}
+	if (location == null) {
+		// when leaving this block dispose off all tracking variables:
+		for (int i=0; i<this.localIndex; i++)
+			this.locals[i].closeTracker = null;		
+		this.trackingVariables = null;
+	}
+}
+
+private int mergeCloseStatus(int status, LocalVariableBinding binding, BlockScope outerScope) {
+	// get the most suitable null status representing whether resource 'binding' has been closed
+	// start at this scope and potentially travel out until 'outerScope'
+	// at each scope consult any recorded 'finallyInfo'.
+	if (status != FlowInfo.NON_NULL) {
+		if (this.finallyInfo != null) {
+			int finallyStatus = this.finallyInfo.nullStatus(binding);
+			if (finallyStatus == FlowInfo.NON_NULL)
+				return finallyStatus;
+			if (finallyStatus != FlowInfo.NULL) // neither is NON_NULL, but not both are NULL => call it POTENTIALLY_NULL
+				status = FlowInfo.POTENTIALLY_NULL;
+		}
+		if (this != outerScope && this.parent instanceof BlockScope)
+			return ((BlockScope) this.parent).mergeCloseStatus(status, binding, outerScope);
+	}
+	return status;
 }
+
 private void reportResourceLeak(FakedTrackingVariable trackingVar, ASTNode location, int nullStatus) {
 	if (location != null)
 		trackingVar.recordErrorLocation(location, nullStatus);
