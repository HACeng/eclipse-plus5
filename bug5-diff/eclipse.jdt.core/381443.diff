commit 2c8186e7489f922689211662fed2641fe910c44e
Author: Stephan Herrmann <stephan@cs.tu-berlin.de>
Date:   Sun Dec 2 20:06:50 2012 +0100

    Bug 381443 - [compiler][null] Allow parameter widening from @NonNull to
    unannotated

4	18	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
37	19	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 9ea37c9..c8ef83a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -21,6 +21,7 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 375366 - ECJ ignores unusedParameterIncludeDocCommentReference unless enableJavadoc option is set
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -12628,12 +12629,7 @@ public void test313_warn_options() {
 		"	                     ^^^^^^\n" + 
 		"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 		"----------\n" + 
-		"3. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" + 
-		"	@Nullable Object foo(Object o, Object o2) { return null; }\n" + 
-		"	                               ^^^^^^\n" + 
-		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" + 
-		"----------\n" + 
-		"3 problems (3 warnings)", 
+		"2 problems (2 warnings)", 
 		true);
 }
 
@@ -12677,12 +12673,7 @@ public void test314_warn_options() {
 		"	                     ^^^^^^\n" + 
 		"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 		"----------\n" + 
-		"3. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" + 
-		"	@Nullable Object foo(Object o, Object o2) { return null; }\n" + 
-		"	                               ^^^^^^\n" + 
-		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" + 
-		"----------\n" + 
-		"3 problems (3 errors)", 
+		"2 problems (2 errors)", 
 		true);
 }
 
@@ -13668,12 +13659,7 @@ public void testBug375366c() throws IOException {
 			"	                     ^^^^^^\n" + 
 			"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 			"----------\n" + 
-			"3. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" + 
-			"	@Nullable Object foo(Object o, Object o2) { return null; }\n" + 
-			"	                               ^^^^^^\n" + 
-			"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" + 
-			"----------\n" + 
-			"3 problems (3 errors)", 
+			"2 problems (2 errors)", 
 			false/*don't flush*/);
 }
 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index f3b1509..c904e2a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -1036,10 +1036,10 @@ public void test_parameter_specification_inheritance_008() {
 	options.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runConformTestWithLibs(
 		new String[] {
-			"IX.java",
+			"X.java",
 			"import org.eclipse.jdt.annotation.*;\n" +
-			"public interface IX {\n" +
-			"    void printObject(@NonNull Object o);\n" +
+			"public class X {\n" +
+			"    void printObject(@NonNull Object o) { System.out.print(o.toString()); }\n" +
 			"}\n"
 		},
 		null /*customOptions*/,
@@ -1047,26 +1047,25 @@ public void test_parameter_specification_inheritance_008() {
 	runNegativeTestWithLibs(
 		false, // don't flush
 		new String[] {
-			"X.java",
-			"public class X implements IX {\n" +
-			"    public void printObject(Object o) { System.out.print(o.toString()); }\n" +
+			"XSub.java",
+			"public class XSub extends X {\n" +
+			"    @Override\n" +
+			"    public void printObject(Object o) { super.printObject(o); }\n" +
 			"}\n",
 			"M.java",
 			"public class M{\n" +
-			"    void foo(IX x, Object o) {\n" +
+			"    void foo(X x, Object o) {\n" +
 			"        x.printObject(o);\n" +
 			"    }\n" +
 			"}\n"
 		},
 		options,
 		"----------\n" +
-		// additional error:
-		"1. ERROR in X.java (at line 2)\n" +
-		"	public void printObject(Object o) { System.out.print(o.toString()); }\n" +
-		"	                        ^^^^^^\n" +
-		"Missing non-null annotation: inherited method from IX declares this parameter as @NonNull\n" +
+		"1. ERROR in XSub.java (at line 3)\n" +
+		"	public void printObject(Object o) { super.printObject(o); }\n" +
+		"	                                                      ^\n" +
+		"Null type safety: The expression of type Object needs unchecked conversion to conform to \'@NonNull Object\'\n" +
 		"----------\n" +
-		// main error:
 		"----------\n" +
 		"1. ERROR in M.java (at line 3)\n" +
 		"	x.printObject(o);\n" +
@@ -1230,18 +1229,14 @@ public void test_parameter_specification_inheritance_013() {
 		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
 		"	       ^^^^^^^^^^^^^^^^\n" +
 		"The return type is incompatible with the @NonNull return from IY.getString(String, String, String)\n" +
+		// no problem regarding s1: widening @NonNull to unannotated
 		"----------\n" +
 		"2. ERROR in p1\\Y.java (at line 5)\n" +
 		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
-		"	                                  ^^^^^^\n" +
-		"Missing non-null annotation: inherited method from IY declares this parameter as @NonNull\n" +
-		"----------\n" +
-		"3. ERROR in p1\\Y.java (at line 5)\n" +
-		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
 		"	                                             ^^^^^^^^^^^^^^^\n" +
 		"Illegal redefinition of parameter s2, inherited method from X declares this parameter as @Nullable\n" +
 		"----------\n" +
-		"4. ERROR in p1\\Y.java (at line 5)\n" +
+		"3. ERROR in p1\\Y.java (at line 5)\n" +
 		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
 		"	                                                                 ^^^^^^^^^^^^^^^\n" +
 		"Illegal redefinition of parameter s3, inherited method from IY declares this parameter as @Nullable\n" +
@@ -1316,6 +1311,29 @@ public void test_parameter_specification_inheritance_014() {
 		"The method getString3(String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" +
 		"----------\n");
 }
+// a method relaxes the parameter null specification from @NonNull to un-annotated
+// see https://bugs.eclipse.org/381443
+public void test_parameter_specification_inheritance_015() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    void foo(@NonNull String s) { System.out.println(s); }\n" +
+			"}\n",
+			"XSub.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class XSub extends X {\n" +
+			"    public void foo(String s) { if (s != null) super.foo(s); }\n" +
+			"    void bar() { foo(null); }\n" +
+			"}\n"
+		},
+		"",
+	    this.LIBS,
+	    false/*shouldFlush*/,
+	    null/*vmArgs*/);
+}
+
 // a nullable return value is dereferenced without a check
 public void test_nullable_return_001() {
 	runNegativeTestWithLibs(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 98492a2..08b5d68 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -319,10 +319,9 @@ public class ImplicitNullAnnotationVerifier {
 					} else {
 						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
 					}
-				} else if (inheritedNonNullNess != null
+				} else if (inheritedNonNullNess == Boolean.FALSE // unannotated conflics only with inherited @Nullable
 							&& currentNonNullNess == null) 
 				{
-					// weak conflict (TODO reconsider this case)
 					if (currentArgument != null) {
 						scope.problemReporter().parameterLackingNullAnnotation(
 								currentArgument,
commit 0001b1dcd0c4e435d76a7a88b7548ff6832acf06
Author: Stephan Herrmann <stephan@cs.tu-berlin.de>
Date:   Sun Dec 2 20:06:50 2012 +0100

    Bug 381443 - [compiler][null] Allow parameter widening from @NonNull to
    unannotated

4	18	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
37	19	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 0912731..e2fd4e6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -25,6 +25,7 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 375366 - ECJ ignores unusedParameterIncludeDocCommentReference unless enableJavadoc option is set
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -12633,12 +12634,7 @@ public void test313_warn_options() {
 		"	                     ^^^^^^\n" + 
 		"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 		"----------\n" + 
-		"3. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" + 
-		"	@Nullable Object foo(Object o, Object o2) { return null; }\n" + 
-		"	                               ^^^^^^\n" + 
-		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" + 
-		"----------\n" + 
-		"3 problems (3 warnings)", 
+		"2 problems (2 warnings)", 
 		true);
 }
 
@@ -12682,12 +12678,7 @@ public void test314_warn_options() {
 		"	                     ^^^^^^\n" + 
 		"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 		"----------\n" + 
-		"3. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" + 
-		"	@Nullable Object foo(Object o, Object o2) { return null; }\n" + 
-		"	                               ^^^^^^\n" + 
-		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" + 
-		"----------\n" + 
-		"3 problems (3 errors)", 
+		"2 problems (2 errors)", 
 		true);
 }
 
@@ -13673,12 +13664,7 @@ public void testBug375366c() throws IOException {
 			"	                     ^^^^^^\n" + 
 			"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 			"----------\n" + 
-			"3. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" + 
-			"	@Nullable Object foo(Object o, Object o2) { return null; }\n" + 
-			"	                               ^^^^^^\n" + 
-			"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" + 
-			"----------\n" + 
-			"3 problems (3 errors)", 
+			"2 problems (2 errors)", 
 			false/*don't flush*/);
 }
 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 4997d50..fc2e484 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -920,10 +920,10 @@ public void test_parameter_specification_inheritance_008() {
 	options.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runConformTestWithLibs(
 		new String[] {
-			"IX.java",
+			"X.java",
 			"import org.eclipse.jdt.annotation.*;\n" +
-			"public interface IX {\n" +
-			"    void printObject(@NonNull Object o);\n" +
+			"public class X {\n" +
+			"    void printObject(@NonNull Object o) { System.out.print(o.toString()); }\n" +
 			"}\n"
 		},
 		null /*customOptions*/,
@@ -931,26 +931,25 @@ public void test_parameter_specification_inheritance_008() {
 	runNegativeTestWithLibs(
 		false, // don't flush
 		new String[] {
-			"X.java",
-			"public class X implements IX {\n" +
-			"    public void printObject(Object o) { System.out.print(o.toString()); }\n" +
+			"XSub.java",
+			"public class XSub extends X {\n" +
+			"    @Override\n" +
+			"    public void printObject(Object o) { super.printObject(o); }\n" +
 			"}\n",
 			"M.java",
 			"public class M{\n" +
-			"    void foo(IX x, Object o) {\n" +
+			"    void foo(X x, Object o) {\n" +
 			"        x.printObject(o);\n" +
 			"    }\n" +
 			"}\n"
 		},
 		options,
 		"----------\n" +
-		// additional error:
-		"1. ERROR in X.java (at line 2)\n" +
-		"	public void printObject(Object o) { System.out.print(o.toString()); }\n" +
-		"	                        ^^^^^^\n" +
-		"Missing non-null annotation: inherited method from IX declares this parameter as @NonNull\n" +
+		"1. ERROR in XSub.java (at line 3)\n" +
+		"	public void printObject(Object o) { super.printObject(o); }\n" +
+		"	                                                      ^\n" +
+		"Null type safety: The expression of type Object needs unchecked conversion to conform to \'@NonNull Object\'\n" +
 		"----------\n" +
-		// main error:
 		"----------\n" +
 		"1. ERROR in M.java (at line 3)\n" +
 		"	x.printObject(o);\n" +
@@ -1114,18 +1113,14 @@ public void test_parameter_specification_inheritance_013() {
 		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
 		"	       ^^^^^^^^^^^^^^^^\n" +
 		"The return type is incompatible with the @NonNull return from IY.getString(String, String, String)\n" +
+		// no problem regarding s1: widening @NonNull to unannotated
 		"----------\n" +
 		"2. ERROR in p1\\Y.java (at line 5)\n" +
 		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
-		"	                                  ^^^^^^\n" +
-		"Missing non-null annotation: inherited method from IY declares this parameter as @NonNull\n" +
-		"----------\n" +
-		"3. ERROR in p1\\Y.java (at line 5)\n" +
-		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
 		"	                                             ^^^^^^^^^^^^^^^\n" +
 		"Illegal redefinition of parameter s2, inherited method from X declares this parameter as @Nullable\n" +
 		"----------\n" +
-		"4. ERROR in p1\\Y.java (at line 5)\n" +
+		"3. ERROR in p1\\Y.java (at line 5)\n" +
 		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
 		"	                                                                 ^^^^^^^^^^^^^^^\n" +
 		"Illegal redefinition of parameter s3, inherited method from IY declares this parameter as @Nullable\n" +
@@ -1200,6 +1195,29 @@ public void test_parameter_specification_inheritance_014() {
 		"The method getString3(String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" +
 		"----------\n");
 }
+// a method relaxes the parameter null specification from @NonNull to un-annotated
+// see https://bugs.eclipse.org/381443
+public void test_parameter_specification_inheritance_015() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    void foo(@NonNull String s) { System.out.println(s); }\n" +
+			"}\n",
+			"XSub.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class XSub extends X {\n" +
+			"    public void foo(String s) { if (s != null) super.foo(s); }\n" +
+			"    void bar() { foo(null); }\n" +
+			"}\n"
+		},
+		"",
+	    this.LIBS,
+	    false/*shouldFlush*/,
+	    null/*vmArgs*/);
+}
+
 // a nullable return value is dereferenced without a check
 public void test_nullable_return_001() {
 	runNegativeTestWithLibs(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 908ad32..664455c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -319,10 +319,9 @@ public class ImplicitNullAnnotationVerifier {
 					} else {
 						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
 					}
-				} else if (inheritedNonNullNess != null
+				} else if (inheritedNonNullNess == Boolean.FALSE // unannotated conflics only with inherited @Nullable
 							&& currentNonNullNess == null) 
 				{
-					// weak conflict (TODO reconsider this case)
 					if (currentArgument != null) {
 						scope.problemReporter().parameterLackingNullAnnotation(
 								currentArgument,
commit 2ed80629ac2deb70ae8b8f65c52c0fee7ade8d07
Author: Stephan Herrmann <stephan@cs.tu-berlin.de>
Date:   Tue Jan 15 18:22:29 2013 +0100

    Bug 381443 - [compiler][null] Allow parameter widening from @NonNull to
    unannotated
    Part 2: re-introduce as configurable warning

70	5	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
97	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
4	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
10	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
5	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
14	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
23	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
27	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index c8ef83a..00ffdd7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1949,7 +1949,8 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noEffectAssignment\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion\" value=\"warning\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral\" value=\"ignore\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral\" value=\"ignore\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped\" value=\"warning\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict\" value=\"error\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullReference\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullSpecViolation\" value=\"error\"/>\n" + 
@@ -12629,13 +12630,18 @@ public void test313_warn_options() {
 		"	                     ^^^^^^\n" + 
 		"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 		"----------\n" + 
-		"2 problems (2 warnings)", 
+		"3. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" +
+		"	@Nullable Object foo(Object o, Object o2) { return null; }\n" +
+		"	                               ^^^^^^\n" +
+		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" +
+		"----------\n" +
+		"3 problems (3 warnings)", 
 		true);
 }
 
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=325342
 // -err option - regression tests to check option nullAnnot
-// Null warnings because of annotations, null spec violations configured as errors
+// Null warnings because of annotations, null spec violations plus one specific problem configured as errors
 public void test314_warn_options() {
 	this.runNegativeTest(
 		new String[] {
@@ -12660,7 +12666,7 @@ public void test314_warn_options() {
 		"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
 		+ " -sourcepath \"" + OUTPUT_DIR + "\""
 		+ " -1.5"
-		+ " -err:+nullAnnot -warn:-null -proc:none -d \"" + OUTPUT_DIR + "\"",
+		+ " -err:+nullAnnot -warn:-null -err:+nonnullNotRepeated -proc:none -d \"" + OUTPUT_DIR + "\"",
 		"",
 		"----------\n" + 
 		"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" + 
@@ -12673,7 +12679,12 @@ public void test314_warn_options() {
 		"	                     ^^^^^^\n" + 
 		"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 		"----------\n" + 
-		"2 problems (2 errors)", 
+		"3. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" +
+		"	@Nullable Object foo(Object o, Object o2) { return null; }\n" +
+		"	                               ^^^^^^\n" +
+		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" +
+		"----------\n" +
+		"3 problems (3 errors)", 
 		true);
 }
 
@@ -13659,6 +13670,60 @@ public void testBug375366c() throws IOException {
 			"	                     ^^^^^^\n" + 
 			"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 			"----------\n" + 
+			"3. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" +
+			"	@Nullable Object foo(Object o, Object o2) { return null; }\n" +
+			"	                               ^^^^^^\n" +
+			"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" +
+			"----------\n" +
+			"3 problems (2 errors, 1 warning)", 
+			false/*don't flush*/);
+}
+
+// Bug 375366 - ECJ ignores unusedParameterIncludeDocCommentReference unless enableJavadoc option is set
+// property file enables null annotation support, one optional warning disabled
+public void testBug375366d() throws IOException {
+	createOutputTestDirectory("regression/.settings");
+	Util.createFile(OUTPUT_DIR+"/.settings/org.eclipse.jdt.core.prefs",
+			"eclipse.preferences.version=1\n" + 
+			"org.eclipse.jdt.core.compiler.annotation.nullanalysis=enabled\n" +
+			"org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped=ignore\n");
+	this.runNegativeTest(
+			new String[] {
+					"p/X.java",
+					"package p;\n" +
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public class X {\n" +
+					"  @NonNull Object foo(@Nullable Object o, @NonNull Object o2) {\n" +
+					"	 return this;\n" +
+					"  }\n" +
+					"}\n" +
+					"class Y extends X {\n" +
+					"    @Nullable Object foo(Object o, Object o2) { return null; }\n" +
+					"}\n",
+					"org/eclipse/jdt/annotation/NonNull.java",
+					NONNULL_ANNOTATION_CONTENT,
+					"org/eclipse/jdt/annotation/Nullable.java",
+					NULLABLE_ANNOTATION_CONTENT,
+					"org/eclipse/jdt/annotation/NonNullByDefault.java",				
+					NONNULL_BY_DEFAULT_ANNOTATION_CONTENT
+			},
+			"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
+			+ " -sourcepath \"" + OUTPUT_DIR + "\""
+			+ " -1.5"
+			+ " -properties " + OUTPUT_DIR + File.separator +".settings" + File.separator + "org.eclipse.jdt.core.prefs "
+			+ " -d \"" + OUTPUT_DIR + "\"",
+			"",
+			"----------\n" +
+			"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" +
+			"	@Nullable Object foo(Object o, Object o2) { return null; }\n" +
+			"	^^^^^^^^^^^^^^^^\n" +
+			"The return type is incompatible with the @NonNull return from X.foo(Object, Object)\n" +
+			"----------\n" +
+			"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" +
+			"	@Nullable Object foo(Object o, Object o2) { return null; }\n" +
+			"	                     ^^^^^^\n" +
+			"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" +
+			"----------\n" +
 			"2 problems (2 errors)", 
 			false/*don't flush*/);
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 0906794..a1ec935 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -16,6 +16,7 @@
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -1472,7 +1473,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("PackageCollidesWithType", SKIP);
 		expectedProblemAttributes.put("PackageIsNotExpectedPackage", SKIP);
 		expectedProblemAttributes.put("ParameterAssignment", new ProblemAttributes(JavaCore.COMPILER_PB_PARAMETER_ASSIGNMENT));
-		expectedProblemAttributes.put("ParameterLackingNonNullAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("ParameterLackingNonNullAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED));
 		expectedProblemAttributes.put("ParameterLackingNullableAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("ParameterMismatch", SKIP);
 		expectedProblemAttributes.put("ParameterizedConstructorArgumentTypeMismatch", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index c904e2a..4c83c85 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -53,7 +53,7 @@ public NullAnnotationTest(String name) {
 // Static initializer to specify tests subset using TESTS_* static variables
 // All specified tests which do not belong to the class are skipped...
 static {
-//		TESTS_NAMES = new String[] { "testBug388281_09" };
+//		TESTS_NAMES = new String[] { "test_parameter_specification_inheritance_01" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -1061,7 +1061,12 @@ public void test_parameter_specification_inheritance_008() {
 		},
 		options,
 		"----------\n" +
-		"1. ERROR in XSub.java (at line 3)\n" +
+		"1. WARNING in XSub.java (at line 3)\n" + 
+		"	public void printObject(Object o) { super.printObject(o); }\n" + 
+		"	                        ^^^^^^\n" + 
+		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in XSub.java (at line 3)\n" +
 		"	public void printObject(Object o) { super.printObject(o); }\n" +
 		"	                                                      ^\n" +
 		"Null type safety: The expression of type Object needs unchecked conversion to conform to \'@NonNull Object\'\n" +
@@ -1197,6 +1202,7 @@ public void test_parameter_specification_inheritance_012() {
 public void test_parameter_specification_inheritance_013() {
 	Map customOptions = getCompilerOptions();
 	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED, JavaCore.IGNORE);
 	runNegativeTestWithLibs(
 		new String[] {
 	"p1/X.java",
@@ -1334,6 +1340,95 @@ public void test_parameter_specification_inheritance_015() {
 	    null/*vmArgs*/);
 }
 
+// a method relaxes the parameter null specification from @NonNull to un-annotated
+// see https://bugs.eclipse.org/381443
+// issue configured as error
+public void test_parameter_specification_inheritance_016() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    void foo(@NonNull String s) { System.out.println(s); }\n" +
+			"}\n",
+			"XSub.java",
+			"public class XSub extends X {\n" +
+			"    @Override\n" +
+			"    public void foo(String s) { if (s != null) super.foo(s); }\n" +
+			"    void bar() { foo(null); }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" +
+		"1. ERROR in XSub.java (at line 3)\n" +
+		"	public void foo(String s) { if (s != null) super.foo(s); }\n" +
+		"	                ^^^^^^\n" +
+		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" +
+		"----------\n");
+}
+
+// a class inherits two methods with different spec: one non-null param & one unannotated param
+// widening reported as warning by default
+// see https://bugs.eclipse.org/381443
+public void test_parameter_specification_inheritance_017() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    public void foo(String s) { System.out.println(s); }\n" +
+			"}\n",
+			"IX.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public interface IX {\n" +
+			"    void foo(@NonNull String s);\n" +
+			"}\n",
+			"XSub.java",
+			"public class XSub extends X implements IX {\n" +
+			"    void bar() { foo(null); }\n" +
+			"    static void zork(XSub sub) {\n" +
+			"        sub.foo(null);\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in XSub.java (at line 1)\n" + 
+		"	public class XSub extends X implements IX {\n" + 
+		"	             ^^^^\n" + 
+		"Missing non-null annotation: inherited method from IX declares this parameter as @NonNull\n" + 
+		"----------\n");
+}
+
+// a class inherits two methods with different spec: one non-null param & one unannotated param
+// opt to accept this widening
+// see https://bugs.eclipse.org/381443
+public void test_parameter_specification_inheritance_018() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED, JavaCore.IGNORE);
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    public void foo(String s) { System.out.println(s); }\n" +
+			"}\n",
+			"IX.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public interface IX {\n" +
+			"    void foo(@NonNull String s);\n" +
+			"}\n",
+			"XSub.java",
+			"public class XSub extends X implements IX {\n" +
+			"    void bar() { foo(null); }\n" +
+			"    static void zork(XSub sub) {\n" +
+			"        sub.foo(null);\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"");
+}
+
 // a nullable return value is dereferenced without a check
 public void test_nullable_return_001() {
 	runNegativeTestWithLibs(
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index bc2fc55..333739c 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -18,6 +18,7 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 375366 - ECJ ignores unusedParameterIncludeDocCommentReference unless enableJavadoc option is set
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.batch;
 
@@ -3686,6 +3687,9 @@ private void handleErrorOrWarningToken(String token, boolean isEnabling, int sev
 			} else if (token.equals("nullUncheckedConversion")) { //$NON-NLS-1$
 				setSeverity(CompilerOptions.OPTION_ReportNullUncheckedConversion, severity, isEnabling);
 				return;
+			} else if (token.equals("nonnullNotRepeated")) { //$NON-NLS-1$
+				setSeverity(CompilerOptions.OPTION_ReportNonnullParameterAnnotationDropped, severity, isEnabling);
+				return;
 			}
 			
 			break;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 911c5e2..8448f06 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -17,6 +17,7 @@
  *								bug 366063 - Compiler should not add synthetic @NonNull annotations
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.impl;
 
@@ -164,6 +165,7 @@ public class CompilerOptions {
 	static final char[][] DEFAULT_NONNULLBYDEFAULT_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNullByDefault".toCharArray()); //$NON-NLS-1$
 	public static final String OPTION_ReportMissingNonNullByDefaultAnnotation = "org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation";  //$NON-NLS-1$
 	public static final String OPTION_InheritNullAnnotations = "org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations";  //$NON-NLS-1$
+	public static final String OPTION_ReportNonnullParameterAnnotationDropped = "org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped";  //$NON-NLS-1$
 	/**
 	 * Possible values for configurable options
 	 */
@@ -277,6 +279,7 @@ public class CompilerOptions {
 	public static final int MissingNonNullByDefaultAnnotation = IrritantSet.GROUP2 | ASTNode.Bit15;
 	public static final int MissingDefaultCase = IrritantSet.GROUP2 | ASTNode.Bit16;
 	public static final int UnusedTypeParameter = IrritantSet.GROUP2 | ASTNode.Bit17;
+	public static final int NonnullParameterAnnotationDropped = IrritantSet.GROUP2 | ASTNode.Bit18;
 
 	// Severity level for handlers
 	/** 
@@ -641,6 +644,8 @@ public class CompilerOptions {
 				return OPTION_ReportNullUncheckedConversion;
 			case RedundantNullAnnotation :
 				return OPTION_ReportRedundantNullAnnotation;
+			case NonnullParameterAnnotationDropped:
+				return OPTION_ReportNonnullParameterAnnotationDropped;
 		}
 		return null;
 	}
@@ -819,7 +824,8 @@ public class CompilerOptions {
 			OPTION_ReportNullUncheckedConversion,
 			OPTION_ReportRedundantNullAnnotation,
 			OPTION_ReportUnusedTypeParameter,
-			OPTION_InheritNullAnnotations
+			OPTION_InheritNullAnnotations,
+			OPTION_ReportNonnullParameterAnnotationDropped
 		};
 		return result;
 	}
@@ -889,6 +895,7 @@ public class CompilerOptions {
 			case NullUncheckedConversion :
 			case RedundantNullAnnotation :
 			case MissingNonNullByDefaultAnnotation:
+			case NonnullParameterAnnotationDropped:
 				return "null"; //$NON-NLS-1$
 			case FallthroughCase :
 				return "fallthrough"; //$NON-NLS-1$
@@ -1118,6 +1125,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportMissingNonNullByDefaultAnnotation, getSeverityString(MissingNonNullByDefaultAnnotation));
 		optionsMap.put(OPTION_ReportUnusedTypeParameter, getSeverityString(UnusedTypeParameter));
 		optionsMap.put(OPTION_InheritNullAnnotations, this.inheritNullAnnotations ? ENABLED : DISABLED);
+		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
 		return optionsMap;
 	}
 
@@ -1610,6 +1618,7 @@ public class CompilerOptions {
 			if ((optionValue = optionsMap.get(OPTION_InheritNullAnnotations)) != null) {
 				this.inheritNullAnnotations = ENABLED.equals(optionValue);
 			}
+			if ((optionValue = optionsMap.get(OPTION_ReportNonnullParameterAnnotationDropped)) != null) updateSeverity(NonnullParameterAnnotationDropped, optionValue);
 		}
 
 		// Javadoc options
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index 9d04d4d..fc8c9b1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -13,6 +13,7 @@
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *								bug 265744 - Enum switch should warn about missing default
  *								bug 374605 - Unreasonable warning for enum-based switch statements
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.impl;
@@ -111,7 +112,8 @@ public class IrritantSet {
 				|CompilerOptions.Tasks
 				|CompilerOptions.UnclosedCloseable
 				|CompilerOptions.NullUncheckedConversion
-				|CompilerOptions.RedundantNullAnnotation);
+				|CompilerOptions.RedundantNullAnnotation
+				|CompilerOptions.NonnullParameterAnnotationDropped);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
 		COMPILER_DEFAULT_ERRORS.set(
 				CompilerOptions.NullSpecViolation
@@ -128,7 +130,8 @@ public class IrritantSet {
 			.set(CompilerOptions.NullSpecViolation)
 			.set(CompilerOptions.NullAnnotationInferenceConflict)
 			.set(CompilerOptions.NullUncheckedConversion)
-			.set(CompilerOptions.RedundantNullAnnotation);
+			.set(CompilerOptions.RedundantNullAnnotation)
+			.set(CompilerOptions.NonnullParameterAnnotationDropped);
 
 		RESTRICTION.set(CompilerOptions.DiscouragedReference);
 		STATIC_ACCESS.set(CompilerOptions.NonStaticAccessToStatic);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 08b5d68..1eced52 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -299,10 +299,8 @@ public class ImplicitNullAnnotationVerifier {
 				}
 			}
 			if (shouldComplain) {
-				boolean needNonNull = false;
 				char[][] annotationName;
 				if (inheritedNonNullNess == Boolean.TRUE) {
-					needNonNull = true;
 					annotationName = environment.getNonNullAnnotationName();
 				} else {
 					annotationName = environment.getNullableAnnotationName();
@@ -319,17 +317,24 @@ public class ImplicitNullAnnotationVerifier {
 					} else {
 						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
 					}
-				} else if (inheritedNonNullNess == Boolean.FALSE // unannotated conflics only with inherited @Nullable
-							&& currentNonNullNess == null) 
+				} else if (currentNonNullNess == null) 
 				{
-					if (currentArgument != null) {
-						scope.problemReporter().parameterLackingNullAnnotation(
+					// unannotated strictly conflicts only with inherited @Nullable
+					if (inheritedNonNullNess == Boolean.FALSE) { 
+						if (currentArgument != null) {
+							scope.problemReporter().parameterLackingNullableAnnotation(
+									currentArgument,
+									inheritedMethod.declaringClass,
+									annotationName);
+						} else {
+							scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
+						}
+					} else if (inheritedNonNullNess == Boolean.TRUE) {
+						// not strictly a conflict, but a configurable warning is given anyway:
+						scope.problemReporter().parameterLackingNonnullAnnotation(
 								currentArgument,
 								inheritedMethod.declaringClass,
-								needNonNull,
 								annotationName);
-					} else {
-						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
 					}
 				}
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 3b69110..ea6c187 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -20,6 +20,7 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 376053 - [compiler][resource] Strange potential resource leak problems
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
@@ -317,13 +318,15 @@ public static int getIrritant(int problemID) {
 		case IProblem.IllegalReturnNullityRedefinition:
 		case IProblem.IllegalRedefinitionToNonNullParameter:
 		case IProblem.IllegalDefinitionToNonNullParameter:
-		case IProblem.ParameterLackingNonNullAnnotation:
 		case IProblem.ParameterLackingNullableAnnotation:
 		case IProblem.CannotImplementIncompatibleNullness:
 		case IProblem.ConflictingNullAnnotations:
 		case IProblem.ConflictingInheritedNullAnnotations:
 			return CompilerOptions.NullSpecViolation;
 
+		case IProblem.ParameterLackingNonNullAnnotation:
+			return CompilerOptions.NonnullParameterAnnotationDropped;
+
 		case IProblem.RequiredNonNullButProvidedPotentialNull:
 			return CompilerOptions.NullAnnotationInferenceConflict;
 		case IProblem.RequiredNonNullButProvidedUnknown:
@@ -598,6 +601,7 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.NullAnnotationInferenceConflict :
 			case CompilerOptions.NullUncheckedConversion :
 			case CompilerOptions.MissingNonNullByDefaultAnnotation:
+			case CompilerOptions.NonnullParameterAnnotationDropped:
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			case CompilerOptions.RedundantNullAnnotation :
 				return CategorizedProblem.CAT_UNNECESSARY_CODE;
@@ -8314,14 +8318,30 @@ public void illegalRedefinitionToNonNullParameter(Argument argument, ReferenceBi
 			argument.type.sourceEnd);
 	}
 }
-public void parameterLackingNullAnnotation(Argument argument, ReferenceBinding declaringClass, boolean needNonNull, char[][] inheritedAnnotationName) {
+public void parameterLackingNullableAnnotation(Argument argument, ReferenceBinding declaringClass, char[][] inheritedAnnotationName) {
 	this.handle(
-		needNonNull ? IProblem.ParameterLackingNonNullAnnotation : IProblem.ParameterLackingNullableAnnotation, 
+		IProblem.ParameterLackingNullableAnnotation, 
 		new String[] { new String(argument.name), new String(declaringClass.readableName()), CharOperation.toString(inheritedAnnotationName)},
 		new String[] { new String(argument.name), new String(declaringClass.shortReadableName()), new String(inheritedAnnotationName[inheritedAnnotationName.length-1])},
 		argument.type.sourceStart,
 		argument.type.sourceEnd);
 }
+public void parameterLackingNonnullAnnotation(Argument argument, ReferenceBinding declaringClass, char[][] inheritedAnnotationName) {
+	int sourceStart = 0, sourceEnd = 0;
+	if (argument != null) {
+		sourceStart = argument.type.sourceStart;
+		sourceEnd = argument.type.sourceEnd;
+	} else if (this.referenceContext instanceof TypeDeclaration) {
+		sourceStart = ((TypeDeclaration) this.referenceContext).sourceStart;
+		sourceEnd =   ((TypeDeclaration) this.referenceContext).sourceEnd;
+	}
+	this.handle(
+		IProblem.ParameterLackingNonNullAnnotation, 
+		new String[] { new String(declaringClass.readableName()), CharOperation.toString(inheritedAnnotationName)},
+		new String[] { new String(declaringClass.shortReadableName()), new String(inheritedAnnotationName[inheritedAnnotationName.length-1])},
+		sourceStart,
+		sourceEnd);
+}
 public void illegalReturnRedefinition(AbstractMethodDeclaration abstractMethodDecl, MethodBinding inheritedMethod, char[][] nonNullAnnotationName) {
 	MethodDeclaration methodDecl = (MethodDeclaration) abstractMethodDecl;
 	StringBuffer methodSignature = new StringBuffer();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 1e19afc..2d41098 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -17,6 +17,7 @@
 #							bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
 #							bug 374605 - Unreasonable warning for enum-based switch statements
 #							bug 388281 - [compiler][null] inheritance of null annotations as an option
+#							bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
 ###############################################################################
 0 = {0}
 1 = super cannot be used in java.lang.Object
@@ -679,7 +680,7 @@
 914 = The return type is incompatible with the @{1} return from {0}
 915 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as @{2}
 916 = Illegal redefinition of parameter {0}, inherited method from {1} does not constrain this parameter
-917 = Missing non-null annotation: inherited method from {1} declares this parameter as @{2}
+917 = Missing non-null annotation: inherited method from {0} declares this parameter as @{1}
 918 = Missing nullable annotation: inherited method from {1} declares this parameter as @{2}
 919 = Potential null pointer access: The method {0} may return null
 920 = Redundant null check: The method {0} cannot return null
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index c88a835..fb96c44 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -96,6 +96,7 @@
  *									COMPILER_PB_MISSING_ENUM_CASE_DESPITE_DEFAULT
  *									COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE
  *									COMPILER_INHERIT_NULL_ANNOTATIONS
+ *									COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED
  *******************************************************************************/
 
 package org.eclipse.jdt.core;
@@ -1707,6 +1708,32 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_INHERIT_NULL_ANNOTATIONS = JavaCore.PLUGIN_ID+".compiler.annotation.inheritNullAnnotations"; //$NON-NLS-1$
 	/**
+	 * Compiler option ID: Reporting Dropped Nonnull Parameter Annotations.
+	 * <p>When enabled, the compiler will issue an error or a warning against a parameter of 
+	 *    a method that overrides an inherited method
+	 *    if all of the following hold:</p>
+	 * <ul>
+	 *    <li>The overridden method declares the corresponding parameter as non-null (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</li>
+	 *    <li>The parameter in the overriding method has no null annotation.</li>
+	 *    <li>The overriding method is not affected by a nullness default (see {@link #COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME}).</li>
+	 *    <li>Inheritance of null annotations is disabled (see {@link #COMPILER_INHERIT_NULL_ANNOTATIONS}).</li>
+	 * </ul>
+	 * <p>This particular situation bears the same inherent risk as any unannotated method parameter,
+	 *    because the compiler's null ananysis cannot decide wither <code>null</code> is or is not a legal value for this parameter.
+	 *    However, the annotation in the overridden method <em>suggests</em> that the parameter should also be annotated as non-null.
+	 *    If that is not intended or possible, it is recommended to annotate the parameter as nullable,
+	 *    in order to make this (legal) change of contract explicit.</p>   
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 * @since 3.9
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED = JavaCore.PLUGIN_ID+".compiler.problem.nonnullParameterAnnotationDropped"; //$NON-NLS-1$
+
+	/**
 	 * Compiler option ID: Setting Source Compatibility Mode.
 	 * <p>Specify whether which source level compatibility is used. From 1.4 on, <code>'assert'</code> is a keyword
 	 *    reserved for assertion support. Also note, than when toggling to 1.4 mode, the target VM
commit f350c3be6ae3f45b0550d20e4f84512419a218a0
Author: Stephan Herrmann <stephan@cs.tu-berlin.de>
Date:   Tue Feb 5 15:19:43 2013 +0530

    Bug 381443 - [compiler][null] Allow parameter widening from @NonNull to
    unannotated
    Part 2: re-introduce as configurable warning

70	5	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
3	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
97	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
4	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
10	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
5	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
14	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
23	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
27	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index e2fd4e6..14862e3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1954,7 +1954,8 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noEffectAssignment\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion\" value=\"warning\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral\" value=\"ignore\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral\" value=\"ignore\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped\" value=\"warning\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict\" value=\"error\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullReference\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullSpecViolation\" value=\"error\"/>\n" + 
@@ -12634,13 +12635,18 @@ public void test313_warn_options() {
 		"	                     ^^^^^^\n" + 
 		"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 		"----------\n" + 
-		"2 problems (2 warnings)", 
+		"3. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" +
+		"	@Nullable Object foo(Object o, Object o2) { return null; }\n" +
+		"	                               ^^^^^^\n" +
+		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" +
+		"----------\n" +
+		"3 problems (3 warnings)", 
 		true);
 }
 
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=325342
 // -err option - regression tests to check option nullAnnot
-// Null warnings because of annotations, null spec violations configured as errors
+// Null warnings because of annotations, null spec violations plus one specific problem configured as errors
 public void test314_warn_options() {
 	this.runNegativeTest(
 		new String[] {
@@ -12665,7 +12671,7 @@ public void test314_warn_options() {
 		"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
 		+ " -sourcepath \"" + OUTPUT_DIR + "\""
 		+ " -1.5"
-		+ " -err:+nullAnnot -warn:-null -proc:none -d \"" + OUTPUT_DIR + "\"",
+		+ " -err:+nullAnnot -warn:-null -err:+nonnullNotRepeated -proc:none -d \"" + OUTPUT_DIR + "\"",
 		"",
 		"----------\n" + 
 		"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" + 
@@ -12678,7 +12684,12 @@ public void test314_warn_options() {
 		"	                     ^^^^^^\n" + 
 		"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 		"----------\n" + 
-		"2 problems (2 errors)", 
+		"3. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" +
+		"	@Nullable Object foo(Object o, Object o2) { return null; }\n" +
+		"	                               ^^^^^^\n" +
+		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" +
+		"----------\n" +
+		"3 problems (3 errors)", 
 		true);
 }
 
@@ -13664,6 +13675,60 @@ public void testBug375366c() throws IOException {
 			"	                     ^^^^^^\n" + 
 			"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" + 
 			"----------\n" + 
+			"3. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" +
+			"	@Nullable Object foo(Object o, Object o2) { return null; }\n" +
+			"	                               ^^^^^^\n" +
+			"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" +
+			"----------\n" +
+			"3 problems (2 errors, 1 warning)", 
+			false/*don't flush*/);
+}
+
+// Bug 375366 - ECJ ignores unusedParameterIncludeDocCommentReference unless enableJavadoc option is set
+// property file enables null annotation support, one optional warning disabled
+public void testBug375366d() throws IOException {
+	createOutputTestDirectory("regression/.settings");
+	Util.createFile(OUTPUT_DIR+"/.settings/org.eclipse.jdt.core.prefs",
+			"eclipse.preferences.version=1\n" + 
+			"org.eclipse.jdt.core.compiler.annotation.nullanalysis=enabled\n" +
+			"org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped=ignore\n");
+	this.runNegativeTest(
+			new String[] {
+					"p/X.java",
+					"package p;\n" +
+					"import org.eclipse.jdt.annotation.*;\n" +
+					"public class X {\n" +
+					"  @NonNull Object foo(@Nullable Object o, @NonNull Object o2) {\n" +
+					"	 return this;\n" +
+					"  }\n" +
+					"}\n" +
+					"class Y extends X {\n" +
+					"    @Nullable Object foo(Object o, Object o2) { return null; }\n" +
+					"}\n",
+					"org/eclipse/jdt/annotation/NonNull.java",
+					NONNULL_ANNOTATION_CONTENT,
+					"org/eclipse/jdt/annotation/Nullable.java",
+					NULLABLE_ANNOTATION_CONTENT,
+					"org/eclipse/jdt/annotation/NonNullByDefault.java",				
+					NONNULL_BY_DEFAULT_ANNOTATION_CONTENT
+			},
+			"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
+			+ " -sourcepath \"" + OUTPUT_DIR + "\""
+			+ " -1.5"
+			+ " -properties " + OUTPUT_DIR + File.separator +".settings" + File.separator + "org.eclipse.jdt.core.prefs "
+			+ " -d \"" + OUTPUT_DIR + "\"",
+			"",
+			"----------\n" +
+			"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" +
+			"	@Nullable Object foo(Object o, Object o2) { return null; }\n" +
+			"	^^^^^^^^^^^^^^^^\n" +
+			"The return type is incompatible with the @NonNull return from X.foo(Object, Object)\n" +
+			"----------\n" +
+			"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" +
+			"	@Nullable Object foo(Object o, Object o2) { return null; }\n" +
+			"	                     ^^^^^^\n" +
+			"Missing nullable annotation: inherited method from X declares this parameter as @Nullable\n" +
+			"----------\n" +
 			"2 problems (2 errors)", 
 			false/*don't flush*/);
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 0313a24..051ce74 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -22,10 +22,11 @@
  *								bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
  *								bug 382347 - [1.8][compiler] Compiler accepts incorrect default method inheritance
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *     Jesper S Moller - Contributions for
  *								bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
-*******************************************************************************/
+ *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
 import java.lang.reflect.Field;
@@ -1537,7 +1538,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("PackageCollidesWithType", SKIP);
 		expectedProblemAttributes.put("PackageIsNotExpectedPackage", SKIP);
 		expectedProblemAttributes.put("ParameterAssignment", new ProblemAttributes(JavaCore.COMPILER_PB_PARAMETER_ASSIGNMENT));
-		expectedProblemAttributes.put("ParameterLackingNonNullAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("ParameterLackingNonNullAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED));
 		expectedProblemAttributes.put("ParameterLackingNullableAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("ParameterMismatch", SKIP);
 		expectedProblemAttributes.put("ParameterizedConstructorArgumentTypeMismatch", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index fc2e484..cf675ea 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -28,7 +28,7 @@ public NullAnnotationTest(String name) {
 // Static initializer to specify tests subset using TESTS_* static variables
 // All specified tests which do not belong to the class are skipped...
 static {
-//		TESTS_NAMES = new String[] { "testBug388281_09" };
+//		TESTS_NAMES = new String[] { "test_parameter_specification_inheritance_01" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -945,7 +945,12 @@ public void test_parameter_specification_inheritance_008() {
 		},
 		options,
 		"----------\n" +
-		"1. ERROR in XSub.java (at line 3)\n" +
+		"1. WARNING in XSub.java (at line 3)\n" + 
+		"	public void printObject(Object o) { super.printObject(o); }\n" + 
+		"	                        ^^^^^^\n" + 
+		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" + 
+		"----------\n" + 
+		"2. ERROR in XSub.java (at line 3)\n" +
 		"	public void printObject(Object o) { super.printObject(o); }\n" +
 		"	                                                      ^\n" +
 		"Null type safety: The expression of type Object needs unchecked conversion to conform to \'@NonNull Object\'\n" +
@@ -1081,6 +1086,7 @@ public void test_parameter_specification_inheritance_012() {
 public void test_parameter_specification_inheritance_013() {
 	Map customOptions = getCompilerOptions();
 	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED, JavaCore.IGNORE);
 	runNegativeTestWithLibs(
 		new String[] {
 	"p1/X.java",
@@ -1218,6 +1224,95 @@ public void test_parameter_specification_inheritance_015() {
 	    null/*vmArgs*/);
 }
 
+// a method relaxes the parameter null specification from @NonNull to un-annotated
+// see https://bugs.eclipse.org/381443
+// issue configured as error
+public void test_parameter_specification_inheritance_016() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    void foo(@NonNull String s) { System.out.println(s); }\n" +
+			"}\n",
+			"XSub.java",
+			"public class XSub extends X {\n" +
+			"    @Override\n" +
+			"    public void foo(String s) { if (s != null) super.foo(s); }\n" +
+			"    void bar() { foo(null); }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" +
+		"1. ERROR in XSub.java (at line 3)\n" +
+		"	public void foo(String s) { if (s != null) super.foo(s); }\n" +
+		"	                ^^^^^^\n" +
+		"Missing non-null annotation: inherited method from X declares this parameter as @NonNull\n" +
+		"----------\n");
+}
+
+// a class inherits two methods with different spec: one non-null param & one unannotated param
+// widening reported as warning by default
+// see https://bugs.eclipse.org/381443
+public void test_parameter_specification_inheritance_017() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    public void foo(String s) { System.out.println(s); }\n" +
+			"}\n",
+			"IX.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public interface IX {\n" +
+			"    void foo(@NonNull String s);\n" +
+			"}\n",
+			"XSub.java",
+			"public class XSub extends X implements IX {\n" +
+			"    void bar() { foo(null); }\n" +
+			"    static void zork(XSub sub) {\n" +
+			"        sub.foo(null);\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in XSub.java (at line 1)\n" + 
+		"	public class XSub extends X implements IX {\n" + 
+		"	             ^^^^\n" + 
+		"Missing non-null annotation: inherited method from IX declares this parameter as @NonNull\n" + 
+		"----------\n");
+}
+
+// a class inherits two methods with different spec: one non-null param & one unannotated param
+// opt to accept this widening
+// see https://bugs.eclipse.org/381443
+public void test_parameter_specification_inheritance_018() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED, JavaCore.IGNORE);
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    public void foo(String s) { System.out.println(s); }\n" +
+			"}\n",
+			"IX.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public interface IX {\n" +
+			"    void foo(@NonNull String s);\n" +
+			"}\n",
+			"XSub.java",
+			"public class XSub extends X implements IX {\n" +
+			"    void bar() { foo(null); }\n" +
+			"    static void zork(XSub sub) {\n" +
+			"        sub.foo(null);\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"");
+}
+
 // a nullable return value is dereferenced without a check
 public void test_nullable_return_001() {
 	runNegativeTestWithLibs(
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 6eaabdc..18e6620 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -22,6 +22,7 @@
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 375366 - ECJ ignores unusedParameterIncludeDocCommentReference unless enableJavadoc option is set
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.batch;
 
@@ -3705,6 +3706,9 @@ private void handleErrorOrWarningToken(String token, boolean isEnabling, int sev
 			} else if (token.equals("nullUncheckedConversion")) { //$NON-NLS-1$
 				setSeverity(CompilerOptions.OPTION_ReportNullUncheckedConversion, severity, isEnabling);
 				return;
+			} else if (token.equals("nonnullNotRepeated")) { //$NON-NLS-1$
+				setSeverity(CompilerOptions.OPTION_ReportNonnullParameterAnnotationDropped, severity, isEnabling);
+				return;
 			}
 			
 			break;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 754a1e5..7ed6c27 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -21,6 +21,7 @@
  *								bug 366063 - Compiler should not add synthetic @NonNull annotations
  *								bug 374605 - Unreasonable warning for enum-based switch statements
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.impl;
 
@@ -168,6 +169,7 @@ public class CompilerOptions {
 	static final char[][] DEFAULT_NONNULLBYDEFAULT_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNullByDefault".toCharArray()); //$NON-NLS-1$
 	public static final String OPTION_ReportMissingNonNullByDefaultAnnotation = "org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation";  //$NON-NLS-1$
 	public static final String OPTION_InheritNullAnnotations = "org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations";  //$NON-NLS-1$
+	public static final String OPTION_ReportNonnullParameterAnnotationDropped = "org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped";  //$NON-NLS-1$
 	/**
 	 * Possible values for configurable options
 	 */
@@ -282,6 +284,7 @@ public class CompilerOptions {
 	public static final int MissingNonNullByDefaultAnnotation = IrritantSet.GROUP2 | ASTNode.Bit15;
 	public static final int MissingDefaultCase = IrritantSet.GROUP2 | ASTNode.Bit16;
 	public static final int UnusedTypeParameter = IrritantSet.GROUP2 | ASTNode.Bit17;
+	public static final int NonnullParameterAnnotationDropped = IrritantSet.GROUP2 | ASTNode.Bit18;
 
 	// Severity level for handlers
 	/** 
@@ -646,6 +649,8 @@ public class CompilerOptions {
 				return OPTION_ReportNullUncheckedConversion;
 			case RedundantNullAnnotation :
 				return OPTION_ReportRedundantNullAnnotation;
+			case NonnullParameterAnnotationDropped:
+				return OPTION_ReportNonnullParameterAnnotationDropped;
 		}
 		return null;
 	}
@@ -830,7 +835,8 @@ public class CompilerOptions {
 			OPTION_ReportNullUncheckedConversion,
 			OPTION_ReportRedundantNullAnnotation,
 			OPTION_ReportUnusedTypeParameter,
-			OPTION_InheritNullAnnotations
+			OPTION_InheritNullAnnotations,
+			OPTION_ReportNonnullParameterAnnotationDropped
 		};
 		return result;
 	}
@@ -900,6 +906,7 @@ public class CompilerOptions {
 			case NullUncheckedConversion :
 			case RedundantNullAnnotation :
 			case MissingNonNullByDefaultAnnotation:
+			case NonnullParameterAnnotationDropped:
 				return "null"; //$NON-NLS-1$
 			case FallthroughCase :
 				return "fallthrough"; //$NON-NLS-1$
@@ -1129,6 +1136,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportMissingNonNullByDefaultAnnotation, getSeverityString(MissingNonNullByDefaultAnnotation));
 		optionsMap.put(OPTION_ReportUnusedTypeParameter, getSeverityString(UnusedTypeParameter));
 		optionsMap.put(OPTION_InheritNullAnnotations, this.inheritNullAnnotations ? ENABLED : DISABLED);
+		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
 		return optionsMap;
 	}
 
@@ -1621,6 +1629,7 @@ public class CompilerOptions {
 			if ((optionValue = optionsMap.get(OPTION_InheritNullAnnotations)) != null) {
 				this.inheritNullAnnotations = ENABLED.equals(optionValue);
 			}
+			if ((optionValue = optionsMap.get(OPTION_ReportNonnullParameterAnnotationDropped)) != null) updateSeverity(NonnullParameterAnnotationDropped, optionValue);
 		}
 
 		// Javadoc options
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index 9d04d4d..fc8c9b1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -13,6 +13,7 @@
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *								bug 265744 - Enum switch should warn about missing default
  *								bug 374605 - Unreasonable warning for enum-based switch statements
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.impl;
@@ -111,7 +112,8 @@ public class IrritantSet {
 				|CompilerOptions.Tasks
 				|CompilerOptions.UnclosedCloseable
 				|CompilerOptions.NullUncheckedConversion
-				|CompilerOptions.RedundantNullAnnotation);
+				|CompilerOptions.RedundantNullAnnotation
+				|CompilerOptions.NonnullParameterAnnotationDropped);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
 		COMPILER_DEFAULT_ERRORS.set(
 				CompilerOptions.NullSpecViolation
@@ -128,7 +130,8 @@ public class IrritantSet {
 			.set(CompilerOptions.NullSpecViolation)
 			.set(CompilerOptions.NullAnnotationInferenceConflict)
 			.set(CompilerOptions.NullUncheckedConversion)
-			.set(CompilerOptions.RedundantNullAnnotation);
+			.set(CompilerOptions.RedundantNullAnnotation)
+			.set(CompilerOptions.NonnullParameterAnnotationDropped);
 
 		RESTRICTION.set(CompilerOptions.DiscouragedReference);
 		STATIC_ACCESS.set(CompilerOptions.NonStaticAccessToStatic);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 2447ede..ca73e47 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -299,10 +299,8 @@ public class ImplicitNullAnnotationVerifier {
 				}
 			}
 			if (shouldComplain) {
-				boolean needNonNull = false;
 				char[][] annotationName;
 				if (inheritedNonNullNess == Boolean.TRUE) {
-					needNonNull = true;
 					annotationName = environment.getNonNullAnnotationName();
 				} else {
 					annotationName = environment.getNullableAnnotationName();
@@ -319,17 +317,24 @@ public class ImplicitNullAnnotationVerifier {
 					} else {
 						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
 					}
-				} else if (inheritedNonNullNess == Boolean.FALSE // unannotated conflics only with inherited @Nullable
-							&& currentNonNullNess == null) 
+				} else if (currentNonNullNess == null) 
 				{
-					if (currentArgument != null) {
-						scope.problemReporter().parameterLackingNullAnnotation(
+					// unannotated strictly conflicts only with inherited @Nullable
+					if (inheritedNonNullNess == Boolean.FALSE) { 
+						if (currentArgument != null) {
+							scope.problemReporter().parameterLackingNullableAnnotation(
+									currentArgument,
+									inheritedMethod.declaringClass,
+									annotationName);
+						} else {
+							scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
+						}
+					} else if (inheritedNonNullNess == Boolean.TRUE) {
+						// not strictly a conflict, but a configurable warning is given anyway:
+						scope.problemReporter().parameterLackingNonnullAnnotation(
 								currentArgument,
 								inheritedMethod.declaringClass,
-								needNonNull,
 								annotationName);
-					} else {
-						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
 					}
 				}
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 0084bae..26ce247 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -26,6 +26,7 @@
  *								bug 382347 - [1.8][compiler] Compiler accepts incorrect default method inheritance
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 376053 - [compiler][resource] Strange potential resource leak problems
+ *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
  *								bug 388739 - [1.8][compiler] consider default methods when detecting whether a class needs to be declared abstract
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
@@ -333,7 +334,6 @@ public static int getIrritant(int problemID) {
 		case IProblem.IllegalReturnNullityRedefinition:
 		case IProblem.IllegalRedefinitionToNonNullParameter:
 		case IProblem.IllegalDefinitionToNonNullParameter:
-		case IProblem.ParameterLackingNonNullAnnotation:
 		case IProblem.ParameterLackingNullableAnnotation:
 		case IProblem.CannotImplementIncompatibleNullness:
 		case IProblem.ConflictingNullAnnotations:
@@ -341,6 +341,9 @@ public static int getIrritant(int problemID) {
 		case IProblem.NullityMismatchingTypeAnnotation:
 			return CompilerOptions.NullSpecViolation;
 
+		case IProblem.ParameterLackingNonNullAnnotation:
+			return CompilerOptions.NonnullParameterAnnotationDropped;
+
 		case IProblem.RequiredNonNullButProvidedPotentialNull:
 			return CompilerOptions.NullAnnotationInferenceConflict;
 		case IProblem.RequiredNonNullButProvidedUnknown:
@@ -616,6 +619,7 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.NullAnnotationInferenceConflict :
 			case CompilerOptions.NullUncheckedConversion :
 			case CompilerOptions.MissingNonNullByDefaultAnnotation:
+			case CompilerOptions.NonnullParameterAnnotationDropped:
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			case CompilerOptions.RedundantNullAnnotation :
 				return CategorizedProblem.CAT_UNNECESSARY_CODE;
@@ -8548,14 +8552,30 @@ public void illegalRedefinitionToNonNullParameter(Argument argument, ReferenceBi
 			argument.type.sourceEnd);
 	}
 }
-public void parameterLackingNullAnnotation(Argument argument, ReferenceBinding declaringClass, boolean needNonNull, char[][] inheritedAnnotationName) {
+public void parameterLackingNullableAnnotation(Argument argument, ReferenceBinding declaringClass, char[][] inheritedAnnotationName) {
 	this.handle(
-		needNonNull ? IProblem.ParameterLackingNonNullAnnotation : IProblem.ParameterLackingNullableAnnotation, 
+		IProblem.ParameterLackingNullableAnnotation, 
 		new String[] { new String(argument.name), new String(declaringClass.readableName()), CharOperation.toString(inheritedAnnotationName)},
 		new String[] { new String(argument.name), new String(declaringClass.shortReadableName()), new String(inheritedAnnotationName[inheritedAnnotationName.length-1])},
 		argument.type.sourceStart,
 		argument.type.sourceEnd);
 }
+public void parameterLackingNonnullAnnotation(Argument argument, ReferenceBinding declaringClass, char[][] inheritedAnnotationName) {
+	int sourceStart = 0, sourceEnd = 0;
+	if (argument != null) {
+		sourceStart = argument.type.sourceStart;
+		sourceEnd = argument.type.sourceEnd;
+	} else if (this.referenceContext instanceof TypeDeclaration) {
+		sourceStart = ((TypeDeclaration) this.referenceContext).sourceStart;
+		sourceEnd =   ((TypeDeclaration) this.referenceContext).sourceEnd;
+	}
+	this.handle(
+		IProblem.ParameterLackingNonNullAnnotation, 
+		new String[] { new String(declaringClass.readableName()), CharOperation.toString(inheritedAnnotationName)},
+		new String[] { new String(declaringClass.shortReadableName()), new String(inheritedAnnotationName[inheritedAnnotationName.length-1])},
+		sourceStart,
+		sourceEnd);
+}
 public void illegalReturnRedefinition(AbstractMethodDeclaration abstractMethodDecl, MethodBinding inheritedMethod, char[][] nonNullAnnotationName) {
 	MethodDeclaration methodDecl = (MethodDeclaration) abstractMethodDecl;
 	StringBuffer methodSignature = new StringBuffer();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index cf58a0c..d460b08 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -24,6 +24,7 @@
 #							bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
 #							bug 382347 - [1.8][compiler] Compiler accepts incorrect default method inheritance
 #							bug 388281 - [compiler][null] inheritance of null annotations as an option
+#							bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
 #							bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
 #		Jesper S Moller <jesper@selskabet.org> - Contributions for
 #							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
@@ -710,7 +711,7 @@
 914 = The return type is incompatible with the @{1} return from {0}
 915 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as @{2}
 916 = Illegal redefinition of parameter {0}, inherited method from {1} does not constrain this parameter
-917 = Missing non-null annotation: inherited method from {1} declares this parameter as @{2}
+917 = Missing non-null annotation: inherited method from {0} declares this parameter as @{1}
 918 = Missing nullable annotation: inherited method from {1} declares this parameter as @{2}
 919 = Potential null pointer access: The method {0} may return null
 920 = Redundant null check: The method {0} cannot return null
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index c88a835..fb96c44 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -96,6 +96,7 @@
  *									COMPILER_PB_MISSING_ENUM_CASE_DESPITE_DEFAULT
  *									COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE
  *									COMPILER_INHERIT_NULL_ANNOTATIONS
+ *									COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED
  *******************************************************************************/
 
 package org.eclipse.jdt.core;
@@ -1707,6 +1708,32 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_INHERIT_NULL_ANNOTATIONS = JavaCore.PLUGIN_ID+".compiler.annotation.inheritNullAnnotations"; //$NON-NLS-1$
 	/**
+	 * Compiler option ID: Reporting Dropped Nonnull Parameter Annotations.
+	 * <p>When enabled, the compiler will issue an error or a warning against a parameter of 
+	 *    a method that overrides an inherited method
+	 *    if all of the following hold:</p>
+	 * <ul>
+	 *    <li>The overridden method declares the corresponding parameter as non-null (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</li>
+	 *    <li>The parameter in the overriding method has no null annotation.</li>
+	 *    <li>The overriding method is not affected by a nullness default (see {@link #COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME}).</li>
+	 *    <li>Inheritance of null annotations is disabled (see {@link #COMPILER_INHERIT_NULL_ANNOTATIONS}).</li>
+	 * </ul>
+	 * <p>This particular situation bears the same inherent risk as any unannotated method parameter,
+	 *    because the compiler's null ananysis cannot decide wither <code>null</code> is or is not a legal value for this parameter.
+	 *    However, the annotation in the overridden method <em>suggests</em> that the parameter should also be annotated as non-null.
+	 *    If that is not intended or possible, it is recommended to annotate the parameter as nullable,
+	 *    in order to make this (legal) change of contract explicit.</p>   
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 * @since 3.9
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED = JavaCore.PLUGIN_ID+".compiler.problem.nonnullParameterAnnotationDropped"; //$NON-NLS-1$
+
+	/**
 	 * Compiler option ID: Setting Source Compatibility Mode.
 	 * <p>Specify whether which source level compatibility is used. From 1.4 on, <code>'assert'</code> is a keyword
 	 *    reserved for assertion support. Also note, than when toggling to 1.4 mode, the target VM
