commit 09d58a6e319cfeec520d29fd7c2c24967ab4e499
Author: Jayapraskash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Tue Mar 5 05:49:53 2013 +0530

    First batch of changes for Bug 399780 - [1.8][compiler] Compiler should
    allow static methods and disallow synchronized methods in interfaces.

2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 084aa1d..1eb328d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -775,6 +775,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("MissingValueForAnnotationMember", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("MultiCatchNotBelow17", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("MultipleFunctionalInterfaces", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("StaticInterfaceMethodNotBelow18", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("MustDefineEitherDimensionExpressionsOrInitializer", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("MustSpecifyPackage", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("NativeMethodsCannotBeStrictfp", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
@@ -1548,6 +1549,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("MissingValueForAnnotationMember", SKIP);
 		expectedProblemAttributes.put("MultiCatchNotBelow17", SKIP);
 		expectedProblemAttributes.put("MultipleFunctionalInterfaces", SKIP);
+		expectedProblemAttributes.put("StaticInterfaceMethodNotBelow18", SKIP);
 		expectedProblemAttributes.put("MustDefineEitherDimensionExpressionsOrInitializer", SKIP);
 		expectedProblemAttributes.put("MustSpecifyPackage", SKIP);
 		expectedProblemAttributes.put("NativeMethodsCannotBeStrictfp", SKIP);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index efa2f17..2d69447 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1579,6 +1579,8 @@ void setSourceStart(int sourceStart);
 	int DuplicateBoundInIntersectionCast = TypeRelated + 894;
 	/** @since 3.9 */
 	int MultipleFunctionalInterfaces = TypeRelated + 895;
+	/** @since 3.9 */
+	int StaticInterfaceMethodNotBelow18 = Internal + Syntax + 896;
 	
 	/**
 	 * Errors/warnings from annotation based null analysis
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 853bbda..754f5d1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -2880,6 +2880,14 @@ public void defaultMethodsNotBelow18(MethodDeclaration md) {
 			md.bodyStart,
 			md.bodyEnd);
 }
+public void staticInterfaceMethodsNotBelow18(MethodDeclaration md) {
+	this.handle(
+			IProblem.StaticInterfaceMethodNotBelow18,
+			NoArgument,
+			NoArgument,
+			md.bodyStart,
+			md.bodyEnd);
+}
 public void referenceExpressionsNotBelow18(ReferenceExpression rexp) {
 	this.handle(
 			rexp.isMethodReference() ? IProblem.MethodReferenceNotBelow18 : IProblem.ConstructorReferenceNotBelow18,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index bb7bec0..45b7700 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -730,6 +730,7 @@
 893 = Arrays are not allowed in intersection cast operator
 894 = Duplicate type in intersection cast operator
 895 = The target type of this expression is not a functional interface: more than one of the intersecting interfaces are functional
+896 = Static methods are allowed in interfaces only at source level 1.8 or above
 
 ### NULL ANNOTATIONS
 910 = Null type mismatch: required ''{0}'' but the provided value is null
commit 0b88f9a0bb1950edae0865a8658608a49edfc445
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Fri Mar 8 16:25:20 2013 -0500

    Fixed Bug 399780 - [1.8][compiler] Compiler should allow static methods
    and disallow synchronized methods in interfaces.

46	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
413	71	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InterfaceMethodsTest.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
20	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
11	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
16	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
9	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
index 7546e09..2cacaa0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ComplianceDiagnoseTest.java
@@ -3119,4 +3119,50 @@ public void testBug399778a() {
 		expectedProblemLog   // 1.8 also issue type safety warning.
 	);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780: static methods in interfaces.
+public void testBug399780() {
+	if(this.complianceLevel >= ClassFileConstants.JDK1_8) {
+		return;
+	}
+	String[] testFiles = new String[] {
+		"I.java",
+		"interface I {\n" +
+		"  public static void foo1() { System.out.println(); }\n" +
+		"  public static void foo2();\n" +
+		"  public abstract static void foo3();\n" +
+		"}\n"
+	};
+
+	String expectedProblemLog =
+			"----------\n" + 
+			"1. ERROR in I.java (at line 2)\n" + 
+			"	public static void foo1() { System.out.println(); }\n" + 
+			"	                   ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo1; only public & abstract are permitted\n" + 
+			"----------\n" + 
+			"2. ERROR in I.java (at line 2)\n" + 
+			"	public static void foo1() { System.out.println(); }\n" + 
+			"	                           ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Static methods are allowed in interfaces only at source level 1.8 or above\n" + 
+			"----------\n" + 
+			"3. ERROR in I.java (at line 3)\n" + 
+			"	public static void foo2();\n" + 
+			"	                   ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo2; only public & abstract are permitted\n" + 
+			"----------\n" + 
+			"4. ERROR in I.java (at line 4)\n" + 
+			"	public abstract static void foo3();\n" + 
+			"	                            ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo3; only public & abstract are permitted\n" + 
+			"----------\n";
+
+	runComplianceParserTest(
+		testFiles,
+		expectedProblemLog,
+		expectedProblemLog,
+		expectedProblemLog,
+		expectedProblemLog,
+		expectedProblemLog
+	);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InterfaceMethodsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InterfaceMethodsTest.java
index ee0da06..1f9a6e0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InterfaceMethodsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InterfaceMethodsTest.java
@@ -47,9 +47,25 @@ public class InterfaceMethodsTest extends AbstractComparableTest {
 
 	// default methods with various modifiers, positive cases
 	public void testModifiers1() {
-// Inject an unrelated compile error to prevent class file verification. TODO revert
-// (even lambda-enabled JRE doesn't accept now-legal modifier combinations)
-//		runConformTest(
+		runConformTest(
+		new String[] {
+			"I.java",
+			"import java.lang.annotation.*;\n" +
+			"@Target(ElementType.METHOD) @interface Annot{}\n" +
+			"public interface I {\n" +
+			"    default void foo1()  {}\n" +
+			"    public default void foo2() { System.exit(0); }\n" +
+			"    strictfp default void foo3() {}\n" +
+			"    public default strictfp void foo4() {}\n" +
+			"    public default strictfp @Annot void foo5() {}\n" +
+			"}\n",
+		}, 
+		"");
+	}
+		
+
+	// default methods with various modifiers, negative cases
+	public void testModifiers1a() {
 		runNegativeTest(
 		new String[] {
 			"I.java",
@@ -61,19 +77,27 @@ public class InterfaceMethodsTest extends AbstractComparableTest {
 			"    strictfp default void foo3() {}\n" +
 			"    public default strictfp synchronized void foo4() {}\n" +
 			"    public default strictfp synchronized @Annot void foo5() {}\n" +
-			"}\n" +
-			"public class Wrong{}\n"}, // TODO remove me
-		// TODO remove me:
-		"----------\n" +
-		"1. ERROR in I.java (at line 10)\n" +
-		"	public class Wrong{}\n" +
-		"	             ^^^^^\n" +
-		"The public type Wrong must be defined in its own file\n" +
-		"----------\n");
+			"}\n"}, 
+			"----------\n" + 
+			"1. ERROR in I.java (at line 5)\n" + 
+			"	public default synchronized void foo2() { System.exit(0); }\n" + 
+			"	                                 ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo2; only public, abstract and strictfp are permitted\n" + 
+			"----------\n" + 
+			"2. ERROR in I.java (at line 7)\n" + 
+			"	public default strictfp synchronized void foo4() {}\n" + 
+			"	                                          ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo4; only public, abstract and strictfp are permitted\n" + 
+			"----------\n" + 
+			"3. ERROR in I.java (at line 8)\n" + 
+			"	public default strictfp synchronized @Annot void foo5() {}\n" + 
+			"	                                                 ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo5; only public, abstract and strictfp are permitted\n" + 
+			"----------\n");
 	}
 
 	// default methods with various modifiers, simple syntax error blows the parser
-	public void testModifiers1a() {
+	public void testModifiers1b() {
 		runNegativeTest(
 		new String[] {
 			"I.java",
@@ -81,10 +105,10 @@ public class InterfaceMethodsTest extends AbstractComparableTest {
 			"@Target(ElementType.METHOD) @interface Annot{}\n" +
 			"public interface I {\n" +
 			"    default void foo1() { System.out.println(3); }\n" +
-			"    public default synchronized void foo2() {}\n" +
+			"    public default void foo2() {}\n" +
 			"    stritfp default void foo3() {}\n" + // typo in strictfp
-			"    default public strictfp synchronized void foo4() {}\n" +
-			"    public strictfp  default synchronized @Annot void foo5() {}\n" +
+			"    default public strictfp void foo4() {}\n" +
+			"    public strictfp  default @Annot void foo5() {}\n" +
 			"    public default <T> T foo6(T t) { return t; }\n" +
 			"}\n"},
 			"----------\n" +
@@ -155,36 +179,36 @@ public class InterfaceMethodsTest extends AbstractComparableTest {
 			"    static default void foo5() {}\n" +
 			"    default static void foo6() {}\n" +
 			"}\n"},
-			"----------\n" +
-			"1. ERROR in I.java (at line 2)\n" +
-			"	native void foo1();\n" +
-			"	            ^^^^^^\n" +
-			"Illegal modifier for the interface method foo1; only public & abstract are permitted\n" +
-			"----------\n" +
-			"2. ERROR in I.java (at line 3)\n" +
-			"	static void foo2();\n" +
-			"	            ^^^^^^\n" +
-			"Illegal modifier for the interface method foo2; only public & abstract are permitted\n" +
-			"----------\n" +
-			"3. ERROR in I.java (at line 4)\n" +
-			"	native default void foo3() {}\n" +
-			"	                    ^^^^^^\n" +
-			"Illegal modifier for the interface method foo3; only public, abstract, strictfp & synchronized are permitted\n" +
-			"----------\n" +
-			"4. ERROR in I.java (at line 5)\n" +
-			"	default native void foo4() {}\n" +
-			"	                    ^^^^^^\n" +
-			"Illegal modifier for the interface method foo4; only public, abstract, strictfp & synchronized are permitted\n" +
-			"----------\n" +
-			"5. ERROR in I.java (at line 6)\n" +
-			"	static default void foo5() {}\n" +
-			"	                    ^^^^^^\n" +
-			"Illegal modifier for the interface method foo5; only public, abstract, strictfp & synchronized are permitted\n" +
-			"----------\n" +
-			"6. ERROR in I.java (at line 7)\n" +
-			"	default static void foo6() {}\n" +
-			"	                    ^^^^^^\n" +
-			"Illegal modifier for the interface method foo6; only public, abstract, strictfp & synchronized are permitted\n" +
+			"----------\n" + 
+			"1. ERROR in I.java (at line 2)\n" + 
+			"	native void foo1();\n" + 
+			"	            ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo1; only public & abstract are permitted\n" + 
+			"----------\n" + 
+			"2. ERROR in I.java (at line 3)\n" + 
+			"	static void foo2();\n" + 
+			"	            ^^^^^^\n" + 
+			"This method requires a body instead of a semicolon\n" + 
+			"----------\n" + 
+			"3. ERROR in I.java (at line 4)\n" + 
+			"	native default void foo3() {}\n" + 
+			"	                    ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo3; only public, abstract and strictfp are permitted\n" + 
+			"----------\n" + 
+			"4. ERROR in I.java (at line 5)\n" + 
+			"	default native void foo4() {}\n" + 
+			"	                    ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo4; only public, abstract and strictfp are permitted\n" + 
+			"----------\n" + 
+			"5. ERROR in I.java (at line 6)\n" + 
+			"	static default void foo5() {}\n" + 
+			"	                    ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo5; only public, abstract and strictfp are permitted\n" + 
+			"----------\n" + 
+			"6. ERROR in I.java (at line 7)\n" + 
+			"	default static void foo6() {}\n" + 
+			"	                    ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo6; only public, abstract and strictfp are permitted\n" + 
 			"----------\n");
 	}
 
@@ -201,31 +225,26 @@ public class InterfaceMethodsTest extends AbstractComparableTest {
 			"    void foo4() { }\n" + // implicit "abstract" without "default" doesn't allow a body, either
 			"    abstract static default void foo5() {}\n" + // double fault
 			"}\n"},
-			"----------\n" +
-			"1. ERROR in I.java (at line 4)\n" +
-			"	public abstract default void foo2() {}\n" +
-			"	                             ^^^^^^\n" +
-			"Abstract methods do not specify a body\n" +
-			"----------\n" +
-			"2. ERROR in I.java (at line 5)\n" +
-			"	default abstract void foo3() {}\n" +
-			"	                      ^^^^^^\n" +
-			"Abstract methods do not specify a body\n" +
-			"----------\n" +
-			"3. ERROR in I.java (at line 6)\n" +
-			"	void foo4() { }\n" +
-			"	     ^^^^^^\n" +
-			"Abstract methods do not specify a body\n" +
-			"----------\n" +
-			"4. ERROR in I.java (at line 7)\n" +
-			"	abstract static default void foo5() {}\n" +
-			"	                             ^^^^^^\n" +
-			"Illegal modifier for the interface method foo5; only public, abstract, strictfp & synchronized are permitted\n" +
-			"----------\n" +
-			"5. ERROR in I.java (at line 7)\n" +
-			"	abstract static default void foo5() {}\n" +
-			"	                             ^^^^^^\n" +
-			"Abstract methods do not specify a body\n" +
+			"----------\n" + 
+			"1. ERROR in I.java (at line 4)\n" + 
+			"	public abstract default void foo2() {}\n" + 
+			"	                             ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo2; only public, abstract and strictfp are permitted\n" + 
+			"----------\n" + 
+			"2. ERROR in I.java (at line 5)\n" + 
+			"	default abstract void foo3() {}\n" + 
+			"	                      ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo3; only public, abstract and strictfp are permitted\n" + 
+			"----------\n" + 
+			"3. ERROR in I.java (at line 6)\n" + 
+			"	void foo4() { }\n" + 
+			"	     ^^^^^^\n" + 
+			"Abstract methods do not specify a body\n" + 
+			"----------\n" + 
+			"4. ERROR in I.java (at line 7)\n" + 
+			"	abstract static default void foo5() {}\n" + 
+			"	                             ^^^^^^\n" + 
+			"Illegal modifier for the interface method foo5; only public, abstract and strictfp are permitted\n" + 
 			"----------\n");
 	}
 
@@ -1231,4 +1250,327 @@ public class InterfaceMethodsTest extends AbstractComparableTest {
 			"OK"
 		);
 	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	// Test for different legal and illegal keywords for static and default methods in interfaces
+	public void testStaticMethod01() {
+		runNegativeTest(
+				new String[] {
+					"I.java",
+					"public interface I {\n" +
+					"	static void foo() {}\n" +
+					"	static void foo1();\n" +
+					"	public static default void foo2 () {};\n" +
+					"	abstract static void foo3();\n" +
+					"	abstract static void foo4() {}\n" +
+					"}"
+				},
+				"----------\n" + 
+				"1. ERROR in I.java (at line 3)\n" + 
+				"	static void foo1();\n" + 
+				"	            ^^^^^^\n" + 
+				"This method requires a body instead of a semicolon\n" + 
+				"----------\n" + 
+				"2. ERROR in I.java (at line 4)\n" + 
+				"	public static default void foo2 () {};\n" + 
+				"	                           ^^^^^^^\n" + 
+				"Illegal modifier for the interface method foo2; only public, abstract and strictfp are permitted\n" + 
+				"----------\n" + 
+				"3. ERROR in I.java (at line 5)\n" + 
+				"	abstract static void foo3();\n" + 
+				"	                     ^^^^^^\n" + 
+				"Illegal modifier for the interface method foo3; only public & abstract are permitted\n" + 
+				"----------\n" + 
+				"4. ERROR in I.java (at line 6)\n" + 
+				"	abstract static void foo4() {}\n" + 
+				"	                     ^^^^^^\n" + 
+				"Illegal modifier for the interface method foo4; only public & abstract are permitted\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	// Test invocation of static methods with different contexts - negative tests
+	public void testStaticMethod02() {
+		runNegativeTest(
+				new String[] {
+					"I.java",
+					"public interface I {\n" +
+					"	public static void foo() {\n" +
+					"		bar();\n" +
+					"		this.bar();\n" +
+					"   }\n" +
+					"	public default void bar () {\n" +
+					"		this.foo();\n" +
+					"	}\n" +
+					"}\n" +
+					"interface II extends I{\n" +
+					"	public static void foobar() {\n" +
+					"		super.bar();\n" +
+					"   }\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in I.java (at line 3)\n" + 
+				"	bar();\n" + 
+				"	^^^\n" + 
+				"Cannot make a static reference to the non-static method bar() from the type I\n" + 
+				"----------\n" + 
+				"2. ERROR in I.java (at line 4)\n" + 
+				"	this.bar();\n" + 
+				"	^^^^\n" + 
+				"Cannot use this in a static context\n" + 
+				"----------\n" + 
+				"3. ERROR in I.java (at line 7)\n" + 
+				"	this.foo();\n" + 
+				"	     ^^^\n" + 
+				"The method foo() is undefined for the type I\n" + 
+				"----------\n" + 
+				"4. ERROR in I.java (at line 12)\n" + 
+				"	super.bar();\n" + 
+				"	^^^^^\n" + 
+				"Cannot use super in a static context\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	// Test invocation of static methods with different contexts - positive tests
+	public void testStaticMethod03() {
+		runConformTest(
+			new String[] {
+				"C.java",
+				"interface I {\n" +
+				"	public static void foo() {\n" +
+				"		System.out.println(\"I#foo() invoked\");\n" +
+				"   }\n" +
+				"}\n" +
+				"interface J extends I {\n" +
+				"	public static void foo() {\n" +
+				"		System.out.println(\"J#foo() invoked\");\n" +
+				"   }\n" +
+				"	public default void bar () {\n" +
+				"		foo();\n" +
+				"	}\n" +
+				"}\n" +
+				"public class C implements J {\n" +
+				"	public static void main(String[] args) {\n" +
+				"		C c = new C();\n" +
+				"		c.bar();\n" +
+				"       J.foo();\n" +
+				"       I.foo();\n" +
+				"	}\n" +
+				"}"
+			},
+			"J#foo() invoked\n" +
+			"J#foo() invoked\n" + 
+			"I#foo() invoked");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	// Test invocation of static methods with different contexts - negative tests
+	public void testStaticMethod04() {
+		runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X implements II {\n"
+						+ "	@Override"
+						+ "	public void foo() {\n"
+						+ "		 bar();\n"
+						+ "		 bar2();\n"
+						+ "	}\n"
+						+ "	public static void main(String[] args) {\n"
+						+ "		bar();\n"
+						+ "		II.bar();\n"
+						+ "		(new X()).bar();\n"
+						+ "		II.bar();\n"
+						+ "		II ii = new X();\n"
+						+ "		ii.bar();\n"
+						+ "		ii.bar2();\n"
+						+ "		I i = new X();\n"
+						+ "		i.bar();\n"
+						+ "      new I() {}.foo();\n"
+						+ "	}\n"
+						+ "}\n"
+						+ "interface I {\n"
+						+ "	public static void bar() {\n"
+						+ "		bar2();\n"
+						+ "	}\n"
+						+ "	public default void bar2() {\n"
+						+ "		bar();\n"
+						+ "	}\n"
+						+ "}\n"
+						+ "interface II extends I {\n"
+						+ "	public default void foo() {\n"
+						+ "		bar();\n"
+						+ "	}\n"
+						+ "}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 3)\n" + 
+				"	bar();\n" + 
+				"	^^^\n" + 
+				"The method bar() is undefined for the type X\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 7)\n" + 
+				"	bar();\n" + 
+				"	^^^\n" + 
+				"The method bar() is undefined for the type X\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 8)\n" + 
+				"	II.bar();\n" + 
+				"	   ^^^\n" + 
+				"The method bar() is undefined for the type II\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 9)\n" + 
+				"	(new X()).bar();\n" + 
+				"	          ^^^\n" + 
+				"The method bar() is undefined for the type X\n" + 
+				"----------\n" + 
+				"5. ERROR in X.java (at line 10)\n" + 
+				"	II.bar();\n" + 
+				"	   ^^^\n" + 
+				"The method bar() is undefined for the type II\n" + 
+				"----------\n" + 
+				"6. ERROR in X.java (at line 12)\n" + 
+				"	ii.bar();\n" + 
+				"	   ^^^\n" + 
+				"The method bar() is undefined for the type II\n" + 
+				"----------\n" + 
+				"7. ERROR in X.java (at line 15)\n" + 
+				"	i.bar();\n" + 
+				"	  ^^^\n" + 
+				"The method bar() is undefined for the type I\n" + 
+				"----------\n" + 
+				"8. ERROR in X.java (at line 16)\n" + 
+				"	new I() {}.foo();\n" + 
+				"	           ^^^\n" + 
+				"The method foo() is undefined for the type new I(){}\n" + 
+				"----------\n" + 
+				"9. ERROR in X.java (at line 21)\n" + 
+				"	bar2();\n" + 
+				"	^^^^\n" + 
+				"Cannot make a static reference to the non-static method bar2() from the type I\n" + 
+				"----------\n" + 
+				"10. ERROR in X.java (at line 29)\n" + 
+				"	bar();\n" + 
+				"	^^^\n" + 
+				"The method bar() is undefined for the type II\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	public void testStaticMethod05() {
+		runNegativeTest(
+				new String[] {
+						"X.java",
+						"interface I {\n" +
+						"	static void foo(int x) { }\n" +
+						"}\n" +
+						"interface II extends I {\n" +
+						"	static void goo(int x) {}   		// No Error.\n" +
+						"}\n" +
+						"interface III extends II {\n" +
+						"	default void foo(int x, int y) {}   // No Error.\n" +
+						"	default void goo() {}   			// No Error.\n" +
+						"	default void foo(int x) {}   		// No Error.\n" +
+						"	default void goo(int x) {}   		// No Error.\n" +
+						"}\n" +
+						"class Y {\n" +
+						"	static void goo(int x) {}\n" +
+						"}\n" +
+						"class X extends Y {\n" +
+						"	void foo(int x) {}   // No error.\n" +
+						"	void goo() {}   	 // No Error.\n" +
+						"	void goo(int x) {}   // Error.\n" +
+						"}\n"
+						},
+						"----------\n" + 
+						"1. ERROR in X.java (at line 19)\n" + 
+						"	void goo(int x) {}   // Error.\n" + 
+						"	     ^^^^^^^^^^\n" + 
+						"This instance method cannot override the static method from Y\n" + 
+						"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	// Test that extending interfaces inherit visible fields and inner types.
+	public void testStaticMethod06() {
+		runConformTest(
+				new String[] {
+					"C.java",
+					"interface I {\n" +
+					"	public static String CONST = \"CONSTANT\";\n" +
+					"	public static void foo(String[] args) {\n" +
+					"		System.out.println(args[0]);\n" +
+					"   }\n" +
+					" 	public interface Inner {}\n" +
+					"}\n" +
+					"interface J extends I {\n" +
+					"	public static void foo() {\n" +
+					"		I.foo(new String[]{CONST});\n" +
+					"   }\n" +
+					" 	public interface InnerInner extends Inner {}\n" +
+					"}\n" +
+					"public class C implements J {\n" +
+					"	public static void main(String[] args) {\n" +
+					"       J.foo();\n" +
+					"       I.foo(new String[]{\"LITERAL\"});\n" +
+					"	}\n" +
+					"}"
+				},
+				"CONSTANT\n" + 
+				"LITERAL");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	// Test that type parameter from enclosing type is not allowed to be referred to in static interface methods
+	public void testStaticMethod07() {
+		runNegativeTest(
+				new String[] {
+					"C.java",
+					"interface I <T> {\n" +
+					"	public static T foo(T t) {\n" +
+					"		return t;" +
+					"   }\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in C.java (at line 2)\n" + 
+				"	public static T foo(T t) {\n" + 
+				"	              ^\n" + 
+				"Cannot make a static reference to the non-static type T\n" + 
+				"----------\n" + 
+				"2. ERROR in C.java (at line 2)\n" + 
+				"	public static T foo(T t) {\n" + 
+				"	                    ^\n" + 
+				"Cannot make a static reference to the non-static type T\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	public void testStaticMethod08() {
+		runNegativeTest(
+				new String[] {
+					"C.java",
+					"@interface A {\n" +
+					"	static String foo() default \"Blah\";\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in C.java (at line 2)\n" + 
+				"	static String foo() default \"Blah\";\n" + 
+				"	              ^^^^^\n" + 
+				"Illegal modifier for the annotation attribute A.foo; only public & abstract are permitted\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	public void testStaticMethod09() {
+		runNegativeTest(
+				new String[] {
+						"C.java",
+						"interface A {\n" +
+						"	static void foo() {}\n" +
+						"	default void goo(A a) {\n" +
+						"		a.foo();\n" +
+						"	}\n" +
+						"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in C.java (at line 4)\n" + 
+				"	a.foo();\n" + 
+				"	  ^^^\n" + 
+				"The method foo() is undefined for the type A\n" + 
+				"----------\n");
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 9da0932..e7f7ba2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -273,7 +273,6 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 			}
 		}
 
-		// by grammatical construction, interface methods are always abstract
 		switch (TypeDeclaration.kind(this.scope.referenceType().modifiers)) {
 			case TypeDeclaration.ENUM_DECL :
 				if (this.selector == TypeConstants.VALUES) break;
@@ -295,6 +294,15 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 						this.bits |= ASTNode.CanBeStatic;
 					}
 				}
+				break;
+			case TypeDeclaration.INTERFACE_DECL :
+				if (compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8
+						&& (this.modifiers & (ExtraCompilerModifiers.AccSemicolonBody | ClassFileConstants.AccAbstract)) == ExtraCompilerModifiers.AccSemicolonBody) {
+					if ((this.modifiers & (ClassFileConstants.AccStatic | ExtraCompilerModifiers.AccDefaultMethod)) != 0) {
+							this.scope.problemReporter().methodNeedBody(this);
+					}
+				}
+				break;
 		}
 		super.resolveStatements();
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index 79f758b..2a3698d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contributions for
@@ -24,6 +28,7 @@ import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.eclipse.jdt.internal.compiler.ast.MessageSend;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
@@ -250,9 +255,23 @@ public final boolean canBeSeenBy(PackageBinding invocationPackage) {
 * NOTE: Cannot invoke this method with a compilation unit scope.
 */
 public final boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope) {
-	if (isPublic()) return true;
 
 	SourceTypeBinding invocationType = scope.enclosingSourceType();
+	if (this.declaringClass.isInterface() && isStatic()) {
+		// Static interface methods can be explicitly invoked only through the type reference of the declaring interface or implicitly in the interface itself.
+		if (scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_8 || !(invocationSite instanceof MessageSend))
+			return false;
+		MessageSend messageSend = (MessageSend) invocationSite;
+		if (messageSend.isTypeAccess() && receiverType == this.declaringClass)
+			return true;
+		if (messageSend.receiver.isImplicitThis() && invocationType == this.declaringClass)
+			return true;
+		return false;
+	}
+	
+	if (isPublic()) return true;
+	
+
 	if (invocationType == this.declaringClass && invocationType == receiverType) return true;
 
 	if (invocationType == null) // static import call
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
index 9dfad0e..d1e06df 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
@@ -178,21 +178,23 @@ private void checkAndSetModifiersForMethod(MethodBinding methodBinding) {
 	// set the requested modifiers for a method in an interface/annotation
 	if (declaringClass.isInterface()) {
 		int expectedModifiers = ClassFileConstants.AccPublic | ClassFileConstants.AccAbstract;
-		// 9.4 got updated for JSR 335 (default methods), more permissive grammar plus:
-		// "It is a compile-time error if an abstract method declaration contains either of the keywords strictfp or synchronized."
-		if (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8 && !methodBinding.isAbstract()) {
-			expectedModifiers |= (ClassFileConstants.AccSynchronized | ClassFileConstants.AccStrictfp);
-		}
 		boolean isDefaultMethod = (modifiers & ExtraCompilerModifiers.AccDefaultMethod) != 0; // no need to check validity, is done by the parser
+		if (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8 && !declaringClass.isAnnotationType()) {
+			if (!methodBinding.isAbstract()) {
+				expectedModifiers |= ClassFileConstants.AccStrictfp
+										| (isDefaultMethod ?  ExtraCompilerModifiers.AccDefaultMethod : ClassFileConstants.AccStatic);
+			}
+			// Kludge - The AccDefaultMethod bit is outside the lower 16 bits and got removed earlier. Putting it back.
+			if (isDefaultMethod) {
+				realModifiers |= ExtraCompilerModifiers.AccDefaultMethod;
+			}
+		}
 		if ((realModifiers & ~expectedModifiers) != 0) {
 			if ((declaringClass.modifiers & ClassFileConstants.AccAnnotation) != 0)
 				problemReporter().illegalModifierForAnnotationMember((AbstractMethodDeclaration) this.referenceContext);
 			else
 				problemReporter().illegalModifierForInterfaceMethod((AbstractMethodDeclaration) this.referenceContext, isDefaultMethod);
 		}
-		if (isDefaultMethod && (modifiers & ClassFileConstants.AccAbstract) != 0) {
-			problemReporter().abstractMethodNeedingNoBody((AbstractMethodDeclaration) this.referenceContext);
-		}
 		return;
 	}
 
@@ -337,7 +339,7 @@ MethodBinding createMethod(AbstractMethodDeclaration method) {
 		checkAndSetModifiersForConstructor(method.binding);
 	} else {
 		if (declaringClass.isInterface()) {// interface or annotation type
-			if (method.isDefaultMethod()) {
+			if (method.isDefaultMethod() || method.isStatic()) {
 				modifiers |= ClassFileConstants.AccPublic; // default method is not abstract
 			} else {
 				modifiers |= ClassFileConstants.AccPublic | ClassFileConstants.AccAbstract;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
index 10b873f..7ea0517 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
@@ -599,6 +599,7 @@ void computeInheritedMethods(ReferenceBinding superclass, ReferenceBinding[] sup
 			MethodBinding[] methods = superType.unResolvedMethods();
 			nextMethod : for (int m = methods.length; --m >= 0;) { // Interface methods are all abstract public
 				MethodBinding inheritedMethod = methods[m];
+				if (inheritedMethod.isStatic()) continue nextMethod;
 				MethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(inheritedMethod.selector);
 				if (existingMethods == null) {
 					existingMethods = new MethodBinding[] {inheritedMethod};
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 1c17c0b..4a2172d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -1039,7 +1039,7 @@ public abstract class Scope {
 			if (exactMethod.isAbstract() && exactMethod.thrownExceptions != Binding.NO_EXCEPTIONS)
 				return null; // may need to merge exceptions with interface method
 			// special treatment for Object.getClass() in 1.5 mode (substitute parameterized return type)
-			if (receiverType.isInterface() || exactMethod.canBeSeenBy(receiverType, invocationSite, this)) {
+			if (exactMethod.canBeSeenBy(receiverType, invocationSite, this)) {
 				if (argumentTypes == Binding.NO_PARAMETERS
 				    && CharOperation.equals(selector, TypeConstants.GETCLASS)
 				    && exactMethod.returnType.isParameterizedType()/*1.5*/) {
@@ -1355,8 +1355,12 @@ public abstract class Scope {
 		if (receiverTypeIsInterface) {
 			unitScope.recordTypeReference(receiverType);
 			MethodBinding[] receiverMethods = receiverType.getMethods(selector, argumentTypes.length);
-			if (receiverMethods.length > 0)
-				found.addAll(receiverMethods);
+			for (int index = 0, length = receiverMethods.length; index < length; index++) {
+				MethodBinding binding = receiverMethods[index];
+				if (binding.canBeSeenBy(receiverType, invocationSite, this)) {
+					found.add(binding);
+				}
+			}
 			findMethodInSuperInterfaces(receiverType, selector, found, invocationSite);
 			currentType = getJavaLangObject();
 		}
@@ -1635,7 +1639,8 @@ public abstract class Scope {
 		return methodBinding;
 	}
 
-	protected void findMethodInSuperInterfaces(ReferenceBinding currentType, char[] selector, ObjectVector found, InvocationSite invocationSite) {
+	protected void findMethodInSuperInterfaces(ReferenceBinding receiverType, char[] selector, ObjectVector found, InvocationSite invocationSite) {
+		ReferenceBinding currentType = receiverType;
 		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
 		if (itsInterfaces != null && itsInterfaces != Binding.NO_SUPERINTERFACES) {
 			ReferenceBinding[] interfacesToVisit = itsInterfaces;
@@ -1647,16 +1652,16 @@ public abstract class Scope {
 				MethodBinding[] currentMethods = currentType.getMethods(selector);
 				if (currentMethods.length > 0) {
 					int foundSize = found.size;
-					if (foundSize > 0) {
-						// its possible to walk the same superinterface from different classes in the hierarchy
-						next : for (int c = 0, l = currentMethods.length; c < l; c++) {
-							MethodBinding current = currentMethods[c];
+					next : for (int c = 0, l = currentMethods.length; c < l; c++) {
+						MethodBinding current = currentMethods[c];
+						if (!current.canBeSeenBy(receiverType, invocationSite, this)) continue next;
+
+						if (foundSize > 0) {
+							// its possible to walk the same superinterface from different classes in the hierarchy
 							for (int f = 0; f < foundSize; f++)
 								if (current == found.elementAt(f)) continue next;
-							found.add(current);
 						}
-					} else {
-						found.addAll(currentMethods);
+						found.add(current);
 					}
 				}
 				if ((itsInterfaces = currentType.superInterfaces()) != null && itsInterfaces != Binding.NO_SUPERINTERFACES) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index c3ffd94..58f3626 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -4751,16 +4751,18 @@ protected void consumeInterfaceMethodDeclaration(boolean hasSemicolonBody) {
 	md.declarationSourceEnd = flushCommentsDefinedPriorTo(this.endStatementPosition);
 	
 	boolean isDefault = (md.modifiers & ExtraCompilerModifiers.AccDefaultMethod) != 0;
-	if (isDefault) {
-		if (!this.parsingJava8Plus) {
-			problemReporter().defaultMethodsNotBelow18(md);
-		} else if (hasSemicolonBody) {
+	boolean isStatic = (md.modifiers & ClassFileConstants.AccStatic) != 0;
+	boolean bodyAllowed = isDefault || isStatic;
+	if (this.parsingJava8Plus) {
+		if (bodyAllowed && hasSemicolonBody) {
 			md.modifiers |= ExtraCompilerModifiers.AccSemicolonBody; // avoid complaints regarding undocumented empty body
-			problemReporter().methodNeedBody(md);	// grammar intentially allows illegal input to enable this error message
 		}
 	} else {
-		// report the problem and continue the parsing - narrowing the problem onto the method
-		if(!this.statementRecoveryActivated && !hasSemicolonBody) problemReporter().abstractMethodNeedingNoBody(md);
+		if (isDefault) problemReporter().defaultMethodsNotBelow18(md);
+		if (isStatic) problemReporter().staticInterfaceMethodsNotBelow18(md);
+	}
+	if (!bodyAllowed && !this.statementRecoveryActivated && !hasSemicolonBody) {
+		problemReporter().abstractMethodNeedingNoBody(md);
 	}
 }
 protected void consumeLabel() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 45b7700..8533bb6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -780,7 +780,7 @@
 
 # Default methods:
 # variant of 359: 
-1050 = Illegal modifier for the interface method {0}; only public, abstract, strictfp & synchronized are permitted
+1050 = Illegal modifier for the interface method {0}; only public, abstract and strictfp are permitted
 1051 = A default method cannot override a method from java.lang.Object 
 1052 = The default method {0} inherited from {1} conflicts with another method inherited from {2}
 1053 = Duplicate default methods named {0} with the parameters ({1}) and ({2}) are inherited from the types {3} and {4}
commit 39c80376eb5a4ddf3b0cc660e46c4e7575c329d8
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sat Mar 9 17:40:15 2013 -0500

    Follow up changes to static interface method support (bug 399780)

2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
92	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InterfaceMethodsTest.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
25	35	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
14	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 1eb328d..dd545bf 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -803,6 +803,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("NonStaticFieldFromStaticInvocation", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("NonStaticOrAlienTypeReceiver", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NonStaticTypeFromStaticInvocation", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("NotVisibleConstructor", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleConstructorInDefaultConstructor", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
@@ -1577,6 +1578,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", SKIP);
 		expectedProblemAttributes.put("NonStaticFieldFromStaticInvocation", SKIP);
+		expectedProblemAttributes.put("NonStaticOrAlienTypeReceiver", SKIP);
 		expectedProblemAttributes.put("NonStaticTypeFromStaticInvocation", SKIP);
 		expectedProblemAttributes.put("NotVisibleConstructor", SKIP);
 		expectedProblemAttributes.put("NotVisibleConstructorInDefaultConstructor", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InterfaceMethodsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InterfaceMethodsTest.java
index 1f9a6e0..14c6250 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InterfaceMethodsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InterfaceMethodsTest.java
@@ -1321,7 +1321,7 @@ public class InterfaceMethodsTest extends AbstractComparableTest {
 				"3. ERROR in I.java (at line 7)\n" + 
 				"	this.foo();\n" + 
 				"	     ^^^\n" + 
-				"The method foo() is undefined for the type I\n" + 
+				"This static method of interface I can only be accessed as I.foo\n" +
 				"----------\n" + 
 				"4. ERROR in I.java (at line 12)\n" + 
 				"	super.bar();\n" + 
@@ -1434,7 +1434,7 @@ public class InterfaceMethodsTest extends AbstractComparableTest {
 				"7. ERROR in X.java (at line 15)\n" + 
 				"	i.bar();\n" + 
 				"	  ^^^\n" + 
-				"The method bar() is undefined for the type I\n" + 
+				"This static method of interface I can only be accessed as I.bar\n" + 
 				"----------\n" + 
 				"8. ERROR in X.java (at line 16)\n" + 
 				"	new I() {}.foo();\n" + 
@@ -1570,7 +1570,96 @@ public class InterfaceMethodsTest extends AbstractComparableTest {
 				"1. ERROR in C.java (at line 4)\n" + 
 				"	a.foo();\n" + 
 				"	  ^^^\n" + 
-				"The method foo() is undefined for the type A\n" + 
+				"This static method of interface A can only be accessed as A.foo\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	public void testStaticMethod10() {
+		runNegativeTest(
+				new String[] {
+						"C.java",
+						"interface A {\n" +
+						"	static void foo(long x) {}\n" +
+						"	static void foo(int x) {}\n" +
+						"	default void goo(A a) {\n" +
+						"		a.foo(10);\n" +
+						"	}\n" +
+						"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in C.java (at line 5)\n" + 
+				"	a.foo(10);\n" + 
+				"	  ^^^\n" + 
+				"This static method of interface A can only be accessed as A.foo\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	public void testStaticMethod11() {
+		runNegativeTest(
+				new String[] {
+						"C.java",
+						"interface A<X> {\n" +
+						"	void foo(X x);\n" +
+						"}\n" +
+						"interface B extends A<String> {\n" +
+						"    static void foo(String s) {}\n" +
+						"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in C.java (at line 5)\n" + 
+				"	static void foo(String s) {}\n" + 
+				"	            ^^^^^^^^^^^^^\n" + 
+				"This static method cannot hide the instance method from A<String>\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	public void testStaticMethod12() {
+		runNegativeTest(
+				new String[] {
+						"C.java",
+						"interface A<X> {\n" +
+						"	static void foo(String x) {}\n" +
+						"}\n" +
+						"interface B extends A<String> {\n" +
+						"    static void foo(String s) {}\n" +
+						"}\n" +
+						"public class X {\n" +
+						"}\n"
+				},
+				"----------\n" + 
+				"1. WARNING in C.java (at line 1)\n" + 
+				"	interface A<X> {\n" + 
+				"	            ^\n" + 
+				"The type parameter X is hiding the type X\n" + 
+				"----------\n" + 
+				"2. ERROR in C.java (at line 7)\n" + 
+				"	public class X {\n" + 
+				"	             ^\n" + 
+				"The public type X must be defined in its own file\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399780
+	public void testStaticMethod13() {
+		runNegativeTest(
+				new String[] {
+						"C.java",
+						"interface A {\n" +
+						"	static void foo(String x) {\n" +
+						"       System.out.println(this);\n"+
+						"       System.out.println(super.hashCode());\n" +
+						"   }\n" +
+						"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in C.java (at line 3)\n" + 
+				"	System.out.println(this);\n" + 
+				"	                   ^^^^\n" + 
+				"Cannot use this in a static context\n" + 
+				"----------\n" + 
+				"2. ERROR in C.java (at line 4)\n" + 
+				"	System.out.println(super.hashCode());\n" + 
+				"	                   ^^^^^\n" + 
+				"Cannot use super in a static context\n" + 
 				"----------\n");
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 2d69447..b8442e3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -421,7 +421,8 @@ void setSourceStart(int sourceStart);
 	int DuplicateBlankFinalFieldInitialization = FieldRelated + 82;
 	/** @since 3.6 */
 	int UnresolvedVariable = FieldRelated + 83;
-
+	/** @since 3.9 */
+	int NonStaticOrAlienTypeReceiver = MethodRelated + 84;
 	// variable hiding
 	/** @since 3.0 */
 	int LocalVariableHidingLocalVariable = Internal + 90;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
index e5a3b37..bf582d6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
@@ -34,4 +34,5 @@ public interface ProblemReasons {
 	final int NoSuchSingleAbstractMethod = 17;
 	final int NotAWellFormedParameterizedType = 18;
 	final int IntersectionHasMultipleFunctionalInterfaces = 19;
+	final int NonStaticOrAlienTypeReceiver = 20;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 4a2172d..641d61f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -1355,12 +1355,8 @@ public abstract class Scope {
 		if (receiverTypeIsInterface) {
 			unitScope.recordTypeReference(receiverType);
 			MethodBinding[] receiverMethods = receiverType.getMethods(selector, argumentTypes.length);
-			for (int index = 0, length = receiverMethods.length; index < length; index++) {
-				MethodBinding binding = receiverMethods[index];
-				if (binding.canBeSeenBy(receiverType, invocationSite, this)) {
-					found.add(binding);
-				}
-			}
+			if (receiverMethods.length > 0)
+				found.addAll(receiverMethods);
 			findMethodInSuperInterfaces(receiverType, selector, found, invocationSite);
 			currentType = getJavaLangObject();
 		}
@@ -1515,37 +1511,31 @@ public abstract class Scope {
 
 		// tiebreak using visibility check
 		int visiblesCount = 0;
-		if (receiverTypeIsInterface) {
-			if (candidatesCount == 1) {
-				unitScope.recordTypeReferences(candidates[0].thrownExceptions);
-				return candidates[0];
-			}
-			visiblesCount = candidatesCount;
-		} else {
-			for (int i = 0; i < candidatesCount; i++) {
-				MethodBinding methodBinding = candidates[i];
-				if (methodBinding.canBeSeenBy(receiverType, invocationSite, this)) {
-					if (visiblesCount != i) {
-						candidates[i] = null;
-						candidates[visiblesCount] = methodBinding;
-					}
-					visiblesCount++;
+		for (int i = 0; i < candidatesCount; i++) {
+			MethodBinding methodBinding = candidates[i];
+			if (methodBinding.canBeSeenBy(receiverType, invocationSite, this)) {
+				if (visiblesCount != i) {
+					candidates[i] = null;
+					candidates[visiblesCount] = methodBinding;
 				}
+				visiblesCount++;
 			}
-			switch (visiblesCount) {
-				case 0 :
-					MethodBinding interfaceMethod =
-						findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, null);
-					if (interfaceMethod != null) return interfaceMethod;
-					return new ProblemMethodBinding(candidates[0], candidates[0].selector, candidates[0].parameters, ProblemReasons.NotVisible);
-				case 1 :
-					if (searchForDefaultAbstractMethod)
-						return findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, candidates[0]);
-					unitScope.recordTypeReferences(candidates[0].thrownExceptions);
-					return candidates[0];
-				default :
-					break;
-			}
+		}
+		switch (visiblesCount) {
+			case 0 :
+				MethodBinding interfaceMethod =
+				findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, null);
+				if (interfaceMethod != null) return interfaceMethod;
+				MethodBinding candidate = candidates[0];
+				return new ProblemMethodBinding(candidates[0], candidates[0].selector, candidates[0].parameters, 
+						candidate.isStatic() && candidate.declaringClass.isInterface() ? ProblemReasons.NonStaticOrAlienTypeReceiver : ProblemReasons.NotVisible);
+			case 1 :
+				if (searchForDefaultAbstractMethod)
+					return findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, candidates[0]);
+				unitScope.recordTypeReferences(candidates[0].thrownExceptions);
+				return candidates[0];
+			default :
+				break;
 		}
 
 		if (complianceLevel <= ClassFileConstants.JDK1_3) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 754f5d1..a47042e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -3978,6 +3978,20 @@ public void invalidMethod(MessageSend messageSend, MethodBinding method) {
 		case ProblemReasons.NonStaticReferenceInStaticContext :
 			id = IProblem.StaticMethodRequested;
 			break;
+		case ProblemReasons.NonStaticOrAlienTypeReceiver:
+			this.handle(
+					IProblem.NonStaticOrAlienTypeReceiver,
+					new String[] {
+							new String(method.declaringClass.readableName()),
+					        new String(method.selector),
+					},
+					new String[] {
+							new String(method.declaringClass.shortReadableName()),
+					        new String(method.selector),
+					},
+					(int) (messageSend.nameSourcePosition >>> 32),
+					(int) messageSend.nameSourcePosition);
+			return;
 		case ProblemReasons.ReceiverTypeNotVisible :
 			this.handle(
 				IProblem.NotVisibleType,	// cannot occur in javadoc comments
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 8533bb6..00d8dc1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -97,6 +97,7 @@
 81 = The blank final field {0} may not have been initialized
 82 = The final field {0} may already have been assigned
 83 = {0} cannot be resolved to a variable
+84 = This static method of interface {0} can only be accessed as {0}.{1}
 
 90 = The local variable {0} is hiding another local variable defined in an enclosing scope
 91 = The local variable {0} is hiding a field from type {1}
