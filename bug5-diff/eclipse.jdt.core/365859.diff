commit f59cd62ee82097eb13f8e87f8fbab8b81f747c29
Author: Stephan Herrmann <sherrmann>
Date:   Sun Mar 11 23:24:22 2012 +0100

    HEAD - Fixed bug 365859: [compiler][null] distinguish warnings based on
    flow analysis vs. null annotations

3	3	org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
8	7	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
7	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
96	73	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
15	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
11	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
5	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
21	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
5	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
10	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
92	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
7	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java b/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
index d3f06d4..f878042 100644
--- a/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
+++ b/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
@@ -1428,7 +1428,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		env.addClass( this.srcRoot, "p1", "Test2", test2CodeB );
 		incrementalBuild( this.projectPath );
 		expectingProblemsFor(test1Path, 
-				"Problem : Type mismatch: required \'@NonNull String\' but the provided value is null [ resource : </Project/src/p1/Test1.java> range : <81,85> category : <90> severity : <2>]");
+				"Problem : Null type mismatch: required \'@NonNull String\' but the provided value is null [ resource : </Project/src/p1/Test1.java> range : <81,85> category : <90> severity : <2>]");
 
 		// verify that Test1 was recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.Test1", "p1.Test2" });
@@ -1481,7 +1481,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		env.addClass( this.srcRoot, "p1", "Test2", test2CodeB );
 		incrementalBuild( this.projectPath );
 		expectingProblemsFor(test1Path, 
-			"Problem : Type mismatch: required \'@NonNull Object\' but the provided value can be null [ resource : </Project/src/p1/Test1.java> range : <126,143> category : <90> severity : <2>]");
+			"Problem : Null type mismatch: required \'@NonNull Object\' but the provided value is inferred as @Nullable [ resource : </Project/src/p1/Test1.java> range : <126,143> category : <90> severity : <2>]");
 
 		// verify that Test1 was recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.Test1", "p1.Test2" });
@@ -1494,7 +1494,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		env.addClass( this.srcRoot, "p1", "Test2", test2CodeC );
 		incrementalBuild( this.projectPath );
 		expectingProblemsFor(test1Path, 
-			"Problem : Potential type mismatch: required \'@NonNull Object\' but nullness of the provided value is unknown [ resource : </Project/src/p1/Test1.java> range : <126,143> category : <90> severity : <1>]");
+			"Problem : Null type safety: The expression of type Object needs unchecked conversion to conform to \'@NonNull Object\' [ resource : </Project/src/p1/Test1.java> range : <126,143> category : <90> severity : <1>]");
 
 		// verify that Test1 was recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.Test1", "p1.Test2" });
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 2bce5c6..2d3304d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -17,6 +17,7 @@
  *     							bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365208 - [compiler][batch] command line options for annotation based null analysis
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
+ *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -79,7 +80,7 @@ public class BatchCompilerTest extends AbstractRegressionTest {
 			"}\n";
 
 	static {
-		TESTS_NAMES = new String[] { "test315_warn_options_a" };
+//		TESTS_NAMES = new String[] { "test315_warn_options_a" };
 //		TESTS_NUMBERS = new int[] { 306 };
 //		TESTS_RANGE = new int[] { 298, -1 };
 	}
@@ -12462,12 +12463,12 @@ public void test312_warn_options() {
 		"3. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 8)\n" + 
 		"	if (o.toString() == \"\"){ return null;}\n" + 
 		"	                                ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"4. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" + 
 		"	if (o2 == null) {}\n" + 
 		"	    ^^\n" + 
-		"Null comparison always yields false: The variable o2 cannot be null at this location\n" + 
+		"Null comparison always yields false: The variable o2 is specified as @NonNull\n" + 
 		"----------\n" + 
 		"5. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 10)\n" + 
 		"	goo(null).toString();\n" + 
@@ -12477,22 +12478,22 @@ public void test312_warn_options() {
 		"6. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 10)\n" + 
 		"	goo(null).toString();\n" + 
 		"	    ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"7. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 13)\n" + 
 		"	return null;\n" + 
 		"	       ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"8. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 19)\n" + 
 		"	if (o2 == null){}\n" + 
 		"	    ^^\n" + 
-		"Null comparison always yields false: The variable o2 cannot be null at this location\n" + 
+		"Null comparison always yields false: The variable o2 is specified as @NonNull\n" + 
 		"----------\n" + 
 		"9. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 20)\n" + 
 		"	if (o2 == null){\n" + 
 		"	    ^^\n" + 
-		"Null comparison always yields false: The variable o2 cannot be null at this location\n" + 
+		"Null comparison always yields false: The variable o2 is specified as @NonNull\n" + 
 		"----------\n" + 
 		"9 problems (9 warnings)", 
 		true);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index f86c58a..3c7d632 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -13,6 +13,7 @@
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *     							bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
+ *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -797,6 +798,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullMessageSend", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("RedundantNullCheckOnSpecdNonNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotation", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotationPackage", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotationType", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
@@ -805,6 +807,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("ReferenceToForwardField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedNull", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedPotentialNull", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("RequiredNonNullButProvidedSpecdNullable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedUnknown", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ReferenceToForwardTypeVariable", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("ResourceHasToImplementAutoCloseable", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
@@ -818,6 +821,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("SafeVarargsOnNonFinalInstanceMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("ShouldImplementHashcode", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ShouldReturnValue", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("SpecdNonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("StaticInheritedMethodConflicts", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("StaticMemberOfParameterizedType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("StaticMethodRequested", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
@@ -1494,6 +1498,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullMessageSend", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("RedundantNullCheckOnSpecdNonNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotationPackage", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotationType", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
@@ -1504,6 +1509,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("RequiredNonNullButProvidedNull", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedPotentialNull", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedUnknown", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO));
+		expectedProblemAttributes.put("RequiredNonNullButProvidedSpecdNullable", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("ResourceHasToImplementAutoCloseable", SKIP);
 		expectedProblemAttributes.put("ReturnTypeAmbiguous", SKIP);
 		expectedProblemAttributes.put("ReturnTypeCannotBeVoidArray", SKIP);
@@ -1515,6 +1521,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("SafeVarargsOnNonFinalInstanceMethod", SKIP);
 		expectedProblemAttributes.put("ShouldImplementHashcode", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_HASHCODE_METHOD));
 		expectedProblemAttributes.put("ShouldReturnValue", SKIP);
+		expectedProblemAttributes.put("SpecdNonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("StaticInheritedMethodConflicts", SKIP);
 		expectedProblemAttributes.put("StaticMemberOfParameterizedType", SKIP);
 		expectedProblemAttributes.put("StaticMethodRequested", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 738bfdd..0ad4ccf 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -206,7 +206,7 @@ public void test_nonnull_parameter_001() {
 		"1. ERROR in X.java (at line 4)\n" +
 		"	if (o != null)\n" +
 		"	    ^\n" +
-		"Redundant null check: The variable o cannot be null at this location\n" +
+		"Redundant null check: The variable o is specified as @NonNull\n" +
 		"----------\n",
 		this.LIBS,
 		true /* shouldFlush*/);
@@ -255,7 +255,7 @@ public void test_nonnull_parameter_003() {
 		"1. ERROR in X.java (at line 7)\n" +
 		"	foo(null);\n" +
 		"	    ^^^^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
 		"----------\n",
 		this.LIBS,
 		true /* shouldFlush*/);
@@ -288,7 +288,7 @@ public void test_nonnull_parameter_004() {
 		"1. ERROR in X.java (at line 5)\n" +
 		"	l.setObject(o);\n" +
 		"	            ^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is inferred as @Nullable\n" +
 		"----------\n");
 }
 // passing unknown value to nonnull parameter  - target method is consumed from .class
@@ -317,7 +317,7 @@ public void test_nonnull_parameter_005() {
 		"1. WARNING in X.java (at line 3)\n" +
 		"	l.setObject(o);\n" +
 		"	            ^\n" +
-		"Potential type mismatch: required \'@NonNull Object\' but nullness of the provided value is unknown\n" +
+		"Null type safety: The expression of type Object needs unchecked conversion to conform to \'@NonNull Object\'\n" +
 		"----------\n");
 }
 // a ternary non-null expression is passed to a nonnull parameter
@@ -362,7 +362,7 @@ public void test_nonnull_parameter_007() {
 		"1. ERROR in XSub.java (at line 4)\n" +
 		"	super(b);\n" +
 		"	      ^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is specified as @Nullable\n" +
 		"----------\n");
 }
 // a nullable value is passed to a non-null parameter in an allocation expression
@@ -384,7 +384,7 @@ public void test_nonnull_parameter_008() {
 		"1. ERROR in X.java (at line 5)\n" +
 		"	return new X(b);\n" +
 		"	             ^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is specified as @Nullable\n" +
 		"----------\n"  /* compiler output */);
 }
 // a nullable value is passed to a non-null parameter in a qualified allocation expression
@@ -408,7 +408,7 @@ public void test_nonnull_parameter_009() {
 		"1. ERROR in X.java (at line 7)\n" +
 		"	return this.new Local(b);\n" +
 		"	                      ^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is specified as @Nullable\n" +
 		"----------\n"  /* compiler output */);
 }
 // null is passed to a non-null parameter in a qualified allocation expression, across CUs
@@ -438,12 +438,12 @@ public void test_nonnull_parameter_010() {
 		"1. ERROR in X.java (at line 3)\n" + 
 		"	ContainingInner2 container = new ContainingInner2(null);\n" + 
 		"	                                                  ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"2. ERROR in X.java (at line 4)\n" + 
 		"	ContainingInner2.Inner inner = container.new Inner(null);\n" + 
 		"	                                                   ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n"  /* compiler output */);
 }
 // null is passed to a non-null parameter in a qualified allocation expression, target class read from .class
@@ -479,12 +479,12 @@ public void test_nonnull_parameter_011() {
 		"1. ERROR in X.java (at line 3)\n" + 
 		"	ContainingInner2 container = new ContainingInner2(null);\n" + 
 		"	                                                  ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"2. ERROR in X.java (at line 4)\n" + 
 		"	ContainingInner2.Inner inner = container.new Inner(null);\n" + 
 		"	                                                   ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n"  /* compiler output */);
 }
 // null is passed to a non-null parameter in a qualified allocation expression, generic constructor, target class read from .class
@@ -520,12 +520,12 @@ public void test_nonnull_parameter_012() {
 		"1. ERROR in X.java (at line 3)\n" + 
 		"	ContainingInner2 container = new ContainingInner2(null);\n" + 
 		"	                                                  ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"2. ERROR in X.java (at line 4)\n" + 
 		"	ContainingInner2.Inner inner = container.new Inner(null);\n" + 
 		"	                                                   ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n"  /* compiler output */);
 }
 // a method of a local class has a non-null parameter, client passes null
@@ -548,7 +548,7 @@ public void test_nonnull_parameter_013() {
 		"1. ERROR in B.java (at line 8)\n" + 
 		"	l.callMe(null);\n" + 
 		"	         ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n");
 }
 // non-null varargs (message send)
@@ -584,12 +584,12 @@ public void test_nonnull_parameter_015() {
 			"1. ERROR in X.java (at line 4)\n" + 
 			"	if (o != null)\n" + 
 			"	    ^\n" + 
-			"Redundant null check: The variable o cannot be null at this location\n" + 
+			"Redundant null check: The variable o is specified as @NonNull\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 14)\n" + 
 			"	foo(objs);\n" + 
 			"	    ^^^^\n" + 
-			"Type mismatch: required \'@NonNull Object[]\' but the provided value is null\n" + 
+			"Null type mismatch: required \'@NonNull Object[]\' but the provided value is null\n" + 
 			"----------\n" + 
 			"3. WARNING in X.java (at line 18)\n" + 
 			"	foo2(2, null);\n" + 
@@ -599,7 +599,7 @@ public void test_nonnull_parameter_015() {
 			"4. ERROR in X.java (at line 18)\n" + 
 			"	foo2(2, null);\n" + 
 			"	        ^^^^\n" + 
-			"Type mismatch: required \'@NonNull Object[]\' but the provided value is null\n" + 
+			"Null type mismatch: required \'@NonNull Object[]\' but the provided value is null\n" + 
 			"----------\n",
 		this.LIBS,
 		true /* shouldFlush*/);
@@ -640,17 +640,17 @@ public void test_nonnull_parameter_016() {
 			"1. ERROR in X.java (at line 4)\n" +
 			"	if (o != null)\n" +
 			"	    ^\n" +
-			"Redundant null check: The variable o cannot be null at this location\n" +
+			"Redundant null check: The variable o is specified as @NonNull\n" +
 			"----------\n" +
 			"2. ERROR in X.java (at line 16)\n" +
 			"	new X((Object[])null);\n" +
 			"	      ^^^^^^^^^^^^^^\n" +
-			"Type mismatch: required \'@NonNull Object[]\' but the provided value is null\n" +
+			"Null type mismatch: required \'@NonNull Object[]\' but the provided value is null\n" +
 			"----------\n" +
 			"3. ERROR in X.java (at line 21)\n" +
 			"	this.new Y(2, (Object[])null);\n" +
 			"	              ^^^^^^^^^^^^^^\n" +
-			"Type mismatch: required \'@NonNull Object[]\' but the provided value is null\n" +
+			"Null type mismatch: required \'@NonNull Object[]\' but the provided value is null\n" +
 			"----------\n",
 		this.LIBS,
 		true /* shouldFlush*/);
@@ -674,12 +674,12 @@ public void test_nonnull_argument_001() {
 			"1. ERROR in ShowNPE2.java (at line 5)\n" + 
 			"	o1 = null;   // expect NPE error\n" + 
 			"	     ^^^^\n" + 
-			"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+			"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 			"----------\n" + 
 			"2. ERROR in ShowNPE2.java (at line 7)\n" + 
 			"	return null;  // expect NPE error\n" + 
 			"	       ^^^^\n" + 
-			"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+			"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 			"----------\n");
 }
 // Bug 367203 - [compiler][null] detect assigning null to nonnull argument
@@ -701,7 +701,7 @@ public void test_nonnull_argument_002() {
 			"1. ERROR in ShowNPE2.java (at line 6)\n" + 
 			"	return null;  // expect NPE error\n" + 
 			"	       ^^^^\n" + 
-			"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+			"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 			"----------\n");
 }
 // a method of a local class has a non-null parameter, client passes potential null (msg send)
@@ -725,7 +725,7 @@ public void test_nonnull_parameter_014() {
 		"1. ERROR in B.java (at line 8)\n" + 
 		"	l.callMe(getNull());\n" + 
 		"	         ^^^^^^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is inferred as @Nullable\n" + 
 		"----------\n");
 }
 // assigning potential null to a nonnull local variable
@@ -746,17 +746,17 @@ public void test_nonnull_local_001() {
 		"1. ERROR in X.java (at line 4)\n" +
 		"	@NonNull Object o1 = b ? null : new Object();\n" +
 		"	                     ^^^^^^^^^^^^^^^^^^^^^^^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is inferred as @Nullable\n" +
 		"----------\n" +
 		"2. ERROR in X.java (at line 6)\n" +
 		"	o2 = null;\n" +
 		"	     ^^^^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value is null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" +
 		"----------\n" +
 		"3. WARNING in X.java (at line 7)\n" +
 		"	@NonNull Object o3 = p;\n" +
 		"	                     ^\n" +
-		"Potential type mismatch: required \'@NonNull Object\' but nullness of the provided value is unknown\n" +
+		"Null type safety: The expression of type Object needs unchecked conversion to conform to \'@NonNull Object\'\n" +
 		"----------\n",
 		this.LIBS,
 		true /* shouldFlush*/);
@@ -783,17 +783,17 @@ public void test_nonnull_local_002() {
 		"1. ERROR in X.java (at line 5)\n" +
 		"	o1 = b ? null : new Object();\n" +
 		"	     ^^^^^^^^^^^^^^^^^^^^^^^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is inferred as @Nullable\n" +
 		"----------\n" +
 		"2. ERROR in X.java (at line 8)\n" +
 		"	o2 = null;\n" +
 		"	     ^^^^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value is null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" +
 		"----------\n" +
 		"3. WARNING in X.java (at line 10)\n" +
 		"	o3 = p;\n" +
 		"	     ^\n" +
-		"Potential type mismatch: required \'@NonNull Object\' but nullness of the provided value is unknown\n" +
+		"Null type safety: The expression of type Object needs unchecked conversion to conform to \'@NonNull Object\'\n" +
 		"----------\n",
 		this.LIBS,
 		true /* shouldFlush*/);
@@ -1027,7 +1027,7 @@ public void test_parameter_specification_inheritance_007a() {
 		"1. ERROR in X.java (at line 4)\n" +
 		"	@NonNull Object getObject() { return null; }\n" +
 		"	                                     ^^^^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
 		"----------\n");
 }
 // a client potentially violates the inherited null specification, super interface declares @NonNull parameter
@@ -1071,7 +1071,7 @@ public void test_parameter_specification_inheritance_008() {
 		"1. ERROR in M.java (at line 3)\n" +
 		"	x.printObject(o);\n" +
 		"	              ^\n" +
-		"Potential type mismatch: required \'@NonNull Object\' but nullness of the provided value is unknown\n" +
+		"Null type safety: The expression of type Object needs unchecked conversion to conform to \'@NonNull Object\'\n" +
 		"----------\n");
 }
 // a static method has a more relaxed null contract than a like method in the super class, but no overriding.
@@ -1156,7 +1156,7 @@ public void test_parameter_specification_inheritance_011() {
 		"1. ERROR in p1\\Y.java (at line 7)\n" +
 		"	return super.getString(null);\n" +
 		"	                       ^^^^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value is null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" +
 		"----------\n");
 }
 // methods from two super types have different null contracts.
@@ -1418,7 +1418,7 @@ public void test_nonnull_return_003() {
 		"1. ERROR in X.java (at line 5)\n" +
 		"	return null;\n" +
 		"	       ^^^^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
 		"----------\n");
 }
 // a non-null method potentially returns null
@@ -1438,7 +1438,7 @@ public void test_nonnull_return_004() {
 		"1. ERROR in X.java (at line 4)\n" +
 		"	return o;\n" +
 		"	       ^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" +
 		"----------\n");
 }
 // a non-null method returns its non-null argument
@@ -1472,7 +1472,7 @@ public void test_nonnull_return_006() {
 		"1. WARNING in X.java (at line 4)\n" +
 		"	return o;\n" +
 		"	       ^\n" +
-		"Potential type mismatch: required \'@NonNull Object\' but nullness of the provided value is unknown\n" +
+		"Null type safety: The expression of type Object needs unchecked conversion to conform to \'@NonNull Object\'\n" +
 		"----------\n");
 }
 // a result from a nullable method is directly dereferenced
@@ -1669,7 +1669,7 @@ public void test_nonnull_return_011() {
 		"1. ERROR in X.java (at line 5)\n" +
 		"	if (dubious == null)\n" +
 		"	    ^^^^^^^\n" +
-		"Null comparison always yields false: The variable dubious cannot be null at this location\n" +
+		"Null comparison always yields false: The variable dubious is specified as @NonNull\n" +
 		"----------\n" +
 		"2. WARNING in X.java (at line 6)\n" +
 		"	return dubious;\n" +
@@ -1704,7 +1704,7 @@ public void _test_nonnull_return_012() {
 		"2. ERROR in X.java (at line 5)\n" +
 		"	return dubious == null ? dubious : null;\n" +
 		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
 		"----------\n");
 }
 // don't apply any default annotations to return void
@@ -1753,15 +1753,15 @@ public void test_nonnull_return_014() {
 		"1. ERROR in X.java (at line 9)\n" + 
 		"	local = x;  // error\n" + 
 		"	        ^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is inferred as @Nullable\n" + 
 		"----------\n" + 
 		"2. ERROR in X.java (at line 10)\n" + 
 		"	return x;   // only a warning.\n" + 
 		"	       ^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is inferred as @Nullable\n" + 
 		"----------\n");
 }
-//suppress an error regarding null-spec violation
+// suppress an error regarding null-spec violation
 public void test_suppress_001() {
 	Map customOptions = getCompilerOptions();
 	customOptions.put(JavaCore.COMPILER_PB_SUPPRESS_OPTIONAL_ERRORS, JavaCore.ENABLED);
@@ -1875,7 +1875,7 @@ public void test_annotation_import_005() {
 		"1. ERROR in X.java (at line 4)\n" +
 		"	return l.getObject();\n" +
 		"	       ^^^^^^^^^^^^^\n" +
-		"Potential type mismatch: required \'@MustNotBeNull Object\' but nullness of the provided value is unknown\n" +
+		"Null type safety: The expression of type Object needs unchecked conversion to conform to \'@MustNotBeNull Object\'\n" +
 		"----------\n",
 		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
@@ -2168,7 +2168,7 @@ public void test_default_nullness_003() {
 		"2. ERROR in p2\\Y.java (at line 6)\n" +
 		"	bar(o);\n" +
 		"	    ^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" +
 		"----------\n");
 }
 // package level default is consumed from package-info.class, similarly for type level default
@@ -2220,12 +2220,12 @@ public void test_default_nullness_003a() {
 		"2. ERROR in p2\\Y.java (at line 6)\n" +
 		"	bar(o);\n" +
 		"	    ^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" +
 		"----------\n" +
 		"3. ERROR in p2\\Y.java (at line 7)\n" +
 		"	accept(o);\n" +
 		"	       ^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" +
 		"----------\n");
 }
 // same as test_default_nullness_003a, but default-induced annotations are combined with explicit ones (not null related)
@@ -2283,12 +2283,12 @@ public void test_default_nullness_003b() {
 		"2. ERROR in p2\\Y.java (at line 6)\n" +
 		"	bar(o);\n" +
 		"	    ^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" +
 		"----------\n" +
 		"3. ERROR in p2\\Y.java (at line 7)\n" +
 		"	accept(o);\n" +
 		"	       ^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is specified as @Nullable\n" +
 		"----------\n");
 }
 // don't apply type-level default to non-reference type
@@ -2347,7 +2347,7 @@ public void test_default_nullness_005() {
 		"1. ERROR in p1\\X.java (at line 4)\n" +
 		"	return null;\n" +
 		"	       ^^^^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
 		"----------\n");
 }
 // package default is non-null, package-info.java read before the annotation type
@@ -2378,7 +2378,7 @@ public void test_default_nullness_006() {
 		"1. ERROR in p1\\X.java (at line 4)\n" +
 		"	return null;\n" +
 		"	       ^^^^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
 		"----------\n");
 }
 // global default nonnull, but return may be null
@@ -2406,7 +2406,7 @@ public void _test_default_nullness_007() {
 		"1. ERROR in X.java (at line 7)\n" +
 		"	return dangerous();\n" +
 		"	       ^^^^^^^^^^^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is inferred as @Nullable\n" +
 		"----------\n");
 }
 
@@ -2481,7 +2481,7 @@ public void test_default_nullness_009() {
 		"1. ERROR in p2\\Y.java (at line 11)\n" +
 		"	bar(o); // error: arg is declared @NonNull\n" +
 		"	    ^\n" +
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
 		"----------\n");
 }
 // non-null declarations are redundant within a default scope.
@@ -2541,12 +2541,12 @@ public void test_default_nullness_011() {
 		"1. ERROR in Main.java (at line 4)\n" + 
 		"	o = null;\n" + 
 		"	    ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"2. ERROR in Main.java (at line 5)\n" + 
 		"	new C(null);\n" + 
 		"	      ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"----------\n" + 
 		"1. WARNING in p1\\C.java (at line 2)\n" + 
@@ -2578,7 +2578,7 @@ public void test_default_nullness_012() {
 		"1. ERROR in X.java (at line 11)\n" + 
 		"	new local().zoo(null); // defaults applying from foo\n" + 
 		"	                ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n");
 }
 // Bug 365836 - [compiler][null] Incomplete propagation of null defaults.
@@ -2607,7 +2607,7 @@ public void test_default_nullness_013() {
 		"1. ERROR in X.java (at line 11)\n" + 
 		"	return null; // defaults applying from foo\n" + 
 		"	       ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n");
 }
 // bug 367154 - [compiler][null] Problem in propagating null defaults.
@@ -2637,7 +2637,7 @@ public void test_default_nullness_014() {
 		"1. ERROR in X.java (at line 12)\n" + 
 		"	return null;  // expect error here\n" + 
 		"	       ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n");
 }
 // bug 367154 - [compiler][null] Problem in propagating null defaults.
@@ -2667,7 +2667,7 @@ public void test_default_nullness_015() {
 		"1. ERROR in X.java (at line 11)\n" + 
 		"	return null;  // expect error here\n" + 
 		"	       ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n");
 }
 
@@ -3031,12 +3031,12 @@ public void test_nonnull_var_in_constrol_structure_1() {
 		"2. ERROR in X.java (at line 10)\n" +
 		"	print(s);\n" +
 		"	      ^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is specified as @Nullable\n" +
 		"----------\n" +
 		"3. ERROR in X.java (at line 15)\n" +
 		"	print(s);\n" +
 		"	      ^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is inferred as @Nullable\n" +
 		"----------\n" +
 		"4. WARNING in X.java (at line 17)\n" +
 		"	void print(@NonNull String s) {\n" +
@@ -3083,12 +3083,12 @@ public void test_nonnull_var_in_constrol_structure_2() {
 		"1. ERROR in X.java (at line 10)\n" +
 		"	print(s);\n" +
 		"	      ^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is specified as @Nullable\n" +
 		"----------\n" +
 		"2. ERROR in X.java (at line 16)\n" +
 		"	print(s);\n" +
 		"	      ^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is inferred as @Nullable\n" +
 		"----------\n");
 }
 // a nonnull variable is dereferenced in a finally block inside a loop
@@ -3130,12 +3130,12 @@ public void test_nonnull_var_in_constrol_structure_3() {
 		"1. ERROR in X.java (at line 12)\n" +
 		"	print(s);\n" +
 		"	      ^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is specified as @Nullable\n" +
 		"----------\n" +
 		"2. ERROR in X.java (at line 19)\n" +
 		"	print(s);\n" +
 		"	      ^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is inferred as @Nullable\n" +
 		"----------\n");
 }
 // witness for an AIOOBE in FlowContext.recordExpectedType()
@@ -3244,7 +3244,30 @@ public void test_message_send_in_control_structure_02() {
 		"1. WARNING in Bug370930.java (at line 5)\n" + 
 		"	for(@NonNull String s: list) { // warning here: insufficient info on elements\n" + 
 		"	                       ^^^^\n" + 
-		"Potential type mismatch: required \'@NonNull String\' but nullness of the provided value is unknown\n" + 
+		"Null type safety: The expression of type String needs unchecked conversion to conform to \'@NonNull String\'\n" + 
+		"----------\n");
+}
+//Bug 370930 - NonNull annotation not considered for enhanced for loops over array
+public void test_message_send_in_control_structure_02a() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"Bug370930.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Bug370930 {\n" +
+			"	void loop(String[] array) {\n" + 
+			"		for(@NonNull String s: array) { // warning here: insufficient info on elements\n" + 
+			"			expectNonNull(s); // no warning here\n" + 
+			"		}\n" + 
+			"	}\n" + 
+			"	\n" + 
+			"	void expectNonNull(@NonNull String s) {}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in Bug370930.java (at line 4)\n" + 
+		"	for(@NonNull String s: array) { // warning here: insufficient info on elements\n" + 
+		"	                       ^^^^^\n" + 
+		"Null type safety: The expression of type String needs unchecked conversion to conform to \'@NonNull String\'\n" + 
 		"----------\n");
 }
 //Bug 370930 - NonNull annotation not considered for enhanced for loops
@@ -3268,7 +3291,7 @@ public void test_message_send_in_control_structure_03() {
 		"1. ERROR in Bug370930.java (at line 6)\n" + 
 		"	expectNonNull(s); // warning here\n" + 
 		"	              ^\n" + 
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is specified as @Nullable\n" + 
 		"----------\n");
 }
 public void test_assignment_expression_1() {
@@ -3347,12 +3370,12 @@ public void test_nesting_1() {
 		"1. ERROR in X.java (at line 16)\n" +
 		"	print(s2);\n" +
 		"	      ^^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is specified as @Nullable\n" +
 		"----------\n" +
 		"2. ERROR in X.java (at line 25)\n" +
 		"	@NonNull String s3R = s3;\n" +
 		"	                      ^^\n" +
-		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"Null type mismatch: required \'@NonNull String\' but the provided value is inferred as @Nullable\n" +
 		"----------\n");
 }
 // Test a regression incurred to the OT/J based implementation
@@ -3427,7 +3450,7 @@ public void test_options_02() {
 		"1. ERROR in Test.java (at line 3)\n" + 
 		"	o = null;\n" + 
 		"	    ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"2. ERROR in Test.java (at line 5)\n" + 
 		"	if (p == null)\n" + 
@@ -3461,7 +3484,7 @@ public void test_options_03() {
 		"1. WARNING in Test.java (at line 3)\n" + 
 		"	o = null;\n" + 
 		"	    ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"2. ERROR in Test.java (at line 5)\n" + 
 		"	if (p == null)\n" + 
@@ -3506,22 +3529,22 @@ public void testBug372011() {
 		"1. ERROR in X.java (at line 7)\n" + 
 		"	new T11().t11foo(null);\n" + 
 		"	                 ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"2. ERROR in X.java (at line 8)\n" + 
 		"	new T12().new T122().foo122(null);\n" + 
 		"	                            ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"3. ERROR in X.java (at line 11)\n" + 
 		"	o.bar(null);\n" + 
 		"	      ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n" + 
 		"4. ERROR in X.java (at line 15)\n" + 
 		"	new T12().new T122().new T1222().foo1222(null);\n" + 
 		"	                                         ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 		"----------\n",
 		libs,
 		true /* shouldFlush*/);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
index 0b7944a..0ecffea 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
@@ -113,7 +113,7 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 					"1. WARNING in /P/p2/C2.java (at line 8)\n" +
 					"	return arg == null ? null : arg.toString();\n" +
 					"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-					"Potential type mismatch: required \'@NonNull String\' but nullness of the provided value is unknown\n" +
+					"Null type safety: The expression of type String needs unchecked conversion to conform to \'@NonNull String\'\n" +
 					"----------\n");
     	} finally {
     		deleteProject("P");
@@ -155,7 +155,7 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 					"1. WARNING in /P/p2/C2.java (at line 8)\n" +
 					"	return arg == null ? null : arg.toString();\n" +
 					"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-					"Potential type mismatch: required \'@NonNull String\' but nullness of the provided value is unknown\n" +
+					"Null type safety: The expression of type String needs unchecked conversion to conform to \'@NonNull String\'\n" +
 					"----------\n");
     	} finally {
     		deleteProject("P");
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index c7be28d..5a8ee0e 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -51,6 +51,18 @@ Eclipse SDK 3.8.0 - %date% - 3.8.0 M6
 (<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_C38">cvs</a>).
 <h2>What's new in this drop</h2>
 <ul>
+<li> New IProblems for distinguishing null warnings based on flow analysis vs. null annotations.
+<pre>
+	/** @since 3.8 */
+	int RedundantNullCheckOnSpecdNonNullLocalVariable = Internal + 931;
+
+	/** @since 3.8 */
+	int SpecdNonNullLocalVariableComparisonYieldsFalse = Internal + 932;
+
+	/** @since 3.8 */
+	int RequiredNonNullButProvidedSpecdNullable = Internal + 933;
+</pre>
+</li>
 <li> New IProblems for reporting missing NonNullByDefault annotation on package/type.
 <pre>
 	/** @since 3.8 */
@@ -86,7 +98,9 @@ Eclipse SDK 3.8.0 - %date% - 3.8.0 M6
 </ul>
 
 <h3>Problem Reports Fixed</h3>
-<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=373571">373571</a>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=365859">365859</a>
+[compiler][null] distinguish warnings based on flow analysis vs. null annotations
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=373571">373571</a>
 [null][regression] Incorrect application of null annotations to primitive types
 <br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=367836">367836</a>
 Inconsistent source range for error from build and reconciler (declared package does not match expected)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index b88354d..7a29115 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -140,6 +140,10 @@
  *									RedundantNullDefaultAnnotationType
  *									RedundantNullDefaultAnnotationMethod
  *									ContradictoryNullAnnotations
+ *									IllegalAnnotationForBaseType
+ *									RedundantNullCheckOnSpecdNonNullLocalVariable
+ *									SpecdNonNullLocalVariableComparisonYieldsFalse
+ *									RequiredNonNullButProvidedSpecdNullable
  *******************************************************************************/
 package org.eclipse.jdt.core.compiler;
 
@@ -1467,7 +1471,7 @@ void setSourceStart(int sourceStart);
 	/** @since 3.8 */
 	int IllegalAnnotationForBaseType = TypeRelated + 923;
 	/** @since 3.8 */
-	int RedundantNullDefaultAnnotation = Internal + 925;
+	int RedundantNullDefaultAnnotation = Internal + 925; // shouldn't actually occur any more after bug 366063
 	/** @since 3.8 */
 	int RedundantNullDefaultAnnotationPackage = Internal + 926;
 	/** @since 3.8 */
@@ -1478,6 +1482,12 @@ void setSourceStart(int sourceStart);
 	int ContradictoryNullAnnotations = Internal + 929;
 	/** @since 3.8 */
 	int MissingNonNullByDefaultAnnotationOnType = Internal + 930; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
+	/** @since 3.8 */
+	int RedundantNullCheckOnSpecdNonNullLocalVariable = Internal + 931;
+	/** @since 3.8 */
+	int SpecdNonNullLocalVariableComparisonYieldsFalse = Internal + 932;
+	/** @since 3.8 */
+	int RequiredNonNullButProvidedSpecdNullable = Internal + 933;
 
 	/**
 	 * External problems -- These are problems defined by other plugins
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index 3d4eda6..4dfe861 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -16,6 +16,7 @@
  *							bug 186342 - [compiler][null] Using annotations for null checking
  *							bug 358903 - Filter practically unimportant resource leak warnings
  *							bug 370639 - [compiler][resource] restore the default for resource leak warnings
+ *							bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -77,7 +78,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				FlowContext.CAN_ONLY_NULL | FlowContext.IN_ASSIGNMENT, flowInfo);
 		}
 	}
-	nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, local, nullStatus, this.expression);
+	nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, local, nullStatus, this.expression, this.expression.resolvedType);
 	if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
 		flowInfo.markNullStatus(local, nullStatus);
 		if (flowContext.initsOnFinally != null)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
index 78fef08..85ee809 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 370930 - NonNull annotation not considered for enhanced for loops
+ *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -103,7 +104,7 @@ public class ForeachStatement extends Statement {
 		if (currentScope.compilerOptions().isAnnotationBasedNullAnalysisEnabled) {
 			// this currently produces an unavoidable warning against all @NonNull element vars:
 			int nullStatus = this.elementVariable.checkAssignmentAgainstNullAnnotation(currentScope, flowContext, 
-															elementVarBinding, FlowInfo.UNKNOWN, this.collection);
+															elementVarBinding, FlowInfo.UNKNOWN, this.collection, this.collectionElementType);
 			// TODO (stephan): 	once we have JSR 308 fetch nullStatus from the collection element type
 			//              	and feed the result into the above check (instead of FlowInfo.UNKNOWN)
 			if ((elementVarBinding.type.tagBits & TagBits.IsBaseType) == 0) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index ca65c04..b2a9b30 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -15,6 +15,7 @@
  *							bug 186342 - [compiler][null] Using annotations for null checking
  *							bug 358903 - Filter practically unimportant resource leak warnings
  *							bug 370639 - [compiler][resource] restore the default for resource leak warnings
+ *							bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -104,7 +105,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		this.bits &= ~FirstAssignmentToLocal;  // int i = (i = 0);
 	}
 	flowInfo.markAsDefinitelyAssigned(this.binding);
-	nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, this.binding, nullStatus, this.initialization);
+	nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, this.binding, nullStatus, this.initialization, this.initialization.resolvedType);
 	if ((this.binding.type.tagBits & TagBits.IsBaseType) == 0) {
 		flowInfo.markNullStatus(this.binding, nullStatus);
 		// no need to inform enclosing try block since its locals won't get
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 081503c..5cd11cf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -17,6 +17,7 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
+ *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -150,7 +151,7 @@ void checkAgainstNullAnnotation(BlockScope scope, FlowContext flowContext, int n
 			return;			
 		}
 		if ((tagBits & TagBits.AnnotationNonNull) != 0) {
-			flowContext.recordNullityMismatch(scope, this.expression, nullStatus, methodBinding.returnType);
+			flowContext.recordNullityMismatch(scope, this.expression, this.expression.resolvedType, methodBinding.returnType, nullStatus);
 		}
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index e8ce295..c4b035b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -14,6 +14,7 @@
  *								bug 365983 - [compiler][null] AIOOB with null annotation analysis and varargs
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 370930 - NonNull annotation not considered for enhanced for loops
+ *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -92,7 +93,7 @@ protected void analyseArguments(BlockScope currentScope, FlowContext flowContext
 				Expression argument = arguments[i];
 				int nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.
 				if (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided
-					flowContext.recordNullityMismatch(currentScope, argument, nullStatus, expectedType);
+					flowContext.recordNullityMismatch(currentScope, argument, argument.resolvedType, expectedType, nullStatus);
 			}
 		}
 	}
@@ -100,12 +101,12 @@ protected void analyseArguments(BlockScope currentScope, FlowContext flowContext
 
 /** Check null-ness of 'local' against a possible null annotation */
 protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, FlowContext flowContext,
-												   LocalVariableBinding local, int nullStatus, Expression expression)
+												   LocalVariableBinding local, int nullStatus, Expression expression, TypeBinding providedType)
 {
 	if (local != null) {
 		if ((local.tagBits & TagBits.AnnotationNonNull) != 0
 				&& nullStatus != FlowInfo.NON_NULL) {
-			flowContext.recordNullityMismatch(currentScope, expression, nullStatus, local.type);
+			flowContext.recordNullityMismatch(currentScope, expression, providedType, local.type, nullStatus);
 			return FlowInfo.NON_NULL;
 		} else if ((local.tagBits & TagBits.AnnotationNullable) != 0
 				&& nullStatus == FlowInfo.UNKNOWN) {	// provided a legacy type?
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index e3d740f..5e7ad10 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -11,6 +11,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
+ *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -93,7 +94,7 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 		for (int i = 0; i < this.nullCount; i++) {
 			if ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == ASSIGN_TO_NONNULL)
 				this.parent.recordNullityMismatch(scope, (Expression)this.nullReferences[i],
-						flowInfo.nullStatus(this.nullLocals[i]), this.expectedTypes[i]);
+						this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], flowInfo.nullStatus(this.nullLocals[i]));
 			else
 				this.parent.recordUsingNullReference(scope, this.nullLocals[i],
 						this.nullReferences[i],	this.nullCheckTypes[i], flowInfo);
@@ -181,7 +182,7 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 					int nullStatus = flowInfo.nullStatus(local);
 					if (nullStatus != FlowInfo.NON_NULL) {
 						char[][] annotationName = scope.environment().getNonNullAnnotationName();
-						scope.problemReporter().nullityMismatch((Expression) location, this.expectedTypes[i], nullStatus, annotationName);
+						scope.problemReporter().nullityMismatch((Expression) location, this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], nullStatus, annotationName);
 					}
 					break;
 				default:
@@ -434,11 +435,11 @@ protected void recordNullReference(LocalVariableBinding local,
 	this.nullReferences[this.nullCount] = expression;
 	this.nullCheckTypes[this.nullCount++] = status;
 }
-protected boolean internalRecordNullityMismatch(Expression expression, int nullStatus, TypeBinding expectedType, int checkType) {
+protected boolean internalRecordNullityMismatch(Expression expression, TypeBinding providedType, int nullStatus, TypeBinding expectedType, int checkType) {
 	// cf. decision structure inside FinallyFlowContext.recordUsingNullReference(..)
 	if (nullStatus == FlowInfo.UNKNOWN ||
 			((this.tagBits & FlowContext.DEFER_NULL_DIAGNOSTIC) != 0 && nullStatus != FlowInfo.NULL)) {
-		recordExpectedType(expectedType, this.nullCount);
+		recordProvidedExpectedTypes(providedType, expectedType, this.nullCount);
 		recordNullReference(expression.localVariableBinding(), expression, checkType);
 		return true;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 5367ea1..b7031df 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -11,6 +11,7 @@
  *     							bug 358827 - [1.7] exception analysis for t-w-r spoils null analysis
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
+ *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -57,8 +58,8 @@ public class FlowContext implements TypeConstants {
 
 	public int tagBits;
 
-	// array to store the expected type from the potential error location (for display in error messages):
-	public TypeBinding[] expectedTypes = null;
+	// array to store the provided and expected types from the potential error location (for display in error messages):
+	public TypeBinding[][] providedExpectedTypes = null;
 
 	public static final int DEFER_NULL_DIAGNOSTIC = 0x1;
 	public static final int PREEMPT_NULL_DIAGNOSTIC = 0x2;
@@ -573,20 +574,20 @@ public boolean recordExitAgainstResource(BlockScope scope, FlowInfo flowInfo, Fa
 	return false; // not handled
 }
 
-protected void recordExpectedType(TypeBinding expectedType, int nullCount) {
+protected void recordProvidedExpectedTypes(TypeBinding providedType, TypeBinding expectedType, int nullCount) {
 	if (nullCount == 0) {
-		this.expectedTypes = new TypeBinding[5];
-	} else if (this.expectedTypes == null) {
+		this.providedExpectedTypes = new TypeBinding[5][];
+	} else if (this.providedExpectedTypes == null) {
 		int size = 5;
 		while (size <= nullCount) size *= 2;
-		this.expectedTypes = new TypeBinding[size];
+		this.providedExpectedTypes = new TypeBinding[size][];
 	}
-	else if (nullCount >= this.expectedTypes.length) {
-		int oldLen = this.expectedTypes.length;
-		System.arraycopy(this.expectedTypes, 0,
-			this.expectedTypes = new TypeBinding[nullCount * 2], 0, oldLen);
+	else if (nullCount >= this.providedExpectedTypes.length) {
+		int oldLen = this.providedExpectedTypes.length;
+		System.arraycopy(this.providedExpectedTypes, 0,
+			this.providedExpectedTypes = new TypeBinding[nullCount * 2][], 0, oldLen);
 	}
-	this.expectedTypes[nullCount] = expectedType;
+	this.providedExpectedTypes[nullCount] = new TypeBinding[]{providedType, expectedType};
 }
 
 protected boolean recordFinalAssignment(VariableBinding variable, Reference finalReference) {
@@ -790,10 +791,14 @@ public String toString() {
  * Record that a nullity mismatch was detected against an annotated type reference.
  * @param currentScope scope for error reporting
  * @param expression the expression violating the specification
- * @param nullStatus the null status of expression at the current location
+ * @param providedType the type of the provided value, i.e., either expression or an element thereof (in ForeachStatements)
  * @param expectedType the declared type of the spec'ed variable, for error reporting.
+ * @param nullStatus the null status of expression at the current location
  */
-public void recordNullityMismatch(BlockScope currentScope, Expression expression, int nullStatus, TypeBinding expectedType) {
+public void recordNullityMismatch(BlockScope currentScope, Expression expression, TypeBinding providedType, TypeBinding expectedType, int nullStatus) {
+	if (providedType == null) {
+		return; // assume type error was already reported
+	}
 	if (expression.localVariableBinding() != null) { // flowContext cannot yet handle non-localvar expressions (e.g., fields)
 		// find the inner-most flowContext that might need deferred handling:
 		FlowContext currentContext = this;
@@ -803,16 +808,16 @@ public void recordNullityMismatch(BlockScope currentScope, Expression expression
 			if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0) {
 				isInsideAssert = FlowContext.HIDE_NULL_COMPARISON_WARNING;
 			}
-			if (currentContext.internalRecordNullityMismatch(expression, nullStatus, expectedType, ASSIGN_TO_NONNULL | isInsideAssert))
+			if (currentContext.internalRecordNullityMismatch(expression, providedType, nullStatus, expectedType, ASSIGN_TO_NONNULL | isInsideAssert))
 				return;
 			currentContext = currentContext.parent;
 		}
 	}
 	// no reason to defer, so report now:
 	char[][] annotationName = currentScope.environment().getNonNullAnnotationName();
-	currentScope.problemReporter().nullityMismatch(expression, expectedType, nullStatus, annotationName);
+	currentScope.problemReporter().nullityMismatch(expression, providedType, expectedType, nullStatus, annotationName);
 }
-protected boolean internalRecordNullityMismatch(Expression expression, int nullStatus, TypeBinding expectedType, int checkType) {
+protected boolean internalRecordNullityMismatch(Expression expression, TypeBinding providedType, int nullStatus, TypeBinding expectedType, int checkType) {
 	// nop, to be overridden in subclasses
 	return false; // not recorded
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index bde8071..a15b17c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -12,6 +12,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
+ *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -250,7 +251,7 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 					}
 					break;
 				case ASSIGN_TO_NONNULL:
-					this.parent.recordNullityMismatch(scope, (Expression)location, flowInfo.nullStatus(local), this.expectedTypes[i]);
+					this.parent.recordNullityMismatch(scope, (Expression)location, this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], flowInfo.nullStatus(local));
 					break;
 				case EXIT_RESOURCE:
 						FakedTrackingVariable trackingVar = local.closeTracker;
@@ -361,7 +362,7 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 					int nullStatus = flowInfo.nullStatus(local);
 					if (nullStatus != FlowInfo.NON_NULL) {
 						char[][] annotationName = scope.environment().getNonNullAnnotationName();
-						scope.problemReporter().nullityMismatch((Expression) location, this.expectedTypes[i], nullStatus, annotationName);
+						scope.problemReporter().nullityMismatch((Expression) location, this.providedExpectedTypes[i][0], this.providedExpectedTypes[i][1], nullStatus, annotationName);
 					}
 					break;
 				case EXIT_RESOURCE:
@@ -707,8 +708,8 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 		return this.escapingExceptionCatchSites != null;
 	}
 
-	protected boolean internalRecordNullityMismatch(Expression expression, int nullStatus, TypeBinding expectedType, int checkType) {
-		recordExpectedType(expectedType, this.nullCount);
+	protected boolean internalRecordNullityMismatch(Expression expression, TypeBinding providedType, int nullStatus, TypeBinding expectedType, int checkType) {
+		recordProvidedExpectedTypes(providedType, expectedType, this.nullCount);
 		recordNullReference(expression.localVariableBinding(), expression, checkType);
 		return true;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
index 5f6ea20..1a46b85 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,7 @@
  *     							bug 185682 - Increment/decrement operators mark local variables as read
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 186342 - [compiler][null] Using annotations for null checking
+ *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -175,6 +176,14 @@ public class LocalVariableBinding extends VariableBinding {
 		}
 	}
 
+	public boolean isNonNull() {
+		return (this.tagBits & TagBits.AnnotationNonNull) != 0;
+	}
+
+	public boolean isNullable() {
+		return (this.tagBits & TagBits.AnnotationNullable) != 0;
+	}
+
 	// Answer whether the variable binding is a secret variable added for code gen purposes
 	public boolean isSecret() {
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 2e2009a..b61e955 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -16,6 +16,7 @@
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
  *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
+ *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
@@ -303,9 +304,12 @@ public static int getIrritant(int problemID) {
 		case IProblem.NullLocalVariableComparisonYieldsFalse:
 		case IProblem.NullLocalVariableInstanceofYieldsFalse:
 		case IProblem.RedundantNullCheckOnNonNullMessageSend:
+		case IProblem.RedundantNullCheckOnSpecdNonNullLocalVariable:
+		case IProblem.SpecdNonNullLocalVariableComparisonYieldsFalse:
 			return CompilerOptions.RedundantNullCheck;
 
 		case IProblem.RequiredNonNullButProvidedNull:
+		case IProblem.RequiredNonNullButProvidedSpecdNullable:
 		case IProblem.IllegalReturnNullityRedefinition:
 		case IProblem.IllegalRedefinitionToNonNullParameter:
 		case IProblem.IllegalDefinitionToNonNullParameter:
@@ -5092,9 +5096,18 @@ public void localVariableHiding(LocalDeclaration local, Binding hiddenVariable,
 public void localVariableNonNullComparedToNull(LocalVariableBinding local, ASTNode location) {
 	int severity = computeSeverity(IProblem.NonNullLocalVariableComparisonYieldsFalse);
 	if (severity == ProblemSeverities.Ignore) return;
-	String[] arguments = new String[] {new String(local.name)  };
+	String[] arguments;
+	int problemId;
+	if (local.isNonNull()) {
+		char[][] annotationName = this.options.nonNullAnnotationName; // cannot be null if local is declared @NonNull
+		arguments = new String[] {new String(local.name), new String(annotationName[annotationName.length-1])  };
+		problemId = IProblem.SpecdNonNullLocalVariableComparisonYieldsFalse;
+	} else {
+		arguments = new String[] {new String(local.name)  };
+		problemId = IProblem.NonNullLocalVariableComparisonYieldsFalse; 
+	}
 	this.handle(
-		IProblem.NonNullLocalVariableComparisonYieldsFalse,
+		problemId,
 		arguments,
 		arguments,
 		severity,
@@ -5157,9 +5170,18 @@ public void localVariablePotentialNullReference(LocalVariableBinding local, ASTN
 public void localVariableRedundantCheckOnNonNull(LocalVariableBinding local, ASTNode location) {
 	int severity = computeSeverity(IProblem.RedundantNullCheckOnNonNullLocalVariable);
 	if (severity == ProblemSeverities.Ignore) return;
-	String[] arguments = new String[] {new String(local.name)  };
+	String[] arguments;
+	int problemId;
+	if (local.isNonNull()) {
+		char[][] annotationName = this.options.nonNullAnnotationName; // cannot be null if local is declared @NonNull
+		arguments = new String[] {new String(local.name), new String(annotationName[annotationName.length-1])  };
+		problemId = IProblem.RedundantNullCheckOnSpecdNonNullLocalVariable;
+	} else {
+		arguments = new String[] {new String(local.name)  };
+		problemId = IProblem.RedundantNullCheckOnNonNullLocalVariable; 
+	}
 	this.handle(
-		IProblem.RedundantNullCheckOnNonNullLocalVariable,
+		problemId, 
 		arguments,
 		arguments,
 		severity,
@@ -8138,26 +8160,81 @@ public void explicitlyClosedAutoCloseable(FakedTrackingVariable trackVar) {
 		trackVar.sourceEnd);	
 }
 
-public void nullityMismatch(Expression expression, TypeBinding requiredType, int nullStatus, char[][] annotationName) {
+public void nullityMismatch(Expression expression, TypeBinding providedType, TypeBinding requiredType, int nullStatus, char[][] annotationName) {
+	if ((nullStatus & FlowInfo.NULL) != 0) {
+		nullityMismatchIsNull(expression, requiredType, annotationName);
+		return;
+	}
+	if ((nullStatus & FlowInfo.POTENTIALLY_NULL) != 0) {
+		if (expression instanceof SingleNameReference) {
+			SingleNameReference snr = (SingleNameReference) expression;
+			if (snr.binding instanceof LocalVariableBinding) {
+				if (((LocalVariableBinding)snr.binding).isNullable()) {
+					nullityMismatchSpecdNullable(expression, requiredType, annotationName);
+					return;
+				}
+			}
+		}
+		nullityMismatchPotentiallyNull(expression, requiredType, annotationName);
+		return;
+	}
+	nullityMismatchIsUnknown(expression, providedType, requiredType, annotationName);
+}
+public void nullityMismatchIsNull(Expression expression, TypeBinding requiredType, char[][] annotationName) {
+	int problemId = IProblem.RequiredNonNullButProvidedNull;
+	String[] arguments = new String[] {
+			String.valueOf(CharOperation.concatWith(annotationName, '.')),
+			String.valueOf(requiredType.readableName())
+	};
+	String[] argumentsShort = new String[] {
+			String.valueOf(annotationName[annotationName.length-1]),
+			String.valueOf(requiredType.shortReadableName())
+	};
+	this.handle(problemId, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
+}
+public void nullityMismatchSpecdNullable(Expression expression, TypeBinding requiredType, char[][] annotationName) {
+	int problemId = IProblem.RequiredNonNullButProvidedSpecdNullable;
+	char[][] nullableName = this.options.nullableAnnotationName;
+	String[] arguments = new String[] {
+			String.valueOf(CharOperation.concatWith(annotationName, '.')),
+			String.valueOf(requiredType.readableName()),
+			String.valueOf(CharOperation.concatWith(nullableName, '.'))
+	};
+	String[] argumentsShort = new String[] {
+			String.valueOf(annotationName[annotationName.length-1]),
+			String.valueOf(requiredType.shortReadableName()),
+			String.valueOf(nullableName[nullableName.length-1])
+	};
+	this.handle(problemId, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
+}
+public void nullityMismatchPotentiallyNull(Expression expression, TypeBinding requiredType, char[][] annotationName) {
+	int problemId = IProblem.RequiredNonNullButProvidedPotentialNull;
+	char[][] nullableName = this.options.nullableAnnotationName;
+	String[] arguments = new String[] {
+			String.valueOf(CharOperation.concatWith(annotationName, '.')),
+			String.valueOf(requiredType.readableName()),
+			String.valueOf(CharOperation.concatWith(nullableName, '.'))
+	};
+	String[] argumentsShort = new String[] {
+			String.valueOf(annotationName[annotationName.length-1]),
+			String.valueOf(requiredType.shortReadableName()),
+			String.valueOf(nullableName[nullableName.length-1])
+	};
+	this.handle(problemId, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
+}
+public void nullityMismatchIsUnknown(Expression expression, TypeBinding providedType, TypeBinding requiredType, char[][] annotationName) {
 	int problemId = IProblem.RequiredNonNullButProvidedUnknown;
-	if ((nullStatus & FlowInfo.NULL) != 0)
-		problemId = IProblem.RequiredNonNullButProvidedNull;
-	if ((nullStatus & FlowInfo.POTENTIALLY_NULL) != 0)
-		problemId = IProblem.RequiredNonNullButProvidedPotentialNull;
 	String[] arguments = new String[] {
+			String.valueOf(providedType.readableName()),
 			String.valueOf(CharOperation.concatWith(annotationName, '.')),
 			String.valueOf(requiredType.readableName())
 	};
 	String[] argumentsShort = new String[] {
+			String.valueOf(providedType.shortReadableName()),
 			String.valueOf(annotationName[annotationName.length-1]),
 			String.valueOf(requiredType.shortReadableName())
 	};
-	this.handle(
-		problemId,
-		arguments,
-		argumentsShort,
-		expression.sourceStart,
-		expression.sourceEnd);
+	this.handle(problemId, arguments, argumentsShort, expression.sourceStart, expression.sourceEnd);
 }
 public void illegalRedefinitionToNonNullParameter(Argument argument, ReferenceBinding declaringClass, char[][] inheritedAnnotationName) {
 	int sourceStart = argument.type.sourceStart;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 8a5d4ef..fd9a4ef 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -14,6 +14,7 @@
 #							bug 186342 - [compiler][null] Using annotations for null checking
 #							bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
 #							bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
+#							bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
 ###############################################################################
 0 = {0}
 1 = super cannot be used in java.lang.Object
@@ -660,9 +661,9 @@
 890 = Cannot switch on an enum value for source level below 1.5. Only convertible int values are permitted
 
 ### NULL ANNOTATIONS
-910 = Type mismatch: required ''@{0} {1}'' but the provided value is null
-911 = Type mismatch: required ''@{0} {1}'' but the provided value can be null
-912 = Potential type mismatch: required ''@{0} {1}'' but nullness of the provided value is unknown
+910 = Null type mismatch: required ''@{0} {1}'' but the provided value is null
+911 = Null type mismatch: required ''@{0} {1}'' but the provided value is inferred as @{2}
+912 = Null type safety: The expression of type {0} needs unchecked conversion to conform to ''@{1} {2}''
 913 = A default nullness annotation has not been specified for the package {0}
 914 = The return type is incompatible with the @{1} return from {0}
 915 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as @{2}
@@ -680,6 +681,9 @@
 928 = Nullness default is redundant with a default specified for the enclosing method {0}
 929 = Contradictory null specification; only one of @{0} and @{1} can be specified at any location
 930 = A default nullness annotation has not been specified for the type {0}
+931 = Redundant null check: The variable {0} is specified as @{1}
+932 = Null comparison always yields false: The variable {0} is specified as @{1}
+933 = Null type mismatch: required ''@{0} {1}'' but the provided value is specified as @{2}
 
 ### ELABORATIONS
 ## Access restrictions
commit d00b9ad70dbedf29a635b964d926113aa73c3dfc
Author: Ayushman Jain <ajain>
Date:   Tue Mar 13 21:39:18 2012 +0530

    Fixed API names after changes in bug 365859: [compiler][null]
    distinguish warnings based on flow analysis vs. null annotations

3	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
20	20	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
2	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
16	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
23	20	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 2d3304d..eae3cad 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1901,15 +1901,15 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noEffectAssignment\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral\" value=\"ignore\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict\" value=\"error\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullReference\" value=\"warning\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullSpecInsufficientInfo\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullSpecViolation\" value=\"error\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullUncheckedConversion\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.overridingMethodWithoutSuperInvocation\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.parameterAssignment\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.potentialNullReference\" value=\"ignore\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.problem.potentialNullSpecViolation\" value=\"error\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.rawTypeReference\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation\" value=\"warning\"/>\n" + 
@@ -1953,7 +1953,7 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.source\" value=\"1.5\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.taskCaseSensitive\" value=\"enabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.taskPriorities\" value=\"\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.taskTags\" value=\"\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.taskTags\" value=\"\"/>\n" + 
 			"	</options>\n" + 
 			"	<classpaths>NORMALIZED SECTION</classpaths>\n" + 
 			"	<sources>\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 3c7d632..7455d46 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1507,8 +1507,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("ReferenceToForwardField", SKIP);
 		expectedProblemAttributes.put("ReferenceToForwardTypeVariable", SKIP);
 		expectedProblemAttributes.put("RequiredNonNullButProvidedNull", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
-		expectedProblemAttributes.put("RequiredNonNullButProvidedPotentialNull", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION));
-		expectedProblemAttributes.put("RequiredNonNullButProvidedUnknown", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO));
+		expectedProblemAttributes.put("RequiredNonNullButProvidedPotentialNull", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT));
+		expectedProblemAttributes.put("RequiredNonNullButProvidedUnknown", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedSpecdNullable", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("ResourceHasToImplementAutoCloseable", SKIP);
 		expectedProblemAttributes.put("ReturnTypeAmbiguous", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 0ad4ccf..5f0ebcd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -323,7 +323,7 @@ public void test_nonnull_parameter_005() {
 // a ternary non-null expression is passed to a nonnull parameter
 public void test_nonnull_parameter_006() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runConformTestWithLibs(
 		new String[] {
 			"X.java",
@@ -340,7 +340,7 @@ public void test_nonnull_parameter_006() {
 // nullable value passed to a non-null parameter in a super-call
 public void test_nonnull_parameter_007() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runNegativeTestWithLibs(
 		new String[] {
 			"XSub.java",
@@ -368,7 +368,7 @@ public void test_nonnull_parameter_007() {
 // a nullable value is passed to a non-null parameter in an allocation expression
 public void test_nonnull_parameter_008() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runNegativeTestWithLibs(
 		new String[] {
 			"X.java",
@@ -390,7 +390,7 @@ public void test_nonnull_parameter_008() {
 // a nullable value is passed to a non-null parameter in a qualified allocation expression
 public void test_nonnull_parameter_009() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runNegativeTestWithLibs(
 		new String[] {
 			"X.java",
@@ -414,7 +414,7 @@ public void test_nonnull_parameter_009() {
 // null is passed to a non-null parameter in a qualified allocation expression, across CUs
 public void test_nonnull_parameter_010() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runNegativeTestWithLibs(
 		new String[] {
 			"ContainingInner2.java",
@@ -449,7 +449,7 @@ public void test_nonnull_parameter_010() {
 // null is passed to a non-null parameter in a qualified allocation expression, target class read from .class
 public void test_nonnull_parameter_011() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runConformTestWithLibs(
 			new String[] {
 				"ContainingInner2.java",
@@ -490,7 +490,7 @@ public void test_nonnull_parameter_011() {
 // null is passed to a non-null parameter in a qualified allocation expression, generic constructor, target class read from .class
 public void test_nonnull_parameter_012() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runConformTestWithLibs(
 			new String[] {
 				"ContainingInner2.java",
@@ -1033,7 +1033,7 @@ public void test_parameter_specification_inheritance_007a() {
 // a client potentially violates the inherited null specification, super interface declares @NonNull parameter
 public void test_parameter_specification_inheritance_008() {
 	Map options = getCompilerOptions();
-	options.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	options.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runConformTestWithLibs(
 		new String[] {
 			"IX.java",
@@ -1095,7 +1095,7 @@ public void test_parameter_specification_inheritance_009() {
 // class default is nonnull, method and its super both use the default
 public void test_parameter_specification_inheritance_010() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runConformTestWithLibs(
 		new String[] {
 	"p1/X.java",
@@ -1126,7 +1126,7 @@ public void test_parameter_specification_inheritance_010() {
 // class default is nonnull, method and its super both use the default, super-call passes null
 public void test_parameter_specification_inheritance_011() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runNegativeTestWithLibs(
 		new String[] {
 	"p1/X.java",
@@ -1163,7 +1163,7 @@ public void test_parameter_specification_inheritance_011() {
 // sub-class merges both using the weakest common contract
 public void test_parameter_specification_inheritance_012() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runConformTestWithLibs(
 		new String[] {
 	"p1/X.java",
@@ -1197,7 +1197,7 @@ public void test_parameter_specification_inheritance_012() {
 // sub-class overrides this method in non-conforming ways
 public void test_parameter_specification_inheritance_013() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runNegativeTestWithLibs(
 		new String[] {
 	"p1/X.java",
@@ -1251,7 +1251,7 @@ public void test_parameter_specification_inheritance_013() {
 // sub-class does not override, but should to bridge the incompatibility
 public void test_parameter_specification_inheritance_014() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runNegativeTestWithLibs(
 		new String[] {
 	"p1/IY.java",
@@ -1650,7 +1650,7 @@ public void test_nonnull_return_010() {
 // a non-null method returns a checked-for null value, but that branch is dead code
 public void test_nonnull_return_011() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runNegativeTestWithLibs(
 		new String[] {
 			"X.java",
@@ -1682,7 +1682,7 @@ public void test_nonnull_return_011() {
 // TODO(SH): ENABLE!
 public void _test_nonnull_return_012() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runNegativeTestWithLibs(
 		new String[] {
 			"X.java",
@@ -1710,7 +1710,7 @@ public void _test_nonnull_return_012() {
 // don't apply any default annotations to return void
 public void test_nonnull_return_013() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runConformTestWithLibs(
 		new String[] {
 			"X.java",
@@ -1838,7 +1838,7 @@ public void test_annotation_import_002() {
 // using a Lib without null specifications
 public void test_annotation_import_005() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.MayBeNull");
 	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.MustNotBeNull");
 	runNegativeTest(
@@ -1882,7 +1882,7 @@ public void test_annotation_import_005() {
 // a non-null method returns a value obtained from an unannotated method, missing annotation types
 public void test_annotation_import_006() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.MayBeNull");
 	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.MustNotBeNull");
 	runNegativeTest(
@@ -3141,7 +3141,7 @@ public void test_nonnull_var_in_constrol_structure_3() {
 // witness for an AIOOBE in FlowContext.recordExpectedType()
 public void test_message_send_in_control_structure_01() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.IGNORE);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.IGNORE);
 	customOptions.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.WARNING);
 	runNegativeTestWithLibs(
 		new String[] {
@@ -3400,7 +3400,7 @@ public void test_constructor_with_nested_class() {
 // test analysis disablement, binary type contains annotation
 public void test_options_01() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION, JavaCore.ERROR);
 	runConformTestWithLibs(
 			new String[] {
 				"ContainingInner2.java",
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index f51a2bc..7562d38 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -3498,8 +3498,8 @@ private void handleErrorOrWarningToken(String token, boolean isEnabling, int sev
 						CompilerOptions.OPTION_AnnotationBasedNullAnalysis,
 						isEnabling ? CompilerOptions.ENABLED : CompilerOptions.DISABLED);
 				setSeverity(CompilerOptions.OPTION_ReportNullSpecViolation, severity, isEnabling);
-				setSeverity(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, severity, isEnabling);
-				setSeverity(CompilerOptions.OPTION_ReportNullSpecInsufficientInfo, severity, isEnabling);
+				setSeverity(CompilerOptions.OPTION_ReportNullAnnotationInferenceConflict, severity, isEnabling);
+				setSeverity(CompilerOptions.OPTION_ReportNullUncheckedConversion, severity, isEnabling);
 				setSeverity(CompilerOptions.OPTION_ReportRedundantNullAnnotation, severity, isEnabling);
 				return;
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 5eb0dc7..4ab00b7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -146,8 +146,8 @@ public class CompilerOptions {
 	public static final String OPTION_ReportPotentiallyUnclosedCloseable = "org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable"; //$NON-NLS-1$
 	public static final String OPTION_ReportExplicitlyClosedAutoCloseable = "org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable"; //$NON-NLS-1$
 	public static final String OPTION_ReportNullSpecViolation = "org.eclipse.jdt.core.compiler.problem.nullSpecViolation";  //$NON-NLS-1$
-	public static final String OPTION_ReportPotentialNullSpecViolation = "org.eclipse.jdt.core.compiler.problem.potentialNullSpecViolation";  //$NON-NLS-1$
-	public static final String OPTION_ReportNullSpecInsufficientInfo = "org.eclipse.jdt.core.compiler.problem.nullSpecInsufficientInfo";  //$NON-NLS-1$
+	public static final String OPTION_ReportNullAnnotationInferenceConflict = "org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict";  //$NON-NLS-1$
+	public static final String OPTION_ReportNullUncheckedConversion = "org.eclipse.jdt.core.compiler.problem.nullUncheckedConversion";  //$NON-NLS-1$
 	public static final String OPTION_ReportRedundantNullAnnotation = "org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation";  //$NON-NLS-1$
 	public static final String OPTION_AnnotationBasedNullAnalysis = "org.eclipse.jdt.core.compiler.annotation.nullanalysis"; //$NON-NLS-1$
 	public static final String OPTION_NullableAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nullable"; //$NON-NLS-1$
@@ -265,8 +265,8 @@ public class CompilerOptions {
 	public static final int PotentiallyUnclosedCloseable = IrritantSet.GROUP2 | ASTNode.Bit9;
 	public static final int ExplicitlyClosedAutoCloseable = IrritantSet.GROUP2 | ASTNode.Bit10;
 	public static final int NullSpecViolation = IrritantSet.GROUP2 | ASTNode.Bit11;
-	public static final int PotentialNullSpecViolation = IrritantSet.GROUP2 | ASTNode.Bit12;
-	public static final int NullSpecInsufficientInfo = IrritantSet.GROUP2 | ASTNode.Bit13;
+	public static final int NullAnnotationInferenceConflict = IrritantSet.GROUP2 | ASTNode.Bit12;
+	public static final int NullUncheckedConversion = IrritantSet.GROUP2 | ASTNode.Bit13;
 	public static final int RedundantNullAnnotation = IrritantSet.GROUP2 | ASTNode.Bit14;
 	public static final int MissingNonNullByDefaultAnnotation = IrritantSet.GROUP2 | ASTNode.Bit15;
 
@@ -610,10 +610,10 @@ public class CompilerOptions {
 				return OPTION_ReportExplicitlyClosedAutoCloseable;
 			case NullSpecViolation :
 				return OPTION_ReportNullSpecViolation;
-			case PotentialNullSpecViolation :
-				return OPTION_ReportPotentialNullSpecViolation;
-			case NullSpecInsufficientInfo :
-				return OPTION_ReportNullSpecInsufficientInfo;
+			case NullAnnotationInferenceConflict :
+				return OPTION_ReportNullAnnotationInferenceConflict;
+			case NullUncheckedConversion :
+				return OPTION_ReportNullUncheckedConversion;
 			case RedundantNullAnnotation :
 				return OPTION_ReportRedundantNullAnnotation;
 		}
@@ -788,8 +788,8 @@ public class CompilerOptions {
 			OPTION_NonNullByDefaultAnnotationName,
 			OPTION_ReportMissingNonNullByDefaultAnnotation,
 			OPTION_ReportNullSpecViolation,
-			OPTION_ReportPotentialNullSpecViolation,
-			OPTION_ReportNullSpecInsufficientInfo,
+			OPTION_ReportNullAnnotationInferenceConflict,
+			OPTION_ReportNullUncheckedConversion,
 			OPTION_ReportRedundantNullAnnotation
 		};
 		return result;
@@ -854,8 +854,8 @@ public class CompilerOptions {
 			case PotentialNullReference :
 			case RedundantNullCheck :
 			case NullSpecViolation :
-			case PotentialNullSpecViolation :
-			case NullSpecInsufficientInfo :
+			case NullAnnotationInferenceConflict :
+			case NullUncheckedConversion :
 			case RedundantNullAnnotation :
 			case MissingNonNullByDefaultAnnotation:
 				return "null"; //$NON-NLS-1$
@@ -1077,8 +1077,8 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportExplicitlyClosedAutoCloseable, getSeverityString(ExplicitlyClosedAutoCloseable));
 		optionsMap.put(OPTION_AnnotationBasedNullAnalysis, this.isAnnotationBasedNullAnalysisEnabled ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportNullSpecViolation, getSeverityString(NullSpecViolation));
-		optionsMap.put(OPTION_ReportPotentialNullSpecViolation, getSeverityString(PotentialNullSpecViolation));
-		optionsMap.put(OPTION_ReportNullSpecInsufficientInfo, getSeverityString(NullSpecInsufficientInfo));
+		optionsMap.put(OPTION_ReportNullAnnotationInferenceConflict, getSeverityString(NullAnnotationInferenceConflict));
+		optionsMap.put(OPTION_ReportNullUncheckedConversion, getSeverityString(NullUncheckedConversion));
 		optionsMap.put(OPTION_ReportRedundantNullAnnotation, getSeverityString(RedundantNullAnnotation));
 		optionsMap.put(OPTION_NullableAnnotationName, String.valueOf(CharOperation.concatWith(this.nullableAnnotationName, '.')));
 		optionsMap.put(OPTION_NonNullAnnotationName, String.valueOf(CharOperation.concatWith(this.nonNullAnnotationName, '.')));
@@ -1548,8 +1548,8 @@ public class CompilerOptions {
 				}
 				// "ignore" is not valid for this option
 			}
-			if ((optionValue = optionsMap.get(OPTION_ReportPotentialNullSpecViolation)) != null) updateSeverity(PotentialNullSpecViolation, optionValue);
-			if ((optionValue = optionsMap.get(OPTION_ReportNullSpecInsufficientInfo)) != null) updateSeverity(NullSpecInsufficientInfo, optionValue);
+			if ((optionValue = optionsMap.get(OPTION_ReportNullAnnotationInferenceConflict)) != null) updateSeverity(NullAnnotationInferenceConflict, optionValue);
+			if ((optionValue = optionsMap.get(OPTION_ReportNullUncheckedConversion)) != null) updateSeverity(NullUncheckedConversion, optionValue);
 			if ((optionValue = optionsMap.get(OPTION_ReportRedundantNullAnnotation)) != null) updateSeverity(RedundantNullAnnotation, optionValue);
 			if ((optionValue = optionsMap.get(OPTION_NullableAnnotationName)) != null) {
 				this.nullableAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index 1f53ff7..6a1aa76 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -109,12 +109,12 @@ public class IrritantSet {
 				CompilerOptions.DeadCode
 				|CompilerOptions.Tasks
 				|CompilerOptions.UnclosedCloseable
-				|CompilerOptions.NullSpecInsufficientInfo
+				|CompilerOptions.NullUncheckedConversion
 				|CompilerOptions.RedundantNullAnnotation);
 		// default errors IF AnnotationBasedNullAnalysis is enabled:
 		COMPILER_DEFAULT_ERRORS.set(
 				CompilerOptions.NullSpecViolation
-				|CompilerOptions.PotentialNullSpecViolation);
+				|CompilerOptions.NullAnnotationInferenceConflict);
 
 		ALL.setAll();
 		HIDING
@@ -125,8 +125,8 @@ public class IrritantSet {
 			.set(CompilerOptions.PotentialNullReference)
 			.set(CompilerOptions.RedundantNullCheck)
 			.set(CompilerOptions.NullSpecViolation)
-			.set(CompilerOptions.PotentialNullSpecViolation)
-			.set(CompilerOptions.NullSpecInsufficientInfo)
+			.set(CompilerOptions.NullAnnotationInferenceConflict)
+			.set(CompilerOptions.NullUncheckedConversion)
 			.set(CompilerOptions.RedundantNullAnnotation);
 
 		RESTRICTION.set(CompilerOptions.DiscouragedReference);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index b61e955..6a2e7f7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -319,9 +319,9 @@ public static int getIrritant(int problemID) {
 			return CompilerOptions.NullSpecViolation;
 
 		case IProblem.RequiredNonNullButProvidedPotentialNull:
-			return CompilerOptions.PotentialNullSpecViolation;
+			return CompilerOptions.NullAnnotationInferenceConflict;
 		case IProblem.RequiredNonNullButProvidedUnknown:
-			return CompilerOptions.NullSpecInsufficientInfo;
+			return CompilerOptions.NullUncheckedConversion;
 		case IProblem.RedundantNullAnnotation:
 		case IProblem.RedundantNullDefaultAnnotation:
 		case IProblem.RedundantNullDefaultAnnotationPackage:
@@ -580,8 +580,8 @@ public static int getProblemCategory(int severity, int problemID) {
 				return CategorizedProblem.CAT_RESTRICTION;
 
 			case CompilerOptions.NullSpecViolation :
-			case CompilerOptions.PotentialNullSpecViolation :
-			case CompilerOptions.NullSpecInsufficientInfo :
+			case CompilerOptions.NullAnnotationInferenceConflict :
+			case CompilerOptions.NullUncheckedConversion :
 			case CompilerOptions.MissingNonNullByDefaultAnnotation:
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			case CompilerOptions.RedundantNullAnnotation :
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 9de477f..dc65013 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1422,8 +1422,8 @@ public final class JavaCore extends Plugin {
 	 *    as specifying whether or not a given type includes the value <code>null</code>.</p>
 	 * <p>The effect of these analyses is further controlled by the options
 	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
-	 *    {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
-	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.
+	 *    {@link #COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT} and
+	 *    {@link #COMPILER_PB_NULL_UNCHECKED_CONVERSION}.
 	 * </p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nullanalysis"</code></dd>
@@ -1448,8 +1448,8 @@ public final class JavaCore extends Plugin {
 	 *    {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}.</p>
 	 * <p>The compiler may furthermore check adherence to the null specification as
 	 *    further controlled by {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
-	 *    {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
-	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.</p>
+	 *    {@link #COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT} and
+	 *    {@link #COMPILER_PB_NULL_UNCHECKED_CONVERSION}.</p>
 	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nullable"</code></dd>
@@ -1474,8 +1474,8 @@ public final class JavaCore extends Plugin {
 	 *    will never occur at runtime in these positions.</p>
 	 * <p>The compiler may furthermore check adherence to the null specification as further
 	 *    controlled by {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
-	 *    {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
-	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.</p>
+	 *    {@link #COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT} and
+	 *    {@link #COMPILER_PB_NULL_UNCHECKED_CONVERSION}.</p>
 	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnull"</code></dd>
@@ -1529,13 +1529,13 @@ public final class JavaCore extends Plugin {
 	 * <p>Depending on this option, the compiler will issue either an error or a warning
 	 *    whenever one of the following situations is detected:
 	 *    <ol>
-	 *    <li>A method declared with a nonnull annotation returns an expression	that is
-	 *          statically known to evaluate to a null value.</li>
-	 *    <li>An expression that is statically known to evaluate to a null value is	passed
-	 *        as an argument in a method call where the corresponding parameter of the called
-	 *        method is declared with a nonnull annotation.</li>
-	 *    <li>An expression that is statically known to evaluate to a null value is	assigned
-	 *        to a local variable that is declared with a nonnull annotation.</li>
+	 *    <li>A method declared with a nonnull annotation returns a
+	 *        <em>nullable</em> expression.</li>
+	 *    <li>A <em>nullable</em> expression is passed
+     *        as an argument in a method call where the corresponding parameter of the called
+     *        method is declared with a nonnull annotation.</li>
+	 *    <li>A <em>nullable</em> expression is assigned
+     *        to a local variable that is declared with a nonnull annotation.</li>
 	 *    <li>A method that overrides an inherited method declared with a nonnull annotation
 	 *        tries to relax that contract by specifying a nullable annotation
 	 *        (prohibition of contravariant return).</li>
@@ -1544,6 +1544,9 @@ public final class JavaCore extends Plugin {
 	 *        specifying a nonnull annotation for its corresponding parameter
 	 *        (prohibition of covariant parameters).</li>
 	 *    </ol>
+	 *    In the above an expression is considered as <em>nullable</em> if
+	 *    either it is statically known to evaluate to the value <code>null</code>, or if it is
+	 *    declared with a nullable annotation.
 	 * </p>
 	 * <p>The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
 	 *    {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
@@ -1560,7 +1563,7 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_PB_NULL_SPECIFICATION_VIOLATION = PLUGIN_ID + ".compiler.problem.nullSpecViolation"; //$NON-NLS-1$
 	/**
-	 * Compiler option ID: Reporting Violations of Null Specifications with Potential Null Value.
+	 * Compiler option ID: Reporting conflicts between declared null annotation and inferred null value 
 	 * <p>When enabled, the compiler will issue an error or a warning whenever one of the
 	 *    following situations is detected:
 	 *    <ol>
@@ -1579,16 +1582,16 @@ public final class JavaCore extends Plugin {
 	 * </p>
 	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
-	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.potentialNullSpecViolation"</code></dd>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
 	 * <dt>Default:</dt><dd><code>"error"</code></dd>
 	 * </dl>
 	 * @since 3.8
 	 * @category CompilerOptionID
 	 */
-	public static final String COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION = PLUGIN_ID + ".compiler.problem.potentialNullSpecViolation"; //$NON-NLS-1$
+	public static final String COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT = PLUGIN_ID + ".compiler.problem.nullAnnotationInferenceConflict"; //$NON-NLS-1$
 	/**
-	 * Compiler option ID: Reporting Insufficient Information for Analysing Adherence to Null Specifications.
+	 * Compiler option ID: Reporting unchecked conversion from a type with unknown nullness to a null annotated type
 	 * <p>When enabled, the compiler will issue an error or a warning whenever one of the
 	 *    following situations is detected:
 	 *    <ol>
@@ -1603,7 +1606,7 @@ public final class JavaCore extends Plugin {
 	 *        statically proving that it will never evaluate to a null value at runtime
 	 *        is assigned to a local variable that is declared with a nonnull annotation.</li>
 	 *    </ol>
-	 *    Insufficient nullness information is usually a consequence of using other unannotated
+	 *    Unchecked null conversion is usually a consequence of using other unannotated
 	 *    variables or methods.
 	 * </p>
 	 * <p>The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
@@ -1612,14 +1615,14 @@ public final class JavaCore extends Plugin {
 	 * </p>
 	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
-	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nullSpecInsufficientInfo"</code></dd>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nullUncheckedConversion"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
 	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
 	 * </dl>
 	 * @since 3.8
 	 * @category CompilerOptionID
 	 */
-	public static final String COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO = PLUGIN_ID + ".compiler.problem.nullSpecInsufficientInfo"; //$NON-NLS-1$
+	public static final String COMPILER_PB_NULL_UNCHECKED_CONVERSION = PLUGIN_ID + ".compiler.problem.nullUncheckedConversion"; //$NON-NLS-1$
 	/**
 	 * Compiler option ID: Reporting Redundant Null Annotations.
 	 * <p>When enabled, the compiler will issue an error or a warning when a non-null annotation
