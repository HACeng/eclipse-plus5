commit 9cbf7e62288f060b33b2dc1c1d579dae84747012
Author: David Audel <daudel>
Date:   Thu Oct 12 09:22:02 2006 +0000

    HEAD - bug 44984

6	6	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
63	20	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
1415	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests.java
255	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests2.java
522	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests_1_5.java
6	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/RunCompletionModelTests.java
130	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
615	128	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
595	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/MissingTypesGuesser.java
19	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnMemberAccess.java
6	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedNameReference.java
10	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
8	0	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
62	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
60	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
101	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
index 32c0308..b2cbc95 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
@@ -9257,9 +9257,9 @@ public void testCompletionKeywordTrue6() throws JavaModelException {
 				"notify[METHOD_REF]{notify(), Ljava.lang.Object;, ()V, notify, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
 				"notifyAll[METHOD_REF]{notifyAll(), Ljava.lang.Object;, ()V, notifyAll, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
 				"toString[METHOD_REF]{toString(), Ljava.lang.Object;, ()Ljava.lang.String;, toString, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
-				"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (JI)V, wait, (millis, nanos), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
-				"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (J)V, wait, (millis), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
 				"wait[METHOD_REF]{wait(), Ljava.lang.Object;, ()V, wait, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+				"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (J)V, wait, (millis), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+				"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (JI)V, wait, (millis, nanos), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
 				"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_EXACT_EXPECTED_TYPE + R_NON_RESTRICTED)+"}\n"+
 				"var[LOCAL_VARIABLE_REF]{var, null, Z, var, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_EXACT_EXPECTED_TYPE + R_NON_RESTRICTED)+"}\n"+
 				"false[KEYWORD]{false, null, null, false, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_EXACT_EXPECTED_TYPE + R_TRUE_OR_FALSE + R_NON_RESTRICTED)+"}\n"+
@@ -9276,9 +9276,9 @@ public void testCompletionKeywordTrue6() throws JavaModelException {
 				"notify[METHOD_REF]{notify(), Ljava.lang.Object;, ()V, notify, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
 				"notifyAll[METHOD_REF]{notifyAll(), Ljava.lang.Object;, ()V, notifyAll, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
 				"toString[METHOD_REF]{toString(), Ljava.lang.Object;, ()Ljava.lang.String;, toString, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
-				"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (JI)V, wait, (millis, nanos), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
-				"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (J)V, wait, (millis), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
 				"wait[METHOD_REF]{wait(), Ljava.lang.Object;, ()V, wait, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+				"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (J)V, wait, (millis), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+				"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (JI)V, wait, (millis, nanos), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
 				"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_EXACT_EXPECTED_TYPE + R_NON_RESTRICTED)+"}\n"+
 				"var[LOCAL_VARIABLE_REF]{var, null, Z, var, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_EXACT_EXPECTED_TYPE + R_NON_RESTRICTED)+"}\n"+
 				"false[KEYWORD]{false, null, null, false, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_EXACT_EXPECTED_TYPE + R_TRUE_OR_FALSE + R_NON_RESTRICTED)+"}\n"+
@@ -9337,9 +9337,9 @@ public void testCompletionKeywordFalse5() throws JavaModelException {
 			"notify[METHOD_REF]{notify(), Ljava.lang.Object;, ()V, notify, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
 			"notifyAll[METHOD_REF]{notifyAll(), Ljava.lang.Object;, ()V, notifyAll, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
 			"toString[METHOD_REF]{toString(), Ljava.lang.Object;, ()Ljava.lang.String;, toString, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
-			"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (JI)V, wait, (millis, nanos), " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
-			"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (J)V, wait, (millis), " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
 			"wait[METHOD_REF]{wait(), Ljava.lang.Object;, ()V, wait, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+			"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (J)V, wait, (millis), " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
+			"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (JI)V, wait, (millis, nanos), " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}\n" +
 			"test[FIELD_REF]{test, Ltest.Test;, Z, test, null, " + (R_DEFAULT + R_CASE + R_UNQUALIFIED + R_EXACT_EXPECTED_TYPE + R_NON_RESTRICTED) + "}\n" +
 			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_EXACT_EXPECTED_TYPE + R_NON_RESTRICTED) + "}\n" +
 			"false[KEYWORD]{false, null, null, false, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_EXACT_EXPECTED_TYPE + R_TRUE_OR_FALSE + R_NON_RESTRICTED) + "}\n" +
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
index f648a37..c9b8f38 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
@@ -32,6 +32,7 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 	private boolean showUniqueKeys;
 	private boolean showPositions;
 	private boolean shortContext;
+	private boolean showMissingTypes;
 	
 	public boolean fDebug = false;
 
@@ -45,13 +46,18 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 		this(showParamNames, showUniqueKeys, false);
 	}
 	public CompletionTestsRequestor2(boolean showParamNames, boolean showUniqueKeys, boolean showPositions) {
-		this(showParamNames, showUniqueKeys, showPositions, true);
+		this(showParamNames, showUniqueKeys, showPositions, true, false);
 	}
+	
 	public CompletionTestsRequestor2(boolean showParamNames, boolean showUniqueKeys, boolean showPositions, boolean shortContext) {
+		this(showParamNames, showUniqueKeys, showPositions, shortContext, false);
+	}
+	public CompletionTestsRequestor2(boolean showParamNames, boolean showUniqueKeys, boolean showPositions, boolean shortContext, boolean showMissingTypes) {
 		this.showParameterNames = showParamNames;
 		this.showUniqueKeys = showUniqueKeys;
 		this.showPositions = showPositions;
 		this.shortContext = shortContext;
+		this.showMissingTypes = showMissingTypes;
 	}
 	public void acceptContext(CompletionContext cc) {
 		this.context = cc;
@@ -63,6 +69,12 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 		}
 		this.proposals[this.proposalsPtr] = proposal;
 	}
+	
+	public void allowAllRequiredProposals() {
+		for (int i = CompletionProposal.ANONYMOUS_CLASS_DECLARATION; i <= CompletionProposal.JAVADOC_INLINE_TAG; i++) {
+			this.setAllowsRequiredProposals(i, true);
+		}
+	}
 
 	public void completionFailure(IProblem p) {
 		this.problem = p;
@@ -198,7 +210,15 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 	}
 
 	protected StringBuffer printProposal(CompletionProposal proposal) {
-		StringBuffer buffer = new StringBuffer(getElementName(proposal));
+		StringBuffer buffer = new StringBuffer();
+		return printProposal(proposal, 0, buffer);
+	}
+	
+	protected StringBuffer printProposal(CompletionProposal proposal, int tab, StringBuffer buffer) {
+		for (int i = 0; i < tab; i++) {
+			buffer.append("   "); //$NON-NLS-1$
+		}
+		buffer.append(getElementName(proposal));
 		buffer.append('[');
 		switch(proposal.getKind()) {
 			case CompletionProposal.ANONYMOUS_CLASS_DECLARATION :
@@ -310,6 +330,18 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 		buffer.append(", ");
 		buffer.append(proposal.getRelevance());
 		buffer.append('}');
+		if(this.showMissingTypes) {
+			CompletionProposal[] requiredProposals = proposal.getRequiredProposals();
+			if (requiredProposals != null) {
+				int length = requiredProposals.length;
+				System.arraycopy(requiredProposals, 0, requiredProposals = new CompletionProposal[length], 0, length);
+				quickSort(requiredProposals, 0, length - 1);
+				for (int i = 0; i < length; i++) {
+					buffer.append('\n');
+					printProposal(requiredProposals[i], tab + 1, buffer);
+				}
+			}
+		}
 		return buffer;
 	}
 
@@ -341,25 +373,36 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 	
 	protected int compare(CompletionProposal proposal1, CompletionProposal proposal2) {
 		int relDif = proposal1.getRelevance() - proposal2.getRelevance();
-		if(relDif != 0) {
-			return relDif;
-		} else {
-			String name1 = getElementName(proposal1);
-			String name2 = getElementName(proposal2);
-			int nameDif = name1.compareTo(name2);
-			if(nameDif != 0) {
-				return nameDif;
-			} else {
-				int kindDif = proposal1.getKind() - proposal2.getKind();
-				if(kindDif != 0) {
-					return kindDif;
-				} else {
-					String completion1 = new String(proposal1.getCompletion());
-					String completion2 = new String(proposal2.getCompletion());
-					return completion1.compareTo(completion2);
-				}
-			}
+		if(relDif != 0) return relDif;
+		String name1 = getElementName(proposal1);
+		String name2 = getElementName(proposal2);
+		int nameDif = name1.compareTo(name2);
+		if(nameDif != 0) return nameDif;
+		int kindDif = proposal1.getKind() - proposal2.getKind();
+		if(kindDif != 0) return kindDif;
+		String completion1 = new String(proposal1.getCompletion());
+		String completion2 = new String(proposal2.getCompletion());
+		int completionDif = completion1.compareTo(completion2);
+		if(completionDif != 0) return completionDif;
+		char[] temp = proposal1.getSignature();
+		String signature1 = temp == null ? null: new String(temp);
+		temp = proposal2.getSignature();
+		String signature2 = temp == null ? null: new String(temp);
+		int signatureDif = 0;
+		if(signature1 != null && signature2 != null) {
+			signatureDif = signature1.compareTo(signature2);
+		}
+		if(signatureDif != 0) return signatureDif;
+		temp = proposal1.getDeclarationSignature();
+		String declarationSignature1 = temp == null ? null: new String(temp);
+		temp = proposal2.getDeclarationSignature();
+		String declarationSignature2 = temp == null ? null: new String(temp);
+		int declarationSignatureDif = 0;
+		if(declarationSignature1 != null && declarationSignature2 != null) {
+			declarationSignatureDif = declarationSignature1.compareTo(declarationSignature2);
 		}
+		if(declarationSignatureDif != 0) return declarationSignatureDif;
+		return 0;
 	}
 	
 	protected String getElementName(CompletionProposal proposal) {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests.java
new file mode 100644
index 0000000..d10ba45
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests.java
@@ -0,0 +1,1415 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.model;
+
+import java.util.Hashtable;
+
+import org.eclipse.jdt.core.*;
+import org.eclipse.jdt.internal.codeassist.RelevanceConstants;
+
+import junit.framework.*;
+
+public class CompletionWithMissingTypesTests extends AbstractJavaModelCompletionTests implements RelevanceConstants {
+
+public CompletionWithMissingTypesTests(String name) {
+	super(name);
+}
+public void setUpSuite() throws Exception {
+	if (COMPLETION_PROJECT == null)  {
+		COMPLETION_PROJECT = setUpJavaProject("Completion");
+	} else {
+		setUpProjectCompliance(COMPLETION_PROJECT, "1.4");
+	}
+	super.setUpSuite();
+}
+public void tearDownSuite() throws Exception {
+	super.tearDownSuite();
+}
+static {
+//	TESTS_NAMES = new String[] { "testZZZ"};
+}
+public static Test suite() {
+	return buildModelTestSuite(CompletionWithMissingTypesTests.class);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0001() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0002() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public int bar;\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[FIELD_REF]{bar, Lmissing.MissingType;, I, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0003() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType extends SuperType {\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/SuperType.java",
+		"package missing;"+
+		"public class SuperType {\n" + 
+		"  public int bar;\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[FIELD_REF]{bar, Lmissing.SuperType;, I, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0004() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType[] m = null;\n" + 
+ 		"    m.\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {};\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_RESTRICTED;
+	int relevance2 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.") + "m.".length();
+	int end1 = start1;
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"length[FIELD_REF]{length, [Lmissing.MissingType;, I, length, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"clone[METHOD_REF]{clone(), [Lmissing.MissingType;, ()Ljava.lang.Object;, clone, null, ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}\n" +
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}\n" +
+			"finalize[METHOD_REF]{finalize(), Ljava.lang.Object;, ()V, finalize, null, ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}\n" +
+			"getClass[METHOD_REF]{getClass(), Ljava.lang.Object;, ()Ljava.lang.Class;, getClass, null, ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}\n" +
+			"hashCode[METHOD_REF]{hashCode(), Ljava.lang.Object;, ()I, hashCode, null, ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}\n" +
+			"notify[METHOD_REF]{notify(), Ljava.lang.Object;, ()V, notify, null, ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}\n" +
+			"notifyAll[METHOD_REF]{notifyAll(), Ljava.lang.Object;, ()V, notifyAll, null, ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}\n" +
+			"toString[METHOD_REF]{toString(), Ljava.lang.Object;, ()Ljava.lang.String;, toString, null, ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}\n" +
+			"wait[METHOD_REF]{wait(), Ljava.lang.Object;, ()V, wait, null, ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}\n" +
+			"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (J)V, wait, (millis), ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}\n" +
+			"wait[METHOD_REF]{wait(), Ljava.lang.Object;, (JI)V, wait, (millis, nanos), ["+start1+", "+end1+"], " + (relevance2) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance2) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0005() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  MissingType m;\n" + 
+		"  void foo() {\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0006() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  MissingType m;\n" + 
+		"  public class Test1 {\n" + 
+		"    void foo() {\n" + 
+ 		"      m.b\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0007() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  MissingType m;\n" + 
+		"  public class Test1 extends test.SuperType {\n" + 
+		"    void foo() {\n" + 
+ 		"      m.e\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/test/SuperType.java",
+		"package test;"+
+		"public class SuperType {\n" + 
+		"  public Object m;\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.e";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.e") + "m.".length();
+	int end1 = start1 + "e".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), ["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0008() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  MissingType m;\n" + 
+		"  public class Test1 extends test.SuperType {\n" + 
+		"    void foo() {\n" + 
+ 		"      m.b\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/test/SuperType.java",
+		"package test;"+
+		"public class SuperType {\n" + 
+		"  public Object m;\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0009() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/missing2/MissingType.java",
+		"package missing2;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"bar[METHOD_REF]{bar(), Lmissing2.MissingType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing2.MissingType, missing2, Lmissing2.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0010() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingMemberType m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public class MissingMemberType {\n" + 
+		"    public void bar() {}\n" + 
+		"  }\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingMemberType");
+	int end2 = start2 + "MissingMemberType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType$MissingMemberType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType.MissingMemberType[TYPE_REF]{missing.MissingType.MissingMemberType, missing, Lmissing.MissingType$MissingMemberType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0011() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  MissingType m() {return null;}\n" + 
+		"  void foo() {\n" + 
+ 		"    m().b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m().b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m().b") + "m().".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0012() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  MissingType m(int i) {return null;}\n" + 
+		"  void foo() {\n" + 
+ 		"    m(0).b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = ".b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m(0).b") + "m(0).".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0013() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  MissingType m() {return null;}\n" + 
+		"  public class Inner extends missing.SuperType{\n" + 
+		"    void foo() {\n" + 
+ 		"      m().e\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/SuperType.java",
+		"package missing;"+
+		"public class SuperType {\n" + 
+		"  public Object m() {return null;}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m().e";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m().e") + "m().".length();
+	int end1 = start1 + "e".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), ["+start1+", "+end1+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0014() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  MissingType m() {return null;}\n" + 
+		"  public class Inner extends missing.SuperType{\n" + 
+		"    void foo() {\n" + 
+ 		"      m().b\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/SuperType.java",
+		"package missing;"+
+		"public class SuperType {\n" + 
+		"  public Object m() {return null;}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m().b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0015() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  MissingType m() {return null;}\n" + 
+		"  public class Inner extends missing.SuperType{\n" + 
+		"    void foo() {\n" + 
+ 		"      m().b\n" + 
+		"    }\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/SuperType.java",
+		"package missing;"+
+		"public class SuperType {\n" + 
+		"  public Object m(int i) {return null;}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m().b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m().b") + "m().".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0016() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType.MissingMemberType m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public class MissingMemberType {\n" + 
+		"    public void bar() {}\n" + 
+		"  }\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType$MissingMemberType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0017() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    missing2.MissingType.MissingMemberType m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing1/missing2/MissingType.java",
+		"package missing1.missing2;"+
+		"public class MissingType {\n" + 
+		"  public class MissingMemberType {\n" + 
+		"    public void bar() {}\n" + 
+		"  }\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0018() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    missing2.missing3.MissingType.MissingMemberType m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing1/missing2/missing3/MissingType.java",
+		"package missing1.missing2.missing3;"+
+		"public class MissingType {\n" + 
+		"  public class MissingMemberType {\n" + 
+		"    public void bar() {}\n" + 
+		"  }\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0019() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType.MissingMemberType[] m = null;\n" + 
+ 		"    m.e\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public class MissingMemberType {\n" + 
+		"    public void bar() {}\n" + 
+		"  }\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.e";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.e") + "m.".length();
+	int end1 = start1 + "e".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"equals[METHOD_REF]{equals(), Ljava.lang.Object;, (Ljava.lang.Object;)Z, equals, (obj), ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0020() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_DEPRECATION_CHECK, JavaCore.DISABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src/test/Test.java",
+			"package test;\n"+
+			"public class Test {\n"+
+			"	void foo() {\n"+
+			"		MissingMemberType m = null;\n"+
+			"		m.b\n"+
+			"	}\n"+
+			"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src/missing/MissingType.java",
+			"package missing;"+
+			"public class MissingType {\n" + 
+			"  /** @deprecated */\n" + 
+			"  public class MissingMemberType {\n" + 
+			"    public void bar() {}\n" + 
+			"  }\n" + 
+			"}\n");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "m.b";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+		int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+		int start1 = str.lastIndexOf("m.b") + "m.".length();
+		int end1 = start1 + "b".length();
+		int start2 = str.lastIndexOf("MissingMemberType");
+		int end2 = start2 + "MissingMemberType".length();
+		assertResults(
+				"bar[METHOD_REF]{bar(), Lmissing.MissingType$MissingMemberType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+				"   MissingType.MissingMemberType[TYPE_REF]{missing.MissingType.MissingMemberType, missing, Lmissing.MissingType$MissingMemberType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0021() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_DEPRECATION_CHECK, JavaCore.ENABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src/test/Test.java",
+			"package test;\n"+
+			"public class Test {\n"+
+			"	void foo() {\n"+
+			"		MissingMemberType m = null;\n"+
+			"		m.b\n"+
+			"	}\n"+
+			"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src/missing/MissingType.java",
+			"package missing;"+
+			"public class MissingType {\n" + 
+			"  /** @deprecated */\n" + 
+			"  public class MissingMemberType {\n" + 
+			"    public void bar() {}\n" + 
+			"  }\n" + 
+			"}\n");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "m.b";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+		
+		assertResults(
+				"",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0022() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_DEPRECATION_CHECK, JavaCore.DISABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src/test/Test.java",
+			"package test;\n"+
+			"public class Test {\n"+
+			"	void foo() {\n"+
+			"		MissingMemberMemberType m = null;\n"+
+			"		m.b\n"+
+			"	}\n"+
+			"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src/missing/MissingType.java",
+			"package missing;"+
+			"public class MissingType {\n" + 
+			"  	/** @deprecated */\n" + 
+			"  public class MissingMemberType {\n" + 
+			"  	 public class MissingMemberMemberType {\n" + 
+			"      public void bar() {}\n" + 
+			"    }\n" + 
+			"  }\n" + 
+			"}\n");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "m.b";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+		int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+		int start1 = str.lastIndexOf("m.b") + "m.".length();
+		int end1 = start1 + "b".length();
+		int start2 = str.lastIndexOf("MissingMemberMemberType");
+		int end2 = start2 + "MissingMemberMemberType".length();
+		assertResults(
+				"bar[METHOD_REF]{bar(), Lmissing.MissingType$MissingMemberType$MissingMemberMemberType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+				"   MissingType.MissingMemberType.MissingMemberMemberType[TYPE_REF]{missing.MissingType.MissingMemberType.MissingMemberMemberType, missing, Lmissing.MissingType$MissingMemberType$MissingMemberMemberType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void _test0023() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_DEPRECATION_CHECK, JavaCore.ENABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src/test/Test.java",
+			"package test;\n"+
+			"public class Test {\n"+
+			"	void foo() {\n"+
+			"		MissingMemberMemberType m = null;\n"+
+			"		m.b\n"+
+			"	}\n"+
+			"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src/missing/MissingType.java",
+			"package missing;"+
+			"public class MissingType {\n" + 
+			"  /** @deprecated */\n" + 
+			"  public class MissingMemberType {\n" + 
+			"  	 public class MissingMemberMemberType {\n" + 
+			"      public void bar() {}\n" + 
+			"    }\n" + 
+			"  }\n" + 
+			"}\n");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "m.b";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+		
+		assertResults(
+				"",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void _test0024() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_VISIBILITY_CHECK, JavaCore.DISABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src/test/Test.java",
+			"package test;\n"+
+			"public class Test {\n"+
+			"	void foo() {\n"+
+			"		MissingMemberType m = null;\n"+
+			"		m.b\n"+
+			"	}\n"+
+			"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src/missing/MissingType.java",
+			"package missing;"+
+			"public class MissingType {\n" + 
+			"  private class MissingMemberType {\n" + 
+			"    public void bar() {}\n" + 
+			"  }\n" + 
+			"}\n");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "m.b";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+		int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+		int start1 = str.lastIndexOf("m.b") + "m.".length();
+		int end1 = start1 + "b".length();
+		int start2 = str.lastIndexOf("MissingMemberType");
+		int end2 = start2 + "MissingMemberType".length();
+		assertResults(
+				"bar[METHOD_REF]{bar(), Lmissing.MissingType$MissingMemberType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+				"   MissingType.MissingMemberType[TYPE_REF]{missing.MissingType.MissingMemberType, missing, Lmissing.MissingType$MissingMemberType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0025() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_VISIBILITY_CHECK, JavaCore.ENABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src/test/Test.java",
+			"package test;\n"+
+			"public class Test {\n"+
+			"	void foo() {\n"+
+			"		MissingMemberType m = null;\n"+
+			"		m.b\n"+
+			"	}\n"+
+			"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src/missing/MissingType.java",
+			"package missing;"+
+			"public class MissingType {\n" + 
+			"  private class MissingMemberType {\n" + 
+			"    public void bar() {}\n" + 
+			"  }\n" + 
+			"}\n");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "m.b";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+		assertResults(
+				"",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void _test0026() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_VISIBILITY_CHECK, JavaCore.DISABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src/test/Test.java",
+			"package test;\n"+
+			"public class Test {\n"+
+			"	void foo() {\n"+
+			"		MissingMemberMemberType m = null;\n"+
+			"		m.b\n"+
+			"	}\n"+
+			"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src/missing/MissingType.java",
+			"package missing;"+
+			"public class MissingType {\n" + 
+			"  private class MissingMemberType {\n" + 
+			"  	 public class MissingMemberMemberType {\n" + 
+			"      public void bar() {}\n" + 
+			"    }\n" + 
+			"  }\n" + 
+			"}\n");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "m.b";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+		int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+		int start1 = str.lastIndexOf("m.b") + "m.".length();
+		int end1 = start1 + "b".length();
+		int start2 = str.lastIndexOf("MissingMemberMemberType");
+		int end2 = start2 + "MissingMemberMemberType".length();
+		assertResults(
+				"bar[METHOD_REF]{bar(), Lmissing.MissingType$MissingMemberType$MissingMemberMemberType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+				"   MissingType.MissingMemberType.MissingMemberMemberType[TYPE_REF]{missing.MissingType.MissingMemberType.MissingMemberMemberType, missing, Lmissing.MissingType$MissingMemberType$MissingMemberMemberType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0027() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_VISIBILITY_CHECK, JavaCore.ENABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src/test/Test.java",
+			"package test;\n"+
+			"public class Test {\n"+
+			"	void foo() {\n"+
+			"		MissingMemberMemberType m = null;\n"+
+			"		m.b\n"+
+			"	}\n"+
+			"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src/missing/MissingType.java",
+			"package missing;"+
+			"public class MissingType {\n" + 
+			"  private class MissingMemberType {\n" + 
+			"  	 public class MissingMemberMemberType {\n" + 
+			"      public void bar() {}\n" + 
+			"    }\n" + 
+			"  }\n" + 
+			"}\n");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "m.b";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+	
+		assertResults(
+				"",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0028() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"import known.KnownType;\n"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType m = null;\n" + 
+ 		"    m.field.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public known.KnownType field\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/test/known/KnownType.java",
+		"package known;"+
+		"public class KnownType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.field.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0029() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"import known.KnownType;\n"+
+		"public class Test {\n" + 
+		"  MissingType m = null;\n" + 
+		"  void foo() {\n" + 
+ 		"    m.field.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public known.KnownType field\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/test/known/KnownType.java",
+		"package known;"+
+		"public class KnownType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.field.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0030() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"import known.KnownType;\n"+
+		"public class Test {\n" + 
+		"  MissingType m(){return null;}\n" + 
+		"  void foo() {\n" + 
+ 		"    m().field.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public known.KnownType field\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/test/known/KnownType.java",
+		"package known;"+
+		"public class KnownType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m().field.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test031() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"import known.KnownType;\n"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+		"    MissingType m = null;\n" + 
+ 		"    m.method().b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public known.KnownType method() {return null;}\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/test/known/KnownType.java",
+		"package known;"+
+		"public class KnownType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.method().b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0032() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"import known.KnownType;\n"+
+		"public class Test {\n" + 
+		"  MissingType m(){return null;}\n" + 
+		"  void foo() {\n" + 
+ 		"    m().method().b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public known.KnownType method() {return null;}\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/test/known/KnownType.java",
+		"package known;"+
+		"public class KnownType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m().method().b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0033() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  /** @see MissingType#b */\n" + 
+		"  void foo() {\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar()\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "MissingType#b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests2.java
new file mode 100644
index 0000000..d5375dd
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests2.java
@@ -0,0 +1,255 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.model;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.Hashtable;
+
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.internal.codeassist.RelevanceConstants;
+
+import junit.framework.*;
+
+public class CompletionWithMissingTypesTests2 extends ModifyingResourceTests implements RelevanceConstants {
+
+public CompletionWithMissingTypesTests2(String name) {
+	super(name);
+}
+public void setUpSuite() throws Exception {
+	super.setUpSuite();
+	
+	setUpJavaProject("Completion");
+}
+public void tearDownSuite() throws Exception {
+	deleteProject("Completion");
+	
+	super.tearDownSuite();
+}
+
+protected static void assertResults(String expected, String actual) {
+	try {
+		assertEquals(expected, actual);
+	} catch(ComparisonFailure c) {
+		System.out.println(actual);
+		System.out.println();
+		throw c;
+	}
+}
+static {
+//	TESTS_NAMES = new String[] { "testBug96950" };
+}
+public static Test suite() {
+	return buildModelTestSuite(CompletionWithMissingTypesTests2.class);
+}
+
+File createFile(File parent, String name, String content) throws IOException {
+	File file = new File(parent, name);
+	FileOutputStream out = new FileOutputStream(file);
+	out.write(content.getBytes());
+	out.close();
+	return file;
+}
+File createDirectory(File parent, String name) {
+	File dir = new File(parent, name);
+	dir.mkdirs();
+	return dir;
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0001() throws Exception {
+	Hashtable oldOptions = JavaCore.getOptions();
+	try {
+		Hashtable options = new Hashtable(oldOptions);
+		options.put(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE, JavaCore.ERROR);
+		options.put(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, JavaCore.WARNING);
+		options.put(JavaCore.CODEASSIST_FORBIDDEN_REFERENCE_CHECK, JavaCore.DISABLED);
+		options.put(JavaCore.CODEASSIST_DISCOURAGED_REFERENCE_CHECK, JavaCore.DISABLED);
+		JavaCore.setOptions(options);
+		
+		// create variable
+//		JavaCore.setClasspathVariables(
+//			new String[] {"JCL_LIB", "JCL_SRC", "JCL_SRCROOT"},
+//			new IPath[] {getExternalJCLPath(), getExternalJCLSourcePath(), getExternalJCLRootSourcePath()},
+//			null);
+
+		// create P1
+		this.createJavaProject(
+			"P1",
+			new String[]{"src"},
+			new String[]{"JCL_LIB"},
+			 "bin");
+		
+		this.createFolder("/P1/src/a");
+		this.createFile(
+				"/P1/src/a/XX.java",
+				"package a;\n"+
+				"public class XX {\n"+
+				"  void foo() {}\n"+
+				"}");
+
+		this.createFolder("/P1/src/b");
+		this.createFile(
+				"/P1/src/b/XX.java",
+				"package b;\n"+
+				"public class XX {\n"+
+				"  void foo() {}\n"+
+				"}");
+		
+		// create P2
+		this.createJavaProject(
+			"P2",
+			new String[]{"src"},
+			new String[]{"JCL_LIB"},
+			null,
+			null,
+			new String[]{"/P1"},
+			new String[][]{{}},
+			new String[][]{{"a/*"}},
+			new boolean[]{false},
+			"bin",
+			null,
+			null,
+			null,
+			"1.4");
+		this.createFile(
+			"/P2/src/YY.java",
+			"public class YY {\n"+
+			"  void foo() {\n"+
+			"    XX x = null;\n"+
+			"    x.fo\n"+
+			"  }\n"+
+			"}");
+		
+		waitUntilIndexesReady();
+		
+		// do completion
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		ICompilationUnit cu= getCompilationUnit("P2", "src", "", "YY.java");
+		
+		String str = cu.getSource();
+		String completeBehind = "x.fo";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		cu.codeComplete(cursorLocation, requestor);
+		
+		int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+		int start1 = str.lastIndexOf("x.fo") + "x.".length();
+		int end1 = start1 + "fo".length();
+		int start2 = str.lastIndexOf("XX");
+		int end2 = start2 + "XX".length();
+		assertResults(
+				"foo[METHOD_REF]{foo(), La.XX;, ()V, foo, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+				"   XX[TYPE_REF]{a.XX, a, La.XX;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+				"foo[METHOD_REF]{foo(), Lb.XX;, ()V, foo, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+				"   XX[TYPE_REF]{b.XX, b, Lb.XX;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+				requestor.getResults());
+	} finally {
+		this.deleteProject("P1");
+		this.deleteProject("P2");
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0002() throws Exception {
+	Hashtable oldOptions = JavaCore.getOptions();
+	try {
+		Hashtable options = new Hashtable(oldOptions);
+		options.put(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE, JavaCore.ERROR);
+		options.put(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, JavaCore.WARNING);
+		options.put(JavaCore.CODEASSIST_FORBIDDEN_REFERENCE_CHECK, JavaCore.ENABLED);
+		options.put(JavaCore.CODEASSIST_DISCOURAGED_REFERENCE_CHECK, JavaCore.DISABLED);
+		JavaCore.setOptions(options);
+		
+		// create variable
+//		JavaCore.setClasspathVariables(
+//			new String[] {"JCL_LIB", "JCL_SRC", "JCL_SRCROOT"},
+//			new IPath[] {getExternalJCLPath(), getExternalJCLSourcePath(), getExternalJCLRootSourcePath()},
+//			null);
+
+		// create P1
+		this.createJavaProject(
+			"P1",
+			new String[]{"src"},
+			new String[]{"JCL_LIB"},
+			 "bin");
+		
+		this.createFolder("/P1/src/a");
+		this.createFile(
+				"/P1/src/a/XX.java",
+				"package a;\n"+
+				"public class XX {\n"+
+				"  void foo() {}\n"+
+				"}");
+
+		this.createFolder("/P1/src/b");
+		this.createFile(
+				"/P1/src/b/XX.java",
+				"package b;\n"+
+				"public class XX {\n"+
+				"  void foo() {}\n"+
+				"}");
+		
+		// create P2
+		this.createJavaProject(
+			"P2",
+			new String[]{"src"},
+			new String[]{"JCL_LIB"},
+			null,
+			null,
+			new String[]{"/P1"},
+			new String[][]{{}},
+			new String[][]{{"a/*"}},
+			new boolean[]{false},
+			"bin",
+			null,
+			null,
+			null,
+			"1.4");
+		this.createFile(
+			"/P2/src/YY.java",
+			"public class YY {\n"+
+			"  void foo() {\n"+
+			"    XX x = null;\n"+
+			"    x.fo\n"+
+			"  }\n"+
+			"}");
+		
+		waitUntilIndexesReady();
+		
+		// do completion
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		ICompilationUnit cu= getCompilationUnit("P2", "src", "", "YY.java");
+		
+		String str = cu.getSource();
+		String completeBehind = "x.fo";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		cu.codeComplete(cursorLocation, requestor);
+		
+		int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+		int start1 = str.lastIndexOf("x.fo") + "x.".length();
+		int end1 = start1 + "fo".length();
+		int start2 = str.lastIndexOf("XX");
+		int end2 = start2 + "XX".length();
+		assertResults(
+				"foo[METHOD_REF]{foo(), Lb.XX;, ()V, foo, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+				"   XX[TYPE_REF]{b.XX, b, Lb.XX;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+				requestor.getResults());
+	} finally {
+		this.deleteProject("P1");
+		this.deleteProject("P2");
+		JavaCore.setOptions(oldOptions);
+	}
+}
+}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests_1_5.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests_1_5.java
new file mode 100644
index 0000000..0cc023d
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionWithMissingTypesTests_1_5.java
@@ -0,0 +1,522 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.model;
+
+import org.eclipse.jdt.core.*;
+import org.eclipse.jdt.internal.codeassist.RelevanceConstants;
+
+import junit.framework.*;
+
+public class CompletionWithMissingTypesTests_1_5 extends AbstractJavaModelCompletionTests implements RelevanceConstants {
+	static {
+//		TESTS_NAMES = new String[]{"test0040"};
+	}
+public CompletionWithMissingTypesTests_1_5(String name) {
+	super(name);
+}
+public void setUpSuite() throws Exception {
+	if (COMPLETION_PROJECT == null)  {
+		COMPLETION_PROJECT = setUpJavaProject("Completion", "1.5");
+	} else {
+		setUpProjectCompliance(COMPLETION_PROJECT, "1.5");
+	}
+	super.setUpSuite();
+}
+
+public void tearDownSuite() throws Exception {
+	super.tearDownSuite();
+}
+public static Test suite() {
+	return buildModelTestSuite(CompletionWithMissingTypesTests_1_5.class);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0001() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType<Object> m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType<T> {\n" + 
+		"  public void bar() {};\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Ljava.lang.Object;>;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType<T>[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType<TT;>;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0002() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType<MissingType2> m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType<T> {\n" + 
+		"  public void bar() {};\n" + 
+		"  public void bar(T t) {};\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/missing/MissingType2.java",
+		"package missing;"+
+		"public class MissingType2 {\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType2");
+	int end2 = start2 + "MissingType2".length();
+	int start3 = str.lastIndexOf("MissingType<");
+	int end3 = start3 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Lmissing.MissingType2;>;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType2[TYPE_REF]{missing.MissingType2, missing, Lmissing.MissingType2;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"   MissingType<T>[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType<TT;>;, null, null, ["+start3+", "+end3+"], " + (relevance1) + "}\n" +
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Lmissing.MissingType2;>;, (Lmissing.MissingType2;)V, bar, (t), ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType2[TYPE_REF]{missing.MissingType2, missing, Lmissing.MissingType2;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"   MissingType<T>[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType<TT;>;, null, null, ["+start3+", "+end3+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0003() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"import missing.MissingType;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType<MissingType2> m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType<T> {\n" + 
+		"  public void bar() {};\n" + 
+		"  public void bar(T t) {};\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/missing/MissingType2.java",
+		"package missing;"+
+		"public class MissingType2 {\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType2");
+	int end2 = start2 + "MissingType2".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Lmissing.MissingType2;>;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType2[TYPE_REF]{missing.MissingType2, missing, Lmissing.MissingType2;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Lmissing.MissingType2;>;, (Lmissing.MissingType2;)V, bar, (t), ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType2[TYPE_REF]{missing.MissingType2, missing, Lmissing.MissingType2;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0004() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"import missing.MissingType2;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType<MissingType2> m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType<T> {\n" + 
+		"  public void bar() {};\n" + 
+		"  public void bar(T t) {};\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/missing/MissingType2.java",
+		"package missing;"+
+		"public class MissingType2 {\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType<");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Lmissing.MissingType2;>;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType<T>[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType<TT;>;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Lmissing.MissingType2;>;, (Lmissing.MissingType2;)V, bar, (t), ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType<T>[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType<TT;>;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0005() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[6];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType<MissingType1, MissingType2> m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType<T, U> {\n" + 
+		"  public void bar(T t, U u) {};\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/missing/MissingType1.java",
+		"package missing;"+
+		"public class MissingType1 {\n" + 
+		"}\n");
+	
+	this.workingCopies[3] = getWorkingCopy(
+		"/Completion/src/missing/MissingType2.java",
+		"package missing;"+
+		"public class MissingType2 {\n" + 
+		"}\n");
+	
+	this.workingCopies[4] = getWorkingCopy(
+		"/Completion/src/missing2/MissingType1.java",
+		"package missing2;"+
+		"public class MissingType1 {\n" + 
+		"}\n");
+	
+	this.workingCopies[5] = getWorkingCopy(
+		"/Completion/src/missing2/MissingType2.java",
+		"package missing2;"+
+		"public class MissingType2 {\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType1");
+	int end2 = start2 + "MissingType1".length();
+	int start3 = str.lastIndexOf("MissingType2");
+	int end3 = start3 + "MissingType2".length();
+	int start4 = str.lastIndexOf("MissingType<");
+	int end4 = start4 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Lmissing.MissingType1;Lmissing.MissingType2;>;, (Lmissing.MissingType1;Lmissing.MissingType2;)V, bar, (t, u), ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType1[TYPE_REF]{missing.MissingType1, missing, Lmissing.MissingType1;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"   MissingType2[TYPE_REF]{missing.MissingType2, missing, Lmissing.MissingType2;, null, null, ["+start3+", "+end3+"], " + (relevance1) + "}\n" +
+			"   MissingType<T,U>[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType<TT;TU;>;, null, null, ["+start4+", "+end4+"], " + (relevance1) + "}\n" +
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Lmissing.MissingType1;Lmissing2.MissingType2;>;, (Lmissing.MissingType1;Lmissing2.MissingType2;)V, bar, (t, u), ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType1[TYPE_REF]{missing.MissingType1, missing, Lmissing.MissingType1;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"   MissingType2[TYPE_REF]{missing2.MissingType2, missing2, Lmissing2.MissingType2;, null, null, ["+start3+", "+end3+"], " + (relevance1) + "}\n" +
+			"   MissingType<T,U>[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType<TT;TU;>;, null, null, ["+start4+", "+end4+"], " + (relevance1) + "}\n" +
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Lmissing2.MissingType1;Lmissing.MissingType2;>;, (Lmissing2.MissingType1;Lmissing.MissingType2;)V, bar, (t, u), ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType1[TYPE_REF]{missing2.MissingType1, missing2, Lmissing2.MissingType1;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"   MissingType2[TYPE_REF]{missing.MissingType2, missing, Lmissing.MissingType2;, null, null, ["+start3+", "+end3+"], " + (relevance1) + "}\n" +
+			"   MissingType<T,U>[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType<TT;TU;>;, null, null, ["+start4+", "+end4+"], " + (relevance1) + "}\n" +
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Lmissing2.MissingType1;Lmissing2.MissingType2;>;, (Lmissing2.MissingType1;Lmissing2.MissingType2;)V, bar, (t, u), ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType1[TYPE_REF]{missing2.MissingType1, missing2, Lmissing2.MissingType1;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"   MissingType2[TYPE_REF]{missing2.MissingType2, missing2, Lmissing2.MissingType2;, null, null, ["+start3+", "+end3+"], " + (relevance1) + "}\n" +
+			"   MissingType<T,U>[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType<TT;TU;>;, null, null, ["+start4+", "+end4+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0006() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  MissingType m(int ... i) {return null;}\n" + 
+		"  void foo() {\n" + 
+ 		"    m(0, 0).b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public void bar() {}\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = ".b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m(0, 0).b") + "m(0, 0).".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0007() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    AType<? extends MissingType> m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/test/AType.java",
+		"package tezt;"+
+		"public class AType<T> {\n" + 
+		"  public void bar(T t) {};\n" + 
+		"}\n");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"}\n");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Ltest.AType<!+Lmissing.MissingType;>;, (!+Lmissing.MissingType;)V, bar, (t), ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0008() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType.MissingMemberType<Object> m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType {\n" + 
+		"  public class MissingMemberType<T> {\n" + 
+		"    public void bar() {};\n" + 
+		"  }\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType$MissingMemberType<Ljava.lang.Object;>;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0009() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    missing2.MissingType<Object> m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing1/missing2/MissingType.java",
+		"package missing1.missing2;"+
+		"public class MissingType<T> {\n" + 
+		"  public void bar() {};\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0010() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingType<Object>.MissingMemberType<Object> m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType<T> {\n" + 
+		"  public class MissingMemberType<T> {\n" + 
+		"    public void bar() {};\n" + 
+		"  }\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_NON_STATIC + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("m.b") + "m.".length();
+	int end1 = start1 + "b".length();
+	int start2 = str.lastIndexOf("MissingType");
+	int end2 = start2 + "MissingType".length();
+	assertResults(
+			"bar[METHOD_REF]{bar(), Lmissing.MissingType<Ljava.lang.Object;>.MissingMemberType<Ljava.lang.Object;>;, ()V, bar, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   MissingType<T>[TYPE_REF]{missing.MissingType, missing, Lmissing.MissingType<TT;>;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=44984
+public void test0011() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src/test/Test.java",
+		"package test;"+
+		"public class Test {\n" + 
+		"  void foo() {\n" + 
+ 		"    MissingMemberType<Object> m = null;\n" + 
+ 		"    m.b\n" + 
+		"  }\n" + 
+		"}\n");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src/missing/MissingType.java",
+		"package missing;"+
+		"public class MissingType<T> {\n" + 
+		"  public class MissingMemberType<T> {\n" + 
+		"    public void bar() {};\n" + 
+		"  }\n" + 
+		"}\n");
+
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "m.b";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/RunCompletionModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/RunCompletionModelTests.java
index 57d7817..6b1ca93 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/RunCompletionModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/RunCompletionModelTests.java
@@ -30,6 +30,8 @@ public class RunCompletionModelTests extends junit.framework.TestCase {
 			COMPLETION_SUITES.add(CompletionTests_1_5.class);
 			COMPLETION_SUITES.add(CompletionContextTests.class);
 			COMPLETION_SUITES.add(CompletionContextTests_1_5.class);
+			COMPLETION_SUITES.add(CompletionWithMissingTypesTests.class);
+			COMPLETION_SUITES.add(CompletionWithMissingTypesTests_1_5.class);
 			COMPLETION_SUITES.add(SnippetCompletionContextTests.class);
 		}
 		COMPLETION_SUITES.add(JavadocTypeCompletionModelTest.class);
@@ -45,11 +47,12 @@ public class RunCompletionModelTests extends junit.framework.TestCase {
 	public static Class[] getTestClasses() {
 		int size = COMPLETION_SUITES.size();
 		if (!ONLY_JAVADOC) {
-			Class[] testClasses = new Class[size+3];
+			Class[] testClasses = new Class[size+4];
 			COMPLETION_SUITES.toArray(testClasses);
 			testClasses[size] = CompletionTests2.class;
-			testClasses[size+1] = SnippetCompletionTests.class;
-			testClasses[size+2] = SnippetCompletionTests_1_5.class;
+			testClasses[size+1] = CompletionWithMissingTypesTests2.class;
+			testClasses[size+2] = SnippetCompletionTests.class;
+			testClasses[size+3] = SnippetCompletionTests_1_5.class;
 			return testClasses;
 		}
 		Class[] testClasses = new Class[size];
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 24ce75a..7b8e2a6 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -79,10 +79,139 @@ public void searchAllTypeNames(
 Similarily to previous added <code>searchAllTypeNames</code> new API method, clients have to provide
 a new requestor: <code>TypeNameMatchRequestor</code> in order to get matches collected during the search.
 </li>
+<li>Code Assist can return completion proprosals that required some other completion proposals:<br>
+To apply a completion proposal the required completion proposals must be applied otherwise the resulting code won't be correct.<br>
+To manage completion proposalswith required proposals the following API have been added:
+<pre>
+public class CompletionProposal {
+
+	...
+
+	/**
+	 * Returns the required completion proposals.
+	 * The proposal can be apply only if these required completion proposals are also applied.
+	 * If the required proposal aren't applied the completion could create complations problems.
+	 * 
+	 * &lt;p&gt;
+	 * This field is available for the following kinds of
+	 * completion proposals:
+	 * &lt;ul&gt;
+	 * 	&lt;li&gt;&lt;code&gt;FIELD_REF&lt;/code&gt;&lt;/li&gt;
+	 * 	&lt;li&gt;&lt;code&gt;METHOD_REF&lt;/code&gt;/li&gt;
+	 * &lt;/ul&gt;
+	 * &lt;/p&gt;
+	 * &lt;p&gt;
+	 * A required completion proposal can is a completion proposal of one of the following kinds:
+	 * &lt;ul&gt;
+	 *  &lt;li&gt;&lt;code&gt;TYPE_REF&lt;/code&gt;&lt;/li&gt;
+	 * &lt;/ul&gt;
+	 * Other kinds of required proposals will be returned in the future, therefore clients of this
+	 * API must allow with {@link CompletionRequestor#setAllowsRequiredProposals(int, boolean)} 
+	 * only kinds which are in this list to avoid unexpected results in the future.
+	 * &lt;/p&gt;
+	 * &lt;p&gt;
+	 * A required completion proposal cannot have required completion proposals.
+	 * &lt;/p&gt;
+	 * 
+	 * @return the required completion proposals, or &lt;code&gt;null&lt;/code&gt; if none.
+	 * 
+	 * @see CompletionRequestor#setAllowsRequiredProposals(int, boolean)
+	 * 
+	 * @since 3.3
+	 */
+	public CompletionProposal[] getRequiredProposals() {...}
+
+	...
+
+}
+</pre>
+<pre>
+public class CompletionRequestor {
+
+	...
+
+	/**
+	 * Returns whether a proposal with a required proposal
+	 * of the given kind is allowed.
+	 * 
+	 * @param completionProposalKind one of the kind constants declared
+	 * on &lt;code&gt;CompletionProposal&lt;/code&gt;
+	 * @return &lt;code&gt;true&lt;/code&gt; if a proposal with a required proposal
+	 * of the given kind is allowed by this requestor, and &lt;code&gt;false&lt;/code&gt; 
+	 * if it isn't of interest.
+	 * &lt;p&gt;
+	 * By default, all kinds of required proposals aren't allowed.
+	 * &lt;/p&gt;
+	 * @see #setAllowsRequiredProposals(int, boolean)
+	 * @see CompletionProposal#getKind()
+	 * @see CompletionProposal#getRequiredProposals()
+	 * 
+	 * @since 3.3
+	 */
+	public boolean isAllowingRequiredProposals(int completionProposalKind) {...}
+	
+	/**
+	 * Sets whether a proposal with a required proposal
+	 * of the given kind is allowed.
+	 * 
+	 * @param completionProposalKind one of the kind constants declared
+	 * on &lt;code&gt;CompletionProposal&lt;/code&gt;
+	 * @param allow &lt;code&gt;true&lt;/code&gt; if a proposal with a required proposal
+	 * of the given kind is allowed by this requestor, and &lt;code&gt;false&lt;/code&gt; 
+	 * if it isn't of interest
+	 * @see #isAllowingRequiredProposals(int)
+	 * @see CompletionProposal#getKind()
+	 * @see CompletionProposal#getRequiredProposals()
+	 * 
+	 * @since 3.3
+	 */
+	public void setAllowsRequiredProposals(int completionProposalKind, boolean allow) {...}
+
+	...
+
+}
+</pre>
+</li>
+<li>Code Assist propose completion even if the type of a variable or the return type of the method is missing.<br>
+e.g.
+<pre>
+package p;
+public class X {
+  void foo() {
+    Vector v = null;
+    v.addEl| // complete at | location
+  }
+}
+</pre>
+A completion proposal with required proposals will be returned. The main proposal will be the method <code>addElement()</code>
+at <code>addEl</code> location with a required proposal of the type <code>java.util.Vector</code> at 
+<code>Vector</code> location.
+The same kind of completion can be computed with the following examples.
+<pre>
+package p;
+public class X {
+  Vector v = null;
+  void foo() {
+    v.addEl| // complete at | location
+  }
+}
+</pre>
+<pre>
+package p;
+public class X {
+  Vector bar() {return null;}
+  void foo() {
+    bar().addEl| // complete at | location
+  }
+}
+</pre>
+</li>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=160494">160494</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=44984">44984</a>
+[typing] Automatically optimize class imports
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=160494">160494</a>
 [search] searchAllTypeNames(char[][], char[][],...) fails to find types in default package
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=160328">160328</a>
 [search] Remove constructor TypeNameMatch(IType)
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 4aa380d..ea6b670 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -68,6 +68,105 @@ public final class CompletionEngine
 	extends Engine
 	implements ISearchRequestor, TypeConstants , TerminalTokens , RelevanceConstants, SuffixConstants {
 	
+	public class CompletionProblemFactory extends DefaultProblemFactory {
+		private int lastErrorStart;
+		
+		public boolean checkProblems = false;
+		public boolean hasProblems = false;
+
+		public CompletionProblemFactory(Locale loc) {
+			super(loc);
+		}
+
+		public CategorizedProblem createProblem(
+			char[] originatingFileName,
+			int problemId,
+			String[] problemArguments,
+			String[] messageArguments,
+			int severity,
+			int start,
+			int end,
+			int lineNumber,
+			int columnNumber) {
+			
+			CategorizedProblem pb = super.createProblem(
+				originatingFileName,
+				problemId,
+				problemArguments,
+				messageArguments,
+				severity,
+				start,
+				end,
+				lineNumber,
+				columnNumber);
+			int id = pb.getID();
+			if (CompletionEngine.this.actualCompletionPosition > start
+				&& this.lastErrorStart < start
+				&& pb.isError()
+				&& (id & IProblem.Syntax) == 0
+				&& (CompletionEngine.this.fileName == null || CharOperation.equals(CompletionEngine.this.fileName, originatingFileName))) {
+					
+				CompletionEngine.this.problem = pb;
+				this.lastErrorStart = start;
+			}
+			if (this.checkProblems && !this.hasProblems) {
+				if (id == IProblem.UsingDeprecatedType) {
+					this.hasProblems =
+						CompletionEngine.this.options.checkDeprecation;
+				} else if (id == IProblem.NotVisibleType) {
+					this.hasProblems =
+						CompletionEngine.this.options.checkVisibility;
+				} else if (id == IProblem.ForbiddenReference) {
+					this.hasProblems =
+						CompletionEngine.this.options.checkForbiddenReference;
+				} else if (id == IProblem.DiscouragedReference) {
+					this.hasProblems =
+						CompletionEngine.this.options.checkDiscouragedReference;
+				} else {
+					this.hasProblems = true;
+				}
+			}
+			
+			return pb;
+		}
+	}
+
+	private class AcceptedType {
+		public AcceptedType(
+			char[] packageName,
+			char[] simpleTypeName,
+			char[][] enclosingTypeNames,
+			int modifiers,
+			int accessibility) {
+			this.packageName = packageName;
+			this.simpleTypeName = simpleTypeName;
+			this.enclosingTypeNames = enclosingTypeNames;
+			this.modifiers = modifiers;
+			this.accessibility = accessibility;
+		}
+		public char[] packageName;
+		public char[] simpleTypeName;
+		public char[][] enclosingTypeNames;
+		public int modifiers;
+		public int accessibility;
+		
+		public boolean mustBeQualified = false;
+		public char[] fullyQualifiedName = null;
+		public char[] qualifiedTypeName = null;
+		
+		public String toString() {
+			StringBuffer buffer = new StringBuffer();
+			buffer.append('{');
+			buffer.append(packageName);
+			buffer.append(',');
+			buffer.append(simpleTypeName);
+			buffer.append(',');
+			buffer.append(CharOperation.concatWith(enclosingTypeNames, '.'));
+			buffer.append('}');
+			return buffer.toString();
+		}
+	}
+	
 	public HashtableOfObject typeCache;
 	
 	public static boolean DEBUG = false;
@@ -118,6 +217,7 @@ public final class CompletionEngine
 	IJavaProject javaProject;
 	CompletionParser parser;
 	CompletionRequestor requestor;
+	CompletionProblemFactory problemFactory;
 	ProblemReporter problemReporter;
 	char[] source;
 	char[] completionToken;
@@ -195,44 +295,8 @@ public final class CompletionEngine
 		public int sourceEnd() { return 0; 	}
 	};
 	
-	private class AcceptedType {
-		public AcceptedType(
-			char[] packageName,
-			char[] simpleTypeName,
-			char[][] enclosingTypeNames,
-			int modifiers,
-			int accessibility) {
-			this.packageName = packageName;
-			this.simpleTypeName = simpleTypeName;
-			this.enclosingTypeNames = enclosingTypeNames;
-			this.modifiers = modifiers;
-			this.accessibility = accessibility;
-		}
-		public char[] packageName;
-		public char[] simpleTypeName;
-		public char[][] enclosingTypeNames;
-		public int modifiers;
-		public int accessibility;
-		
-		public boolean mustBeQualified = false;
-		public char[] fullyQualifiedName = null;
-		public char[] qualifiedTypeName = null;
-		
-		public String toString() {
-			StringBuffer buffer = new StringBuffer();
-			buffer.append('{');
-			buffer.append(packageName);
-			buffer.append(',');
-			buffer.append(simpleTypeName);
-			buffer.append(',');
-			buffer.append(CharOperation.concatWith(enclosingTypeNames, '.'));
-			buffer.append('}');
-			return buffer.toString();
-		}
-	}
-	
 	private ObjectVector acceptedTypes;
-
+	
 	/**
 	 * The CompletionEngine is responsible for computing source completions.
 	 *
@@ -261,47 +325,11 @@ public final class CompletionEngine
 		this.nameEnvironment = nameEnvironment;
 		this.typeCache = new HashtableOfObject(5);
 
+		this.problemFactory = new CompletionProblemFactory(Locale.getDefault());
 		this.problemReporter = new ProblemReporter(
 				DefaultErrorHandlingPolicies.proceedWithAllProblems(),
 				this.compilerOptions,
-				new DefaultProblemFactory(Locale.getDefault()) {
-					int lastErrorStart;
-					
-					public CategorizedProblem createProblem(
-						char[] originatingFileName,
-						int problemId,
-						String[] problemArguments,
-						String[] messageArguments,
-						int severity,
-						int start,
-						int end,
-						int lineNumber,
-						int columnNumber) {
-						
-						CategorizedProblem pb = super.createProblem(
-							originatingFileName,
-							problemId,
-							problemArguments,
-							messageArguments,
-							severity,
-							start,
-							end,
-							lineNumber,
-							columnNumber);
-						if(CompletionEngine.this.actualCompletionPosition > start
-							&& this.lastErrorStart < start
-							&& pb.isError()
-							&& (pb.getID() & IProblem.Syntax) == 0
-							&& (CompletionEngine.this.fileName == null || CharOperation.equals(CompletionEngine.this.fileName, originatingFileName))) {
-								
-							CompletionEngine.this.problem = pb;
-							this.lastErrorStart = start;
-						}
-						
-						return pb;
-					}
-
-				});
+				problemFactory);
 		this.lookupEnvironment =
 			new LookupEnvironment(this, this.compilerOptions, this.problemReporter, nameEnvironment);
 		this.parser =
@@ -565,6 +593,37 @@ public final class CompletionEngine
 		this.acceptedTypes = null; // reset
 	}
 
+	// this code is derived from MethodBinding#areParametersCompatibleWith(TypeBinding[])
+	private final boolean areParametersCompatibleWith(TypeBinding[] parameters, TypeBinding[] arguments, boolean isVarargs) {
+		int paramLength = parameters.length;
+		int argLength = arguments.length;
+		int lastIndex = argLength;
+		if (isVarargs) {
+			lastIndex = paramLength - 1;
+			if (paramLength == argLength) { // accept X[] but not X or X[][]
+				TypeBinding varArgType = parameters[lastIndex]; // is an ArrayBinding by definition
+				TypeBinding lastArgument = arguments[lastIndex];
+				if (varArgType != lastArgument && !lastArgument.isCompatibleWith(varArgType))
+					return false;
+			} else if (paramLength < argLength) { // all remainig argument types must be compatible with the elementsType of varArgType
+				TypeBinding varArgType = ((ArrayBinding) parameters[lastIndex]).elementsType();
+				for (int i = lastIndex; i < argLength; i++)
+					if (varArgType != arguments[i] && !arguments[i].isCompatibleWith(varArgType))
+						return false;
+			} else if (lastIndex != argLength) { // can call foo(int i, X ... x) with foo(1) but NOT foo();
+				return false;
+			}
+			// now compare standard arguments from 0 to lastIndex
+		} else {
+			if(paramLength != argLength)
+				return false;
+		}
+		for (int i = 0; i < lastIndex; i++)
+			if (parameters[i] != arguments[i] && !arguments[i].isCompatibleWith(parameters[i]))
+				return false;
+		return true;
+	}
+	
 	private void proposeType(char[] packageName, char[] simpleTypeName, int modifiers, int accessibility, char[] typeName, char[] fullyQualifiedName, boolean isQualified) {
 		char[] completionName = fullyQualifiedName;
 		if(isQualified) {
@@ -746,7 +805,7 @@ public final class CompletionEngine
 				SourceTypeBinding enclosingType = scope.enclosingSourceType();
 				if (!enclosingType.isAnnotationType()) {
 					if (!this.requestor.isIgnored(CompletionProposal.METHOD_DECLARATION)) {
-						findMethods(this.completionToken,null,null,enclosingType,scope,new ObjectVector(),false,false,true,null,null,false,false,true);
+						findMethods(this.completionToken,null,null,enclosingType,scope,new ObjectVector(),false,false,true,null,null,false,false,true,null, null, null);
 					}
 					if (!this.requestor.isIgnored(CompletionProposal.POTENTIAL_METHOD_DECLARATION)) {
 						proposeNewMethod(this.completionToken, enclosingType);
@@ -768,7 +827,7 @@ public final class CompletionEngine
 				SourceTypeBinding enclosingType = scope.enclosingSourceType();
 				if (!enclosingType.isAnnotationType()) {
 					if (!this.requestor.isIgnored(CompletionProposal.METHOD_DECLARATION)) {
-						findMethods(this.completionToken,null,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false,false,true);
+						findMethods(this.completionToken,null,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false,false,true,null, null, null);
 					}
 					if (!this.requestor.isIgnored(CompletionProposal.POTENTIAL_METHOD_DECLARATION)) {
 						proposeNewMethod(this.completionToken, scope.enclosingSourceType());
@@ -861,12 +920,49 @@ public final class CompletionEngine
 			this.completionToken = ref.completionIdentifier;
 			long completionPosition = ref.sourcePositions[ref.sourcePositions.length - 1];
 
-			if (qualifiedBinding instanceof VariableBinding) {
-
+			if (qualifiedBinding.problemId() == ProblemReasons.NotFound) {
+				setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
+				// complete field members with missing fields type
+				// class X {
+				//   Missing f;
+				//   void foo() {
+				//     f.|
+				//   }
+				// }
+				if (this.assistNodeInJavadoc == 0 &&
+						this.requestor.isAllowingRequiredProposals(CompletionProposal.TYPE_REF)) {
+					if(ref.tokens.length == 1) {
+						findFieldsAndMethodsFromMissingFieldType(ref.tokens[0], scope, ref, insideTypeAnnotation);
+					}
+				}
+			} else if (qualifiedBinding instanceof VariableBinding) {
 				setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
 				TypeBinding receiverType = ((VariableBinding) qualifiedBinding).type;
 				if (receiverType != null) {
-					findFieldsAndMethods(this.completionToken, receiverType.capture(scope, ref.sourceEnd), scope, ref, scope,false,false);
+					findFieldsAndMethods(this.completionToken, receiverType.capture(scope, ref.sourceEnd), scope, ref, scope,false,false, null, null, null);
+				} else if (this.assistNodeInJavadoc == 0 &&
+						this.requestor.isAllowingRequiredProposals(CompletionProposal.TYPE_REF)) {
+					boolean proposeField = !this.requestor.isIgnored(CompletionProposal.FIELD_REF);
+					boolean proposeMethod = !this.requestor.isIgnored(CompletionProposal.METHOD_REF);
+					if (proposeField || proposeMethod) {
+						if (qualifiedBinding instanceof LocalVariableBinding) {
+							// complete local variable members with missing variables type
+							// class X {
+							//   void foo() {
+							//     Missing f;
+							//     f.|
+							//   }
+							// }
+							LocalVariableBinding localVariableBinding = (LocalVariableBinding) qualifiedBinding;
+							
+							findFieldsAndMethodsFromMissingType(
+									this.completionToken,
+									localVariableBinding.declaration.type,
+									localVariableBinding.declaringScope,
+									ref,
+									scope);
+						}
+					}
 				}
 
 			} else if (qualifiedBinding instanceof ReferenceBinding && !(qualifiedBinding instanceof TypeVariableBinding)) {
@@ -928,7 +1024,10 @@ public final class CompletionEngine
 						ref,
 						scope,
 						false,
-						false);
+						false,
+						null,
+						null,
+						null);
 				}
 
 				if (!isInsideAnnotationAttribute && !this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
@@ -946,7 +1045,10 @@ public final class CompletionEngine
 						scope,
 						false,
 						false,
-						false);
+						false,
+						null,
+						null,
+						null);
 				}
 
 			} else if (qualifiedBinding instanceof PackageBinding) {
@@ -996,18 +1098,41 @@ public final class CompletionEngine
 
 			this.completionToken = access.token;
 			
-			if (!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
-				findKeywords(this.completionToken, new char[][]{Keywords.NEW}, false, false);
+			if (qualifiedBinding.problemId() == ProblemReasons.NotFound) {
+				// complete method members with missing return type
+				// class X {
+				//   Missing f() {return null;}
+				//   void foo() {
+				//     f().|
+				//   }
+				// }
+				if (this.assistNodeInJavadoc == 0 &&
+						this.requestor.isAllowingRequiredProposals(CompletionProposal.TYPE_REF)) {
+					ProblemMethodBinding problemMethodBinding = (ProblemMethodBinding) qualifiedBinding;				
+					findFieldsAndMethodsFromMissingReturnType(
+							problemMethodBinding.selector,
+							problemMethodBinding.parameters,
+							scope,
+							access,
+							insideTypeAnnotation);
+				}
+			} else {
+				if (!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
+					findKeywords(this.completionToken, new char[][]{Keywords.NEW}, false, false);
+				}
+				
+				findFieldsAndMethods(
+					this.completionToken,
+					((TypeBinding) qualifiedBinding).capture(scope, access.receiver.sourceEnd),
+					scope,
+					access,
+					scope,
+					false,
+					access.receiver instanceof SuperReference,
+					null,
+					null,
+					null);
 			}
-			
-			findFieldsAndMethods(
-				this.completionToken,
-				((TypeBinding) qualifiedBinding).capture(scope, access.receiver.sourceEnd),
-				scope,
-				access,
-				scope,
-				false,
-				access.receiver instanceof SuperReference);
 
 		} else if (astNode instanceof CompletionOnMessageSend) {
 			setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
@@ -1034,7 +1159,10 @@ public final class CompletionEngine
 					scope,
 					false,
 					messageSend.receiver instanceof SuperReference,
-					false);
+					false,
+					null,
+					null,
+					null);
 			}
 		} else if (astNode instanceof CompletionOnExplicitConstructorCall) {
 			if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
@@ -1269,7 +1397,10 @@ public final class CompletionEngine
 								scope,
 								false,
 								false,
-								true);
+								false,
+								null,
+								null,
+								null);
 					}
 				}
 			}
@@ -1342,7 +1473,10 @@ public final class CompletionEngine
 							fieldRef,
 							scope,
 							false,
-							true);
+							true,
+							null,
+							null,
+							null);
 					}
 
 					if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)
@@ -1360,7 +1494,10 @@ public final class CompletionEngine
 							scope,
 							false,
 							false,
-							true);
+							true,
+							null,
+							null,
+							null);
 						if (fieldRef.receiverType instanceof ReferenceBinding) {
 							ReferenceBinding refBinding = (ReferenceBinding)fieldRef.receiverType;
 							if (this.completionToken == null
@@ -1394,7 +1531,8 @@ public final class CompletionEngine
 						findImplicitMessageSends(this.completionToken, argTypes, scope, messageSend, scope);
 					}
 				} else if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
-					findMethods(this.completionToken,
+					findMethods(
+						this.completionToken,
 						null,
 						argTypes,
 						(ReferenceBinding) ((ReferenceBinding) qualifiedBinding).capture(scope, messageSend.receiver.sourceEnd),
@@ -1407,7 +1545,10 @@ public final class CompletionEngine
 						scope,
 						false,
 						messageSend.receiver instanceof SuperReference,
-						true);
+						true,
+						null,
+						null,
+						null);
 				}
 			} else if (astNode instanceof CompletionOnJavadocAllocationExpression) {
 //				setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
@@ -2400,7 +2541,10 @@ public final class CompletionEngine
 		InvocationSite invocationSite,
 		Scope invocationScope,
 		boolean implicitCall,
-		boolean canBePrefixed) {
+		boolean canBePrefixed,
+		Binding[] missingElements,
+		int[] missingElementsStarts,
+		int[] missingElementsEnds) {
 
 		ObjectVector newFieldsFound = new ObjectVector();
 		// Inherited fields which are hidden by subclasses are filtered out
@@ -2523,6 +2667,18 @@ public final class CompletionEngine
 				proposal.setPackageName(field.type.qualifiedPackageName());
 				proposal.setTypeName(field.type.qualifiedSourceName()); 
 				proposal.setName(field.name);
+				if (missingElements != null) {
+					CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+					for (int i = 0; i < missingElements.length; i++) {
+						subProposals[i] =
+							createRequiredTypeProposal(
+									missingElements[i],
+									missingElementsStarts[i],
+									missingElementsEnds[i],
+									relevance);
+					}
+					proposal.setRequiredProposals(subProposals);
+				}
 				proposal.setCompletion(completion);
 				proposal.setFlags(field.modifiers);
 				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
@@ -2589,7 +2745,10 @@ public final class CompletionEngine
 		InvocationSite invocationSite,
 		Scope invocationScope,
 		boolean implicitCall,
-		boolean canBePrefixed) {
+		boolean canBePrefixed,
+		Binding[] missingElements,
+		int[] missingElementsStarts,
+		int[] missingElementsEnds) {
 
 		boolean notInJavadoc = this.assistNodeInJavadoc == 0;
 		if (fieldName == null && notInJavadoc)
@@ -2630,7 +2789,10 @@ public final class CompletionEngine
 					invocationSite,
 					invocationScope,
 					implicitCall,
-					canBePrefixed);
+					canBePrefixed,
+					missingElements,
+					missingElementsStarts,
+					missingElementsEnds);
 			}
 			currentType = currentType.superclass();
 		} while (notInJavadoc && currentType != null);
@@ -2651,7 +2813,10 @@ public final class CompletionEngine
 						invocationSite,
 						invocationScope,
 						implicitCall,
-						canBePrefixed);
+						canBePrefixed,
+						missingElements,
+						missingElementsStarts,
+						missingElementsEnds);
 				}
 
 				ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
@@ -2670,14 +2835,17 @@ public final class CompletionEngine
 		}
 	}
 
-	private void findFieldsAndMethods(
+	protected void findFieldsAndMethods(
 		char[] token,
 		TypeBinding receiverType,
 		Scope scope,
 		InvocationSite invocationSite,
 		Scope invocationScope,
 		boolean implicitCall,
-		boolean superCall) {
+		boolean superCall,
+		Binding[] missingElements,
+		int[] missingElementsStarts,
+		int[] missingElementsEnds) {
 
 		if (token == null)
 			return;
@@ -2712,6 +2880,18 @@ public final class CompletionEngine
 					//proposal.setPackageName(null);
 					proposal.setTypeName(INT);
 					proposal.setName(lengthField);
+					if (missingElements != null) {
+						CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+						for (int i = 0; i < missingElements.length; i++) {
+							subProposals[i] =
+								createRequiredTypeProposal(
+										missingElements[i],
+										missingElementsStarts[i],
+										missingElementsEnds[i],
+										relevance);
+						}
+						proposal.setRequiredProposals(subProposals);
+					}
 					proposal.setCompletion(lengthField);
 					proposal.setFlags(Flags.AccPublic);
 					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
@@ -2762,6 +2942,18 @@ public final class CompletionEngine
 					proposal.setPackageName(CharOperation.concatWith(JAVA_LANG, '.'));
 					proposal.setTypeName(OBJECT);
 					proposal.setName(cloneMethod);
+					if (missingElements != null) {
+						CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+						for (int i = 0; i < missingElements.length; i++) {
+							subProposals[i] =
+								createRequiredTypeProposal(
+										missingElements[i],
+										missingElementsStarts[i],
+										missingElementsEnds[i],
+										relevance);
+						}
+						proposal.setRequiredProposals(subProposals);
+					}
 					proposal.setCompletion(completion);
 					proposal.setFlags(Flags.AccPublic);
 					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
@@ -2788,7 +2980,10 @@ public final class CompletionEngine
 				invocationSite,
 				invocationScope,
 				implicitCall,
-				false);
+				false,
+				missingElements,
+				missingElementsStarts,
+				missingElementsEnds);
 		}
 
 		if(proposeMethod) {
@@ -2806,10 +3001,178 @@ public final class CompletionEngine
 				invocationScope,
 				implicitCall,
 				superCall,
-				false);
+				false,
+				missingElements,
+				missingElementsStarts,
+				missingElementsEnds);
+		}
+	}
+	
+	private void findFieldsAndMethodsFromMissingFieldType(
+		char[] token,
+		Scope scope,
+		InvocationSite invocationSite,
+		boolean insideTypeAnnotation) {
+
+		boolean staticsOnly = false;
+		Scope currentScope = scope;
+
+		done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
+
+			switch (currentScope.kind) {
+
+				case Scope.METHOD_SCOPE :
+					// handle the error case inside an explicit constructor call (see MethodScope>>findField)
+					MethodScope methodScope = (MethodScope) currentScope;
+					staticsOnly |= methodScope.isStatic | methodScope.isConstructorCall;
+
+				case Scope.BLOCK_SCOPE :
+					break;
+
+				case Scope.CLASS_SCOPE :
+					ClassScope classScope = (ClassScope) currentScope;
+					SourceTypeBinding enclosingType = classScope.referenceContext.binding;
+					if(!insideTypeAnnotation) {
+						
+						FieldDeclaration[] fields = classScope.referenceContext.fields;
+						
+						int fieldsCount = fields == null ? 0 : fields.length;
+						for (int i = 0; i < fieldsCount; i++) {
+							FieldDeclaration fieldDeclaration = fields[i];
+							if (CharOperation.equals(fieldDeclaration.name, token)) {
+								if (fieldDeclaration.binding == null) {
+									findFieldsAndMethodsFromMissingType(
+											this.completionToken,
+											fieldDeclaration.type, 
+											currentScope, 
+											invocationSite,
+											scope);
+								}
+								break done;
+							}
+						}
+					}
+					staticsOnly |= enclosingType.isStatic();
+					insideTypeAnnotation = false;
+					break;
+				case Scope.COMPILATION_UNIT_SCOPE :
+					break done;
+			}
+			currentScope = currentScope.parent;
+		}
+	}
+	
+	private void findFieldsAndMethodsFromMissingReturnType(
+		char[] token,
+		TypeBinding[] arguments,
+		Scope scope,
+		InvocationSite invocationSite,
+		boolean insideTypeAnnotation) {
+
+		boolean staticsOnly = false;
+		Scope currentScope = scope;
+
+		done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
+
+			switch (currentScope.kind) {
+
+				case Scope.METHOD_SCOPE :
+					// handle the error case inside an explicit constructor call (see MethodScope>>findField)
+					MethodScope methodScope = (MethodScope) currentScope;
+					staticsOnly |= methodScope.isStatic | methodScope.isConstructorCall;
+
+				case Scope.BLOCK_SCOPE :
+					break;
+
+				case Scope.CLASS_SCOPE :
+					ClassScope classScope = (ClassScope) currentScope;
+					SourceTypeBinding enclosingType = classScope.referenceContext.binding;
+					if(!insideTypeAnnotation) {
+						
+						AbstractMethodDeclaration[] methods = classScope.referenceContext.methods;
+						
+						int methodsCount = methods == null ? 0 : methods.length;
+						for (int i = 0; i < methodsCount; i++) {
+							AbstractMethodDeclaration methodDeclaration = methods[i];
+							if (methodDeclaration instanceof MethodDeclaration &&
+									CharOperation.equals(methodDeclaration.selector, token)) {
+								MethodDeclaration method = (MethodDeclaration) methodDeclaration;
+								if (methodDeclaration.binding == null) {
+									Argument[] parameters = method.arguments;
+									int parametersLength = parameters == null ? 0 : parameters.length;
+									int argumentsLength = arguments == null ? 0 : arguments.length;
+									
+									if (parametersLength == 0) {
+										if (argumentsLength == 0) {
+											findFieldsAndMethodsFromMissingType(
+													this.completionToken,
+													method.returnType, 
+													currentScope, 
+													invocationSite,
+													scope);
+											break done;
+										}
+									} else {
+										TypeBinding[] parametersBindings = new TypeBinding[parametersLength];
+										for (int j = 0; j < parametersLength; j++) {
+											parametersBindings[j] = parameters[j].type.resolvedType;
+										}
+										if(areParametersCompatibleWith(parametersBindings, arguments, parameters[parametersLength - 1].isVarArgs())) {
+											findFieldsAndMethodsFromMissingType(
+													this.completionToken,
+													method.returnType, 
+													currentScope,
+													invocationSite,
+													scope);
+											break done;
+										}
+									}
+								}
+								
+							}
+						}
+					}
+					staticsOnly |= enclosingType.isStatic();
+					insideTypeAnnotation = false;
+					break;
+				case Scope.COMPILATION_UNIT_SCOPE :
+					break done;
+			}
+			currentScope = currentScope.parent;
 		}
 	}
 
+	private void findFieldsAndMethodsFromMissingType(
+			final char[] token,
+			TypeReference typeRef,
+			final Scope scope, 
+			final InvocationSite invocationSite,
+			final Scope invocationScope) {
+		MissingTypesGuesser missingTypesConverter = new MissingTypesGuesser(this);
+		MissingTypesGuesser.GuessedTypeRequestor substitutionRequestor =
+			new MissingTypesGuesser.GuessedTypeRequestor() {
+				public void accept(
+						TypeBinding guessedType,
+						Binding[] missingElements,
+						int[] missingElementsStarts,
+						int[] missingElementsEnds) {
+					findFieldsAndMethods(
+						CompletionEngine.this.completionToken,
+						guessedType,
+						scope,
+						invocationSite, 
+						invocationScope, 
+						false,
+						false,
+						missingElements,
+						missingElementsStarts,
+						missingElementsEnds);
+					
+				}
+			};
+		missingTypesConverter.guess(typeRef, scope, substitutionRequestor);
+	}
+	
 	private void findImports(CompletionOnImportReference importReference, boolean findMembers) {
 		char[][] tokens = importReference.tokens;
 			
@@ -3633,7 +3996,10 @@ public final class CompletionEngine
 		Scope invocationScope,
 		boolean implicitCall,
 		boolean superCall,
-		boolean canBePrefixed) {
+		boolean canBePrefixed,
+		Binding[] missingElements,
+		int[] missingElementssStarts,
+		int[] missingElementsEnds) {
 
 		if (selector == null)
 			return;
@@ -3669,7 +4035,10 @@ public final class CompletionEngine
 							invocationScope,
 							implicitCall,
 							superCall,
-							canBePrefixed);
+							canBePrefixed,
+							missingElements,
+							missingElementssStarts,
+							missingElementsEnds);
 					}
 				}
 
@@ -3729,7 +4098,10 @@ public final class CompletionEngine
 						invocationScope,
 						true,
 						false,
-						true);
+						true,
+						null,
+						null,
+						null);
 					staticsOnly |= enclosingType.isStatic();
 					break;
 
@@ -3755,7 +4127,10 @@ public final class CompletionEngine
 		Scope invocationScope,
 		boolean implicitCall,
 		boolean superCall,
-		boolean canBePrefixed) {
+		boolean canBePrefixed,
+		Binding[] missingElements,
+		int[] missingElementsStarts,
+		int[] missingElementsEnds) {
 
 		ObjectVector newMethodsFound =  new ObjectVector();
 		// Inherited methods which are hidden by subclasses are filtered out
@@ -3979,6 +4354,18 @@ public final class CompletionEngine
 				proposal.setPackageName(method.returnType.qualifiedPackageName());
 				proposal.setTypeName(method.returnType.qualifiedSourceName());
 				proposal.setName(method.selector);
+				if (missingElements != null) {
+					CompletionProposal[] subProposals = new CompletionProposal[missingElements.length];
+					for (int i = 0; i < missingElements.length; i++) {
+						subProposals[i] =
+							createRequiredTypeProposal(
+									missingElements[i],
+									missingElementsStarts[i],
+									missingElementsEnds[i],
+									relevance);
+					}
+					proposal.setRequiredProposals(subProposals);
+				}
 				proposal.setCompletion(completion);
 				proposal.setFlags(method.modifiers);
 				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
@@ -4024,6 +4411,41 @@ public final class CompletionEngine
 		methodsFound.addAll(newMethodsFound);
 	}
 	
+	private CompletionProposal createRequiredTypeProposal(Binding binding, int start, int end, int relevance) {
+		CompletionProposal proposal = null;
+		if (binding instanceof ReferenceBinding) {
+			ReferenceBinding typeBinding = (ReferenceBinding) binding;
+			
+			char[] packageName = typeBinding.qualifiedPackageName();
+			char[] typeName = typeBinding.qualifiedSourceName();
+			char[] fullyQualifiedName = CharOperation.concat(packageName, typeName, '.');
+			
+			proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
+			proposal.nameLookup = this.nameEnvironment.nameLookup;
+			proposal.completionEngine = this;
+			proposal.setDeclarationSignature(packageName);
+			proposal.setSignature(getSignature(typeBinding));
+			proposal.setPackageName(packageName);
+			proposal.setTypeName(typeName);
+			proposal.setCompletion(fullyQualifiedName);
+			proposal.setFlags(typeBinding.modifiers);
+			proposal.setReplaceRange(start - this.offset, end - this.offset);
+			proposal.setRelevance(relevance);
+		} else if (binding instanceof PackageBinding) {
+			PackageBinding packageBinding = (PackageBinding) binding;
+			
+			char[] packageName = CharOperation.concatWith(packageBinding.compoundName, '.');
+			
+			proposal = this.createProposal(CompletionProposal.PACKAGE_REF, this.actualCompletionPosition);
+			proposal.setDeclarationSignature(packageName);
+			proposal.setPackageName(packageName);
+			proposal.setCompletion(packageName);
+			proposal.setReplaceRange(start - this.offset, end - this.offset);
+			proposal.setRelevance(relevance);
+		}
+		return proposal;
+	}
+
 	// Helper method for findMethods(char[], TypeBinding[], ReferenceBinding, Scope, ObjectVector, boolean, boolean, boolean)
 	private void findLocalMethodsOfStaticImports(
 		char[] methodName,
@@ -4610,7 +5032,10 @@ public final class CompletionEngine
 		Scope invocationScope,
 		boolean implicitCall,
 		boolean superCall,
-		boolean canBePrefixed) {
+		boolean canBePrefixed,
+		Binding[] missingElements,
+		int[] missingElementsStarts,
+		int[] missingElementsEnds) {
 
 		boolean notInJavadoc = this.assistNodeInJavadoc == 0;
 		if (selector == null && notInJavadoc) {
@@ -4647,7 +5072,10 @@ public final class CompletionEngine
 						invocationScope,
 						implicitCall,
 						superCall,
-						canBePrefixed);
+						canBePrefixed,
+						missingElements,
+						missingElementsStarts,
+						missingElementsEnds);
 				} else {
 					findInterfacesMethods(
 						selector,
@@ -4664,7 +5092,10 @@ public final class CompletionEngine
 						invocationScope,
 						implicitCall,
 						superCall,
-						canBePrefixed);
+						canBePrefixed,
+						missingElements,
+						missingElementsStarts,
+						missingElementsEnds);
 				}
 				
 				currentType = scope.getJavaLangObject();
@@ -4685,7 +5116,10 @@ public final class CompletionEngine
 						invocationScope,
 						implicitCall,
 						superCall,
-						canBePrefixed);
+						canBePrefixed,
+						missingElements,
+						missingElementsStarts,
+						missingElementsEnds);
 					
 					currentType = receiverType.superclass();
 				}
@@ -4719,7 +5153,10 @@ public final class CompletionEngine
 						invocationScope,
 						implicitCall,
 						superCall,
-						canBePrefixed);
+						canBePrefixed,
+						missingElements,
+						missingElementsStarts,
+						missingElementsEnds);
 				}
 			}
 			
@@ -4739,7 +5176,10 @@ public final class CompletionEngine
 					invocationScope,
 					implicitCall,
 					superCall,
-					canBePrefixed);
+					canBePrefixed,
+					missingElements,
+					missingElementsStarts,
+					missingElementsEnds);
 			} else {
 				hasPotentialDefaultAbstractMethods = false;
 			}
@@ -5593,7 +6033,10 @@ public final class CompletionEngine
 									invocationSite,
 									invocationScope,
 									true,
-									true);
+									true,
+									null,
+									null,
+									null);
 							}
 							if(proposeMethod && !insideAnnotationAttribute) {
 								findMethods(
@@ -5610,7 +6053,10 @@ public final class CompletionEngine
 									invocationScope,
 									true,
 									false,
-									true);
+									true,
+									null,
+									null,
+									null);
 							}
 						}
 						staticsOnly |= enclosingType.isStatic();
@@ -5643,7 +6089,10 @@ public final class CompletionEngine
 										invocationSite,
 										invocationScope,
 										true,
-										false);
+										false,
+										null,
+										null,
+										null);
 								}
 								if(proposeMethod && !insideAnnotationAttribute) {
 									findMethods(
@@ -5660,7 +6109,10 @@ public final class CompletionEngine
 										invocationScope,
 										true,
 										false,
-										false);
+										false,
+										null,
+										null,
+										null);
 								}
 							}
 						} else {
@@ -5677,7 +6129,10 @@ public final class CompletionEngine
 												invocationSite,
 												invocationScope,
 												true,
-												false);
+												false,
+												null,
+												null,
+												null);
 								}
 							} else if ((binding.kind() & Binding.METHOD) != 0) {
 								if(proposeMethod && !insideAnnotationAttribute) {
@@ -6628,8 +7083,19 @@ public final class CompletionEngine
 		}
 	}
 	
+	private void printDebugTab(int tab, StringBuffer buffer) {
+		for (int i = 0; i < tab; i++) {
+			buffer.append('\t');
+		}
+	}
+	
 	protected void printDebug(CompletionProposal proposal){
 		StringBuffer buffer = new StringBuffer();
+		printDebug(proposal, 0, buffer);
+		System.out.println(buffer.toString());
+	}
+	private void printDebug(CompletionProposal proposal, int tab, StringBuffer buffer){
+		printDebugTab(tab, buffer);
 		buffer.append("COMPLETION - "); //$NON-NLS-1$
 		switch(proposal.getKind()) {
 			case CompletionProposal.ANONYMOUS_CLASS_DECLARATION :
@@ -6678,17 +7144,20 @@ public final class CompletionEngine
 		}
 		
 		buffer.append("{\n");//$NON-NLS-1$
+		printDebugTab(tab, buffer);
 		buffer.append("\tCompletion[").append(proposal.getCompletion() == null ? "null".toCharArray() : proposal.getCompletion()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+		printDebugTab(tab, buffer);
 		buffer.append("\tDeclarationSignature[").append(proposal.getDeclarationSignature() == null ? "null".toCharArray() : proposal.getDeclarationSignature()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+		printDebugTab(tab, buffer);
 		buffer.append("\tDeclarationKey[").append(proposal.getDeclarationKey() == null ? "null".toCharArray() : proposal.getDeclarationKey()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+		printDebugTab(tab, buffer);
 		buffer.append("\tSignature[").append(proposal.getSignature() == null ? "null".toCharArray() : proposal.getSignature()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+		printDebugTab(tab, buffer);
 		buffer.append("\tKey[").append(proposal.getKey() == null ? "null".toCharArray() : proposal.getKey()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-//		buffer.append("\tDeclarationPackage[").append(proposal.getDeclarationPackageName() == null ? "null".toCharArray() : proposal.getDeclarationPackageName()).append("]\n");
-//		buffer.append("\tDeclarationType[").append(proposal.getDeclarationTypeName() == null ? "null".toCharArray() : proposal.getDeclarationTypeName()).append("]\n");
-//		buffer.append("\tPackage[").append(proposal.getPackageName() == null ? "null".toCharArray() : proposal.getPackageName()).append("]\n");
-//		buffer.append("\tType[").append(proposal.getTypeName() == null ? "null".toCharArray() : proposal.getTypeName()).append("]\n");
+		printDebugTab(tab, buffer);
 		buffer.append("\tName[").append(proposal.getName() == null ? "null".toCharArray() : proposal.getName()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
 		
+		printDebugTab(tab, buffer);
 		buffer.append("\tFlags[");//$NON-NLS-1$
 		int flags = proposal.getFlags();
 		buffer.append(Flags.toString(flags));
@@ -6696,19 +7165,37 @@ public final class CompletionEngine
 		if((flags & Flags.AccEnum) != 0) buffer.append("enum ");//$NON-NLS-1$
 		buffer.append("]\n"); //$NON-NLS-1$
 		
+		CompletionProposal[] proposals = proposal.getRequiredProposals();
+		if(proposals != null) {
+			printDebugTab(tab, buffer);
+			buffer.append("\tRequiredProposals[");//$NON-NLS-1$
+			for (int i = 0; i < proposals.length; i++) {
+				buffer.append("\n"); //$NON-NLS-1$
+				printDebug(proposals[i], tab + 2, buffer);
+			}
+			printDebugTab(tab, buffer);
+			buffer.append("\n\t]\n"); //$NON-NLS-1$
+		}
+		
+		printDebugTab(tab, buffer);
 		buffer.append("\tCompletionLocation[").append(proposal.getCompletionLocation()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
 		int start = proposal.getReplaceStart();
 		int end = proposal.getReplaceEnd();
+		printDebugTab(tab, buffer);
 		buffer.append("\tReplaceStart[").append(start).append("]"); //$NON-NLS-1$ //$NON-NLS-2$
 		buffer.append("-ReplaceEnd[").append(end).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
-		if (this.source != null)
+		if (this.source != null) {
+			printDebugTab(tab, buffer);
 			buffer.append("\tReplacedText[").append(this.source, start, end-start).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
+		}
+		printDebugTab(tab, buffer);
 		buffer.append("\tTokenStart[").append(proposal.getTokenStart()).append("]"); //$NON-NLS-1$ //$NON-NLS-2$
 		buffer.append("-TokenEnd[").append(proposal.getTokenEnd()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
+		printDebugTab(tab, buffer);
 		buffer.append("\tRelevance[").append(proposal.getRelevance()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
 
+		printDebugTab(tab, buffer);
 		buffer.append("}\n");//$NON-NLS-1$
-		System.out.println(buffer.toString());
 	}
 	
 	private char[][] substituteMethodTypeParameterNames(TypeVariableBinding[] typeVariables, char[][] excludedNames) {
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/MissingTypesGuesser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/MissingTypesGuesser.java
new file mode 100644
index 0000000..669eee0
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/MissingTypesGuesser.java
@@ -0,0 +1,595 @@
+/*******************************************************************************
+ * Copyright (c) 2006 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Set;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.search.IJavaSearchConstants;
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
+import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt;
+import org.eclipse.jdt.internal.core.SearchableEnvironment;
+
+public class MissingTypesGuesser extends ASTVisitor {
+	public static interface GuessedTypeRequestor {
+		public void accept(
+				TypeBinding guessedType,
+				Binding[] missingElements,
+				int[] missingElementsStarts,
+				int[] missingElementsEnds);
+		
+	}
+	
+	private static class ResolutionCleaner extends ASTVisitor {
+		private HashtableOfObjectToInt bitsMap = new HashtableOfObjectToInt();
+		private boolean firstCall = true;
+		
+		public ResolutionCleaner(){
+			super();
+		}
+		
+		private void cleanUp(TypeReference typeReference) {
+			if (this.firstCall) {
+				this.bitsMap.put(typeReference, typeReference.bits);
+			} else {
+				typeReference.bits = this.bitsMap.get(typeReference);
+			}
+			typeReference.resolvedType = null;
+		}
+		
+		private void cleanUp(ParameterizedSingleTypeReference typeReference) {
+			this.cleanUp((TypeReference)typeReference);
+			typeReference.didResolve = false;
+		}
+		
+		private void cleanUp(ParameterizedQualifiedTypeReference typeReference) {
+			this.cleanUp((TypeReference)typeReference);
+			typeReference.didResolve = false;
+		}
+		
+		public void cleanUp(TypeReference convertedType, BlockScope scope) {
+			convertedType.traverse(this, scope);
+			this.firstCall = false;
+		}
+
+		public void cleanUp(TypeReference convertedType, ClassScope scope) {
+			convertedType.traverse(this, scope);
+			this.firstCall = false;
+		}
+		
+		public boolean visit(SingleTypeReference singleTypeReference, BlockScope scope) {
+			this.cleanUp(singleTypeReference);
+			return true;
+		}
+		
+		public boolean visit(SingleTypeReference singleTypeReference, ClassScope scope) {
+			this.cleanUp(singleTypeReference);
+			return true;
+		}
+		
+		public boolean visit(Wildcard wildcard, BlockScope scope) {
+			this.cleanUp(wildcard);
+			return true;
+		}
+		
+		public boolean visit(Wildcard wildcard, ClassScope scope) {
+			this.cleanUp(wildcard);
+			return true;
+		}
+		
+		public boolean visit(ArrayTypeReference arrayTypeReference, BlockScope scope) {
+			this.cleanUp(arrayTypeReference);
+			return true;
+		}
+		
+		public boolean visit(ArrayTypeReference arrayTypeReference, ClassScope scope) {
+			this.cleanUp(arrayTypeReference);
+			return true;
+		}
+		
+		public boolean visit(ParameterizedSingleTypeReference parameterizedSingleTypeReference, BlockScope scope) {
+			this.cleanUp(parameterizedSingleTypeReference);
+			return true;
+		}
+		
+		public boolean visit(ParameterizedSingleTypeReference parameterizedSingleTypeReference, ClassScope scope) {
+			this.cleanUp(parameterizedSingleTypeReference);
+			return true;
+		}
+		
+		public boolean visit(QualifiedTypeReference qualifiedTypeReference, BlockScope scope) {
+			this.cleanUp(qualifiedTypeReference);
+			return true;
+		}
+		
+		public boolean visit(QualifiedTypeReference qualifiedTypeReference, ClassScope scope) {
+			this.cleanUp(qualifiedTypeReference);
+			return true;
+		}
+		
+		public boolean visit(ArrayQualifiedTypeReference arrayQualifiedTypeReference, BlockScope scope) {
+			this.cleanUp(arrayQualifiedTypeReference);
+			return true;
+		}
+		
+		public boolean visit(ArrayQualifiedTypeReference arrayQualifiedTypeReference, ClassScope scope) {
+			this.cleanUp(arrayQualifiedTypeReference);
+			return true;
+		}
+		
+		public boolean visit(ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference, BlockScope scope) {
+			this.cleanUp(parameterizedQualifiedTypeReference);
+			return true;
+		}
+		
+		public boolean visit(ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference, ClassScope scope) {
+			this.cleanUp(parameterizedQualifiedTypeReference);
+			return true;
+		}
+
+	}
+	
+	private CompletionEngine.CompletionProblemFactory problemFactory ;
+	private  SearchableEnvironment nameEnvironment;
+	
+	private HashMap substituedTypes;
+	private HashMap originalTypes;
+	private int combinationsCount;
+			
+	public MissingTypesGuesser(CompletionEngine completionEngine) {
+		this.problemFactory = completionEngine.problemFactory;
+		this.nameEnvironment = completionEngine.nameEnvironment;
+	}
+	
+	private boolean computeMissingElements(
+			QualifiedTypeReference[] substituedTypeNodes,
+			char[][][] originalTypeNames,
+			Binding[] missingElements,
+			int[] missingElementsStarts,
+			int[] missingElementsEnds) {
+		int length = substituedTypeNodes.length;
+		
+		for (int i = 0; i < length; i++) {
+			TypeReference substituedType = substituedTypeNodes[i];
+			if (substituedType.resolvedType == null) return false;
+			ReferenceBinding erasure = (ReferenceBinding)substituedType.resolvedType.leafComponentType().erasure();
+			Binding missingElement;
+			int depthToRemove = originalTypeNames[i].length - 1 ;
+			if (depthToRemove == 0) {
+				missingElement = erasure;
+			} else {
+				int depth = erasure.depth() + 1;
+				
+				if (depth > depthToRemove) {
+					missingElement = erasure.enclosingTypeAt(depthToRemove);
+				} else {
+					return false;
+					///////////////////////////////////////////////////////////
+					//// Uncomment the following code to return missing package
+					///////////////////////////////////////////////////////////
+					//depthToRemove -= depth;
+					//PackageBinding packageBinding = erasure.getPackage();
+					//while(depthToRemove > 0) {
+					//	packageBinding = packageBinding.parent;
+					//	depthToRemove--;
+					//}
+					//missingElement = packageBinding;
+				}
+			}
+			
+			missingElements[i] = missingElement;
+			missingElementsStarts[i] = substituedType.sourceStart;
+			missingElementsEnds[i] = substituedType.sourceEnd + 1;
+			
+		}
+		
+		return true;
+	}
+
+	private TypeReference convert(ArrayQualifiedTypeReference typeRef) {
+		if (typeRef.resolvedType != null) {
+			if (typeRef.resolvedType.isValidBinding()) {
+				ArrayQualifiedTypeReference convertedType =
+					new ArrayQualifiedTypeReference(
+							typeRef.tokens,
+							typeRef.dimensions(),
+							typeRef.sourcePositions);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = typeRef.sourceEnd;
+				return convertedType;
+			} else if((typeRef.resolvedType.problemId() & ProblemReasons.NotFound) != 0) {
+				// only the first token must be resolved
+				if(((ReferenceBinding)typeRef.resolvedType.leafComponentType()).compoundName.length != 1) return null;
+				
+				char[][] typeName = typeRef.getTypeName();
+				char[][][] typeNames = findTypeNames(typeName);
+				if(typeNames == null || typeNames.length == 0) return null;
+				ArrayQualifiedTypeReference convertedType =
+					new ArrayQualifiedTypeReference(
+							typeNames[0],
+							typeRef.dimensions(),
+							new long[typeNames[0].length]);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = (int)(typeRef.sourcePositions[0] & 0x00000000FFFFFFFFL);
+				this.substituedTypes.put(convertedType, typeNames);
+				this.originalTypes.put(convertedType, typeName);
+				this.combinationsCount *= typeNames.length;
+				return convertedType;
+			}
+		}
+		return null;
+	}
+
+	private TypeReference convert(ArrayTypeReference typeRef) {
+		if (typeRef.resolvedType != null) {
+			if (typeRef.resolvedType.isValidBinding()) {
+				ArrayTypeReference convertedType =
+					new ArrayTypeReference(
+							typeRef.token,
+							typeRef.dimensions,
+							0);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = typeRef.originalSourceEnd;
+				return convertedType;
+			} else if((typeRef.resolvedType.problemId() & ProblemReasons.NotFound) != 0) {
+				char[][] typeName = typeRef.getTypeName();
+				char[][][] typeNames = findTypeNames(typeName);
+				if(typeNames == null || typeNames.length == 0) return null;
+				ArrayQualifiedTypeReference convertedType =
+					new ArrayQualifiedTypeReference(
+							typeNames[0],
+							typeRef.dimensions,
+							new long[typeNames[0].length]);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = typeRef.originalSourceEnd;
+				this.substituedTypes.put(convertedType, typeNames);
+				this.originalTypes.put(convertedType, typeName);
+				this.combinationsCount *= typeNames.length;
+				return convertedType;
+			}
+		}
+		return null;
+	}
+	
+	private TypeReference convert(ParameterizedQualifiedTypeReference typeRef) {
+		if (typeRef.resolvedType != null) {
+			TypeReference[][] typeArguments = typeRef.typeArguments;
+			int length = typeArguments.length;
+			TypeReference[][] convertedTypeArguments = new TypeReference[length][];
+			next : for (int i = 0; i < length; i++) {
+				if (typeArguments[i] == null) continue next;
+				int length2 = typeArguments[i].length;
+				convertedTypeArguments[i] = new TypeReference[length2];
+				for (int j = 0; j < length2; j++) {
+					convertedTypeArguments[i][j] = convert(typeArguments[i][j]);
+					if (convertedTypeArguments[i][j] == null) return null;
+				}
+			}
+			
+			if (typeRef.resolvedType.isValidBinding()) {
+				ParameterizedQualifiedTypeReference convertedType =
+					new ParameterizedQualifiedTypeReference(
+							typeRef.tokens,
+							convertedTypeArguments,
+							typeRef.dimensions(),
+							new long[typeRef.tokens.length]);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = typeRef.sourceEnd;
+				return convertedType;
+			} else if((typeRef.resolvedType.problemId() & ProblemReasons.NotFound) != 0) {
+				// only the first token must be resolved
+				if(((ReferenceBinding)typeRef.resolvedType.leafComponentType()).compoundName.length != 1) return null;
+				
+				char[][] typeName = typeRef.getTypeName();
+				char[][][] typeNames = findTypeNames(typeName);
+				if(typeNames == null || typeNames.length == 0) return null;
+				
+				TypeReference[][] newConvertedTypeArguments = new TypeReference[typeNames[0].length][];
+				for (int k = newConvertedTypeArguments.length - 1, l = convertedTypeArguments.length -1; k > -1 && l > -1;) {
+					newConvertedTypeArguments[k] = convertedTypeArguments[l];
+					k--;
+					l--;
+				}
+				
+				ParameterizedQualifiedTypeReference convertedType =
+					new ParameterizedQualifiedTypeReference(
+							typeNames[0],
+							newConvertedTypeArguments,
+							typeRef.dimensions(),
+							new long[typeNames[0].length]);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = (int)(typeRef.sourcePositions[0] & 0x00000000FFFFFFFFL);
+				this.substituedTypes.put(convertedType, typeNames);
+				this.originalTypes.put(convertedType, typeName);
+				this.combinationsCount *= typeNames.length;
+				return convertedType;
+			}
+		}
+		return null;
+	}
+	
+	private TypeReference convert(ParameterizedSingleTypeReference typeRef) {
+		if (typeRef.resolvedType != null) {
+			TypeReference[] typeArguments = typeRef.typeArguments;
+			int length = typeArguments.length;
+			TypeReference[] convertedTypeArguments = new TypeReference[length];
+			for (int i = 0; i < length; i++) {
+				convertedTypeArguments[i] = convert(typeArguments[i]);
+				if(convertedTypeArguments[i] == null) return null;
+			}
+			
+			if (typeRef.resolvedType.isValidBinding()) {
+				ParameterizedSingleTypeReference convertedType =
+					new ParameterizedSingleTypeReference(
+							typeRef.token,
+							convertedTypeArguments,
+							typeRef.dimensions,
+							0);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = typeRef.sourceEnd;
+				return convertedType;
+			} else if((typeRef.resolvedType.problemId() & ProblemReasons.NotFound) != 0) {
+				char[][] typeName = typeRef.getTypeName();
+				char[][][] typeNames = findTypeNames(typeName);
+				if(typeNames == null || typeNames.length == 0) return null;
+				
+				TypeReference[][] allConvertedTypeArguments = new TypeReference[typeNames[0].length][];
+				allConvertedTypeArguments[allConvertedTypeArguments.length - 1] = convertedTypeArguments;
+				
+				ParameterizedQualifiedTypeReference convertedType =
+					new ParameterizedQualifiedTypeReference(
+							typeNames[0],
+							allConvertedTypeArguments,
+							typeRef.dimensions,
+							new long[typeNames[0].length]);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = typeRef.sourceEnd;
+				this.substituedTypes.put(convertedType, typeNames);
+				this.originalTypes.put(convertedType, typeName);
+				this.combinationsCount *= typeNames.length;
+				return convertedType;
+			}
+		}
+		return null;
+	}
+	
+	private TypeReference convert(QualifiedTypeReference typeRef) {
+		if (typeRef.resolvedType != null) {
+			if (typeRef.resolvedType.isValidBinding()) {
+				QualifiedTypeReference convertedType = new QualifiedTypeReference(typeRef.tokens, typeRef.sourcePositions);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = typeRef.sourceEnd;
+				return convertedType;
+			} else if((typeRef.resolvedType.problemId() & ProblemReasons.NotFound) != 0) {
+				// only the first token must be resolved
+				if(((ReferenceBinding)typeRef.resolvedType).compoundName.length != 1) return null;
+				
+				char[][] typeName = typeRef.getTypeName();
+				char[][][] typeNames = findTypeNames(typeName);
+				if(typeNames == null || typeNames.length == 0) return null;
+				QualifiedTypeReference convertedType = new QualifiedTypeReference(typeNames[0], new long[typeNames[0].length]);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = (int)(typeRef.sourcePositions[0] & 0x00000000FFFFFFFFL);
+				this.substituedTypes.put(convertedType, typeNames);
+				this.originalTypes.put(convertedType, typeName);
+				this.combinationsCount *= typeNames.length;
+				return convertedType;
+			}
+		}
+		return null;
+	}
+	
+	private TypeReference convert(SingleTypeReference typeRef) {
+		if (typeRef.resolvedType != null) {
+			if (typeRef.resolvedType.isValidBinding()) {
+				SingleTypeReference convertedType = new SingleTypeReference(typeRef.token, 0);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = typeRef.sourceEnd;
+				return convertedType;
+			} else if((typeRef.resolvedType.problemId() & ProblemReasons.NotFound) != 0) {
+				char[][] typeName = typeRef.getTypeName();
+				char[][][] typeNames = findTypeNames(typeName);
+				if(typeNames == null || typeNames.length == 0) return null;
+				QualifiedTypeReference convertedType = new QualifiedTypeReference(typeNames[0], new long[typeNames[0].length]);
+				convertedType.sourceStart = typeRef.sourceStart;
+				convertedType.sourceEnd = typeRef.sourceEnd;
+				this.substituedTypes.put(convertedType, typeNames);
+				this.originalTypes.put(convertedType, typeName);
+				this.combinationsCount *= typeNames.length;
+				return convertedType;
+			}
+		}
+		return null;
+	}
+	
+	private TypeReference convert(TypeReference typeRef) {
+		if (typeRef instanceof ParameterizedSingleTypeReference) {
+			return convert((ParameterizedSingleTypeReference)typeRef);
+		} else if(typeRef instanceof ParameterizedQualifiedTypeReference) {
+			return convert((ParameterizedQualifiedTypeReference)typeRef);
+		} else if (typeRef instanceof ArrayTypeReference) {
+			return convert((ArrayTypeReference)typeRef);
+		} else if(typeRef instanceof ArrayQualifiedTypeReference) {
+			return convert((ArrayQualifiedTypeReference)typeRef);
+		} else if(typeRef instanceof Wildcard) {
+			return convert((Wildcard)typeRef);
+		} else if (typeRef instanceof SingleTypeReference) {
+			return convert((SingleTypeReference)typeRef);
+		} else if (typeRef instanceof QualifiedTypeReference) {
+			return convert((QualifiedTypeReference)typeRef);
+		}
+		return null;
+	}
+	
+	private TypeReference convert(Wildcard typeRef) {
+		TypeReference bound = typeRef.bound;
+		TypeReference convertedBound = null;
+		if (bound != null) {
+			convertedBound = convert(bound);
+			if (convertedBound == null) return null;
+		}
+		Wildcard convertedType = new Wildcard(typeRef.kind);
+		convertedType.bound = convertedBound;
+		convertedType.sourceStart = typeRef.sourceStart;
+		convertedType.sourceEnd = typeRef.sourceEnd;
+		return convertedType;
+	}
+	
+	private char[][][] findTypeNames(char[][] missingTypeName) {
+		char[] missingSimpleName = missingTypeName[missingTypeName.length - 1];
+		final boolean isQualified = missingTypeName.length > 1;
+		final char[] missingFullyQualifiedName = 
+			isQualified ? CharOperation.concatWith(missingTypeName, '.') : null;
+		final ArrayList results = new ArrayList();
+		ISearchRequestor storage = new ISearchRequestor() {
+			
+			public void acceptPackage(char[] packageName) {
+				// package aren't searched
+			}
+			public void acceptType(
+					char[] packageName,
+					char[] typeName,
+					char[][] enclosingTypeNames,
+					int modifiers,
+					AccessRestriction accessRestriction) {
+				char[] fullyQualifiedName = CharOperation.concat(packageName, CharOperation.concat(CharOperation.concatWith(enclosingTypeNames, '.'), typeName, '.'), '.');
+				if (isQualified && !CharOperation.endsWith(fullyQualifiedName, missingFullyQualifiedName)) return;
+				char[][] compoundName = CharOperation.splitOn('.', fullyQualifiedName);
+				results.add(compoundName);
+			}
+		
+		};
+		nameEnvironment.findExactTypes(missingSimpleName, true, IJavaSearchConstants.TYPE, storage);
+		if(results.size() == 0) return null;
+		return (char[][][])results.toArray(new char[results.size()][0][0]);
+	}
+	
+	private char[][] getOriginal(TypeReference typeRef) {
+		return (char[][])this.originalTypes.get(typeRef);
+	}
+	
+	private QualifiedTypeReference[] getSubstituedTypes() {
+		Set types = this.substituedTypes.keySet();
+		return (QualifiedTypeReference[]) types.toArray(new QualifiedTypeReference[types.size()]);
+	}
+	
+	private char[][][] getSubstitution(TypeReference typeRef) {
+		return (char[][][])this.substituedTypes.get(typeRef);
+	}
+	
+	public void guess(TypeReference typeRef, Scope scope, GuessedTypeRequestor requestor) {
+		this.substituedTypes = new HashMap();
+		this.originalTypes = new HashMap();
+		this.combinationsCount = 1;
+		
+		TypeReference convertedType = convert(typeRef);
+		
+		if(convertedType == null) return;
+		
+		QualifiedTypeReference[] substituedTypeNodes = this.getSubstituedTypes();
+		int length = substituedTypeNodes.length;
+		
+		int[] substitutionsIndexes = new int[substituedTypeNodes.length];
+		char[][][][] subtitutions = new char[substituedTypeNodes.length][][][];
+		char[][][] originalTypeNames = new char[substituedTypeNodes.length][][];
+		for (int i = 0; i < substituedTypeNodes.length; i++) {
+			subtitutions[i] = this.getSubstitution(substituedTypeNodes[i]);
+			originalTypeNames[i] = this.getOriginal(substituedTypeNodes[i]);
+		}
+		
+		ResolutionCleaner resolutionCleaner = new ResolutionCleaner();
+		for (int i = 0; i < this.combinationsCount; i++) {
+			
+			nextSubstitution(substituedTypeNodes, subtitutions, substitutionsIndexes);
+			
+			this.problemFactory.hasProblems = false;
+			this.problemFactory.checkProblems = true;
+			TypeBinding guessedType = null;
+			switch (scope.kind) {
+				case Scope.METHOD_SCOPE :
+				case Scope.BLOCK_SCOPE :
+					resolutionCleaner.cleanUp(convertedType, (BlockScope)scope);
+					convertedType.traverse(resolutionCleaner, (BlockScope)scope);
+					guessedType = convertedType.resolveType((BlockScope)scope);
+					break;
+				case Scope.CLASS_SCOPE :
+					resolutionCleaner.cleanUp(convertedType, (ClassScope)scope);
+					convertedType.traverse(resolutionCleaner, (ClassScope)scope);
+					guessedType = convertedType.resolveType((ClassScope)scope);
+					break;
+			}
+			this.problemFactory.checkProblems = false;
+			if (!this.problemFactory.hasProblems) {
+				if (guessedType != null) {
+					Binding[] missingElements = new Binding[length];
+					int[] missingElementsStarts = new int[length];
+					int[] missingElementsEnds = new int[length];
+					
+					if(computeMissingElements(
+							substituedTypeNodes,
+							originalTypeNames,
+							missingElements,
+							missingElementsStarts,
+							missingElementsEnds)) {
+						requestor.accept(
+								guessedType.capture(scope, typeRef.sourceEnd),
+								missingElements,
+								missingElementsStarts,
+								missingElementsEnds);
+					}
+				}
+			}
+		}
+	}
+	private void nextSubstitution(
+			QualifiedTypeReference[] substituedTypeNodes,
+			char[][][][] subtitutions,
+			int[] substitutionsIndexes) {
+		int length = substituedTypeNodes.length;
+		
+		done : for (int i = 0; i < length; i++) {
+			if(substitutionsIndexes[i] < subtitutions[i].length - 1) {
+				substitutionsIndexes[i]++;
+				break done;
+			} else {
+				substitutionsIndexes[i] = 0;
+			}
+		}
+		
+		for (int i = 0; i < length; i++) {
+			QualifiedTypeReference qualifiedTypeReference = substituedTypeNodes[i];
+			qualifiedTypeReference.tokens = subtitutions[i][substitutionsIndexes[i]];
+			qualifiedTypeReference.sourcePositions = new long[qualifiedTypeReference.tokens.length];
+			if(qualifiedTypeReference instanceof ParameterizedQualifiedTypeReference) {
+				ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference =
+					(ParameterizedQualifiedTypeReference)qualifiedTypeReference;
+				TypeReference[][] typeArguments = parameterizedQualifiedTypeReference.typeArguments;
+				TypeReference[][] newTypeArguments = new TypeReference[qualifiedTypeReference.tokens.length][];
+				for (int j = newTypeArguments.length - 1, k = typeArguments.length -1; j > -1 && k > -1;) {
+					newTypeArguments[j] = typeArguments[k];
+					j--;
+					k--;
+				}
+			}
+		}
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnMemberAccess.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnMemberAccess.java
index 37e0da8..32707f9 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnMemberAccess.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnMemberAccess.java
@@ -51,6 +51,25 @@ public class CompletionOnMemberAccess extends FieldReference {
 	public TypeBinding resolveType(BlockScope scope) {
 		
 		this.receiverType = receiver.resolveType(scope);
+		
+		if (this.receiverType == null && receiver instanceof MessageSend) {
+			MessageSend messageSend = (MessageSend) receiver;
+			if(messageSend.receiver instanceof ThisReference) {
+				Expression[] arguments = messageSend.arguments;
+				int length = arguments == null ? 0 : arguments.length;
+				TypeBinding[] argBindings = new TypeBinding[length];
+				for (int i = 0; i < length; i++) {
+					argBindings[i] = arguments[i].resolvedType;
+					if(argBindings[i] == null || !argBindings[i].isValidBinding()) {
+						throw new CompletionNodeFound();
+					}
+				}
+					
+				ProblemMethodBinding problemMethodBinding = new ProblemMethodBinding(messageSend.selector, argBindings, ProblemReasons.NotFound);
+				throw new CompletionNodeFound(this, problemMethodBinding, scope);
+			}
+		}
+		
 		if (this.receiverType == null || this.receiverType.isBaseType())
 			throw new CompletionNodeFound();
 		else
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedNameReference.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedNameReference.java
index 196b9da..f1c52d3 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedNameReference.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedNameReference.java
@@ -65,9 +65,14 @@ public TypeBinding resolveType(BlockScope scope) {
 		} else {
 			scope.problemReporter().unresolvableReference(this, binding);
 		}
+		
+		if (binding.problemId() == ProblemReasons.NotFound) {
+			throw new CompletionNodeFound(this, binding, scope);
+		}
+		
 		throw new CompletionNodeFound();
 	}
-
+	
 	throw new CompletionNodeFound(this, binding, scope);
 }
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
index d9e4132..a716dc8 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
@@ -30,7 +30,7 @@ public abstract class Engine implements ITypeRequestor {
 	public LookupEnvironment lookupEnvironment;
 	
 	protected CompilationUnitScope unitScope;
-	protected SearchableEnvironment nameEnvironment;
+	public SearchableEnvironment nameEnvironment;
 
 	public AssistOptions options;
 	public CompilerOptions compilerOptions; 
@@ -339,4 +339,13 @@ public abstract class Engine implements ITypeRequestor {
 		result = CharOperation.replaceOnCopy(result, '/', '.');
 		return result;
 	}
+	
+	public static char[][] getSignatures(Binding[] bindings) {
+		int length = bindings == null ? 0 : bindings.length;
+		char[][] signatures = new char[length][];
+		for (int i = 0; i < length; i++) {
+			signatures[i] = getSignature(bindings[i]);
+		}
+		return signatures;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index f09263d..3b7a82d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -22,7 +22,7 @@ import org.eclipse.jdt.internal.compiler.lookup.*;
 public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeReference {
 
 	public TypeReference[][] typeArguments;
-	private boolean didResolve = false;
+	public boolean didResolve = false;
 
 	/**
 	 * @param tokens
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
index d8561c1..8ac4223 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
@@ -22,7 +22,7 @@ import org.eclipse.jdt.internal.compiler.lookup.*;
 public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 
 	public TypeReference[] typeArguments;
-	private boolean didResolve = false;
+	public boolean didResolve = false;
 	
 	public ParameterizedSingleTypeReference(char[] name, TypeReference[] typeArguments, int dim, long pos){
 		super(name, dim, pos);
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
index 5a07967..20ea1b6 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
@@ -206,6 +206,14 @@ public CompletionRequestor getCompletionRequestor(final CompletionRequestor orig
 		public void setIgnored(int completionProposalKind, boolean ignore) {
 			originalRequestor.setIgnored(completionProposalKind, ignore);
 		}
+		
+		public boolean isAllowingRequiredProposals(int completionProposalKind) {
+			return originalRequestor.isAllowingRequiredProposals(completionProposalKind);
+		}
+
+		public void setAllowsRequiredProposals(int completionProposalKind, boolean allow) {
+			originalRequestor.setAllowsRequiredProposals(completionProposalKind, allow);
+		}
 	};
 }
 public char[] getCUSource(String lineSeparator) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
index 185955a..5dec922 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
@@ -731,6 +731,13 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	private char[] key = null;
 	
 	/**
+	 * Array of required completion proposals, or <code>null</code> if none.
+	 * The proposal can not be applied if the required prooposals aren't applied.
+	 * Defaults to <code>null</code>.
+	 */
+	private CompletionProposal[] requiredProposals;
+	
+	/**
 	 * Modifier flags relevant in the context, or
 	 * <code>Flags.AccDefault</code> if none.
 	 * Defaults to <code>Flags.AccDefault</code>.
@@ -1562,6 +1569,61 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	}
 	
 	/**
+	 * Returns the required completion proposals.
+	 * The proposal can be apply only if these required completion proposals are also applied.
+	 * If the required proposal aren't applied the completion could create complations problems.
+	 * 
+	 * <p>
+	 * This field is available for the following kinds of
+	 * completion proposals:
+	 * <ul>
+	 * 	<li><code>FIELD_REF</code></li>
+	 * 	<li><code>METHOD_REF</code>/li>
+	 * </ul>
+	 * </p>
+	 * <p>
+	 * A required completion proposal can is a completion proposal of one of the following kinds:
+	 * <ul>
+	 *  <li><code>TYPE_REF</code></li>
+	 * </ul>
+	 * Other kinds of required proposals will be returned in the future, therefore clients of this
+	 * API must allow with {@link CompletionRequestor#setAllowsRequiredProposals(int, boolean)} 
+	 * only kinds which are in this list to avoid unexpected results in the future.
+	 * </p>
+	 * <p>
+	 * A required completion proposal cannot have required completion proposals.
+	 * </p>
+	 * 
+	 * @return the required completion proposals, or <code>null</code> if none.
+	 * 
+	 * @see CompletionRequestor#setAllowsRequiredProposals(int, boolean)
+	 * 
+	 * @since 3.3
+	 */
+	public CompletionProposal[] getRequiredProposals() {
+		return this.requiredProposals;
+	}
+	
+	
+	/**
+	 * Sets the list of required completion proposals, or <code>null</code> if none.
+	 * <p>
+	 * If not set, defaults to none.
+	 * </p>
+	 * <p>
+	 * The completion engine creates instances of this class and sets
+	 * its properties; this method is not intended to be used by other clients.
+	 * </p>
+	 * 
+	 * @param proposals the list of required completion proposals, or
+	 * <code>null</code> if none
+     * @since 3.3
+	 */
+	public void setRequiredProposals(CompletionProposal[] proposals) {
+		this.requiredProposals = proposals;
+	}
+	
+	/**
 	 * Finds the method parameter names.
 	 * This information is relevant to method reference (and
 	 * method declaration proposals). Returns <code>null</code>
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
index 29126ca..f5be7cd 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
@@ -59,6 +59,13 @@ public abstract class CompletionRequestor {
 	 * 1 << completionProposalKind
 	 */
 	private int ignoreSet = 0;
+	
+	/**
+	 * The set of CompletionProposal kinds that this requestor
+	 * allows for required proposals; <code>0</code> means the set is empty.
+	 * 1 << completionProposalKind
+	 */
+	private int requiredProposalAllowSet = 0;
 
 	/**
 	 * Creates a new completion requestor.
@@ -112,6 +119,59 @@ public abstract class CompletionRequestor {
 	}
 	
 	/**
+	 * Returns whether a proposal with a required proposal
+	 * of the given kind is allowed.
+	 * 
+	 * @param completionProposalKind one of the kind constants declared
+	 * on <code>CompletionProposal</code>
+	 * @return <code>true</code> if a proposal with a required proposal
+	 * of the given kind is allowed by this requestor, and <code>false</code> 
+	 * if it isn't of interest.
+	 * <p>
+	 * By default, all kinds of required proposals aren't allowed.
+	 * </p>
+	 * @see #setAllowsRequiredProposals(int, boolean)
+	 * @see CompletionProposal#getKind()
+	 * @see CompletionProposal#getRequiredProposals()
+	 * 
+	 * @since 3.3
+	 */
+	public boolean isAllowingRequiredProposals(int completionProposalKind) {
+		if (completionProposalKind < CompletionProposal.FIRST_KIND
+			|| completionProposalKind > CompletionProposal.LAST_KIND) {
+				throw new IllegalArgumentException("Unknown kind of completion proposal: "+completionProposalKind); //$NON-NLS-1$
+		}
+		return 0 != (this.requiredProposalAllowSet & (1 << completionProposalKind));
+	}
+	
+	/**
+	 * Sets whether a proposal with a required proposal
+	 * of the given kind is allowed.
+	 * 
+	 * @param completionProposalKind one of the kind constants declared
+	 * on <code>CompletionProposal</code>
+	 * @param allow <code>true</code> if a proposal with a required proposal
+	 * of the given kind is allowed by this requestor, and <code>false</code> 
+	 * if it isn't of interest
+	 * @see #isAllowingRequiredProposals(int)
+	 * @see CompletionProposal#getKind()
+	 * @see CompletionProposal#getRequiredProposals()
+	 * 
+	 * @since 3.3
+	 */
+	public void setAllowsRequiredProposals(int completionProposalKind, boolean allow) {
+		if (completionProposalKind < CompletionProposal.FIRST_KIND
+			|| completionProposalKind > CompletionProposal.LAST_KIND) {
+				throw new IllegalArgumentException("Unknown kind of completion proposal: "+completionProposalKind); //$NON-NLS-1$
+		}
+		if (allow) {
+			this.requiredProposalAllowSet |= (1 << completionProposalKind);
+		} else {
+			this.requiredProposalAllowSet &= ~(1 << completionProposalKind);
+		}
+	}
+	
+	/**
 	 * Pro forma notification sent before reporting a batch of
 	 * completion proposals.
 	 * <p>
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
index fca2d59..45acefc 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
@@ -152,6 +152,107 @@ public class SearchableEnvironment
 	}
 
 	/**
+	 * Find the top-level types that are defined
+	 * in the current environment and whose simple name matches the given name.
+	 *
+	 * The types found are passed to one of the following methods (if additional
+	 * information is known about the types):
+	 *    ISearchRequestor.acceptType(char[][] packageName, char[] typeName)
+	 *    ISearchRequestor.acceptClass(char[][] packageName, char[] typeName, int modifiers)
+	 *    ISearchRequestor.acceptInterface(char[][] packageName, char[] typeName, int modifiers)
+	 *
+	 * This method can not be used to find member types... member
+	 * types are found relative to their enclosing type.
+	 */
+	public void findExactTypes(char[] name, final boolean findMembers, int searchFor, final ISearchRequestor storage) {
+
+		try {
+			final String excludePath;
+			if (this.unitToSkip != null) {
+				if (!(this.unitToSkip instanceof IJavaElement)) {
+					// revert to model investigation
+					findExactTypes(
+						new String(name),
+						storage,
+						convertSearchFilterToModelFilter(searchFor));
+					return;
+				}
+				excludePath = ((IJavaElement) this.unitToSkip).getPath().toString();
+			} else {
+				excludePath = null;
+			}
+
+			IProgressMonitor progressMonitor = new IProgressMonitor() {
+				boolean isCanceled = false;
+				public void beginTask(String n, int totalWork) {
+					// implements interface method
+				}
+				public void done() {
+					// implements interface method
+				}
+				public void internalWorked(double work) {
+					// implements interface method
+				}
+				public boolean isCanceled() {
+					return isCanceled;
+				}
+				public void setCanceled(boolean value) {
+					isCanceled = value;
+				}
+				public void setTaskName(String n) {
+					// implements interface method
+				}
+				public void subTask(String n) {
+					// implements interface method
+				}
+				public void worked(int work) {
+					// implements interface method
+				}
+			};
+			IRestrictedAccessTypeRequestor typeRequestor = new IRestrictedAccessTypeRequestor() {
+				public void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, String path, AccessRestriction access) {
+					if (excludePath != null && excludePath.equals(path))
+						return;
+					if (!findMembers && enclosingTypeNames != null && enclosingTypeNames.length > 0)
+						return; // accept only top level types
+					storage.acceptType(packageName, simpleTypeName, enclosingTypeNames, modifiers, access);
+				}
+			};
+			try {
+				new BasicSearchEngine(this.workingCopies).searchAllTypeNames(
+					null,
+					SearchPattern.R_EXACT_MATCH,
+					name,
+					SearchPattern.R_EXACT_MATCH,
+					searchFor,
+					this.searchScope,
+					typeRequestor,
+					CANCEL_IF_NOT_READY_TO_SEARCH,
+					progressMonitor);
+			} catch (OperationCanceledException e) {
+				findExactTypes(
+					new String(name),
+					storage,
+					convertSearchFilterToModelFilter(searchFor));
+			}
+		} catch (JavaModelException e) {
+			findExactTypes(
+				new String(name),
+				storage,
+				convertSearchFilterToModelFilter(searchFor));
+		}
+	}
+	
+	/**
+	 * Returns all types whose simple name matches with the given <code>name</code>.
+	 */
+	private void findExactTypes(String name, ISearchRequestor storage, int type) {
+		SearchableEnvironmentRequestor requestor =
+			new SearchableEnvironmentRequestor(storage, this.unitToSkip, this.project, this.nameLookup);
+		this.nameLookup.seekTypes(name, null, false, type, requestor);
+	}
+	
+	/**
 	 * @see org.eclipse.jdt.internal.compiler.env.INameEnvironment#findType(char[][])
 	 */
 	public NameEnvironmentAnswer findType(char[][] compoundTypeName) {
