commit e5f50e77278670587327e1a9ae99915e7634cf7c
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Jul 18 21:02:59 2017 +0200

    Bug 519723 - [9] report not-uniquely visible packages against
    module-info
    
    Change-Id: I3e603beb0c8201d5c33415effe4fdc7aeaa3f8b1

7	0	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
9	9	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
11	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
9	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
4	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
24	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
8	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModulePathEntry.java
14	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
22	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
20	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
11	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
13	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectEntry.java
34	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
12	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
9	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
4	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
1	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
8	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
39	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
7	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
21	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
index 401014e..34007fe 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
@@ -182,6 +182,13 @@ public class ClasspathJsr199 extends ClasspathLocation {
 		}
 		return singletonModuleNameIf(result);
 	}
+	
+	@Override
+	public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName) {
+		if (this.jrt != null)
+			return this.jrt.hasCompilationUnit(qualifiedPackageName, moduleName);
+		return false;
+	}
 
 	@Override
 	public void reset() {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index 4935cb8..dec01c6 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -57,7 +57,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	}
 
 	static {
-//		 TESTS_NAMES = new String[] { "testBug518282e" };
+//		 TESTS_NAMES = new String[] { "test_conflicting_packages" };
 	}
 	private static boolean isJRE9 = false;
 	private String sourceWorkspacePath = null;
@@ -3226,7 +3226,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	}
 	// test that two packages with the same name result in conflict if they are both
 	// accessible to a module
-	public void _test_conflicting_packages() throws CoreException {
+	public void test_conflicting_packages() throws CoreException {
 		if (!isJRE9) return;
 		try {
 			String[] sources = new String[] {
@@ -3274,8 +3274,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
 			sortMarkers(markers);
 			assertMarkers("Unexpected markers", 
-					"Package org.astro exists in multiple modules, org.astro and some.mod\n" +
-					"World cannot be resolved to a type",  markers);
+					"The package org.astro is accessible from more than one module: org.astro, some.mod", markers);
 		} finally {
 			deleteProject("org.astro");
 			deleteProject("some.mod");
@@ -3444,7 +3443,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	}
 	// test that two packages of the same name exported by two named modules result in
 	// a conflict in the context of a non-modular project
-	public void _test_conflicting_packages_unnamed() throws CoreException {
+	public void test_conflicting_packages_unnamed() throws CoreException {
 		if (!isJRE9) return;
 		try {
 			String[] sources = new String[] {
@@ -3492,8 +3491,8 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
 			sortMarkers(markers);
 			assertMarkers("Unexpected markers", 
-					"Package org.astro exists in multiple modules, org.astro and some.mod\n" +
-					"World cannot be resolved to a type",  markers);
+					"The package org.astro is accessible from more than one module: org.astro, some.mod",
+					markers);
 		} finally {
 			deleteProject("org.astro");
 			deleteProject("some.mod");
@@ -3606,7 +3605,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	}
 	// test that a conflicting package does not cause an error when resolving a sub package name
 	// when the sub package is accessible in the context of a non-modular project
-	public void _test_noconflict_subpkg_unnamed() throws CoreException {
+	public void test_noconflict_subpkg_unnamed() throws CoreException {
 		if (!isJRE9) return;
 		try {
 			IClasspathEntry dep = JavaCore.newContainerEntry(new Path(JavaCore.MODULE_PATH_CONTAINER_ID));
@@ -3655,7 +3654,8 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
 			assertMarkers("Unexpected markers", 
-					"Package bundle.org exists in another module, other.mod",  markers);
+					"The package bundle.org is accessible from more than one module: <unnamed>, other.mod",
+					markers);
 		} finally {
 			deleteProject("org.astro");
 			deleteProject("other.mod");
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
index a54d089..3003725 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
@@ -283,6 +283,17 @@ public char[][] getModulesDeclaringPackage(String qualifiedPackageName, /*@Nulla
 	String qp2 = File.separatorChar == '/' ? qualifiedPackageName : qualifiedPackageName.replace('/', File.separatorChar);
 	return singletonModuleNameIf(directoryList(qp2) != null);
 }
+@Override
+public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName) {
+	String qp2 = File.separatorChar == '/' ? qualifiedPackageName : qualifiedPackageName.replace('/', File.separatorChar);
+	String[] dirList = directoryList(qp2);
+	for (String entry : dirList) {
+		String entryLC = entry.toLowerCase();
+		if (entryLC.endsWith(SUFFIX_STRING_java) || entryLC.endsWith(SUFFIX_STRING_class))
+			return true;
+	}
+	return false;
+}
 public void reset() {
 	this.directoryCache = new Hashtable(11);
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index e6db8ec..79f5ade 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -238,6 +238,15 @@ public synchronized char[][] getModulesDeclaringPackage(String qualifiedPackageN
 	}
 	return singletonModuleNameIf(this.packageCache.contains(qualifiedPackageName));
 }
+@Override
+public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName) {
+	for (Enumeration<? extends ZipEntry> e = this.zipFile.entries(); e.hasMoreElements(); ) {
+		String fileName = e.nextElement().getName();
+		if (fileName.startsWith(qualifiedPackageName) && fileName.toLowerCase().endsWith(SUFFIX_STRING_class))
+			return true;
+	}	
+	return false;
+}
 public void reset() {
 	if (this.closeZipFileAtEnd) {
 		if (this.zipFile != null) {
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
index 1f59ed4..ca6d4aa 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
@@ -64,6 +64,10 @@ public class ClasspathJrt extends ClasspathLocation implements IMultiModuleEntry
 		List<String> modules = JRTUtil.getModulesDeclaringPackage(this.file, qualifiedPackageName, moduleName);
 		return CharOperation.toCharArrays(modules);
 	}
+	@Override
+	public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName) {
+		return JRTUtil.hasCompilationUnit(this.file, qualifiedPackageName, moduleName);
+	}
 	public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageName, String moduleName, String qualifiedBinaryFileName) {
 		return findClass(typeName, qualifiedPackageName, moduleName, qualifiedBinaryFileName, false);
 	}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
index 4c51329..94b31d2 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
@@ -59,7 +59,6 @@ public class FileSystem implements IModuleAwareNameEnvironment, SuffixConstants
 		NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageName, String moduleName, String qualifiedBinaryFileName);
 		NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageName, String moduleName, String qualifiedBinaryFileName, boolean asBinaryOnly);
 		boolean isPackage(String qualifiedPackageName, /*@Nullable*/String moduleName);
-		char[][] getModulesDeclaringPackage(String qualifiedPackageName, /*@Nullable*/String moduleName);
 		default boolean hasModule() { return getModule() != null; }
 		/**
 		 * Return a list of the jar file names defined in the Class-Path section
@@ -530,6 +529,30 @@ public char[][] getModulesDeclaringPackage(char[][] parentPackageName, char[] pa
 }
 
 @Override
+public boolean hasCompilationUnit(char[][] qualifiedPackageName, char[] moduleName) {
+	String qPackageName = String.valueOf(CharOperation.concatWith(qualifiedPackageName, '/'));
+	String moduleNameString = String.valueOf(moduleName);
+	LookupStrategy strategy = LookupStrategy.get(moduleName);
+	switch (strategy) {
+		case Named:
+			if (this.moduleLocations != null) {
+				Classpath location = this.moduleLocations.get(moduleNameString);
+				if (location != null)
+					return location.hasCompilationUnit(qPackageName, moduleNameString);
+			}
+			return false;
+		default:
+			for (int i = 0; i < this.classpaths.length; i++) {
+				Classpath location = this.classpaths[i];
+				if (strategy.matches(location, Classpath::hasModule))
+					if (location.hasCompilationUnit(qPackageName, moduleNameString))
+						return true;
+			}
+			return false;
+	}
+}
+
+@Override
 public IModule getModule(char[] name) {
 	if (this.module != null && CharOperation.equals(name, this.module.name())) {
 		return this.module;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
index 4d21f85..e692682 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
@@ -107,7 +107,14 @@ public interface IModuleAwareNameEnvironment extends INameEnvironment {
 	/** Answer a type identified by the given names. moduleName may be one of the special names from ModuleBinding (ANY, ANY_NAMED, UNNAMED). */
 	NameEnvironmentAnswer findType(char[] typeName, char[][] packageName, char[] moduleName);
 	char[][] getModulesDeclaringPackage(char[][] parentPackageName, char[] name, char[] moduleName);
-
+	
+	/**
+	 * Answer whether the given package (within the given module) contains any compilation unit.
+	 * @param qualifiedPackageName
+	 * @return true iff the package contains at least one compilation unit.
+	 */
+	boolean hasCompilationUnit(char[][] qualifiedPackageName, char[] moduleName);
+	
 	/** Get the module with the given name, which must denote a named module. */
 	IModule getModule(char[] moduleName);
 	IModule[] getAllAutomaticModules();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModulePathEntry.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModulePathEntry.java
index 7404b10..609c829 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModulePathEntry.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModulePathEntry.java
@@ -68,6 +68,15 @@ public interface IModulePathEntry {
 	char[][] getModulesDeclaringPackage(String qualifiedPackageName, /*@Nullable*/String moduleName);
 
 	/**
+	 * Answer whether the given package has any compilation unit (.java or .class) in the given module.
+	 * For entries representing a single module, the module name should be checked before invoking this method.
+	 * @param qualifiedPackageName '/'-separated package name
+	 * @param moduleName if non-null only CUs attached to the given module should be considered
+	 * @return true iff a .java or .class file could be found in the given module / package.
+	 */
+	boolean hasCompilationUnit(String qualifiedPackageName, String moduleName);
+
+	/**
 	 * Specifies whether this entry represents an automatic module.
 	 * 
 	 * @return true if this is an automatic module, false otherwise
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
index 016d793..0c70650 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
@@ -19,6 +19,7 @@
 package org.eclipse.jdt.internal.compiler.lookup;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfPackage;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfType;
 
@@ -361,4 +362,17 @@ public boolean isDeclaredIn(ModuleBinding moduleBinding) {
 public boolean subsumes(PackageBinding binding) {
 	return binding == this;
 }
+public boolean hasCompilationUnit() {
+	if (this.knownTypes != null) {
+		for (ReferenceBinding knownType : this.knownTypes.valueTable) {
+			if (knownType != null && knownType != LookupEnvironment.TheNotFoundType)
+				return true;
+		}
+	}
+	if (this.environment.useModuleSystem) {
+		IModuleAwareNameEnvironment moduleEnv = (IModuleAwareNameEnvironment) this.environment.nameEnvironment;
+		return moduleEnv.hasCompilationUnit(this.compoundName, this.enclosingModule.nameForLookup());
+	}
+	return false;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
index 51fef1c..f677b0e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
@@ -254,7 +254,7 @@ public class SplitPackageBinding extends PackageBinding {
 	public boolean hasConflict() {
 		int visibleCount = 0;
 		for (PackageBinding incarnation : this.incarnations) {
-			if (incarnation.knownTypes != null && incarnation.knownTypes.elementSize > 0) { // FIXME(SHMOD): this is a workaround for checking existence of any CU
+			if (incarnation.hasCompilationUnit()) {
 				if (this.enclosingModule.canAccess(incarnation)) 
 					if (++visibleCount > 1)
 						return true;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
index 7bf24a7..5d19f2a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/JRTUtil.java
@@ -27,6 +27,7 @@ import java.nio.file.FileVisitResult;
 import java.nio.file.FileVisitor;
 import java.nio.file.Files;
 import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
@@ -158,6 +159,10 @@ public class JRTUtil {
 	public static List<String> getModulesDeclaringPackage(File jrt, String qName, String moduleName) {
 		return getJrtSystem(jrt).getModulesDeclaringPackage(qName, moduleName);
 	}
+
+	public static boolean hasCompilationUnit(File jrt, String qualifiedPackageName, String moduleName) {
+		return getJrtSystem(jrt).hasClassFile(qualifiedPackageName, moduleName);
+	}
 }
 class JrtFileSystem {
 	private final Map<String, String> packageToModule = new HashMap<String, String>();
@@ -245,6 +250,23 @@ class JrtFileSystem {
 		}
 		return JRTUtil.DEFAULT_MODULE;
 	}
+	public boolean hasClassFile(String qualifiedPackageName, String module) {
+		// easy checks first:
+		String knownModule = this.packageToModule.get(qualifiedPackageName);
+		if (knownModule == null || (knownModule != JRTUtil.MULTIPLE && !knownModule.equals(module)))
+			return false;
+		Path packagePath = this.jrtSystem.getPath(JRTUtil.MODULES_SUBDIR, module, qualifiedPackageName);
+		if (!Files.exists(packagePath))
+			return false;
+		// iterate files:
+		try {
+			return Files.list(packagePath)
+				.anyMatch(filePath -> filePath.endsWith(SuffixConstants.SUFFIX_STRING_class)
+										|| filePath.endsWith(SuffixConstants.SUFFIX_STRING_CLASS));
+		} catch (IOException e) {
+			return false;
+		}
+	}
 
 	public InputStream getContentFromJrt(String fileName, String module) throws IOException {
 		if (module != null) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
index d37eb0c..2f86ea6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
@@ -1867,4 +1867,24 @@ public class NameLookup implements SuffixConstants {
 		return false;
 	}
 
+	public boolean hasCompilationUnit(char[][] pkgName, IJavaElement moduleContext) {
+		String packageName = CharOperation.toString(pkgName);
+		if (packageName == null || packageName.length() == 0) {
+			packageName= IPackageFragment.DEFAULT_PACKAGE_NAME;
+		}
+
+		// Look for concerned package fragments
+		JavaElementRequestor elementRequestor = new JavaElementRequestor();
+		seekPackageFragments(packageName, false, elementRequestor, moduleContext);
+		IPackageFragment[] packages= elementRequestor.getPackageFragments();
+		for (IPackageFragment fragment : packages) {
+			try {
+				if (fragment.containsJavaResources())
+					return true;
+			} catch (JavaModelException e) {
+				// silent
+			}
+		}
+		return false;
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index 4944722..1fd3d23 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -884,4 +884,15 @@ public IModuleDescription getModuleDescription() {
 	}
 	return null;
 }
+/** @see org.eclipse.jdt.internal.compiler.env.IModulePathEntry#hasCompilationUnit(String, String) */
+public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName) {
+	IPackageFragment fragment = getPackageFragment(qualifiedPackageName.replace('/', '.'));
+	try {
+		if (fragment.exists())
+			return fragment.containsJavaResources();
+	} catch (JavaModelException e) {
+		// silent
+	}
+	return false;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectEntry.java
index 23d9b6b..2ac5cd2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ProjectEntry.java
@@ -19,6 +19,7 @@ import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IModuleDescription;
 import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.IModule;
@@ -78,4 +79,16 @@ public class ProjectEntry implements IModulePathEntry {
 		}
 		return null;
 	}
+	@Override
+	public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName) {
+		try {
+			for (IPackageFragmentRoot root : this.project.getPackageFragmentRoots()) {
+				if (root instanceof PackageFragmentRoot && ((PackageFragmentRoot) root).hasCompilationUnit(qualifiedPackageName, moduleName))
+					return true;
+			}
+		} catch (JavaModelException e) {
+			// silent
+		}
+		return false;
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
index efd239b..0609b2d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
@@ -806,6 +806,40 @@ public class SearchableEnvironment
 				throw new IllegalArgumentException("Unexpected LookupStrategy "+strategy); //$NON-NLS-1$
 		}
 	}
+	@Override
+	public boolean hasCompilationUnit(char[][] pkgName, char[] moduleName) {
+		LookupStrategy strategy = LookupStrategy.get(moduleName);
+		switch (strategy) {
+			case Named:
+				if (this.knownModuleLocations != null) {
+					IJavaElement moduleContext = findModuleContext(moduleName);
+					if (moduleContext != null) {
+						// (this.owner != null && this.owner.isPackage(pkgName)) // TODO(SHMOD) see old isPackage
+						if (this.nameLookup.hasCompilationUnit(pkgName, moduleContext))
+							return true;
+					}
+				}
+				return false;
+			case Unnamed:
+			case Any:
+				// if in pre-9 mode we may still search the unnamed module 
+				if (this.knownModuleLocations == null) {
+					if (this.nameLookup.hasCompilationUnit(pkgName, null))
+						return true;
+				}
+				//$FALL-THROUGH$
+			case AnyNamed:
+				for (IPackageFragmentRoot packageRoot : this.nameLookup.packageFragmentRoots) {
+					if (strategy.matches(packageRoot, loc -> loc instanceof JrtPackageFragmentRoot || getModuleDescription(loc) != null)) {
+						if (this.nameLookup.hasCompilationUnit(pkgName, packageRoot))
+							return true;
+					}
+				}
+				return false;
+			default:
+				throw new IllegalArgumentException("Unexpected LookupStrategy "+strategy); //$NON-NLS-1$
+		}
+	}
 	private IModuleDescription getModuleDescription(IPackageFragmentRoot root) {
 		if (root instanceof JarPackageFragmentRoot)
 			return root.getModuleDescription();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
index 7cc6242..552053a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
@@ -213,6 +213,18 @@ public boolean isPackage(String qualifiedPackageName, String moduleName) {
 	}
 	return directoryList(qualifiedPackageName) != null;
 }
+@Override
+public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName) {
+	String[] dirList = directoryList(qualifiedPackageName);
+	if (dirList != null) {
+		for (String entry : dirList) {
+			String entryLC = entry.toLowerCase();
+			if (entryLC.endsWith(SuffixConstants.SUFFIX_STRING_class) || entryLC.endsWith(SuffixConstants.SUFFIX_STRING_java))
+				return true;
+		}
+	}
+	return false;
+}
 
 public void reset() {
 	this.directoryCache = new SimpleLookupTable(5);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index cdab5d4..48a4a61 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -277,6 +277,15 @@ public boolean isPackage(String qualifiedPackageName, String moduleName) {
 		scanContent();
 	return this.knownPackageNames.includes(qualifiedPackageName);
 }
+@Override
+public boolean hasCompilationUnit(String pkgName, String moduleName) {
+	for (Enumeration<? extends ZipEntry> e = this.zipFile.entries(); e.hasMoreElements(); ) {
+		String fileName = e.nextElement().getName();
+		if (fileName.startsWith(pkgName) && fileName.toLowerCase().endsWith(SuffixConstants.SUFFIX_STRING_class))
+			return true;
+	}	
+	return false;
+}
 
 /** Scan the contained packages and try to locate the module descriptor. */
 private void scanContent() {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
index 8274ebf..484f865 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
@@ -226,6 +226,10 @@ public char[][] getModulesDeclaringPackage(String qualifiedPackageName, String m
 	return CharOperation.toCharArrays(moduleNames); 
 }
 @Override
+public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName) {
+	return JRTUtil.hasCompilationUnit(new File(this.zipFilename), qualifiedPackageName, moduleName);
+}
+@Override
 public boolean isPackage(String qualifiedPackageName, String moduleName) {
 	return JRTUtil.getModulesDeclaringPackage(new File(this.zipFilename), qualifiedPackageName, moduleName) != null;
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
index 2bc1147..20f397c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
@@ -38,6 +38,7 @@ public abstract class ClasspathLocation {
 		return singletonModuleNameIf(isPackage(qualifiedPackageName, moduleName));
 	}
 	public boolean hasModule() { return getModule() != null; }
+	abstract public boolean hasCompilationUnit(String pkgName, String moduleName);
 
 	public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageName, String moduleName, String qualifiedBinaryFileName, boolean asBinaryOnly) {
 		String fileName = new String(typeName);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
index 041aea0..c326b2a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ModulePathEntry.java
@@ -117,4 +117,12 @@ public class ModulePathEntry implements IModulePathEntry {
 		}
 		return names == CharOperation.NO_CHAR_CHAR ? null : names;
 	}
+	@Override
+	public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName) {
+		for (ClasspathLocation cp : this.locations) {
+			if (cp.hasCompilationUnit(qualifiedPackageName, moduleName))
+				return true;
+		}
+		return false;
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index b32c6a7..bda7661 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -480,6 +480,45 @@ public char[][] getModulesDeclaringPackage(char[][] parentPackageName, char[] na
 	}
 	return null;
 }
+
+@Override
+public boolean hasCompilationUnit(char[][] qualifiedPackageName, char[] moduleName) {
+	String pkgName = String.valueOf(CharOperation.concatWith(qualifiedPackageName, '/'));
+	LookupStrategy strategy = LookupStrategy.get(moduleName);
+	String modName = LookupStrategy.getStringName(moduleName);
+	switch (strategy) {
+		// include unnamed (search all locations):
+		case Any:
+		case Unnamed:
+			for (ClasspathLocation location : this.binaryLocations) {
+				if (strategy.matches(location, ClasspathLocation::hasModule))
+					if (location.hasCompilationUnit(pkgName, null))
+						return true;
+			}
+			for (ClasspathLocation location : this.sourceLocations) {
+				if (strategy.matches(location, ClasspathLocation::hasModule))
+					if (location.hasCompilationUnit(pkgName, null))
+						return true;
+			}
+			return false;
+		// only named (rely on modulePathEntries):
+		case Named:
+			if (this.modulePathEntries != null) {
+				IModulePathEntry modulePathEntry = this.modulePathEntries.get(modName);
+				return modulePathEntry != null && modulePathEntry.hasCompilationUnit(pkgName, modName);
+			}
+			return false;
+		case AnyNamed:
+			if (this.modulePathEntries != null) {
+				for (IModulePathEntry modulePathEntry : this.modulePathEntries.values())
+					if (modulePathEntry.hasCompilationUnit(pkgName, modName))
+						return true;
+			}
+			return false;
+		default:
+			throw new IllegalArgumentException("Unexpected LookupStrategy "+strategy); //$NON-NLS-1$
+	}
+}
 private boolean isPackage(String qualifiedPackageName, char[] moduleName) {
 	String stringModuleName = null;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
index 782338d..1f27612 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
@@ -141,6 +141,13 @@ public boolean isPackage(String qualifiedPackageName, String moduleName) {
 	}
 	return directoryTable(qualifiedPackageName) != null;
 }
+@Override
+public boolean hasCompilationUnit(String qualifiedPackageName, String moduleName) {
+	SimpleLookupTable dirTable = directoryTable(qualifiedPackageName);
+	if (dirTable != null && dirTable.elementSize > 0)
+		return true;
+	return false;
+}
 
 public void reset() {
 	this.directoryCache = new SimpleLookupTable(5);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index 9ef9045..51dd7fc 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -313,6 +313,27 @@ public char[][] getModulesDeclaringPackage(char[][] parentPackageName, char[] pa
 }
 
 @Override
+public boolean hasCompilationUnit(char[][] qualifiedPackageName, char[] moduleName) {
+	String qualifiedPackageNameString = String.valueOf(CharOperation.concatWith(qualifiedPackageName, '/'));
+	LookupStrategy strategy = LookupStrategy.get(moduleName);
+	String moduleNameString = LookupStrategy.getStringName(moduleName);
+	if (strategy == LookupStrategy.Named) {
+		if (this.moduleLocations != null) {
+			ClasspathLocation location = this.moduleLocations.get(moduleNameString);
+			if (location != null)
+				return location.hasCompilationUnit(qualifiedPackageNameString, moduleNameString);
+		}
+	} else {
+		for (ClasspathLocation location : this.locationSet) {
+			if (strategy.matches(location, ClasspathLocation::hasModule) )
+				if (location.hasCompilationUnit(qualifiedPackageNameString, moduleNameString))
+					return true;
+		}
+	}
+	return false;
+}
+
+@Override
 public IModule getModule(char[] moduleName) {
 	computeModules();
 	IModuleDescription moduleDesc = this.modules.get(new String(moduleName));
commit 945630481f843e105af19f0a539378d2d27c1154
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Jul 25 20:59:11 2017 +0200

    Bug 519723 - [9] report not-uniquely visible packages against
    module-info
    
    Change-Id: I88f8cfc5abcd7d97637da6a6778983b0e8a89098

108	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
6	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
41	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
16	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index 738e708..4cc0913 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -1754,6 +1754,99 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				false);
 	}
 
+	// conflict even without any reference to the conflicting package
+	// - three-way conflict between two direct and one indirect dependency
+	public void testPackageConflict0() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+
+		String moduleLoc = directory + File.separator + "mod.x";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.x { \n" +
+						"	exports pm;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "pm", "C1x.java", 
+						"package pm;\n" +
+						"public class C1x {\n" +
+						"}\n");
+		
+		moduleLoc = directory + File.separator + "mod.y";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.y { \n" +
+						"	requires transitive mod.x;\n" +
+						"}");
+		
+		moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports pm;\n" +
+						"	exports p2;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "pm", "C1.java", 
+						"package pm;\n" +
+						"public class C1 {\n" +
+						"}\n");
+		writeFile(moduleLoc + File.separator + "p2", "C2.java", 
+						"package p2;\n" +
+						"public class C2 {\n" +
+						"}\n");
+
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	exports pm;\n" +
+						"	exports p2.sub;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "pm", "C3.java", 
+						"package pm;\n" +
+						"public class C3 {\n" +
+						"}\n");
+		writeFile(moduleLoc + File.separator + "p2" + File.separator + "sub", "C4.java", 
+						"package p2.sub;\n" +
+						"public class C4 {\n" +
+						"}\n");
+
+		moduleLoc = directory + File.separator + "mod.three";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.three { \n" +
+						"	requires mod.one;\n" +
+						"	requires mod.two;\n" +
+						"	requires transitive mod.y;\n" +
+						"}");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+
+		runNegativeTest(new String[]{}, 
+				buffer.toString(), 
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/module-info.java (at line 2)\n" + 
+				"	requires mod.one;\n" + 
+				"	^^^^^^^^^^^^^^^^\n" + 
+				"The package pm is accessible from more than one module: mod.one, mod.two, mod.x\n" + 
+				"----------\n" + 
+				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/module-info.java (at line 3)\n" + 
+				"	requires mod.two;\n" + 
+				"	^^^^^^^^^^^^^^^^\n" + 
+				"The package pm is accessible from more than one module: mod.one, mod.two, mod.x\n" + 
+				"----------\n" + 
+				"3. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/module-info.java (at line 4)\n" + 
+				"	requires transitive mod.y;\n" + 
+				"	^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"The package pm is accessible from more than one module: mod.one, mod.two, mod.x\n" + 
+				"----------\n" + 
+				"3 problems (3 errors)\n",
+				false);
+	}
+
 	public void testPackageConflict1() {
 		File outputDirectory = new File(OUTPUT_DIR);
 		Util.flushDirectoryContent(outputDirectory);
@@ -1820,22 +1913,33 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				buffer.toString(), 
 				"",
 				"----------\n" + 
-				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/po/Client.java (at line 2)\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/module-info.java (at line 2)\n" + 
+				"	requires mod.one;\n" + 
+				"	^^^^^^^^^^^^^^^^\n" + 
+				"The package pm is accessible from more than one module: mod.one, mod.two\n" + 
+				"----------\n" + 
+				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/module-info.java (at line 3)\n" + 
+				"	requires mod.two;\n" + 
+				"	^^^^^^^^^^^^^^^^\n" + 
+				"The package pm is accessible from more than one module: mod.one, mod.two\n" + 
+				"----------\n" + 
+				"----------\n" + 
+				"3. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/po/Client.java (at line 2)\n" + 
 				"	import pm.*;\n" + 
 				"	       ^^\n" + 
 				"The package pm is accessible from more than one module: mod.one, mod.two\n" + 
 				"----------\n" + 
-				"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/po/Client.java (at line 3)\n" + 
+				"4. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/po/Client.java (at line 3)\n" + 
 				"	import pm.C3;\n" + 
 				"	       ^^\n" + 
 				"The package pm is accessible from more than one module: mod.one, mod.two\n" + 
 				"----------\n" + 
-				"3. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/po/Client.java (at line 8)\n" + 
+				"5. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.three/po/Client.java (at line 8)\n" + 
 				"	pm.C1 f1;\n" + 
 				"	^^\n" + 
 				"The package pm is accessible from more than one module: mod.one, mod.two\n" + 
 				"----------\n" + 
-				"3 problems (3 errors)\n",
+				"5 problems (5 errors)\n",
 				false);
 	}
 	public void testPackageTypeConflict1() {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index 1cb67e6..b6798fa 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -3280,8 +3280,12 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
 			sortMarkers(markers);
-			assertMarkers("Unexpected markers", 
-					"The package org.astro is accessible from more than one module: org.astro, some.mod", markers);
+			assertMarkers("Unexpected markers",
+					// reported against both 'requires' directives & against the import:
+					"The package org.astro is accessible from more than one module: org.astro, some.mod\n" +
+					"The package org.astro is accessible from more than one module: org.astro, some.mod\n" +
+					"The package org.astro is accessible from more than one module: org.astro, some.mod",
+					markers);
 		} finally {
 			deleteProject("org.astro");
 			deleteProject("some.mod");
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
index 94435cf..43de885 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
@@ -126,6 +126,9 @@ public void analyseCode() {
 				this.types[i].analyseCode(this.scope);
 			}
 		}
+		if (this.moduleDeclaration != null) {
+			this.moduleDeclaration.analyseModuleGraph(this.scope);
+		}
 		// request inner emulation propagation
 		propagateInnerEmulationForAllLocalTypes();
 	} catch (AbortCompilationUnit e) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
index f17b2a1..77baf34 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
@@ -16,7 +16,9 @@
 package org.eclipse.jdt.internal.compiler.ast;
 
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
@@ -235,6 +237,45 @@ public class ModuleDeclaration extends ASTNode {
 		this.binding.setServices(interfaces.toArray(new TypeBinding[interfaces.size()]));
 	}
 
+	public void analyseModuleGraph(CompilationUnitScope skope) {
+		if (this.requires != null) {
+			// collect transitively:
+			Map<String, Set<ModuleBinding>> pack2mods = new HashMap<>();
+			for (ModuleBinding requiredModule : this.binding.getAllRequiredModules()) {
+				for (PackageBinding exportedPackage : requiredModule.getExports()) {
+					if (this.binding.canAccess(exportedPackage)) {
+						String packName = String.valueOf(exportedPackage.readableName());
+						Set<ModuleBinding> mods = pack2mods.get(packName);
+						if (mods == null)
+							pack2mods.put(packName, mods = new HashSet<>());
+						mods.add(requiredModule);
+					}
+				}
+			}
+			// report against the causing requires directives:
+			for (RequiresStatement requiresStat : this.requires) {
+				ModuleBinding requiredModule = requiresStat.resolvedBinding;
+				if (requiredModule != null) {
+					analyseOneDependency(requiresStat, requiredModule, skope, pack2mods);
+					if (requiresStat.isTransitive()) {
+						for (ModuleBinding secondLevelModule : requiredModule.getAllRequiredModules())
+							analyseOneDependency(requiresStat, secondLevelModule, skope, pack2mods);
+					}
+				}
+			}
+		}
+	}
+
+	private void analyseOneDependency(RequiresStatement requiresStat, ModuleBinding requiredModule, CompilationUnitScope skope,
+			Map<String, Set<ModuleBinding>> pack2mods)
+	{
+		for (PackageBinding pack : requiredModule.getExports()) {
+			Set<ModuleBinding> mods = pack2mods.get(String.valueOf(pack.readableName()));
+			if (mods != null && mods.size() > 1)
+				skope.problemReporter().conflictingPackagesFromModules(pack, mods, requiresStat.sourceStart, requiresStat.sourceEnd);
+		}
+	}
+
 	public StringBuffer printHeader(int indent, StringBuffer output) {
 		if (this.annotations != null) {
 			for (int i = 0; i < this.annotations.length; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index cffc138..ff5b822 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -83,6 +83,7 @@ import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Set;
 import java.util.stream.Collectors;
 
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
@@ -3228,6 +3229,21 @@ public void conflictingPackagesFromModules(SplitPackageBinding splitPackage, int
 			sourceStart,
 			sourceEnd);
 }
+public void conflictingPackagesFromModules(PackageBinding pack, Set<ModuleBinding> modules, int sourceStart, int sourceEnd) {
+	String moduleNames = modules.stream()
+						.map(p -> String.valueOf(p.name()))
+						.sorted()
+						.collect(Collectors.joining(", ")); //$NON-NLS-1$
+	String[] arguments = new String[] {
+						CharOperation.toString(pack.compoundName),
+						moduleNames };
+	this.handle(
+			IProblem.ConflictingPackageFromModules,
+			arguments,
+			arguments,
+			sourceStart,
+			sourceEnd);
+}
 public void incompatibleExceptionInThrowsClause(SourceTypeBinding type, MethodBinding currentMethod, MethodBinding inheritedMethod, ReferenceBinding exceptionType) {
 	if (TypeBinding.equalsEquals(type, currentMethod.declaringClass)) {
 		int id;
commit 90f049c41c0d5fb68f1d6752dad21c4b010de176
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sat Jul 29 18:16:05 2017 +0200

    Bug 519723 - [9] report not-uniquely visible packages against
    module-info
    
    Change-Id: I3cbc33b08d1ecacf57e84c717f2424e640230251

3	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
47	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
6	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
23	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ImportReference.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
11	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
13	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 27d0582..87dfc1c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -878,6 +878,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NotAccessibleType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NotAccessiblePackage", new ProblemAttributes(CategorizedProblem.CAT_IMPORT));
 		expectedProblemAttributes.put("ConflictingPackageFromModules", new ProblemAttributes(CategorizedProblem.CAT_IMPORT));
+		expectedProblemAttributes.put("ConflictingPackageFromOtherModules", new ProblemAttributes(CategorizedProblem.CAT_IMPORT));
 		expectedProblemAttributes.put("NotVisibleConstructor", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleConstructorInDefaultConstructor", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("NotVisibleConstructorInImplicitConstructorCall", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
@@ -1756,7 +1757,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NotAccessibleMethod", SKIP);
 		expectedProblemAttributes.put("NotAccessibleType", SKIP);
 		expectedProblemAttributes.put("NotAccessiblePackage", SKIP);
-		expectedProblemAttributes.put("ConflictingPackageFromModules", SKIP);		
+		expectedProblemAttributes.put("ConflictingPackageFromModules", SKIP);
+		expectedProblemAttributes.put("ConflictingPackageFromOtherModules", SKIP);
 		expectedProblemAttributes.put("NotVisibleConstructor", SKIP);
 		expectedProblemAttributes.put("NotVisibleConstructorInDefaultConstructor", SKIP);
 		expectedProblemAttributes.put("NotVisibleConstructorInImplicitConstructorCall", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
index 4cc0913..3644ec8 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ModuleCompilationTests.java
@@ -1942,6 +1942,53 @@ public class ModuleCompilationTests extends AbstractBatchCompilerTest {
 				"5 problems (5 errors)\n",
 				false);
 	}
+	// conflict foreign<->local package
+	public void testPackageConflict3() {
+		File outputDirectory = new File(OUTPUT_DIR);
+		Util.flushDirectoryContent(outputDirectory);
+		String out = "bin";
+		String directory = OUTPUT_DIR + File.separator + "src";
+
+		String moduleLoc = directory + File.separator + "mod.one";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.one { \n" +
+						"	exports pm;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "pm", "C1.java", 
+						"package pm;\n" +
+						"public class C1 {\n" +
+						"}\n");
+
+		moduleLoc = directory + File.separator + "mod.two";
+		writeFile(moduleLoc, "module-info.java", 
+						"module mod.two { \n" +
+						"	requires mod.one;\n" +
+						"}");
+		writeFile(moduleLoc + File.separator + "pm", "C3.java", 
+						"package pm;\n" +
+						"public class C3 {\n" +
+						"}\n");
+
+		StringBuffer buffer = new StringBuffer();
+		buffer.append("-d " + OUTPUT_DIR + File.separator + out )
+			.append(" -9 ")
+			.append(" -classpath \"")
+			.append(Util.getJavaClassLibsAsString())
+			.append("\" ")
+			.append(" --module-source-path " + "\"" + directory + "\"");
+
+		runNegativeTest(new String[]{},
+				buffer.toString(), 
+				"",
+				"----------\n" + 
+				"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/src/mod.two/pm/C3.java (at line 1)\n" + 
+				"	package pm;\n" + 
+				"	        ^^\n" + 
+				"The package pm conflicts with a package accessible from another module: mod.one\n" + 
+				"----------\n" + 
+				"1 problem (1 error)\n",
+				false);
+	}
 	public void testPackageTypeConflict1() {
 		File outputDirectory = new File(OUTPUT_DIR);
 		Util.flushDirectoryContent(outputDirectory);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index 0380bdc..20b58b9 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -3335,7 +3335,8 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
 			assertMarkers("Unexpected markers", 
-					"The package org.astro is accessible from more than one module: com.greetings, org.astro",  markers);
+					"org.astro.World cannot be resolved to a type\n" +
+					"The package org.astro conflicts with a package accessible from another module: org.astro",  markers);
 		} finally {
 			deleteProject("org.astro");
 			deleteProject("com.greetings");
@@ -3552,7 +3553,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
 			assertMarkers("Unexpected markers", 
-					"The package org.astro is accessible from more than one module: <unnamed>, org.astro",
+					"The package org.astro conflicts with a package accessible from another module: org.astro",
 					markers);
 		} finally {
 			deleteProject("org.astro");
@@ -3665,7 +3666,8 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
 			assertMarkers("Unexpected markers", 
-					"The package bundle.org is accessible from more than one module: <unnamed>, other.mod",
+					"The package bundle.org conflicts with a package accessible from another module: other.mod\n" + 
+					"bundle.org.astro.World cannot be resolved to a type",
 					markers);
 		} finally {
 			deleteProject("org.astro");
@@ -4501,6 +4503,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 		}
 	}
 	public void testPrivateMethod_Bug515985() throws CoreException {
+		if (!isJRE9) return;
 		try {
 			String[] src = new String[] {
 					"src/module-info.java", 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 647c141..a4216ac 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1960,6 +1960,8 @@ void setSourceStart(int sourceStart);
 	int NotAccessiblePackage = ImportRelated + 1454;
 	/** @since 3.13 BETA_JAVA9 */
 	int ConflictingPackageFromModules = ImportRelated + 1455;
+	/** @since 3.13 BETA_JAVA9 */
+	int ConflictingPackageFromOtherModules = ImportRelated + 1456;
 
 	/** @since 3.13 */
 	int RedundantNullDefaultAnnotationLocal = Internal + 1062;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ImportReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ImportReference.java
index 6011941..06de2f5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ImportReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ImportReference.java
@@ -1,15 +1,22 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import java.util.HashSet;
+import java.util.Set;
+
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.*;
@@ -54,6 +61,21 @@ public class ImportReference extends ASTNode {
 		return this.tokens;
 	}
 
+	public void checkPackageConflict(CompilationUnitScope scope) {
+		ModuleBinding module = scope.module();
+		PackageBinding visiblePackage = module.getVisiblePackage(this.tokens);
+		if (visiblePackage instanceof SplitPackageBinding) {
+			Set<ModuleBinding> declaringMods = new HashSet<>();
+			for (PackageBinding incarnation : ((SplitPackageBinding) visiblePackage).incarnations) {
+				if (incarnation.enclosingModule != module && module.canAccess(incarnation))
+					declaringMods.add(incarnation.enclosingModule);
+			}
+			if (!declaringMods.isEmpty()) {
+				scope.problemReporter().conflictingPackagesFromOtherModules(this, declaringMods);
+			}
+		}
+	}
+
 	public StringBuffer print(int indent, StringBuffer output) {
 
 		return print(indent, output, true);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
index cebb11b..7be4ed2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
@@ -117,13 +117,13 @@ public class QualifiedTypeReference extends TypeReference {
 	    PackageBinding packageBinding = binding == null ? null : (PackageBinding) binding;
 	    int typeStart = packageBinding == null ? 0 : packageBinding.compoundName.length;
 	    
+	    if (packageBinding != null)
+	    	packageBinding = packageBinding.getVisibleFor(scope.module());
 	    if (packageBinding instanceof SplitPackageBinding) {
 	    	SplitPackageBinding splitPackage = (SplitPackageBinding) packageBinding;
-	    	if (splitPackage.hasConflict(scope.module())) {
-	    		scope.problemReporter().conflictingPackagesFromModules(splitPackage, this.sourceStart, (int)this.sourcePositions[typeStart-1]);
-	    		this.resolvedType = new ProblemReferenceBinding(this.tokens, null, ProblemReasons.Ambiguous);
-	    		return null;
-	    	}
+	    	scope.problemReporter().conflictingPackagesFromModules(splitPackage, this.sourceStart, (int)this.sourcePositions[typeStart-1]);
+	    	this.resolvedType = new ProblemReferenceBinding(this.tokens, null, ProblemReasons.Ambiguous);
+	    	return null;
 	    }
 	    rejectAnnotationsOnPackageQualifiers(scope, packageBinding);
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index 4ecef5b..d4aa711 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -424,9 +424,10 @@ void faultInImports() {
 				problemReporter().importProblem(importReference, importBinding);
 				continue nextImport;
 			}
-			if (importBinding instanceof SplitPackageBinding) {
-				SplitPackageBinding splitPackage = (SplitPackageBinding) importBinding;
-				if (splitPackage.hasConflict(module())) {
+			if (importBinding instanceof PackageBinding) {
+				importBinding = ((PackageBinding)importBinding).getVisibleFor(module());
+				if (importBinding instanceof SplitPackageBinding) {
+					SplitPackageBinding splitPackage = (SplitPackageBinding) importBinding;
 					problemReporter().conflictingPackagesFromModules(splitPackage, importReference.sourceStart, importReference.sourceEnd);
 					continue nextImport;
 				}
@@ -460,13 +461,13 @@ void faultInImports() {
 				}
 				// re-get to find a possible split package:
 				importedPackage = (PackageBinding) findImport(importedPackage.compoundName, false, true);
+				if (importedPackage != null)
+					importedPackage = importedPackage.getVisibleFor(module());
 				if (importedPackage instanceof SplitPackageBinding) {
 					SplitPackageBinding splitPackage = (SplitPackageBinding) importedPackage;
-					if (splitPackage.hasConflict(module())) {
-						int sourceEnd = (int) importReference.sourcePositions[splitPackage.compoundName.length-1];
-						problemReporter().conflictingPackagesFromModules(splitPackage, importReference.sourceStart, sourceEnd);
-						continue nextImport;
-					}
+					int sourceEnd = (int) importReference.sourcePositions[splitPackage.compoundName.length-1];
+					problemReporter().conflictingPackagesFromModules(splitPackage, importReference.sourceStart, sourceEnd);
+					continue nextImport;
 				}
 			}
 			// all the code here which checks for valid bindings have been moved to the method 
@@ -504,6 +505,8 @@ public void faultInTypes() {
 	faultInImports();
 	if (this.referenceContext.moduleDeclaration != null) {
 		this.referenceContext.moduleDeclaration.resolveTypeDirectives(this);
+	} else if (this.referenceContext.currentPackage != null) {
+		this.referenceContext.currentPackage.checkPackageConflict(this);
 	}
 
 	for (int i = 0, length = this.topLevelTypes.length; i < length; i++)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
index c3a789c..39676d3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
@@ -355,6 +355,17 @@ public boolean isDeclaredIn(ModuleBinding moduleBinding) {
 public boolean subsumes(PackageBinding binding) {
 	return binding == this;
 }
+/**
+ * If this package is uniquely visible to 'module' return a plain PackageBinding.
+ * In case of a conflict between a local package and foreign package
+ * the plain local package is returned, because this conflict will more
+ * appropriately be reported against the package declaration, not its references.
+ * In case of multiple accessible foreign packages a SplitPackageBinding is returned
+ * to indicate a conflict.
+ */
+public PackageBinding getVisibleFor(ModuleBinding module) {
+	return this;
+}
 public boolean hasCompilationUnit() {
 	if (this.knownTypes != null) {
 		for (ReferenceBinding knownType : this.knownTypes.valueTable) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
index 927965d..2a9edb8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
@@ -243,16 +243,24 @@ public class SplitPackageBinding extends PackageBinding {
 		return this.declaringModules.contains(moduleBinding);
 	}
 
-	public boolean hasConflict(ModuleBinding clientModule) {
+	@Override
+	public PackageBinding getVisibleFor(ModuleBinding clientModule) {
 		int visibleCount = 0;
+		PackageBinding unique = null;
 		for (PackageBinding incarnation : this.incarnations) {
 			if (incarnation.hasCompilationUnit()) {
-				if (clientModule.canAccess(incarnation)) 
-					if (++visibleCount > 1)
-						return true;
+				if (incarnation.enclosingModule == clientModule) {
+					return incarnation; // prefer local package over foreign
+				} else {
+					if (clientModule.canAccess(incarnation)) {
+						if (++visibleCount > 1)
+							return this;
+						unique = incarnation;
+					}
+				}
 			}
 		}
-		return false;
+		return unique;
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index ff5b822..f0ef36d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -3244,6 +3244,14 @@ public void conflictingPackagesFromModules(PackageBinding pack, Set<ModuleBindin
 			sourceStart,
 			sourceEnd);
 }
+public void conflictingPackagesFromOtherModules(ImportReference currentPackage, Set<ModuleBinding> declaringModules) {
+		String moduleNames = declaringModules.stream()
+								.map(p -> String.valueOf(p.name()))
+								.sorted()
+								.collect(Collectors.joining(", ")); //$NON-NLS-1$
+		String[] arguments = new String[] { CharOperation.toString(currentPackage.tokens), moduleNames };
+		this.handle(IProblem.ConflictingPackageFromOtherModules, arguments, arguments, currentPackage.sourceStart, currentPackage.sourceEnd);
+}
 public void incompatibleExceptionInThrowsClause(SourceTypeBinding type, MethodBinding currentMethod, MethodBinding inheritedMethod, ReferenceBinding exceptionType) {
 	if (TypeBinding.equalsEquals(type, currentMethod.declaringClass)) {
 		int id;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 560aa80..f9e7f31 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -920,6 +920,7 @@
 1453 = The constructor {0}({1}) is not accessible
 1454 = The package {0} is not accessible
 1455 = The package {0} is accessible from more than one module: {1}
+1456 = The package {0} conflicts with a package accessible from another module: {1}
 
 ### ELABORATIONS
 ## Access restrictions
