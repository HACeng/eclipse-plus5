commit 3bf5bab95449ec256a601c2551910573083178b4
Author: David Audel <daudel>
Date:   Wed Jun 16 17:10:22 2004 +0000

    bug 66271

286	6	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java
10	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateFieldDeclaration.java
10	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateFieldDeclaration3.java
4	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration.java
10	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration11.java
4	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration3.java
4	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration5.java
6	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration7.java
10	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration9.java
0	4	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDelcaration.java
6	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration.java
10	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration3.java
10	0	org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration5.java
1	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
16	0	org.eclipse.jdt.core/buildnotes_jdt-core.html
39	3	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/ISelectionRequestor.java
110	22	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
6	6	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
204	55	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
3	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java
index ef48e0b..7d099db 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java
@@ -1026,8 +1026,8 @@ public void testEndOfFile() throws JavaModelException {
 /**
  * https://bugs.eclipse.org/bugs/show_bug.cgi?id=65259
  */
-public void testDuplicateMethodDelcaration() throws JavaModelException {
-	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDelcaration.java");
+public void testDuplicateMethodDeclaration() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration.java");
 	
 	String str = cu.getSource();
 	int start = str.indexOf("foo");
@@ -1036,15 +1036,15 @@ public void testDuplicateMethodDelcaration() throws JavaModelException {
 	
 	assertElementsEqual(
 			"Unexpected elements",
-			"foo() [in ResolveDuplicateMethodDelcaration [in ResolveDuplicateMethodDelcaration.java [in <default> [in src [in Resolve]]]]]",
+			"foo() [in ResolveDuplicateMethodDeclaration [in ResolveDuplicateMethodDeclaration.java [in <default> [in src [in Resolve]]]]]",
 			elements
 	);
 }
 /**
  * https://bugs.eclipse.org/bugs/show_bug.cgi?id=65259
  */
-public void testDuplicateMethodDelcaration2() throws JavaModelException {
-	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDelcaration.java");
+public void testDuplicateMethodDeclaration2() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration.java");
 	
 	String str = cu.getSource();
 	int start = str.lastIndexOf("foo");
@@ -1053,7 +1053,287 @@ public void testDuplicateMethodDelcaration2() throws JavaModelException {
 	
 	assertElementsEqual(
 			"Unexpected elements",
-			"foo()#2 [in ResolveDuplicateMethodDelcaration [in ResolveDuplicateMethodDelcaration.java [in <default> [in src [in Resolve]]]]]",
+			"foo()#2 [in ResolveDuplicateMethodDeclaration [in ResolveDuplicateMethodDeclaration.java [in <default> [in src [in Resolve]]]]]",
+			elements
+	);
+}
+public void testDuplicateMethodDeclaration3() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration3.java");
+	
+	String str = cu.getSource();
+	int start = str.indexOf("foo");
+	int length = "foo".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"foo(Object) [in ResolveDuplicateMethodDeclaration3 [in ResolveDuplicateMethodDeclaration3.java [in <default> [in src [in Resolve]]]]]",
+			elements
+	);
+}
+public void testDuplicateMethodDeclaration4() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration3.java");
+	
+	String str = cu.getSource();
+	int start = str.lastIndexOf("foo");
+	int length = "foo".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"foo(Object)#2 [in ResolveDuplicateMethodDeclaration3 [in ResolveDuplicateMethodDeclaration3.java [in <default> [in src [in Resolve]]]]]",
+			elements
+	);
+}
+public void testDuplicateMethodDeclaration5() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration5.java");
+	
+	String str = cu.getSource();
+	int start = str.indexOf("foo");
+	int length = "foo".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"foo(Zork) [in ResolveDuplicateMethodDeclaration5 [in ResolveDuplicateMethodDeclaration5.java [in <default> [in src [in Resolve]]]]]",
+			elements
+	);
+}
+public void testDuplicateMethodDeclaration6() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration5.java");
+	
+	String str = cu.getSource();
+	int start = str.lastIndexOf("foo");
+	int length = "foo".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"foo(Zork)#2 [in ResolveDuplicateMethodDeclaration5 [in ResolveDuplicateMethodDeclaration5.java [in <default> [in src [in Resolve]]]]]",
+			elements
+	);
+}
+public void testDuplicateMethodDeclaration7() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration7.java");
+	
+	String str = cu.getSource();
+	int start = str.indexOf("foo");
+	int length = "foo".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"foo(Zork) [in Inner [in ResolveDuplicateMethodDeclaration7 [in ResolveDuplicateMethodDeclaration7.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateMethodDeclaration8() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration7.java");
+	
+	String str = cu.getSource();
+	int start = str.lastIndexOf("foo");
+	int length = "foo".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"foo(Zork)#2 [in Inner [in ResolveDuplicateMethodDeclaration7 [in ResolveDuplicateMethodDeclaration7.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateMethodDeclaration9() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration9.java");
+	
+	String str = cu.getSource();
+	int start = str.indexOf("foo(/*1*/");
+	int length = "foo".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"foo(Zork) [in Inner [in ResolveDuplicateMethodDeclaration9 [in ResolveDuplicateMethodDeclaration9.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateMethodDeclaration10() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration9.java");
+	
+	String str = cu.getSource();
+	int start = str.lastIndexOf("foo(/*1*/");
+	int length = "foo".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"foo(Zork)#2 [in Inner [in ResolveDuplicateMethodDeclaration9 [in ResolveDuplicateMethodDeclaration9.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateMethodDeclaration11() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration11.java");
+	
+	String str = cu.getSource();
+	int start = str.indexOf("foo(/*2*/");
+	int length = "foo".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"foo(Zork) [in Inner#2 [in ResolveDuplicateMethodDeclaration11 [in ResolveDuplicateMethodDeclaration11.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateMethodDeclaration12() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateMethodDeclaration11.java");
+	
+	String str = cu.getSource();
+	int start = str.lastIndexOf("foo(/*2*/");
+	int length = "foo".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"foo(Zork)#2 [in Inner#2 [in ResolveDuplicateMethodDeclaration11 [in ResolveDuplicateMethodDeclaration11.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateFieldDeclaration() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateFieldDeclaration.java");
+	
+	String str = cu.getSource();
+	int start = str.indexOf("var;/*1*/");
+	int length = "var".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"var [in Inner [in ResolveDuplicateFieldDeclaration [in ResolveDuplicateFieldDeclaration.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateFieldDeclaration2() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateFieldDeclaration.java");
+	
+	String str = cu.getSource();
+	int start = str.lastIndexOf("var;/*1*/");
+	int length = "var".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"var#2 [in Inner [in ResolveDuplicateFieldDeclaration [in ResolveDuplicateFieldDeclaration.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateFieldDeclaration3() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateFieldDeclaration3.java");
+	
+	String str = cu.getSource();
+	int start = str.indexOf("var;/*2*/");
+	int length = "var".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"var [in Inner#2 [in ResolveDuplicateFieldDeclaration3 [in ResolveDuplicateFieldDeclaration3.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateFieldDeclaration4() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateFieldDeclaration3.java");
+	
+	String str = cu.getSource();
+	int start = str.lastIndexOf("var;/*2*/");
+	int length = "var".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"var#2 [in Inner#2 [in ResolveDuplicateFieldDeclaration3 [in ResolveDuplicateFieldDeclaration3.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateTypeDeclaration() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateTypeDeclaration.java");
+	
+	String str = cu.getSource();
+	int start = str.indexOf("Inner");
+	int length = "Inner".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"Inner [in ResolveDuplicateTypeDeclaration [in ResolveDuplicateTypeDeclaration.java [in <default> [in src [in Resolve]]]]]",
+			elements
+	);
+}
+public void testDuplicateTypeDeclaration2() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateTypeDeclaration.java");
+	
+	String str = cu.getSource();
+	int start = str.lastIndexOf("Inner");
+	int length = "Inner".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"Inner#2 [in ResolveDuplicateTypeDeclaration [in ResolveDuplicateTypeDeclaration.java [in <default> [in src [in Resolve]]]]]",
+			elements
+	);
+}
+public void testDuplicateTypeDeclaration3() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateTypeDeclaration3.java");
+	
+	String str = cu.getSource();
+	int start = str.indexOf("Inner2/*1*/");
+	int length = "Inner2".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"Inner2 [in Inner [in ResolveDuplicateTypeDeclaration3 [in ResolveDuplicateTypeDeclaration3.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateTypeDeclaration4() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateTypeDeclaration3.java");
+	
+	String str = cu.getSource();
+	int start = str.lastIndexOf("Inner2/*1*/");
+	int length = "Inner2".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"Inner2#2 [in Inner [in ResolveDuplicateTypeDeclaration3 [in ResolveDuplicateTypeDeclaration3.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateTypeDeclaration5() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateTypeDeclaration5.java");
+	
+	String str = cu.getSource();
+	int start = str.indexOf("Inner2/*2*/");
+	int length = "Inner2".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"Inner2 [in Inner#2 [in ResolveDuplicateTypeDeclaration5 [in ResolveDuplicateTypeDeclaration5.java [in <default> [in src [in Resolve]]]]]]",
+			elements
+	);
+}
+public void testDuplicateTypeDeclaration6() throws JavaModelException {
+	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveDuplicateTypeDeclaration5.java");
+	
+	String str = cu.getSource();
+	int start = str.lastIndexOf("Inner2/*2*/");
+	int length = "Inner2".length();
+	IJavaElement[] elements =  cu.codeSelect(start, length);
+	
+	assertElementsEqual(
+			"Unexpected elements",
+			"Inner2#2 [in Inner#2 [in ResolveDuplicateTypeDeclaration5 [in ResolveDuplicateTypeDeclaration5.java [in <default> [in src [in Resolve]]]]]]",
 			elements
 	);
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateFieldDeclaration.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateFieldDeclaration.java
new file mode 100644
index 0000000..2b16e85
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateFieldDeclaration.java
@@ -0,0 +1,10 @@
+public class ResolveDuplicateFieldDeclaration {
+	class Inner {
+		int var;/*1*/
+		int var;/*1*/
+	}
+	class Inner {
+		int var;/*2*/
+		int var;/*2*/
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateFieldDeclaration3.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateFieldDeclaration3.java
new file mode 100644
index 0000000..182c415
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateFieldDeclaration3.java
@@ -0,0 +1,10 @@
+public class ResolveDuplicateFieldDeclaration3 {
+	class Inner {
+		int var;/*1*/
+		int var;/*1*/
+	}
+	class Inner {
+		int var;/*2*/
+		int var;/*2*/
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration.java
new file mode 100644
index 0000000..5b82c89
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration.java
@@ -0,0 +1,4 @@
+public class ResolveDuplicateMethodDeclaration {
+	void foo() {}
+	void foo() {}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration11.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration11.java
new file mode 100644
index 0000000..728c096
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration11.java
@@ -0,0 +1,10 @@
+public class ResolveDuplicateMethodDeclaration11 {
+	class Inner {
+		void foo(/*1*/Zork o) {}
+		void foo(/*1*/Zork o) {}
+	}
+	class Inner {
+		void foo(/*2*/Zork o) {}
+		void foo(/*2*/Zork o) {}
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration3.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration3.java
new file mode 100644
index 0000000..79eecec
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration3.java
@@ -0,0 +1,4 @@
+public class ResolveDuplicateMethodDeclaration3 {
+	void foo(Object o) {}
+	void foo(Object o) {}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration5.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration5.java
new file mode 100644
index 0000000..831ee6c
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration5.java
@@ -0,0 +1,4 @@
+public class ResolveDuplicateMethodDeclaration5 {
+	void foo(Zork o) {}
+	void foo(Zork o) {}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration7.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration7.java
new file mode 100644
index 0000000..d8d5d1f
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration7.java
@@ -0,0 +1,6 @@
+public class ResolveDuplicateMethodDeclaration7 {
+	class Inner {
+		void foo(Zork o) {}
+		void foo(Zork o) {}
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration9.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration9.java
new file mode 100644
index 0000000..3351088
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDeclaration9.java
@@ -0,0 +1,10 @@
+public class ResolveDuplicateMethodDeclaration9 {
+	class Inner {
+		void foo(/*1*/Zork o) {}
+		void foo(/*1*/Zork o) {}
+	}
+	class Inner {
+		void foo(/*2*/Zork o) {}
+		void foo(/*2*/Zork o) {}
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDelcaration.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDelcaration.java
deleted file mode 100644
index 18bb3bc..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateMethodDelcaration.java
+++ /dev/null
@@ -1,4 +0,0 @@
-public class ResolveDuplicateMethodDelcaration {
-	void foo() {}
-	void foo() {}
-}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration.java
new file mode 100644
index 0000000..7235988
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration.java
@@ -0,0 +1,6 @@
+public class ResolveDuplicateTypeDeclaration {
+	class Inner {
+	}
+	class Inner {
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration3.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration3.java
new file mode 100644
index 0000000..4263310
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration3.java
@@ -0,0 +1,10 @@
+public class ResolveDuplicateTypeDeclaration3 {
+	class Inner {
+		class Inner2/*1*/ {}
+		class Inner2/*1*/ {}
+	}
+	class Inner {
+		class Inner2/*2*/ {}
+		class Inner2/*2*/ {}
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration5.java b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration5.java
new file mode 100644
index 0000000..2e1568a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Resolve/src/ResolveDuplicateTypeDeclaration5.java
@@ -0,0 +1,10 @@
+public class ResolveDuplicateTypeDeclaration5 {
+	class Inner {
+		class Inner2/*1*/ {}
+		class Inner2/*1*/ {}
+	}
+	class Inner {
+		class Inner2/*2*/ {}
+		class Inner2/*2*/ {}
+	}
+}
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index 688e463..12f7a7e 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -12,7 +12,7 @@
 
 ### compiler 
 compiler.name = Eclipse Java Compiler
-compiler.version = 0.441
+compiler.version = 0.442
 compiler.copyright = Copyright IBM Corp 2000, 2004. All rights reserved.
 
 ### scanning
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index aa0c1d8..53ad4dc 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -33,6 +33,22 @@
   </tr>
 </table>
 
+<a name="v_442"></a>
+<p><hr><h1>
+Eclipse Platform Build Notes&nbsp;<br>
+Java Development Tooling Core</h1>
+Eclipse SDK 3.0RC3 Build - ?th June 2004
+<br>Project org.eclipse.jdt.core v_442
+(<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_442">cvs</a>).
+<h2>
+What's new in this drop</h2>
+<ul>
+</ul>
+
+<h3>Problem Reports Fixed</h3>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=66271">66271</a>
+No need to resolve type names when selecting declaration
+
 <a name="v_441"></a>
 <p><hr><h1>
 Eclipse Platform Build Notes&nbsp;<br>
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/ISelectionRequestor.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/ISelectionRequestor.java
index 8e86534..59730f2 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/ISelectionRequestor.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/ISelectionRequestor.java
@@ -27,6 +27,15 @@ public interface ISelectionRequestor {
 	 * @param needQualification boolean
 	 * 		Flag indicating if the type name 
 	 *    	must be qualified by its package name (depending on imports).
+	 * 
+	 * @param isDeclaration boolean
+	 *  	Answer if the selected method is a declaration
+	 * 
+	 * @param start
+	 *  	Start of the selection
+	 * 
+	 * @param end
+	 *  	End of the selection
 	 *
 	 * NOTE - All package and type names are presented in their readable form:
 	 *    Package names are in the form "a.b.c".
@@ -36,7 +45,10 @@ public interface ISelectionRequestor {
 	void acceptClass(
 		char[] packageName,
 		char[] className,
-		boolean needQualification);
+		boolean needQualification,
+		boolean isDeclaration,
+		int start,
+		int end);
 
 	/**
 	 * Code assist notification of a compilation error detected during selection.
@@ -62,6 +74,15 @@ public interface ISelectionRequestor {
 	 * 
 	 * @param name char[]
 	 * 		Name of the field.
+	 * 
+	 * @param isDeclaration boolean
+	 *  	Answer if the selected field is a declaration
+	 * 
+	 * @param start
+	 *  	Start of the selection
+	 * 
+	 * @param end
+	 *  	End of the selection
 	 *
 	 * NOTE - All package and type names are presented in their readable form:
 	 *    Package names are in the form "a.b.c".
@@ -71,7 +92,10 @@ public interface ISelectionRequestor {
 	void acceptField(
 		char[] declaringTypePackageName,
 		char[] declaringTypeName,
-		char[] name);
+		char[] name,
+		boolean isDeclaration,
+		int start,
+		int end);
 
 	/**
 	 * Code assist notification of an interface selection.
@@ -84,6 +108,15 @@ public interface ISelectionRequestor {
 	 * @param needQualification boolean
 	 * 		Flag indicating if the type name 
 	 *    	must be qualified by its package name (depending on imports).
+	 * 
+	 * @param isDeclaration boolean
+	 *  	Answer if the selected method is a declaration
+	 * 
+	 * @param start
+	 *  	Start of the selection
+	 * 
+	 * @param end
+	 *  	End of the selection
 	 *
 	 * NOTE - All package and type names are presented in their readable form:
 	 *    Package names are in the form "a.b.c".
@@ -93,7 +126,10 @@ public interface ISelectionRequestor {
 	void acceptInterface(
 		char[] packageName,
 		char[] interfaceName,
-		boolean needQualification);
+		boolean needQualification,
+		boolean isDeclaration,
+		int start,
+		int end);
 
 	/**
 	 * Code assist notification of a method selection.
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
index e79dcca..642504d 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
@@ -162,7 +162,10 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				requestor.acceptClass(
 					packageName,
 					className,
-					false);
+					false,
+					false,
+					this.actualSelectionStart,
+					this.actualSelectionEnd);
 				this.acceptedAnswer = true;
 			}
 		}
@@ -209,7 +212,10 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				this.requestor.acceptInterface(
 					packageName,
 					interfaceName,
-					false);
+					false,
+					false,
+					this.actualSelectionStart,
+					this.actualSelectionEnd);
 				this.acceptedAnswer = true;
 			}
 		}
@@ -235,7 +241,10 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				this.requestor.acceptClass(
 					acceptedClasses[i][0],
 					acceptedClasses[i][1],
-					true);
+					true,
+					false,
+					this.actualSelectionStart,
+					this.actualSelectionEnd);
 			}
 			acceptedClasses = null;
 			acceptedClassesCount = 0;
@@ -247,7 +256,10 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				this.requestor.acceptInterface(
 					acceptedInterfaces[i][0],
 					acceptedInterfaces[i][1],
-					true);
+					true,
+					false,
+					this.actualSelectionStart,
+					this.actualSelectionEnd);
 			}
 			acceptedInterfaces = null;
 			acceptedInterfacesCount = 0;
@@ -492,12 +504,13 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 					}
 				}
 				if (parsedUnit.types != null) {
+					if(selectDeclaration(parsedUnit))
+						return;
 					lookupEnvironment.buildTypeBindings(parsedUnit);
 					if ((this.unitScope = parsedUnit.scope)  != null) {
 						try {
 							lookupEnvironment.completeTypeBindings(parsedUnit, true);
 							parsedUnit.scope.faultInTypes();
-							selectDeclaration(parsedUnit);
 							ASTNode node = parseBlockStatements(parsedUnit, selectionSourceStart);
 							if(DEBUG) {
 								System.out.println("SELECTION - AST :"); //$NON-NLS-1$
@@ -557,7 +570,10 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 					this.requestor.acceptInterface(
 						typeBinding.qualifiedPackageName(),
 						typeBinding.qualifiedSourceName(),
-						false);
+						false,
+						false,
+						this.actualSelectionStart,
+						this.actualSelectionEnd);
 				}
 			} else if(typeBinding instanceof ProblemReferenceBinding){
 				ReferenceBinding original = ((ProblemReferenceBinding) typeBinding).original;
@@ -571,7 +587,10 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 					this.requestor.acceptClass(
 						original.qualifiedPackageName(),
 						original.qualifiedSourceName(),
-						false);
+						false,
+						false,
+						this.actualSelectionStart,
+						this.actualSelectionEnd);
 				}
 			} else {
 				noProposal = false;
@@ -583,7 +602,10 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 					this.requestor.acceptClass(
 						typeBinding.qualifiedPackageName(),
 						typeBinding.qualifiedSourceName(),
-						false);
+						false,
+						false,
+						this.actualSelectionStart,
+						this.actualSelectionEnd);
 				}
 			}
 			this.acceptedAnswer = true;
@@ -643,7 +665,10 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 							this.requestor.acceptField(
 								declaringClass.qualifiedPackageName(),
 								declaringClass.qualifiedSourceName(),
-								fieldBinding.name);
+								fieldBinding.name,
+								false,
+								this.actualSelectionStart,
+								this.actualSelectionEnd);
 						}
 						this.acceptedAnswer = true;
 					}
@@ -858,48 +883,111 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 	}
 
 	// Check if a declaration got selected in this unit
-	private void selectDeclaration(CompilationUnitDeclaration compilationUnit){
+	private boolean selectDeclaration(CompilationUnitDeclaration compilationUnit){
 
 		// the selected identifier is not identical to the parser one (equals but not identical),
 		// for traversing the parse tree, the parser assist identifier is necessary for identitiy checks
 		char[] assistIdentifier = this.getParser().assistIdentifier();
-		if (assistIdentifier == null) return;
+		if (assistIdentifier == null) return false;
 		
+		ImportReference currentPackage = compilationUnit.currentPackage;
+		char[] packageName = currentPackage == null ? new char[0] : CharOperation.concatWith(currentPackage.tokens, '.');
 		// iterate over the types
 		TypeDeclaration[] types = compilationUnit.types;
 		for (int i = 0, length = types == null ? 0 : types.length; i < length; i++){
-			selectDeclaration(types[i], assistIdentifier);
+			if(selectDeclaration(types[i], assistIdentifier, packageName))
+				return true;
 		}
+		return false;
 	}
 
 	// Check if a declaration got selected in this type
-	private void selectDeclaration(TypeDeclaration typeDeclaration, char[] assistIdentifier){
+	private boolean selectDeclaration(TypeDeclaration typeDeclaration, char[] assistIdentifier, char[] packageName){
 	
 		if (typeDeclaration.name == assistIdentifier){
-			throw new SelectionNodeFound(typeDeclaration.binding, true);
+			char[] qualifiedSourceName = null;
+			
+			TypeDeclaration enclosingType = typeDeclaration;
+			while(enclosingType != null) {
+				qualifiedSourceName = CharOperation.concat(enclosingType.name, qualifiedSourceName, '.');
+				enclosingType = enclosingType.enclosingType;
+			}
+			
+			if(!typeDeclaration.isInterface()) {
+				this.requestor.acceptClass(
+					packageName,
+					qualifiedSourceName,
+					false,
+					true,
+					this.actualSelectionStart,
+					this.actualSelectionEnd);
+			} else {
+				this.requestor.acceptInterface(
+					packageName,
+					qualifiedSourceName,
+					false,
+					true,
+					this.actualSelectionStart,
+					this.actualSelectionEnd);
+			}
+			this.noProposal = false;
+			return true;
 		}
 		TypeDeclaration[] memberTypes = typeDeclaration.memberTypes;
 		for (int i = 0, length = memberTypes == null ? 0 : memberTypes.length; i < length; i++){
-			selectDeclaration(memberTypes[i], assistIdentifier);
+			if(selectDeclaration(memberTypes[i], assistIdentifier, packageName))
+				return true;
 		}
 		FieldDeclaration[] fields = typeDeclaration.fields;
 		for (int i = 0, length = fields == null ? 0 : fields.length; i < length; i++){
 			if (fields[i].name == assistIdentifier){
-				throw new SelectionNodeFound(fields[i].binding, true);
+				char[] qualifiedSourceName = null;
+				
+				TypeDeclaration enclosingType = typeDeclaration;
+				while(enclosingType != null) {
+					qualifiedSourceName = CharOperation.concat(enclosingType.name, qualifiedSourceName, '.');
+					enclosingType = enclosingType.enclosingType;
+				}
+				
+				this.requestor.acceptField(
+					packageName,
+					qualifiedSourceName,
+					fields[i].name,
+					true,
+					this.actualSelectionStart,
+					this.actualSelectionEnd);
+
+				this.noProposal = false;
+				return true;
 			}
 		}
 		AbstractMethodDeclaration[] methods = typeDeclaration.methods;
 		for (int i = 0, length = methods == null ? 0 : methods.length; i < length; i++){
 			AbstractMethodDeclaration method = methods[i];
 			if (method.selector == assistIdentifier){
-				if(method.binding != null) {
-					throw new SelectionNodeFound(method.binding, true);
-				} else {
-					if(method.scope != null) {
-						throw new SelectionNodeFound(new MethodBinding(method.modifiers, method.selector, null, null, null, method.scope.referenceType().binding), true);
-					}
+				char[] qualifiedSourceName = null;
+				
+				TypeDeclaration enclosingType = typeDeclaration;
+				while(enclosingType != null) {
+					qualifiedSourceName = CharOperation.concat(enclosingType.name, qualifiedSourceName, '.');
+					enclosingType = enclosingType.enclosingType;
 				}
+				
+				this.requestor.acceptMethod(
+					packageName,
+					qualifiedSourceName,
+					method.selector,
+					null, // SelectionRequestor does not need of parameters type for method declaration
+					null, // SelectionRequestor does not need of parameters type for method declaration
+					method.isConstructor(),
+					true,
+					this.actualSelectionStart,
+					this.actualSelectionEnd);
+				
+				this.noProposal = false;
+				return true;
 			}
 		}
+		return false;
 	}
 }
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
index d007842..f113447 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetToCuMapper.java
@@ -271,8 +271,8 @@ public char[] getImport(int lineNumber) {
  */
 public ISelectionRequestor getSelectionRequestor(final ISelectionRequestor originalRequestor) {
 	return new ISelectionRequestor() {
-		public void acceptClass(char[] packageName, char[] className, boolean needQualification) {
-			originalRequestor.acceptClass(packageName, className, needQualification);
+		public void acceptClass(char[] packageName, char[] className, boolean needQualification, boolean isDeclaration, int start, int end) {
+			originalRequestor.acceptClass(packageName, className, needQualification, isDeclaration, start, end);
 		}
 		public void acceptError(IProblem error) {
 			error.setSourceLineNumber(error.getSourceLineNumber() -  CodeSnippetToCuMapper.this.lineNumberOffset);
@@ -280,11 +280,11 @@ public ISelectionRequestor getSelectionRequestor(final ISelectionRequestor origi
 			error.setSourceEnd(error.getSourceEnd() - CodeSnippetToCuMapper.this.startPosOffset);
 			originalRequestor.acceptError(error);
 		}
-		public void acceptField(char[] declaringTypePackageName, char[] declaringTypeName, char[] name) {
-			originalRequestor.acceptField(declaringTypePackageName, declaringTypeName, name);
+		public void acceptField(char[] declaringTypePackageName, char[] declaringTypeName, char[] name, boolean isDeclaration, int start, int end) {
+			originalRequestor.acceptField(declaringTypePackageName, declaringTypeName, name, isDeclaration, start, end);
 		}
-		public void acceptInterface(char[] packageName, char[] interfaceName, boolean needQualification) {
-			originalRequestor.acceptInterface(packageName, interfaceName, needQualification);
+		public void acceptInterface(char[] packageName, char[] interfaceName, boolean needQualification, boolean isDeclaration, int start, int end) {
+			originalRequestor.acceptInterface(packageName, interfaceName, needQualification, isDeclaration, start, end);
 		}
 		public void acceptMethod(char[] declaringTypePackageName, char[] declaringTypeName, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames, boolean isConstructor, boolean isDeclaration, int start, int end) {
 			originalRequestor.acceptMethod(declaringTypePackageName, declaringTypeName, selector, parameterPackageNames, parameterTypeNames, isConstructor, isDeclaration, start, end);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
index e701cc1..93a3d5f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
@@ -99,8 +99,8 @@ protected void acceptBinaryMethod(IType type, char[] selector, char[][] paramete
 /**
  * Resolve the class.
  */
-public void acceptClass(char[] packageName, char[] className, boolean needQualification) {
-	acceptType(packageName, className, NameLookup.ACCEPT_CLASSES, needQualification);
+public void acceptClass(char[] packageName, char[] className, boolean needQualification, boolean isDeclaration, int start, int end) {
+	acceptType(packageName, className, NameLookup.ACCEPT_CLASSES, needQualification, isDeclaration, start, end);
 }
 /**
  * @see ISelectionRequestor#acceptError
@@ -111,17 +111,45 @@ public void acceptError(IProblem error) {
 /**
  * Resolve the field.
  */
-public void acceptField(char[] declaringTypePackageName, char[] declaringTypeName, char[] name) {
-	IType type= resolveType(declaringTypePackageName, declaringTypeName,
-		NameLookup.ACCEPT_CLASSES | NameLookup.ACCEPT_INTERFACES);
-	if (type != null) {
-		IField field= type.getField(new String(name));
-		if (field.exists()) {
-			addElement(field);
-			if(SelectionEngine.DEBUG){
-				System.out.print("SELECTION - accept field("); //$NON-NLS-1$
-				System.out.print(field.toString());
-				System.out.println(")"); //$NON-NLS-1$
+public void acceptField(char[] declaringTypePackageName, char[] declaringTypeName, char[] name, boolean isDeclaration, int start, int end) {
+	if(isDeclaration) {
+		IType type= resolveTypeByLocation(declaringTypePackageName, declaringTypeName,
+				NameLookup.ACCEPT_CLASSES | NameLookup.ACCEPT_INTERFACES,
+				start, end);
+		if(type != null) {
+			try {
+				IField[] fields = type.getFields();
+				for (int i = 0; i < fields.length; i++) {
+					IField field = fields[i];
+					ISourceRange range = field.getNameRange();
+					if(range.getOffset() <= start
+							&& range.getOffset() + range.getLength() >= end
+							&& field.getElementName().equals(new String(name))) {
+						addElement(fields[i]);
+						if(SelectionEngine.DEBUG){
+							System.out.print("SELECTION - accept field("); //$NON-NLS-1$
+							System.out.print(field.toString());
+							System.out.println(")"); //$NON-NLS-1$
+						}
+						return; // only one method is possible
+					}
+				}
+			} catch (JavaModelException e) {
+				return; 
+			}
+		}
+	} else {
+		IType type= resolveType(declaringTypePackageName, declaringTypeName,
+				NameLookup.ACCEPT_CLASSES | NameLookup.ACCEPT_INTERFACES);
+		if (type != null) {
+			IField field= type.getField(new String(name));
+			if (field.exists()) {
+				addElement(field);
+				if(SelectionEngine.DEBUG){
+					System.out.print("SELECTION - accept field("); //$NON-NLS-1$
+					System.out.print(field.toString());
+					System.out.println(")"); //$NON-NLS-1$
+				}
 			}
 		}
 	}
@@ -129,8 +157,8 @@ public void acceptField(char[] declaringTypePackageName, char[] declaringTypeNam
 /**
  * Resolve the interface
  */
-public void acceptInterface(char[] packageName, char[] interfaceName, boolean needQualification) {
-	acceptType(packageName, interfaceName, NameLookup.ACCEPT_INTERFACES, needQualification);
+public void acceptInterface(char[] packageName, char[] interfaceName, boolean needQualification, boolean isDeclaration, int start, int end) {
+	acceptType(packageName, interfaceName, NameLookup.ACCEPT_INTERFACES, needQualification, isDeclaration, start, end);
 }
 public void acceptLocalField(SourceTypeBinding typeBinding, char[] name, CompilationUnitDeclaration parsedUnit) {
 	IType type = (IType)this.handleFactory.createElement(typeBinding.scope.referenceContext, parsedUnit, this.openable);
@@ -173,7 +201,7 @@ public void acceptLocalMethod(SourceTypeBinding typeBinding, char[] selector, ch
 			
 			acceptBinaryMethod(type, selector, parameterPackageNames, parameterTypeNames);
 		} else {
-			acceptSourceMethod(type, selector, parameterPackageNames, parameterTypeNames, isDeclaration, start, end);
+			acceptSourceMethod(type, selector, parameterPackageNames, parameterTypeNames);
 		}
 	}
 }
@@ -203,34 +231,44 @@ public void acceptLocalVariable(LocalVariableBinding binding, CompilationUnitDec
  * Resolve the method
  */
 public void acceptMethod(char[] declaringTypePackageName, char[] declaringTypeName, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames, boolean isConstructor, boolean isDeclaration, int start, int end) {
-	IType type= resolveType(declaringTypePackageName, declaringTypeName,
-		NameLookup.ACCEPT_CLASSES | NameLookup.ACCEPT_INTERFACES);
-	// fix for 1FWFT6Q
-	if (type != null) {
-		if (type.isBinary()) {
-			
-			// need to add a paramater for constructor in binary type
-			IType declaringDeclaringType = type.getDeclaringType();
-			
-			boolean isStatic = false;
-			try {
-				isStatic = Flags.isStatic(type.getFlags());
-			} catch (JavaModelException e) {
-				// isStatic == false
-			}
-			
-			if(declaringDeclaringType != null && isConstructor	&& !isStatic) {
-				int length = parameterPackageNames.length;
-				System.arraycopy(parameterPackageNames, 0, parameterPackageNames = new char[length+1][], 1, length);
-				System.arraycopy(parameterTypeNames, 0, parameterTypeNames = new char[length+1][], 1, length);
+	if(isDeclaration) {
+		IType type = resolveTypeByLocation(declaringTypePackageName, declaringTypeName,
+				NameLookup.ACCEPT_CLASSES | NameLookup.ACCEPT_INTERFACES,
+				start, end);
+		
+		if(type != null) {
+			this.acceptMethodDeclaration(type, selector, start, end);
+		}
+	} else {
+		IType type = resolveType(declaringTypePackageName, declaringTypeName,
+			NameLookup.ACCEPT_CLASSES | NameLookup.ACCEPT_INTERFACES);
+		// fix for 1FWFT6Q
+		if (type != null) {
+			if (type.isBinary()) {
 				
-				parameterPackageNames[0] = declaringDeclaringType.getPackageFragment().getElementName().toCharArray();
-				parameterTypeNames[0] = declaringDeclaringType.getTypeQualifiedName().toCharArray();
+				// need to add a paramater for constructor in binary type
+				IType declaringDeclaringType = type.getDeclaringType();
+				
+				boolean isStatic = false;
+				try {
+					isStatic = Flags.isStatic(type.getFlags());
+				} catch (JavaModelException e) {
+					// isStatic == false
+				}
+				
+				if(declaringDeclaringType != null && isConstructor	&& !isStatic) {
+					int length = parameterPackageNames.length;
+					System.arraycopy(parameterPackageNames, 0, parameterPackageNames = new char[length+1][], 1, length);
+					System.arraycopy(parameterTypeNames, 0, parameterTypeNames = new char[length+1][], 1, length);
+					
+					parameterPackageNames[0] = declaringDeclaringType.getPackageFragment().getElementName().toCharArray();
+					parameterTypeNames[0] = declaringDeclaringType.getTypeQualifiedName().toCharArray();
+				}
+				
+				acceptBinaryMethod(type, selector, parameterPackageNames, parameterTypeNames);
+			} else {
+				acceptSourceMethod(type, selector, parameterPackageNames, parameterTypeNames);
 			}
-			
-			acceptBinaryMethod(type, selector, parameterPackageNames, parameterTypeNames);
-		} else {
-			acceptSourceMethod(type, selector, parameterPackageNames, parameterTypeNames, isDeclaration, start, end);
 		}
 	}
 }
@@ -255,21 +293,15 @@ public void acceptPackage(char[] packageName) {
  *
  * fix for 1FWFT6Q
  */
-protected void acceptSourceMethod(IType type, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames, boolean isDeclaration, int start, int end) {
+protected void acceptSourceMethod(IType type, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames) {
 	String name = new String(selector);
 	IMethod[] methods = null;
 	try {
 		methods = type.getMethods();
 		for (int i = 0; i < methods.length; i++) {
-			if (methods[i].getElementName().equals(name) && methods[i].getParameterTypes().length == parameterTypeNames.length) {
-				if(isDeclaration) {
-					ISourceRange range = methods[i].getNameRange();
-					if(range.getOffset() <= start && range.getOffset() + range.getLength() >= end) {
-						addElement(methods[i]);
-					}
-				} else {
-					addElement(methods[i]);
-				}
+			if (methods[i].getElementName().equals(name)
+					&& methods[i].getParameterTypes().length == parameterTypeNames.length) {
+				addElement(methods[i]);
 			}
 		}
 	} catch (JavaModelException e) {
@@ -326,11 +358,49 @@ protected void acceptSourceMethod(IType type, char[] selector, char[][] paramete
 	}
 	
 }
+protected void acceptMethodDeclaration(IType type, char[] selector, int start, int end) {
+	String name = new String(selector);
+	IMethod[] methods = null;
+	try {
+		methods = type.getMethods();
+		for (int i = 0; i < methods.length; i++) {
+			ISourceRange range = methods[i].getNameRange();
+			if(range.getOffset() <= start
+					&& range.getOffset() + range.getLength() >= end
+					&& methods[i].getElementName().equals(name)) {
+				addElement(methods[i]);
+				if(SelectionEngine.DEBUG){
+					System.out.print("SELECTION - accept method("); //$NON-NLS-1$
+					System.out.print(this.elements[0].toString());
+					System.out.println(")"); //$NON-NLS-1$
+				}
+				return; // only one method is possible
+			}
+		}
+	} catch (JavaModelException e) {
+		return; 
+	}
+
+	// no match was actually found
+	addElement(type);
+	if(SelectionEngine.DEBUG){
+		System.out.print("SELECTION - accept type("); //$NON-NLS-1$
+		System.out.print(type.toString());
+		System.out.println(")"); //$NON-NLS-1$
+	}
+	return;
+}
 /**
  * Resolve the type, adding to the resolved elements.
  */
-protected void acceptType(char[] packageName, char[] typeName, int acceptFlags, boolean needQualification) {
-	IType type= resolveType(packageName, typeName, acceptFlags);
+protected void acceptType(char[] packageName, char[] typeName, int acceptFlags, boolean needQualification, boolean isDeclaration, int start, int end) {
+	IType type = null;
+	if(isDeclaration) {
+		type = resolveTypeByLocation(packageName, typeName, acceptFlags, start, end);
+	} else {
+		type = resolveType(packageName, typeName, acceptFlags);
+	}
+	
 	if (type != null) {
 		addElement(type);
 		if(SelectionEngine.DEBUG){
@@ -339,7 +409,6 @@ protected void acceptType(char[] packageName, char[] typeName, int acceptFlags,
 			System.out.println(")"); //$NON-NLS-1$
 		}
 	} 
-	
 }
 /*
  * Adds the given element to the list of resolved elements.
@@ -427,4 +496,84 @@ protected IType resolveType(char[] packageName, char[] typeName, int acceptFlags
 	}
 	return type;
 }
+protected IType resolveTypeByLocation(char[] packageName, char[] typeName, int acceptFlags, int start, int end) {
+
+	IType type= null;
+	
+	// TODO (david) post 3.0 should remove isOpen check, and investigate reusing ICompilationUnit#getElementAt. may need to optimize #getElementAt to remove recursions
+	if (this.openable instanceof CompilationUnit && ((CompilationUnit)this.openable).isOpen()) {
+		CompilationUnit wc = (CompilationUnit) this.openable;
+		try {
+			if(((packageName == null || packageName.length == 0) && wc.getPackageDeclarations().length == 0) ||
+				(!(packageName == null || packageName.length == 0) && wc.getPackageDeclaration(new String(packageName)).exists())) {
+					
+				char[][] compoundName = CharOperation.splitOn('.', typeName);
+				if(compoundName.length > 0) {
+					
+					IType[] tTypes = wc.getTypes();
+					int i = 0;
+					int depth = 0;
+					done : while(i < tTypes.length) {
+						ISourceRange range = tTypes[i].getSourceRange();
+						if(range.getOffset() <= start
+								&& range.getOffset() + range.getLength() >= end
+								&& tTypes[i].getElementName().equals(new String(compoundName[depth]))) {
+							if(depth == compoundName.length - 1) {
+								type = tTypes[i];
+								break done;
+							}
+							tTypes = tTypes[i].getTypes();
+							i = 0;
+							depth++;
+							continue done;
+						}
+						i++;
+					}
+				}
+				
+				if(type != null && !type.exists()) {
+					type = null;
+				}
+			}
+		}catch (JavaModelException e) {
+			type = null;
+		}
+	}
+
+	if(type == null) {
+		IPackageFragment[] pkgs = this.nameLookup.findPackageFragments(
+			(packageName == null || packageName.length == 0) ? IPackageFragment.DEFAULT_PACKAGE_NAME : new String(packageName), 
+			false);
+		// iterate type lookup in each package fragment
+		for (int i = 0, length = pkgs == null ? 0 : pkgs.length; i < length; i++) {
+			type= this.nameLookup.findType(new String(typeName), pkgs[i], false, acceptFlags);
+			if (type != null) break;	
+		}
+		if (type == null) {
+			String pName= IPackageFragment.DEFAULT_PACKAGE_NAME;
+			if (packageName != null) {
+				pName = new String(packageName);
+			}
+			if (this.openable != null && this.openable.getParent().getElementName().equals(pName)) {
+				// look inside the type in which we are resolving in
+				String tName= new String(typeName);
+				tName = tName.replace('.','$');
+				IType[] allTypes= null;
+				try {
+					ArrayList list = this.openable.getChildrenOfType(IJavaElement.TYPE);
+					allTypes = new IType[list.size()];
+					list.toArray(allTypes);
+				} catch (JavaModelException e) {
+					return null;
+				}
+				for (int i= 0; i < allTypes.length; i++) {
+					if (allTypes[i].getTypeQualifiedName().equals(tName)) {
+						return allTypes[i];
+					}
+				}
+			}
+		}
+	}
+	return type;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
index 24b6fb7..b5d443f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
@@ -718,18 +718,18 @@ public String[][] resolveType(String typeName, WorkingCopyOwner owner) throws Ja
 				this.answers[length] = answer;
 			}
 		}
-		public void acceptClass(char[] packageName, char[] className, boolean needQualification) {
+		public void acceptClass(char[] packageName, char[] className, boolean needQualification, boolean isDeclaration, int start, int end) {
 			acceptType(new String[]  { new String(packageName), new String(className) });
 		}
 		
-		public void acceptInterface(char[] packageName, char[] interfaceName, boolean needQualification) {
+		public void acceptInterface(char[] packageName, char[] interfaceName, boolean needQualification, boolean isDeclaration, int start, int end) {
 			acceptType(new String[]  { new String(packageName), new String(interfaceName) });
 		}
 
 		public void acceptError(IProblem error) {
 			// ignore
 		}
-		public void acceptField(char[] declaringTypePackageName, char[] declaringTypeName, char[] fieldName) {
+		public void acceptField(char[] declaringTypePackageName, char[] declaringTypeName, char[] fieldName, boolean isDeclaration, int start, int end) {
 			// ignore
 		}
 		public void acceptMethod(char[] declaringTypePackageName, char[] declaringTypeName, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames, boolean isConstructor, boolean isDeclaration, int start, int end) {
