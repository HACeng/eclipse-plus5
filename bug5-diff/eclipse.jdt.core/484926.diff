commit 265a71c883de0f578a309877285f7e93b41a8fcf
Author: Till Brychcy <register.eclipse@brychcy.de>
Date:   Sat Aug 13 10:37:39 2016 +0200

    Bug 484926 - [1.8][null] implement @NonNullByDefault for FIELD and
    LOCAL_VARIABLE
    
    Change-Id: I27189c4b4da86c31825f5cc2ed8b60ad65f7d00e
    Also-by: Stephan Herrmann <stephan.herrmann@berlin.de>

5	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
538	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
19	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
102	23	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
10	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
2	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
25	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
20	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
15	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
27	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
112	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
13	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 4c28907..1d93cb4 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2016 IBM Corporation and others.
+ * Copyright (c) 2006, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -937,6 +937,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotationPackage", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotationType", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotationMethod", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
+		expectedProblemAttributes.put("RedundantNullDefaultAnnotationLocal", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
+		expectedProblemAttributes.put("RedundantNullDefaultAnnotationField", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("RedundantSuperinterface", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("ReferenceExpressionParameterNullityMismatch", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ReferenceExpressionParameterNullityUnchecked", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -1776,6 +1778,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotationPackage", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotationType", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
 		expectedProblemAttributes.put("RedundantNullDefaultAnnotationMethod", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
+		expectedProblemAttributes.put("RedundantNullDefaultAnnotationLocal", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
+		expectedProblemAttributes.put("RedundantNullDefaultAnnotationField", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
 		expectedProblemAttributes.put("RedundantSuperinterface", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_SUPERINTERFACE));
 		expectedProblemAttributes.put("ReferenceExpressionParameterNullityMismatch", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("ReferenceExpressionParameterNullityUnchecked", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 65b3627..5540811 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012, 2016 GK Software AG and others.
+ * Copyright (c) 2012, 2017 GK Software AG and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -13139,6 +13139,543 @@ public void testBug502112b() {
 		"----------\n"
 	);
 }
+public void testBug484926locals() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/NNBDOnLocalOrField.java",
+			"package test;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"\n" +
+			"class AtomicReference<T> {\n" +
+			"\n" +
+			"	public void set(T object) {\n" +
+			"	}\n" +
+			"\n" +
+			"}\n" +
+			"\n" +
+			"@NonNullByDefault\n" +
+			"public class NNBDOnLocalOrField {\n" +
+			"	void someMethod() {\n" +
+			"		AtomicReference<String> x1 = new AtomicReference<>();\n" +
+			"		AtomicReference<String> x2 = new AtomicReference<@NonNull String>(), x3=new AtomicReference<@Nullable String>();\n" +
+			"		@NonNullByDefault({})\n" +
+			"		AtomicReference<String> y1 = new AtomicReference<>();\n" +
+			"		@NonNullByDefault({})\n" +
+			"		AtomicReference<String> y2 = new AtomicReference<@NonNull String>(), y3=new AtomicReference<@Nullable String>();\n" +
+			"		x1.set(null);\n" +
+			"		x2.set(null);\n" +
+			"		x3.set(null);\n" +
+			"		y1.set(null);\n" +
+			"		y2.set(null);\n" +
+			"		y3.set(null);\n" +
+			"	}\n" +
+			"}\n" 
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\NNBDOnLocalOrField.java (at line 16)\n" + 
+		"	AtomicReference<String> x2 = new AtomicReference<@NonNull String>(), x3=new AtomicReference<@Nullable String>();\n" + 
+		"	                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'AtomicReference<@NonNull String>\' but this expression has type \'AtomicReference<@Nullable String>\'\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\NNBDOnLocalOrField.java (at line 21)\n" + 
+		"	x1.set(null);\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+		"----------\n" + 
+		"3. ERROR in test\\NNBDOnLocalOrField.java (at line 22)\n" + 
+		"	x2.set(null);\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+		"----------\n" + 
+		"4. ERROR in test\\NNBDOnLocalOrField.java (at line 23)\n" + 
+		"	x3.set(null);\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+		"----------\n"
+	);
+}
+public void testBug484926fields() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/NNBDOnLocalOrField.java",
+			"package test;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"\n" +
+			"class AtomicReference<T> {\n" +
+			"\n" +
+			"	public void set(T object) {\n" +
+			"	}\n" +
+			"\n" +
+			"}\n" +
+			"\n" +
+			"@NonNullByDefault\n" +
+			"public class NNBDOnLocalOrField {\n" +
+			"	AtomicReference<String> x1 = new AtomicReference<>();\n" +
+			"	AtomicReference<String> x2 = new AtomicReference<@NonNull String>(), x3=new AtomicReference<@Nullable String>();\n" +
+			"	@NonNullByDefault({})\n" +
+			"	AtomicReference<String> y1 = new AtomicReference<>();\n" +
+			"	@NonNullByDefault({})\n" +
+			"	AtomicReference<String> y2 = new AtomicReference<@NonNull String>(), y3=new AtomicReference<@Nullable String>();\n" +
+			"	void someMethod() {\n" +
+			"		x1.set(null);\n" +
+			"		x2.set(null);\n" +
+			"		x3.set(null);\n" +
+			"		y1.set(null);\n" +
+			"		y2.set(null);\n" +
+			"		y3.set(null);\n" +
+			"	}\n" +
+			"}\n" 
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\NNBDOnLocalOrField.java (at line 15)\n" + 
+		"	AtomicReference<String> x2 = new AtomicReference<@NonNull String>(), x3=new AtomicReference<@Nullable String>();\n" + 
+		"	                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@NonNull AtomicReference<@NonNull String>\' but this expression has type \'AtomicReference<@Nullable String>\'\n" + 
+		"----------\n" + 
+		"2. ERROR in test\\NNBDOnLocalOrField.java (at line 21)\n" + 
+		"	x1.set(null);\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+		"----------\n" + 
+		"3. ERROR in test\\NNBDOnLocalOrField.java (at line 22)\n" + 
+		"	x2.set(null);\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+		"----------\n" + 
+		"4. ERROR in test\\NNBDOnLocalOrField.java (at line 23)\n" + 
+		"	x3.set(null);\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+		"----------\n"
+	);
+}
+public void testBug484926() {
+	runConformTestWithLibs(
+		new String[] {
+			"test/NNBDOnLocalOrField.java",
+			"package test;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"\n" +
+			"class AtomicReference<T> {\n" +
+			"\n" +
+			"	public void set(T object) {\n" +
+			"	}\n" +
+			"\n" +
+			"}\n" +
+			"\n" +
+			"@NonNullByDefault\n" +
+			"public class NNBDOnLocalOrField {\n" +
+			"	@NonNullByDefault({})\n" +
+			"	AtomicReference<String> f = new AtomicReference<>();\n" +
+			"\n" +
+			"	{\n" +
+			"		f.set(null);\n" +
+			"	}\n" +
+			"\n" +
+			"	@NonNullByDefault({})\n" +
+			"	Runnable r = () -> {\n" +
+			"		AtomicReference<String> x1 = new AtomicReference<>();\n" +
+			"		x1.set(null);\n" +
+			"	};\n" +
+			"\n" +
+			"	Object someMethod() {\n" +
+			"		@NonNullByDefault({})\n" +
+			"		AtomicReference<String> x2 = new AtomicReference<>();\n" +
+			"		x2.set(null);\n" +
+			"\n" +
+			"		@NonNullByDefault({})\n" +
+			"		Runnable r1 = () -> {\n" +
+			"			AtomicReference<String> x3 = new AtomicReference<>();\n" +
+			"			x3.set(null);\n" +
+			"		};\n" +
+			"		\n" +
+			"		return r1;\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+}
+public void testBug484926nesting() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"test/NNBDOnLocalOrField.java",
+			"package test;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"\n" +
+			"class AtomicReference<T> {\n" +
+			"\n" +
+			"	public void set(T object) {\n" +
+			"	}\n" +
+			"\n" +
+			"}\n" +
+			"\n" +
+			"public class NNBDOnLocalOrField {\n" +
+			"	@NonNullByDefault()\n" +
+			"	Runnable r = () -> {\n" +
+			"		@NonNullByDefault({})\n" +
+			"		AtomicReference<String> x1 = new AtomicReference<>();\n" +
+			"		x1.set(null);\n" +
+			"	};\n" +
+			"	@NonNullByDefault\n" +
+			"	Object someMethod() {\n" +
+			"		@NonNullByDefault({})\n" +
+			"		AtomicReference<String> x2 = new AtomicReference<>();\n" +
+			"		x2.set(null);\n" +
+			"\n" +
+			"		@NonNullByDefault({})\n" +
+			"		Runnable r1 = () -> {\n" +
+			"			@NonNullByDefault\n" +
+			"			AtomicReference<String> x3 = new AtomicReference<>();\n" +
+			"			x3.set(null);\n" +
+			"		};\n" +
+			"		\n" +
+			"		return r1;\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in test\\NNBDOnLocalOrField.java (at line 29)\n" + 
+		"	x3.set(null);\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+		"----------\n"
+	);
+}
+public void testBug484926localDeclarationInForLoop() {
+	runConformTestWithLibs(
+		new String[] {
+			"test/NNBDOnLocalOrField.java",
+			"package test;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"\n" +
+			"class AtomicReference<T> {\n" +
+			"\n" +
+			"	public void set(T object) {\n" +
+			"	}\n" +
+			"\n" +
+			"}\n" +
+			"\n" +
+			"@NonNullByDefault\n" +
+			"public class NNBDOnLocalOrField {\n" +
+			"	void someMethod() {\n" +
+			"		for(@NonNullByDefault({})\n" +
+			"		Runnable r1 = () -> {\n" +
+			"			AtomicReference<String> x3 = new AtomicReference<>();\n" +
+			"			x3.set(null);\n" +
+			"		}, r2 = () -> {\n" +
+			"			AtomicReference<String> x4 = new AtomicReference<>();\n" +
+			"			x4.set(null);\n" +
+			"		};;) {\n" +
+			"			r1.run();\n" +
+			"			r2.run();\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+}
+public void testBug484926redundantNNBD() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"testnnbd/NNBDRedundantOnLocalOrField.java",
+			"package testnnbd;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.DefaultLocation;\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"\n" +
+			"@NonNullByDefault({})\n" +
+			"class AtomicReference<T> {\n" +
+			"	public void set(T object) {\n" +
+			"	}\n" +
+			"}\n" +
+			"\n" +
+			"public class NNBDRedundantOnLocalOrField {\n" +
+			"	@NonNullByDefault\n" +
+			"	Runnable r1 = () -> {\n" +
+			"		@NonNullByDefault\n" +
+			"		AtomicReference<String> x3 = new AtomicReference<>();\n" +
+			"		x3.set(null);\n" +
+			"	}, r2 = () -> {\n" +
+			"		@NonNullByDefault({})\n" +
+			"		AtomicReference<String> x4 = new AtomicReference<String>() {\n" +
+			"			@NonNullByDefault({})\n" +
+			"			public void set(String object) {\n" +
+			"			}\n" +
+			"		};\n" +
+			"		x4.set(null);\n" +
+			"	};\n" +
+			"\n" +
+			"	@NonNullByDefault\n" +
+			"	class X1 {\n" +
+			"		@NonNullByDefault\n" +
+			"		Runnable r = () -> {\n" +
+			"			@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"			class Local extends AtomicReference<String> {\n" +
+			"				@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"				class X2 {\n" +
+			"					@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"					String s;\n" +
+			"					\n" +
+			"					{\n" +
+			"						set(null);\n" +
+			"					}\n" +
+			"				}\n" +
+			"				{\n" +
+			"				new X2().hashCode();\n" +
+			"				}\n" +
+			"			}\n" +
+			"			Local x1 = new Local();\n" +
+			"			x1.set(null);\n" +
+			"		};\n" +
+			"	}\n" +
+			"\n" +
+			"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"	Object someMethod() {\n" +
+			"		@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"		AtomicReference<String> x2 = new AtomicReference<>();\n" +
+			"		x2.set(null);\n" +
+			"\n" +
+			"		@NonNullByDefault({})\n" +
+			"		Runnable r = () -> {\n" +
+			"			@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"			AtomicReference<String> x3 = new AtomicReference<>();\n" +
+			"			x3.set(null);\n" +
+			"		};\n" +
+			"\n" +
+			"		@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"		Runnable r2 = new Runnable() {\n" +
+			"			@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"			@Override\n" +
+			"			public void run() {\n" +
+			"			}\n" +
+			"		};\n" +
+			"\n" +
+			"		r2.run();\n" +
+			"		return r;\n" +
+			"	}\n" +
+			"\n" +
+			"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"	void forLoopVariable() {\n" +
+			"		{\n" +
+			"			@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"			Runnable r = () -> {\n" +
+			"				AtomicReference<String> x3 = new AtomicReference<>();\n" +
+			"				x3.set(null);\n" +
+			"			}, r2 = () -> {\n" +
+			"				AtomicReference<String> x4 = new AtomicReference<>();\n" +
+			"				x4.set(null);\n" +
+			"			};\n" +
+			"			r.run();\n" +
+			"			r2.run();\n" +
+			"		}\n" +
+			"		for (@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"		Runnable r = () -> {\n" +
+			"			@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"			AtomicReference<String> x3 = new AtomicReference<>();\n" +
+			"			x3.set(null);\n" +
+			"		}, r2 = () -> {\n" +
+			"			@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" +
+			"			AtomicReference<String> x4 = new AtomicReference<>();\n" +
+			"			x4.set(null);\n" +
+			"		};;) {\n" +
+			"			r.run();\n" +
+			"			r2.run();\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+			"testnnbd/package-info.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"package testnnbd;\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 13)\n" + 
+		"	@NonNullByDefault\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing package testnnbd\n" + 
+		"----------\n" + 
+		"2. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 15)\n" + 
+		"	@NonNullByDefault\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the field r1\n" + 
+		"----------\n" + 
+		"3. ERROR in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 17)\n" + 
+		"	x3.set(null);\n" + 
+		"	       ^^^^\n" + 
+		"Null type mismatch: required \'@NonNull String\' but the provided value is null\n" + 
+		"----------\n" + 
+		"4. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 21)\n" + 
+		"	@NonNullByDefault({})\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the variable x4\n" + 
+		"----------\n" + 
+		"5. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 22)\n" + 
+		"	public void set(String object) {\n" + 
+		"	            ^^^^^^^^^^^^^^^^^^\n" + 
+		"The method set(String) of type new AtomicReference<String>(){} should be tagged with @Override since it actually overrides a superclass method\n" + 
+		"----------\n" + 
+		"6. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 28)\n" + 
+		"	@NonNullByDefault\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing package testnnbd\n" + 
+		"----------\n" + 
+		"7. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 30)\n" + 
+		"	@NonNullByDefault\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing type NNBDRedundantOnLocalOrField.X1\n" + 
+		"----------\n" + 
+		"8. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 34)\n" + 
+		"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing type Local\n" + 
+		"----------\n" + 
+		"9. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 36)\n" + 
+		"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing type Local.X2\n" + 
+		"----------\n" + 
+		"10. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 37)\n" + 
+		"	String s;\n" + 
+		"	       ^\n" + 
+		"The value of the field Local.X2.s is not used\n" + 
+		"----------\n" + 
+		"11. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 54)\n" + 
+		"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing method someMethod()\n" + 
+		"----------\n" + 
+		"12. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 65)\n" + 
+		"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing method someMethod()\n" + 
+		"----------\n" + 
+		"13. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 66)\n" + 
+		"	Runnable r2 = new Runnable() {\n" + 
+		"	         ^^\n" + 
+		"The local variable r2 is hiding a field from type NNBDRedundantOnLocalOrField\n" + 
+		"----------\n" + 
+		"14. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 67)\n" + 
+		"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the variable r2\n" + 
+		"----------\n" + 
+		"15. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 80)\n" + 
+		"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing method forLoopVariable()\n" + 
+		"----------\n" + 
+		"16. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 84)\n" + 
+		"	}, r2 = () -> {\n" + 
+		"	   ^^\n" + 
+		"The local variable r2 is hiding a field from type NNBDRedundantOnLocalOrField\n" + 
+		"----------\n" + 
+		"17. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 91)\n" + 
+		"	for (@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" + 
+		"	     ^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing method forLoopVariable()\n" + 
+		"----------\n" + 
+		"18. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 91)\n" + 
+		"	for (@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" + 
+		"	     ^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing method forLoopVariable()\n" + 
+		"----------\n" + 
+		"19. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 93)\n" + 
+		"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the variable r\n" + 
+		"----------\n" + 
+		"20. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 96)\n" + 
+		"	}, r2 = () -> {\n" + 
+		"	   ^^\n" + 
+		"The local variable r2 is hiding a field from type NNBDRedundantOnLocalOrField\n" + 
+		"----------\n" + 
+		"21. WARNING in testnnbd\\NNBDRedundantOnLocalOrField.java (at line 97)\n" + 
+		"	@NonNullByDefault(DefaultLocation.RETURN_TYPE)\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the variable r2\n" + 
+		"----------\n"
+	);
+}
+public void testBug484926BTB() {
+	runConformTestWithLibs(
+		new String[] {
+			"test/ClassWithNNBDOnField.java",
+			"package test;\n" +
+			"\n" +
+			"import org.eclipse.jdt.annotation.NonNullByDefault;\n" +
+			"\n" +
+			"class AtomicReference<T> {\n" +
+			"	public void set(T object) {\n" +
+			"	}\n" +
+			"}\n" +
+			"\n" +
+			"@NonNullByDefault()\n" +
+			"public class ClassWithNNBDOnField {\n" +
+			"	@NonNullByDefault({})\n" +
+			"	AtomicReference<String> f = new AtomicReference<>();\n" +
+			"	{\n" +
+			"		f.set(null);\n" +
+			"	}\n" +
+			"\n" +
+			"	public static class X {\n" +
+			"		@NonNullByDefault({})\n" +
+			"		AtomicReference<String> nested = new AtomicReference<>();\n" +
+			"		{\n" +
+			"			nested.set(null);\n" +
+			"		}\n" +
+			"	}\n" +
+			"\n" +
+			"	public X x = new X();\n" +
+			"	\n" +
+			"	void test() {\n" +
+			"		new ClassWithNNBDOnField().f.set(null);\n" +
+			"		new ClassWithNNBDOnField().f = null;\n" +
+			"		new ClassWithNNBDOnField().x.nested.set(null);\n" +
+			"		new ClassWithNNBDOnField().x.nested = null;\n" +
+			"	}\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+	runConformTestWithLibs(
+		new String[] {
+			"test/Test.java",
+			"package test;\n" +
+			"\n" +
+			"public class Test {\n" +
+			"	void test() {\n" +
+			"		new ClassWithNNBDOnField().f.set(null);\n" +
+			"		new ClassWithNNBDOnField().f = null;\n" +
+			"		new ClassWithNNBDOnField().x.nested.set(null);\n" +
+			"		new ClassWithNNBDOnField().x.nested = null;\n" +
+			"	}\n" +
+			"\n" +
+			"}\n" +
+			"",
+		}, 
+		getCompilerOptions(),
+		""
+	);
+}
 public void testBug500885() {
 	runConformTest(
 		new String[] {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 4faa530..c0ac572 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1875,6 +1875,12 @@ void setSourceStart(int sourceStart);
 	/** @since 3.13 */
 	int NullAnnotationAtQualifyingType = Internal + Syntax + 1061;
 
+	/** @since 3.13 */
+	int RedundantNullDefaultAnnotationLocal = Internal + 1062;
+	
+	/** @since 3.13 */
+	int RedundantNullDefaultAnnotationField = Internal + 1063;
+	
 	/** @since 3.10 */
 	int GenericInferenceError = 1100; 	// FIXME: This is just a stop-gap measure, be more specific via https://bugs.eclipse.org/404675
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index 940ee52..496a5dc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -944,6 +944,24 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 		return scope.environment().createAnnotatedType(type, annotationBindings);
 	}
 
+	/**
+	 * "early" handling of NonNullByDefault because for local variables annotations are resolved after their type because of bug
+	 * 96991.
+	 * @param localDeclaration 
+	 */
+	public static void handleNonNullByDefault(BlockScope scope, Annotation[] sourceAnnotations, LocalDeclaration localDeclaration) {
+		if (sourceAnnotations == null || sourceAnnotations.length == 0) {
+			return;
+		}
+		int length = sourceAnnotations.length;
+		for (int i = 0; i < length; i++) {
+			Annotation annotation = sourceAnnotations[i];
+			annotation.handleNonNullByDefault(scope, localDeclaration);
+		}
+	}
+
+
+	
 	// When SE8 annotations feature in SE7 locations, they get attributed to the declared entity. Copy/move these to the type of the declared entity (field, local, argument etc.)
 	public static void copySE8AnnotationsToType(BlockScope scope, Binding recipient, Annotation[] annotations, boolean annotatingEnumerator) {
 		
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index b49f838..11f6b1c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -394,29 +394,35 @@ public abstract class Annotation extends Expression {
 		} else if (annotationType.hasNullBit(TypeIds.BitNonNullAnnotation)) {
 			tagBits |= TagBits.AnnotationNonNull;
 		} else if (annotationType.hasNullBit(TypeIds.BitNonNullByDefaultAnnotation)) {
-			Object value = null;
-			if (valueAttribute != null) {
-				if (valueAttribute.compilerElementPair != null)
-					value = valueAttribute.compilerElementPair.value;
-			} else { // fetch default value  - TODO: cache it?
-				MethodBinding[] methods = annotationType.methods();
-				if (methods != null && methods.length == 1)
-					value = methods[0].getDefaultValue();
-				else
-					tagBits |= TagBits.AnnotationNonNullByDefault; // custom unconfigurable NNBD
-			}
-			if (value instanceof BooleanConstant) {
-				// boolean value is used for declaration annotations, signal using the annotation tag bit:
-				tagBits |= ((BooleanConstant)value).booleanValue() ? TagBits.AnnotationNonNullByDefault : TagBits.AnnotationNullUnspecifiedByDefault;
-			} else if (value != null) {
-				// non-boolean value signals type annotations, evaluate from DefaultLocation[] to bitvector a la Binding#NullnessDefaultMASK:
-				tagBits |= nullLocationBitsFromAnnotationValue(value);
-			}
+			tagBits |= determineNonNullByDefaultTagBits(annotationType, valueAttribute);
 		}
 		
 		return tagBits;
 	}
 
+	private long determineNonNullByDefaultTagBits(ReferenceBinding annotationType, MemberValuePair valueAttribute) {
+		long tagBits = 0;
+		Object value = null;
+		if (valueAttribute != null) {
+			if (valueAttribute.compilerElementPair != null)
+				value = valueAttribute.compilerElementPair.value;
+		} else { // fetch default value  - TODO: cache it?
+			MethodBinding[] methods = annotationType.methods();
+			if (methods != null && methods.length == 1)
+				value = methods[0].getDefaultValue();
+			else
+				tagBits |= TagBits.AnnotationNonNullByDefault; // custom unconfigurable NNBD
+		}
+		if (value instanceof BooleanConstant) {
+			// boolean value is used for declaration annotations, signal using the annotation tag bit:
+			tagBits |= ((BooleanConstant)value).booleanValue() ? TagBits.AnnotationNonNullByDefault : TagBits.AnnotationNullUnspecifiedByDefault;
+		} else if (value != null) {
+			// non-boolean value signals type annotations, evaluate from DefaultLocation[] to bitvector a la Binding#NullnessDefaultMASK:
+			tagBits |= nullLocationBitsFromAnnotationValue(value);
+		}
+		return tagBits;
+	}
+
 	/**
 	 * Convert the value() attribute of @NonNullByDefault into a bitvector a la {@link Binding#NullnessDefaultMASK}.
 	 * This method understands value encodings from source and binary types.
@@ -789,11 +795,16 @@ public abstract class Annotation extends Expression {
 			return this.resolvedType;
 		this.constant = Constant.NotAConstant;
 
-		TypeBinding typeBinding = this.type.resolveType(scope);
-		if (typeBinding == null) {
-			return null;
+		TypeBinding typeBinding;
+		if (this.resolvedType == null) {
+			typeBinding = this.type.resolveType(scope);
+			if (typeBinding == null) {
+				return null;
+			}
+			this.resolvedType = typeBinding;
+		} else {
+			typeBinding = this.resolvedType;
 		}
-		this.resolvedType = typeBinding;
 		// ensure type refers to an annotation type
 		if (!typeBinding.isAnnotationType() && typeBinding.isValidBinding()) {
 			scope.problemReporter().notAnnotationType(typeBinding, this.type);
@@ -928,6 +939,15 @@ public abstract class Annotation extends Expression {
 							FieldDeclaration fieldDeclaration = sourceType.scope.referenceContext.declarationOf(sourceField);
 							recordSuppressWarnings(scope, fieldDeclaration.declarationSourceStart, fieldDeclaration.declarationSourceEnd, scope.compilerOptions().suppressWarnings);
 						}
+						if (defaultNullness != 0) {
+							sourceType = (SourceTypeBinding) sourceField.declaringClass;
+							FieldDeclaration fieldDeclaration = sourceType.scope.referenceContext.declarationOf(sourceField);
+							Binding target = scope.checkRedundantDefaultNullness(defaultNullness, fieldDeclaration.sourceStart);
+							scope.recordNonNullByDefault(fieldDeclaration.binding, defaultNullness, this, fieldDeclaration.declarationSourceStart, fieldDeclaration.declarationSourceEnd);
+							if (target != null) {
+								scope.problemReporter().nullDefaultAnnotationIsRedundant(fieldDeclaration, new Annotation[]{this}, target);
+							}
+						}
 						// fields don't yet have their type resolved, in 1.8 null annotations
 						// will be transfered from the field to its type during STB.resolveTypeFor().
 						if ((sourceField.tagBits & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) {
@@ -946,6 +966,7 @@ public abstract class Annotation extends Expression {
 							LocalDeclaration localDeclaration = variable.declaration;
 							recordSuppressWarnings(scope, localDeclaration.declarationSourceStart, localDeclaration.declarationSourceEnd, scope.compilerOptions().suppressWarnings);
 						}
+						// note: defaultNullness for local declarations has been already been handled earlier by handleNonNullByDefault() 
 						break;
 				}
 			} 
@@ -959,6 +980,64 @@ public abstract class Annotation extends Expression {
 		return this.resolvedType;
 	}
 
+	public void handleNonNullByDefault(BlockScope scope, LocalDeclaration localDeclaration) {
+		TypeBinding typeBinding = this.resolvedType;
+		if (typeBinding == null) {
+			typeBinding = this.type.resolveType(scope);
+			if (typeBinding == null) {
+				return;
+			}
+			this.resolvedType = typeBinding;
+		}
+		if (!typeBinding.isAnnotationType()) {
+			return;
+		}
+
+		ReferenceBinding annotationType = (ReferenceBinding) typeBinding;
+		
+		if (!annotationType.hasNullBit(TypeIds.BitNonNullByDefaultAnnotation)) {
+			return;
+		}
+
+		MethodBinding[] methods = annotationType.methods();
+		// clone valuePairs to keep track of unused ones
+		MemberValuePair[] pairs = memberValuePairs();
+		MemberValuePair valueAttribute = null; // remember the first 'value' pair
+		int pairsLength = pairs.length;
+
+		for (int i = 0, requiredLength = methods.length; i < requiredLength; i++) {
+			MethodBinding method = methods[i];
+			char[] selector = method.selector;
+			nextPair: for (int j = 0; j < pairsLength; j++) {
+				MemberValuePair pair = pairs[j];
+				if (pair == null) continue nextPair;
+				char[] name = pair.name;
+				if (CharOperation.equals(name, selector)) {
+					if (valueAttribute == null && CharOperation.equals(name, TypeConstants.VALUE)) {
+						valueAttribute = pair;
+						pair.binding = method;
+						pair.resolveTypeExpecting(scope, method.returnType);
+					}
+				}
+			}
+		}
+		// recognize standard annotations ?
+		long tagBits = determineNonNullByDefaultTagBits(annotationType, valueAttribute);
+		int defaultNullness = (int)(tagBits & Binding.NullnessDefaultMASK);
+
+		if (defaultNullness != 0) {
+			// the actual localDeclaration.binding is not set yet. fake one for problemreporter.			
+			LocalVariableBinding binding = new LocalVariableBinding(localDeclaration, null, 0, false);
+			Binding target = scope.checkRedundantDefaultNullness(defaultNullness, localDeclaration.sourceStart);
+			boolean recorded = scope.recordNonNullByDefault(binding, defaultNullness, this, this.sourceStart, localDeclaration.declarationSourceEnd);
+			 if (recorded) {
+				if (target != null) {
+					scope.problemReporter().nullDefaultAnnotationIsRedundant(localDeclaration, new Annotation[]{this}, target);
+				}
+			}
+		} 
+	}
+	
 	public enum AnnotationTargetAllowed {
 		YES, TYPE_ANNOTATION_ON_QUALIFIED_NAME, NO;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index fdad3a1..38043ce 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -195,6 +195,11 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	}
 	public void resolve(BlockScope scope) {
 
+		// prescan NNBD
+		if (scope.environment().usesNullTypeAnnotations()) {
+			handleNonNullByDefault(scope, this.annotations, this);
+		}
+
 		// create a binding and add it to the scope
 		TypeBinding variableType = this.type.resolveType(scope, true /* check bounds*/);
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
index 81ca5c8..5490493 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -60,6 +60,9 @@ public class MemberValuePair extends ASTNode {
 	}
 
 	public void resolveTypeExpecting(final BlockScope scope, final TypeBinding requiredType) {
+		if (this.compilerElementPair != null) {
+			return;
+		}
 
 		if (this.value == null) {
 			this.compilerElementPair = new ElementValuePair(this.name, this.value, this.binding);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
index fd48a67..f323ae7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeParameter.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -129,7 +129,7 @@ public class TypeParameter extends AbstractVariableDeclaration {
 			if (isAnnotationBasedNullAnalysisEnabled) {
 				if (this.binding != null && this.binding.isValidBinding()) {
 					if (!this.binding.hasNullTypeAnnotations()
-							&& scope.hasDefaultNullnessFor(Binding.DefaultLocationTypeParameter)) {
+							&& scope.hasDefaultNullnessFor(Binding.DefaultLocationTypeParameter, this.sourceStart())) {
 						AnnotationBinding[] annots = new AnnotationBinding[] { environment.getNonNullAnnotation() };
 						TypeVariableBinding previousBinding = this.binding;
 						this.binding = (TypeVariableBinding) environment.createAnnotatedType(this.binding, annots);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index b2561d8..2fe855d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -655,7 +655,7 @@ protected void resolveAnnotations(Scope scope, int location) {
 			&& !this.resolvedType.isTypeVariable()
 			&& !this.resolvedType.isWildcard()
 			&& location != 0
-			&& scope.hasDefaultNullnessFor(location)) 
+			&& scope.hasDefaultNullnessFor(location, this.sourceStart)) 
 	{
 		if (location == Binding.DefaultLocationTypeBound && this.resolvedType.id == TypeIds.T_JavaLangObject) {
 			scope.problemReporter().implicitObjectBoundNoNullDefault(this);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 0740f84..a01bd08 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -616,7 +616,7 @@ private void createFields(IBinaryField[] iFields, IBinaryType binaryType, long s
 			for (int i = 0; i < size; i++) {
 				IBinaryField binaryField = iFields[i];
 				char[] fieldSignature = use15specifics ? binaryField.getGenericSignature() : null;
-				ITypeAnnotationWalker walker = getTypeAnnotationWalker(binaryField.getTypeAnnotations(), Binding.NO_NULL_DEFAULT);
+				ITypeAnnotationWalker walker = getTypeAnnotationWalker(binaryField.getTypeAnnotations(), getNullDefaultFrom(binaryField.getAnnotations()));
 				if (sourceLevel >= ClassFileConstants.JDK1_8) { // below 1.8, external annotations will be attached later
 					walker = binaryType.enrichWithExternalAnnotationsFor(walker, iFields[i], this.environment);
 				}
@@ -1568,9 +1568,14 @@ private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBi
 		if (fieldType != null
 				&& !fieldType.isBaseType()
 				&& (fieldType.tagBits & TagBits.AnnotationNullMASK) == 0
-				&& fieldType.acceptsNonNullDefault()
-				&& hasNonNullDefaultFor(DefaultLocationField, true)) {
-			fieldBinding.type = this.environment.createAnnotatedType(fieldType, new AnnotationBinding[]{this.environment.getNonNullAnnotation()});
+				&& fieldType.acceptsNonNullDefault()) {
+				int nullDefaultFromField = getNullDefaultFrom(field.getAnnotations());
+				if (nullDefaultFromField == Binding.NO_NULL_DEFAULT
+						? hasNonNullDefaultFor(DefaultLocationField, true, -1)
+						: (nullDefaultFromField & DefaultLocationField) != 0) {
+					fieldBinding.type = this.environment.createAnnotatedType(fieldType,
+							new AnnotationBinding[] { this.environment.getNonNullAnnotation() });
+				}
 		}
 		return; // not using fieldBinding.tagBits when we have type annotations.
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
index 866ca8b..3f5b926 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1232,8 +1232,5 @@ private boolean checkAppropriate(MethodBinding compileTimeDeclaration, MethodBin
 	}
 	return true;
 }
-@Override
-public boolean hasDefaultNullnessFor(int location) {
-	return this.parent.hasDefaultNullnessFor(location);
-}
+
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
index 54c0643..a2eb9e2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1356,16 +1356,37 @@ public class ClassScope extends Scope {
 	}
 
 	@Override
-	public boolean hasDefaultNullnessFor(int location) {
+	public boolean hasDefaultNullnessFor(int location, int sourceStart) {
+		int nonNullByDefaultValue = localNonNullByDefaultValue(sourceStart);
+		if (nonNullByDefaultValue != 0) {
+			return (nonNullByDefaultValue & location) != 0;
+		}
 		SourceTypeBinding binding = this.referenceContext.binding;
 		if (binding != null) {
 			int nullDefault = binding.getNullDefault();
-			if (nullDefault != 0)
+			if (nullDefault != 0) {
 				return (nullDefault & location) != 0;
+			}
 		}
-		return this.parent.hasDefaultNullnessFor(location);
+		return this.parent.hasDefaultNullnessFor(location, sourceStart);
 	}
 
+	@Override
+	public /* @Nullable */ Binding checkRedundantDefaultNullness(int nullBits, int sourceStart) {
+		Binding target = localCheckRedundantDefaultNullness(nullBits, sourceStart);
+		if (target != null) {
+			return target;
+		}
+		SourceTypeBinding binding = this.referenceContext.binding;
+		if (binding != null) {
+			int nullDefault = binding.getNullDefault();
+			if (nullDefault != 0) {
+				return (nullDefault == nullBits) ? binding : null;
+			}
+		}
+		return this.parent.checkRedundantDefaultNullness(nullBits, sourceStart);
+	}
+	
 	public String toString() {
 		if (this.referenceContext != null)
 			return "--- Class Scope ---\n\n"  //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index 64ef1c7..123289f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -974,11 +974,29 @@ private int checkAndRecordImportBinding(
 	return this.importPtr;
 }
 @Override
-public boolean hasDefaultNullnessFor(int location) {
+public boolean hasDefaultNullnessFor(int location, int sourceStart) {
+	int nonNullByDefaultValue = localNonNullByDefaultValue(sourceStart);
+	if (nonNullByDefaultValue != 0) {
+		return (nonNullByDefaultValue & location) != 0;
+	}
 	if (this.fPackage != null)
 		return (this.fPackage.defaultNullness & location) != 0;
 	return false;
 }
+
+@Override
+public /* @Nullable */ Binding checkRedundantDefaultNullness(int nullBits, int sourceStart) {
+	Binding target = localCheckRedundantDefaultNullness(nullBits, sourceStart);
+	if (target != null) {
+		return target;
+	}
+	if (this.fPackage != null) {
+		return (this.fPackage.defaultNullness == nullBits) ? this.fPackage : null;
+	}
+
+	return null;
+}
+
 public void registerInferredInvocation(Invocation invocation) {
 	if (this.inferredInvocations == null)
 		this.inferredInvocations = new ArrayList<>();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index c4afbca..429a767 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012, 2015 GK Software AG, IBM Corporation and others.
+ * Copyright (c) 2012, 2017 GK Software AG, IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -86,9 +86,9 @@ public class ImplicitNullAnnotationVerifier {
 			}
 			boolean usesTypeAnnotations = scope.environment().usesNullTypeAnnotations();
 			boolean needToApplyReturnNonNullDefault =
-					currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationReturnType, usesTypeAnnotations);
+					currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationReturnType, usesTypeAnnotations, srcMethod);
 			boolean needToApplyParameterNonNullDefault =
-					currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter, usesTypeAnnotations);
+					currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter, usesTypeAnnotations, srcMethod);
 			boolean needToApplyNonNullDefault = needToApplyReturnNonNullDefault | needToApplyParameterNonNullDefault;
 			// compatibility & inheritance do not consider constructors / static methods:
 			boolean isInstanceMethod = !currentMethod.isConstructor() && !currentMethod.isStatic();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index 0e2f812..934a483 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -525,7 +525,7 @@ protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod
 	if(original == null) {
 		return;
 	}
-	if (hasNonNullDefaultFor(DefaultLocationParameter, true)) {
+	if (hasNonNullDefaultFor(DefaultLocationParameter, true, sourceMethod)) {
 		boolean added = false;
 		int length = this.parameters.length;
 		for (int i = 0; i < length; i++) {
@@ -548,7 +548,7 @@ protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod
 		if (added)
 			this.tagBits |= TagBits.HasParameterAnnotations;
 	}
-	if (original.returnType != null && hasNonNullDefaultFor(DefaultLocationReturnType, true) && original.returnType.acceptsNonNullDefault()) {
+	if (original.returnType != null && hasNonNullDefaultFor(DefaultLocationReturnType, true, sourceMethod) && original.returnType.acceptsNonNullDefault()) {
 		if ((this.returnType.tagBits & TagBits.AnnotationNullMASK) == 0) {
 			this.returnType = env.createAnnotatedType(this.returnType, new AnnotationBinding[]{env.getNonNullAnnotation()});
 		} else if (sourceMethod instanceof MethodDeclaration && (this.returnType.tagBits & TagBits.AnnotationNonNull) != 0 
@@ -649,9 +649,16 @@ public long getAnnotationTagBits() {
 				long nullDefaultBits = usesNullTypeAnnotations ? this.defaultNullness
 						: this.tagBits & (TagBits.AnnotationNonNullByDefault|TagBits.AnnotationNullUnspecifiedByDefault);
 				if (nullDefaultBits != 0 && this.declaringClass instanceof SourceTypeBinding) {
-					SourceTypeBinding declaringSourceType = (SourceTypeBinding) this.declaringClass;
-					if (declaringSourceType.checkRedundantNullnessDefaultOne(methodDecl, methodDecl.annotations, nullDefaultBits, usesNullTypeAnnotations)) {
-						declaringSourceType.checkRedundantNullnessDefaultRecurse(methodDecl, methodDecl.annotations, nullDefaultBits, usesNullTypeAnnotations);
+					if (usesNullTypeAnnotations) {
+						Binding target = scope.checkRedundantDefaultNullness(this.defaultNullness, typeDecl.declarationSourceStart);
+						if (target != null) {
+							methodDecl.scope.problemReporter().nullDefaultAnnotationIsRedundant(methodDecl, methodDecl.annotations, target);
+						}
+					} else {
+						SourceTypeBinding declaringSourceType = (SourceTypeBinding) this.declaringClass;
+						if (declaringSourceType.checkRedundantNullnessDefaultOne(methodDecl, methodDecl.annotations, nullDefaultBits, usesNullTypeAnnotations)) {
+							declaringSourceType.checkRedundantNullnessDefaultRecurse(methodDecl, methodDecl.annotations, nullDefaultBits, usesNullTypeAnnotations);
+						}
 					}
 				}
 			}
@@ -1298,7 +1305,7 @@ public TypeVariableBinding[] typeVariables() {
 	return this.typeVariables;
 }
 //pre: null annotation analysis is enabled
-public boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations) {
+public boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations, AbstractMethodDeclaration srcMethod) {
 	if ((this.modifiers & ExtraCompilerModifiers.AccIsDefaultConstructor) != 0)
 		return false;
 	if (useTypeAnnotations) {
@@ -1310,7 +1317,7 @@ public boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations) {
 		if ((this.tagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
 			return false;
 	}
-	return this.declaringClass.hasNonNullDefaultFor(location, useTypeAnnotations);
+	return this.declaringClass.hasNonNullDefaultFor(location, useTypeAnnotations, srcMethod == null ? -1 : srcMethod.declarationSourceStart);
 }
 
 public boolean redeclaresPublicObjectMethod(Scope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
index 65f2d85..985e414 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -572,12 +572,33 @@ void resolveTypeParameter(TypeParameter typeParameter) {
 	typeParameter.resolve(this);
 }
 @Override
-public boolean hasDefaultNullnessFor(int location) {
-	if (this.referenceContext instanceof AbstractMethodDeclaration) {
-		MethodBinding binding = ((AbstractMethodDeclaration) this.referenceContext).binding;
-		if (binding != null && binding.defaultNullness != 0)
+public boolean hasDefaultNullnessFor(int location, int sourceStart) {
+	int nonNullByDefaultValue = localNonNullByDefaultValue(sourceStart);
+	if(nonNullByDefaultValue != 0) {
+		return (nonNullByDefaultValue & location) != 0;
+	}
+	AbstractMethodDeclaration referenceMethod = referenceMethod();
+	if (referenceMethod != null) {
+		MethodBinding binding = referenceMethod.binding;
+		if (binding != null && binding.defaultNullness != 0) {
 			return (binding.defaultNullness & location) != 0;
+		}
+	}
+	return this.parent.hasDefaultNullnessFor(location, sourceStart);
+}
+@Override
+public Binding checkRedundantDefaultNullness(int nullBits, int sourceStart) {
+	Binding target = localCheckRedundantDefaultNullness(nullBits, sourceStart);
+	if (target != null) {
+		return target;
+	}
+	AbstractMethodDeclaration referenceMethod = referenceMethod();
+	if (referenceMethod != null) {
+		MethodBinding binding = referenceMethod.binding;
+		if (binding != null && binding.defaultNullness != 0) {
+			return (binding.defaultNullness == nullBits) ? binding : null;
+		}
 	}
-	return this.parent.hasDefaultNullnessFor(location);
+	return this.parent.checkRedundantDefaultNullness(nullBits, sourceStart);
 }
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
index b583e89..5f5c784 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -80,8 +80,8 @@ void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[]
 	if (analyseNullAnnotations && this.type.equals(concreteMethod.declaringClass)) // is currentMethod from the current type?
 		srcMethod = concreteMethod.sourceMethod();
 	boolean useTypeAnnotations = this.environment.usesNullTypeAnnotations();
-	boolean hasReturnNonNullDefault = analyseNullAnnotations && concreteMethod.hasNonNullDefaultFor(Binding.DefaultLocationReturnType, useTypeAnnotations);
-	boolean hasParameterNonNullDefault = analyseNullAnnotations && concreteMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter, useTypeAnnotations);
+	boolean hasReturnNonNullDefault = analyseNullAnnotations && concreteMethod.hasNonNullDefaultFor(Binding.DefaultLocationReturnType, useTypeAnnotations, srcMethod);
+	boolean hasParameterNonNullDefault = analyseNullAnnotations && concreteMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter, useTypeAnnotations, srcMethod);
 
 	for (int i = 0, l = abstractMethods.length; i < l; i++) {
 		MethodBinding abstractMethod = abstractMethods[i];
@@ -397,8 +397,8 @@ void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] m
 		if (this.type.equals(currentMethod.declaringClass)) // is currentMethod from the current type?
 			srcMethod = currentMethod.sourceMethod();
 		boolean useTypeAnnotations = this.environment.usesNullTypeAnnotations();
-		boolean hasReturnNonNullDefault = currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationReturnType, useTypeAnnotations);
-		boolean hasParameterNonNullDefault = currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter, useTypeAnnotations);
+		boolean hasReturnNonNullDefault = currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationReturnType, useTypeAnnotations, srcMethod);
+		boolean hasParameterNonNullDefault = currentMethod.hasNonNullDefaultFor(Binding.DefaultLocationParameter, useTypeAnnotations, srcMethod);
 		for (int i = length; --i >= 0;)
 			if (!currentMethod.isStatic() && !methods[i].isStatic())
 				checkNullSpecInheritance(currentMethod, srcMethod, hasReturnNonNullDefault, hasParameterNonNullDefault, true, methods[i], methods, this.type.scope, null);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 9e72105..96ba4af 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1122,7 +1122,7 @@ public boolean hasMemberTypes() {
  * for 1.8 check if the default is applicable to the given kind of location.
  */
 // pre: null annotation analysis is enabled
-boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations) {
+boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations, int sourceStart) {
 	// Note, STB overrides for correctly handling local types
 	ReferenceBinding currentType = this;
 	while (currentType != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index ba4457c..97988d8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -75,6 +75,18 @@ import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 @SuppressWarnings({ "rawtypes", "unchecked" })
 public abstract class Scope {
 
+	public static Binding NOT_REDUNDANT = new Binding() {
+		@Override
+		public int kind() {
+			throw new IllegalStateException();
+		}
+	
+		@Override
+		public char[] readableName() {
+			throw new IllegalStateException();
+		}
+	};
+
 	/* Scope kinds */
 	public final static int BLOCK_SCOPE = 1;
 	public final static int CLASS_SCOPE = 3;
@@ -95,6 +107,22 @@ public abstract class Scope {
 	public int kind;
 	public Scope parent;
 	
+	private static class NullDefaultRange {
+		final int value;
+		final Annotation annotation;
+		final int start, end;
+		final Binding target;
+
+		NullDefaultRange(int value, Annotation annotation, int start, int end, Binding target) {
+			this.value = value;
+			this.annotation = annotation;
+			this.start = start;
+			this.end = end;
+			this.target = target;
+		}
+	}
+
+	private /* @Nullable */ ArrayList<NullDefaultRange> nullDefaultRanges;
 
 	protected Scope(int kind, Scope parent) {
 		this.kind = kind;
@@ -5050,9 +5078,90 @@ public abstract class Scope {
 		}
 		return true;
 	}
-	
+
+	/**
+	 * Record a NNBD annotation applying to a given source range within the current scope
+	 * @param target the annotated element
+	 * @param value bitset describing the default nullness (see Binding.NullnessDefaultMASK)
+	 * @param annotation the NNBD annotation 
+	 * @param scopeStart start of the source range affected by the default
+	 * @param scopeEnd end of the source range affected by the default
+	 * @return <code>true</code> if the annotation was newly recorded, <code>false</code> if a corresponding entry already existed.
+	 */
+	public boolean recordNonNullByDefault(Binding target, int value, Annotation annotation, int scopeStart, int scopeEnd) {
+		ReferenceContext context = referenceContext();
+		if (context instanceof LambdaExpression && context != ((LambdaExpression) context).original)
+			return false; // Do not record from copies. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=441929
+			
+		if (this.nullDefaultRanges == null) {
+			this.nullDefaultRanges=new ArrayList<>(3);
+		}
+		for (NullDefaultRange nullDefaultRange : this.nullDefaultRanges) {
+			if (nullDefaultRange.annotation == annotation
+					&& nullDefaultRange.start== scopeStart
+					&& nullDefaultRange.end==scopeEnd
+					&& nullDefaultRange.value==value) {
+				// annotation data already recorded
+				return false;
+			}
+		}
+		this.nullDefaultRanges.add(new NullDefaultRange(value, annotation, scopeStart, scopeEnd, target));
+		return true;
+	}
+
+	/**
+	 * Check whether the given null default is redundant at the given position inside this scope.
+	 * @param nullBits locally defined nullness default, see Binding.NullnessDefaultMASK
+	 * @param sourceStart
+	 * @return enclosing binding that already has a matching NonNullByDefault annotation,
+	 * 		or the special binding {@link #NOT_REDUNDANT}, indicating that a different enclosing nullness default was found, 
+	 * 		or null to indicate that no enclosing nullness default was found.
+	 */
+	public Binding checkRedundantDefaultNullness(int nullBits, int sourceStart) {
+		Binding target = localCheckRedundantDefaultNullness(nullBits, sourceStart);
+		if (target != null) {
+			return target;
+		}
+		return this.parent.checkRedundantDefaultNullness(nullBits, sourceStart);
+	}
+
 	/** Answer a defaultNullness defined for the closest enclosing scope, using bits from Binding.NullnessDefaultMASK. */
-	public abstract boolean hasDefaultNullnessFor(int location);
+	public boolean hasDefaultNullnessFor(int location, int sourceStart) {
+		int nonNullByDefaultValue = localNonNullByDefaultValue(sourceStart);
+		if (nonNullByDefaultValue != 0) {
+			return (nonNullByDefaultValue & location) != 0;
+		}
+		return this.parent.hasDefaultNullnessFor(location, sourceStart);
+	}
+
+	/*
+	 * helper for hasDefaultNullnessFor(..) which inspects only ranges recorded within this scope.
+	 */
+	final protected int localNonNullByDefaultValue(int start) {
+		NullDefaultRange nullDefaultRange = nullDefaultRangeForPosition(start);
+		return nullDefaultRange != null ? nullDefaultRange.value : 0;
+	}
+
+	/*
+	 * local variant of checkRedundantDefaultNullness(..), i.e., only inspect ranges recorded within this scope.
+	 */
+	final protected /* @Nullable */ Binding localCheckRedundantDefaultNullness(int nullBits, int position) {
+		NullDefaultRange nullDefaultRange = nullDefaultRangeForPosition(position);
+		if (nullDefaultRange != null)
+			return (nullBits == nullDefaultRange.value) ? nullDefaultRange.target : NOT_REDUNDANT;
+		return null;
+	}
+
+	private /* @Nullable */ NullDefaultRange nullDefaultRangeForPosition(int start) {
+		if (this.nullDefaultRanges != null) {
+			for (NullDefaultRange nullDefaultRange : this.nullDefaultRanges) {
+				if (start >= nullDefaultRange.start && start < nullDefaultRange.end) {
+					return nullDefaultRange;
+				}
+			}
+		}
+		return null;
+	}
 
 	public static BlockScope typeAnnotationsResolutionScope(Scope scope) {
 		BlockScope resolutionScope = null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 9178803..be3d0db 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -1791,7 +1791,7 @@ public FieldBinding resolveTypeFor(FieldBinding field) {
 					// enum constants neither have a type declaration nor can they be null
 					field.tagBits |= TagBits.AnnotationNonNull;
 				} else {
-					if (hasNonNullDefaultFor(DefaultLocationField, this.environment.usesNullTypeAnnotations())) {
+					if (hasNonNullDefaultFor(DefaultLocationField, this.environment.usesNullTypeAnnotations(), fieldDecl.sourceStart)) {
 						field.fillInDefaultNonNullness(fieldDecl, initializationScope);
 					}
 					// validate null annotation:
@@ -2120,7 +2120,10 @@ public void evaluateNullAnnotations() {
 				pkg.defaultNullness = this.defaultNullness;
 			} else {
 				TypeDeclaration typeDecl = this.scope.referenceContext;
-				checkRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, this.defaultNullness, true);
+				Binding target = this.scope.parent.checkRedundantDefaultNullness(this.defaultNullness, typeDecl.declarationSourceStart);
+				if(target != null) {
+					this.scope.problemReporter().nullDefaultAnnotationIsRedundant(typeDecl, typeDecl.annotations, target);
+				}
 			}
 		} else if (isPackageInfo || (isInDefaultPkg && !(this instanceof NestedTypeBinding))) {
 			this.scope.problemReporter().missingNonNullByDefaultAnnotation(this.scope.referenceContext);
@@ -2164,10 +2167,10 @@ public void evaluateNullAnnotations() {
 }
 
 private void maybeMarkTypeParametersNonNull() {
+	if (this.typeVariables != null && this.typeVariables.length > 0) {
 	// when creating type variables we didn't yet have the defaultNullness, fill it in now:
-	if (this.scope == null || !this.scope.hasDefaultNullnessFor(DefaultLocationTypeParameter))
+		if (this.scope == null || !this.scope.hasDefaultNullnessFor(DefaultLocationTypeParameter, this.sourceStart()))
 		return;
-	if (this.typeVariables != null && this.typeVariables.length > 0) {
 		AnnotationBinding[] annots = new AnnotationBinding[]{ this.environment.getNonNullAnnotation() };
 		for (int i = 0; i < this.typeVariables.length; i++) {
 			TypeVariableBinding tvb = this.typeVariables[i];
@@ -2220,7 +2223,8 @@ protected boolean checkRedundantNullnessDefaultOne(ASTNode location, Annotation[
 	return true;
 }
 
-boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations) {
+@Override
+boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations, int sourceStart) {
 	
 	if (!isPrototype()) throw new IllegalStateException();
 	
@@ -2229,7 +2233,10 @@ boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations) {
 		if (this.scope == null) {
 			return (this.defaultNullness & location) != 0;
 		}
-		return this.scope.hasDefaultNullnessFor(location);
+		Scope skope = this.scope.referenceContext.initializerScope; // for @NNBD on a field
+		if (skope == null)
+			skope = this.scope;
+		return skope.hasDefaultNullnessFor(location, sourceStart);
 	}
 
 	// find the applicable default inside->out:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index f139e72..3773f15 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -450,6 +450,8 @@ public static int getIrritant(int problemID) {
 		case IProblem.RedundantNullDefaultAnnotationPackage:
 		case IProblem.RedundantNullDefaultAnnotationType:
 		case IProblem.RedundantNullDefaultAnnotationMethod:
+		case IProblem.RedundantNullDefaultAnnotationLocal:
+		case IProblem.RedundantNullDefaultAnnotationField:
 			return CompilerOptions.RedundantNullAnnotation;
 
 		case IProblem.BoxingConversion :
@@ -9705,6 +9707,8 @@ public void nullAnnotationIsRedundant(FieldDeclaration sourceField) {
 }
 
 public void nullDefaultAnnotationIsRedundant(ASTNode location, Annotation[] annotations, Binding outer) {
+	if (outer == Scope.NOT_REDUNDANT)
+		return;
 	Annotation annotation = findAnnotation(annotations, TypeIds.BitNonNullByDefaultAnnotation);
 	int start = annotation != null ? annotation.sourceStart : location.sourceStart;
 	int end = annotation != null ? annotation.sourceEnd : location.sourceStart;
@@ -9721,6 +9725,10 @@ public void nullDefaultAnnotationIsRedundant(ASTNode location, Annotation[] anno
 		problemId = IProblem.RedundantNullDefaultAnnotationType;
 	} else if (outer instanceof MethodBinding) {
 		problemId = IProblem.RedundantNullDefaultAnnotationMethod;
+	} else if (outer instanceof LocalVariableBinding) {
+		problemId = IProblem.RedundantNullDefaultAnnotationLocal;
+	} else if (outer instanceof FieldBinding) {
+		problemId = IProblem.RedundantNullDefaultAnnotationField;
 	}
 	this.handle(problemId, args, shortArgs, start, end);
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 82f4734..fbd87c9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -1,5 +1,5 @@
 ###############################################################################
-# Copyright (c) 2000, 2016 IBM Corporation and others.
+# Copyright (c) 2000, 2017 IBM Corporation and others.
 # All rights reserved. This program and the accompanying materials
 # are made available under the terms of the Eclipse Public License v1.0
 # which accompanies this distribution, and is available at
@@ -861,6 +861,8 @@
 1059 = Cannot infer type argument(s) for <{0}> {1}
 1060 = Illegally placed annotation: type annotations must directly precede the simple name of the type they are meant to affect (or the [] for arrays)
 1061 = The nullness annotation ''{0}'' is not applicable at this location, it must be placed directly before the nested type name.
+1062 = Nullness default is redundant with a default specified for the variable {0}
+1063 = Nullness default is redundant with a default specified for the field {0}
 
 1100 = Problem detected during type inference: {0}
 #1101 is already used up but deprecated
