commit 0d03fa7f20cfc1f665880ee8b014c1270a66b1bf
Author: Harry Terkelsen <het@google.com>
Date:   Fri Feb 20 18:20:18 2015 -0800

    Fixes Bug 460491 - NPE in ParameterizedTypeBinding.collectSubstitutes
    
    Change-Id: I98cac84feadc5262cb18ff348b89082ef07051b4
    Signed-off-by: Harry Terkelsen <het@google.com>

20	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
index 6f9b808..f022ecc 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
@@ -20,6 +20,7 @@
  *								Bug 426676 - [1.8][compiler] Wrong generic method type inferred from lambda expression
  *								Bug 423505 - [1.8] Implement "18.5.4 More Specific Method Inference"
  *								Bug 434483 - [1.8][compiler][inference] Type inference not picked up with method reference
+ *     Harry Terkelsen - Bug 460491 - NPE in ParameterizedTypeBinding.collectSubstitutes
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -52165,4 +52166,23 @@ public void testBug469201_B(){
 		"The method bar(Bar) from the type A is not visible\n" + 
 		"----------\n");
 		}
+public void testBug460491() {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_7) {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(CompilerOptions.OPTION_ReportRedundantSpecificationOfTypeArguments, CompilerOptions.WARNING);
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"class A {\n" +
+				"	private static final B.C c = new B.D<Void>();\n" +
+				"}",
+				"B.java",
+				"class B<T> {\n" +
+				"	public interface C {}\n" +
+				"	public static class D<R> implements C {}\n" +
+				"}"
+			},
+			customOptions);
+	}
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index f6a4126..9c041f9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -287,6 +287,9 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
         	default :
         		return;
         }
+        if (formalArguments == null || actualArguments == null) { // band-aid for https://bugs.eclipse.org/460491 TODO: remove once really fixed
+        	return;
+        }
         inferenceContext.depth++;
         for (int i = 0, length = formalArguments.length; i < length; i++) {
         	TypeBinding formalArgument = formalArguments[i];
commit a287b30addb5f7ff3e59523ce299b99d755f7ecd
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Apr 24 19:11:28 2016 +0200

    Bug 460491: [compiler] don't consider parameter-less static member type
    with generic enclosing as parameterized
    
    Change-Id: Ibdd3fa1fa797075a8cf2e98bd1021f85dd7e16fb

1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ExpressionContextTests.java
44	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeSignatureTest.java
58	35	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
18	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest.java
3	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GrammarCoverageTests308.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java
6	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
46	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
46	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS8Test.java
46	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
3	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
18	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
2	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
10	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
10	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
34	24	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
18	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
37	27	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
index 2efbb3e..89897b0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AnnotationTest.java
@@ -8968,7 +8968,7 @@ public void test270() {
 		"1. ERROR in Test.java (at line 3)\n" +
 		"	Anno value();\n" +
 		"	^^^^\n" +
-		"Cycle detected: the annotation type Test<T>.Anno cannot contain attributes of the annotation type itself\n" +
+		"Cycle detected: the annotation type Test.Anno cannot contain attributes of the annotation type itself\n" +
 		"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=289576
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
index 5a7a600..d3f2e1c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
@@ -3182,7 +3182,7 @@ public void test099() {
 		"1. ERROR in X.java (at line 13)\n" +
 		"	A<Integer>.E e1 = e;\n" +
 		"	^^^^^^^^^^^^\n" +
-		"The member type A<Integer>.E cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type A<Integer>\n" +
+		"The member type A.E cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type A<Integer>\n" +
 		"----------\n");
 }
 /* from JLS
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ExpressionContextTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ExpressionContextTests.java
index 6cc0ae1..6392ec8 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ExpressionContextTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ExpressionContextTests.java
@@ -299,7 +299,7 @@ public void test010() {
 			"1. ERROR in X.java (at line 9)\n" + 
 			"	I<X> i2 = (Map<String, String>.Entry & I<X> & Serializable) null;\n" + 
 			"	           ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"The member type Map<String,String>.Entry cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Map<String,String>\n" + 
+			"The member type Map.Entry<K,V> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Map<String,String>\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 9)\n" + 
 			"	I<X> i2 = (Map<String, String>.Entry & I<X> & Serializable) null;\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeSignatureTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeSignatureTest.java
index bc82e03..0084fe6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeSignatureTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeSignatureTest.java
@@ -1277,4 +1277,48 @@ public class GenericTypeSignatureTest extends AbstractRegressionTest {
 		}
 	}
 
+	public void testBug460491() {
+		final String[] testsSource = new String[] {
+				"C.java",
+				"public class C<E> {\n" + 
+				"  static class F { }\n" + 
+				"  interface G { }\n" + 
+				"  class H { }\n" + 
+				"  void m1(F f) {}\n" + 
+				"  void m2(G g) {}\n" + 
+				"  void m3(H h) {}\n" + 
+				"}\n"
+		};
+		this.runConformTest(
+				testsSource,
+				"");
+
+		try {
+			ClassFileReader classFileReader = ClassFileReader.read(OUTPUT_DIR + File.separator + "C.class");
+			IBinaryMethod[] methods = classFileReader.getMethods();
+			assertNotNull("No methods", methods);
+			assertEquals("Wrong size", 4, methods.length); // incl ctor
+
+			IBinaryMethod m1 = methods[1];
+			assertEquals("Wrong name", "m1", new String(m1.getSelector()));
+			char[] signature = m1.getGenericSignature();
+			assertNull("Unexpected signature", signature); // no generic signature should have been produced
+
+
+			IBinaryMethod m2 = methods[2];
+			assertEquals("Wrong name", "m2", new String(m2.getSelector()));
+			signature = m2.getGenericSignature();
+			assertNull("Unexpected signature", signature); // no generic signature should have been produced
+
+			IBinaryMethod m3 = methods[3];
+			assertEquals("Wrong name", "m3", new String(m3.getSelector()));
+			signature = m3.getGenericSignature();
+			assertEquals("Wrong signature", "(LC<TE;>.H;)V", String.valueOf(signature)); // generic signature *should* have been produced
+		} catch (ClassFormatException e) {
+			assertTrue(false);
+		} catch (IOException e) {
+			assertTrue(false);
+		}
+	}
+
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
index 7bf167f..4601d58 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
@@ -8600,7 +8600,7 @@ public class GenericTypeTest extends AbstractComparableTest {
 			"1. ERROR in X.java (at line 11)\n" +
 			"	X<String>.A.B<String> bs;\n" +
 			"	^^^^^^^^^^^\n" +
-			"The member type X<String>.A cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<String>\n" +
+			"The member type X.A<U> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<String>\n" +
 			"----------\n");
 	}
 	// ensure bound check deals with supertype (and their enclosing type)
@@ -9076,8 +9076,8 @@ public class GenericTypeTest extends AbstractComparableTest {
 			"----------\n" +
 			"1. WARNING in X.java (at line 6)\n" +
 			"	public int foo(T t) { return t.i + t.i() + T.M.j; }\n" +
-			"	                                           ^^^^^\n" +
-			"Read access to enclosing field X<T>.M.j is emulated by a synthetic accessor method\n" +
+			"	                                               ^\n" +
+			"Read access to enclosing field X.M.j is emulated by a synthetic accessor method\n" +
 			"----------\n" +
 			"2. ERROR in X.java (at line 9)\n" +
 			"	class Y extends Zork {\n" +
@@ -13841,12 +13841,12 @@ public class GenericTypeTest extends AbstractComparableTest {
 			"1. ERROR in X.java (at line 6)\n" +
 			"	X<String>.Inner<Integer> d4 = new X<String>.Inner<Integer>();\n" +
 			"	^^^^^^^^^^^^^^^\n" +
-			"The member type X<String>.Inner cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<String>\n" +
+			"The member type X.Inner<B> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<String>\n" +
 			"----------\n" +
 			"2. ERROR in X.java (at line 6)\n" +
 			"	X<String>.Inner<Integer> d4 = new X<String>.Inner<Integer>();\n" +
 			"	                                  ^^^^^^^^^^^^^^^\n" +
-			"The member type X<String>.Inner cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<String>\n" +
+			"The member type X.Inner<B> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<String>\n" +
 			"----------\n");
 	}
 
@@ -20475,7 +20475,7 @@ public void test0617() {
 			"1. WARNING in X.java (at line 3)\n" +
 			"	Outer.Inner inner = new Outer().new Inner();\n" +
 			"	^^^^^^^^^^^\n" +
-			"Outer.Inner is a raw type. References to generic type Outer<T>.Inner<U> should be parameterized\n" +
+			"Outer.Inner is a raw type. References to generic type Outer.Inner<U> should be parameterized\n" +
 			"----------\n" +
 			"2. WARNING in X.java (at line 3)\n" +
 			"	Outer.Inner inner = new Outer().new Inner();\n" +
@@ -20485,12 +20485,12 @@ public void test0617() {
 			"3. WARNING in X.java (at line 3)\n" +
 			"	Outer.Inner inner = new Outer().new Inner();\n" +
 			"	                                    ^^^^^\n" +
-			"Outer.Inner is a raw type. References to generic type Outer<T>.Inner<U> should be parameterized\n" +
+			"Outer.Inner is a raw type. References to generic type Outer.Inner<U> should be parameterized\n" +
 			"----------\n" +
 			"4. WARNING in X.java (at line 4)\n" +
 			"	X x = inner.set(new X());\n" +
 			"	      ^^^^^^^^^^^^^^^^^^\n" +
-			"Type safety: The method set(Object) belongs to the raw type Outer.Inner. References to generic type Outer<T>.Inner<U> should be parameterized\n" +
+			"Type safety: The method set(Object) belongs to the raw type Outer.Inner. References to generic type Outer.Inner<U> should be parameterized\n" +
 			"----------\n" +
 			"5. ERROR in X.java (at line 4)\n" +
 			"	X x = inner.set(new X());\n" +
@@ -20500,7 +20500,7 @@ public void test0617() {
 			"6. ERROR in X.java (at line 6)\n" +
 			"	Outer<String>.Inner innerS = inner;\n" +
 			"	^^^^^^^^^^^^^^^^^^^\n" +
-			"The member type Outer<String>.Inner cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Outer<String>\n" +
+			"The member type Outer.Inner<U> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Outer<String>\n" +
 			"----------\n");
 	}
 	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=94644 - variation
@@ -20750,7 +20750,7 @@ public void test0617() {
 			"4. WARNING in X.java (at line 8)\n" +
 			"	for (Map.Entry e : myMap.entrySet())\n" +
 			"	     ^^^^^^^^^\n" +
-			"Map.Entry is a raw type. References to generic type Map<K,V>.Entry<K,V> should be parameterized\n" +
+			"Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized\n" +
 			"----------\n" +
 			"5. ERROR in X.java (at line 8)\n" +
 			"	for (Map.Entry e : myMap.entrySet())\n" +
@@ -20760,7 +20760,7 @@ public void test0617() {
 			"6. WARNING in X.java (at line 10)\n" +
 			"	Set<Map.Entry> set = myMap.entrySet();\n" +
 			"	    ^^^^^^^^^\n" +
-			"Map.Entry is a raw type. References to generic type Map<K,V>.Entry<K,V> should be parameterized\n" +
+			"Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized\n" +
 			"----------\n" +
 			"7. WARNING in X.java (at line 10)\n" +
 			"	Set<Map.Entry> set = myMap.entrySet();\n" +
@@ -20770,7 +20770,7 @@ public void test0617() {
 			"8. WARNING in X.java (at line 11)\n" +
 			"	for (Map.Entry e : set)\n" +
 			"	     ^^^^^^^^^\n" +
-			"Map.Entry is a raw type. References to generic type Map<K,V>.Entry<K,V> should be parameterized\n" +
+			"Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized\n" +
 			"----------\n");
 	}
 // **
@@ -22613,27 +22613,27 @@ public void test0705() {
 		"1. WARNING in X.java (at line 5)\n" +
 		"	((Map.Entry)o).setValue(\"bug\");\n" +
 		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-		"Type safety: The method setValue(Object) belongs to the raw type Map.Entry. References to generic type Map<K,V>.Entry<K,V> should be parameterized\n" +
+		"Type safety: The method setValue(Object) belongs to the raw type Map.Entry. References to generic type Map.Entry<K,V> should be parameterized\n" +
 		"----------\n" +
 		"2. WARNING in X.java (at line 5)\n" +
 		"	((Map.Entry)o).setValue(\"bug\");\n" +
 		"	  ^^^^^^^^^\n" +
-		"Map.Entry is a raw type. References to generic type Map<K,V>.Entry<K,V> should be parameterized\n" +
+		"Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized\n" +
 		"----------\n" +
 		"3. WARNING in X.java (at line 7)\n" +
 		"	Map.Entry me= (Map.Entry)o; \n" +
 		"	^^^^^^^^^\n" +
-		"Map.Entry is a raw type. References to generic type Map<K,V>.Entry<K,V> should be parameterized\n" +
+		"Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized\n" +
 		"----------\n" +
 		"4. WARNING in X.java (at line 7)\n" +
 		"	Map.Entry me= (Map.Entry)o; \n" +
 		"	               ^^^^^^^^^\n" +
-		"Map.Entry is a raw type. References to generic type Map<K,V>.Entry<K,V> should be parameterized\n" +
+		"Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized\n" +
 		"----------\n" +
 		"5. WARNING in X.java (at line 8)\n" +
 		"	me.setValue(\"ok\");\n" +
 		"	^^^^^^^^^^^^^^^^^\n" +
-		"Type safety: The method setValue(Object) belongs to the raw type Map.Entry. References to generic type Map<K,V>.Entry<K,V> should be parameterized\n" +
+		"Type safety: The method setValue(Object) belongs to the raw type Map.Entry. References to generic type Map.Entry<K,V> should be parameterized\n" +
 		"----------\n" +
 		"6. WARNING in X.java (at line 10)\n" +
 		"	((Vector)o).add(\"ok\");\n" +
@@ -24267,12 +24267,12 @@ public void test0755() {
 		"1. ERROR in X.java (at line 4)\n" +
 		"	X<?>.B[] b = new X<?>.B[1];\n" +
 		"	^^^^^^\n" +
-		"The member type X<?>.B cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<?>\n" +
+		"The member type X.B cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<?>\n" +
 		"----------\n" +
 		"2. ERROR in X.java (at line 4)\n" +
 		"	X<?>.B[] b = new X<?>.B[1];\n" +
 		"	                 ^^^^^^\n" +
-		"The member type X<?>.B cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<?>\n" +
+		"The member type X.B cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<?>\n" +
 		"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=99999 - variation
@@ -24316,7 +24316,7 @@ public void test0757() {
 		"1. WARNING in X.java (at line 7)\n" +
 		"	EntryMap.Entry internalGet(Object key) {\n" +
 		"	^^^^^^^^^^^^^^\n" +
-		"X.EntryMap.Entry is a raw type. References to generic type X<K,V>.EntryMap<K,V>.Entry should be parameterized\n" +
+		"X.EntryMap.Entry is a raw type. References to generic type X.EntryMap<K,V>.Entry should be parameterized\n" +
 		"----------\n" +
 		"2. WARNING in X.java (at line 12)\n" +
 		"	EntryMap<K,V>.Entry entry = internalGet(key);\n" +
@@ -24354,7 +24354,7 @@ public void test0758() {
 		"1. WARNING in X.java (at line 7)\n" +
 		"	EntryMap.Entry internalGet(Object key) {\n" +
 		"	^^^^^^^^^^^^^^\n" +
-		"X.EntryMap.Entry is a raw type. References to generic type X<K,V>.EntryMap<K,V>.Entry should be parameterized\n" +
+		"X.EntryMap.Entry is a raw type. References to generic type X.EntryMap<K,V>.Entry should be parameterized\n" +
 		"----------\n" +
 		"2. WARNING in X.java (at line 12)\n" +
 		"	EntryMap<K,V>.Entry entry = (EntryMap.Entry) internalGet(key);\n" +
@@ -24369,7 +24369,7 @@ public void test0758() {
 		"4. WARNING in X.java (at line 12)\n" +
 		"	EntryMap<K,V>.Entry entry = (EntryMap.Entry) internalGet(key);\n" +
 		"	                             ^^^^^^^^^^^^^^\n" +
-		"X.EntryMap.Entry is a raw type. References to generic type X<K,V>.EntryMap<K,V>.Entry should be parameterized\n" +
+		"X.EntryMap.Entry is a raw type. References to generic type X.EntryMap<K,V>.Entry should be parameterized\n" +
 		"----------\n" +
 		"5. ERROR in X.java (at line 14)\n" +
 		"	Zork z;\n" +
@@ -28225,7 +28225,7 @@ public void test0864() {
 		"1. ERROR in A.java (at line 13)\n" +
 		"	B<Object>.J<Object> bar();\n" +
 		"	^^^^^^^^^^^\n" +
-		"The member type B<Object>.J cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type B<Object>\n" +
+		"The member type B.J<E> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type B<Object>\n" +
 		"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=114304 - variation
@@ -28523,7 +28523,7 @@ public void test0872() {
 		"1. ERROR in X.java (at line 22)\n" +
 		"	M3<X>.N3<X> n = m.new N3<X>();\n" +
 		"	^^^^^^^^\n" +
-		"The member type X.M3<X>.N3 cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.M3<X>\n" +
+		"The member type X.M3.N3<U> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.M3<X>\n" +
 		"----------\n" +
 		"2. ERROR in X.java (at line 25)\n" +
 		"	static class N3<U> {\n" +
@@ -28533,7 +28533,7 @@ public void test0872() {
 		"3. ERROR in X.java (at line 30)\n" +
 		"	M4<X>.N4<X> n = m.new N4<X>();\n" +
 		"	^^^^^^^^\n" +
-		"The member type X.M4<X>.N4 cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.M4<X>\n" +
+		"The member type X.M4.N4<U> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.M4<X>\n" +
 		"----------\n");
 }
 public void test0873() {
@@ -32301,7 +32301,7 @@ public void test0970() {
 			"1. ERROR in X.java (at line 16)\n" +
 			"	I1<E>.I2<E> i1i2 = null;\n" +
 			"	^^^^^^^^\n" +
-			"The member type X.I1<E>.I2 cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.I1<E>\n" +
+			"The member type X.I1.I2<T> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.I1<E>\n" +
 			"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=136946 - variation
@@ -32336,37 +32336,37 @@ public void test0971() {
 			"2. WARNING in X.java (at line 3)\n" +
 			"	interface I2<T> extends I1 {\n" +
 			"	                        ^^\n" +
-			"X.I1 is a raw type. References to generic type X<T>.I1<T> should be parameterized\n" +
+			"X.I1 is a raw type. References to generic type X.I1<T> should be parameterized\n" +
 			"----------\n" +
 			"3. WARNING in X.java (at line 6)\n" +
 			"	interface I3<T> extends I1 {\n" +
 			"	                        ^^\n" +
-			"X.I1 is a raw type. References to generic type X<T>.I1<T> should be parameterized\n" +
+			"X.I1 is a raw type. References to generic type X.I1<T> should be parameterized\n" +
 			"----------\n" +
 			"4. WARNING in X.java (at line 9)\n" +
 			"	interface I4<T> extends I1.I2, I1.I3 {    \n" +
 			"	                        ^^^^^\n" +
-			"X.I1.I2 is a raw type. References to generic type X<T>.I1<T>.I2<T> should be parameterized\n" +
+			"X.I1.I2 is a raw type. References to generic type X.I1.I2<T> should be parameterized\n" +
 			"----------\n" +
 			"5. WARNING in X.java (at line 9)\n" +
 			"	interface I4<T> extends I1.I2, I1.I3 {    \n" +
 			"	                               ^^^^^\n" +
-			"X.I1.I3 is a raw type. References to generic type X<T>.I1<T>.I3<T> should be parameterized\n" +
+			"X.I1.I3 is a raw type. References to generic type X.I1.I3<T> should be parameterized\n" +
 			"----------\n" +
 			"6. WARNING in X.java (at line 14)\n" +
 			"	I1 i1 = null;\n" +
 			"	^^\n" +
-			"X.I1 is a raw type. References to generic type X<T>.I1<T> should be parameterized\n" +
+			"X.I1 is a raw type. References to generic type X.I1<T> should be parameterized\n" +
 			"----------\n" +
 			"7. WARNING in X.java (at line 15)\n" +
 			"	I1.I2 i2 = null;\n" +
 			"	^^^^^\n" +
-			"X.I1.I2 is a raw type. References to generic type X<T>.I1<T>.I2<T> should be parameterized\n" +
+			"X.I1.I2 is a raw type. References to generic type X.I1.I2<T> should be parameterized\n" +
 			"----------\n" +
 			"8. ERROR in X.java (at line 16)\n" +
 			"	I1<E>.I2 i1i2 = null;\n" +
 			"	^^^^^^^^\n" +
-			"The member type X.I1<E>.I2 cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.I1<E>\n" +
+			"The member type X.I1.I2<T> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.I1<E>\n" +
 			"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=137203
@@ -37668,7 +37668,7 @@ public void test1088() {
 			"2. WARNING in X.java (at line 5)\n" +
 			"	class M {} // hides member\n" +
 			"	      ^\n" +
-			"The type M is hiding the type X<M>.M\n" +
+			"The type M is hiding the type X.M\n" +
 			"----------\n" +
 			"3. WARNING in X.java (at line 11)\n" +
 			"	class T {}; // hiding warning\n" +
@@ -52098,8 +52098,31 @@ public void testBug433989a() {
 		"----------\n" + 
 		"1. ERROR in A.java (at line 7)\n" + 
 		"	new In.Inner<X>();\n" + 
+		"	    ^^^^^^^^\n" + 
+		"The member type A.Nested.In.Inner<X> must be qualified with a parameterized type, since it is not static\n" + 
+		"----------\n");
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=433989
+public void testBug433989b() {
+	this.runNegativeTest(
+		new String[] {
+			"A.java",
+			"class A<V> {\n" + 
+			"	public class Nested {\n" + 
+			"		public class In<U> {\n" + 
+			"			public class Inner<W> {}\n" + 
+			"		}\n" + 
+			"		public <X> void create() {\n" + 
+			"			new In.Inner<X>();\n" + 
+			"		}\n" + 
+			"	}\n" + 
+			"}"
+		},
+		"----------\n" + 
+		"1. ERROR in A.java (at line 7)\n" + 
+		"	new In.Inner<X>();\n" + 
 		"	    ^^\n" + 
-		"The member type A.Nested.In must be parameterized, since it is qualified with a parameterized type\n" + 
+		"The member type A<V>.Nested.In must be parameterized, since it is qualified with a parameterized type\n" + 
 		"----------\n");
 }
 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest.java
index 51513de..ac89ff7 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest.java
@@ -1953,7 +1953,7 @@ public void test339478h() {
 		"1. ERROR in X.java (at line 2)\n" + 
 		"	public void foo(Object x) throws X.Y<>.LException {\n" + 
 		"	                                 ^^^\n" + 
-		"Incorrect number of arguments for type X.Y; it cannot be parameterized with arguments <>\n" + 
+		"Incorrect number of arguments for type X.Y<T>; it cannot be parameterized with arguments <>\n" + 
 		"----------\n" + 
 		"2. WARNING in X.java (at line 5)\n" + 
 		"	static class LException extends Throwable {}\n" + 
@@ -5846,5 +5846,22 @@ public void testBug498057() {
 		null
 	);
 }
+public void testBug460491_comment23() {
+	runConformTest(
+		new String[] {
+			"PM.java",
+			"public class PM<E extends Enum<E>> {\n" + 
+			"	public PM(Class<E> clazz) {\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	enum MyEnum {\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		new PM<MyEnum>(MyEnum.class);\n" + 
+			"	}\n" + 
+			"}\n"
+		});
+}
 }
 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GrammarCoverageTests308.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GrammarCoverageTests308.java
index 1e11f50..5ba678d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GrammarCoverageTests308.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GrammarCoverageTests308.java
@@ -1160,12 +1160,12 @@ public class GrammarCoverageTests308 extends AbstractRegressionTest {
 					"1. WARNING in X.java (at line 3)\n" + 
 					"	java.util.Map.Entry [] e = (java.util.Map<String, String>.@Marker Entry []) null;\n" + 
 					"	^^^^^^^^^^^^^^^^^^^\n" + 
-					"Map.Entry is a raw type. References to generic type Map<K,V>.Entry<K,V> should be parameterized\n" + 
+					"Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized\n" + 
 					"----------\n" + 
 					"2. ERROR in X.java (at line 3)\n" + 
 					"	java.util.Map.Entry [] e = (java.util.Map<String, String>.@Marker Entry []) null;\n" + 
 					"	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-					"The member type Map<String,String>.Entry cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Map<String,String>\n" + 
+					"The member type Map.Entry<K,V> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Map<String,String>\n" + 
 					"----------\n" + 
 					"3. ERROR in X.java (at line 3)\n" + 
 					"	java.util.Map.Entry [] e = (java.util.Map<String, String>.@Marker Entry []) null;\n" + 
@@ -1590,7 +1590,7 @@ public class GrammarCoverageTests308 extends AbstractRegressionTest {
 				"9. ERROR in X.java (at line 5)\n" + 
 				"	Object r = (@Marker java. @Marker util.@Marker Map<@Marker String, @Marker String>.@Marker Entry @Marker []) null;\n" + 
 				"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"The member type Map<String,String>.Entry cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Map<String,String>\n" + 
+				"The member type Map.Entry<K,V> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Map<String,String>\n" + 
 				"----------\n" + 
 				"10. ERROR in X.java (at line 5)\n" + 
 				"	Object r = (@Marker java. @Marker util.@Marker Map<@Marker String, @Marker String>.@Marker Entry @Marker []) null;\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java
index 300af03..7b3680f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodVerifyTest.java
@@ -10124,7 +10124,7 @@ public void test169() {
 		"2. WARNING in X.java (at line 6)\n" + 
 		"	public R foo(A a, I i) { return null; }\n" + 
 		"	                  ^\n" + 
-		"X.I is a raw type. References to generic type X<T>.I<S> should be parameterized\n" + 
+		"X.I is a raw type. References to generic type X.I<S> should be parameterized\n" + 
 		"----------\n",
 		Excuse.EclipseHasSomeMoreWarnings
 	);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
index 0c38ebb..799b42e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
@@ -209,7 +209,7 @@ public void test006() {
 			"1. ERROR in X.java (at line 12)\n" + 
 			"	IX i = Outer<One, Two>.Inner<Three, Four>.Deeper<Five, Six<String>>.Leaf::<Blah, Blah>method;\n" + 
 			"	       ^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"The member type Outer<One,Two>.Inner cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Outer<One,Two>\n" + 
+			"The member type Outer.Inner<T3,T4> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Outer<One,Two>\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 12)\n" + 
 			"	IX i = Outer<One, Two>.Inner<Three, Four>.Deeper<Five, Six<String>>.Leaf::<Blah, Blah>method;\n" + 
@@ -6853,6 +6853,11 @@ public void test410114() throws IOException {
 						"	I i = Y<String>.Z<Integer>::<String> new;\n" + 
 						"	                             ^^^^^^\n" + 
 						"Unused type arguments for the non generic constructor Y<String>.Z<Integer>(Y<String>) of type Y<String>.Z<Integer>; it should not be parameterized with arguments <String>\n" + 
+						"----------\n" + 
+						"2. WARNING in Y.java (at line 14)\n" + 
+						"	i = Y.Z:: new;\n" + 
+						"	    ^^^^^^^^^\n" + 
+						"Type safety: The constructor Y.Z(Y) belongs to the raw type Y.Z. References to generic type Y<T>.Z<K> should be parameterized\n" + 
 						"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=412453,
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
index 62f1b8d..c212f51 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
@@ -2564,7 +2564,7 @@ public class NegativeTypeAnnotationTest extends AbstractRegressionTest {
 					"2. WARNING in A.java (at line 6)\n" + 
 					"	Object o = (@Marker @Annot A.@Marker B.@Marker C) null;\n" + 
 					"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-					"A.B.C is a raw type. References to generic type A<T>.B<T>.C<K,V> should be parameterized\n" + 
+					"A.B.C is a raw type. References to generic type A.B.C<K,V> should be parameterized\n" + 
 					"----------\n" + 
 					"3. ERROR in A.java (at line 6)\n" + 
 					"	Object o = (@Marker @Annot A.@Marker B.@Marker C) null;\n" + 
@@ -2579,7 +2579,7 @@ public class NegativeTypeAnnotationTest extends AbstractRegressionTest {
 					"5. WARNING in A.java (at line 7)\n" + 
 					"	Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" + 
 					"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-					"A.B.C is a raw type. References to generic type A<T>.B<T>.C<K,V> should be parameterized\n" + 
+					"A.B.C is a raw type. References to generic type A.B.C<K,V> should be parameterized\n" + 
 					"----------\n" + 
 					"6. ERROR in A.java (at line 7)\n" + 
 					"	Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index d97ca73..1696be5 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -12466,7 +12466,7 @@ public void testBug497698nestedinraw() {
 		"1. ERROR in test\\X.java (at line 8)\n" + 
 		"	public <V1> Or<V1> create() {\n" + 
 		"	            ^^\n" + 
-		"Incorrect number of arguments for type X<Z>.Or; it cannot be parameterized with arguments <V1>\n" + 
+		"Incorrect number of arguments for type X<Z>.Or<D,V>; it cannot be parameterized with arguments <V1>\n" + 
 		"----------\n"
 	);
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
index 59f2534..ef5c448 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
@@ -6352,7 +6352,7 @@ public class ASTConverter15JLS4Test extends ConverterTestSetup {
 	}
 
 	/*
-	 * Ensures that the key of parameterized type binding with a raw enclosing type is correct
+	 * Ensures that the key of static member of generic enclosing type is correct
 	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
 	 */
 	public void test0204() throws JavaModelException {
@@ -6365,11 +6365,54 @@ public class ASTConverter15JLS4Test extends ConverterTestSetup {
     		"}";
 	   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
 	   	assertBindingsEqual(
-	   		"LX<>.Y;",
+	   		"LX$Y;", // static member is not raw
 	   		bindings);
 	}
 
 	/*
+	 * Ensures that the key of non-static member with a generic enclosing type is correct
+	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
+	 */
+	public void test0204b() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter15/src/X.java", true/*resolve*/);
+    	String contents =
+    		"public class X<T> {\n" +
+    		"	class Y {\n" +
+    		"		/*start*/Y/*end*/ y;\n" +
+    		"	}\n" +
+    		"}";
+	   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
+	   	assertBindingsEqual(
+	   		"LX<LX;:TT;>.Y;", // non-static member is generic
+	   		bindings);
+	}
+
+	/*
+	 * Ensures that the key of non-static member with a raw enclosing type is correct
+	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
+	 */
+	public void test0204c() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter15/src/X.java", true/*resolve*/);
+    	String contents =
+    		"public class X<T> {\n" +
+    		"	class Y {\n" +
+    		"	}\n" +
+    		"	static X./*start*/Y/*end*/ y;\n" +
+    		"}";
+    	IJavaProject javaProject = this.workingCopy.getJavaProject();
+		String old = javaProject.getOption(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE, true);
+    	try {
+    		javaProject.setOption(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE, JavaCore.IGNORE);
+		   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
+		   	assertBindingsEqual(
+		   		"LX<>.Y;", // non-static member with raw enclosing
+		   		bindings);
+    	} finally {
+    		javaProject.setOption(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE, old);
+    	}
+	}
+
+	/*
 	 * Ensures that the declaration method binding and the reference method bindings are the same
 	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
 	 */
@@ -6384,7 +6427,7 @@ public class ASTConverter15JLS4Test extends ConverterTestSetup {
     		"    }\n" +
     		"}";
 	   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
-	   	assertFalse("Declaration and reference keys should not be the same", bindings[0].getKey().equals(bindings[1].getKey()));
+	   	assertTrue("Bindings should be the same", bindings[0] == bindings[1]); // generic outer is irrelevant because @interface is implicitly static
 	}
 
 	/*
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS8Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS8Test.java
index eaf9a49..171aac2 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS8Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS8Test.java
@@ -6339,7 +6339,7 @@ public class ASTConverter15JLS8Test extends ConverterTestSetup {
 	}
 
 	/*
-	 * Ensures that the key of parameterized type binding with a raw enclosing type is correct
+	 * Ensures that the key of static member of generic enclosing type is correct
 	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
 	 */
 	public void test0204() throws JavaModelException {
@@ -6352,11 +6352,54 @@ public class ASTConverter15JLS8Test extends ConverterTestSetup {
     		"}";
 	   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
 	   	assertBindingsEqual(
-	   		"LX<>.Y;",
+	   		"LX$Y;", // static member is not raw
 	   		bindings);
 	}
 
 	/*
+	 * Ensures that the key of non-static member with a generic enclosing type is correct
+	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
+	 */
+	public void test0204b() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter15/src/X.java", true/*resolve*/);
+    	String contents =
+    		"public class X<T> {\n" +
+    		"	class Y {\n" +
+    		"		/*start*/Y/*end*/ y;\n" +
+    		"	}\n" +
+    		"}";
+	   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
+	   	assertBindingsEqual(
+	   		"LX<LX;:TT;>.Y;", // non-static member is generic
+	   		bindings);
+	}
+
+	/*
+	 * Ensures that the key of non-static member with a raw enclosing type is correct
+	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
+	 */
+	public void test0204c() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter15/src/X.java", true/*resolve*/);
+    	String contents =
+    		"public class X<T> {\n" +
+    		"	class Y {\n" +
+    		"	}\n" +
+    		"	static X./*start*/Y/*end*/ y;\n" +
+    		"}";
+    	IJavaProject javaProject = this.workingCopy.getJavaProject();
+		String old = javaProject.getOption(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE, true);
+    	try {
+    		javaProject.setOption(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE, JavaCore.IGNORE);
+		   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
+		   	assertBindingsEqual(
+		   		"LX<>.Y;", // non-static member with raw enclosing
+		   		bindings);
+    	} finally {
+    		javaProject.setOption(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE, old);
+    	}
+	}
+
+	/*
 	 * Ensures that the declaration method binding and the reference method bindings are the same
 	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
 	 */
@@ -6371,7 +6414,7 @@ public class ASTConverter15JLS8Test extends ConverterTestSetup {
     		"    }\n" +
     		"}";
 	   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
-	   	assertFalse("Declaration and reference keys should not be the same", bindings[0].getKey().equals(bindings[1].getKey()));
+	   	assertTrue("Bindings should be the same", bindings[0] == bindings[1]); // generic outer is irrelevant because @interface is implicitly static
 	}
 
 	/*
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
index 2919eaa..d9b462c 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
@@ -6362,7 +6362,7 @@ public class ASTConverter15Test extends ConverterTestSetup {
 	}
 
 	/*
-	 * Ensures that the key of parameterized type binding with a raw enclosing type is correct
+	 * Ensures that the key of static member of generic enclosing type is correct
 	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
 	 */
 	public void test0204() throws JavaModelException {
@@ -6375,11 +6375,54 @@ public class ASTConverter15Test extends ConverterTestSetup {
     		"}";
 	   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
 	   	assertBindingsEqual(
-	   		"LX<>.Y;",
+	   		"LX$Y;", // static member is not raw
 	   		bindings);
 	}
 
 	/*
+	 * Ensures that the key of non-static member with a generic enclosing type is correct
+	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
+	 */
+	public void test0204b() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter15/src/X.java", true/*resolve*/);
+    	String contents =
+    		"public class X<T> {\n" +
+    		"	class Y {\n" +
+    		"		/*start*/Y/*end*/ y;\n" +
+    		"	}\n" +
+    		"}";
+	   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
+	   	assertBindingsEqual(
+	   		"LX<LX;:TT;>.Y;", // non-static member is generic
+	   		bindings);
+	}
+
+	/*
+	 * Ensures that the key of non-static member with a raw enclosing type is correct
+	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
+	 */
+	public void test0204c() throws JavaModelException {
+		this.workingCopy = getWorkingCopy("/Converter15/src/X.java", true/*resolve*/);
+    	String contents =
+    		"public class X<T> {\n" +
+    		"	class Y {\n" +
+    		"	}\n" +
+    		"	static X./*start*/Y/*end*/ y;\n" +
+    		"}";
+    	IJavaProject javaProject = this.workingCopy.getJavaProject();
+		String old = javaProject.getOption(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE, true);
+    	try {
+    		javaProject.setOption(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE, JavaCore.IGNORE);
+		   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
+		   	assertBindingsEqual(
+		   		"LX<>.Y;", // non-static member with raw enclosing
+		   		bindings);
+    	} finally {
+    		javaProject.setOption(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE, old);
+    	}
+	}
+
+	/*
 	 * Ensures that the declaration method binding and the reference method bindings are the same
 	 * (regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=83064)
 	 */
@@ -6394,7 +6437,7 @@ public class ASTConverter15Test extends ConverterTestSetup {
     		"    }\n" +
     		"}";
 	   	IBinding[] bindings = resolveBindings(contents, this.workingCopy);
-	   	assertFalse("Declaration and reference keys should not be the same", bindings[0].getKey().equals(bindings[1].getKey()));
+	   	assertTrue("Bindings should be the same", bindings[0] == bindings[1]); // generic outer is irrelevant because @interface is implicitly static
 	}
 
 	/*
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
index 645a2e9..8406110 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
@@ -14065,7 +14065,7 @@ public void testBug351426e() throws JavaModelException {
 	
 	assertResults(
 			"expectedTypesSignatures={Ltest.X$X1<Ljava.lang.String;>;}\n" +
-			"expectedTypesKeys={Ltest/X<>.X1<Ljava/lang/String;>;}",
+			"expectedTypesKeys={Ltest/X$X1<Ljava/lang/String;>;}",
 			requestor.getContext());
 	assertResults(
 			"X.X1<E>[TYPE_REF]{, test, Ltest.X$X1<TE;>;, null, null, replace[123, 123], token[123, 123], " + relevance + "}",
@@ -14157,7 +14157,7 @@ public void testBug351426h() throws JavaModelException {
 	
 	assertResults(
 			"expectedTypesSignatures={Ltest.X$X1<Ljava.lang.String;>;}\n" +
-			"expectedTypesKeys={Ltest/X<>.X1<Ljava/lang/String;>;}",
+			"expectedTypesKeys={Ltest/X$X1<Ljava/lang/String;>;}",
 			requestor.getContext());
 	assertResults(
 			"X.X1<E>[TYPE_REF]{, test, Ltest.X$X1<TE;>;, null, null, replace[113, 113], token[113, 113], " + relevance + "}",
@@ -14217,7 +14217,7 @@ public void testBug351426j() throws JavaModelException {
 	
 	assertResults(
 			"expectedTypesSignatures={Ltest.X$X1<Ljava.lang.String;>;}\n" +
-			"expectedTypesKeys={Ltest/X<>.X1<Ljava/lang/String;>;}",
+			"expectedTypesKeys={Ltest/X$X1<Ljava/lang/String;>;}",
 			requestor.getContext());
 	assertResults(
 			"X.X1<E>[TYPE_REF]{, test, Ltest.X$X1<TE;>;, null, null, replace[123, 123], token[123, 123], " + relevance + "}",
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index b87ffae..10645c1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -260,18 +260,17 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 			ReferenceBinding currentType = (ReferenceBinding) this.resolvedType;
 			if (qualifyingType == null) {
 				qualifyingType = currentType.enclosingType(); // if member type
-				if (qualifyingType != null) {
-					qualifyingType = currentType.isStatic()
-						? (ReferenceBinding) scope.environment().convertToRawType(qualifyingType, false /*do not force conversion of enclosing types*/)
-						: scope.environment().convertToParameterizedType(qualifyingType);
+				if (qualifyingType != null && !currentType.isStatic()) {
+					qualifyingType = scope.environment().convertToParameterizedType(qualifyingType);
 				}
 			} else {
 				if (this.annotations != null)
 					rejectAnnotationsOnStaticMemberQualififer(scope, currentType, this.annotations[i-1]);
 				if (typeIsConsistent && currentType.isStatic()
 						&& (qualifyingType.isParameterizedTypeWithActualArguments() || qualifyingType.isGenericType())) {
-					scope.problemReporter().staticMemberOfParameterizedType(this, scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), null, qualifyingType), i);
+					scope.problemReporter().staticMemberOfParameterizedType(this, currentType, qualifyingType, i);
 					typeIsConsistent = false;
+					qualifyingType = qualifyingType.actualType(); // avoid raw/parameterized enclosing of static member
 				}
 				ReferenceBinding enclosingType = currentType.enclosingType();
 				if (enclosingType != null && TypeBinding.notEquals(enclosingType.erasure(), qualifyingType.erasure())) { // qualifier != declaring/enclosing
@@ -328,13 +327,18 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 						return null;
 					}
 				}
-				// check parameterizing non-static member type of raw type
-				if (typeIsConsistent && !currentType.isStatic()) {
-					ReferenceBinding actualEnclosing = currentType.enclosingType();
-					if (actualEnclosing != null && actualEnclosing.isRawType()) {
-						scope.problemReporter().rawMemberTypeCannotBeParameterized(
-								this, scope.environment().createRawType(currentOriginal, actualEnclosing), argTypes);
-						typeIsConsistent = false;
+				// check parameterizing (non-)static member type of raw type
+				if (typeIsConsistent) {
+					if (currentType.isStatic()) {
+						if (qualifyingType != null && qualifyingType.isRawType())
+							this.typesPerToken[i-1] = qualifyingType = qualifyingType.actualType(); // revert rawification of enclosing, since its generics are inaccessible
+					} else {
+						ReferenceBinding actualEnclosing = currentType.enclosingType();
+						if (actualEnclosing != null && actualEnclosing.isRawType()) {
+							scope.problemReporter().rawMemberTypeCannotBeParameterized(
+									this, scope.environment().createRawType(currentOriginal, actualEnclosing), argTypes);
+							typeIsConsistent = false;
+						}
 					}
 				}
 				ParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(currentOriginal, argTypes, qualifyingType);
@@ -360,7 +364,8 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 					}
 	   			    qualifyingType = scope.environment().createRawType(currentOriginal, qualifyingType); // raw type
 				} else {
-					qualifyingType = (qualifyingType != null && qualifyingType.isParameterizedType())
+					boolean canSeeEnclosingTypeParameters = qualifyingType != null && qualifyingType.isParameterizedType() && !currentType.isStatic();
+					qualifyingType = canSeeEnclosingTypeParameters
 													? scope.environment().createParameterizedType(currentOriginal, null, qualifyingType)
 													: currentType;
 				}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
index 8b13a2f..42bad6b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
@@ -215,11 +215,8 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 				// be resilient, still attempt resolving arguments
 			}
 			enclosingType = currentType.enclosingType(); // if member type
-			if (enclosingType != null) {
-				enclosingType = currentType.isStatic()
-					? (ReferenceBinding) scope.environment().convertToRawType(enclosingType, false /*do not force conversion of enclosing types*/)
-					: scope.environment().convertToParameterizedType(enclosingType);
-				currentType = scope.environment().createParameterizedType((ReferenceBinding) currentType.erasure(), null /* no arg */, enclosingType);
+			if (enclosingType != null && !currentType.isStatic()) {
+				enclosingType = scope.environment().convertToParameterizedType(enclosingType);
 			}
 		} else { // resolving member type (relatively to enclosingType)
 			this.resolvedType = currentType = scope.getMemberType(this.token, enclosingType);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
index 66a7cfa..537bcbe 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
@@ -131,15 +131,19 @@ public class QualifiedTypeReference extends TypeReference {
 				if (enclosingType != null && TypeBinding.notEquals(enclosingType.erasure(), qualifiedType.erasure())) {
 					qualifiedType = enclosingType; // inherited member type, leave it associated with its enclosing rather than subtype
 				}
-				boolean rawQualified;
 				if (currentType.isGenericType()) {
 					qualifiedType = scope.environment().createRawType(currentType, qualifiedType);
-				} else if ((rawQualified = qualifiedType.isRawType()) && !currentType.isStatic()) {
-					qualifiedType = scope.environment().createRawType((ReferenceBinding)currentType.erasure(), qualifiedType);
-				} else if ((rawQualified || qualifiedType.isParameterizedType()) && TypeBinding.equalsEquals(qualifiedType.erasure(), currentType.enclosingType().erasure())) {
-					qualifiedType = scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), null, qualifiedType);
+				} else if (currentType.isStatic()) {
+					qualifiedType = currentType; // parameterization of enclosing is irrelevant in this case
 				} else {
-					qualifiedType = currentType;
+					boolean rawQualified = qualifiedType.isRawType();
+					if (rawQualified) {
+						qualifiedType = scope.environment().createRawType((ReferenceBinding)currentType.erasure(), qualifiedType);
+					} else if (qualifiedType.isParameterizedType() && TypeBinding.equalsEquals(qualifiedType.erasure(), currentType.enclosingType().erasure())) {
+						qualifiedType = scope.environment().createParameterizedType((ReferenceBinding)currentType.erasure(), null, qualifiedType);
+					} else {
+						qualifiedType = currentType;
+					}
 				}
 			} else {
 				qualifiedType = currentType.isGenericType() ? (ReferenceBinding)scope.environment().convertToRawType(currentType, false /*do not force conversion of enclosing types*/) : currentType;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
index aabd3c7..54c0643 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
@@ -464,7 +464,9 @@ public class ClassScope extends Scope {
 		ReferenceBinding enclosingType = sourceType.enclosingType();
 		boolean isMemberType = sourceType.isMemberType();
 		if (isMemberType) {
-			modifiers |= (enclosingType.modifiers & (ExtraCompilerModifiers.AccGenericSignature|ClassFileConstants.AccStrictfp));
+			if (!sourceType.isStatic())
+				modifiers |= (enclosingType.modifiers & ExtraCompilerModifiers.AccGenericSignature);
+			modifiers |= (enclosingType.modifiers & ClassFileConstants.AccStrictfp);
 			// checks for member types before local types to catch local members
 			if (enclosingType.isInterface())
 				modifiers |= ClassFileConstants.AccPublic;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 44ae3f0..f2bcf5a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -478,13 +478,13 @@ private PackageBinding computePackageFrom(char[][] constantPoolName, boolean isM
 public ReferenceBinding convertToParameterizedType(ReferenceBinding originalType) {
 	if (originalType != null) {
 		boolean isGeneric = originalType.isGenericType();
+		if (!isGeneric && originalType.isStatic())
+			return originalType;
 		ReferenceBinding originalEnclosingType = originalType.enclosingType();
 		ReferenceBinding convertedEnclosingType = originalEnclosingType;
 		boolean needToConvert = isGeneric;
-		if (originalEnclosingType != null) {
-			convertedEnclosingType = originalType.isStatic()
-				? (ReferenceBinding) convertToRawType(originalEnclosingType, false /*do not force conversion of enclosing types*/)
-				: convertToParameterizedType(originalEnclosingType);
+		if (originalEnclosingType != null && !originalType.isStatic()) {
+			convertedEnclosingType = convertToParameterizedType(originalEnclosingType);
 			needToConvert |= TypeBinding.notEquals(originalEnclosingType, convertedEnclosingType);
 		}
 		if (needToConvert) {
@@ -535,6 +535,7 @@ public TypeBinding convertToRawType(TypeBinding type, boolean forceRawEnclosingT
 			needToConvert = false;
 			break;
 	}
+	forceRawEnclosingType &= !type.isStatic();
 	ReferenceBinding originalEnclosing = originalType.enclosingType();
 	TypeBinding convertedType;
 	if (originalEnclosing == null) {
@@ -554,7 +555,7 @@ public TypeBinding convertToRawType(TypeBinding type, boolean forceRawEnclosingT
 		}
 		if (needToConvert) {
 			convertedType = createRawType((ReferenceBinding) originalType.erasure(), convertedEnclosing);
-		} else if (TypeBinding.notEquals(originalEnclosing, convertedEnclosing)) {
+		} else if (TypeBinding.notEquals(originalEnclosing, convertedEnclosing) && !originalType.isStatic()) {
 			convertedType = createParameterizedType((ReferenceBinding) originalType.erasure(), null, convertedEnclosing);
 		} else {
 			convertedType = originalType;
@@ -629,14 +630,15 @@ public TypeBinding convertUnresolvedBinaryToRawType(TypeBinding type) {
 	if (originalEnclosing == null) {
 		convertedType = needToConvert ? createRawType((ReferenceBinding)originalType.erasure(), null) : originalType;
 	} else {
+		if (!needToConvert && originalType.isStatic())
+			return originalType;
+
 		ReferenceBinding convertedEnclosing = (ReferenceBinding) convertUnresolvedBinaryToRawType(originalEnclosing);
 		if (TypeBinding.notEquals(convertedEnclosing, originalEnclosing)) {
-			needToConvert |= !((ReferenceBinding)originalType).isStatic();
+			needToConvert = true;
 		}
 		if (needToConvert) {
 			convertedType = createRawType((ReferenceBinding) originalType.erasure(), convertedEnclosing);
-		} else if (TypeBinding.notEquals(originalEnclosing, convertedEnclosing)) {
-			convertedType = createParameterizedType((ReferenceBinding) originalType.erasure(), null, convertedEnclosing);
 		} else {
 			convertedType = originalType;
 		}
@@ -1533,9 +1535,6 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 		if (CharOperation.indexOf('$', actualType.compoundName[actualType.compoundName.length - 1]) > 0)
 			actualType = (ReferenceBinding) BinaryTypeBinding.resolveType(actualType, this, false /* no raw conversion */); // must resolve member types before asking for enclosingType
 	ReferenceBinding actualEnclosing = actualType.enclosingType();
-	if (actualEnclosing != null) { // convert needed if read some static member type
-		actualEnclosing = (ReferenceBinding) convertToRawType(actualEnclosing, false /*do not force conversion of enclosing types*/);
-	}
 	AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(actualType.id), this, missingTypeNames);
 	TypeBinding[] typeArguments = getTypeArgumentsFromSignature(wrapper, staticVariables, enclosingType, actualType, missingTypeNames, walker);
 	ParameterizedTypeBinding parameterizedType = createParameterizedType(actualType, typeArguments, actualEnclosing, annotations);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index 9c041f9..e5e3085 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -76,6 +76,8 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	public ParameterizedTypeBinding(ReferenceBinding type, TypeBinding[] arguments,  ReferenceBinding enclosingType, LookupEnvironment environment){
 		this.environment = environment;
 		this.enclosingType = enclosingType; // never unresolved, never lazy per construction
+		if (type.isStatic() && arguments == null && !(this instanceof RawTypeBinding))
+			throw new IllegalStateException();
 		initialize(type, arguments);
 		if (type instanceof UnresolvedReferenceBinding)
 			((UnresolvedReferenceBinding) type).addWrapper(this, environment);
@@ -287,9 +289,6 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
         	default :
         		return;
         }
-        if (formalArguments == null || actualArguments == null) { // band-aid for https://bugs.eclipse.org/460491 TODO: remove once really fixed
-        	return;
-        }
         inferenceContext.depth++;
         for (int i = 0, length = formalArguments.length; i < length; i++) {
         	TypeBinding formalArgument = formalArguments[i];
@@ -496,7 +495,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		    	this.genericTypeSignature = this.type.signature();
 			} else {
 			    StringBuffer sig = new StringBuffer(10);
-			    if (isMemberType()) {
+			    if (isMemberType() && !isStatic()) {
 			    	ReferenceBinding enclosing = enclosingType();
 					char[] typeSig = enclosing.genericTypeSignature();
 					sig.append(typeSig, 0, typeSig.length-1);// copy all but trailing semicolon
@@ -923,11 +922,12 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 				int length = originalMemberTypes.length;
 				ReferenceBinding[] parameterizedMemberTypes = new ReferenceBinding[length];
 				// boolean isRaw = this.isRawType();
-				for (int i = 0; i < length; i++)
+				for (int i = 0; i < length; i++) {
 					// substitute all member types, so as to get updated enclosing types
-					parameterizedMemberTypes[i] = /*isRaw && originalMemberTypes[i].isGenericType()
-						? this.environment.createRawType(originalMemberTypes[i], this)
-						: */ this.environment.createParameterizedType(originalMemberTypes[i], null, this);
+					parameterizedMemberTypes[i] = originalMemberTypes[i].isStatic()
+							? originalMemberTypes[i]
+							: this.environment.createParameterizedType(originalMemberTypes[i], null, this);
+				}
 				this.memberTypes = parameterizedMemberTypes;
 			} finally {
 				// if the original fields cannot be retrieved (ex. AbortCompilation), then assume we do not have any fields
@@ -1016,19 +1016,24 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	 * @see org.eclipse.jdt.internal.compiler.lookup.Binding#readableName()
 	 */
 	public char[] readableName() {
+		return readableName(true);
+	}
+	public char[] readableName(boolean showGenerics) {
 	    StringBuffer nameBuffer = new StringBuffer(10);
 		if (isMemberType()) {
-			nameBuffer.append(CharOperation.concat(enclosingType().readableName(), this.sourceName, '.'));
+			nameBuffer.append(CharOperation.concat(enclosingType().readableName(showGenerics && !isStatic()), this.sourceName, '.'));
 		} else {
 			nameBuffer.append(CharOperation.concatWith(this.type.compoundName, '.'));
 		}
-		if (this.arguments != null && this.arguments.length > 0) { // empty arguments array happens when PTB has been created just to capture type annotations
-			nameBuffer.append('<');
-		    for (int i = 0, length = this.arguments.length; i < length; i++) {
-		        if (i > 0) nameBuffer.append(',');
-		        nameBuffer.append(this.arguments[i].readableName());
-		    }
-		    nameBuffer.append('>');
+		if (showGenerics) {
+			if (this.arguments != null && this.arguments.length > 0) { // empty arguments array happens when PTB has been created just to capture type annotations
+				nameBuffer.append('<');
+			    for (int i = 0, length = this.arguments.length; i < length; i++) {
+			        if (i > 0) nameBuffer.append(',');
+			        nameBuffer.append(this.arguments[i].readableName());
+			    }
+			    nameBuffer.append('>');
+			}
 		}
 		int nameLength = nameBuffer.length();
 		char[] readableName = new char[nameLength];
@@ -1087,19 +1092,24 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	 * @see org.eclipse.jdt.internal.compiler.lookup.Binding#shortReadableName()
 	 */
 	public char[] shortReadableName() {
+		return shortReadableName(true);
+	}
+	public char[] shortReadableName(boolean showGenerics) {
 	    StringBuffer nameBuffer = new StringBuffer(10);
 		if (isMemberType()) {
-			nameBuffer.append(CharOperation.concat(enclosingType().shortReadableName(), this.sourceName, '.'));
+			nameBuffer.append(CharOperation.concat(enclosingType().shortReadableName(showGenerics && !isStatic()), this.sourceName, '.'));
 		} else {
 			nameBuffer.append(this.type.sourceName);
 		}
-		if (this.arguments != null && this.arguments.length > 0) { // empty arguments array happens when PTB has been created just to capture type annotations
-			nameBuffer.append('<');
-		    for (int i = 0, length = this.arguments.length; i < length; i++) {
-		        if (i > 0) nameBuffer.append(',');
-		        nameBuffer.append(this.arguments[i].shortReadableName());
-		    }
-		    nameBuffer.append('>');
+		if (showGenerics) {
+			if (this.arguments != null && this.arguments.length > 0) { // empty arguments array happens when PTB has been created just to capture type annotations
+				nameBuffer.append('<');
+			    for (int i = 0, length = this.arguments.length; i < length; i++) {
+			        if (i > 0) nameBuffer.append(',');
+			        nameBuffer.append(this.arguments[i].shortReadableName());
+			    }
+			    nameBuffer.append('>');
+			}
 		}
 		int nameLength = nameBuffer.length();
 		char[] shortReadableName = new char[nameLength];
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
index dfeb526..c930888 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
@@ -62,10 +62,20 @@ public class RawTypeBinding extends ParameterizedTypeBinding {
 
 	public char[] computeUniqueKey(boolean isLeaf) {
 	    StringBuffer sig = new StringBuffer(10);
-		if (isMemberType() && enclosingType().isParameterizedType()) {
-		    char[] typeSig = enclosingType().computeUniqueKey(false/*not a leaf*/);
-		    sig.append(typeSig, 0, typeSig.length-1); // copy all but trailing semicolon
-		    sig.append('.').append(sourceName()).append('<').append('>').append(';');
+		if (isMemberType() && (enclosingType().isParameterizedType() || enclosingType().isRawType())) {
+			if (isStatic()) {
+			    char[] typeSig = enclosingType().signature(); // don't consider generics from enclosing of static member
+			    sig.append(typeSig, 0, typeSig.length-1); // copy all but trailing semicolon
+			    sig.append('$'); // for consistency with keys prior to https://bugs.eclipse.org/460491
+			} else {
+				char[] typeSig = enclosingType().computeUniqueKey(false/*not a leaf*/);
+				sig.append(typeSig, 0, typeSig.length-1); // copy all but trailing semicolon
+				sig.append('.');
+			}
+			sig.append(sourceName());
+		    if (genericType().typeVariables() != Binding.NO_TYPE_VARIABLES) // don't show <> if raw only due to a generic enclosing
+		    	sig.append('<').append('>');
+		    sig.append(';');
 		} else {
 		     sig.append(genericType().computeUniqueKey(false/*not a leaf*/));
 		     sig.insert(sig.length()-1, "<>"); //$NON-NLS-1$
@@ -252,10 +262,10 @@ public class RawTypeBinding extends ParameterizedTypeBinding {
 	/**
 	 * @see org.eclipse.jdt.internal.compiler.lookup.Binding#readableName()
 	 */
-	public char[] readableName() /*java.lang.Object,  p.X<T> */ {
+	public char[] readableName(boolean showGenerics) /*java.lang.Object,  p.X<T> */ {
 	    char[] readableName;
 		if (isMemberType()) {
-			readableName = CharOperation.concat(enclosingType().readableName(), this.sourceName, '.');
+			readableName = CharOperation.concat(enclosingType().readableName(showGenerics && !isStatic()), this.sourceName, '.');
 		} else {
 			readableName = CharOperation.concatWith(actualType().compoundName, '.');
 		}
@@ -265,10 +275,10 @@ public class RawTypeBinding extends ParameterizedTypeBinding {
 	/**
 	 * @see org.eclipse.jdt.internal.compiler.lookup.Binding#shortReadableName()
 	 */
-	public char[] shortReadableName() /*Object*/ {
+	public char[] shortReadableName(boolean showGenerics) /*Object*/ {
 	    char[] shortReadableName;
 		if (isMemberType()) {
-			shortReadableName = CharOperation.concat(enclosingType().shortReadableName(), this.sourceName, '.');
+			shortReadableName = CharOperation.concat(enclosingType().shortReadableName(showGenerics && !isStatic()), this.sourceName, '.');
 		} else {
 			shortReadableName = actualType().sourceName;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 86464d4..c8157b4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -396,7 +396,7 @@ public boolean canBeSeenBy(Scope scope) {
 
 public char[] computeGenericTypeSignature(TypeVariableBinding[] typeVariables) {
 
-	boolean isMemberOfGeneric = isMemberType() && (enclosingType().modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0;
+	boolean isMemberOfGeneric = isMemberType() && !isStatic() && (enclosingType().modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0;
 	if (typeVariables == Binding.NO_TYPE_VARIABLES && !isMemberOfGeneric) {
 		return signature();
 	}
@@ -1628,24 +1628,29 @@ public char[] qualifiedSourceName() {
  * NOTE: This method should only be used during/after code gen.
  */
 public char[] readableName() /*java.lang.Object,  p.X<T> */ {
+	return readableName(true);
+}
+public char[] readableName(boolean showGenerics) /*java.lang.Object,  p.X<T> */ {
     char[] readableName;
 	if (isMemberType()) {
-		readableName = CharOperation.concat(enclosingType().readableName(), this.sourceName, '.');
+		readableName = CharOperation.concat(enclosingType().readableName(showGenerics && !isStatic()), this.sourceName, '.');
 	} else {
 		readableName = CharOperation.concatWith(this.compoundName, '.');
 	}
-	TypeVariableBinding[] typeVars;
-	if ((typeVars = typeVariables()) != Binding.NO_TYPE_VARIABLES) {
-	    StringBuffer nameBuffer = new StringBuffer(10);
-	    nameBuffer.append(readableName).append('<');
-	    for (int i = 0, length = typeVars.length; i < length; i++) {
-	        if (i > 0) nameBuffer.append(',');
-	        nameBuffer.append(typeVars[i].readableName());
-	    }
-	    nameBuffer.append('>');
-		int nameLength = nameBuffer.length();
-		readableName = new char[nameLength];
-		nameBuffer.getChars(0, nameLength, readableName, 0);
+	if (showGenerics) {
+		TypeVariableBinding[] typeVars;
+		if ((typeVars = typeVariables()) != Binding.NO_TYPE_VARIABLES) {
+		    StringBuffer nameBuffer = new StringBuffer(10);
+		    nameBuffer.append(readableName).append('<');
+		    for (int i = 0, length = typeVars.length; i < length; i++) {
+		        if (i > 0) nameBuffer.append(',');
+		        nameBuffer.append(typeVars[i].readableName());
+		    }
+		    nameBuffer.append('>');
+			int nameLength = nameBuffer.length();
+			readableName = new char[nameLength];
+			nameBuffer.getChars(0, nameLength, readableName, 0);
+		}
 	}
 	return readableName;
 }
@@ -1771,24 +1776,29 @@ char[] nullAnnotatedShortReadableName(CompilerOptions options) {
 }
 
 public char[] shortReadableName() /*Object*/ {
+	return shortReadableName(true);
+}
+public char[] shortReadableName(boolean showGenerics) /*Object*/ {
 	char[] shortReadableName;
 	if (isMemberType()) {
-		shortReadableName = CharOperation.concat(enclosingType().shortReadableName(), this.sourceName, '.');
+		shortReadableName = CharOperation.concat(enclosingType().shortReadableName(showGenerics && !isStatic()), this.sourceName, '.');
 	} else {
 		shortReadableName = this.sourceName;
 	}
-	TypeVariableBinding[] typeVars;
-	if ((typeVars = typeVariables()) != Binding.NO_TYPE_VARIABLES) {
-	    StringBuffer nameBuffer = new StringBuffer(10);
-	    nameBuffer.append(shortReadableName).append('<');
-	    for (int i = 0, length = typeVars.length; i < length; i++) {
-	        if (i > 0) nameBuffer.append(',');
-	        nameBuffer.append(typeVars[i].shortReadableName());
-	    }
-	    nameBuffer.append('>');
-		int nameLength = nameBuffer.length();
-		shortReadableName = new char[nameLength];
-		nameBuffer.getChars(0, nameLength, shortReadableName, 0);
+	if (showGenerics) {
+		TypeVariableBinding[] typeVars;
+		if ((typeVars = typeVariables()) != Binding.NO_TYPE_VARIABLES) {
+		    StringBuffer nameBuffer = new StringBuffer(10);
+		    nameBuffer.append(shortReadableName).append('<');
+		    for (int i = 0, length = typeVars.length; i < length; i++) {
+		        if (i > 0) nameBuffer.append(',');
+		        nameBuffer.append(typeVars[i].shortReadableName());
+		    }
+		    nameBuffer.append('>');
+			int nameLength = nameBuffer.length();
+			shortReadableName = new char[nameLength];
+			nameBuffer.getChars(0, nameLength, shortReadableName, 0);
+		}
 	}
 	return shortReadableName;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 7c8dc05..b96939c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -490,7 +490,7 @@ public abstract class Scope {
 					ParameterizedTypeBinding originalParameterizedType = (ParameterizedTypeBinding) originalType;
 					ReferenceBinding originalEnclosing = originalType.enclosingType();
 					ReferenceBinding substitutedEnclosing = originalEnclosing;
-					if (originalEnclosing != null) {
+					if (originalEnclosing != null && !originalType.isStatic()) {
 						substitutedEnclosing = (ReferenceBinding) substitute(substitution, originalEnclosing);
 						if (isMemberTypeOfRaw(originalType, substitutedEnclosing))
 							return originalParameterizedType.environment.createRawType(
@@ -571,7 +571,7 @@ public abstract class Scope {
 					}
 	
 				    // treat as if parameterized with its type variables (non generic type gets 'null' arguments)
-					if (substitutedEnclosing != originalEnclosing) { //$IDENTITY-COMPARISON$
+					if (substitutedEnclosing != originalEnclosing && !originalType.isStatic()) { //$IDENTITY-COMPARISON$
 						return substitution.isRawSubstitution()
 							? substitution.environment().createRawType(originalReferenceType, substitutedEnclosing, originalType.getTypeAnnotations())
 							:  substitution.environment().createParameterizedType(originalReferenceType, null, substitutedEnclosing, originalType.getTypeAnnotations());
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
index 7183878..a1e7e4e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
@@ -37,8 +37,9 @@ public class SyntheticFactoryMethodBinding extends MethodBinding {
 	    if method type arguments is not empty materialize the parameterized generic constructor 
 	*/
 	public ParameterizedMethodBinding applyTypeArgumentsOnConstructor(TypeBinding[] typeArguments, TypeBinding[] constructorTypeArguments, boolean inferredWithUncheckedConversion) {
-		ReferenceBinding parameterizedType = this.environment.createParameterizedType(this.declaringClass, typeArguments,
-																						this.enclosingType);
+		ReferenceBinding parameterizedType = typeArguments == null
+				? this.environment.createRawType(this.declaringClass, this.enclosingType)
+				: this.environment.createParameterizedType(this.declaringClass, typeArguments, this.enclosingType);
 		for (MethodBinding parameterizedMethod : parameterizedType.methods()) {
 			if (parameterizedMethod.original() == this.staticFactoryFor)
 				return (constructorTypeArguments.length > 0 || inferredWithUncheckedConversion)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index a7b8e8b..3845a58 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -7654,7 +7654,7 @@ public void staticInheritedMethodConflicts(SourceTypeBinding type, MethodBinding
 		type.sourceStart(),
 		type.sourceEnd());
 }
-public void staticMemberOfParameterizedType(ASTNode location, ReferenceBinding type, int index) {
+public void staticMemberOfParameterizedType(ASTNode location, ReferenceBinding type, ReferenceBinding qualifyingType, int index) {
 	if (location == null) { // binary case
 	    this.handle(
 			IProblem.StaticMemberOfParameterizedType,
@@ -7672,8 +7672,8 @@ public void staticMemberOfParameterizedType(ASTNode location, ReferenceBinding t
 	}*/
     this.handle(
 		IProblem.StaticMemberOfParameterizedType,
-		new String[] {new String(type.readableName()), new String(type.enclosingType().readableName()), },
-		new String[] {new String(type.shortReadableName()), new String(type.enclosingType().shortReadableName()), },
+		new String[] {new String(type.readableName()), new String(qualifyingType.readableName()), },
+		new String[] {new String(type.shortReadableName()), new String(qualifyingType.shortReadableName()), },
 		location.sourceStart,
 		nodeSourceEnd(null, location, index));
 }
commit 6318793760c6e15de1935159d9bdeb4d4fe13e64
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Fri Jul 29 23:57:44 2016 +0200

    Bug 460491 - [compiler] don't consider parameter-less static member type
    with generic enclosing as parameterized (edit)
    
    - test and fix for re-open via comment 30
    - skip bogus type arguments in .class files generated by earlier
    compiler versions
    
    Change-Id: I41cb1f3439fa0612f3be7fd8ff88c13376fb7d57
    Also-by: Till Brychcy <register.eclipse@brychcy.de>

45	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
66	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
-	-	org.eclipse.jdt.core.tests.model/workspace/NullAnnotations/lib/bug460491-compiled-with-4.6.jar
1	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
22	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
1	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
index 20affbf..40cdcd1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
@@ -19,6 +19,8 @@ import junit.framework.Test;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.dom.AST;
 import org.eclipse.jdt.core.dom.ASTNode;
@@ -36,6 +38,7 @@ import org.eclipse.jdt.core.dom.Expression;
 import org.eclipse.jdt.core.dom.ExpressionStatement;
 import org.eclipse.jdt.core.dom.FieldDeclaration;
 import org.eclipse.jdt.core.dom.IAnnotationBinding;
+import org.eclipse.jdt.core.dom.IBinding;
 import org.eclipse.jdt.core.dom.IMethodBinding;
 import org.eclipse.jdt.core.dom.ITypeBinding;
 import org.eclipse.jdt.core.dom.IVariableBinding;
@@ -47,6 +50,7 @@ import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.ParameterizedType;
 import org.eclipse.jdt.core.dom.ParenthesizedExpression;
 import org.eclipse.jdt.core.dom.PrefixExpression;
+import org.eclipse.jdt.core.dom.QualifiedName;
 import org.eclipse.jdt.core.dom.QualifiedType;
 import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SimpleName;
@@ -2652,4 +2656,45 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 			deleteFile("/Converter18/src/X.java");
 		}
 	}
+	public void testBug460491_comment30() throws CoreException {
+		// placed in this suite because we need type annotations enabled
+		IPackageFragmentRoot srcRoot = this.currentProject.getPackageFragmentRoots()[0];
+		assertFalse(srcRoot.isReadOnly());
+		createFolder(srcRoot.getPath().append("test"));
+		IPackageFragment testPackage = srcRoot.getPackageFragment("test");
+		
+		testPackage.createCompilationUnit("Generic.java", 
+				"package test;\n" + 
+				"\n" + 
+				"public class Generic<T> {\n" + 
+				"	public static class NestedStatic {\n" + 
+				"		public static final String X = \"x\";\n" + 
+				"	}\n" + 
+				"}\n",
+				true,
+				null);
+		String contents =
+				"package test;\n" + 
+				"\n" + 
+				"public class Usage {\n" + 
+				"	String f() {\n" + 
+				"		return Generic.NestedStatic.X;\n" + 
+				"	}\n" + 
+				"}\n";
+		ICompilationUnit cu = testPackage.createCompilationUnit("Usage.java", contents, true, null);
+		ASTNode node = buildAST(contents, cu, false);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+
+		List types = compilationUnit.types();
+		assertEquals(1, types.size());
+		List methods = ((TypeDeclaration) types.get(0)).bodyDeclarations();
+		assertEquals(1, methods.size());
+		List statements = ((MethodDeclaration) methods.get(0)).getBody().statements();
+		assertEquals(1, statements.size());
+		
+		Expression expression = ((ReturnStatement) statements.get(0)).getExpression();
+		IBinding binding = ((QualifiedName) expression).getQualifier().resolveBinding();
+		assertNotNull(binding);
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
index 9756e12..3b006e7c 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
@@ -805,4 +805,70 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 				deleteProject(project);
 		}
 	}
+	
+	public void testBug460491WithOldBinary() throws CoreException, InterruptedException, IOException {
+		IJavaProject project = null;
+    	try {
+			project = createJavaProject("Bug460491", new String[] {"src"}, new String[] {"JCL18_LIB", this.ANNOTATION_LIB, testJarPath("bug460491-compiled-with-4.6.jar")}, "bin", "1.8");
+			project.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+
+			// bug460491-compiled-with-4.6.jar contains classes compiled with eclipse 4.6:
+			/*-
+				package test1;
+				
+				import org.eclipse.jdt.annotation.DefaultLocation;
+				import org.eclipse.jdt.annotation.NonNullByDefault;
+				import org.eclipse.jdt.annotation.Nullable;
+				
+				public abstract class Base<B> {
+				   static public class Static {
+				    public class Middle1 {
+				     public class Middle2<M> {
+				       public class Middle3 {
+				        public class GenericInner<T> {
+				        }
+				       }
+				     }
+				   }
+				  }
+				
+				  @NonNullByDefault(DefaultLocation.PARAMETER)
+				  public Object method( Static.Middle1.Middle2<Object>.Middle3.@Nullable GenericInner<String> nullable) {
+				    return new Object();
+				  }
+				}
+			 */
+
+			this.createFolder("/Bug460491/src/test2");
+			String c2SourceString =
+					"package test2;\n" +
+					"\n" +
+					"import test1.Base;\n" +
+					"\n" +
+					"class Derived extends Base<Object> {\n" +
+					"  void test() {\n" +
+					"    method(null);\n" +
+					"  }\n" +
+					"}\n";
+			this.createFile(
+				"/Bug460491/src/test2/Derived.java",
+	    			c2SourceString);
+
+			char[] c2SourceChars = c2SourceString.toCharArray();
+			this.problemRequestor.initialize(c2SourceChars);
+
+			getCompilationUnit("/Bug460491/src/test2/Derived.java").getWorkingCopy(this.wcOwner, null);
+			// enable this after bug 492322 is fixed:
+			/*-
+				assertProblems(
+						"Unexpected problems",
+						"----------\n" +
+						"----------\n"
+						);
+			*/
+		} finally {
+			if (project != null)
+				deleteProject(project);
+		}
+}	
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/NullAnnotations/lib/bug460491-compiled-with-4.6.jar b/org.eclipse.jdt.core.tests.model/workspace/NullAnnotations/lib/bug460491-compiled-with-4.6.jar
new file mode 100644
index 0000000..97cda75
Binary files /dev/null and b/org.eclipse.jdt.core.tests.model/workspace/NullAnnotations/lib/bug460491-compiled-with-4.6.jar differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index 10645c1..c23ab21 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -364,10 +364,7 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 					}
 	   			    qualifyingType = scope.environment().createRawType(currentOriginal, qualifyingType); // raw type
 				} else {
-					boolean canSeeEnclosingTypeParameters = qualifyingType != null && qualifyingType.isParameterizedType() && !currentType.isStatic();
-					qualifyingType = canSeeEnclosingTypeParameters
-													? scope.environment().createParameterizedType(currentOriginal, null, qualifyingType)
-													: currentType;
+					qualifyingType = scope.environment().maybeCreateParameterizedType(currentOriginal, qualifyingType);
 				}
 			}
 			if (isTypeUseDeprecated(qualifyingType, scope))
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index f2bcf5a..c2c20d2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -980,6 +980,14 @@ public ParameterizedTypeBinding createParameterizedType(ReferenceBinding generic
 public ParameterizedTypeBinding createParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, ReferenceBinding enclosingType, AnnotationBinding [] annotations) {
 	return this.typeSystem.getParameterizedType(genericType, typeArguments, enclosingType, annotations);
 }
+public ReferenceBinding maybeCreateParameterizedType(ReferenceBinding nonGenericType, ReferenceBinding enclosingType) {
+	boolean canSeeEnclosingTypeParameters = enclosingType != null 
+			&& (enclosingType.isParameterizedType() | enclosingType.isRawType())
+			&& !nonGenericType.isStatic();
+	if (canSeeEnclosingTypeParameters)
+		return createParameterizedType(nonGenericType, null, enclosingType);
+	return nonGenericType;
+}
 
 public TypeBinding createAnnotatedType(TypeBinding type, AnnotationBinding[][] annotations) {
 	return this.typeSystem.getAnnotatedType(type, annotations);
@@ -1537,29 +1545,37 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 	ReferenceBinding actualEnclosing = actualType.enclosingType();
 	AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(actualType.id), this, missingTypeNames);
 	TypeBinding[] typeArguments = getTypeArgumentsFromSignature(wrapper, staticVariables, enclosingType, actualType, missingTypeNames, walker);
-	ParameterizedTypeBinding parameterizedType = createParameterizedType(actualType, typeArguments, actualEnclosing, annotations);
+	ReferenceBinding currentType = createParameterizedType(actualType, typeArguments, actualEnclosing, annotations);
 
 	while (wrapper.signature[wrapper.start] == '.') {
 		wrapper.start++; // skip '.'
 		int memberStart = wrapper.start;
 		char[] memberName = wrapper.nextWord();
-		BinaryTypeBinding.resolveType(parameterizedType, this, false);
-		ReferenceBinding memberType = parameterizedType.genericType().getMemberType(memberName);
+		BinaryTypeBinding.resolveType(currentType, this, false);
+		ReferenceBinding enclosing = (currentType instanceof ParameterizedTypeBinding) ? ((ParameterizedTypeBinding) currentType).genericType() : currentType;
+		ReferenceBinding memberType = enclosing.getMemberType(memberName);
 		// need to protect against the member type being null when the signature is invalid
 		if (memberType == null)
-			this.problemReporter.corruptedSignature(parameterizedType, wrapper.signature, memberStart); // aborts
+			this.problemReporter.corruptedSignature(currentType, wrapper.signature, memberStart); // aborts
 		walker = walker.toNextNestedType();
 		annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(memberType.id), this, missingTypeNames);
+		if (memberType.isStatic()) {
+			if (annotations != Binding.NO_ANNOTATIONS)
+				currentType = (ReferenceBinding) createAnnotatedType(memberType, annotations);
+			else
+				currentType = memberType;
+			continue; // skip inaccessible type arguments of outer if any
+		}
 		if (wrapper.signature[wrapper.start] == '<') {
 			wrapper.start++; // skip '<'
 			typeArguments = getTypeArgumentsFromSignature(wrapper, staticVariables, enclosingType, memberType, missingTypeNames, walker);
 		} else {
 			typeArguments = null;
 		}
-		parameterizedType = createParameterizedType(memberType, typeArguments, parameterizedType, annotations);
+		currentType = createParameterizedType(memberType, typeArguments, currentType, annotations);
 	}
 	wrapper.start++; // skip ';'
-	return dimension == 0 ? (TypeBinding) parameterizedType : createArrayType(parameterizedType, dimension, AnnotatableTypeSystem.flattenedAnnotations(annotationsOnDimensions));
+	return dimension == 0 ? (TypeBinding) currentType : createArrayType(currentType, dimension, AnnotatableTypeSystem.flattenedAnnotations(annotationsOnDimensions));
 }
 
 private TypeBinding getTypeFromTypeVariable(TypeVariableBinding typeVariableBinding, int dimension, AnnotationBinding [][] annotationsOnDimensions, ITypeAnnotationWalker walker, char [][][] missingTypeNames) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index d7854b4..ba4457c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -3387,9 +3387,7 @@ public abstract class Scope {
 			if (typeBinding.isGenericType()) {
 				qualifiedType = environment().createRawType(typeBinding, qualifiedType);
 			} else {
-				qualifiedType = (qualifiedType != null && (qualifiedType.isRawType() || qualifiedType.isParameterizedType()))
-					? environment().createParameterizedType(typeBinding, null, qualifiedType)
-					: typeBinding;
+				qualifiedType = environment().maybeCreateParameterizedType(typeBinding, qualifiedType);
 			}
 		}
 		return qualifiedType;
