commit 8b22a6a060913ad4f5ee39ebcec264e365a32f19
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Jul 25 18:44:06 2017 +0200

    Bug 519963 - [9] Clean-up of the new name lookup
    - clarification of SHARED vs. ROOT_ONLY fields in LE
    
    Change-Id: Ie008577c5fbceb83a29219dadef0fb8ce8590e05

2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
15	14	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index b1ffdcf..76927c3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -644,7 +644,7 @@ private MethodBinding findStaticMethod(ReferenceBinding currentType, char[] sele
 }
 ImportBinding[] getDefaultImports() {
 	// initialize the default imports if necessary... share the default java.lang.* import
-	if (this.environment.defaultImports != null) return this.environment.defaultImports;
+	if (this.environment.root.defaultImports != null) return this.environment.root.defaultImports;
 
 	Binding importBinding = this.environment.getTopLevelPackage(TypeConstants.JAVA);
 	if (importBinding != null)
@@ -660,7 +660,7 @@ ImportBinding[] getDefaultImports() {
 		importBinding = missingObject.fPackage;
 	}
 
-	return this.environment.defaultImports = new ImportBinding[] {new ImportBinding(TypeConstants.JAVA_LANG, true, importBinding, null)};
+	return this.environment.root.defaultImports = new ImportBinding[] {new ImportBinding(TypeConstants.JAVA_LANG, true, importBinding, null)};
 }
 // NOT Public API
 public final Binding getImport(char[][] compoundName, boolean onDemand, boolean isStaticImport) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index d3288bb..27f324b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -72,13 +72,13 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 	 * Map from typeBinding -> accessRestriction rule
 	 */
 	private Map accessRestrictions;
-	ImportBinding[] defaultImports;
+	ImportBinding[] defaultImports;				// ROOT_ONLY
 	/**
 	 * The root environment driving the current compilation.
 	 * Other mutable fields in this class marked as ROOT_ONLY must always be accessed from the root environment.
 	 * It is assumed that external clients only know the root environment, whereas calls internally in the compiler
 	 * have to delegate to root where necessary.
-	 * Immutable fields with "global" semantics are shared among environments via aliasing.
+	 * Immutable fields with "global" semantics are SHARED among environments via aliasing.
 	 */
 	public final LookupEnvironment root;
 	public ModuleBinding UnNamedModule;
@@ -87,22 +87,22 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 	public PackageBinding defaultPackage;
 	/** All visible toplevel packages, i.e. observable packages associated with modules read by the current module. */
 	HashtableOfPackage knownPackages;
-	private int lastCompletedUnitIndex = -1; // ROOT_ONLY
-	private int lastUnitIndex = -1; // ROOT_ONLY
+	private int lastCompletedUnitIndex = -1; 	// ROOT_ONLY
+	private int lastUnitIndex = -1; 			// ROOT_ONLY
 
-	TypeSystem typeSystem;
+	TypeSystem typeSystem;					 	// SHARED
 	
-	public INameEnvironment nameEnvironment;
-	public CompilerOptions globalOptions;
+	public INameEnvironment nameEnvironment;	// SHARED
+	public CompilerOptions globalOptions;		// SHARED
 
-	public ProblemReporter problemReporter;
-	public ClassFilePool classFilePool;
+	public ProblemReporter problemReporter; 	// SHARED
+	public ClassFilePool classFilePool; 		// SHARED
 	// indicate in which step on the compilation we are.
 	// step 1 : build the reference binding
 	// step 2 : conect the hierarchy (connect bindings)
 	// step 3 : build fields and method bindings.
-	private int stepCompleted; // ROOT_ONLY
-	public ITypeRequestor typeRequestor;
+	private int stepCompleted; 					// ROOT_ONLY
+	public ITypeRequestor typeRequestor;		// SHARED
 
 	private SimpleLookupTable uniqueParameterizedGenericMethodBindings;
 	
@@ -112,7 +112,7 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 
 	boolean useModuleSystem;					// true when compliance >= 9 and nameEnvironment is module aware
 	// key is a string with the module name value is a module binding
-	public HashtableOfModule knownModules;
+	public HashtableOfModule knownModules;		// SHARED
 
 	public CompilationUnitDeclaration unitBeingCompleted = null; // only set while completing units -- ROOT_ONLY
 	public Object missingClassFileLocation = null; // only set when resolving certain references, to help locating problems
@@ -120,7 +120,7 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 	private MethodVerifier verifier;
 
 	private ArrayList missingTypes;
-	Set<SourceTypeBinding> typesBeingConnected;
+	Set<SourceTypeBinding> typesBeingConnected;	// SHARED
 	public boolean isProcessingAnnotations = false;
 	public boolean mayTolerateMissingType = false;
 
@@ -133,7 +133,7 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 
 	Map<String,Integer> allNullAnnotations = null;
 
-	final List<MethodBinding> deferredEnumMethods; // during early initialization we cannot mark Enum-methods as nonnull.
+	final List<MethodBinding> deferredEnumMethods; // SHARED: during early initialization we cannot mark Enum-methods as nonnull.
 
 	/** Global access to the outermost active inference context as the universe for inference variable interning. */
 	InferenceContext18 currentInferenceContext;
@@ -1978,6 +1978,7 @@ boolean isMissingType(char[] typeName) {
 
 // The method verifier is lazily initialized to guarantee the receiver, the compiler & the oracle are ready.
 public MethodVerifier methodVerifier() {
+	 // TODO(SHMOD): I'm not sure if the verifier would need to be created with a specific LE?
 	if (this.verifier == null)
 		this.verifier = newMethodVerifier();
 	return this.verifier;
commit a46b8d22cf6a5800682565693196df32eba88bc8
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Jul 27 13:27:10 2017 +0530

    Bug 519963 - [9] Clean-up of the new name lookup
    - various small fixes on behalf of other bugs
    
    Also-by: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
    Change-Id: I997827a5624a8aacbff149db87ebfa47453b4a08

202	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
26	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
10	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
0	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
4	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index 130a23b..dad5e29 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -4222,6 +4222,208 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 		}
 
 	}	
+	public void testBug520147() throws CoreException, IOException {
+		if (!isJRE9) return;
+		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
+		try {
+			String[] src = new String[] { 
+					"src/module-info.java",
+					"module org.astro {\n" +
+					"	exports org.astro;\n" +
+					"}",
+					"src/bundle/org/SomeClass.java",
+					"package bundle.org;\n" +
+					"public class SomeClass {}",
+					"src/org/astro/World.java",
+					"package org.astro;\n" +
+					"public interface World {\n" +
+					"	public String name();\n" +
+					"}"
+			};
+			IJavaProject p1 = setupModuleProject("org.astro", src);
+			src = new String[] {
+				"src/module-info.java",
+				"module com.greetings {\n" +
+					"	requires org.astro;\n" +
+					"	exports bundle.org;\n" +
+					"}",
+				"src/bundle/org/SomeWorld.java",
+				"package bundle.org;\n" +
+				"import  org.astro.World;\n" +
+				"public class SomeWorld implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" Some World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false, new IClasspathAttribute[] {modAttr}, false);
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] {dep});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			src = new String[] { 
+				"src/module-info.java",
+				"module test {\n" +
+				"	exports test;\n" +
+				"	requires org.astro;\n" +
+				"	requires com.greetings;\n" +
+				"}",
+				"src/test/Main.java",
+				"package test;\n" +
+				"import bundle.org.SomeWorld;\n" +
+				"public class Main {\n" +
+				"	public static void main(String[] args) {\n" +
+				"		org.astro.World world = new SomeWorld();\n" +
+				"		System.out.println(world.name());\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath(), null, false, new IClasspathAttribute[] {modAttr}, false);
+			IJavaProject p3 = setupModuleProject("test", src, new IClasspathEntry[] {dep, dep2});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "", markers);
+		} finally {
+			this.deleteProject("test");
+			this.deleteProject("com.greetings");
+			this.deleteProject("org.astro");
+			JavaCore.setOptions(javaCoreOptions);
+		}
+	}	
+	public void testBug520147a() throws CoreException, IOException {
+		if (!isJRE9) return;
+		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
+		try {
+			String[] src = new String[] { 
+					"src/module-info.java",
+					"module org.astro {\n" +
+					"	exports org.astro;\n" +
+					"}",
+					"src/bundle/org/SomeClass.java",
+					"package bundle.org;\n" +
+					"public class SomeClass {}",
+					"src/org/astro/World.java",
+					"package org.astro;\n" +
+					"public interface World {\n" +
+					"	public String name();\n" +
+					"}"
+			};
+			IJavaProject p1 = setupModuleProject("org.astro", src);
+			src = new String[] {
+				"src/module-info.java",
+				"module com.greetings {\n" +
+					"	requires org.astro;\n" +
+					"	exports bundle.org;\n" +
+					"}",
+				"src/bundle/org/SomeWorld.java",
+				"package bundle.org;\n" +
+				"import  org.astro.World;\n" +
+				"public class SomeWorld implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" Some World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false, new IClasspathAttribute[] {modAttr}, false);
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] {dep});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			src = new String[] { 
+				"src/module-info.java",
+				"module test {\n" +
+				"	exports test;\n" +
+				"	requires com.greetings;\n" +
+				"}",
+				"src/test/Main.java",
+				"package test;\n" +
+				"import bundle.org.SomeWorld;\n" +
+				"public class Main {\n" +
+				"	public static void main(String[] args) {\n" +
+				"		org.astro.World world = new SomeWorld();\n" +
+				"		System.out.println(world.name());\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath(), null, false, new IClasspathAttribute[] {modAttr}, false);
+			IJavaProject p3 = setupModuleProject("test", src, new IClasspathEntry[] {dep, dep2});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", 
+					"The type org.astro.World is not accessible", markers);
+		} finally {
+			this.deleteProject("test");
+			this.deleteProject("com.greetings");
+			this.deleteProject("org.astro");
+			JavaCore.setOptions(javaCoreOptions);
+		}
+	}
+	public void testBug520147b() throws CoreException, IOException {
+		if (!isJRE9) return;
+		Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();
+		try {
+			String[] src = new String[] { 
+					"src/module-info.java",
+					"module org.astro {\n" +
+					"	exports org.astro;\n" +
+					"	exports bundle.org to com.greetings;\n" +
+					"}",
+					"src/bundle/org/SomeClass.java",
+					"package bundle.org;\n" +
+					"public class SomeClass {}",
+					"src/org/astro/World.java",
+					"package org.astro;\n" +
+					"public interface World {\n" +
+					"	public String name();\n" +
+					"}"
+			};
+			IJavaProject p1 = setupModuleProject("org.astro", src);
+			src = new String[] {
+				"src/module-info.java",
+				"module com.greetings {\n" +
+					"	requires org.astro;\n" +
+					"	exports bundle.org;\n" +
+					"}",
+				"src/bundle/org/SomeWorld.java",
+				"package bundle.org;\n" +
+				"import  org.astro.World;\n" +
+				"public class SomeWorld implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" Some World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathAttribute modAttr = new ClasspathAttribute("module", "true");
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath(), null, false, new IClasspathAttribute[] {modAttr}, false);
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] {dep});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			src = new String[] { 
+				"src/module-info.java",
+				"module test {\n" +
+				"	exports test;\n" +
+				"	requires org.astro;\n" +
+				"	requires com.greetings;\n" +
+				"}",
+				"src/test/Main.java",
+				"package test;\n" +
+				"import bundle.org.SomeWorld;\n" +
+				"public class Main {\n" +
+				"	public static void main(String[] args) {\n" +
+				"		org.astro.World world = new SomeWorld();\n" +
+				"		System.out.println(world.name());\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathEntry dep2 = JavaCore.newProjectEntry(p2.getPath(), null, false, new IClasspathAttribute[] {modAttr}, false);
+			IJavaProject p3 = setupModuleProject("test", src, new IClasspathEntry[] {dep, dep2});
+			getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p3.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "", markers);
+		} finally {
+			this.deleteProject("test");
+			this.deleteProject("com.greetings");
+			this.deleteProject("org.astro");
+			JavaCore.setOptions(javaCoreOptions);
+		}
+	}
 	protected void assertNoErrors() throws CoreException {
 		for (IProject p : getWorkspace().getRoot().getProjects()) {
 			int maxSeverity = p.findMaxProblemSeverity(null, true, IResource.DEPTH_INFINITE);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
index 4a2c115..cebb11b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
@@ -119,7 +119,7 @@ public class QualifiedTypeReference extends TypeReference {
 	    
 	    if (packageBinding instanceof SplitPackageBinding) {
 	    	SplitPackageBinding splitPackage = (SplitPackageBinding) packageBinding;
-	    	if (splitPackage.hasConflict()) {
+	    	if (splitPackage.hasConflict(scope.module())) {
 	    		scope.problemReporter().conflictingPackagesFromModules(splitPackage, this.sourceStart, (int)this.sourcePositions[typeStart-1]);
 	    		this.resolvedType = new ProblemReferenceBinding(this.tokens, null, ProblemReasons.Ambiguous);
 	    		return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index 76927c3..4ecef5b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -426,7 +426,7 @@ void faultInImports() {
 			}
 			if (importBinding instanceof SplitPackageBinding) {
 				SplitPackageBinding splitPackage = (SplitPackageBinding) importBinding;
-				if (splitPackage.hasConflict()) {
+				if (splitPackage.hasConflict(module())) {
 					problemReporter().conflictingPackagesFromModules(splitPackage, importReference.sourceStart, importReference.sourceEnd);
 					continue nextImport;
 				}
@@ -462,7 +462,7 @@ void faultInImports() {
 				importedPackage = (PackageBinding) findImport(importedPackage.compoundName, false, true);
 				if (importedPackage instanceof SplitPackageBinding) {
 					SplitPackageBinding splitPackage = (SplitPackageBinding) importedPackage;
-					if (splitPackage.hasConflict()) {
+					if (splitPackage.hasConflict(module())) {
 						int sourceEnd = (int) importReference.sourcePositions[splitPackage.compoundName.length-1];
 						problemReporter().conflictingPackagesFromModules(splitPackage, importReference.sourceStart, sourceEnd);
 						continue nextImport;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 6e65f73..409fc52 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -403,8 +403,11 @@ private static NameEnvironmentAnswer fromSplitPackageOrOracle(IModuleAwareNameEn
 		// now check if the module-incarnation of the package has the type:
 		// (needed because the moduleEnv will not answer initial types).
 		ReferenceBinding binding = ((SplitPackageBinding) packageBinding).getType0ForModule(module, name);
-		if (binding != null && binding.isValidBinding())
+		if (binding != null && binding.isValidBinding()) {
+			if (binding instanceof UnresolvedReferenceBinding)
+				binding = ((UnresolvedReferenceBinding) binding).resolve(module.environment, false);
 			return new NameEnvironmentAnswer(binding, module);
+		}
 	}
 	return moduleEnv.findType(name, packageBinding.compoundName, module.nameForLookup());
 }
@@ -717,14 +720,18 @@ private PackageBinding computePackageFrom(char[][] constantPoolName, boolean isM
 
 	PackageBinding packageBinding = getPackage0(constantPoolName[0]);
 	if (packageBinding == null || packageBinding == TheNotFoundPackage) {
-		if (this.useModuleSystem && this.module.isUnnamed()) {
-			char[][] declaringModules = ((IModuleAwareNameEnvironment) this.nameEnvironment).getModulesDeclaringPackage(null, constantPoolName[0], ModuleBinding.ANY);
-			if (declaringModules != null) {
-				for (char[] mod : declaringModules) {
-					ModuleBinding declaringModule = this.root.getModule(mod);
-					if (declaringModule != null)
-						packageBinding = SplitPackageBinding.combine(declaringModule.getTopLevelPackage(constantPoolName[0]), packageBinding, this.module);
+		if (this.useModuleSystem) {
+			if (this.module.isUnnamed()) {
+				char[][] declaringModules = ((IModuleAwareNameEnvironment) this.nameEnvironment).getModulesDeclaringPackage(null, constantPoolName[0], ModuleBinding.ANY);
+				if (declaringModules != null) {
+					for (char[] mod : declaringModules) {
+						ModuleBinding declaringModule = this.root.getModule(mod);
+						if (declaringModule != null)
+							packageBinding = SplitPackageBinding.combine(declaringModule.getTopLevelPackage(constantPoolName[0]), packageBinding, this.module);
+					}
 				}
+			} else {
+				packageBinding = this.module.getTopLevelPackage(constantPoolName[0]);
 			}
 		}
 		if (packageBinding == null || packageBinding == TheNotFoundPackage) {
@@ -737,14 +744,18 @@ private PackageBinding computePackageFrom(char[][] constantPoolName, boolean isM
 	for (int i = 1, length = constantPoolName.length - 1; i < length; i++) {
 		PackageBinding parent = packageBinding;
 		if ((packageBinding = parent.getPackage0(constantPoolName[i])) == null || packageBinding == TheNotFoundPackage) {
-			if (this.useModuleSystem && this.module.isUnnamed()) {
-				char[][] declaringModules = ((IModuleAwareNameEnvironment) this.nameEnvironment).getModulesDeclaringPackage(parent.compoundName, constantPoolName[i], ModuleBinding.ANY);
-				if (declaringModules != null) {
-					for (char[] mod : declaringModules) {
-						ModuleBinding declaringModule = this.root.getModule(mod);
-						if (declaringModule != null)
-							packageBinding = SplitPackageBinding.combine(declaringModule.getPackage(parent.compoundName, constantPoolName[i]), packageBinding, this.module);
+			if (this.useModuleSystem) {
+				if (this.module.isUnnamed()) {
+					char[][] declaringModules = ((IModuleAwareNameEnvironment) this.nameEnvironment).getModulesDeclaringPackage(parent.compoundName, constantPoolName[i], ModuleBinding.ANY);
+					if (declaringModules != null) {
+						for (char[] mod : declaringModules) {
+							ModuleBinding declaringModule = this.root.getModule(mod);
+							if (declaringModule != null)
+								packageBinding = SplitPackageBinding.combine(declaringModule.getPackage(parent.compoundName, constantPoolName[i]), packageBinding, this.module);
+						}
 					}
+				} else {
+					packageBinding = this.module.getVisiblePackage(parent, constantPoolName[i]);
 				}
 			}
 			if (packageBinding == null || packageBinding == TheNotFoundPackage) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
index 0d7b206..96098f8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -369,17 +369,22 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 	}
 
 	/**
-	 * Check if the specified package is exported to the client module by this module. True if the package appears
-	 * in the list of exported packages and when the export is targeted, the module appears in the targets of the
-	 * exports statement
+	 * Check if the specified package is owned by the current module and exported to the client module.
+	 * True if the package appears in the list of exported packages and when the export is targeted,
+	 * the module appears in the targets of the exports statement.
 	 * @param pkg - the package whose visibility is to be checked
 	 * @param client - the module that wishes to use the package
 	 * @return true if the package is visible to the client module, false otherwise
 	 */
 	public boolean isPackageExportedTo(PackageBinding pkg, ModuleBinding client) {
 		// TODO(SHMOD): cache the result?
-		PackageBinding resolved = getVisiblePackage(pkg.compoundName);
-		if (pkg.isEquivalentTo(resolved)) {
+		PackageBinding resolved = null;
+		if (pkg instanceof SplitPackageBinding) {
+			resolved = ((SplitPackageBinding) pkg).getIncarnation(this);
+		} else if (pkg.enclosingModule == this) {
+			resolved = pkg;
+		}
+		if (resolved != null) {
 			if (this.isAuto) { // all packages are exported by an automatic module
 				return pkg.enclosingModule == this; // no transitive export
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
index 0c70650..c3a789c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
@@ -349,13 +349,6 @@ public String toString() {
 	}
 	return str;
 }
-public boolean isEquivalentTo(PackageBinding other) {
-	if (this == other)
-		return true;
-	if (other instanceof SplitPackageBinding)
-		return other.isEquivalentTo(this);
-	return false;
-}
 public boolean isDeclaredIn(ModuleBinding moduleBinding) {
 	return this.enclosingModule == moduleBinding;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
index f677b0e..927965d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
@@ -175,19 +175,11 @@ public class SplitPackageBinding extends PackageBinding {
 		}
 		return null; // FIXME(SHMOD) is this an error?? (note that requestedModule could be the unnamed module
 	}
-	
-	@Override
-	public boolean isEquivalentTo(PackageBinding other) {
-		if (other == this)
-			return true;
-		if (other == null)
-			return false;
-		return CharOperation.equals(this.compoundName, other.compoundName)
-				&& this.declaringModules.contains(other.enclosingModule);
-	}
 
 	@Override
 	public boolean subsumes(PackageBinding binding) {
+		if (!CharOperation.equals(this.compoundName, binding.compoundName))
+			return false;
 		if (binding instanceof SplitPackageBinding)
 			return this.declaringModules.containsAll(((SplitPackageBinding) binding).declaringModules);
 		else
@@ -251,11 +243,11 @@ public class SplitPackageBinding extends PackageBinding {
 		return this.declaringModules.contains(moduleBinding);
 	}
 
-	public boolean hasConflict() {
+	public boolean hasConflict(ModuleBinding clientModule) {
 		int visibleCount = 0;
 		for (PackageBinding incarnation : this.incarnations) {
 			if (incarnation.hasCompilationUnit()) {
-				if (this.enclosingModule.canAccess(incarnation)) 
+				if (clientModule.canAccess(incarnation)) 
 					if (++visibleCount > 1)
 						return true;
 			}
commit a2441f7ed408ccbc2d7c0ca605da60ffd8348cd3
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Fri Aug 4 23:03:09 2017 +0200

    Bug 519963 - [9] Clean-up of the new name lookup
    
    
    Change-Id: I7ac6c1ab1fbfc369f1908ce13d70a86a0eac1a95

10	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
index fa9f32f..077964c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -635,10 +635,16 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 	 * @return True, if the package is accessible by this module, false otherwise
 	 */
 	public boolean canAccess(PackageBinding pkg) {
-		boolean answer = pkg.isDeclaredIn(this) || Stream.of(getAllRequiredModules()).anyMatch(
-				dep -> dep.isPackageExportedTo(pkg, ModuleBinding.this) // TODO(SHMOD): store export status in the PackageBinding
-		);
-		return answer;
+		if (pkg.isDeclaredIn(this))
+			return true;
+		for (ModuleBinding requiredModule : getAllRequiredModules()) {
+			// If pkg is a SplitPackageBinding, we actually ask the intersection of all required modules
+			// and modules declaring the package, if any of them exports the package to this module.
+			// The intersection is computed when inside isPackageExportedTo we ask for pkg's incarnation in requiredModule.
+			if (requiredModule.isPackageExportedTo(pkg, ModuleBinding.this))
+				return true; // TODO(SHMOD): store export status in the PackageBinding
+		}
+		return false;
 	}
 	@Override
 	public char[] computeUniqueKey(boolean isLeaf) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
index 39676d3..0998868 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
@@ -61,7 +61,7 @@ public PackageBinding(char[][] compoundName, PackageBinding parent, LookupEnviro
 	if (enclosingModule != null)
 		this.enclosingModule = enclosingModule;
 	else if (parent != null)
-		this.enclosingModule = parent.enclosingModule; // FIXME(SHMOD): check parent for split package?
+		this.enclosingModule = parent.enclosingModule; // stop-gap for any remaining calls that don't provide an enclosingModule (they should)
 	
 	if (this.enclosingModule == null)
 		throw new IllegalStateException("Package should have an enclosing module"); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
index 2a9edb8..1941e29 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SplitPackageBinding.java
@@ -173,7 +173,7 @@ public class SplitPackageBinding extends PackageBinding {
 			if (incarnation.enclosingModule == requestedModule)
 				return incarnation;
 		}
-		return null; // FIXME(SHMOD) is this an error?? (note that requestedModule could be the unnamed module
+		return null;
 	}
 
 	@Override
commit 3282d35642a295fd7440ccf400467dc07541f77f
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Aug 13 01:06:22 2017 +0200

    Bug 519963 - [9] Clean-up of the new name lookup
    
    - fixes driven by WIP in bug 520713
    
    Change-Id: If941d4342bb8eda305e29c6e38962a915d511bbd

0	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
8	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
13	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index 1421620..955748b 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -3340,7 +3340,6 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
 			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
 			assertMarkers("Unexpected markers", 
-					"org.astro.World cannot be resolved to a type\n" +
 					"The package org.astro conflicts with a package accessible from another module: org.astro",  markers);
 		} finally {
 			deleteProject("org.astro");
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
index 7be4ed2..f148e81 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedTypeReference.java
@@ -117,13 +117,14 @@ public class QualifiedTypeReference extends TypeReference {
 	    PackageBinding packageBinding = binding == null ? null : (PackageBinding) binding;
 	    int typeStart = packageBinding == null ? 0 : packageBinding.compoundName.length;
 	    
-	    if (packageBinding != null)
-	    	packageBinding = packageBinding.getVisibleFor(scope.module());
-	    if (packageBinding instanceof SplitPackageBinding) {
-	    	SplitPackageBinding splitPackage = (SplitPackageBinding) packageBinding;
-	    	scope.problemReporter().conflictingPackagesFromModules(splitPackage, this.sourceStart, (int)this.sourcePositions[typeStart-1]);
-	    	this.resolvedType = new ProblemReferenceBinding(this.tokens, null, ProblemReasons.Ambiguous);
-	    	return null;
+	    if (packageBinding != null) {
+	    	PackageBinding uniquePackage = packageBinding.getVisibleFor(scope.module());
+	    	if (uniquePackage instanceof SplitPackageBinding) {
+	    		SplitPackageBinding splitPackage = (SplitPackageBinding) uniquePackage;
+    			scope.problemReporter().conflictingPackagesFromModules(splitPackage, this.sourceStart, (int)this.sourcePositions[typeStart-1]);
+    			this.resolvedType = new ProblemReferenceBinding(this.tokens, null, ProblemReasons.Ambiguous);
+    			return null;
+	    	}
 	    }
 	    rejectAnnotationsOnPackageQualifiers(scope, packageBinding);
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index a3847e9..576851c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -386,7 +386,12 @@ private NameEnvironmentAnswer[] askForTypeFromModules(ModuleBinding clientModule
 		for (int i = 0; i < otherModules.length; i++) {
 			NameEnvironmentAnswer answer = oracle.apply(otherModules[i]);
 			if (answer != null) {
-				answer.moduleBinding = otherModules[i];
+				char[] nameFromAnswer = answer.moduleName();
+				if (nameFromAnswer == null || CharOperation.equals(nameFromAnswer, otherModules[i].moduleName)) {
+					answer.moduleBinding = otherModules[i];
+				} else {
+					answer.moduleBinding = getModule(nameFromAnswer);
+				}
 				answers[i] = answer;
 				found = true;
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
index dc67f49..003298d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -228,6 +228,19 @@ public class ModuleBinding extends Binding implements IUpdatableModule {
 		} else {
 			// TODO(SHMOD) report error
 		}
+		// update known packages:
+		HashtableOfPackage knownPackages = this.environment.knownPackages;
+		for (int i = 0; i < knownPackages.valueTable.length; i++) {
+			PackageBinding packageBinding = knownPackages.valueTable[i];
+			if (packageBinding == null) continue;
+			PackageBinding newBinding = requiredModule.getVisiblePackage(packageBinding.compoundName);
+			newBinding = SplitPackageBinding.combine(newBinding, packageBinding, this);
+			if (packageBinding != newBinding) {
+				knownPackages.valueTable[i] = newBinding;
+				if (this.declaredPackages.containsKey(newBinding.readableName()))
+					this.declaredPackages.put(newBinding.readableName(), newBinding);
+			}
+		}
 	}
 	@Override
 	public void addExports(char[] packageName, char[][] targetModules) {
commit 845ed7a938667506fa74af955e7c7411ab734f1b
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Aug 31 13:41:58 2017 +0200

    Bug 519963: [9] Clean-up of the new name lookup
    
    - link FIXMEs to their bugs
    - remove stale FIXMEs
    
    Change-Id: I1b7b2b20f9653db3145beb43324aa68543844498

1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/JrtFileSystem.java
0	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
0	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/INameEnvironment.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/JrtFileSystem.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/JrtFileSystem.java
index a05eacf..56e5708 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/JrtFileSystem.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/JrtFileSystem.java
@@ -154,7 +154,7 @@ public class JrtFileSystem extends Archive {
 	}
 	
 	class JrtFileObject extends ArchiveFileObject {
-		IModule module = null; // FIXME(SHMOD): always null??
+		IModule module = null; // FIXME(SHMOD): always null?? https://bugs.eclipse.org/517059
 		private JrtFileObject(File file, String fileName, IModule module, Charset charset) {
 			super(file, fileName, charset);
 			this.module = module;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
index 4fc7cd7..5fc3dac 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleAwareNameEnvironment.java
@@ -20,8 +20,6 @@ import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
 
 /**
  * A module aware name environment
- * FIXME(SHMOD): consider folding this interface into INameEnvironment and extend existing methods rather then adding new ones. 
- *
  */
 public interface IModuleAwareNameEnvironment extends INameEnvironment {
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/INameEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/INameEnvironment.java
index e3998e4..b4550a7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/INameEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/INameEnvironment.java
@@ -27,7 +27,6 @@ package org.eclipse.jdt.internal.compiler.env;
  * <li>Determine to which module a given compilation unit / package is associated (JLS 7.3)</li>
  * </ul>
  * </p>
- * FIXME(SHMOD): fold methods of sub-interface IModuleAwareNameEnvironment back into this interface? (see also the following note). 
  * <p>
  * Note: This internal interface has been implemented illegally by the
  * org.apache.jasper.glassfish bundle from Orbit, see
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 786905d..fe96381 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -3214,7 +3214,7 @@ public abstract class Scope {
 
 		// at this point the scope is a compilation unit scope
 		CompilationUnitScope unitScope = (CompilationUnitScope) scope;
-		HashtableOfObject typeOrPackageCache = unitScope.typeOrPackageCache; // FIXME(SHMOD): dangerous, may mask other same named packages
+		HashtableOfObject typeOrPackageCache = unitScope.typeOrPackageCache;
 		if (typeOrPackageCache != null) {
 			Binding cachedBinding = (Binding) typeOrPackageCache.get(name);
 			if (cachedBinding != null) { // can also include NotFound ProblemReferenceBindings if we already know this name is not found
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
index 334d044..d44121f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
@@ -1236,7 +1236,7 @@ public class NameLookup implements SuffixConstants {
 		IModuleDescription[] modules = requestor.getModules();
 		if (modules.length == 0) {
 			try {
-				// FIXME(SHMOD): only considers source modules??
+				// FIXME(SHMOD): only considers source modules?? (MODULEPATH container is only experimental)
 				JavaModelManager.getModulePathManager().seekModule(moduleName, false, requestor);
 				modules = requestor.getModules();
 			} catch (JavaModelException e) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
index 10708a8..94bb409 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
@@ -104,7 +104,7 @@ public class ClasspathJMod extends ClasspathJar {
 								if (inputStream == null) throw new IOException("Invalid zip entry name : " + entry.getName()); //$NON-NLS-1$
 								stream = new BufferedInputStream(inputStream);
 								byte[] content = Util.getInputStreamAsByteArray(stream, (int) entry.getSize());
-								// FIXME(SHMOD): avoid this (platform dependent) temp file!!
+								// FIXME(SHMOD): avoid this (platform dependent) temp file!! https://bugs.eclipse.org/511950
 								DataOutputStream dos = new DataOutputStream(new FileOutputStream(new File("c:\\temp\\module-info.class"))); //$NON-NLS-1$
 								dos.write(content);
 								dos.close();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index 1dc4108..93198b6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -342,7 +342,7 @@ public char[][] getModulesDeclaringPackage(char[][] parentPackageName, char[] pa
 			if (location.isPackage(qualifiedPackageName, null)) {
 				IModule module = location.getModule();
 				char[] aName = module != null ? module.name() : ModuleBinding.UNNAMED;
-				moduleNames = CharOperation.arrayConcat(moduleNames, aName); // FIXME(SHMOD): handle multiple modules per location
+				moduleNames = CharOperation.arrayConcat(moduleNames, aName); // FIXME(SHMOD): handle multiple modules per location https://bugs.eclipse.org/501162#c29
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
index 59209a9..ee5e393 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PossibleMatch.java
@@ -134,7 +134,7 @@ private char[] getQualifiedName() {
 		PackageFragment pkg = (PackageFragment) this.openable.getParent();
 		return Util.concatWith(pkg.names, simpleName, '.').toCharArray();
 	} else if (this.openable instanceof ModularClassFile) {
-		// FIXME(SHMOD): not useful
+		// FIXME(SHMOD): not useful https://bugs.eclipse.org/501162#c30
 		String simpleName = TypeConstants.MODULE_INFO_NAME_STRING;
 		PackageFragment pkg = (PackageFragment) this.openable.getParent();
 		return Util.concatWith(pkg.names, simpleName, '.').toCharArray();
@@ -161,7 +161,7 @@ private String getSourceFileName() {
 				this.sourceFileName = fileName == null ? NO_SOURCE_FILE_NAME : fileName;
 			}
 		} else if (this.openable instanceof ModularClassFile) {
-			// FIXME(SHMOD): premature
+			// FIXME(SHMOD): premature https://bugs.eclipse.org/501162#c31
 			this.sourceFileName = TypeConstants.MODULE_INFO_FILE_NAME_STRING;
 		}
 	}
