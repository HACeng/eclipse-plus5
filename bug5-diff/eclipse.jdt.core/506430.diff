commit 49e9d0cec84062b8f937bcce9ab15ec576e3a013
Author: Mateusz Matela <mateusz.matela@gmail.com>
Date:   Thu May 4 17:30:28 2017 +0200

    Bug 506430 - [1.9] Formatter support for module-info.java

38	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
13	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/A_in.java
18	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/A_out.java
13	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/B_in.java
34	0	org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/B_out.java
17	3	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
11	0	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
68	46	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
8	0	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
24	0	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
36	0	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java
35	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
index ba62f38..122f47f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
@@ -13997,4 +13997,42 @@ public void testBug362260g() throws JavaModelException {
 	String input = getCompilationUnit("Formatter", "", "test362260", "G_in.java").getSource();
 	formatSource(input, getCompilationUnit("Formatter", "", "test362260", "G_out.java").getSource());
 }
+/**
+ * https://bugs.eclipse.org/506430 - [1.9] Formatter support for module-info.java
+ */
+public void testBug506430a() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_9);
+	setPageWidth80();
+	String input = getCompilationUnit("Formatter", "", "test506430", "A_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test506430", "A_out.java") .getSource(),
+			CodeFormatter.K_MODULE_INFO | CodeFormatter.F_INCLUDE_COMMENTS);
+}
+/**
+ * https://bugs.eclipse.org/506430 - [1.9] Formatter support for module-info.java
+ */
+public void testBug506430b() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_9);
+	setPageWidth80();
+	this.formatterPrefs.brace_position_for_type_declaration = DefaultCodeFormatterConstants.NEXT_LINE;
+	this.formatterPrefs.blank_lines_before_new_chunk = 2;
+	this.formatterPrefs.blank_lines_before_first_class_body_declaration = 3;
+	this.formatterPrefs.blank_lines_before_field = 1;
+	this.formatterPrefs.indent_body_declarations_compare_to_type_header = false;
+	this.formatterPrefs.insert_space_before_comma_in_multiple_field_declarations = true;
+	this.formatterPrefs.alignment_for_module_statements = Alignment.M_NEXT_PER_LINE_SPLIT;
+	this.formatterPrefs.insert_new_line_at_end_of_file_if_missing = true;
+	String input = getCompilationUnit("Formatter", "", "test506430", "B_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test506430", "B_out.java") .getSource(),
+			CodeFormatter.K_MODULE_INFO | CodeFormatter.F_INCLUDE_COMMENTS);
+}
+/**
+ * https://bugs.eclipse.org/506430 - [1.9] Formatter support for module-info.java
+ */
+public void testBug506430c() throws JavaModelException {
+	setComplianceLevel(CompilerOptions.VERSION_9);
+	setPageWidth80();
+	String input = getCompilationUnit("Formatter", "", "test506430", "A_in.java").getSource();
+	formatSource(input, getCompilationUnit("Formatter", "", "test506430", "A_out.java") .getSource(),
+			CodeFormatter.K_UNKNOWN | CodeFormatter.F_INCLUDE_COMMENTS);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/A_in.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/A_in.java
new file mode 100644
index 0000000..1ee3375
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/A_in.java
@@ -0,0 +1,13 @@
+module aaaaaaaaaa.bbbbbbbbbb{
+  requires aaaaaaaaaa.cccccccccc; // a      comment
+  requires transitive aaaaaaaaaa
+      .dddddddddd;
+  requires static aaaaaaaaaa.eeeeeeeeee;
+  requires transitive static aaaaaaaaaa.ffffffffff.ggggggggg.hhhhhhhhhh.iiiiiiiiii;
+  exports aaaaaaaaaa.jjjjjjjjjj;
+  exports aaaaaaaaaa.kkkkkkkkkk to aaaaaaaaaa.llllllllll, aaaaaaaaaa.mmmmmmmmmm, aaaaaaaaaa.nnnnnnnnnn;
+  opens aaaaaaaaaa.oooooooooo;
+  opens aaaaaaaaaa.pppppppppp to aaaaaaaaaa.qqqqqqqqqq;
+  uses aaaaaaaaaa.ssssssssss;
+  provides aaaaaaaaaa.tttttttttt with aaaaaaaaaa.uuuuuuuuuu, aaaaaaaaaa.vvvvvvvvvv;
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/A_out.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/A_out.java
new file mode 100644
index 0000000..2fc184a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/A_out.java
@@ -0,0 +1,18 @@
+module aaaaaaaaaa.bbbbbbbbbb {
+	requires aaaaaaaaaa.cccccccccc; // a comment
+	requires transitive aaaaaaaaaa.dddddddddd;
+	requires static aaaaaaaaaa.eeeeeeeeee;
+	requires transitive static aaaaaaaaaa.ffffffffff.ggggggggg.hhhhhhhhhh.iiiiiiiiii;
+
+	exports aaaaaaaaaa.jjjjjjjjjj;
+	exports aaaaaaaaaa.kkkkkkkkkk to aaaaaaaaaa.llllllllll,
+			aaaaaaaaaa.mmmmmmmmmm, aaaaaaaaaa.nnnnnnnnnn;
+
+	opens aaaaaaaaaa.oooooooooo;
+	opens aaaaaaaaaa.pppppppppp to aaaaaaaaaa.qqqqqqqqqq;
+
+	uses aaaaaaaaaa.ssssssssss;
+
+	provides aaaaaaaaaa.tttttttttt
+			with aaaaaaaaaa.uuuuuuuuuu, aaaaaaaaaa.vvvvvvvvvv;
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/B_in.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/B_in.java
new file mode 100644
index 0000000..1ee3375
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/B_in.java
@@ -0,0 +1,13 @@
+module aaaaaaaaaa.bbbbbbbbbb{
+  requires aaaaaaaaaa.cccccccccc; // a      comment
+  requires transitive aaaaaaaaaa
+      .dddddddddd;
+  requires static aaaaaaaaaa.eeeeeeeeee;
+  requires transitive static aaaaaaaaaa.ffffffffff.ggggggggg.hhhhhhhhhh.iiiiiiiiii;
+  exports aaaaaaaaaa.jjjjjjjjjj;
+  exports aaaaaaaaaa.kkkkkkkkkk to aaaaaaaaaa.llllllllll, aaaaaaaaaa.mmmmmmmmmm, aaaaaaaaaa.nnnnnnnnnn;
+  opens aaaaaaaaaa.oooooooooo;
+  opens aaaaaaaaaa.pppppppppp to aaaaaaaaaa.qqqqqqqqqq;
+  uses aaaaaaaaaa.ssssssssss;
+  provides aaaaaaaaaa.tttttttttt with aaaaaaaaaa.uuuuuuuuuu, aaaaaaaaaa.vvvvvvvvvv;
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/B_out.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/B_out.java
new file mode 100644
index 0000000..ed4da95
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test506430/B_out.java
@@ -0,0 +1,34 @@
+module aaaaaaaaaa.bbbbbbbbbb
+{
+
+
+
+requires aaaaaaaaaa.cccccccccc; // a comment
+
+requires transitive aaaaaaaaaa.dddddddddd;
+
+requires static aaaaaaaaaa.eeeeeeeeee;
+
+requires transitive static aaaaaaaaaa.ffffffffff.ggggggggg.hhhhhhhhhh.iiiiiiiiii;
+
+
+exports aaaaaaaaaa.jjjjjjjjjj;
+
+exports aaaaaaaaaa.kkkkkkkkkk to
+		aaaaaaaaaa.llllllllll ,
+		aaaaaaaaaa.mmmmmmmmmm ,
+		aaaaaaaaaa.nnnnnnnnnn;
+
+
+opens aaaaaaaaaa.oooooooooo;
+
+opens aaaaaaaaaa.pppppppppp to aaaaaaaaaa.qqqqqqqqqq;
+
+
+uses aaaaaaaaaa.ssssssssss;
+
+
+provides aaaaaaaaaa.tttttttttt with
+		aaaaaaaaaa.uuuuuuuuuu ,
+		aaaaaaaaaa.vvvvvvvvvv;
+}
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
index 75a8ff9..4b46f88 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -109,6 +109,17 @@ public abstract class CodeFormatter {
 	public static final int K_JAVA_DOC = 0x40;
 
 	/**
+	 * Kind used to format a module description (a module-info.java file).
+	 * <p>
+	 * If the corresponding comment option is set to <code>true</code> then it is
+	 * also possible to format the comments on the fly by adding the
+	 * {@link #F_INCLUDE_COMMENTS} flag to this kind of format.
+	 * </p>
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int K_MODULE_INFO = 0x80;
+
+	/**
 	 * Flag used to include the comments during the formatting of the code
 	 * snippet.
 	 * <p>
@@ -119,6 +130,7 @@ public abstract class CodeFormatter {
 	 * 		<li>{@link #K_CLASS_BODY_DECLARATIONS} <i>(since 3.6)</i></li>
 	 * 		<li>{@link #K_EXPRESSION} <i>(since 3.6)</i></li>
 	 * 		<li>{@link #K_STATEMENTS} <i>(since 3.6)</i></li>
+	 * 		<li>{@link #K_MODULE_INFO}</li>
 	 * </ul>
 	 * </p><p>
 	 * Note also that it has an effect only when one or several format comments
@@ -201,7 +213,8 @@ public abstract class CodeFormatter {
 	 * 	<li>{@link #K_EXPRESSION}</li>
 	 * 	<li>{@link #K_STATEMENTS}</li>
 	 * 	<li>{@link #K_CLASS_BODY_DECLARATIONS}</li>
-	 * 	<li>{@link #K_COMPILATION_UNIT}<br>
+	 * 	<li>{@link #K_COMPILATION_UNIT}</li>
+	 * 	<li>{@link #K_MODULE_INFO}<br>
 	 * 		<b>Since 3.4</b>, the comments can be formatted on the fly while
 	 * 		using this kind of code snippet<br>
 	 * 		(see {@link #F_INCLUDE_COMMENTS} for more detailed explanation on
@@ -244,7 +257,8 @@ public abstract class CodeFormatter {
 	 * 	<li>{@link #K_EXPRESSION}</li>
 	 * 	<li>{@link #K_STATEMENTS}</li>
 	 * 	<li>{@link #K_CLASS_BODY_DECLARATIONS}</li>
-	 * 	<li>{@link #K_COMPILATION_UNIT}<br>
+	 * 	<li>{@link #K_COMPILATION_UNIT}</li>
+	 * 	<li>{@link #K_MODULE_INFO}<br>
 	 * 		<b>Since 3.4</b>, the comments can be formatted on the fly while
 	 * 		using this kind of code snippet<br>
 	 * 		(see {@link #F_INCLUDE_COMMENTS} for more detailed explanation on
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
index 9f9f186..a442121 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
@@ -236,6 +236,17 @@ public class DefaultCodeFormatterConstants {
 	public static final String FORMATTER_ALIGNMENT_FOR_METHOD_DECLARATION = JavaCore.PLUGIN_ID + ".formatter.alignment_for_method_declaration";	 //$NON-NLS-1$
 	/**
 	 * <pre>
+	 * FORMATTER / Option for alignment of module statements
+	 *     - option id:         "org.eclipse.jdt.core.formatter.alignment_for_module_statements"
+	 *     - possible values:   values returned by <code>createAlignmentValue(boolean, int, int)</code> call
+	 *     - default:           createAlignmentValue(false, WRAP_COMPACT, INDENT_DEFAULT)
+	 * </pre>
+	 * @see #createAlignmentValue(boolean, int, int)
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final String FORMATTER_ALIGNMENT_FOR_MODULE_STATEMENTS = JavaCore.PLUGIN_ID + ".formatter.alignment_for_module_statements";	 //$NON-NLS-1$
+	/**
+	 * <pre>
 	 * FORMATTER / Option for alignment of multiple fields
 	 *     - option id:         "org.eclipse.jdt.core.formatter.alignment_for_multiple_fields"
 	 *     - possible values:   values returned by <code>createAlignmentValue(boolean, int, int)</code> call
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
index 9b709ed..19ce52b 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
@@ -24,9 +24,14 @@ import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameC
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameCOMMENT_LINE;
 
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.compiler.IProblem;
 import org.eclipse.jdt.core.compiler.InvalidInputException;
@@ -40,8 +45,10 @@ import org.eclipse.jdt.core.dom.TypeDeclaration;
 import org.eclipse.jdt.core.formatter.CodeFormatter;
 import org.eclipse.jdt.core.formatter.DefaultCodeFormatterConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.util.Util;
+import org.eclipse.jdt.internal.core.PackageFragment;
 import org.eclipse.jdt.internal.formatter.linewrap.CommentWrapExecutor;
 import org.eclipse.jdt.internal.formatter.linewrap.WrapPreparator;
 import org.eclipse.jface.text.IRegion;
@@ -66,8 +73,18 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		| K_STATEMENTS
 		| K_CLASS_BODY_DECLARATIONS
 		| K_COMPILATION_UNIT
+		| K_MODULE_INFO
 		| K_COMMENTS_MASK;
 
+	private static final Map<Integer, Integer> FORMAT_TO_PARSER_KIND = new HashMap<>();
+	static {
+		FORMAT_TO_PARSER_KIND.put(K_COMPILATION_UNIT, ASTParser.K_COMPILATION_UNIT);
+		FORMAT_TO_PARSER_KIND.put(K_MODULE_INFO, ASTParser.K_COMPILATION_UNIT);
+		FORMAT_TO_PARSER_KIND.put(K_CLASS_BODY_DECLARATIONS, ASTParser.K_CLASS_BODY_DECLARATIONS);
+		FORMAT_TO_PARSER_KIND.put(K_STATEMENTS, ASTParser.K_STATEMENTS);
+		FORMAT_TO_PARSER_KIND.put(K_EXPRESSION, ASTParser.K_EXPRESSION);
+	}
+
 	private DefaultCodeFormatterOptions originalOptions;
 	private DefaultCodeFormatterOptions workingOptions;
 
@@ -75,7 +92,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 	private String sourceLevel;
 
 	private String sourceString;
-	private char[] sourceArray;
+	char[] sourceArray;
 	private IRegion[] formatRegions;
 
 	private ASTNode astRoot;
@@ -169,7 +186,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		return result;
 	}
 
-	private boolean init(String source) {
+	private boolean init(String source, int kind) {
 
 		// this is convenient for debugging (see Token.toString())
 		// Token.source = source;
@@ -179,12 +196,12 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		this.tokens.clear();
 		this.tokenManager = new TokenManager(this.tokens, source, this.workingOptions);
 
-		tokenizeSource();
+		tokenizeSource(kind);
 		return !this.tokens.isEmpty();
 	}
 
 	List<Token> prepareFormattedCode(String source, int kind) {
-		if (!init(source))
+		if (!init(source, kind))
 			return null;
 
 		this.astRoot = parseSourceCode(kind);
@@ -218,7 +235,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 
 	private TextEdit formatComments(String source, int kind) {
 		MultiTextEdit result = new MultiTextEdit();
-		if (!init(source))
+		if (!init(source, kind))
 			return result;
 
 		CommentsPreparator commentsPreparator = new CommentsPreparator(this.tokenManager, this.workingOptions,
@@ -226,12 +243,9 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		CommentWrapExecutor commentWrapper = new CommentWrapExecutor(this.tokenManager, this.workingOptions);
 		switch (kind) {
 			case K_JAVA_DOC:
-				ASTParser parser = ASTParser.newParser(AST.JLS9);
 				for (Token token : this.tokens) {
 					if (token.tokenType == TokenNameCOMMENT_JAVADOC) {
-						parser.setSourceRange(token.originalStart, token.countChars());
-						CompilationUnit cu = (CompilationUnit) parseSourceCode(parser, ASTParser.K_COMPILATION_UNIT,
-								true);
+						CompilationUnit cu = (CompilationUnit) parseSourceCode(ASTParser.K_COMPILATION_UNIT);
 						Javadoc javadoc = (Javadoc) cu.getCommentList().get(0);
 						javadoc.accept(commentsPreparator);
 						int startPosition = this.tokenManager.findSourcePositionInLine(token.originalStart);
@@ -286,59 +300,67 @@ public class DefaultCodeFormatter extends CodeFormatter {
 	}
 
 	private ASTNode parseSourceCode(int kind) {
+		kind = kind & K_MASK;
+		if (kind != K_UNKNOWN) {
+			ASTNode astNode = createParser(kind).createAST(null);
+			if (kind == K_COMPILATION_UNIT || kind == K_MODULE_INFO)
+				return astNode;
+			return hasErrors(astNode) ? null : astNode;
+		}
+
+		int[] kindsToTry = { K_COMPILATION_UNIT, K_EXPRESSION, K_CLASS_BODY_DECLARATIONS, K_STATEMENTS, K_MODULE_INFO };
+		for (int kindToTry : kindsToTry) {
+			ASTNode astNode = createParser(kindToTry).createAST(null);
+			if (!hasErrors(astNode)) {
+				if (kindToTry == K_MODULE_INFO) 
+					tokenizeSource(kindToTry); // run scanner again to get module specific tokens
+				return astNode;
+			}
+		}
+		return null;
+	}
+
+	private ASTParser createParser(int kind) {
 		ASTParser parser = ASTParser.newParser(AST.JLS9);
+
+		if (kind == K_MODULE_INFO) {
+			Path fakeModuleInfoPath = new Path("project/" + TypeConstants.MODULE_INFO_FILE_NAME_STRING); //$NON-NLS-1$
+			IFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(fakeModuleInfoPath);
+			ICompilationUnit unit = JavaCore.createCompilationUnitFrom(file);
+			parser.setSource(new org.eclipse.jdt.internal.core.CompilationUnit((PackageFragment) unit.getParent(),
+					unit.getElementName(), unit.getOwner()) {
+				@Override
+				public char[] getContents() {
+					return DefaultCodeFormatter.this.sourceArray;
+				}
+			});
+		} else {
+			parser.setSource(this.sourceArray);
+		}
+		parser.setKind(FORMAT_TO_PARSER_KIND.get(kind));
+
 		Map<String, String> parserOptions = JavaCore.getOptions();
 		parserOptions.put(CompilerOptions.OPTION_Source, this.sourceLevel);
 		parserOptions.put(CompilerOptions.OPTION_DocCommentSupport, CompilerOptions.ENABLED);
 		parser.setCompilerOptions(parserOptions);
-
-		switch (kind & K_MASK) {
-			case K_COMPILATION_UNIT:
-				return parseSourceCode(parser, ASTParser.K_COMPILATION_UNIT, true);
-			case K_CLASS_BODY_DECLARATIONS:
-				return parseSourceCode(parser, ASTParser.K_CLASS_BODY_DECLARATIONS, false);
-			case K_STATEMENTS:
-				return parseSourceCode(parser, ASTParser.K_STATEMENTS, false);
-			case K_EXPRESSION:
-				return parseSourceCode(parser, ASTParser.K_EXPRESSION, false);
-			case K_UNKNOWN:
-				int[] parserModes = { ASTParser.K_COMPILATION_UNIT, ASTParser.K_EXPRESSION,
-						ASTParser.K_CLASS_BODY_DECLARATIONS, ASTParser.K_STATEMENTS };
-				for (int parserMode : parserModes) {
-					ASTNode astNode = parseSourceCode(parser, parserMode, false);
-					if (astNode != null)
-						return astNode;
-					parser.setCompilerOptions(parserOptions); // parser loses compiler options after every use
-				}
-				return null;
-			default:
-				throw new IllegalArgumentException();
-		}
+		return parser;
 	}
 
-	private ASTNode parseSourceCode(ASTParser parser, int parserMode, boolean ignoreErrors) {
-		parser.setKind(parserMode);
-		parser.setSource(this.sourceArray);
-		ASTNode astNode = parser.createAST(null);
-		if (ignoreErrors)
-			return astNode;
-
-		boolean hasErrors = false;
+	private boolean hasErrors(ASTNode astNode) {
 		CompilationUnit root = (CompilationUnit) astNode.getRoot();
 		for (IProblem problem : root.getProblems()) {
-			if (problem.isError()) {
-				hasErrors = true;
-				break;
-			}
+			if (problem.isError())
+				return true;
 		}
-		return hasErrors ? null : astNode;
+		return false;
 	}
 
-	private void tokenizeSource() {
+	private void tokenizeSource(int kind) {
 		this.tokens.clear();
 		Scanner scanner = new Scanner(true, false, false/* nls */, CompilerOptions.versionToJdkLevel(this.sourceLevel),
 				null/* taskTags */, null/* taskPriorities */, false/* taskCaseSensitive */);
 		scanner.setSource(this.sourceArray);
+		scanner.fakeInModule = (kind & K_MODULE_INFO) != 0;
 		while (true) {
 			try {
 				int tokenType = scanner.getNextToken();
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
index d35679a..5120ed4 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
@@ -124,6 +124,7 @@ public class DefaultCodeFormatterOptions {
 	public int alignment_for_expressions_in_array_initializer;
 	public int alignment_for_expressions_in_for_loop_header;
 	public int alignment_for_method_declaration;
+	public int alignment_for_module_statements;
 	// TODO following option cannot be set in preferences dialog (but it's used by old.CodeFormatter)
 	public int alignment_for_multiple_fields;
 	public int alignment_for_parameterized_type_references;
@@ -460,6 +461,7 @@ public class DefaultCodeFormatterOptions {
 		options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_EXPRESSIONS_IN_ARRAY_INITIALIZER, getAlignment(this.alignment_for_expressions_in_array_initializer));
 		options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_EXPRESSIONS_IN_FOR_LOOP_HEADER, getAlignment(this.alignment_for_expressions_in_for_loop_header));
 		options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_METHOD_DECLARATION, getAlignment(this.alignment_for_method_declaration));
+		options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_MODULE_STATEMENTS, getAlignment(this.alignment_for_module_statements));
 		options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_MULTIPLE_FIELDS, getAlignment(this.alignment_for_multiple_fields));
 		options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_PARAMETERIZED_TYPE_REFERENCES, getAlignment(this.alignment_for_parameterized_type_references));
 		options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_PARAMETERS_IN_CONSTRUCTOR_DECLARATION, getAlignment(this.alignment_for_parameters_in_constructor_declaration));
@@ -897,6 +899,10 @@ public class DefaultCodeFormatterOptions {
 				this.alignment_for_method_declaration = Alignment.M_COMPACT_SPLIT;
 			}
 		}
+		final Object alignmentForModuleStatementsOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_MODULE_STATEMENTS);
+		if (alignmentForModuleStatementsOption != null)
+			this.alignment_for_module_statements = toInt(alignmentForModuleStatementsOption, Alignment.M_COMPACT_SPLIT);
+
 		final Object alignmentForMultipleFieldsOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_MULTIPLE_FIELDS);
 		if (alignmentForMultipleFieldsOption != null) {
 			try {
@@ -2430,6 +2436,7 @@ public class DefaultCodeFormatterOptions {
 		this.alignment_for_expressions_in_array_initializer = Alignment.M_COMPACT_SPLIT;
 		this.alignment_for_expressions_in_for_loop_header = Alignment.M_NO_ALIGNMENT;
 		this.alignment_for_method_declaration = Alignment.M_NO_ALIGNMENT;
+		this.alignment_for_module_statements = Alignment.M_COMPACT_SPLIT;
 		this.alignment_for_multiple_fields = Alignment.M_COMPACT_SPLIT;
 		this.alignment_for_parameterized_type_references = Alignment.M_NO_ALIGNMENT;
 		this.alignment_for_parameters_in_constructor_declaration = Alignment.M_COMPACT_SPLIT;
@@ -2740,6 +2747,7 @@ public class DefaultCodeFormatterOptions {
 		this.alignment_for_expressions_in_array_initializer = Alignment.M_COMPACT_SPLIT;
 		this.alignment_for_expressions_in_for_loop_header = Alignment.M_NO_ALIGNMENT;
 		this.alignment_for_method_declaration = Alignment.M_NO_ALIGNMENT;
+		this.alignment_for_module_statements = Alignment.M_COMPACT_SPLIT;
 		this.alignment_for_multiple_fields = Alignment.M_COMPACT_SPLIT;
 		this.alignment_for_parameterized_type_references = Alignment.M_NO_ALIGNMENT;
 		this.alignment_for_parameters_in_constructor_declaration = Alignment.M_COMPACT_SPLIT;
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
index fb34029..ddf781b 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java
@@ -60,6 +60,8 @@ import org.eclipse.jdt.core.dom.MarkerAnnotation;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
 import org.eclipse.jdt.core.dom.Modifier;
+import org.eclipse.jdt.core.dom.ModuleDeclaration;
+import org.eclipse.jdt.core.dom.ModuleStatement;
 import org.eclipse.jdt.core.dom.NormalAnnotation;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
 import org.eclipse.jdt.core.dom.ReturnStatement;
@@ -674,6 +676,28 @@ public class LineBreaksPreparator extends ASTVisitor {
 		return true;
 	}
 
+	@Override
+	public boolean visit(ModuleDeclaration node) {
+		// using settings for type declaration and fields for now, add new settings if necessary
+		breakLineBefore(node);
+		handleBracedCode(node, node.getName(), this.options.brace_position_for_type_declaration,
+				this.options.indent_body_declarations_compare_to_type_header,
+				this.options.insert_new_line_in_empty_type_declaration);
+
+		List<ModuleStatement> statements = node.moduleStatements();
+		ModuleStatement previous = null;
+		for (ModuleStatement statement : statements) {
+			int blankLines = previous == null ? this.options.blank_lines_before_first_class_body_declaration
+					: previous.getClass().equals(statement.getClass()) ? this.options.blank_lines_before_field
+							: this.options.blank_lines_before_new_chunk;
+			putBlankLinesBefore(statement, blankLines);
+			previous = statement;
+		}
+
+		this.declarationModifierVisited = false;
+		return true;
+	}
+
 	private void breakLineBefore(ASTNode node) {
 		this.tm.firstTokenIn(node, -1).breakBefore();
 	}
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java
index 03f1135..23bb472 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java
@@ -40,6 +40,7 @@ import org.eclipse.jdt.core.dom.DoStatement;
 import org.eclipse.jdt.core.dom.EnhancedForStatement;
 import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
 import org.eclipse.jdt.core.dom.EnumDeclaration;
+import org.eclipse.jdt.core.dom.ExportsStatement;
 import org.eclipse.jdt.core.dom.Expression;
 import org.eclipse.jdt.core.dom.ExpressionMethodReference;
 import org.eclipse.jdt.core.dom.ExpressionStatement;
@@ -56,12 +57,16 @@ import org.eclipse.jdt.core.dom.MarkerAnnotation;
 import org.eclipse.jdt.core.dom.MemberValuePair;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
+import org.eclipse.jdt.core.dom.ModuleDeclaration;
+import org.eclipse.jdt.core.dom.Name;
 import org.eclipse.jdt.core.dom.NormalAnnotation;
+import org.eclipse.jdt.core.dom.OpensStatement;
 import org.eclipse.jdt.core.dom.PackageDeclaration;
 import org.eclipse.jdt.core.dom.ParameterizedType;
 import org.eclipse.jdt.core.dom.ParenthesizedExpression;
 import org.eclipse.jdt.core.dom.PostfixExpression;
 import org.eclipse.jdt.core.dom.PrefixExpression;
+import org.eclipse.jdt.core.dom.ProvidesStatement;
 import org.eclipse.jdt.core.dom.PrefixExpression.Operator;
 import org.eclipse.jdt.core.dom.ReturnStatement;
 import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
@@ -951,6 +956,37 @@ public class SpacePreparator extends ASTVisitor {
 		return true;
 	}
 
+	@Override
+	public boolean visit(ModuleDeclaration node) {
+		handleToken(node.getName(), TokenNameLBRACE,
+				this.options.insert_space_before_opening_brace_in_type_declaration, false);
+		return true;
+	}
+
+	@Override
+	public boolean visit(ExportsStatement node) {
+		handleModuleStatementCommas(node.modules());
+		return true;
+	}
+	
+	@Override
+	public boolean visit(OpensStatement node) {
+		handleModuleStatementCommas(node.modules());
+		return true;
+	}
+
+	@Override
+	public boolean visit(ProvidesStatement node) {
+		handleModuleStatementCommas(node.implementations());
+		return true;
+	}
+
+	private void handleModuleStatementCommas(List<Name> names) {
+		// using settings for fields for now, add new settings if necessary
+		handleCommas(names, this.options.insert_space_before_comma_in_multiple_field_declarations,
+				this.options.insert_space_after_comma_in_multiple_field_declarations);
+	}
+
 	private void handleCommas(List<? extends ASTNode> nodes, boolean spaceBefore, boolean spaceAfter) {
 		if (spaceBefore || spaceAfter) {
 			for (int i = 1; i < nodes.size(); i++) {
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
index 8909b86..41a5cdf 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/WrapPreparator.java
@@ -34,6 +34,8 @@ import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamen
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamesuper;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamethis;
 import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamethrows;
+import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNameto;
+import static org.eclipse.jdt.internal.compiler.parser.TerminalTokens.TokenNamewith;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -55,6 +57,7 @@ import org.eclipse.jdt.core.dom.ConstructorInvocation;
 import org.eclipse.jdt.core.dom.CreationReference;
 import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
 import org.eclipse.jdt.core.dom.EnumDeclaration;
+import org.eclipse.jdt.core.dom.ExportsStatement;
 import org.eclipse.jdt.core.dom.Expression;
 import org.eclipse.jdt.core.dom.ExpressionMethodReference;
 import org.eclipse.jdt.core.dom.FieldAccess;
@@ -67,8 +70,11 @@ import org.eclipse.jdt.core.dom.InfixExpression.Operator;
 import org.eclipse.jdt.core.dom.LambdaExpression;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.MethodInvocation;
+import org.eclipse.jdt.core.dom.Name;
 import org.eclipse.jdt.core.dom.NormalAnnotation;
+import org.eclipse.jdt.core.dom.OpensStatement;
 import org.eclipse.jdt.core.dom.ParameterizedType;
+import org.eclipse.jdt.core.dom.ProvidesStatement;
 import org.eclipse.jdt.core.dom.QualifiedName;
 import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.Statement;
@@ -779,6 +785,34 @@ public class WrapPreparator extends ASTVisitor {
 		handleWrap(this.options.alignment_for_type_arguments);
 	}
 
+	@Override
+	public boolean visit(ExportsStatement node) {
+		handleModuleStatement(node.modules(), TokenNameto);
+		return true;
+	}
+
+	@Override
+	public boolean visit(OpensStatement node) {
+		handleModuleStatement(node.modules(), TokenNameto);
+		return true;
+	}
+
+	@Override
+	public boolean visit(ProvidesStatement node) {
+		handleModuleStatement(node.implementations(), TokenNamewith);
+		return true;
+	}
+
+	private void handleModuleStatement(List<Name> names, int joiningTokenType) {
+		if (names.isEmpty())
+			return;
+		int joiningTokenIndex = this.tm.firstIndexBefore(names.get(0), joiningTokenType);
+		this.wrapParentIndex = this.tm.firstIndexBefore(names.get(0), TokenNameIdentifier);
+		this.wrapIndexes.add(joiningTokenIndex);
+		prepareElementsList(names, TokenNameCOMMA, -1);
+		handleWrap(this.options.alignment_for_module_statements, PREFERRED);
+	}
+
 	/**
 	 * Makes sure all new lines within given node will have wrap policy so that
 	 * wrap executor will fix their indentation if necessary.
@@ -1025,7 +1059,7 @@ public class WrapPreparator extends ASTVisitor {
 		int endingBreaks = getLineBreaksToPreserve(last, null, false);
 		if (endingBreaks > 0) {
 			last.putLineBreaksAfter(endingBreaks);
-		} else if ((this.kind & CodeFormatter.K_COMPILATION_UNIT) != 0
+		} else if ((this.kind & (CodeFormatter.K_COMPILATION_UNIT | CodeFormatter.K_MODULE_INFO)) != 0
 				&& this.options.insert_new_line_at_end_of_file_if_missing) {
 			last.breakAfter();
 		}
commit 7cd689e47acb28ea4d32dafcdb91c140b9faaa25
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Fri Aug 4 21:11:10 2017 +0530

    Enabler for fix of Bug 506430: [1.9] Formatter support for
    module-info.java
    
    Change-Id: Ia2f93e97f38617cf3e17cc8fbb1410f9fbe752fe

82	9	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
80	0	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
23	2	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
index 67a7006..16556f1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
@@ -4,7 +4,11 @@
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Brock Janiczak - Contribution for bug 150741
@@ -189,14 +193,31 @@ public class FormatterRegressionTests extends AbstractJavaModelTests {
 	}
 
 	String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, IRegion[] regions, String lineSeparator) {
-//		long time = System.currentTimeMillis();
 		TextEdit edit = codeFormatter.format(kind, source, regions, indentationLevel, lineSeparator);//$NON-NLS-1$
-//		System.out.println((System.currentTimeMillis() - time) + " ms");
+		return edit == null ? null : org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);
+	}
+
+	String runFormatterModuleInfoFile(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator, boolean repeat) {
+		TextEdit edit = codeFormatter.formatModuleInfoFile(kind, source, offset, length, indentationLevel, lineSeparator);//$NON-NLS-1$
 		if (edit == null) return null;
+		String result = org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);
+
+		if (repeat && length == source.length()) {
+			edit = codeFormatter.formatModuleInfoFile(kind, result, 0, result.length(), indentationLevel, lineSeparator);//$NON-NLS-1$
+			if (edit == null) return null;
+			final String result2 = org.eclipse.jdt.internal.core.util.Util.editedString(result, edit);
+			if (!result.equals(result2)) {
+				assertSourceEquals("Second formatting is different from first one!", Util.convertToIndependantLineDelimiter(result), Util.convertToIndependantLineDelimiter(result2));
+			}
+		}
+		return result;
+	}
 
-		return org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);
+	String runFormatterModuleInfoFile(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, IRegion[] regions, String lineSeparator) {
+		TextEdit edit = codeFormatter.formatModuleInfoFile(kind, source, regions, indentationLevel, lineSeparator);//$NON-NLS-1$
+		return edit == null ? null : org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);
 	}
-	
+
 	/**
 	 * Init formatter preferences with Eclipse default settings.
 	 */
@@ -343,6 +364,58 @@ public class FormatterRegressionTests extends AbstractJavaModelTests {
 		}
 	}
 
+	void formatSourceModuleInfoFile(String source, String formattedOutput, int kind) {
+		formatSourceModuleInfoFile(source, formattedOutput, kind, 0, true /*repeat formatting twice*/);
+	}
+	void formatSourceModuleInfoFile(String source, String formattedOutput, int kind, int indentationLevel, int offset, int length, String lineSeparator, boolean repeat) {
+		DefaultCodeFormatter codeFormatter = codeFormatter();
+		String result;
+		if (length == -1) {
+			result = runFormatterModuleInfoFile(codeFormatter, source, kind, indentationLevel, offset, source.length(), lineSeparator, repeat);
+		} else {
+			result = runFormatterModuleInfoFile(codeFormatter, source, kind, indentationLevel, offset, length, lineSeparator, repeat);
+		}
+		if (lineSeparator == null) {
+			assertLineEquals(result, source, formattedOutput);
+		} else {
+			// Do not convert line delimiter while comparing result when a specific one is specified
+			assertNotNull("Error(s) occured while formatting", result);
+			String outputSource = formattedOutput == null ? source : formattedOutput;
+			assertSourceEquals("Different number of length", outputSource, result, false/*do not convert line delimiter*/);
+		}
+	}
+
+	void formatSourceModuleInfoFile(String source, String formattedOutput, int kind, int indentationLevel, boolean repeat) {
+		int regionStart = source.indexOf("[#");
+		if (regionStart != -1) {
+			ArrayList<IRegion> regions =  new ArrayList<>();
+			int start = 0;
+			int delta = 0;
+			StringBuffer buffer = new StringBuffer();
+			while (regionStart != -1) {
+				buffer.append(source.substring(start, regionStart));
+				int regionEnd = source.indexOf("#]", regionStart+2);
+				buffer.append(source.substring(regionStart+2, regionEnd));
+				regions.add(new Region(regionStart-delta, regionEnd-(regionStart+2)));
+				delta += 4;
+				start = regionEnd + 2;
+				regionStart = source.indexOf("[#", start);
+			}
+			buffer.append(source.substring(start, source.length()));
+			String newSource = buffer.toString();
+			String result;
+			if (regions.size() == 1) {
+				// Use offset and length until bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=233967 is fixed
+				result = runFormatterModuleInfoFile(codeFormatter(), newSource, kind, indentationLevel, regions.get(0).getOffset(), regions.get(0).getLength(), LINE_SEPARATOR, repeat);
+			} else {
+				IRegion[] regionsArray = regions.toArray(new IRegion[regions.size()]);
+				result = runFormatterModuleInfoFile(codeFormatter(), newSource, kind, indentationLevel, regionsArray, LINE_SEPARATOR);
+			}
+			assertLineEquals(result, newSource, formattedOutput);
+		} else {
+			formatSourceModuleInfoFile(source, formattedOutput, kind, indentationLevel, 0, -1, null, repeat);
+		}
+	}
 
 	private void runTest(String packageName, String compilationUnitName) {
 		DefaultCodeFormatterOptions preferences = new DefaultCodeFormatterOptions(DefaultCodeFormatterConstants.getEclipse21Settings());
@@ -14012,8 +14085,8 @@ public void testBug506430a() throws JavaModelException {
 	setComplianceLevel(CompilerOptions.VERSION_9);
 	setPageWidth80();
 	String input = getCompilationUnit("Formatter", "", "test506430", "A_in.java").getSource();
-	formatSource(input, getCompilationUnit("Formatter", "", "test506430", "A_out.java") .getSource(),
-			CodeFormatter.K_MODULE_INFO | CodeFormatter.F_INCLUDE_COMMENTS);
+	formatSourceModuleInfoFile(input, getCompilationUnit("Formatter", "", "test506430", "A_out.java") .getSource(),
+			CodeFormatter.K_COMPILATION_UNIT | CodeFormatter.F_INCLUDE_COMMENTS);
 }
 /**
  * https://bugs.eclipse.org/506430 - [1.9] Formatter support for module-info.java
@@ -14030,7 +14103,7 @@ public void testBug506430b() throws JavaModelException {
 	this.formatterPrefs.alignment_for_module_statements = Alignment.M_NEXT_PER_LINE_SPLIT;
 	this.formatterPrefs.insert_new_line_at_end_of_file_if_missing = true;
 	String input = getCompilationUnit("Formatter", "", "test506430", "B_in.java").getSource();
-	formatSource(input, getCompilationUnit("Formatter", "", "test506430", "B_out.java") .getSource(),
+	formatSourceModuleInfoFile(input, getCompilationUnit("Formatter", "", "test506430", "B_out.java") .getSource(),
 			CodeFormatter.K_MODULE_INFO | CodeFormatter.F_INCLUDE_COMMENTS);
 }
 /**
@@ -14040,7 +14113,7 @@ public void testBug506430c() throws JavaModelException {
 	setComplianceLevel(CompilerOptions.VERSION_9);
 	setPageWidth80();
 	String input = getCompilationUnit("Formatter", "", "test506430", "A_in.java").getSource();
-	formatSource(input, getCompilationUnit("Formatter", "", "test506430", "A_out.java") .getSource(),
+	formatSourceModuleInfoFile(input, getCompilationUnit("Formatter", "", "test506430", "A_out.java") .getSource(),
 			CodeFormatter.K_UNKNOWN | CodeFormatter.F_INCLUDE_COMMENTS);
 }
 }
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
index 4b46f88..9d539b5 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Harry Terkelsen (het@google.com) - Bug 449262 - Allow the use of third-party Java formatters
@@ -284,6 +288,82 @@ public abstract class CodeFormatter {
 	public abstract TextEdit format(int kind, String source, IRegion[] regions, int indentationLevel, String lineSeparator);
 
 	/**
+	 * Format <code>source</code> in a module-info.java file,
+	 * and returns a text edit that correspond to the difference between the given
+	 * string and the formatted string.
+	 * <p>
+	 * It returns null if the given string cannot be formatted.
+	 * </p><p>
+	 * If the offset position is matching a whitespace, the result can include
+	 * whitespaces. It would be up to the caller to get rid of preceding
+	 * whitespaces.
+	 * </p>
+	 *
+	 * @param kind Use to specify the kind of the code snippet to format. It can
+	 * be any of these:
+	 * <ul>
+	 * 	<li>{@link #K_EXPRESSION}</li>
+	 * 	<li>{@link #K_STATEMENTS}</li>
+	 * 	<li>{@link #K_CLASS_BODY_DECLARATIONS}</li>
+	 * 	<li>{@link #K_COMPILATION_UNIT}</li>
+	 * 	<li>{@link #K_UNKNOWN}</li>
+	 * 	<li>{@link #K_SINGLE_LINE_COMMENT}</li>
+	 * 	<li>{@link #K_MULTI_LINE_COMMENT}</li>
+	 * 	<li>{@link #K_JAVA_DOC}</li>
+	 * </ul>
+	 * @param source the source to format
+	 * @param offset the given offset to start recording the edits (inclusive).
+	 * @param length the given length to stop recording the edits (exclusive).
+	 * @param indentationLevel the initial indentation level, used
+	 *      to shift left/right the entire source fragment. An initial indentation
+	 *      level of zero or below has no effect.
+	 * @param lineSeparator the line separator to use in formatted source,
+	 *     if set to <code>null</code>, then the platform default one will be used.
+	 * @return the text edit
+	 * @throws IllegalArgumentException if offset is lower than 0, length is lower than 0 or
+	 * length is greater than source length.
+	 */
+	public abstract TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator);
+
+	/**
+	 * Format <code>source</code> in a module-info.java file,
+	 * and returns a text edit that correspond to the difference between the given string and the formatted string.
+	 * <p>It returns null if the given string cannot be formatted.</p>
+	 *
+	 * <p>If an offset position is matching a whitespace, the result can include whitespaces. It would be up to the
+	 * caller to get rid of preceding whitespaces.</p>
+	 *
+	 * <p>No region in <code>regions</code> must overlap with any other region in <code>regions</code>.
+	 * Each region must be within source. There must be at least one region. Regions must be sorted
+	 * by their offsets, smaller offset first.</p>
+	 *
+	 * @param kind Use to specify the kind of the code snippet to format. It can
+	 * be any of these:
+	 * <ul>
+	 * 	<li>{@link #K_EXPRESSION}</li>
+	 * 	<li>{@link #K_STATEMENTS}</li>
+	 * 	<li>{@link #K_CLASS_BODY_DECLARATIONS}</li>
+	 * 	<li>{@link #K_COMPILATION_UNIT}</li>
+	 * 	<li>{@link #K_UNKNOWN}</li>
+	 * 	<li>{@link #K_SINGLE_LINE_COMMENT}</li>
+	 * 	<li>{@link #K_MULTI_LINE_COMMENT}</li>
+	 * 	<li>{@link #K_JAVA_DOC}</li>
+	 * </ul>
+	 * @param source the source to format
+	 * @param regions a set of regions in source to format
+	 * @param indentationLevel the initial indentation level, used
+	 *      to shift left/right the entire source fragment. An initial indentation
+	 *      level of zero or below has no effect.
+	 * @param lineSeparator the line separator to use in formatted source,
+	 *     if set to <code>null</code>, then the platform default one will be used.
+	 * @return the text edit
+	 * @throws IllegalArgumentException if there is no region, a region overlaps with another region, or the regions are not
+	 * sorted in the ascending order.
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public abstract TextEdit formatModuleInfoFile(int kind, String source, IRegion[] regions, int indentationLevel, String lineSeparator);
+
+	/**
 	 * Answers the string that corresponds to the indentation to the given indentation level or an empty string
 	 * if the indentation cannot be computed.
 	 * <p>This method needs to be overridden in a subclass.</p>
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
index 683d70d..4b8958f 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Jesper Steen Moller - Contributions for
@@ -100,6 +104,8 @@ public class DefaultCodeFormatter extends CodeFormatter {
 	private List<Token> tokens = new ArrayList<>();
 	private TokenManager tokenManager;
 
+	private boolean isInModuleInfo = false;
+
 	public DefaultCodeFormatter() {
 		this(new DefaultCodeFormatterOptions(DefaultCodeFormatterConstants.getJavaConventionsSettings()), null);
 	}
@@ -187,6 +193,21 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		return result;
 	}
 
+	/**
+	 * @see org.eclipse.jdt.core.formatter.CodeFormatter#formatModuleInfoFile(int, java.lang.String, int, int, int, java.lang.String)
+	 */
+	public TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator) {
+		this.isInModuleInfo = true;
+		return format(kind, source, new IRegion[] { new Region(offset, length) }, indentationLevel, lineSeparator);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public TextEdit formatModuleInfoFile(int kind, String source, IRegion[] regions, int indentationLevel, String lineSeparator) {
+		this.isInModuleInfo = true;
+		return format(kind, source, regions, indentationLevel, lineSeparator);
+	}
 	private boolean init(String source, int kind) {
 
 		// this is convenient for debugging (see Token.toString())
@@ -327,7 +348,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 	private ASTParser createParser(int kind) {
 		ASTParser parser = ASTParser.newParser(AST.JLS9);
 
-		if (kind == K_MODULE_INFO) {
+		if (this.isInModuleInfo) {
 			Path fakeModuleInfoPath = new Path("project/" + TypeConstants.MODULE_INFO_FILE_NAME_STRING); //$NON-NLS-1$
 			IFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(fakeModuleInfoPath);
 			ICompilationUnit unit = JavaCore.createCompilationUnitFrom(file);
@@ -364,7 +385,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		Scanner scanner = new Scanner(true, false, false/* nls */, CompilerOptions.versionToJdkLevel(this.sourceLevel),
 				null/* taskTags */, null/* taskPriorities */, false/* taskCaseSensitive */);
 		scanner.setSource(this.sourceArray);
-		scanner.fakeInModule = (kind & K_MODULE_INFO) != 0;
+		scanner.fakeInModule = this.isInModuleInfo;
 		while (true) {
 			try {
 				int tokenType = scanner.getNextToken();
commit 3eeae7f125ec3cc66e40d1816d49730d896f5053
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Tue Aug 8 09:27:30 2017 +0530

    Revert "Enabler for fix of Bug 506430: [1.9] Formatter support for module-info.java"
    
    This reverts commit 7cd689e47acb28ea4d32dafcdb91c140b9faaa25.

9	82	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
0	80	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
2	23	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
index 16556f1..67a7006 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
@@ -4,11 +4,7 @@
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Brock Janiczak - Contribution for bug 150741
@@ -193,31 +189,14 @@ public class FormatterRegressionTests extends AbstractJavaModelTests {
 	}
 
 	String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, IRegion[] regions, String lineSeparator) {
+//		long time = System.currentTimeMillis();
 		TextEdit edit = codeFormatter.format(kind, source, regions, indentationLevel, lineSeparator);//$NON-NLS-1$
-		return edit == null ? null : org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);
-	}
-
-	String runFormatterModuleInfoFile(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator, boolean repeat) {
-		TextEdit edit = codeFormatter.formatModuleInfoFile(kind, source, offset, length, indentationLevel, lineSeparator);//$NON-NLS-1$
+//		System.out.println((System.currentTimeMillis() - time) + " ms");
 		if (edit == null) return null;
-		String result = org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);
-
-		if (repeat && length == source.length()) {
-			edit = codeFormatter.formatModuleInfoFile(kind, result, 0, result.length(), indentationLevel, lineSeparator);//$NON-NLS-1$
-			if (edit == null) return null;
-			final String result2 = org.eclipse.jdt.internal.core.util.Util.editedString(result, edit);
-			if (!result.equals(result2)) {
-				assertSourceEquals("Second formatting is different from first one!", Util.convertToIndependantLineDelimiter(result), Util.convertToIndependantLineDelimiter(result2));
-			}
-		}
-		return result;
-	}
 
-	String runFormatterModuleInfoFile(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, IRegion[] regions, String lineSeparator) {
-		TextEdit edit = codeFormatter.formatModuleInfoFile(kind, source, regions, indentationLevel, lineSeparator);//$NON-NLS-1$
-		return edit == null ? null : org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);
+		return org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);
 	}
-
+	
 	/**
 	 * Init formatter preferences with Eclipse default settings.
 	 */
@@ -364,58 +343,6 @@ public class FormatterRegressionTests extends AbstractJavaModelTests {
 		}
 	}
 
-	void formatSourceModuleInfoFile(String source, String formattedOutput, int kind) {
-		formatSourceModuleInfoFile(source, formattedOutput, kind, 0, true /*repeat formatting twice*/);
-	}
-	void formatSourceModuleInfoFile(String source, String formattedOutput, int kind, int indentationLevel, int offset, int length, String lineSeparator, boolean repeat) {
-		DefaultCodeFormatter codeFormatter = codeFormatter();
-		String result;
-		if (length == -1) {
-			result = runFormatterModuleInfoFile(codeFormatter, source, kind, indentationLevel, offset, source.length(), lineSeparator, repeat);
-		} else {
-			result = runFormatterModuleInfoFile(codeFormatter, source, kind, indentationLevel, offset, length, lineSeparator, repeat);
-		}
-		if (lineSeparator == null) {
-			assertLineEquals(result, source, formattedOutput);
-		} else {
-			// Do not convert line delimiter while comparing result when a specific one is specified
-			assertNotNull("Error(s) occured while formatting", result);
-			String outputSource = formattedOutput == null ? source : formattedOutput;
-			assertSourceEquals("Different number of length", outputSource, result, false/*do not convert line delimiter*/);
-		}
-	}
-
-	void formatSourceModuleInfoFile(String source, String formattedOutput, int kind, int indentationLevel, boolean repeat) {
-		int regionStart = source.indexOf("[#");
-		if (regionStart != -1) {
-			ArrayList<IRegion> regions =  new ArrayList<>();
-			int start = 0;
-			int delta = 0;
-			StringBuffer buffer = new StringBuffer();
-			while (regionStart != -1) {
-				buffer.append(source.substring(start, regionStart));
-				int regionEnd = source.indexOf("#]", regionStart+2);
-				buffer.append(source.substring(regionStart+2, regionEnd));
-				regions.add(new Region(regionStart-delta, regionEnd-(regionStart+2)));
-				delta += 4;
-				start = regionEnd + 2;
-				regionStart = source.indexOf("[#", start);
-			}
-			buffer.append(source.substring(start, source.length()));
-			String newSource = buffer.toString();
-			String result;
-			if (regions.size() == 1) {
-				// Use offset and length until bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=233967 is fixed
-				result = runFormatterModuleInfoFile(codeFormatter(), newSource, kind, indentationLevel, regions.get(0).getOffset(), regions.get(0).getLength(), LINE_SEPARATOR, repeat);
-			} else {
-				IRegion[] regionsArray = regions.toArray(new IRegion[regions.size()]);
-				result = runFormatterModuleInfoFile(codeFormatter(), newSource, kind, indentationLevel, regionsArray, LINE_SEPARATOR);
-			}
-			assertLineEquals(result, newSource, formattedOutput);
-		} else {
-			formatSourceModuleInfoFile(source, formattedOutput, kind, indentationLevel, 0, -1, null, repeat);
-		}
-	}
 
 	private void runTest(String packageName, String compilationUnitName) {
 		DefaultCodeFormatterOptions preferences = new DefaultCodeFormatterOptions(DefaultCodeFormatterConstants.getEclipse21Settings());
@@ -14085,8 +14012,8 @@ public void testBug506430a() throws JavaModelException {
 	setComplianceLevel(CompilerOptions.VERSION_9);
 	setPageWidth80();
 	String input = getCompilationUnit("Formatter", "", "test506430", "A_in.java").getSource();
-	formatSourceModuleInfoFile(input, getCompilationUnit("Formatter", "", "test506430", "A_out.java") .getSource(),
-			CodeFormatter.K_COMPILATION_UNIT | CodeFormatter.F_INCLUDE_COMMENTS);
+	formatSource(input, getCompilationUnit("Formatter", "", "test506430", "A_out.java") .getSource(),
+			CodeFormatter.K_MODULE_INFO | CodeFormatter.F_INCLUDE_COMMENTS);
 }
 /**
  * https://bugs.eclipse.org/506430 - [1.9] Formatter support for module-info.java
@@ -14103,7 +14030,7 @@ public void testBug506430b() throws JavaModelException {
 	this.formatterPrefs.alignment_for_module_statements = Alignment.M_NEXT_PER_LINE_SPLIT;
 	this.formatterPrefs.insert_new_line_at_end_of_file_if_missing = true;
 	String input = getCompilationUnit("Formatter", "", "test506430", "B_in.java").getSource();
-	formatSourceModuleInfoFile(input, getCompilationUnit("Formatter", "", "test506430", "B_out.java") .getSource(),
+	formatSource(input, getCompilationUnit("Formatter", "", "test506430", "B_out.java") .getSource(),
 			CodeFormatter.K_MODULE_INFO | CodeFormatter.F_INCLUDE_COMMENTS);
 }
 /**
@@ -14113,7 +14040,7 @@ public void testBug506430c() throws JavaModelException {
 	setComplianceLevel(CompilerOptions.VERSION_9);
 	setPageWidth80();
 	String input = getCompilationUnit("Formatter", "", "test506430", "A_in.java").getSource();
-	formatSourceModuleInfoFile(input, getCompilationUnit("Formatter", "", "test506430", "A_out.java") .getSource(),
+	formatSource(input, getCompilationUnit("Formatter", "", "test506430", "A_out.java") .getSource(),
 			CodeFormatter.K_UNKNOWN | CodeFormatter.F_INCLUDE_COMMENTS);
 }
 }
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
index 9d539b5..4b46f88 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
@@ -5,10 +5,6 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Harry Terkelsen (het@google.com) - Bug 449262 - Allow the use of third-party Java formatters
@@ -288,82 +284,6 @@ public abstract class CodeFormatter {
 	public abstract TextEdit format(int kind, String source, IRegion[] regions, int indentationLevel, String lineSeparator);
 
 	/**
-	 * Format <code>source</code> in a module-info.java file,
-	 * and returns a text edit that correspond to the difference between the given
-	 * string and the formatted string.
-	 * <p>
-	 * It returns null if the given string cannot be formatted.
-	 * </p><p>
-	 * If the offset position is matching a whitespace, the result can include
-	 * whitespaces. It would be up to the caller to get rid of preceding
-	 * whitespaces.
-	 * </p>
-	 *
-	 * @param kind Use to specify the kind of the code snippet to format. It can
-	 * be any of these:
-	 * <ul>
-	 * 	<li>{@link #K_EXPRESSION}</li>
-	 * 	<li>{@link #K_STATEMENTS}</li>
-	 * 	<li>{@link #K_CLASS_BODY_DECLARATIONS}</li>
-	 * 	<li>{@link #K_COMPILATION_UNIT}</li>
-	 * 	<li>{@link #K_UNKNOWN}</li>
-	 * 	<li>{@link #K_SINGLE_LINE_COMMENT}</li>
-	 * 	<li>{@link #K_MULTI_LINE_COMMENT}</li>
-	 * 	<li>{@link #K_JAVA_DOC}</li>
-	 * </ul>
-	 * @param source the source to format
-	 * @param offset the given offset to start recording the edits (inclusive).
-	 * @param length the given length to stop recording the edits (exclusive).
-	 * @param indentationLevel the initial indentation level, used
-	 *      to shift left/right the entire source fragment. An initial indentation
-	 *      level of zero or below has no effect.
-	 * @param lineSeparator the line separator to use in formatted source,
-	 *     if set to <code>null</code>, then the platform default one will be used.
-	 * @return the text edit
-	 * @throws IllegalArgumentException if offset is lower than 0, length is lower than 0 or
-	 * length is greater than source length.
-	 */
-	public abstract TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator);
-
-	/**
-	 * Format <code>source</code> in a module-info.java file,
-	 * and returns a text edit that correspond to the difference between the given string and the formatted string.
-	 * <p>It returns null if the given string cannot be formatted.</p>
-	 *
-	 * <p>If an offset position is matching a whitespace, the result can include whitespaces. It would be up to the
-	 * caller to get rid of preceding whitespaces.</p>
-	 *
-	 * <p>No region in <code>regions</code> must overlap with any other region in <code>regions</code>.
-	 * Each region must be within source. There must be at least one region. Regions must be sorted
-	 * by their offsets, smaller offset first.</p>
-	 *
-	 * @param kind Use to specify the kind of the code snippet to format. It can
-	 * be any of these:
-	 * <ul>
-	 * 	<li>{@link #K_EXPRESSION}</li>
-	 * 	<li>{@link #K_STATEMENTS}</li>
-	 * 	<li>{@link #K_CLASS_BODY_DECLARATIONS}</li>
-	 * 	<li>{@link #K_COMPILATION_UNIT}</li>
-	 * 	<li>{@link #K_UNKNOWN}</li>
-	 * 	<li>{@link #K_SINGLE_LINE_COMMENT}</li>
-	 * 	<li>{@link #K_MULTI_LINE_COMMENT}</li>
-	 * 	<li>{@link #K_JAVA_DOC}</li>
-	 * </ul>
-	 * @param source the source to format
-	 * @param regions a set of regions in source to format
-	 * @param indentationLevel the initial indentation level, used
-	 *      to shift left/right the entire source fragment. An initial indentation
-	 *      level of zero or below has no effect.
-	 * @param lineSeparator the line separator to use in formatted source,
-	 *     if set to <code>null</code>, then the platform default one will be used.
-	 * @return the text edit
-	 * @throws IllegalArgumentException if there is no region, a region overlaps with another region, or the regions are not
-	 * sorted in the ascending order.
-	 * @since 3.13 BETA_JAVA9
-	 */
-	public abstract TextEdit formatModuleInfoFile(int kind, String source, IRegion[] regions, int indentationLevel, String lineSeparator);
-
-	/**
 	 * Answers the string that corresponds to the indentation to the given indentation level or an empty string
 	 * if the indentation cannot be computed.
 	 * <p>This method needs to be overridden in a subclass.</p>
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
index 4b8958f..683d70d 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
@@ -5,10 +5,6 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Jesper Steen Moller - Contributions for
@@ -104,8 +100,6 @@ public class DefaultCodeFormatter extends CodeFormatter {
 	private List<Token> tokens = new ArrayList<>();
 	private TokenManager tokenManager;
 
-	private boolean isInModuleInfo = false;
-
 	public DefaultCodeFormatter() {
 		this(new DefaultCodeFormatterOptions(DefaultCodeFormatterConstants.getJavaConventionsSettings()), null);
 	}
@@ -193,21 +187,6 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		return result;
 	}
 
-	/**
-	 * @see org.eclipse.jdt.core.formatter.CodeFormatter#formatModuleInfoFile(int, java.lang.String, int, int, int, java.lang.String)
-	 */
-	public TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator) {
-		this.isInModuleInfo = true;
-		return format(kind, source, new IRegion[] { new Region(offset, length) }, indentationLevel, lineSeparator);
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	public TextEdit formatModuleInfoFile(int kind, String source, IRegion[] regions, int indentationLevel, String lineSeparator) {
-		this.isInModuleInfo = true;
-		return format(kind, source, regions, indentationLevel, lineSeparator);
-	}
 	private boolean init(String source, int kind) {
 
 		// this is convenient for debugging (see Token.toString())
@@ -348,7 +327,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 	private ASTParser createParser(int kind) {
 		ASTParser parser = ASTParser.newParser(AST.JLS9);
 
-		if (this.isInModuleInfo) {
+		if (kind == K_MODULE_INFO) {
 			Path fakeModuleInfoPath = new Path("project/" + TypeConstants.MODULE_INFO_FILE_NAME_STRING); //$NON-NLS-1$
 			IFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(fakeModuleInfoPath);
 			ICompilationUnit unit = JavaCore.createCompilationUnitFrom(file);
@@ -385,7 +364,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 		Scanner scanner = new Scanner(true, false, false/* nls */, CompilerOptions.versionToJdkLevel(this.sourceLevel),
 				null/* taskTags */, null/* taskPriorities */, false/* taskCaseSensitive */);
 		scanner.setSource(this.sourceArray);
-		scanner.fakeInModule = this.isInModuleInfo;
+		scanner.fakeInModule = (kind & K_MODULE_INFO) != 0;
 		while (true) {
 			try {
 				int tokenType = scanner.getNextToken();
commit 4d69e622c685dab4bb529a73447c5cb9832cf2e5
Author: Mateusz Matela <mateusz.matela@gmail.com>
Date:   Thu Aug 10 15:32:49 2017 +0200

    Bug 506430 - [1.9] Formatter support for module-info.java - improved javadoc

14	15	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
index 4b46f88..cd11b04 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
@@ -79,8 +79,9 @@ public abstract class CodeFormatter {
 	/**
 	 * Kind used to format a compilation unit
 	 * <p>
-	 * Note that using this constant, the comments are only indented while
-	 * formatting the compilation unit.
+	 * <u>Note:</u> <b>since 3.13 BETA_JAVA9</b>, if the formatted compilation unit is a
+	 * module declaration (i.e. it's named module-info.java), the
+	 * {@link #K_MODULE_INFO} kind must be used instead.
 	 * </p><p>
 	 * <b>Since 3.4</b>, if the corresponding comment option is set to
 	 * <code>true</code> then it is also possible to format the comments on the fly
@@ -130,7 +131,7 @@ public abstract class CodeFormatter {
 	 * 		<li>{@link #K_CLASS_BODY_DECLARATIONS} <i>(since 3.6)</i></li>
 	 * 		<li>{@link #K_EXPRESSION} <i>(since 3.6)</i></li>
 	 * 		<li>{@link #K_STATEMENTS} <i>(since 3.6)</i></li>
-	 * 		<li>{@link #K_MODULE_INFO}</li>
+	 * 		<li>{@link #K_MODULE_INFO} <i>(since 3.13 BETA_JAVA9</i></li>
 	 * </ul>
 	 * </p><p>
 	 * Note also that it has an effect only when one or several format comments
@@ -214,17 +215,16 @@ public abstract class CodeFormatter {
 	 * 	<li>{@link #K_STATEMENTS}</li>
 	 * 	<li>{@link #K_CLASS_BODY_DECLARATIONS}</li>
 	 * 	<li>{@link #K_COMPILATION_UNIT}</li>
-	 * 	<li>{@link #K_MODULE_INFO}<br>
-	 * 		<b>Since 3.4</b>, the comments can be formatted on the fly while
-	 * 		using this kind of code snippet<br>
-	 * 		(see {@link #F_INCLUDE_COMMENTS} for more detailed explanation on
-	 * 		this flag)
-	 * 	</li>
+	 * 	<li>{@link #K_MODULE_INFO}</li>
 	 * 	<li>{@link #K_UNKNOWN}</li>
 	 * 	<li>{@link #K_SINGLE_LINE_COMMENT}</li>
 	 * 	<li>{@link #K_MULTI_LINE_COMMENT}</li>
 	 * 	<li>{@link #K_JAVA_DOC}</li>
 	 * </ul>
+	 * <b>Since 3.4</b> for {@link #K_MODULE_INFO} and <b>since 3.6</b> for other
+	 * kinds unrelated to comments, the {@link #F_INCLUDE_COMMENTS} flag can be
+	 * used to format comments on the fly (see the flag documentation for more
+	 * detailed explanation).
 	 * @param source the source to format
 	 * @param offset the given offset to start recording the edits (inclusive).
 	 * @param length the given length to stop recording the edits (exclusive).
@@ -258,17 +258,16 @@ public abstract class CodeFormatter {
 	 * 	<li>{@link #K_STATEMENTS}</li>
 	 * 	<li>{@link #K_CLASS_BODY_DECLARATIONS}</li>
 	 * 	<li>{@link #K_COMPILATION_UNIT}</li>
-	 * 	<li>{@link #K_MODULE_INFO}<br>
-	 * 		<b>Since 3.4</b>, the comments can be formatted on the fly while
-	 * 		using this kind of code snippet<br>
-	 * 		(see {@link #F_INCLUDE_COMMENTS} for more detailed explanation on
-	 * 		this flag)
-	 * 	</li>
+	 * 	<li>{@link #K_MODULE_INFO}</li>
 	 * 	<li>{@link #K_UNKNOWN}</li>
 	 * 	<li>{@link #K_SINGLE_LINE_COMMENT}</li>
 	 * 	<li>{@link #K_MULTI_LINE_COMMENT}</li>
 	 * 	<li>{@link #K_JAVA_DOC}</li>
 	 * </ul>
+	 * <b>Since 3.4</b> for {@link #K_MODULE_INFO} and <b>since 3.6</b> for other
+	 * kinds unrelated to comments, the {@link #F_INCLUDE_COMMENTS} flag can be
+	 * used to format comments on the fly (see the flag documentation for more
+	 * detailed explanation).
 	 * @param source the source to format
 	 * @param regions a set of regions in source to format
 	 * @param indentationLevel the initial indentation level, used
commit 6d88b8b3b3489dcbd48fd8b5528ae20c4ee31f39
Author: Mateusz Matela <mateusz.matela@gmail.com>
Date:   Sat Aug 12 18:30:50 2017 +0200

    Bug 506430 - [1.9] Formatter support for module-info.java - improved javadoc, removed unused warning filter

0	8	org.eclipse.jdt.core/.settings/.api_filters
10	4	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
diff --git a/org.eclipse.jdt.core/.settings/.api_filters b/org.eclipse.jdt.core/.settings/.api_filters
index 8f783d5..8f497b8 100644
--- a/org.eclipse.jdt.core/.settings/.api_filters
+++ b/org.eclipse.jdt.core/.settings/.api_filters
@@ -39,12 +39,4 @@
             </message_arguments>
         </filter>
     </resource>
-    <resource path="formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java" type="org.eclipse.jdt.core.formatter.CodeFormatter">
-        <filter comment="safe in practice" id="336658481">
-            <message_arguments>
-                <message_argument value="org.eclipse.jdt.core.formatter.CodeFormatter"/>
-                <message_argument value="K_MODULE_INFO"/>
-            </message_arguments>
-        </filter>
-    </resource>
 </component>
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
index cd11b04..b7f5446 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatter.java
@@ -37,6 +37,8 @@ public abstract class CodeFormatter {
 	/**
 	 * Kind used to format an expression
 	 * <p>
+	 * This kind is not applicable to module descriptions.
+	 * </p><p>
 	 * Note that using this constant, the comments encountered while formatting
 	 * the expression may be shifted to match the correct indentation but are not
 	 * formatted.
@@ -51,6 +53,8 @@ public abstract class CodeFormatter {
 	/**
 	 * Kind used to format a set of statements
 	 * <p>
+	 * This kind is not applicable to module descriptions.
+	 * </p><p>
 	 * Note that using this constant, the comments encountered while formatting
 	 * the statements may be shifted to match the correct indentation but are not
 	 * formatted.
@@ -65,6 +69,8 @@ public abstract class CodeFormatter {
 	/**
 	 * Kind used to format a set of class body declarations
 	 * <p>
+	 * This kind is not applicable to module descriptions.
+	 * </p><p>
 	 * Note that using this constant, the comments encountered while formatting
 	 * the body declarations may be shifted to match the correct indentation but
 	 * are not formatted.
@@ -80,7 +86,7 @@ public abstract class CodeFormatter {
 	 * Kind used to format a compilation unit
 	 * <p>
 	 * <u>Note:</u> <b>since 3.13 BETA_JAVA9</b>, if the formatted compilation unit is a
-	 * module declaration (i.e. it's named module-info.java), the
+	 * module description (i.e. it's named module-info.java), the
 	 * {@link #K_MODULE_INFO} kind must be used instead.
 	 * </p><p>
 	 * <b>Since 3.4</b>, if the corresponding comment option is set to
@@ -131,7 +137,7 @@ public abstract class CodeFormatter {
 	 * 		<li>{@link #K_CLASS_BODY_DECLARATIONS} <i>(since 3.6)</i></li>
 	 * 		<li>{@link #K_EXPRESSION} <i>(since 3.6)</i></li>
 	 * 		<li>{@link #K_STATEMENTS} <i>(since 3.6)</i></li>
-	 * 		<li>{@link #K_MODULE_INFO} <i>(since 3.13 BETA_JAVA9</i></li>
+	 * 		<li>{@link #K_MODULE_INFO} <i>(since 3.13 BETA_JAVA9)</i></li>
 	 * </ul>
 	 * </p><p>
 	 * Note also that it has an effect only when one or several format comments
@@ -221,7 +227,7 @@ public abstract class CodeFormatter {
 	 * 	<li>{@link #K_MULTI_LINE_COMMENT}</li>
 	 * 	<li>{@link #K_JAVA_DOC}</li>
 	 * </ul>
-	 * <b>Since 3.4</b> for {@link #K_MODULE_INFO} and <b>since 3.6</b> for other
+	 * <b>Since 3.4</b> for {@link #K_COMPILATION_UNIT} and <b>since 3.6</b> for other
 	 * kinds unrelated to comments, the {@link #F_INCLUDE_COMMENTS} flag can be
 	 * used to format comments on the fly (see the flag documentation for more
 	 * detailed explanation).
@@ -264,7 +270,7 @@ public abstract class CodeFormatter {
 	 * 	<li>{@link #K_MULTI_LINE_COMMENT}</li>
 	 * 	<li>{@link #K_JAVA_DOC}</li>
 	 * </ul>
-	 * <b>Since 3.4</b> for {@link #K_MODULE_INFO} and <b>since 3.6</b> for other
+	 * <b>Since 3.4</b> for {@link #K_COMPILATION_UNIT} and <b>since 3.6</b> for other
 	 * kinds unrelated to comments, the {@link #F_INCLUDE_COMMENTS} flag can be
 	 * used to format comments on the fly (see the flag documentation for more
 	 * detailed explanation).
commit a12a8b06ed46f08c4f2334d2bb7677bd8e3f0433
Author: Mateusz Matela <mateusz.matela@gmail.com>
Date:   Sun Aug 13 22:04:14 2017 +0200

    Bug 506430 - [1.9] Formatter support for module-info.java - potentially relevant formatter invocations

3	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFormatter.java
4	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatterApplication.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFormatter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFormatter.java
index 302aa0a..5b2c515 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFormatter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFormatter.java
@@ -298,6 +298,9 @@ public final class ASTRewriteFormatter {
 				case ASTNode.COMPILATION_UNIT:
 					code= CodeFormatter.K_COMPILATION_UNIT;
 					break;
+				case ASTNode.MODULE_DECLARATION:
+					code= CodeFormatter.K_MODULE_INFO;
+					break;
 				case ASTNode.VARIABLE_DECLARATION_EXPRESSION:
 					suffix= ";"; //$NON-NLS-1$
 					code= CodeFormatter.K_STATEMENTS;
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatterApplication.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatterApplication.java
index d9527fc..863e4b1 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatterApplication.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/CodeFormatterApplication.java
@@ -27,6 +27,7 @@ import java.util.Properties;
 import org.eclipse.equinox.app.IApplication;
 import org.eclipse.equinox.app.IApplicationContext;
 import org.eclipse.jdt.core.ToolFactory;
+import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.core.util.Util;
 import org.eclipse.jface.text.BadLocationException;
 import org.eclipse.jface.text.Document;
@@ -221,7 +222,9 @@ public class CodeFormatterApplication implements IApplication {
 			String contents = new String(org.eclipse.jdt.internal.compiler.util.Util.getFileCharContent(file, null));
 			// format the file (the meat and potatoes)
 			doc.set(contents);
-			TextEdit edit = codeFormatter.format(CodeFormatter.K_COMPILATION_UNIT | CodeFormatter.F_INCLUDE_COMMENTS, contents, 0, contents.length(), 0, null);
+			int kind = (file.getName().equals(IModule.MODULE_INFO_JAVA)? CodeFormatter.K_MODULE_INFO
+					: CodeFormatter.K_COMPILATION_UNIT) | CodeFormatter.F_INCLUDE_COMMENTS;
+			TextEdit edit = codeFormatter.format(kind, contents, 0, contents.length(), 0, null);
 			if (edit != null) {
 				edit.apply(doc);
 			} else {
