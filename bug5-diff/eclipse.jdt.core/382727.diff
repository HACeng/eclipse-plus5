commit 4b84620f8d71e6de7e42a2050aa5360e2143f846
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Tue Feb 12 16:53:13 2013 -0500

    Fix for Bug 382727 - [1.8][compiler] Lambda expression parameters and
    locals cannot shadow variables from context

7	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AssignmentTest.java
4	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
554	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
7	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
5	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
19	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
18	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AssignmentTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AssignmentTest.java
index fa1fba2..eda35e6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AssignmentTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AssignmentTest.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2012 IBM Corporation and others.
+ * Copyright (c) 2005, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
@@ -902,7 +906,7 @@ public void test038() {
 		"1. WARNING in X.java (at line 19)\n" +
 		"	public void valueChanged(TreeSelectionEvent e) {\n" +
 		"	                                            ^\n" +
-		"The parameter e is hiding another local variable defined in an enclosing type scope\n" +
+		"The parameter e is hiding another local variable defined in an enclosing scope\n" +
 		"----------\n" +
 		"2. ERROR in X.java (at line 23)\n" +
 		"	static {\n" +
@@ -917,7 +921,7 @@ public void test038() {
 		"4. WARNING in X.java (at line 26)\n" +
 		"	public void actionPerformed(ActionEvent e) {\n" +
 		"	                                        ^\n" +
-		"The parameter e is hiding another local variable defined in an enclosing type scope\n" +
+		"The parameter e is hiding another local variable defined in an enclosing scope\n" +
 		"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=111898
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index c6f6cea..325202b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -719,6 +719,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("JavadocUsingDeprecatedMethod", new ProblemAttributes(CategorizedProblem.CAT_JAVADOC));
 		expectedProblemAttributes.put("JavadocUsingDeprecatedType", new ProblemAttributes(CategorizedProblem.CAT_JAVADOC));
 		expectedProblemAttributes.put("LambdaExpressionNotBelow18", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
+		expectedProblemAttributes.put("LambdaRedeclaresArgument", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
+		expectedProblemAttributes.put("LambdaRedeclaresLocal", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("LocalVariableCanOnlyBeNull", DEPRECATED);
 		expectedProblemAttributes.put("LocalVariableCannotBeNull", DEPRECATED);
 		expectedProblemAttributes.put("LocalVariableHidingField", new ProblemAttributes(CategorizedProblem.CAT_NAME_SHADOWING_CONFLICT));
@@ -1475,6 +1477,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("JavadocUsingDeprecatedMethod", new ProblemAttributes(JavaCore.COMPILER_PB_INVALID_JAVADOC));
 		expectedProblemAttributes.put("JavadocUsingDeprecatedType", new ProblemAttributes(JavaCore.COMPILER_PB_INVALID_JAVADOC));
 		expectedProblemAttributes.put("LambdaExpressionNotBelow18", SKIP);
+		expectedProblemAttributes.put("LambdaRedeclaresArgument", SKIP);
+		expectedProblemAttributes.put("LambdaRedeclaresLocal", SKIP);
 		expectedProblemAttributes.put("LocalVariableCanOnlyBeNull", SKIP);
 		expectedProblemAttributes.put("LocalVariableCannotBeNull", SKIP);
 		expectedProblemAttributes.put("LocalVariableHidingField", new ProblemAttributes(JavaCore.COMPILER_PB_LOCAL_VARIABLE_HIDING));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
index c517a1a..bd861b5 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
@@ -6725,7 +6725,7 @@ public class GenericTypeTest extends AbstractComparableTest {
 			"2. WARNING in X.java (at line 13)\n" +
 			"	} catch (T t) {\n" +
 			"	           ^\n" +
-			"The parameter t is hiding another local variable defined in an enclosing type scope\n" +
+			"The parameter t is hiding another local variable defined in an enclosing scope\n" +
 			"----------\n" +
 			"3. WARNING in X.java (at line 19)\n" +
 			"	class EX extends Exception {\n" +
@@ -37146,7 +37146,7 @@ public void test1089() {
 		"2. WARNING in X.java (at line 5)\n" +
 		"	T t = t;\n" +
 		"	  ^\n" +
-		"The field T.t is hiding another local variable defined in an enclosing type scope\n" +
+		"The field T.t is hiding another local variable defined in an enclosing scope\n" +
 		"----------\n" +
 		"3. ERROR in X.java (at line 5)\n" +
 		"	T t = t;\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
index ba99972..ee5f509 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
@@ -1211,17 +1211,17 @@ public void test036() {
 			"1. ERROR in X.java (at line 7)\n" + 
 			"	I i = (x, y) -> { // Error: x,y being redeclared\n" + 
 			"	       ^\n" + 
-			"Duplicate parameter x\n" + 
+			"Lambda expression\'s parameter x cannot redeclare another local variable defined in an enclosing scope. \n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 7)\n" + 
 			"	I i = (x, y) -> { // Error: x,y being redeclared\n" + 
 			"	          ^\n" + 
-			"Duplicate parameter y\n" + 
+			"Lambda expression\'s parameter y cannot redeclare another local variable defined in an enclosing scope. \n" + 
 			"----------\n" + 
 			"3. ERROR in X.java (at line 8)\n" + 
 			"	int args = 10; //  Error args is being redeclared\n" + 
 			"	    ^^^^\n" + 
-			"Duplicate local variable args\n" + 
+			"Lambda expression\'s local variable args cannot redeclare another local variable defined in an enclosing scope. \n" + 
 			"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=382702 - [1.8][compiler] Lambda expressions should be rejected in disallowed contexts
@@ -2369,6 +2369,557 @@ public void test068() {
 				"Variable x is required to be final or effectively final\n" + 
 				"----------\n");
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test069() {
+	// Lambda argument hides a field.
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"	int f1;\n" +
+					"	int f2;\n" +
+					"\n" +
+					"	void foo() {\n" +
+					"		I i = (int f1)  -> {\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. WARNING in X.java (at line 9)\n" + 
+				"	I i = (int f1)  -> {\n" + 
+				"	           ^^\n" + 
+				"The parameter f1 is hiding a field from type X\n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test070() {
+	// Lambda argument redeclares outer method argument.
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"	void foo(int x) {\n" +
+					"		I i = (int x)  -> {\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 6)\n" + 
+				"	I i = (int x)  -> {\n" + 
+				"	           ^\n" + 
+				"Lambda expression\'s parameter x cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test071() {
+	// Lambda argument redeclares outer method local.
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"	void foo(int x) {\n" +
+					"       int l;\n" +
+					"		I i = (int l)  -> {\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 7)\n" + 
+				"	I i = (int l)  -> {\n" + 
+				"	           ^\n" + 
+				"Lambda expression\'s parameter l cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test072() {
+	// Lambda redeclares its own argument
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"	void foo(int x) {\n" +
+					"       int l;\n" +
+					"		I i = (int p, int p)  -> {\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 7)\n" + 
+				"	I i = (int p, int p)  -> {\n" + 
+				"	                  ^\n" + 
+				"Duplicate parameter p\n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test073() {
+	// Lambda local hides a field
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo() {\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"           int f;\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. WARNING in X.java (at line 8)\n" + 
+				"	int f;\n" + 
+				"	    ^\n" + 
+				"The local variable f is hiding a field from type X\n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test074() {
+	// Lambda local redelares the enclosing method's argument
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int a) {\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"           int a;\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 8)\n" + 
+				"	int a;\n" + 
+				"	    ^\n" + 
+				"Lambda expression\'s local variable a cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test075() {
+	// Lambda local redelares the enclosing method's local
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int a) {\n" +
+					"       int loc;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"           int loc;\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 9)\n" + 
+				"	int loc;\n" + 
+				"	    ^^^\n" + 
+				"Lambda expression\'s local variable loc cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test076() {
+	// Lambda local redelares its own parameter
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int a) {\n" +
+					"       int loc;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"           int p;\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 9)\n" + 
+				"	int p;\n" + 
+				"	    ^\n" + 
+				"Duplicate local variable p\n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test077() {
+	// Lambda local redelares its own self
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int a) {\n" +
+					"       int loc;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"           int self, self;\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 9)\n" + 
+				"	int self, self;\n" + 
+				"	          ^^^^\n" + 
+				"Duplicate local variable self\n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test078() {
+	// Nested Lambda argument redeclares a field.
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int a) {\n" +
+					"       int loc;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"           I i2 = (int f, int p0) -> {};\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. WARNING in X.java (at line 9)\n" + 
+				"	I i2 = (int f, int p0) -> {};\n" + 
+				"	            ^\n" + 
+				"The parameter f is hiding a field from type X\n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test079() {
+	// Nested Lambda argument redeclares outer method's argument.
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int outerp) {\n" +
+					"       int loc;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"           I i2 = (int f, int outerp) -> {};\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. WARNING in X.java (at line 9)\n" + 
+				"	I i2 = (int f, int outerp) -> {};\n" + 
+				"	            ^\n" + 
+				"The parameter f is hiding a field from type X\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 9)\n" + 
+				"	I i2 = (int f, int outerp) -> {};\n" + 
+				"	                   ^^^^^^\n" + 
+				"Lambda expression\'s parameter outerp cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test080() {
+	// Nested Lambda argument redeclares outer method's local.
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int outerp) {\n" +
+					"       int locouter;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"           I i2 = (int locouter, int outerp) -> {};\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 9)\n" + 
+				"	I i2 = (int locouter, int outerp) -> {};\n" + 
+				"	            ^^^^^^^^\n" + 
+				"Lambda expression\'s parameter locouter cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 9)\n" + 
+				"	I i2 = (int locouter, int outerp) -> {};\n" + 
+				"	                          ^^^^^^\n" + 
+				"Lambda expression\'s parameter outerp cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test081() {
+	// Nested Lambda argument redeclares outer lambda's argument.
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int outerp) {\n" +
+					"       int locouter;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"           I i2 = (int p, int q) -> {};\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 9)\n" + 
+				"	I i2 = (int p, int q) -> {};\n" + 
+				"	            ^\n" + 
+				"Lambda expression\'s parameter p cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 9)\n" + 
+				"	I i2 = (int p, int q) -> {};\n" + 
+				"	                   ^\n" + 
+				"Lambda expression\'s parameter q cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test082() {
+	// Nested Lambda argument redeclares outer lambda's local.
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int outerp) {\n" +
+					"       int locouter;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"       int lamlocal;\n" +
+					"           I i2 = (int lamlocal, int q) -> {};\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int lamlocal, int q) -> {};\n" + 
+				"	            ^^^^^^^^\n" + 
+				"Lambda expression\'s parameter lamlocal cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int lamlocal, int q) -> {};\n" + 
+				"	                          ^\n" + 
+				"Lambda expression\'s parameter q cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test083() {
+	// Nested Lambda local redeclares a field.
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int outerp) {\n" +
+					"       int locouter;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"       int lamlocal;\n" +
+					"           I i2 = (int lamlocal, int q) -> {int f;};\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int lamlocal, int q) -> {int f;};\n" + 
+				"	            ^^^^^^^^\n" + 
+				"Lambda expression\'s parameter lamlocal cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int lamlocal, int q) -> {int f;};\n" + 
+				"	                          ^\n" + 
+				"Lambda expression\'s parameter q cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n" + 
+				"3. WARNING in X.java (at line 10)\n" + 
+				"	I i2 = (int lamlocal, int q) -> {int f;};\n" + 
+				"	                                     ^\n" + 
+				"The local variable f is hiding a field from type X\n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test084() {
+	// Nested Lambda local redeclares outer methods local.
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int outerp) {\n" +
+					"       int locouter;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"       int lamlocal;\n" +
+					"           I i2 = (int lamlocal, int q) -> {int locouter;};\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int lamlocal, int q) -> {int locouter;};\n" + 
+				"	            ^^^^^^^^\n" + 
+				"Lambda expression\'s parameter lamlocal cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int lamlocal, int q) -> {int locouter;};\n" + 
+				"	                          ^\n" + 
+				"Lambda expression\'s parameter q cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int lamlocal, int q) -> {int locouter;};\n" + 
+				"	                                     ^^^^^^^^\n" + 
+				"Lambda expression\'s local variable locouter cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test085() {
+	// Nested Lambda local redeclares outer lambda's argument & local
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int outerp) {\n" +
+					"       int locouter;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"       int lamlocal;\n" +
+					"           I i2 = (int j, int q) -> {int p, lamlocal;};\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int j, int q) -> {int p, lamlocal;};\n" + 
+				"	                   ^\n" + 
+				"Lambda expression\'s parameter q cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int j, int q) -> {int p, lamlocal;};\n" + 
+				"	                              ^\n" + 
+				"Lambda expression\'s local variable p cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int j, int q) -> {int p, lamlocal;};\n" + 
+				"	                                 ^^^^^^^^\n" + 
+				"Lambda expression\'s local variable lamlocal cannot redeclare another local variable defined in an enclosing scope. \n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test086() {
+	// Nested Lambda local redeclares its own argument & local
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int outerp) {\n" +
+					"       int locouter;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"       int lamlocal;\n" +
+					"           I i2 = (int x1, int x2) -> {int x1, x2;};\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int x1, int x2) -> {int x1, x2;};\n" + 
+				"	                                ^^\n" + 
+				"Duplicate local variable x1\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 10)\n" + 
+				"	I i2 = (int x1, int x2) -> {int x1, x2;};\n" + 
+				"	                                    ^^\n" + 
+				"Duplicate local variable x2\n" + 
+				"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=382727, [1.8][compiler] Lambda expression parameters and locals cannot shadow variables from context
+public void test087() {
+	// Inner class (!) inside Lambda hides field
+	this.runNegativeTest(
+			new String[] {
+					"X.java",
+					"interface I {\n" +
+					"	void foo(int p, int q);\n" +
+					"}\n" +
+					"public class X {\n" +
+					"   int f;\n" +
+					"	void foo(int outerp) {\n" +
+					"       int locouter;\n" +
+					"		I i = (int p, int q)  -> {\n" +
+					"       int lamlocal;\n" +
+					"           class X { void foo(int f) {} }\n" +
+					"		};\n" +
+					"	}	\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 10)\n" + 
+				"	class X { void foo(int f) {} }\n" + 
+				"	      ^\n" + 
+				"The nested type X cannot hide an enclosing type\n" + 
+				"----------\n" + 
+				"2. WARNING in X.java (at line 10)\n" + 
+				"	class X { void foo(int f) {} }\n" + 
+				"	                       ^\n" + 
+				"The parameter f is hiding a field from type X\n" + 
+				"----------\n");
+}
 public static Class testClass() {
 	return NegativeLambdaExpressionsTest.class;
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
index 3300eba..eeaef15 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TryWithResourcesStatementTest.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2012 IBM Corporation and others.
+ * Copyright (c) 2011, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contributions for
@@ -438,12 +442,12 @@ public void test013() {
 		"1. WARNING in X.java (at line 5)\n" + 
 		"	public void foo(int p) {\n" + 
 		"	                    ^\n" + 
-		"The parameter p is hiding another local variable defined in an enclosing type scope\n" + 
+		"The parameter p is hiding another local variable defined in an enclosing scope\n" + 
 		"----------\n" + 
 		"2. WARNING in X.java (at line 8)\n" + 
 		"	} catch (Exception y) {\n" + 
 		"	                   ^\n" + 
-		"The parameter y is hiding another local variable defined in an enclosing type scope\n" + 
+		"The parameter y is hiding another local variable defined in an enclosing scope\n" + 
 		"----------\n" + 
 		"3. ERROR in X.java (at line 13)\n" + 
 		"	System.out.println(y);\n" + 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index fcf7d73..8d2f3b1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -431,6 +431,10 @@ void setSourceStart(int sourceStart);
 	int ArgumentHidingField = Internal + 95;
 	/** @since 3.1 */
 	int MissingSerialVersion = Internal + 96;
+	/** @since 3.9 */
+	int LambdaRedeclaresArgument = Internal + 97;
+	/** @since 3.9 */
+	int LambdaRedeclaresLocal = Internal + 98;
 
 	// methods
 	int UndefinedMethod = MethodRelated + 100;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index ab32c40..cb2f555 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -57,7 +57,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	public final static int Bit19 = 0x40000;			// didResolve (parameterized qualified type ref/parameterized single type ref)  | empty (javadoc return statement) | needReceiverGenericCast (msg/fieldref)
 	public final static int Bit20 = 0x80000;			// contains syntax errors (method declaration, type declaration, field declarations, initializer), typeref: <> name ref: lambda capture)
 	public final static int Bit21 = 0x100000;
-	public final static int Bit22 = 0x200000;			// parenthesis count (expression) | used (import reference)
+	public final static int Bit22 = 0x200000;			// parenthesis count (expression) | used (import reference) shadows outer local (local declarations)
 	public final static int Bit23 = 0x400000;			// parenthesis count (expression)
 	public final static int Bit24 = 0x800000;			// parenthesis count (expression)
 	public final static int Bit25 = 0x1000000;		// parenthesis count (expression)
@@ -127,6 +127,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	public static final int IsArgument = Bit3;
 	public static final int IsLocalDeclarationReachable = Bit31;
 	public static final int IsForeachElementVariable = Bit5;
+	public static final int ShadowsOuterLocal = Bit22;
 
 	// for name refs or local decls
 	public static final int FirstAssignmentToLocal = Bit4;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
index 61eabf0..5e08fc1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
@@ -75,7 +75,10 @@ public class Argument extends LocalDeclaration {
 		// record the resolved type into the type reference
 		Binding existingVariable = scope.getBinding(this.name, Binding.VARIABLE, this, false /*do not resolve hidden field*/);
 		if (existingVariable != null && existingVariable.isValidBinding()){
-			if (existingVariable instanceof LocalVariableBinding && this.hiddenVariableDepth == 0) {
+			final boolean localExists = existingVariable instanceof LocalVariableBinding;
+			if (localExists && (this.bits & ASTNode.ShadowsOuterLocal) != 0 && scope.isLambdaSubscope()) {
+				scope.problemReporter().lambdaRedeclaresArgument(this);
+			} else if (localExists && this.hiddenVariableDepth == 0) {
 				scope.problemReporter().redefineArgument(this);
 			} else {
 				boolean isSpecialArgument = false;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index 3e873ad..f2d9e92 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -236,8 +236,11 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 
 		Binding existingVariable = scope.getBinding(this.name, Binding.VARIABLE, this, false /*do not resolve hidden field*/);
 		if (existingVariable != null && existingVariable.isValidBinding()){
-			if (existingVariable instanceof LocalVariableBinding && this.hiddenVariableDepth == 0) {
-				scope.problemReporter().redefineLocal(this);
+			boolean localExists = existingVariable instanceof LocalVariableBinding; 
+			if (localExists && (this.bits & ASTNode.ShadowsOuterLocal) != 0 && scope.isLambdaSubscope()) {
+					scope.problemReporter().lambdaRedeclaresLocal(this);
+			} else if (localExists && this.hiddenVariableDepth == 0) {
+					scope.problemReporter().redefineLocal(this);
 			} else {
 				scope.problemReporter().localVariableHiding(this, existingVariable, false);
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
index ced2952..20dd8c1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
@@ -459,6 +459,8 @@ public class ClassScope extends Scope {
 				switch (scope.kind) {
 					case METHOD_SCOPE :
 						MethodScope methodScope = (MethodScope) scope;
+						if (methodScope.isLambdaScope()) 
+							methodScope = methodScope.namedMethodScope();
 						if (methodScope.isInsideInitializer()) {
 							SourceTypeBinding type = ((TypeDeclaration) methodScope.referenceContext).binding;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 695526c..c20eab2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -1735,7 +1735,7 @@ public abstract class Scope {
 				Scope scope = this;
 				int depth = 0;
 				int foundDepth = 0;
-				boolean shouldCaptureOuterLocals = false;
+				boolean shouldTrackOuterLocals = false;
 				ReferenceBinding foundActualReceiverType = null;
 				done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
 					switch (scope.kind) {
@@ -1758,9 +1758,14 @@ public abstract class Scope {
 										ProblemReasons.InheritedNameHidesEnclosingName);
 								if (depth > 0)
 									invocationSite.setDepth(depth);
-								if (shouldCaptureOuterLocals && invocationSite instanceof NameReference) {
+								if (shouldTrackOuterLocals) {
+									if (invocationSite instanceof NameReference) {
 										NameReference nameReference = (NameReference) invocationSite;
 										nameReference.bits |= ASTNode.IsCapturedOuterLocal;
+									} else if (invocationSite instanceof AbstractVariableDeclaration) {
+										AbstractVariableDeclaration variableDeclaration = (AbstractVariableDeclaration) invocationSite;
+										variableDeclaration.bits |= ASTNode.ShadowsOuterLocal;
+									}
 								}
 								return variableBinding;
 							}
@@ -1841,7 +1846,7 @@ public abstract class Scope {
 							}
 							insideTypeAnnotation = false;
 							depth++;
-							shouldCaptureOuterLocals = true;
+							shouldTrackOuterLocals = true;
 							insideStaticContext |= receiverType.isStatic();
 							// 1EX5I8Z - accessing outer fields within a constructor call is permitted
 							// in order to do so, we change the flag as we exit from the type, not the method
@@ -1853,7 +1858,7 @@ public abstract class Scope {
 							break done;
 					}
 					if (scope.isLambdaScope()) // Not in Kansas anymore ...
-						shouldCaptureOuterLocals = true;
+						shouldTrackOuterLocals = true;
 					scope = scope.parent;
 				}
 
@@ -3540,6 +3545,16 @@ public abstract class Scope {
 		} while (scope != null);
 		return null;
 	}
+	
+	public final MethodScope namedMethodScope() {
+		Scope scope = this;
+		do {
+			if (scope instanceof MethodScope && !scope.isLambdaScope())
+				return (MethodScope) scope;
+			scope = scope.parent;
+		} while (scope != null);
+		return null;
+	}
 
 	/**
 	 * Returns the most specific set of types compatible with all given types.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 97875c7..01242ca 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -9089,4 +9089,22 @@ public void multipleFunctionalInterfaces(FunctionalExpression functionalExpressi
 			functionalExpression.sourceStart,
 			functionalExpression.sourceEnd);
 }
+public void lambdaRedeclaresArgument(Argument argument) {
+	String[] arguments = new String[] {new String(argument.name)};
+	this.handle(
+		IProblem.LambdaRedeclaresArgument,
+		arguments,
+		arguments,
+		argument.sourceStart,
+		argument.sourceEnd);
+}
+public void lambdaRedeclaresLocal(LocalDeclaration local) {
+	String[] arguments = new String[] {new String(local.name)};
+	this.handle(
+		IProblem.LambdaRedeclaresLocal,
+		arguments,
+		arguments,
+		local.sourceStart,
+		local.sourceEnd);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 4b641a1..9dcc6a4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -95,13 +95,15 @@
 82 = The final field {0} may already have been assigned
 83 = {0} cannot be resolved to a variable
 
-90 = The local variable {0} is hiding another local variable defined in an enclosing type scope
+90 = The local variable {0} is hiding another local variable defined in an enclosing scope
 91 = The local variable {0} is hiding a field from type {1}
-92 = The field {0}.{1} is hiding another local variable defined in an enclosing type scope
+92 = The field {0}.{1} is hiding another local variable defined in an enclosing scope
 93 = The field {0}.{1} is hiding a field from type {2}
-94 = The parameter {0} is hiding another local variable defined in an enclosing type scope
+94 = The parameter {0} is hiding another local variable defined in an enclosing scope
 95 = The parameter {0} is hiding a field from type {1}
 96 = The serializable class {0} does not declare a static final serialVersionUID field of type long
+97 = Lambda expression's parameter {0} cannot redeclare another local variable defined in an enclosing scope. 
+98 = Lambda expression's local variable {0} cannot redeclare another local variable defined in an enclosing scope. 
 
 100 = The method {1}({2}) is undefined for the type {0}
 101 = The method {1}({2}) from the type {0} is not visible
