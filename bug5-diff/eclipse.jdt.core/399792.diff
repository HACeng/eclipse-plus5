commit a2a0577109951f3af96b6ee7e6f23d457b52d52d
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Wed Apr 17 13:48:19 2013 +0530

    Fix for bug 399792 - [1.8][dom ast] AST APIs should support casts with
    intersection types.

108	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
11	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
13	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
31	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
23	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
9	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
30	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
173	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IntersectionType.java
16	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
2	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
15	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
8	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
index f768ae3..9c1cca8 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
@@ -1935,4 +1935,112 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		method = (MethodDeclaration) type.bodyDeclarations().get(3);
 		assertEquals("Method should be malformed", ASTNode.MALFORMED, (method.getFlags() & ASTNode.MALFORMED));
 	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399792
+	public void testBug399792() throws JavaModelException {
+		String content =
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.io.Serializable;\n" +
+				"public class X {\n" +
+				"      Object o = (@Marker1 @Marker2 Serializable & I & @Marker3 @Marker1 J) () -> {};" +
+				"      public Serializable main(Object o) {\n" +
+				"    	  Serializable oo = (Serializable & @Marker3 @Marker1 @Marker2 I & J) o;\n" +
+				"    	  return oo;\n" +
+				"      }\n" +
+				"}\n" +
+				"interface I {\n" +
+				"  public void foo();\n" +
+				"}\n" +
+				"interface J {\n" +
+				"  public void foo();\n" +
+				"  public void bar();\n" +
+				"}\n" +
+				"interface K {\n" +
+				"  public void foo();\n" +
+				"  public void bar();\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n" +
+				"@java.lang.annotation.Target (ElementType.TYPE_USE)\n" +
+				"@interface Marker3 {}";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", false);
+		ASTNode node = buildAST(content, this.workingCopy, false);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit unit = (CompilationUnit) node;
+		TypeDeclaration type =  (TypeDeclaration) unit.types().get(0);
+		node = (ASTNode) type.bodyDeclarations().get(0);
+		assertEquals("Not a field Declaration", ASTNode.FIELD_DECLARATION, node.getNodeType());
+		FieldDeclaration field = (FieldDeclaration) node;
+		assertEquals("Field should not be malformed", 0, (field.getFlags() & ASTNode.MALFORMED));
+
+		List fragments = field.fragments();
+		assertEquals("Incorrect no of fragments", 1, fragments.size());
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);
+		CastExpression cast = (CastExpression) fragment.getInitializer();
+		Type castType = cast.getType();
+		assertEquals("Not an intersection cast type", ASTNode.INTERSECTION_TYPE, castType.getNodeType());
+		assertTrue("Not an intersection cast type", castType.isIntersectionType());
+		assertEquals("Type should not be malformed", 0, (castType.getFlags() & ASTNode.MALFORMED));
+
+		List intersectionTypes = ((IntersectionType) castType).types();
+		assertEquals("Incorrect no of types", 3, intersectionTypes.size());
+		castType = (Type) intersectionTypes.get(0);
+		assertEquals("Incorrect type", ASTNode.SIMPLE_TYPE, castType.getNodeType());
+		SimpleName name = (SimpleName) ((SimpleType) castType).getName();
+		assertEquals("Incorrect name", "Serializable", name.getIdentifier());
+
+		List annotations = ((SimpleType) castType).annotations();
+		assertEquals("Incorrect no of annotations", 2, annotations.size());
+		assertEquals("Incorrect receiver", "@Marker1 @Marker2 Serializable", castType.toString());
+
+		castType = (Type) intersectionTypes.get(1);
+		assertEquals("Incorrect type", ASTNode.SIMPLE_TYPE, castType.getNodeType());
+		name = (SimpleName) ((SimpleType) castType).getName();
+		assertEquals("Incorrect name", "I", name.getIdentifier());
+
+		annotations = ((SimpleType) castType).annotations();
+		assertEquals("Incorrect no of annotations", 0, annotations.size());
+		assertEquals("Incorrect receiver", "I", castType.toString());
+
+		castType = (Type) intersectionTypes.get(2);
+		assertEquals("Incorrect type", ASTNode.SIMPLE_TYPE, castType.getNodeType());
+		name = (SimpleName) ((SimpleType) castType).getName();
+		assertEquals("Incorrect name", "J", name.getIdentifier());
+
+		annotations = ((SimpleType) castType).annotations();
+		assertEquals("Incorrect no of annotations", 2, annotations.size());
+		assertEquals("Incorrect receiver", "@Marker3 @Marker1 J", castType.toString());
+
+		node = (ASTNode) type.bodyDeclarations().get(1);
+		assertEquals("Not a method Declaration", ASTNode.METHOD_DECLARATION, node.getNodeType());
+		MethodDeclaration method = (MethodDeclaration) node;
+		assertEquals("Method should not be malformed", 0, (method.getFlags() & ASTNode.MALFORMED));
+		
+		List statements = method.getBody().statements();
+		VariableDeclarationStatement statement = (VariableDeclarationStatement) statements.get(0);
+		fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		cast = (CastExpression) fragment.getInitializer();
+		castType = cast.getType();
+		
+		intersectionTypes = ((IntersectionType) castType).types();
+		assertEquals("Incorrect no of types", 3, intersectionTypes.size());
+		castType = (Type) intersectionTypes.get(0);
+
+		annotations = ((SimpleType) castType).annotations();
+		assertEquals("Incorrect no of annotations", 0, annotations.size());
+		assertEquals("Incorrect receiver", "Serializable", castType.toString());
+
+		castType = (Type) intersectionTypes.get(1);
+		annotations = ((SimpleType) castType).annotations();
+		assertEquals("Incorrect no of annotations", 3, annotations.size());
+		assertEquals("Incorrect receiver", "@Marker3 @Marker1 @Marker2 I", castType.toString());
+
+		castType = (Type) intersectionTypes.get(2);
+
+		annotations = ((SimpleType) castType).annotations();
+		assertEquals("Incorrect no of annotations", 0, annotations.size());
+		assertEquals("Incorrect receiver", "J", castType.toString());
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
index eb059aa..970ef6e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTMatcherTest.java
@@ -561,6 +561,9 @@ public class ASTMatcherTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		public boolean match(LambdaExpression node, Object other) {
 			return standardBody(node, other, this.superMatch ? super.match(node, other) : false);
 		}
+		public boolean match(IntersectionType node, Object other) {
+			return standardBody(node, other, this.superMatch ? super.match(node, other) : false);
+		}
 	}
 
 	/**
@@ -1622,4 +1625,12 @@ public class ASTMatcherTest extends org.eclipse.jdt.core.tests.junit.extension.T
 		x1.setBody(this.E1);
 		basicMatch(x1);
 	}
+	public void testIntersectionType() {
+		if (this.ast.apiLevel() < AST.JLS8) {
+			return;
+		}
+		IntersectionType x1 = this.ast.newIntersectionType();
+		x1.types().add(this.ast.newSimpleType(this.N1));
+		basicMatch(x1);
+	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
index 4d88963..4e88c28 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/AST.java
@@ -2423,6 +2423,19 @@ public final class AST {
 	}
 
 	/**
+	 * Creates a new unparented intersection type node owned by this AST.
+	 * By default, the intersection type has no types.
+	 *
+	 * @return a new unparented IntersectionType node
+	 * @exception UnsupportedOperationException if this operation is used in
+	 * a JLS2, JLS3 or JLS4 AST
+	 * @since 3.9 BETA_JAVA8
+	 */
+	public IntersectionType newIntersectionType() {
+		return new IntersectionType(this);
+	}
+
+	/**
 	 * Creates a new unparented local variable declaration expression node
 	 * owned by this AST, for the given variable declaration fragment. By
 	 * default, there are no modifiers and the base type is unspecified
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index b790622..43a6c33 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -35,6 +35,7 @@ import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ForeachStatement;
+import org.eclipse.jdt.internal.compiler.ast.IntersectionCastTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.JavadocArgumentExpression;
 import org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference;
 import org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend;
@@ -50,6 +51,7 @@ import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
 import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.StringLiteralConcatenation;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.ast.UnionTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
@@ -3691,7 +3693,7 @@ class ASTConverter {
 					qualifiedType.index  = 1;
 				}
 				type = currentType;
-			} else {
+			} else if (typeReference instanceof UnionTypeReference){
 				TypeReference[] typeReferences = ((org.eclipse.jdt.internal.compiler.ast.UnionTypeReference) typeReference).typeReferences;
 				switch(this.ast.apiLevel) {
 					case AST.JLS2_INTERNAL :
@@ -3719,6 +3721,34 @@ class ASTConverter {
 						length = endPosition - start; /* + 1 - 1 == 0 */
 						type.setSourceRange(start, length);
 				}
+			} else if (typeReference instanceof IntersectionCastTypeReference) {
+				TypeReference[] typeReferences = ((IntersectionCastTypeReference) typeReference).typeReferences;
+				switch(this.ast.apiLevel) {
+					case AST.JLS2_INTERNAL :
+					case AST.JLS3_INTERNAL :
+					case AST.JLS4_INTERNAL :
+						type = this.convertType(typeReferences[0]);
+						int start = typeReference.sourceStart;
+						int endPosition = typeReference.sourceEnd;
+						length = endPosition - start + 1;
+						type.setSourceRange(start, length);
+						type.setFlags(type.getFlags() | ASTNode.MALFORMED);
+						break;
+					default:
+						// intersection type reference
+						final IntersectionType castType = new IntersectionType(this.ast);
+						for (int i = 0, max = typeReferences.length; i < max; i++) {
+							castType.types().add(this.convertType(typeReferences[i]));
+						}
+						type = castType;
+						List types = castType.types();
+						int size = types.size();
+						start = ((Type) types.get(0)).getStartPosition();
+						Type lastType = (Type) types.get(size - 1);
+						endPosition = lastType.getStartPosition() + lastType.getLength();
+						length = endPosition - start;
+						type.setSourceRange(start, length);
+				}
 			}
 
 			length = typeReference.sourceEnd - sourceStart + 1;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index eb13ec6..3bbc9a9 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -2307,6 +2307,29 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.9 BETA_JAVA8
+	 */
+	public boolean match(IntersectionType node, Object other) {
+		if (!(other instanceof IntersectionType)) {
+			return false;
+		}
+		IntersectionType o = (IntersectionType) other;
+		return safeSubtreeListMatch(node.types(), o.types());
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(VariableDeclarationExpression node, Object other) {
 		if (!(other instanceof VariableDeclarationExpression)) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index f7dc90c..1f7a946 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -851,6 +851,15 @@ public abstract class ASTNode {
 	public static final int LAMBDA_EXPRESSION = 86;
 
 	/**
+	 * Node type constant indicating a node of type
+	 * <code>IntersectionType</code>.
+	 *
+	 * @see IntersectionType
+	 * @since 3.9 BETA_JAVA8
+	 */
+	public static final int INTERSECTION_TYPE = 87;
+
+	/**
 	 * Returns the node class for the corresponding node type.
 	 *
 	 * @param nodeType AST node type
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index 442c2d2..00c80fc 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -1547,6 +1547,23 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.9 BETA_JAVA8
+	 */
+	public boolean visit(IntersectionType node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
+	 * Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
 	 */
 	public boolean visit(VariableDeclarationExpression node) {
 		return true;
@@ -2628,6 +2645,19 @@ public abstract class ASTVisitor {
 	 * </p>
 	 *
 	 * @param node the node to visit
+	 * @since 3.9 BETA_JAVA8
+	 */
+	public void endVisit(IntersectionType node) {
+		// default implementation: do nothing
+	}
+
+	/**
+	 * End of visit the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing. Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
 	 */
 	public void endVisit(VariableDeclarationExpression node) {
 		// default implementation: do nothing
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IntersectionType.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IntersectionType.java
new file mode 100644
index 0000000..df210fd
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IntersectionType.java
@@ -0,0 +1,173 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Type node for an intersection type in a cast expression (added in JLS8 API).
+ * <pre>
+ * IntersectionType:
+ *    Type <b>&</b> Type { <b>&</b> Type }
+ * </pre>
+ * <p>
+ * This kind of node is used only inside a cast expression.
+ * </p>
+ *
+ * @since 3.9 BETA_JAVA8
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+public class IntersectionType extends Type {
+
+	/**
+	 * The "types" structural property of this node type (element type: {@link Type}).
+	 */
+	public static final ChildListPropertyDescriptor TYPES_PROPERTY =
+		new ChildListPropertyDescriptor(IntersectionType.class, "types", Type.class, CYCLE_RISK); //$NON-NLS-1$
+
+	/**
+	 * A list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor}),
+	 * or null if uninitialized.
+	 */
+	private static final List PROPERTY_DESCRIPTORS_8_0;
+
+	static {
+		List propertyList = new ArrayList(2);
+		createPropertyList(IntersectionType.class, propertyList);
+		addProperty(TYPES_PROPERTY, propertyList);
+		PROPERTY_DESCRIPTORS_8_0 = reapPropertyList(propertyList);
+	}
+
+	/**
+	 * Returns a list of structural property descriptors for this node type.
+	 * Clients must not modify the result.
+	 *
+	 * @param apiLevel the API level; one of the
+	 * <code>AST.JLS*</code> constants
+	 * @return a list of property descriptors (element type:
+	 * {@link StructuralPropertyDescriptor})
+	 */
+	public static List propertyDescriptors(int apiLevel) {
+		return PROPERTY_DESCRIPTORS_8_0;
+	}
+
+	/**
+	 * The list of types (element type: {@link Type}).  Defaults to an empty list.
+	 */
+	private ASTNode.NodeList types = new ASTNode.NodeList(TYPES_PROPERTY);
+
+	/**
+	 * Creates a new unparented node for an intersection type owned by the given AST.
+	 * By default, it has no types.<p>
+	 * 
+	 * N.B. This constructor is package-private.
+	 * </p>
+	 *
+	 * @param ast the AST that is to own this node
+	 */
+	IntersectionType(AST ast) {
+		super(ast);
+		unsupportedIn2_3_4();
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final List internalStructuralPropertiesForType(int apiLevel) {
+		return propertyDescriptors(apiLevel);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final List internalGetChildListProperty(ChildListPropertyDescriptor property) {
+		if (property == TYPES_PROPERTY) {
+			return types();
+		}
+		// allow default implementation to flag the error
+		return super.internalGetChildListProperty(property);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final int getNodeType0() {
+		return INTERSECTION_TYPE;
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	ASTNode clone0(AST target) {
+		IntersectionType result = new IntersectionType(target);
+		result.setSourceRange(getStartPosition(), getLength());
+		result.types().addAll(
+				ASTNode.copySubtrees(target, types()));
+		return result;
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	final boolean subtreeMatch0(ASTMatcher matcher, Object other) {
+		// dispatch to correct overloaded match method
+		return matcher.match(this, other);
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	void accept0(ASTVisitor visitor) {
+		boolean visitChildren = visitor.visit(this);
+		if (visitChildren) {
+			// visit children in normal left to right reading order
+			acceptChildren(visitor, this.types);
+		}
+		visitor.endVisit(this);
+	}
+
+	/**
+	 * Returns the live ordered list of types in this intersection type.
+	 * Adding and removing nodes from this list affects this node
+	 * dynamically. All nodes in this list must be
+	 * <code>Type</code>s; attempts to add any other
+	 * type of node will trigger an exception.
+	 *
+	 * @return the live list of types in this intersection type (element type: {@link Type})
+	 */
+	public List types() {
+		return this.types;
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	int memSize() {
+		return BASE_NODE_SIZE + 1 * 4;
+	}
+
+	/* (omit javadoc for this method)
+	 * Method declared on ASTNode.
+	 */
+	int treeSize() {
+		return
+			memSize()
+			+ this.types.listSize();
+	}
+}
+
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
index b724115..4d7ff0b 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/Type.java
@@ -35,7 +35,8 @@ package org.eclipse.jdt.core.dom;
  *       QualifiedType
  *       WildcardType
  *    ParameterizedType
- *    UnionType  
+ *    UnionType
+ *    IntersectionType
  *    
  * {@link PrimitiveType}:
  *    { Annotation } <b>byte</b>
@@ -59,6 +60,8 @@ package org.eclipse.jdt.core.dom;
  *    Type <b>&lt;</b> Type { <b>,</b> Type } <b>&gt;</b>
  * {@link UnionType}:
  *    Type <b>|</b> Type { <b>|</b> Type }
+ * {@link IntersectionType}:
+ *    Type <b>&</b> Type { <b>&</b> Type }
  * </pre>
  * </p>
  *
@@ -164,6 +167,18 @@ public abstract class Type extends ASTNode {
 	}
 
 	/**
+	 * Returns whether this type is an intersection type
+	 * ({@link IntersectionType}).
+	 *
+	 * @return <code>true</code> if this is an intersection type, and
+	 * 		<code>false</code> otherwise
+	 * @since 3.9 BETA_JAVA8
+	 */
+	public final boolean isIntersectionType() {
+		return (this instanceof IntersectionType);
+	}
+
+	/**
 	 * Returns whether this type is a wildcard type
 	 * ({@link WildcardType}).
 	 * <p>
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
index d723536..14df83d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
@@ -666,6 +666,7 @@ class TypeBinding implements ITypeBinding {
 			case Binding.TYPE_PARAMETER : // includes capture scenario
 			case Binding.WILDCARD_TYPE :
 			case Binding.INTERSECTION_TYPE:
+			case Binding.INTERSECTION_CAST_TYPE:
 				return null;
 		}
 		ReferenceBinding referenceBinding = (ReferenceBinding) this.binding;
@@ -762,7 +763,7 @@ class TypeBinding implements ITypeBinding {
 				}
 				return String.valueOf(buffer);
 			default :
-				if (isAnonymous() || this.binding.isLocalType()) {
+				if (isAnonymous() || this.binding.isLocalType() || this.binding.isIntersectionCastType()) {
 					return NO_NAME;
 				}
 				if (isPrimitive() || isNullType()) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index 8058a4a..7f4b3a1 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -1738,6 +1738,21 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	/*
+	 * @see ASTVisitor#visit(IntersectionType)
+	 * @since 3.7
+	 */
+	public boolean visit(IntersectionType node) {
+		for (Iterator it = node.types().iterator(); it.hasNext(); ) {
+			Type t = (Type) it.next();
+			t.accept(this);
+			if (it.hasNext()) {
+				this.buffer.append(" & "); //$NON-NLS-1$
+			}
+		}
+		return false;
+	}
+
+	/*
 	 * @see ASTVisitor#visit(VariableDeclarationExpression)
 	 */
 	public boolean visit(VariableDeclarationExpression node) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
index 784259f..6d02c67 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
@@ -1122,6 +1122,14 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	}
 	
 	/*
+	 * @see ASTVisitor#visit(IntersectionType)
+	 */
+	public boolean visit(IntersectionType node) {
+		visitList(node, IntersectionType.TYPES_PROPERTY, " & ", Util.EMPTY_STRING, Util.EMPTY_STRING); //$NON-NLS-1$
+		return false;
+	}
+
+	/*
 	 * @see ASTVisitor#visit(VariableDeclarationExpression)
 	 */
 	public boolean visit(VariableDeclarationExpression node) {
commit 1987bebfc0499fe07d643a641d2e74ff184f5cc7
Author: Jayaprakash Arthanareeswaran <jarthana@in.ibm.com>
Date:   Fri Apr 19 16:43:28 2013 +0530

    Fix for bug 399792 - DefaultASTVisitor and ASTNode#nodeClassForType need
    to be updated for IntersectionType

1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
2	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
12	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
index e3c1cb1..4333647 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTStructuralPropertyTest.java
@@ -350,7 +350,7 @@ public class ASTStructuralPropertyTest extends org.eclipse.jdt.core.tests.junit.
 				// oops - guess that's not valid
 			}
 		}
-		assertEquals("Wrong last known type", 86, hi); // last known one
+		assertEquals("Wrong last known type", 87, hi); // last known one
 		assertEquals("Wrong number of distinct types",  hi, classes.size()); // all classes are distinct
 	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index 1f7a946..548fe12 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -949,6 +949,8 @@ public abstract class ASTNode {
 				return Javadoc.class;
 			case LABELED_STATEMENT :
 				return LabeledStatement.class;
+			case INTERSECTION_TYPE:
+				return IntersectionType.class;
 			case LAMBDA_EXPRESSION :
 				return LambdaExpression.class;
 			case LINE_COMMENT :
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
index 8709b86..8ddff3a 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
@@ -113,6 +113,12 @@ class DefaultASTVisitor extends ASTVisitor {
 	public void endVisit(ExtraDimension node) {
 		endVisitNode(node);
 	}
+	public void endVisit(LambdaExpression node) {
+		endVisitNode(node);
+	}
+	public void endVisit(IntersectionType node) {
+		endVisit(node);
+	}
 	public void endVisit(FieldAccess node) {
 		endVisitNode(node);
 	}
@@ -375,6 +381,12 @@ class DefaultASTVisitor extends ASTVisitor {
 	public boolean visit(ExtraDimension node) {
 		return visitNode(node);
 	}
+	public boolean visit(LambdaExpression node) {
+		return visitNode(node);
+	}
+	public boolean visit(IntersectionType node) {
+		return visitNode(node);
+	}
 	public boolean visit(FieldAccess node) {
 		return visitNode(node);
 	}
commit acc3e872f413b4237eeb7d6d9e3f49d61ce6d84c
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Mon Apr 22 17:42:00 2013 +0200

    cleanup for bug 399792 - [1.8][dom ast] AST APIs should support casts with intersection types

40	40	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
2	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
18	18	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
12	12	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
15	15	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
24	24	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
index 3bbc9a9..4e81660 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTMatcher.java
@@ -1052,6 +1052,41 @@ public class ASTMatcher {
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
 	 */
+	public boolean match(Initializer node, Object other) {
+		if (!(other instanceof Initializer)) {
+			return false;
+		}
+		Initializer o = (Initializer) other;
+		int level = node.getAST().apiLevel;
+		if (level == AST.JLS2_INTERNAL) {
+			if (node.getModifiers() != o.getModifiers()) {
+				return false;
+			}
+		}
+		if (level >= AST.JLS3_INTERNAL) {
+			if (!safeSubtreeListMatch(node.modifiers(), o.modifiers())) {
+				return false;
+			}
+		}
+		return (
+				safeSubtreeMatch(node.getJavadoc(), o.getJavadoc())
+				&& safeSubtreeMatch(node.getBody(), o.getBody()));
+	}
+
+	/**
+	 * Returns whether the given node and the other object match.
+	 * <p>
+	 * The default implementation provided by this class tests whether the
+	 * other object is a node of the same type with structurally isomorphic
+	 * child subtrees. Subclasses may override this method as needed.
+	 * </p>
+	 *
+	 * @param node the node
+	 * @param other the other object, or <code>null</code>
+	 * @return <code>true</code> if the subtree matches, or
+	 *   <code>false</code> if they do not match or the other object has a
+	 *   different node type or is <code>null</code>
+	 */
 	public boolean match(InstanceofExpression node, Object other) {
 		if (!(other instanceof InstanceofExpression)) {
 			return false;
@@ -1075,26 +1110,14 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
+	 * @since 3.9 BETA_JAVA8
 	 */
-	public boolean match(Initializer node, Object other) {
-		if (!(other instanceof Initializer)) {
+	public boolean match(IntersectionType node, Object other) {
+		if (!(other instanceof IntersectionType)) {
 			return false;
 		}
-		Initializer o = (Initializer) other;
-		int level = node.getAST().apiLevel;
-		if (level == AST.JLS2_INTERNAL) {
-			if (node.getModifiers() != o.getModifiers()) {
-				return false;
-			}
-		}
-		if (level >= AST.JLS3_INTERNAL) {
-			if (!safeSubtreeListMatch(node.modifiers(), o.modifiers())) {
-				return false;
-			}
-		}
-		return (
-				safeSubtreeMatch(node.getJavadoc(), o.getJavadoc())
-				&& safeSubtreeMatch(node.getBody(), o.getBody()));
+		IntersectionType o = (IntersectionType) other;
+		return safeSubtreeListMatch(node.types(), o.types());
 	}
 
 	/**
@@ -2307,29 +2330,6 @@ public class ASTMatcher {
 	 * @return <code>true</code> if the subtree matches, or
 	 *   <code>false</code> if they do not match or the other object has a
 	 *   different node type or is <code>null</code>
-	 * @since 3.9 BETA_JAVA8
-	 */
-	public boolean match(IntersectionType node, Object other) {
-		if (!(other instanceof IntersectionType)) {
-			return false;
-		}
-		IntersectionType o = (IntersectionType) other;
-		return safeSubtreeListMatch(node.types(), o.types());
-	}
-
-	/**
-	 * Returns whether the given node and the other object match.
-	 * <p>
-	 * The default implementation provided by this class tests whether the
-	 * other object is a node of the same type with structurally isomorphic
-	 * child subtrees. Subclasses may override this method as needed.
-	 * </p>
-	 *
-	 * @param node the node
-	 * @param other the other object, or <code>null</code>
-	 * @return <code>true</code> if the subtree matches, or
-	 *   <code>false</code> if they do not match or the other object has a
-	 *   different node type or is <code>null</code>
 	 */
 	public boolean match(VariableDeclarationExpression node, Object other) {
 		if (!(other instanceof VariableDeclarationExpression)) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
index 548fe12..3ebd6ff 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTNode.java
@@ -945,12 +945,12 @@ public abstract class ASTNode {
 				return Initializer.class;
 			case INSTANCEOF_EXPRESSION :
 				return InstanceofExpression.class;
+			case INTERSECTION_TYPE:
+				return IntersectionType.class;
 			case JAVADOC :
 				return Javadoc.class;
 			case LABELED_STATEMENT :
 				return LabeledStatement.class;
-			case INTERSECTION_TYPE:
-				return IntersectionType.class;
 			case LAMBDA_EXPRESSION :
 				return LambdaExpression.class;
 			case LINE_COMMENT :
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
index 00c80fc..fe08581 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTVisitor.java
@@ -755,6 +755,22 @@ public abstract class ASTVisitor {
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
 	 */
+	public boolean visit(Initializer node) {
+		return true;
+	}
+
+	/**
+	 * Visits the given type-specific AST node.
+	 * <p>
+	 * The default implementation does nothing and return true.
+	 * Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param node the node to visit
+	 * @return <code>true</code> if the children of this node should be
+	 * visited, and <code>false</code> if the children of this node should
+	 * be skipped
+	 */
 	public boolean visit(InstanceofExpression node) {
 		return true;
 	}
@@ -770,8 +786,9 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
+	 * @since 3.9 BETA_JAVA8
 	 */
-	public boolean visit(Initializer node) {
+	public boolean visit(IntersectionType node) {
 		return true;
 	}
 
@@ -1547,23 +1564,6 @@ public abstract class ASTVisitor {
 	 * @return <code>true</code> if the children of this node should be
 	 * visited, and <code>false</code> if the children of this node should
 	 * be skipped
-	 * @since 3.9 BETA_JAVA8
-	 */
-	public boolean visit(IntersectionType node) {
-		return true;
-	}
-
-	/**
-	 * Visits the given type-specific AST node.
-	 * <p>
-	 * The default implementation does nothing and return true.
-	 * Subclasses may reimplement.
-	 * </p>
-	 *
-	 * @param node the node to visit
-	 * @return <code>true</code> if the children of this node should be
-	 * visited, and <code>false</code> if the children of this node should
-	 * be skipped
 	 */
 	public boolean visit(VariableDeclarationExpression node) {
 		return true;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
index 8ddff3a..a6ef441 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultASTVisitor.java
@@ -113,12 +113,6 @@ class DefaultASTVisitor extends ASTVisitor {
 	public void endVisit(ExtraDimension node) {
 		endVisitNode(node);
 	}
-	public void endVisit(LambdaExpression node) {
-		endVisitNode(node);
-	}
-	public void endVisit(IntersectionType node) {
-		endVisit(node);
-	}
 	public void endVisit(FieldAccess node) {
 		endVisitNode(node);
 	}
@@ -143,12 +137,18 @@ class DefaultASTVisitor extends ASTVisitor {
 	public void endVisit(InstanceofExpression node) {
 		endVisitNode(node);
 	}
+	public void endVisit(IntersectionType node) {
+		endVisit(node);
+	}
 	public void endVisit(Javadoc node) {
 		endVisitNode(node);
 	}
 	public void endVisit(LabeledStatement node) {
 		endVisitNode(node);
 	}
+	public void endVisit(LambdaExpression node) {
+		endVisitNode(node);
+	}
 	public void endVisit(LineComment node) {
 		endVisitNode(node);
 	}
@@ -381,12 +381,6 @@ class DefaultASTVisitor extends ASTVisitor {
 	public boolean visit(ExtraDimension node) {
 		return visitNode(node);
 	}
-	public boolean visit(LambdaExpression node) {
-		return visitNode(node);
-	}
-	public boolean visit(IntersectionType node) {
-		return visitNode(node);
-	}
 	public boolean visit(FieldAccess node) {
 		return visitNode(node);
 	}
@@ -411,6 +405,9 @@ class DefaultASTVisitor extends ASTVisitor {
 	public boolean visit(InstanceofExpression node) {
 		return visitNode(node);
 	}
+	public boolean visit(IntersectionType node) {
+		return visitNode(node);
+	}
 	public boolean visit(Javadoc node) {
 		//	do not visit Javadoc tags by default. Use constructor with boolean to enable.
 		if (super.visit(node)) {
@@ -421,6 +418,9 @@ class DefaultASTVisitor extends ASTVisitor {
 	public boolean visit(LabeledStatement node) {
 		return visitNode(node);
 	}
+	public boolean visit(LambdaExpression node) {
+		return visitNode(node);
+	}
 	public boolean visit(LineComment node) {
 		return visitNode(node);
 	}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
index 7f4b3a1..a9c1d60 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/NaiveASTFlattener.java
@@ -851,6 +851,21 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	/*
+	 * @see ASTVisitor#visit(IntersectionType)
+	 * @since 3.7
+	 */
+	public boolean visit(IntersectionType node) {
+		for (Iterator it = node.types().iterator(); it.hasNext(); ) {
+			Type t = (Type) it.next();
+			t.accept(this);
+			if (it.hasNext()) {
+				this.buffer.append(" & "); //$NON-NLS-1$
+			}
+		}
+		return false;
+	}
+
+	/*
 	 * @see ASTVisitor#visit(Javadoc)
 	 */
 	public boolean visit(Javadoc node) {
@@ -1738,21 +1753,6 @@ public class NaiveASTFlattener extends ASTVisitor {
 	}
 
 	/*
-	 * @see ASTVisitor#visit(IntersectionType)
-	 * @since 3.7
-	 */
-	public boolean visit(IntersectionType node) {
-		for (Iterator it = node.types().iterator(); it.hasNext(); ) {
-			Type t = (Type) it.next();
-			t.accept(this);
-			if (it.hasNext()) {
-				this.buffer.append(" & "); //$NON-NLS-1$
-			}
-		}
-		return false;
-	}
-
-	/*
 	 * @see ASTVisitor#visit(VariableDeclarationExpression)
 	 */
 	public boolean visit(VariableDeclarationExpression node) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
index 6d02c67..a031c72 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteFlattener.java
@@ -499,6 +499,12 @@ public class ASTRewriteFlattener extends ASTVisitor {
 		return false;
 	}
 
+	public boolean visit(ExtraDimension node) {
+		visitList(node, ExtraDimension.ANNOTATIONS_PROPERTY, String.valueOf(' '), String.valueOf(' '), String.valueOf(' '));
+		this.result.append("[]"); //$NON-NLS-1$
+		return false;
+	}
+
 	/*
 	 * @see ASTVisitor#visit(FieldAccess)
 	 */
@@ -604,16 +610,6 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	}
 
 	/*
-	 * @see ASTVisitor#visit(InstanceofExpression)
-	 */
-	public boolean visit(InstanceofExpression node) {
-		getChildNode(node, InstanceofExpression.LEFT_OPERAND_PROPERTY).accept(this);
-		this.result.append(" instanceof "); //$NON-NLS-1$
-		getChildNode(node, InstanceofExpression.RIGHT_OPERAND_PROPERTY).accept(this);
-		return false;
-	}
-
-	/*
 	 * @see ASTVisitor#visit(Initializer)
 	 */
 	public boolean visit(Initializer node) {
@@ -631,6 +627,24 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	}
 
 	/*
+	 * @see ASTVisitor#visit(InstanceofExpression)
+	 */
+	public boolean visit(InstanceofExpression node) {
+		getChildNode(node, InstanceofExpression.LEFT_OPERAND_PROPERTY).accept(this);
+		this.result.append(" instanceof "); //$NON-NLS-1$
+		getChildNode(node, InstanceofExpression.RIGHT_OPERAND_PROPERTY).accept(this);
+		return false;
+	}
+
+	/*
+	 * @see ASTVisitor#visit(IntersectionType)
+	 */
+	public boolean visit(IntersectionType node) {
+		visitList(node, IntersectionType.TYPES_PROPERTY, " & ", Util.EMPTY_STRING, Util.EMPTY_STRING); //$NON-NLS-1$
+		return false;
+	}
+
+	/*
 	 * @see ASTVisitor#visit(Javadoc)
 	 */
 	public boolean visit(Javadoc node) {
@@ -653,12 +667,6 @@ public class ASTRewriteFlattener extends ASTVisitor {
 		getChildNode(node, LabeledStatement.BODY_PROPERTY).accept(this);
 		return false;
 	}
-	public boolean visit(ExtraDimension node) {
-		visitList(node, ExtraDimension.ANNOTATIONS_PROPERTY, String.valueOf(' '), String.valueOf(' '), String.valueOf(' '));
-		this.result.append("[]"); //$NON-NLS-1$
-		return false;
-	}
-
 	/*
 	 * @see ASTVisitor#visit(LambdaExpression)
 	 */
@@ -1122,14 +1130,6 @@ public class ASTRewriteFlattener extends ASTVisitor {
 	}
 	
 	/*
-	 * @see ASTVisitor#visit(IntersectionType)
-	 */
-	public boolean visit(IntersectionType node) {
-		visitList(node, IntersectionType.TYPES_PROPERTY, " & ", Util.EMPTY_STRING, Util.EMPTY_STRING); //$NON-NLS-1$
-		return false;
-	}
-
-	/*
 	 * @see ASTVisitor#visit(VariableDeclarationExpression)
 	 */
 	public boolean visit(VariableDeclarationExpression node) {
commit e7e2695fe5657cf6f05f673f7f1f6646805752fe
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Wed Apr 24 18:24:15 2013 +0200

    Bug 399792: [1.8][dom ast] AST APIs should support casts with intersection types

18	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
index 3cd23b3..7adedd2 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/ASTRewriteAnalyzer.java
@@ -2752,7 +2752,7 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 		return false;
 	}
 
-	public void ensureSpaceAfterReplace(ASTNode node, ChildPropertyDescriptor desc) {
+	private void ensureSpaceAfterReplace(ASTNode node, ChildPropertyDescriptor desc) {
 		if (getChangeKind(node, desc) == RewriteEvent.REPLACED) {
 			int leftOperandEnd= getExtendedEnd((ASTNode) getOriginalValue(node, desc));
 			try {
@@ -2767,7 +2767,7 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 		}
 	}
 	
-	public void ensureSpaceBeforeReplace(ASTNode node) {
+	private void ensureSpaceBeforeReplace(ASTNode node) {
 		if (this.beforeRequiredSpaceIndex  == -1) return;
 		
 		List events = this.eventStore.getChangedPropertieEvents(node);
@@ -2789,6 +2789,22 @@ public final class ASTRewriteAnalyzer extends ASTVisitor {
 	}
 
 	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.dom.ASTVisitor#visit(IntersectionType)
+	 */
+	public boolean visit(IntersectionType node) {
+		if (!hasChildrenChanges(node)) {
+			return doVisitUnchangedChildren(node);
+		}
+		int pos= node.getStartPosition();
+		if (isChanged(node, IntersectionType.TYPES_PROPERTY)) {
+			pos= rewriteNodeList(node, IntersectionType.TYPES_PROPERTY, pos, Util.EMPTY_STRING, " & "); //$NON-NLS-1$
+		} else {
+			pos= doVisit(node, IntersectionType.TYPES_PROPERTY, pos);
+		}
+		return false;
+	}
+	
+	/* (non-Javadoc)
 	 * @see org.eclipse.jdt.core.dom.ASTVisitor#visit(Javadoc)
 	 */
 	public boolean visit(Javadoc node) {
