commit 520b5ba70c0bc4e81e4304416320f75656e3c94b
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Sat Feb 4 11:10:53 2017 +0530

    Fix for bug 510339 [1.9][select] code select for constructs in
    module-info.java
    
    Change-Id: I89f8b644ed58330bd9b9e8f081ec61abcbbc6877
    Signed-off-by: Manoj Palat <manpalat@in.ibm.com>

374	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/SelectionParserTest9.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
4	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava9Tests.java
53	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
390	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
0	53	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
37	15	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
0	47	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnExportReference.java
47	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnPackageVisibilityReference.java
7	3	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ProvidesStatement.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/SelectionParserTest9.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/SelectionParserTest9.java
new file mode 100644
index 0000000..2956ec6
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/SelectionParserTest9.java
@@ -0,0 +1,374 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.parser;
+
+import org.eclipse.jdt.core.JavaModelException;
+
+import junit.framework.Test;
+
+public class SelectionParserTest9 extends AbstractSelectionTest {
+static {
+//		TESTS_NUMBERS = new int[] { 1 };
+//		TESTS_NAMES = new String[] { "test510339_007" };
+}
+public static Test suite() {
+	return buildMinimalComplianceTestSuite(SelectionParserTest9.class, F_9);
+}
+
+public SelectionParserTest9(String testName) {
+	super(testName);
+}
+
+public void test510339_001_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  exports pack1;\n"
+			+ "}\n";
+
+
+	String selection = "pack1";
+	String selectKey = "<SelectOnPackageVisibility:";
+	String expectedCompletionNodeToString = selectKey + selection + ">";
+
+	String completionIdentifier = "pack1";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  exports " + expectedCompletionNodeToString +";\n"
+			+ "}\n";
+	String expectedReplacedSource = "pack1";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+public void test510339_002_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  exports pack1 to second;\n"
+			+ "}\n";
+
+
+	String selection = "second";
+
+	String expectedCompletionNodeToString = "<SelectOnModuleReference:" + selection + ">";
+
+	String completionIdentifier = "second";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  exports pack1 to "+ expectedCompletionNodeToString + ";\n"
+			+ "}\n";
+	String expectedReplacedSource = "second";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+public void test510339_003_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  opens pack1;\n"
+			+ "}\n";
+
+
+	String selection = "pack1";
+	String selectKey = "<SelectOnPackageVisibility:";
+	String expectedCompletionNodeToString = selectKey + selection + ">";
+
+	String completionIdentifier = "pack1";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  opens " + expectedCompletionNodeToString +";\n"
+			+ "}\n";
+	String expectedReplacedSource = "pack1";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+public void test510339_004_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  opens pack1 to second;\n"
+			+ "}\n";
+
+
+	String selection = "second";
+
+	String expectedCompletionNodeToString = "<SelectOnModuleReference:" + selection + ">";
+
+	String completionIdentifier = "second";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  opens pack1 to "+ expectedCompletionNodeToString + ";\n"
+			+ "}\n";
+	String expectedReplacedSource = "second";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+public void test510339_005_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  requires second;\n"
+			+ "}\n";
+
+
+	String selection = "second";
+
+	String expectedCompletionNodeToString = "<SelectOnModuleReference:" + selection + ">";
+
+	String completionIdentifier = "second";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  requires "+ expectedCompletionNodeToString + ";\n"
+			+ "}\n";
+	String expectedReplacedSource = "second";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+public void test510339_006_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  uses Z;\n"
+			+ "}\n";
+
+
+	String selection = "Z";
+
+	String expectedCompletionNodeToString = "<SelectOnType:" + selection + ">";
+
+	String completionIdentifier = "Z";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  uses "+ expectedCompletionNodeToString + ";\n"
+			+ "}\n";
+	String expectedReplacedSource = "Z";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+public void test510339_007_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  uses pack1.Z;\n"
+			+ "}\n";
+
+
+	String selection = "Z";
+	String expectedCompletionNodeToString = "<SelectOnType:pack1.Z>";
+
+	String completionIdentifier = "Z";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  uses <SelectOnType:pack1.Z>" + ";\n"
+			+ "}\n";
+	String expectedReplacedSource = "pack1.Z";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+public void test510339_008_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  provides Y with Z;\n"
+			+ "}\n";
+
+
+	String selection = "Y";
+
+	String expectedCompletionNodeToString = "<SelectOnType:" + selection + ">";
+
+	String completionIdentifier = "Y";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  provides "+ expectedCompletionNodeToString + " with Z;\n"
+			+ "}\n";
+	String expectedReplacedSource = "Y";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+public void test510339_009_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  provides pack1.Y with Z;\n"
+			+ "}\n";
+
+
+	String selection = "Y";
+
+	String expectedCompletionNodeToString = "<SelectOnType:pack1.Y>";
+
+	String completionIdentifier = "Y";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  provides <SelectOnType:pack1.Y> with Z;\n"
+			+ "}\n";
+	String expectedReplacedSource = "pack1.Y";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+public void test510339_010_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  provides Y with Z;\n"
+			+ "}\n";
+
+
+	String selection = "Z";
+
+	String expectedCompletionNodeToString = "<SelectOnType:" + selection + ">";
+
+	String completionIdentifier = "Z";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  provides Y with "+ expectedCompletionNodeToString + ";\n"
+			+ "}\n";
+	String expectedReplacedSource = "Z";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+public void test510339_011_since_9() throws JavaModelException {
+	String string =  "module my.mod {\n"
+			+ "  provides Y with pack1.Z;\n"
+			+ "}\n";
+
+
+	String selection = "Z";
+
+	String expectedCompletionNodeToString = "<SelectOnType:pack1.Z>";
+
+	String completionIdentifier = "Z";
+	String expectedUnitDisplayString =
+			"module my.mod {\n"
+			+ "  provides Y with "+ expectedCompletionNodeToString + ";\n"
+			+ "}\n";
+	String expectedReplacedSource = "pack1.Z";
+	String testName = "module-info.java";
+
+	int selectionStart = string.lastIndexOf(selection);
+	int selectionEnd = string.lastIndexOf(selection) + selection.length() - 1;
+
+	checkDietParse(
+		string.toCharArray(),
+		selectionStart,
+		selectionEnd,
+		expectedCompletionNodeToString,
+		expectedUnitDisplayString,
+		completionIdentifier,
+		expectedReplacedSource,
+		testName);
+}
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
index 92b8d3e..8a8aa93 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -130,6 +130,7 @@ public static TestSuite getTestSuite(boolean addComplianceDiagnoseTest) {
 		tests_9.add(TypeAnnotationSyntaxTest.class);
 		tests_9.add(CompletionParserTest18.class);
 		tests_9.add(SelectionParserTest18.class);
+		tests_9.add(SelectionParserTest9.class);
 		tests_9.add(ModuleDeclarationSyntaxTest.class);
 		// Reset forgotten subsets tests
 		TestCase.TESTS_PREFIX = null;
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava9Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava9Tests.java
index 7d5e641..f2b3ac1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava9Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava9Tests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,6 +17,7 @@ package org.eclipse.jdt.core.tests;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
+import org.eclipse.jdt.core.tests.compiler.parser.SelectionParserTest9;
 import org.eclipse.jdt.core.tests.dom.ASTConverter9Test;
 import org.eclipse.jdt.core.tests.dom.ConverterTestSetup;
 import org.eclipse.jdt.core.tests.model.CompletionTests9;
@@ -31,7 +32,7 @@ import junit.framework.TestSuite;
 
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class RunAllJava9Tests extends TestCase {
-	
+
 	public RunAllJava9Tests(String name) {
 		super(name);
 	}
@@ -41,6 +42,7 @@ public class RunAllJava9Tests extends TestCase {
 			Java9ElementTests.class,
 			JavaSearchBugs9Tests.class,
 			CompletionTests9.class,
+			SelectionParserTest9.class,
 		};
 	}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
index 4a40d8e..c1e41cd 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1281,7 +1281,7 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 	protected void createJar(String[] javaPathsAndContents, String jarPath, Map options) throws IOException {
 		org.eclipse.jdt.core.tests.util.Util.createJar(javaPathsAndContents, null, jarPath, null, "1.4", options);
 	}
-	
+
 	protected void createJar(String[] javaPathsAndContents, String jarPath, String[] classpath, String compliance) throws IOException {
 		org.eclipse.jdt.core.tests.util.Util.createJar(javaPathsAndContents, null,jarPath, classpath, compliance);
 	}
@@ -1289,7 +1289,22 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 	protected void createJar(String[] javaPathsAndContents, String jarPath, String[] classpath, String compliance, Map options) throws IOException {
 		org.eclipse.jdt.core.tests.util.Util.createJar(javaPathsAndContents, null, jarPath, classpath, compliance, options);
 	}
-	
+
+	protected IJavaProject createJava9Project(String name) throws CoreException {
+		return createJava9Project(name, new String[]{"src"});
+	}
+	protected IJavaProject createJava9Project(String name, String[] srcFolders) throws CoreException {
+		String bootModPath = System.getProperty("java.home") + File.separator +"/lib/jrt-fs.jar";
+		IClasspathEntry jrtEntry = JavaCore.newLibraryEntry(new Path(bootModPath), null, null, null, null, false);
+		IJavaProject project = this.createJavaProject(name, srcFolders, new String[0],
+				new String[0], "bin", "9");
+		IClasspathEntry[] old = project.getRawClasspath();
+		IClasspathEntry[] newPath = new IClasspathEntry[old.length +1];
+		System.arraycopy(old, 0, newPath, 0, old.length);
+		newPath[old.length] = jrtEntry;
+		project.setRawClasspath(newPath, null);
+		return project;
+	}
 	/*
 	}
 	 * Creates a Java project where prj=src=bin and with JCL_LIB on its classpath.
@@ -2769,6 +2784,41 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 			assertTrue("failed to set classpath", false);
 		}
 	}
+	protected IJavaProject setupModuleProject(String name, String[] sources) throws CoreException {
+		return setupModuleProject(name, sources, false);
+	}
+	protected IJavaProject setupModuleProject(String name, String[] sources, boolean addModulePathContainer) throws CoreException {
+		IClasspathEntry[] deps = null;
+		if (addModulePathContainer) {
+			IClasspathEntry containerEntry = JavaCore.newContainerEntry(new Path(JavaCore.MODULE_PATH_CONTAINER_ID));
+			deps = new IClasspathEntry[] {containerEntry};
+		}
+		return setupModuleProject(name, sources, deps);
+	}
+	protected IJavaProject setupModuleProject(String name, String[] sources, IClasspathEntry[] deps) throws CoreException {
+		return setupModuleProject(name, new String[]{"src"}, sources, deps);
+	}
+	protected IJavaProject setupModuleProject(String name, String[] srcFolders, String[] sources, IClasspathEntry[] deps) throws CoreException {
+		IJavaProject project = createJava9Project(name, srcFolders);
+		IProgressMonitor monitor = new NullProgressMonitor();
+		for (int i = 0; i < sources.length; i+= 2) {
+			IPath path = new Path(sources[i]);
+			IPath parentPath = path.removeLastSegments(1);
+			IFolder folder = project.getProject().getFolder(parentPath);
+			if (!folder.exists())
+				this.createFolder(folder.getFullPath());
+			IFile file = project.getProject().getFile(new Path(sources[i]));
+			file.create(new ByteArrayInputStream(sources[i+1].getBytes()), true, monitor);
+		}
+		if (deps != null) {
+			IClasspathEntry[] old = project.getRawClasspath();
+			IClasspathEntry[] newPath = new IClasspathEntry[old.length + deps.length];
+			System.arraycopy(old, 0, newPath, 0, old.length);
+			System.arraycopy(deps, 0, newPath, old.length, deps.length);
+			project.setRawClasspath(newPath, null);
+		}
+		return project;
+	}
 	/**
 	 * Check locally for the required JCL files, <jclName>.jar and <jclName>src.zip.
 	 * If not available, copy from the project resources.
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
index 101d1cd..d13884c 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
@@ -14,6 +14,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
+import org.eclipse.core.runtime.Path;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
@@ -22,14 +23,17 @@ import org.eclipse.jdt.core.IModuleDescription.IModuleReference;
 import org.eclipse.jdt.core.IModuleDescription.IOpenPackage;
 import org.eclipse.jdt.core.IModuleDescription.IPackageExport;
 import org.eclipse.jdt.core.IModuleDescription.IProvidedService;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.tests.util.AbstractCompilerTest;
 
 import junit.framework.Test;
 
-public class Java9ElementTests extends AbstractJavaModelTests { 
+public class Java9ElementTests extends AbstractJavaModelTests {
 
 	static {
-//		TESTS_NAMES = new String[] {"test010"};
+//		TESTS_NAMES = new String[] {"testBug510339_002"};
 	}
 
 	public Java9ElementTests(String name) {
@@ -474,4 +478,388 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 			deleteProject("Java9Elements");
 		}
 	}
+	public void testBug510339_001_since_9() throws Exception {
+		try {
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			addClasspathEntry(project, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			project.open(null);
+			String fileContent =
+				"module first {\n" +
+				"    exports pack1 to second;\n" +
+				"}\n";
+			createFile("/Java9Elements/src/module-info.java",	fileContent);
+			int start = fileContent.lastIndexOf("pack1");
+			createFolder("/Java9Elements/src/pack1");
+			createFile("/Java9Elements/src/pack1/X11.java",
+					"package pack1;\n" +
+					"public class X11 {}\n");
+
+			ICompilationUnit unit = getCompilationUnit("/Java9Elements/src/module-info.java");
+
+			IJavaElement[] elements = unit.codeSelect(start, "pack1".length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			IPackageFragment fragment = (IPackageFragment) elements[0];
+			assertEquals("pack1", fragment.getElementName());
+		}
+		finally {
+			deleteProject("Java9Elements");
+		}
+	}
+	public void testBug510339_002_since_9() throws Exception {
+		try {
+
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent =
+				"module first {\n" +
+				"    exports pack1 to second;\n" +
+				"}\n";
+			createFile("/Java9Elements/src/module-info.java",	fileContent);
+			String selection = "second";
+			int start = fileContent.lastIndexOf(selection);
+			createFolder("/Java9Elements/src/pack1");
+			createFile("/Java9Elements/src/pack1/X11.java",
+					"package pack1;\n" +
+					"public class X11 {}\n");
+
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project2.open(null);
+			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String secondFile =
+					"module second {\n" +
+					"    requires first;\n" +
+					"}\n";
+			createFile("/second/src/module-info.java",	secondFile);
+
+			addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+			project1.close(); // sync
+			project2.close();
+			project2.open(null);
+			project1.open(null);
+
+			ICompilationUnit unit = getCompilationUnit("/Java9Elements/src/module-info.java");
+			IJavaElement[] elements = unit.codeSelect(start, selection.length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			IModuleDescription ref = (IModuleDescription) elements[0];
+			assertEquals("second", ref.getElementName());
+		}
+		finally {
+			deleteProject("Java9Elements");
+			deleteProject("second");
+		}
+	}
+	public void testBug510339_003_since_9() throws Exception {
+		try {
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			addClasspathEntry(project, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			project.open(null);
+			String fileContent =
+				"module first {\n" +
+				"    opens pack1 to second;\n" +
+				"}\n";
+			createFile("/Java9Elements/src/module-info.java",	fileContent);
+			int start = fileContent.lastIndexOf("pack1");
+			createFolder("/Java9Elements/src/pack1");
+			createFile("/Java9Elements/src/pack1/X11.java",
+					"package pack1;\n" +
+					"public class X11 {}\n");
+
+			ICompilationUnit unit = getCompilationUnit("/Java9Elements/src/module-info.java");
+
+			IJavaElement[] elements = unit.codeSelect(start, "pack1".length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			IPackageFragment fragment = (IPackageFragment) elements[0];
+			assertEquals("pack1", fragment.getElementName());
+		}
+		finally {
+			deleteProject("Java9Elements");
+		}
+	}
+	public void testBug510339_004_since_9() throws Exception {
+		try {
+
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent =
+				"module first {\n" +
+				"    exports pack1 to second;\n" +
+				"}\n";
+			createFile("/Java9Elements/src/module-info.java",	fileContent);
+			createFolder("/Java9Elements/src/pack1");
+			createFile("/Java9Elements/src/pack1/X11.java",
+					"package pack1;\n" +
+					"public class X11 {}\n");
+
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project2.open(null);
+			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String secondFile =
+					"module second {\n" +
+					"    requires first;\n" +
+					"}\n";
+			createFile("/second/src/module-info.java",	secondFile);
+
+			addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+			project1.close(); // sync
+			project2.close();
+			project2.open(null);
+			project1.open(null);
+
+			ICompilationUnit unit = getCompilationUnit("/second/src/module-info.java");
+			String selection = "first";
+			int start = secondFile.lastIndexOf(selection);
+			IJavaElement[] elements = unit.codeSelect(start, selection.length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			IModuleDescription ref = (IModuleDescription) elements[0];
+			assertEquals("first", ref.getElementName());
+		}
+		finally {
+			deleteProject("Java9Elements");
+			deleteProject("second");
+		}
+	}
+	public void testBug510339_005_since_9() throws Exception {
+		try {
+
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent =
+				"module first {\n" +
+				"    requires second;\n" +
+				"    provides pack22.I22 with pack11.X11;\n" +
+				"}\n";
+			createFile("/Java9Elements/src/module-info.java", fileContent);
+			createFolder("/Java9Elements/src/pack11");
+			createFile("/Java9Elements/src/pack11/X11.java",
+					"package pack11;\n" +
+					"public class X11 implements pack22.I22 {}\n");
+
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project2.open(null);
+			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String secondFile =
+					"module second {\n" +
+					"    exports pack22 to first;\n" +
+					"}\n";
+			createFile("/second/src/module-info.java",	secondFile);
+			createFolder("/second/src/pack22");
+			createFile("/second/src/pack22/I22.java",
+					"package pack22;\n" +
+					"public interface I22 {}\n");
+
+			addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+			project1.close(); // sync
+			project2.close();
+			project2.open(null);
+			project1.open(null);
+
+			ICompilationUnit unit = getCompilationUnit("/Java9Elements/src/module-info.java");
+			String selection = "pack22";
+			int start = fileContent.lastIndexOf(selection);
+			IJavaElement[] elements = unit.codeSelect(start, selection.length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			IPackageFragment fragment = (IPackageFragment) elements[0];
+			assertEquals("pack22", fragment.getElementName());
+		}
+		finally {
+			deleteProject("Java9Elements");
+			deleteProject("second");
+		}
+	}
+	public void testBug510339_006_since_9() throws Exception {
+		try {
+
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent =
+				"module first {\n" +
+				"    requires second;\n" +
+				"    provides pack22.I22 with pack11.X11;\n" +
+				"}\n";
+			createFile("/Java9Elements/src/module-info.java", fileContent);
+			createFolder("/Java9Elements/src/pack11");
+			createFile("/Java9Elements/src/pack11/X11.java",
+					"package pack11;\n" +
+					"public class X11 implements pack22.I22 {}\n");
+
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project2.open(null);
+			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String secondFile =
+					"module second {\n" +
+					"    exports pack22 to first;\n" +
+					"}\n";
+			createFile("/second/src/module-info.java",	secondFile);
+			createFolder("/second/src/pack22");
+			createFile("/second/src/pack22/I22.java",
+					"package pack22;\n" +
+					"public interface I22 {}\n");
+
+			addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+			project1.close(); // sync
+			project2.close();
+			project2.open(null);
+			project1.open(null);
+
+			ICompilationUnit unit = getCompilationUnit("/Java9Elements/src/module-info.java");
+			String selection = "pack11";
+			int start = fileContent.lastIndexOf(selection);
+			IJavaElement[] elements = unit.codeSelect(start, selection.length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			IPackageFragment fragment = (IPackageFragment) elements[0];
+			assertEquals("pack11", fragment.getElementName());
+		}
+		finally {
+			deleteProject("Java9Elements");
+			deleteProject("second");
+		}
+	}
+	public void testBug510339_007_since_9() throws Exception {
+		try {
+
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent =
+				"module first {\n" +
+				"    requires second;\n" +
+				"    uses pack11.X11;\n" +
+				"}\n";
+			createFile("/Java9Elements/src/module-info.java", fileContent);
+			createFolder("/Java9Elements/src/pack11");
+			createFile("/Java9Elements/src/pack11/X11.java",
+					"package pack11;\n" +
+					"public class X11 implements pack22.I22 {}\n");
+
+			project1.close(); // sync
+			project1.open(null);
+
+			ICompilationUnit unit = getCompilationUnit("/Java9Elements/src/module-info.java");
+			String selection = "pack11";
+			int start = fileContent.lastIndexOf(selection);
+			IJavaElement[] elements = unit.codeSelect(start, selection.length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			IPackageFragment fragment = (IPackageFragment) elements[0];
+			assertEquals("pack11", fragment.getElementName());
+		}
+		finally {
+			deleteProject("Java9Elements");
+		}
+	}
+	public void testBug510339_008_since_9() throws Exception {
+		try {
+
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent =
+				"module first {\n" +
+				"    requires second;\n" +
+				"    provides pack22.I22 with pack11.X11;\n" +
+				"}\n";
+			createFile("/Java9Elements/src/module-info.java", fileContent);
+			createFolder("/Java9Elements/src/pack11");
+			createFile("/Java9Elements/src/pack11/X11.java",
+					"package pack11;\n" +
+					"public class X11 implements pack22.I22 {}\n");
+
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project2.open(null);
+			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String secondFile =
+					"module second {\n" +
+					"    exports pack22 to first;\n" +
+					"}\n";
+			createFile("/second/src/module-info.java",	secondFile);
+			createFolder("/second/src/pack22");
+			createFile("/second/src/pack22/I22.java",
+					"package pack22;\n" +
+					"public interface I22 {}\n");
+
+			addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+			project1.close(); // sync
+			project2.close();
+			project2.open(null);
+			project1.open(null);
+
+			ICompilationUnit unit = getCompilationUnit("/Java9Elements/src/module-info.java");
+			String selection = "X11";
+			int start = fileContent.lastIndexOf(selection);
+			IJavaElement[] elements = unit.codeSelect(start, selection.length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			IType type = (IType) elements[0];
+			assertEquals("X11", type.getElementName());
+		}
+		finally {
+			deleteProject("Java9Elements");
+			deleteProject("second");
+		}
+	}
+	public void testBug510339_009_since_9() throws Exception {
+		try {
+
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent =
+				"module first {\n" +
+				"    requires second;\n" +
+				"    uses pack11.X11;\n" +
+				"}\n";
+			createFile("/Java9Elements/src/module-info.java", fileContent);
+			createFolder("/Java9Elements/src/pack11");
+			createFile("/Java9Elements/src/pack11/X11.java",
+					"package pack11;\n" +
+					"public class X11 implements pack22.I22 {}\n");
+
+			project1.close(); // sync
+			project1.open(null);
+
+			ICompilationUnit unit = getCompilationUnit("/Java9Elements/src/module-info.java");
+			String selection = "X11";
+			int start = fileContent.lastIndexOf(selection);
+			IJavaElement[] elements = unit.codeSelect(start, selection.length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			IType type = (IType) elements[0];
+			assertEquals("X11", type.getElementName());
+		}
+		finally {
+			deleteProject("Java9Elements");
+		}
+	}
+	public void testBug510339_010_since_9() throws Exception {
+		try {
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent =
+				"module first {\n" +
+				"    requires second;\n" +
+				"    uses pack11.X11;\n" +
+				"}\n";
+			createFile("/Java9Elements/src/module-info.java", fileContent);
+			createFolder("/Java9Elements/src/pack11");
+			createFile("/Java9Elements/src/pack11/X11.java",
+					"package pack11;\n" +
+					"public class X11 implements pack22.I22 {}\n");
+
+			project1.close(); // sync
+			project1.open(null);
+
+			ICompilationUnit unit = getCompilationUnit("/Java9Elements/src/module-info.java");
+			String selection = "X11";
+			int start = fileContent.lastIndexOf(selection);
+			IJavaElement[] elements = unit.codeSelect(start, selection.length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			IType type = (IType) elements[0];
+			assertEquals("X11", type.getElementName());
+		}
+		finally {
+			deleteProject("Java9Elements");
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index f438788..661ff11 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -14,7 +14,6 @@
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
-import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
@@ -28,8 +27,6 @@ import org.eclipse.core.resources.IWorkspaceDescription;
 import org.eclipse.core.resources.IncrementalProjectBuilder;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.NullProgressMonitor;
 import org.eclipse.core.runtime.Path;
 import org.eclipse.jdt.core.IClasspathEntry;
 import org.eclipse.jdt.core.ICompilationUnit;
@@ -87,21 +84,6 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 		waitForManualRefresh();
 		waitForAutoBuild();
 	}
-	private IJavaProject createJava9Project(String name) throws CoreException {
-		return createJava9Project(name, new String[]{"src"});
-	}
-	private IJavaProject createJava9Project(String name, String[] srcFolders) throws CoreException {
-		String bootModPath = System.getProperty("java.home") + File.separator +"/lib/jrt-fs.jar";
-		IClasspathEntry jrtEntry = JavaCore.newLibraryEntry(new Path(bootModPath), null, null, null, null, false);
-		IJavaProject project = this.createJavaProject(name, srcFolders, new String[0],
-				new String[0], "bin", "9");
-		IClasspathEntry[] old = project.getRawClasspath();
-		IClasspathEntry[] newPath = new IClasspathEntry[old.length +1];
-		System.arraycopy(old, 0, newPath, 0, old.length);
-		newPath[old.length] = jrtEntry;
-		project.setRawClasspath(newPath, null);
-		return project;
-	}
 	// Test that the java.base found as a module package fragment root in the project 
 	public void test001() throws CoreException {
 		if (!isJRE9) return;
@@ -2547,41 +2529,6 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			deleteProject("com.greetings");
 		}
 	}
-	private IJavaProject setupModuleProject(String name, String[] sources) throws CoreException {
-		return setupModuleProject(name, sources, false);
-	}
-	private IJavaProject setupModuleProject(String name, String[] sources, boolean addModulePathContainer) throws CoreException {
-		IClasspathEntry[] deps = null;
-		if (addModulePathContainer) {
-			IClasspathEntry containerEntry = JavaCore.newContainerEntry(new Path(JavaCore.MODULE_PATH_CONTAINER_ID));
-			deps = new IClasspathEntry[] {containerEntry};
-		}
-		return setupModuleProject(name, sources, deps);
-	}
-	private IJavaProject setupModuleProject(String name, String[] sources, IClasspathEntry[] deps) throws CoreException {
-		return setupModuleProject(name, new String[]{"src"}, sources, deps);
-	}
-	private IJavaProject setupModuleProject(String name, String[] srcFolders, String[] sources, IClasspathEntry[] deps) throws CoreException {
-		IJavaProject project = createJava9Project(name, srcFolders);
-		IProgressMonitor monitor = new NullProgressMonitor();
-		for (int i = 0; i < sources.length; i+= 2) {
-			IPath path = new Path(sources[i]);
-			IPath parentPath = path.removeLastSegments(1);
-			IFolder folder = project.getProject().getFolder(parentPath);
-			if (!folder.exists())
-				this.createFolder(folder.getFullPath());
-			IFile file = project.getProject().getFile(new Path(sources[i]));
-			file.create(new ByteArrayInputStream(sources[i+1].getBytes()), true, monitor);
-		}
-		if (deps != null) {
-			IClasspathEntry[] old = project.getRawClasspath();
-			IClasspathEntry[] newPath = new IClasspathEntry[old.length + deps.length];
-			System.arraycopy(old, 0, newPath, 0, old.length);
-			System.arraycopy(deps, 0, newPath, old.length, deps.length);
-			project.setRawClasspath(newPath, null);
-		}
-		return project;
-	}
 	// sort by CHAR_START
 	protected void sortMarkers(IMarker[] markers) {
 		Arrays.sort(markers, (a,b) -> a.getAttribute(IMarker.CHAR_START, 0) - b.getAttribute(IMarker.CHAR_START, 0)); 
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
index 0931991..22c7b49 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -40,7 +44,7 @@ import org.eclipse.jdt.internal.codeassist.impl.AssistParser;
 import org.eclipse.jdt.internal.codeassist.impl.Engine;
 import org.eclipse.jdt.internal.codeassist.select.SelectionJavadocParser;
 import org.eclipse.jdt.internal.codeassist.select.SelectionNodeFound;
-import org.eclipse.jdt.internal.codeassist.select.SelectionOnExportReference;
+import org.eclipse.jdt.internal.codeassist.select.SelectionOnPackageVisibilityReference;
 import org.eclipse.jdt.internal.codeassist.select.SelectionOnImportReference;
 import org.eclipse.jdt.internal.codeassist.select.SelectionOnPackageReference;
 import org.eclipse.jdt.internal.codeassist.select.SelectionOnQualifiedTypeReference;
@@ -53,11 +57,12 @@ import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.ExportsStatement;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
+import org.eclipse.jdt.internal.compiler.ast.PackageVisibilityStatement;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
@@ -85,6 +90,7 @@ import org.eclipse.jdt.internal.compiler.lookup.ProblemFieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
@@ -1022,17 +1028,10 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				if (parsedUnit.isModuleInfo() && parsedUnit.types != null &&
 						parsedUnit.types.length > 0) {
 					ModuleDeclaration module = (ModuleDeclaration) parsedUnit.types[0];//TODO, could be null
-					ExportsStatement[] exports = module.exports;
-					if (exports != null) {
-						for (ExportsStatement exportReference : exports) {
-							if (exportReference.pkgRef instanceof SelectionOnExportReference) {
-								char[][] tokens = ((SelectionOnExportReference) exportReference.pkgRef).tokens;
-								this.noProposal = false;
-								this.requestor.acceptPackage(CharOperation.concatWith(tokens, '.'));
-							}
-						}
-					}
-				} 
+					this.lookupEnvironment.buildTypeBindings(parsedUnit, null /*no access restriction*/);
+					acceptPackageVisibilityStatements(module.exports, parsedUnit.scope);
+					acceptPackageVisibilityStatements(module.opens, parsedUnit.scope);
+				}
 				if (parsedUnit.types != null || parsedUnit.isPackageInfo()) {
 					if(selectDeclaration(parsedUnit))
 						return;
@@ -1040,7 +1039,6 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 					if ((this.unitScope = parsedUnit.scope)  != null) {
 						try {
 							this.lookupEnvironment.completeTypeBindings(parsedUnit, true);
-							
 							CompilationUnitDeclaration previousUnitBeingCompleted = this.lookupEnvironment.unitBeingCompleted;
 							this.lookupEnvironment.unitBeingCompleted = parsedUnit;
 							parsedUnit.scope.faultInTypes();
@@ -1102,6 +1100,30 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 		}
 	}
 
+	private void acceptPackageVisibilityStatements(PackageVisibilityStatement[] pvs, Scope scope) {
+		if (pvs != null) {
+			for (PackageVisibilityStatement pv : pvs) {
+				if (pv.pkgRef instanceof SelectionOnPackageVisibilityReference) {
+					this.noProposal = false;
+					this.requestor.acceptPackage(CharOperation.concatWith(((SelectionOnPackageVisibilityReference) pv.pkgRef).tokens, '.'));
+				}
+				if (pv.targets == null || pv.targets.length == 0) continue;
+				for (ModuleReference ref : pv.targets) {
+					acceptModuleReference(ref, scope);
+				}
+			}
+		}
+	}
+	private void acceptModuleReference(ModuleReference ref, Scope scope) {
+		try {
+			ref.resolve(scope);
+		} catch (SelectionNodeFound e) {
+			if (e.binding != null) {
+				this.noProposal = false;
+				this.requestor.acceptModule(ref.moduleName, e.binding.computeUniqueKey(), ref.sourceStart, ref.sourceEnd);
+			}
+		}
+	}
 	private void selectMemberTypeFromImport(CompilationUnitDeclaration parsedUnit, char[] lastToken, ReferenceBinding ref, boolean staticOnly) {
 		int fieldLength = lastToken.length;
 		ReferenceBinding[] memberTypes = ref.memberTypes();
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnExportReference.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnExportReference.java
deleted file mode 100644
index b1ab981..0000000
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnExportReference.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *
- *******************************************************************************/
-package org.eclipse.jdt.internal.codeassist.select;
-
-import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.ast.ImportReference;
-
-/*
- * Selection node build by the parser in any case it was intending to
- * reduce an export reference containing the assist identifier.
- * e.g.
- *
- *	module myModule {
- *  exports packageo[cursor];
- *  }
- *
- *	module myModule {
- *	---> <SelectionOnExport:packageo>
- *  }
- *
- */ 
-public class SelectionOnExportReference extends ImportReference {
-
-	public SelectionOnExportReference(char[][] tokens, long[] positions) {
-		super(tokens, positions, false, 0);
-	}
-
-	public StringBuffer print(int indent, StringBuffer output) {
-
-		printIndent(indent, output).append("<SelectOnExport:"); //$NON-NLS-1$
-		output.append(new String(CharOperation.concatWith(this.tokens, '.')));
-		return output.append('>');
-	}
-}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnPackageVisibilityReference.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnPackageVisibilityReference.java
new file mode 100644
index 0000000..75a980f
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionOnPackageVisibilityReference.java
@@ -0,0 +1,47 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.select;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ImportReference;
+
+/*
+ * Selection node build by the parser in any case it was intending to
+ * reduce an export reference containing the assist identifier.
+ * e.g.
+ *
+ *	module myModule {
+ *  exports packageo[cursor];
+ *  }
+ *
+ *	module myModule {
+ *	---> <SelectionOnExport:packageo>
+ *  }
+ *
+ */
+public class SelectionOnPackageVisibilityReference extends ImportReference {
+
+	public SelectionOnPackageVisibilityReference(char[][] tokens, long[] positions) {
+		super(tokens, positions, false, 0);
+	}
+
+	public StringBuffer print(int indent, StringBuffer output) {
+
+		printIndent(indent, output).append("<SelectOnPackageVisibility:"); //$NON-NLS-1$
+		output.append(new String(CharOperation.concatWith(this.tokens, '.')));
+		return output.append('>');
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
index dedc77e..4f7d270 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/select/SelectionParser.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -1261,7 +1265,7 @@ protected SelectionParser createSnapShotParser() {
 	return new SelectionParser(this.problemReporter);
 }
 public ImportReference createAssistPackageVisibilityReference(char[][] tokens, long[] positions){
-	return new SelectionOnExportReference(tokens, positions);
+	return new SelectionOnPackageVisibilityReference(tokens, positions);
 }
 public ImportReference createAssistImportReference(char[][] tokens, long[] positions, int mod){
 	return new SelectionOnImportReference(tokens, positions, mod);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ProvidesStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ProvidesStatement.java
index eee06f1..17835e6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ProvidesStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ProvidesStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -108,9 +108,9 @@ public class ProvidesStatement extends ModuleStatement {
 		printIndent(indent, output);
 		output.append("provides "); //$NON-NLS-1$
 		this.serviceInterface.print(0, output);
-		output.append("\n"); //$NON-NLS-1$
-		printIndent(indent + 1, output);
-		output.append("with "); //$NON-NLS-1$
+		//output.append(" "); //$NON-NLS-1$
+		//printIndent(indent + 1, output);
+		output.append(" with "); //$NON-NLS-1$
 		for (int i = 0; i < this.implementations.length; i++) {
 			this.implementations[i].print(0, output);
 			if (i < this.implementations.length - 1)
