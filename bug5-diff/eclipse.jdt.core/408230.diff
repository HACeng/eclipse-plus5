commit a0893fa670a9452a3bb55e34d39061d0e31c358a
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Mon Nov 25 16:03:36 2013 +0530

    Fixed Bug 408230 - [1.8][hovering] NPE on hovering over a type inferred
    parameter in lambda expression

1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/SelectionTest.java
655	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
71	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
19	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
7	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
16	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
124	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLambdaExpression.java
19	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLocalVariable.java
10	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredStatement.java
6	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/SelectionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/SelectionTest.java
index a11f6ac..b74bfe8 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/SelectionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/SelectionTest.java
@@ -2449,7 +2449,7 @@ public void test55() {
 		testName);
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=291040
-public void test56() {
+public void _test56() {
 
 	String str =
 			"class X {\n" +
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
index e62e8dc..ff68861 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests18.java
@@ -17,6 +17,8 @@ package org.eclipse.jdt.core.tests.model;
 
 import junit.framework.Test;
 
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.jdt.core.ICodeAssist;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.JavaModelException;
@@ -693,4 +695,657 @@ public void test0023() throws JavaModelException {
 		elements
 	);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230, [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+public void test0024() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	int foo(int a);\n" +
+			"}\n" +
+			"public class X {	\n" +
+			"	void foo() {\n" +
+			"		I i = (xyz) -> {\n" +
+			"			return xyz;\n" +
+			"		};\n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "xyz";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"xyz [in foo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		elements
+	);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230, [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+public void test0025() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	int foo(int a);\n" +
+			"}\n" +
+			"public class X {	\n" +
+			"	void foo() {\n" +
+			"		I i = (abc) -> abc++; \n" +
+			"	}\n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "abc";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"abc [in foo() [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		elements
+	);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230, [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+public void test0026() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"	int foo(int a);\n" +
+			"}\n" +
+			"public class X {	\n" +
+			"	I i = (abc) -> abc++; \n" +
+			"}\n");
+
+	String str = this.wc.getSource();
+	String selection = "abc";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"abc [in i [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		elements
+	);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230, [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+public void test0027() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"    I doit(I xyz);\n" +
+			"}\n" +
+			"public class X { \n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = (pqr) -> {\n" +
+			"			return (xyz) -> {\n" +
+			"				return (abc) -> abc; \n" +
+			"			};\n" +
+			"		};\n" +
+			"	}\n" +
+			"}\n");
+	String str = this.wc.getSource();
+	String selection = "abc";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"abc [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		elements
+	);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230, [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+public void test0028() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"    I doit(I xyz);\n" +
+			"}\n" +
+			"public class X { \n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = (pqr) -> {\n" +
+			"			return (xyz) -> {\n" +
+			"				return (abc) -> xyz; \n" +
+			"			};\n" +
+			"		};\n" +
+			"	}\n" +
+			"}\n");
+	String str = this.wc.getSource();
+	String selection = "xyz";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"xyz [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		elements
+	);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230, [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+public void test0029() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"    I doit(I xyz);\n" +
+			"}\n" +
+			"public class X { \n" +
+			"	public static void main(String[] args) {\n" +
+			"		I i = (pqr) -> {\n" +
+			"			return (xyz) -> {\n" +
+			"				return (abc) -> args; \n" +
+			"			};\n" +
+			"		};\n" +
+			"	}\n" +
+			"}\n");
+	String str = this.wc.getSource();
+	String selection = "args";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"args [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		elements
+	);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230, [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+public void test0030() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"    I doit(I xyz);\n" +
+			"}\n" +
+			"public class X { \n" +
+			"	X fx = new X((pqr) -> {\n" +
+			"		return (zyx) -> {\n" +
+			"			return (abc) -> zyx; \n" +
+			"		};\n" +
+			"	});\n" +
+			"	X(I i) {\n" +
+			"	}\n" +
+			"	void foo(X x) {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		X x = null;\n" +
+			"		x = new X((pqr) -> {\n" +
+			"			return (xyz) -> {\n" +
+			"				return (abc) -> xyz; \n" +
+			"			};\n" +
+			"		});\n" +
+			"		System.out.println(x);\n" +
+			"	}\n" +
+			"}\n");
+	String str = this.wc.getSource();
+	String selection = "zyx";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"zyx [in fx [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		elements
+	);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230, [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+public void test0031() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"    I doit(I xyz);\n" +
+			"}\n" +
+			"public class X { \n" +
+			"	X(I i) {\n" +
+			"	}\n" +
+			"	void foo(X x) {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		X x = null;\n" +
+			"		x = new X((pqr) -> {\n" +
+			"			return (xyz) -> {\n" +
+			"				return (abc) -> xyz; \n" +
+			"			};\n" +
+			"		});\n" +
+			"		System.out.println(x);\n" +
+			"	}\n" +
+			"}\n");
+	String str = this.wc.getSource();
+	String selection = "xyz";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"xyz [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		elements
+	);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230, [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+public void test0032() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"    I doit(I xyz);\n" +
+			"}\n" +
+			"public class X { \n" +
+			"	X fx = new X((pqr) -> {\n" +
+			"		return (xyz) -> {\n" +
+			"			return (abc) -> xyz; \n" +
+			"		};\n" +
+			"	});\n" +
+			"	X(I i) {\n" +
+			"	}\n" +
+			"	void foo(X x) {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		X x = null;\n" +
+			"		I i = args != null ? (mno) -> mno : (def) -> (hij) -> {\n" +
+			"			return hij;\n" +
+			"		};\n" +
+			"	}\n" +
+			"}\n");
+	String str = this.wc.getSource();
+	String selection = "hij";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"hij [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		elements
+	);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230, [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+public void test0033() throws JavaModelException {
+	this.wc = getWorkingCopy(
+			"/Resolve/src/X.java",
+			"interface I {\n" +
+			"    I doit(I xyz);\n" +
+			"}\n" +
+			"public class X { \n" +
+			"	X fx = new X((pqr) -> {\n" +
+			"		return (xyz) -> {\n" +
+			"			return (abc) -> xyz; \n" +
+			"		};\n" +
+			"	});\n" +
+			"	X(I i) {\n" +
+			"	}\n" +
+			"	void foo(X x) {}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		X x = null;\n" +
+			"		I i;\n" +
+			"       i = args != null ? (mno) -> mno : (def) -> (hij) -> {\n" +
+			"			return hij;\n" +
+			"		};\n" +
+			"	}\n" +
+			"}\n");
+	String str = this.wc.getSource();
+	String selection = "hij";
+	int start = str.lastIndexOf(selection);
+	int length = selection.length();
+
+	IJavaElement[] elements = this.wc.codeSelect(start, length);
+	assertElementsEqual(
+		"Unexpected elements",
+		"hij [in main(String[]) [in X [in [Working copy] X.java [in <default> [in src [in Resolve]]]]]]",
+		elements
+	);
+}
+//Bug 408230 - [1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=408230
+public void testBug408230a() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				"  FI i1 = (a, barg) -> a+barg;\n" +
+				"}\n" +
+				"interface FI { int f1(int a, int b); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "barg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230b() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				"  void foo() {\n" +
+				"	FI i2 = (a, barg) -> { return a+barg; };\n" +
+				"  }\n" +
+				"}\n" +
+				"interface FI { int f1(int a, int b); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "barg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230c() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				"  void foo() {\n" +
+				"	FI i2 = (a, barg) -> { int x = 2; while (x < 2) { x++; } return a+barg; };\n" +
+				"  }\n" +
+				"}\n" +
+				"interface FI { int f1(int a, int b); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "barg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230d() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				"  FI i1 = (barg) -> ++barg;\n" +
+				"}\n" +
+				"interface FI { int f1(int b); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "barg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230e() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				"  FI i1 = (aarg) -> { return aarg++;};\n" +
+				"}\n" +
+				"interface FI { int f1(int a); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "aarg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230f() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				"  FI i1 = (aarg) -> {  int x = aarg; return aarg++;};\n" +
+				"}\n" +
+				"interface FI { int f1(int a); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "aarg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230g() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				" public void boo(FI fi) {}\n" +
+				"  void foo() {\n" +
+				"	boo((aarg) -> aarg++);\n" +
+				"  }\n" +
+				"}\n" +
+				"interface FI { int f1(int a); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "aarg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230h() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				" public void boo(FI fi) {}\n" +
+				"  void foo() {\n" +
+				"	boo((aarg) -> {int b = 10; return aarg++;});\n" +
+				"  }\n" +
+				"}\n" +
+				"interface FI { int f1(int a); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "aarg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230i() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				" public void boo(FI fi) {}\n" +
+				"  void foo() {\n" +
+				"	boo((aarg, x) -> x + aarg++);\n" +
+				"  }\n" +
+				"}\n" +
+				"interface FI { int f1(int a, int b); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "aarg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230j() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				" public void boo(FI fi) {}\n" +
+				"  void foo() {\n" +
+				"	boo((aarg, x) -> {int b = 10; return x + aarg++;});\n" +
+				"  }\n" +
+				"}\n" +
+				"interface FI { int f1(int a, int b); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "aarg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230k() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				" public void boo(int x, int y, FI fi) {}\n" +
+				"  void foo() {\n" +
+				"	boo(2, 4, (aarg) -> aarg++);\n" +
+				"  }\n" +
+				"}\n" +
+				"interface FI { int f1(int a); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "aarg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230l() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				" public void boo(int x, FI fi) {}\n" +
+				"  void foo() {\n" +
+				"	boo(2, (aarg) -> {int b = 10; return aarg++;});\n" +
+				"  }\n" +
+				"}\n" +
+				"interface FI { int f1(int a); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "aarg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230m() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				" public void boo(int x, int y, FI fi) {}\n" +
+				"  void foo() {\n" +
+				"	boo(2, 5+6, (aarg, x) -> x + aarg++);\n" +
+				"  }\n" +
+				"}\n" +
+				"interface FI { int f1(int a, int b); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "aarg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
+public void testBug408230n() throws CoreException {
+	try {
+		createJavaProject("P", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.8");
+		String source = "package p;\n" +
+				"public class X {\n" +
+				" public void boo(int x, FI fi) {}\n" +
+				"  void foo() {\n" +
+				"	boo(2, (aarg, x) -> {int b = 10; return x + aarg++;});\n" +
+				"  }\n" +
+				"}\n" +
+				"interface FI { int f1(int a, int b); }\n";
+		createFolder("/P/src/p");
+		createFile(
+			"/P/src/p/X.java",
+			source
+		);
+		waitForAutoBuild();
+		
+		ICompilationUnit unit = getCompilationUnit("/P/src/p/X.java"); 
+		String selectString = "aarg";
+		IJavaElement [] variable = ((ICodeAssist) unit).codeSelect(source.lastIndexOf(selectString), selectString.length());
+		assertEquals(1, variable.length);
+	} finally {
+		deleteProject("P");
+	}
+}
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
index 1c2c24c..165c547 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
@@ -164,11 +164,9 @@ public RecoveredElement buildInitialRecoveryState(){
 
 	for(int i = 0; i <= this.astPtr; i++){
 		ASTNode node = this.astStack[i];
-
 		if(node instanceof ForeachStatement && ((ForeachStatement)node).action == null) {
 			node = ((ForeachStatement)node).elementVariable;
 		}
-
 		/* check for intermediate block creation, so recovery can properly close them afterwards */
 		int nodeStart = node.sourceStart;
 		for (int j = blockIndex; j <= this.realBlockPtr; j++){
@@ -193,6 +191,7 @@ public RecoveredElement buildInitialRecoveryState(){
 			}
 			blockIndex = j+1; // shift the index to the new block
 		}
+		
 		if (node instanceof LocalDeclaration){
 			LocalDeclaration local = (LocalDeclaration) node;
 			if (local.declarationSourceEnd == 0){
@@ -256,6 +255,12 @@ public RecoveredElement buildInitialRecoveryState(){
 			}
 			continue;
 		}
+		if (node instanceof LambdaExpression) {
+			LambdaExpression lambda = (LambdaExpression) node;
+			element = element.add(lambda, 0);
+			this.lastCheckPoint = lambda.sourceEnd + 1;
+			continue;
+		}
 		if (node instanceof ImportReference){
 			ImportReference importRef = (ImportReference) node;
 			element = element.add(importRef, 0);
@@ -385,6 +390,69 @@ protected void consumeInterfaceHeader() {
 	super.consumeInterfaceHeader();
 	pushOnElementStack(K_TYPE_DELIMITER);
 }
+
+protected void consumeLambdaExpression() {
+	// LambdaExpression ::= LambdaHeader LambdaBody // Synthetic/fake production with a synthetic non-terminal for code assist.
+	this.astLengthPtr--; 	// pop length for LambdaBody (always 1)
+	Statement body = (Statement) this.astStack[this.astPtr--];
+	if (body instanceof Block) {
+		this.nestedType--; 	// matching NestedType in "LambdaBody ::= NestedType NestedMethod  '{' BlockStatementsopt '}'"
+		this.intPtr--; 		// position after '{' pushed during consumeNestedMethod()
+		if (this.options.ignoreMethodBodies) {
+			body = new Block(0);
+		}
+	}
+	
+	LambdaExpression lexp = (LambdaExpression) this.astStack[this.astPtr--];
+	this.astLengthPtr--;
+	lexp.body = body;
+	lexp.sourceEnd = body.sourceEnd;
+	
+	if (body instanceof Expression) {
+		Expression expression = (Expression) body;
+		expression.statementEnd = body.sourceEnd;
+	}
+	if (this.currentElement != null) {
+		if (this.currentElement.parseTree() == lexp && this.currentElement.parent != null) {
+			this.currentElement = this.currentElement.parent;
+		}
+		this.restartRecovery = true;
+	}
+}
+protected void consumeLambdaHeader() {
+	// LambdaHeader ::= LambdaParameters '->'|  Synthetic/fake production with a synthetic non-terminal for code assist. Body not seen yet.
+
+	Argument [] arguments = null;
+	int length = this.astLengthStack[this.astLengthPtr--];
+	this.astPtr -= length;
+	//arguments
+	if (length != 0) {
+		System.arraycopy(
+			this.astStack,
+			this.astPtr + 1,
+			arguments = new Argument[length],
+			0,
+			length);
+	}
+	for (int i = 0; i < length; i++) {
+		final Argument argument = arguments[i];
+		if (argument.isReceiver()) {
+			problemReporter().illegalThis(argument);
+		}
+		if (argument.name.length == 1 && argument.name[0] == '_')
+			problemReporter().illegalUseOfUnderscoreAsAnIdentifier(argument.sourceStart, argument.sourceEnd, true); // true == lambdaParameter
+	}
+	LambdaExpression lexp = new LambdaExpression(this.compilationUnit.compilationResult, arguments, null, true /* synthesize elided types as needed */);
+	lexp.sourceEnd = this.intStack[this.intPtr--];   // ')' position or identifier position.
+	lexp.sourceStart = this.intStack[this.intPtr--]; // '(' position or identifier position.
+	lexp.hasParentheses = (this.scanner.getSource()[lexp.sourceStart] == '(');
+	pushOnAstStack(lexp);
+	pushOnExpressionStack(lexp);
+	if (!this.parsingJava8Plus) {
+		problemReporter().lambdaExpressionsNotBelow18(lexp);
+	}
+	this.listLength = 0; // reset this.listLength after having read all parameters
+}
 protected void consumeMethodBody() {
 	super.consumeMethodBody();
 	popElement(K_METHOD_DELIMITER);
@@ -1401,6 +1469,7 @@ public void parseBlockStatements(
 		initializer.bits |= ASTNode.HasLocalType;
 	}
 }
+
 /**
  * Parse the block statements inside the given method declaration and try to complete at the
  * cursor location.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 392dba5..660162f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -76,12 +76,14 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 	private SyntheticArgumentBinding[] outerLocalVariables = NO_SYNTHETIC_ARGUMENTS;
 	private int outerLocalVariablesSlotSize = 0;
 	public boolean shouldCaptureInstance = false;
+	private boolean shouldUnelideTypes = false;
 	private static final SyntheticArgumentBinding [] NO_SYNTHETIC_ARGUMENTS = new SyntheticArgumentBinding[0];
 	
-	public LambdaExpression(CompilationResult compilationResult, Argument [] arguments, Statement body) {
+	public LambdaExpression(CompilationResult compilationResult, Argument [] arguments, Statement body, boolean shouldUnelideTypes) {
 		super(compilationResult);
 		this.arguments = arguments != null ? arguments : ASTNode.NO_ARGUMENTS;
 		this.body = body;
+		this.shouldUnelideTypes = shouldUnelideTypes;
 	}
 	
 	protected FunctionalExpression original() {
@@ -152,15 +154,23 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 
 		super.resolveType(blockScope); // compute & capture interface function descriptor in singleAbstractMethod.
 		
-		final boolean argumentsTypeElided = argumentsTypeElided();
+		boolean argumentsTypeElided = argumentsTypeElided();
 		final boolean haveDescriptor = this.descriptor != null;
 		
 		if (haveDescriptor && this.descriptor.typeVariables != Binding.NO_TYPE_VARIABLES) // already complained in kosher*
 			return null;
 		
-		if (!haveDescriptor && argumentsTypeElided) 
-			return null; // FUBAR, bail out...
-
+		if (!haveDescriptor) {
+			if (argumentsTypeElided && !this.shouldUnelideTypes)
+				return null; // FUBAR, bail out...
+			// for code assist ONLY, keep the sluice gate shut on bogus errors otherwise.
+			argumentsTypeElided = false;
+			int length = this.arguments != null ? this.arguments.length : 0;
+			for (int i = 0; i < length; i++) {
+				this.arguments[i].type = new SingleTypeReference(TypeConstants.OBJECT, 0);
+			}
+		}
+		
 		this.binding = new MethodBinding(ClassFileConstants.AccPrivate | ClassFileConstants.AccSynthetic | ExtraCompilerModifiers.AccUnresolved,
 							TypeConstants.ANONYMOUS_METHOD, // will be fixed up later.
 							haveDescriptor ? this.descriptor.returnType : null, 
@@ -435,7 +445,10 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 			}
 		}
 		output.append(") -> " ); //$NON-NLS-1$
-		this.body.print(this.body instanceof Block ? tab : 0, output);
+		if (this.body != null)
+			this.body.print(this.body instanceof Block ? tab : 0, output);
+		else 
+			output.append("<@incubator>"); //$NON-NLS-1$
 		return output.append(suffix);
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index dbfbc8e..270fe64 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -1006,7 +1006,7 @@ public org.eclipse.jdt.internal.compiler.ReadManager readManager;
 private boolean shouldDeferRecovery = false; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=291040
 private int valueLambdaNestDepth = -1;
 private int stateStackLengthStack[] = new int[0];
-private boolean parsingJava8Plus;
+protected boolean parsingJava8Plus;
 protected int unstackedAct = ERROR_ACTION;
 private boolean haltOnSyntaxError = false;
 private boolean tolerateDefaultClassMethods = false;
@@ -7873,7 +7873,7 @@ protected void consumeLambdaExpression() {
 		if (argument.name.length == 1 && argument.name[0] == '_')
 			problemReporter().illegalUseOfUnderscoreAsAnIdentifier(argument.sourceStart, argument.sourceEnd, true); // true == lambdaParameter
 	}
-	LambdaExpression lexp = new LambdaExpression(this.compilationUnit.compilationResult, arguments, body);
+	LambdaExpression lexp = new LambdaExpression(this.compilationUnit.compilationResult, arguments, body, false);
 	this.intPtr--;  // ')' position, discard for now.
 	lexp.sourceStart = this.intStack[this.intPtr--]; // '(' position or identifier position.
 	lexp.sourceEnd = body.sourceEnd;
@@ -8123,7 +8123,7 @@ protected void consumeReferenceExpressionGenericTypeForm() {
 	}
 }
 protected void consumeEnterInstanceCreationArgumentList() {
-	this.shouldDeferRecovery = true;
+	this.shouldDeferRecovery = false; // See https://bugs.eclipse.org/bugs/show_bug.cgi?id=417935#c2
 }
 protected void consumeSimpleAssertStatement() {
 	// AssertStatement ::= 'assert' Expression ';'
@@ -8707,6 +8707,7 @@ protected void consumeToken(int type) {
 			this.processingLambdaParameterList = true;
 			break;
 		case TokenNameARROW:
+			consumeLambdaHeader();
 			this.processingLambdaParameterList = false;
 			break;
 		case TokenNameIdentifier :
@@ -9033,6 +9034,9 @@ protected void consumeToken(int type) {
 			//  case TokenNameGREATER  :
 	}
 }
+protected void consumeLambdaHeader() {
+	// Overridden in assist parser.
+}
 protected void consumeTypeArgument() {
 	pushOnGenericsStack(getTypeReference(this.intStack[this.intPtr--]));
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
index 1d74fe8..37fce6f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredBlock.java
@@ -1,10 +1,13 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -19,6 +22,7 @@ import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Block;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Statement;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
@@ -57,6 +61,14 @@ public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bra
 	return super.add(methodDeclaration, bracketBalanceValue);
 }
 /*
+ * Record a Lambda declaration
+ */
+public RecoveredElement add(LambdaExpression expression, int bracketBalanceValue) {
+	RecoveredLambdaExpression element = new RecoveredLambdaExpression(expression, this, bracketBalanceValue);
+	attach(element);
+	return element;
+}
+/*
  * Record a nested block declaration
  */
 public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValue) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
index 4833bf7..68b9688 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
@@ -1,23 +1,29 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- *
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
+
 package org.eclipse.jdt.internal.compiler.parser;
 
 /**
  * Internal structure for parsing recovery
  */
-import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Block;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;
+import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Statement;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
@@ -99,6 +105,13 @@ public RecoveredElement add(LocalDeclaration localDeclaration, int bracketBalanc
 	this.updateSourceEndIfNecessary(previousAvailableLineEnd(localDeclaration.declarationSourceStart - 1));
 	return this.parent.add(localDeclaration, bracketBalanceValue);
 }
+
+/*
+ * Record a LambdaExpression: Only can occur inside a block. Note: Field initializers are wrapped into a block.
+ */
+public RecoveredElement add(LambdaExpression expression, int bracketBalanceValue) {
+	return this;
+}
 /*
  * Record a statement
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLambdaExpression.java
new file mode 100644
index 0000000..2614be8
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLambdaExpression.java
@@ -0,0 +1,124 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.internal.compiler.parser;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.Block;
+import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
+import org.eclipse.jdt.internal.compiler.ast.Statement;
+
+public class RecoveredLambdaExpression extends RecoveredBlock {
+
+	private LambdaExpression expression;
+	private boolean haveBlockBody = false;
+	private boolean haveExpressionBody = false;
+	private RecoveredStatement bodyExpression;
+	
+	public RecoveredLambdaExpression(LambdaExpression expression, RecoveredElement parent, int bracketBalance){
+		super(new Block(0), parent, bracketBalance); // don't have a block yet. May never have, in that event will course correct.
+		this.expression = expression;
+		this.expression.body = this.blockDeclaration;
+	}
+	
+	/*
+	 * Record a nested block declaration
+	 */
+	public RecoveredElement add(Block block, int bracketBalanceValue) {
+		if (!this.haveBlockBody && !this.haveExpressionBody) {
+			this.haveBlockBody = true;
+			this.haveExpressionBody = false;
+			this.blockDeclaration.sourceStart = block.sourceStart;
+			this.blockDeclaration.sourceEnd = block.sourceEnd;
+			return this; 
+		}
+		return super.add(block, bracketBalanceValue);
+	}
+
+	/*
+	 * Record a nested block declaration
+	 */
+	public RecoveredElement add(LambdaExpression lambda, int bracketBalanceValue) {
+		if (!this.haveBlockBody && !this.haveExpressionBody) {
+			this.haveBlockBody = false;
+			this.haveExpressionBody = true;
+			this.bodyExpression = new RecoveredLambdaExpression(lambda, this, bracketBalanceValue);
+			this.expression.body = lambda;
+			return this.bodyExpression;
+		}
+		return super.add(lambda, bracketBalanceValue);
+	}
+	
+	/*
+	 * Record a statement declaration
+	 */
+	public RecoveredElement add(Statement stmt, int bracketBalanceValue) {
+		return this.add(stmt, bracketBalanceValue, false);
+	}
+
+	/*
+	 * Record a statement declaration
+	 */
+	public RecoveredElement add(Statement stmt, int bracketBalanceValue, boolean delegatedByParent) {
+		if (!this.haveBlockBody && !this.haveExpressionBody) {
+			this.haveBlockBody = false;
+			this.haveExpressionBody = true;
+			this.bodyExpression = new RecoveredStatement(stmt, this, bracketBalanceValue);
+			this.expression.body = stmt;
+			return this.bodyExpression;
+		}
+		return super.add(stmt, bracketBalanceValue, delegatedByParent);
+	}
+	
+	/*
+	 * Answer the associated parsed structure
+	 */
+	public ASTNode parseTree(){
+		return updatedLambdaExpression(0, new HashSet());
+	}
+
+	public LambdaExpression updatedLambdaExpression(int depth, Set knownTypes) {
+		this.expression.body = this.haveBlockBody ? super.updatedStatement(depth, knownTypes) : this.bodyExpression.updatedStatement(depth, knownTypes);
+		return this.expression;
+	}
+	/*
+	 * Rebuild a statement from the nested structure which is in scope
+	 */
+	public Statement updatedStatement(int depth, Set knownTypes){
+		return updatedLambdaExpression(depth, knownTypes);
+	}
+	/*
+	 * Final update the corresponding parse node
+	 */
+	public void updateParseTree(){
+		updatedLambdaExpression(0, new HashSet());
+	}
+	/*
+	 * Rebuild a flattened block from the nested structure which is in scope
+	 */
+	public Statement updateStatement(int depth, Set knownTypes){
+		return updatedLambdaExpression(depth, knownTypes);
+	}
+	
+	public String toString(int tab) {
+		StringBuffer result = new StringBuffer(tabString(tab));
+		result.append("Recovered Lambda Expression:\n"); //$NON-NLS-1$
+		this.expression.print(tab + 1, result);
+		return result.toString();
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLocalVariable.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLocalVariable.java
index 98dba36..57bae05 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLocalVariable.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredLocalVariable.java
@@ -21,6 +21,7 @@ import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Statement;
 
@@ -28,7 +29,7 @@ public class RecoveredLocalVariable extends RecoveredStatement {
 
 	public RecoveredAnnotation[] annotations;
 	public int annotationCount;
-
+	private RecoveredLambdaExpression initializer;
 	public int modifiers;
 	public int modifiersStart;
 
@@ -54,6 +55,21 @@ public RecoveredElement add(Statement stmt, int bracketBalanceValue) {
 		return this;
 	}
 }
+/*
+ * Record an expression statement if local variable is expecting an initialization expression.
+ */
+public RecoveredElement add(LambdaExpression expression, int bracketBalanceValue) {
+
+	if (this.alreadyCompletedLocalInitialization) {
+		return this;
+	} else {
+		this.alreadyCompletedLocalInitialization = true;
+		this.localDeclaration.initialization = expression;
+		this.localDeclaration.declarationSourceEnd = expression.sourceEnd;
+		this.localDeclaration.declarationEnd = expression.sourceEnd;
+		return this.initializer = new RecoveredLambdaExpression(expression, this, bracketBalanceValue);
+	}
+}
 public void attach(RecoveredAnnotation[] annots, int annotCount, int mods, int modsSourceStart) {
 	if (annotCount > 0) {
 		Annotation[] existingAnnotations = this.localDeclaration.annotations;
@@ -117,6 +133,8 @@ public Statement updatedStatement(int depth, Set knownTypes){
 			this.localDeclaration.declarationSourceStart = start;
 		}
 	}
+	if (this.initializer != null)
+		this.initializer.updateParseTree();
 	return this.localDeclaration;
 }
 /*
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredStatement.java
index 5d3f653..326d985 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredStatement.java
@@ -17,19 +17,28 @@ import java.util.HashSet;
 import java.util.Set;
 
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
 import org.eclipse.jdt.internal.compiler.ast.Statement;
 
 public class RecoveredStatement extends RecoveredElement {
 
 	public Statement statement;
+	public RecoveredLambdaExpression subExpression;
+	
 public RecoveredStatement(Statement statement, RecoveredElement parent, int bracketBalance){
 	super(parent, bracketBalance);
 	this.statement = statement;
 }
+
+public RecoveredElement add(LambdaExpression expression, int bracketBalanceValue) {
+	return this.subExpression = new RecoveredLambdaExpression(expression, this, bracketBalanceValue);
+}
 /*
  * Answer the associated parsed structure
  */
-public ASTNode parseTree(){
+public ASTNode parseTree() {
+	if (this.subExpression != null)
+		this.subExpression.updateParseTree();
 	return this.statement;
 }
 /*
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
index 7accbff..1ab6fa7 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SelectionRequestor.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -451,7 +455,7 @@ public void acceptLocalVariable(LocalVariableBinding binding) {
 				local.declarationSourceEnd,
 				local.sourceStart,
 				local.sourceEnd,
-				Util.typeSignature(local.type),
+				local.type == null ? Signature.createTypeSignature(local.binding.type.readableName(), false) : Util.typeSignature(local.type),
 				local.annotations,
 				local.modifiers,
 				local.getKind() == AbstractVariableDeclaration.PARAMETER);
