commit 1155b311a647fc5f126edd0c5e6b818f225baee0
Author: Andrew Clement <andrew.clement@gmail.com>
Date:   Wed May 15 09:49:20 2013 +0530

    Cleanups and bug fixes preparatory for Bug 383624 - [1.8][compiler]
    Revive code generation support for type annotations

13	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
21	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
1	51	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index d1906e1..0f40e66 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -14,6 +14,8 @@
  *     Stephan Herrmann - Contributions for
  *								bug 342671 - ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -40,6 +42,17 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 
 		super(tokens, dim, positions);
 		this.typeArguments = typeArguments;
+		annotationSearch: for (int i = 0, max = typeArguments.length; i < max; i++) {
+			TypeReference[] typeArgumentsOnTypeComponent = typeArguments[i];
+			if (typeArgumentsOnTypeComponent != null) {
+				for (int j = 0, max2 = typeArgumentsOnTypeComponent.length; j < max2; j++) {
+					if ((typeArgumentsOnTypeComponent[j].bits & ASTNode.HasTypeAnnotations) != 0) {
+						this.bits |= ASTNode.HasTypeAnnotations;
+						break annotationSearch;
+					}
+				}
+			}
+		}
 	}
 	public ParameterizedQualifiedTypeReference(char[][] tokens, TypeReference[][] typeArguments, int dim, Annotation[][] annotationsOnDimensions, long[] positions) {
 		this(tokens, typeArguments, dim, positions);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
index 82a06ef..b3b26f2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,6 +14,8 @@
  *     Stephan Herrmann - Contributions for
  *								bug 342671 - ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -35,6 +37,12 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 		super(name, dim, pos);
 		this.originalSourceEnd = this.sourceEnd;
 		this.typeArguments = typeArguments;
+		for (int i = 0, max = typeArguments.length; i < max; i++) {
+			if ((typeArguments[i].bits & ASTNode.HasTypeAnnotations) != 0) {
+				this.bits |= ASTNode.HasTypeAnnotations;
+				break;
+			}
+		}
 	}
 	public ParameterizedSingleTypeReference(char[] name, TypeReference[] typeArguments, int dim, Annotation[][] annotationsOnDimensions, long pos) {
 		this(name, typeArguments, dim, pos);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index baf23ff..0fd892c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -24,7 +24,8 @@
  *							bug 399695 - [1.8][compiler] [1.8][compiler] migrate parser to other syntax for default methods
  *							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
  *									bug 393192 - Incomplete type hierarchy with > 10 annotations
- *
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.parser;
 
@@ -1818,11 +1819,13 @@ protected void consumeArrayCreationExpressionWithInitializer() {
 		length);
 	Annotation[][] annotationsOnDimensions = getAnnotationsOnDimensions(length);
 	arrayAllocation.annotationsOnDimensions = annotationsOnDimensions;
+
+	arrayAllocation.type = getTypeReference(0);
+	arrayAllocation.type.bits |= ASTNode.IgnoreRawTypeCheck; // no need to worry about raw type usage
 	if (annotationsOnDimensions != null) {
 		arrayAllocation.bits |= ASTNode.HasTypeAnnotations;
+		arrayAllocation.type.bits |= ASTNode.HasTypeAnnotations;
 	}
-	arrayAllocation.type = getTypeReference(0);
-	arrayAllocation.type.bits |= ASTNode.IgnoreRawTypeCheck; // no need to worry about raw type usage
 
 	arrayAllocation.sourceStart = this.intStack[this.intPtr--];
 	if (arrayAllocation.initializer == null) {
@@ -1848,11 +1851,12 @@ protected void consumeArrayCreationExpressionWithoutInitializer() {
 		length);
 	Annotation[][] annotationsOnDimensions = getAnnotationsOnDimensions(length);
 	arrayAllocation.annotationsOnDimensions = annotationsOnDimensions;
+	arrayAllocation.type = getTypeReference(0);
+	arrayAllocation.type.bits |= ASTNode.IgnoreRawTypeCheck; // no need to worry about raw type usage
 	if (annotationsOnDimensions != null) {
 		arrayAllocation.bits |= ASTNode.HasTypeAnnotations;
+		arrayAllocation.type.bits |= ASTNode.HasTypeAnnotations;
 	}
-	arrayAllocation.type = getTypeReference(0);
-	arrayAllocation.type.bits |= ASTNode.IgnoreRawTypeCheck; // no need to worry about raw type usage
 	arrayAllocation.sourceStart = this.intStack[this.intPtr--];
 	if (arrayAllocation.initializer == null) {
 		arrayAllocation.sourceEnd = this.endStatementPosition;
@@ -5180,6 +5184,7 @@ protected void consumeMethodHeaderRightParen() {
 				if (type.annotations == null) {
 					type.bits |= ASTNode.HasTypeAnnotations;
 					type.annotations = new Annotation[type.getAnnotatableLevels()][];
+					md.bits |= ASTNode.HasTypeAnnotations;
 				}
 				type.annotations[0] = annotations;
 				int annotationSourceStart = annotations[0].sourceStart;
@@ -5187,6 +5192,7 @@ protected void consumeMethodHeaderRightParen() {
 					type.sourceStart = annotationSourceStart;
 				arg.annotations = null;
 			}
+			md.bits |= (arg.type.bits & ASTNode.HasTypeAnnotations);
 		} else {
 			System.arraycopy(
 					this.astStack,
@@ -5194,6 +5200,12 @@ protected void consumeMethodHeaderRightParen() {
 					md.arguments = new Argument[length],
 					0,
 					length);
+			for (int i = 0, max = md.arguments.length; i < max; i++) {
+				if ((md.arguments[i].bits & ASTNode.HasTypeAnnotations) != 0) {
+					md.bits |= ASTNode.HasTypeAnnotations;
+					break;
+				}
+			}
 		}
 	}
 	md.bodyStart = this.rParenPos+1;
@@ -10000,7 +10012,7 @@ protected Expression getTypeReference(Expression exp) {
 	exp.bits |= Binding.TYPE;
 	return exp;
 }
-protected void annotateTypeReference(TypeReference ref) {
+protected void annotateTypeReference(Wildcard ref) {
 	int length;
 	if ((length = this.typeAnnotationLengthStack[this.typeAnnotationLengthPtr--]) != 0) {
 		if (ref.annotations == null)
@@ -10016,6 +10028,9 @@ protected void annotateTypeReference(TypeReference ref) {
 		}
 		ref.bits |= ASTNode.HasTypeAnnotations;
 	}
+	if (ref.bound != null) {
+		ref.bits |= (ref.bound.bits & ASTNode.HasTypeAnnotations);
+	}
 }
 protected TypeReference getTypeReference(int dim) {
 	/* build a Reference on a variable that may be qualified or not
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
index cfffccf..28371d6 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTRecoveryPropagator.java
@@ -1,14 +1,10 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2012 IBM Corporation and others.
+ * Copyright (c) 2006, 2008 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -130,52 +126,6 @@ class ASTRecoveryPropagator extends DefaultASTVisitor {
 	}
 
 	public void endVisit(Block node) {
-		int level = node.getAST().apiLevel;
-		
-		List statements = node.statements();
-		next : for (int i = 0, max = statements.size(); i < max; i++) {
-			ASTNode statement = (ASTNode) statements.get(i);
-			if (statement.getNodeType() == ASTNode.VARIABLE_DECLARATION_STATEMENT) {
-				VariableDeclarationStatement variableDeclarationStatement =  (VariableDeclarationStatement) statement;
-				
-				if (level == AST.JLS2_INTERNAL) {
-					if (variableDeclarationStatement.getModifiers() != Modifier.NONE) {
-						continue next;
-					}
-				} else if (level >= AST.JLS3_INTERNAL) {
-					if (variableDeclarationStatement.modifiers().size() != 0) {
-						continue next;
-					}
-				}
-				
-				Type type = variableDeclarationStatement.getType();
-				if (type.getNodeType() != ASTNode.SIMPLE_TYPE) {
-					continue next;
-				}
-				
-				List fragments = variableDeclarationStatement.fragments();
-				if (fragments.size() == 1) {
-					VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);
-					
-					SimpleName simpleName = fragment.getName();
-					if (CharOperation.equals(RecoveryScanner.FAKE_IDENTIFIER, simpleName.getIdentifier().toCharArray())) {
-						SimpleType simpleType = (SimpleType) type;
-						Name name = simpleType.getName();
-						name.setParent(null, null);
-						name.setFlags(name.getFlags() | ASTNode.RECOVERED);
-						
-						final ExpressionStatement stmt = new ExpressionStatement(name.getAST());
-						stmt.setExpression(name);
-						stmt.setSourceRange(variableDeclarationStatement.getStartPosition(), variableDeclarationStatement.getLength());
-						stmt.setFlags(stmt.getFlags() | ASTNode.RECOVERED);
-						
-						statements.add(i, stmt);
-						statements.remove(variableDeclarationStatement);
-					}
-				}
-			}
-		}
-		
 		this.blockDepth--;
 		if(this.blockDepth <= 0) {
 			flagNodeWithInsertedTokens();
commit 79c1182746ff2f44f9956aeaf2f61882a4911acb
Author: Andrew Clement <andrew.clement@gmail.com>
Date:   Tue May 28 10:33:19 2013 +0530

    Bug 383624 - [1.8][compiler] Revive code generation support for type
    annotations (from Olivier's work)

102	86	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
3731	1635	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
203	330	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
239	146	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
6	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
8	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
37	18	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
9	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
32	37	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationTargetTypeConstants.java
37	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
15	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
22	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
60	37	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
36	39	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotation.java
32	35	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotationConstants.java
11	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeAttribute.java
148	323	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
114	180	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java
13	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
13	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
index 1782c1c..d823d7b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
@@ -11,6 +11,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.parser;
 
@@ -108,19 +110,19 @@ public class TypeAnnotationSyntaxTest extends AbstractSyntaxTreeTest {
 		}
 		public boolean visit(MarkerAnnotation annotation, BlockScope scope) {
 			if (this.enclosingReference != null) {
-				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, this.primaryAnnotations, annotation, null));
+				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, this.primaryAnnotations, annotation, null, 0));
 			}
 			return false;
 		}
 		public boolean visit(SingleMemberAnnotation annotation, BlockScope scope) {
 			if (this.enclosingReference != null) {
-				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, this.primaryAnnotations, annotation, null));
+				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, this.primaryAnnotations, annotation, null, 0));
 			}
 			return false;
 		}
 		public boolean visit(NormalAnnotation annotation, BlockScope scope) {
 			if (this.enclosingReference != null) {
-				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, this.primaryAnnotations, annotation, null));
+				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, this.primaryAnnotations, annotation, null, 0));
 			}
 			return false;
 		}
@@ -133,14 +135,28 @@ public class TypeAnnotationSyntaxTest extends AbstractSyntaxTreeTest {
 				this.locations.put(key, null);
 				return;
 			}
-			StringBuffer buffer = new StringBuffer("{");
-			for (int i = 0, max = tab.length; i < max; i++) {
+			
+			StringBuffer buffer = new StringBuffer("[");
+			for (int i = 0, max = tab.length; i < max; i += 2) {
 				if (i > 0) {
-					buffer.append(',');
+					buffer.append(", ");
+				}
+				switch (tab[i]) {
+				case 0:
+					buffer.append("ARRAY");
+					break;
+				case 1:
+					buffer.append("INNER_TYPE");
+					break;
+				case 2:
+					buffer.append("WILDCARD");
+					break;
+				case 3:
+					buffer.append("TYPE_ARGUMENT(").append(tab[i+1]).append(')');
+					break;
 				}
-				buffer.append(tab[i]);
 			}
-			buffer.append('}');
+			buffer.append(']');
 			this.locations.put(key, String.valueOf(buffer));
 		}
 
@@ -1656,9 +1672,9 @@ public void test0068() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 4, locations.size());
 	assertEquals("Wrong location", null, locations.get("@E"));
-	assertEquals("Wrong location", "{0}", locations.get("@F"));
-	assertEquals("Wrong location", "{1}", locations.get("@G"));
-	assertEquals("Wrong location", "{2}", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@H"));
 }
 //check locations
 public void test0069() throws IOException {
@@ -1678,8 +1694,8 @@ public void test0069() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 3, locations.size());
 	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "{0}", locations.get("@B"));
-	assertEquals("Wrong location", "{1}", locations.get("@H"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@H"));
 }
 //check locations
 public void test0070() throws IOException {
@@ -1699,11 +1715,11 @@ public void test0070() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 6, locations.size());
 	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "{0}", locations.get("@B"));
-	assertEquals("Wrong location", "{1}", locations.get("@E"));
-	assertEquals("Wrong location", "{1,0}", locations.get("@F"));
-	assertEquals("Wrong location", "{1,1}", locations.get("@G"));
-	assertEquals("Wrong location", "{1,2}", locations.get("@H"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@E"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
 }
 //check locations
 public void test0071() throws IOException {
@@ -1723,11 +1739,11 @@ public void test0071() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 6, locations.size());
 	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "{0}", locations.get("@B"));
-	assertEquals("Wrong location", "{1}", locations.get("@C"));
-	assertEquals("Wrong location", "{1,0,2}", locations.get("@H"));
-	assertEquals("Wrong location", "{1,0}", locations.get("@E"));
-	assertEquals("Wrong location", "{1,0,1}", locations.get("@G"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@C"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@E"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
 }
 //check locations
 public void test0072() throws IOException {
@@ -1746,14 +1762,14 @@ public void test0072() throws IOException {
 	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0072", expectedUnitToString, visitor);
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 8, locations.size());
-	assertEquals("Wrong location", "{0}", locations.get("@I"));
-	assertEquals("Wrong location", "{1}", locations.get("@J"));
-	assertEquals("Wrong location", "{2}", locations.get("@A"));
-	assertEquals("Wrong location", "{2,0}", locations.get("@B"));
-	assertEquals("Wrong location", "{2,1}", locations.get("@C"));
-	assertEquals("Wrong location", "{2,1,0,2}", locations.get("@H"));
-	assertEquals("Wrong location", "{2,1,0}", locations.get("@E"));
-	assertEquals("Wrong location", "{2,1,0,1}", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@I"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@J"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@A"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@C"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
 }
 //check locations
 public void test0073() throws IOException {
@@ -1773,13 +1789,13 @@ public void test0073() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 8, locations.size());
 	assertEquals("Wrong location", null, locations.get("@I"));
-	assertEquals("Wrong location", "{1}", locations.get("@J"));
-	assertEquals("Wrong location", "{2}", locations.get("@A"));
-	assertEquals("Wrong location", "{2,0}", locations.get("@B"));
-	assertEquals("Wrong location", "{2,1}", locations.get("@C"));
-	assertEquals("Wrong location", "{2,1,0,2}", locations.get("@H"));
-	assertEquals("Wrong location", "{2,1,0}", locations.get("@E"));
-	assertEquals("Wrong location", "{2,1,0,1}", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@J"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@A"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@C"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
 }
 //check locations
 public void test0074() throws IOException {
@@ -1799,15 +1815,15 @@ public void test0074() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 10, locations.size());
 	assertEquals("Wrong location", null, locations.get("@I"));
-	assertEquals("Wrong location", "{0}", locations.get("@F"));
-	assertEquals("Wrong location", "{1}", locations.get("@J"));
-	assertEquals("Wrong location", "{2}", locations.get("@A"));
-	assertEquals("Wrong location", "{2,0}", locations.get("@C"));
-	assertEquals("Wrong location", "{2,0,0}", locations.get("@E"));
-	assertEquals("Wrong location", "{2,0,0,1}", locations.get("@G"));
-	assertEquals("Wrong location", "{2,0,0,2}", locations.get("@H"));
-	assertEquals("Wrong location", "{2,1,0}", locations.get("@D"));
-	assertEquals("Wrong location", "{2,1}", locations.get("@B"));
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@J"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@A"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@C"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), ARRAY]", locations.get("@D"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@B"));
 }
 //check locations
 public void test0075() throws IOException {
@@ -1826,16 +1842,16 @@ public void test0075() throws IOException {
 	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0075", expectedUnitToString, visitor);
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 10, locations.size());
-	assertEquals("Wrong location", "{0}", locations.get("@I"));
-	assertEquals("Wrong location", "{1}", locations.get("@F"));
-	assertEquals("Wrong location", "{2}", locations.get("@J"));
-	assertEquals("Wrong location", "{3}", locations.get("@A"));
-	assertEquals("Wrong location", "{3,0}", locations.get("@C"));
-	assertEquals("Wrong location", "{3,0,0}", locations.get("@E"));
-	assertEquals("Wrong location", "{3,0,0,1}", locations.get("@G"));
-	assertEquals("Wrong location", "{3,0,0,2}", locations.get("@H"));
-	assertEquals("Wrong location", "{3,1}", locations.get("@B"));
-	assertEquals("Wrong location", "{3,1,0,0}", locations.get("@D"));
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@I"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@J"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY]", locations.get("@A"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@C"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@B"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY]", locations.get("@D"));
 }
 //check locations
 public void test0076() throws IOException {
@@ -1855,9 +1871,9 @@ public void test0076() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 4, locations.size());
 	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "{0}", locations.get("@B"));
-	assertEquals("Wrong location", "{1}", locations.get("@C"));
-	assertEquals("Wrong location", "{1,0}", locations.get("@D"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@C"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@D"));
 }
 //check locations
 public void test0077() throws IOException {
@@ -1877,9 +1893,9 @@ public void test0077() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 4, locations.size());
 	assertEquals("Wrong location", null, locations.get("@E"));
-	assertEquals("Wrong location", "{0}", locations.get("@F"));
-	assertEquals("Wrong location", "{1}", locations.get("@G"));
-	assertEquals("Wrong location", "{2}", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@H"));
 }
 //check locations
 public void test0078() throws IOException {
@@ -1899,13 +1915,13 @@ public void test0078() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 8, locations.size());
 	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "{0}", locations.get("@B"));
-	assertEquals("Wrong location", "{0,0,2}", locations.get("@C"));
-	assertEquals("Wrong location", "{0,0}", locations.get("@D"));
-	assertEquals("Wrong location", "{0,0,0}", locations.get("@E"));
-	assertEquals("Wrong location", "{0,0,1}", locations.get("@F"));
-	assertEquals("Wrong location", "{1}", locations.get("@G"));
-	assertEquals("Wrong location", "{1,0}", locations.get("@H"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@C"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@D"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY]", locations.get("@E"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@G"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@H"));
 }
 //check locations
 public void test0079() throws IOException {
@@ -1925,13 +1941,13 @@ public void test0079() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 8, locations.size());
 	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "{0}", locations.get("@B"));
-	assertEquals("Wrong location", "{0,0,2}", locations.get("@C"));
-	assertEquals("Wrong location", "{0,0}", locations.get("@D"));
-	assertEquals("Wrong location", "{0,0,0}", locations.get("@E"));
-	assertEquals("Wrong location", "{0,0,1}", locations.get("@F"));
-	assertEquals("Wrong location", "{1}", locations.get("@G"));
-	assertEquals("Wrong location", "{1,0}", locations.get("@H"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@C"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@D"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY]", locations.get("@E"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@G"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@H"));
 }
 //check locations
 public void test0080() throws IOException {
@@ -1951,7 +1967,7 @@ public void test0080() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 2, locations.size());
 	assertEquals("Wrong location", null, locations.get("@B"));
-	assertEquals("Wrong location", "{1}", locations.get("@A"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), WILDCARD]", locations.get("@A"));
 }
 //check locations
 public void test0081() throws IOException {
@@ -1971,9 +1987,9 @@ public void test0081() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 4, locations.size());
 	assertEquals("Wrong location", null, locations.get("@E"));
-	assertEquals("Wrong location", "{0}", locations.get("@F"));
-	assertEquals("Wrong location", "{1}", locations.get("@G"));
-	assertEquals("Wrong location", "{2}", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@H"));
 }
 //check locations
 public void test0082() throws IOException {
@@ -1993,11 +2009,11 @@ public void test0082() throws IOException {
 	Map locations = visitor.getLocations();
 	assertEquals("Wrong size", 6, locations.size());
 	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "{0}", locations.get("@B"));
-	assertEquals("Wrong location", "{1}", locations.get("@E"));
-	assertEquals("Wrong location", "{1,0}", locations.get("@F"));
-	assertEquals("Wrong location", "{1,1}", locations.get("@G"));
-	assertEquals("Wrong location", "{1,2}", locations.get("@H"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@E"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
 }
 public void test0083() throws IOException {
 	String source =
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
index 0443b26..b16cc6d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2012 IBM Corporation and others.
+ * Copyright (c) 2011, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,12 +11,15 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
 import java.io.File;
-
+import java.util.Map;
 import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 
 import junit.framework.Test;
 
@@ -34,611 +37,208 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 	public TypeAnnotationTest(String testName){
 		super(testName);
 	}
-//	// superclass
-//	public void test001() throws Exception {
-//		this.runConformTest(
-//				new String[] {
-//					"Marker.java",
-//					"import java.lang.annotation.Target;\n" + 
-//					"import static java.lang.annotation.ElementType.*;\n" + 
-//					"@Target(TYPE_USE)\n" + 
-//					"@interface Marker {}",
-//					"X.java",
-//					"public class X extends @Marker Object {}",
-//				},
-//				"");
-//		String expectedOutput =
-//			"  RuntimeInvisibleTypeAnnotations: \n" + 
-//			"    #17 @Marker(\n" + 
-//			"      target type = 0x14 CLASS_EXTENDS_IMPLEMENTS\n" + 
-//			"      type index = -1\n" + 
-//			"    )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-//	// type parameter
-//	public void test002() throws Exception {
-//		this.runConformTest(
-//				new String[] {
-//					"Marker.java",
-//					"import java.lang.annotation.Target;\n" + 
-//					"import static java.lang.annotation.ElementType.*;\n" + 
-//					"@Target(TYPE_PARAMETER)\n" + 
-//					"@interface Marker {}",
-//					"X.java",
-//					"public class X<@Marker T> {}",
-//				},
-//				"");
-//		String expectedOutput =
-//			"  RuntimeInvisibleTypeAnnotations: \n" + 
-//			"    #21 @Marker(\n" + 
-//			"      target type = 0x22 CLASS_TYPE_PARAMETER\n" + 
-//			"      type parameter index = 0\n" + 
-//			"    )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-//	// superclass
-//	public void test003() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String id() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"C.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface C {\n" + 
-//				"	char value() default '-';\n" + 
-//				"}\n",
-//				"Y.java",
-//				"class Y {}\n",
-//				"X.java",
-//				"public class X extends @A(id=\"Hello, World!\") @B @C('(') Y {\n" + 
-//				"}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"  RuntimeVisibleTypeAnnotations: \n" + 
-//			"    #19 @A(\n" + 
-//			"      #20 id=\"Hello, World!\" (constant type)\n" + 
-//			"      target type = 0x14 CLASS_EXTENDS_IMPLEMENTS\n" + 
-//			"      type index = -1\n" + 
-//			"    )\n" + 
-//			"    #22 @C(\n" + 
-//			"      #23 value=\'(\' (constant type)\n" + 
-//			"      target type = 0x14 CLASS_EXTENDS_IMPLEMENTS\n" + 
-//			"      type index = -1\n" + 
-//			"    )\n" + 
-//			"  RuntimeInvisibleTypeAnnotations: \n" + 
-//			"    #17 @B(\n" + 
-//			"      target type = 0x14 CLASS_EXTENDS_IMPLEMENTS\n" + 
-//			"      type index = -1\n" + 
-//			"    )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-//	// super interfaces
-//	public void test004() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String id() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"C.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface C {\n" + 
-//				"	char value() default '-';\n" + 
-//				"}\n",
-//				"I.java",
-//				"interface I {}\n",
-//				"J.java",
-//				"interface J {}\n",
-//				"X.java",
-//				"public class X implements @A(id=\"Hello, World!\") I, @B @C('(') J {}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"  RuntimeVisibleTypeAnnotations: \n" + 
-//			"    #23 @A(\n" + 
-//			"      #24 id=\"Hello, World!\" (constant type)\n" + 
-//			"      target type = 0x14 CLASS_EXTENDS_IMPLEMENTS\n" + 
-//			"      type index = 0\n" + 
-//			"    )\n" + 
-//			"    #26 @C(\n" + 
-//			"      #27 value=\'(\' (constant type)\n" + 
-//			"      target type = 0x14 CLASS_EXTENDS_IMPLEMENTS\n" + 
-//			"      type index = 1\n" + 
-//			"    )\n" + 
-//			"  RuntimeInvisibleTypeAnnotations: \n" + 
-//			"    #21 @B(\n" + 
-//			"      target type = 0x14 CLASS_EXTENDS_IMPLEMENTS\n" + 
-//			"      type index = 1\n" + 
-//			"    )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-//	// class literal
-//	public void test005() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String value() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"C.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface C {\n" + 
-//				"	char value() default '-';\n" + 
-//				"}\n",
-//				"I.java",
-//				"interface I {}\n",
-//				"J.java",
-//				"interface J {}\n",
-//				"X.java",
-//				"public class X {\n" + 
-//				"	public boolean foo(String s) {\n" + 
-//				"		boolean b = (s instanceof @C('_') Object);\n" + 
-//				"		Object o = new @B(3) @A(\"new Object\") Object();\n" + 
-//				"		Class<?> c = @B(4) Object.class;\n" + 
-//				"		Class<?> c2 = @A(\"int class literal\")  @B(5) int.class;\n" + 
-//				"		System.out.println(o.toString() + c.toString() + c2.toString());\n" + 
-//				"		return b;\n" + 
-//				"	}\n" + 
-//				"}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"    RuntimeVisibleTypeAnnotations: \n" + 
-//			"      #73 @C(\n" + 
-//			"        #68 value=\'_\' (constant type)\n" + 
-//			"        target type = 0x2 TYPE_INSTANCEOF\n" + 
-//			"        offset = 1\n" + 
-//			"      )\n" + 
-//			"      #75 @A(\n" + 
-//			"        #68 value=\"new Object\" (constant type)\n" + 
-//			"        target type = 0x4 OBJECT_CREATION\n" + 
-//			"        offset = 5\n" + 
-//			"      )\n" + 
-//			"      #75 @A(\n" + 
-//			"        #68 value=\"int class literal\" (constant type)\n" + 
-//			"        target type = 0x1e CLASS_LITERAL\n" + 
-//			"        offset = 17\n" + 
-//			"      )\n" + 
-//			"    RuntimeInvisibleTypeAnnotations: \n" + 
-//			"      #67 @B(\n" + 
-//			"        #68 value=(int) 3 (constant type)\n" + 
-//			"        target type = 0x4 OBJECT_CREATION\n" + 
-//			"        offset = 5\n" + 
-//			"      )\n" + 
-//			"      #67 @B(\n" + 
-//			"        #68 value=(int) 4 (constant type)\n" + 
-//			"        target type = 0x1e CLASS_LITERAL\n" + 
-//			"        offset = 13\n" + 
-//			"      )\n" + 
-//			"      #67 @B(\n" + 
-//			"        #68 value=(int) 5 (constant type)\n" + 
-//			"        target type = 0x1e CLASS_LITERAL\n" + 
-//			"        offset = 17\n" + 
-//			"      )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-//	// class literal generic and array
-//	public void test006() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String value() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"C.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface C {\n" + 
-//				"	char value() default '-';\n" + 
-//				"}\n",
-//				"I.java",
-//				"interface I {}\n",
-//				"J.java",
-//				"interface J {}\n",
-//				"X.java",
-//				"public class X {\n" + 
-//				"	public boolean foo(Object o) {\n" + 
-//				"		boolean b = (o instanceof @C('_') Object[]);\n" + 
-//				"		Object o1 = new @B(3) @A(\"new Object\") Object[] {};\n" + 
-//				"		Class<?> c = @B(4) Object[].class;\n" + 
-//				"		Class<?> c2 = @A(\"int class literal\")  @B(5) int[].class;\n" + 
-//				"		System.out.println(o1.toString() + c.toString() + c2.toString());\n" + 
-//				"		return b;\n" + 
-//				"	}\n" + 
-//				"}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"    RuntimeVisibleTypeAnnotations: \n" + 
-//			"      #70 @C(\n" + 
-//			"        #66 value=\'_\' (constant type)\n" + 
-//			"        target type = 0x2 TYPE_INSTANCEOF\n" + 
-//			"        offset = 1\n" + 
-//			"      )\n" + 
-//			"      #72 @A(\n" + 
-//			"        #66 value=\"int class literal\" (constant type)\n" + 
-//			"        target type = 0x1e CLASS_LITERAL\n" + 
-//			"        offset = 14\n" + 
-//			"      )\n" + 
-//			"    RuntimeInvisibleTypeAnnotations: \n" + 
-//			"      #65 @B(\n" + 
-//			"        #66 value=(int) 4 (constant type)\n" + 
-//			"        target type = 0x1e CLASS_LITERAL\n" + 
-//			"        offset = 10\n" + 
-//			"      )\n" + 
-//			"      #65 @B(\n" + 
-//			"        #66 value=(int) 5 (constant type)\n" + 
-//			"        target type = 0x1e CLASS_LITERAL\n" + 
-//			"        offset = 14\n" + 
-//			"      )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-//	// parameterized superclass
-//	public void test007() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String value() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"C.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface C {\n" + 
-//				"	char value() default '-';\n" + 
-//				"}\n",
-//				"Y.java",
-//				"class Y<T> {}\n",
-//				"X.java",
-//				"public class X extends @A(\"Hello, World!\") Y<@B @C('(') String> {\n" + 
-//				"}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"  RuntimeVisibleTypeAnnotations: \n" + 
-//			"    #21 @A(\n" + 
-//			"      #22 value=\"Hello, World!\" (constant type)\n" + 
-//			"      target type = 0x14 CLASS_EXTENDS_IMPLEMENTS\n" + 
-//			"      type index = -1\n" + 
-//			"    )\n" + 
-//			"    #24 @C(\n" + 
-//			"      #22 value=\'(\' (constant type)\n" + 
-//			"      target type = 0x15 CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY\n" + 
-//			"      type index = -1\n" + 
-//			"      locations = {0}\n" + 
-//			"    )\n" + 
-//			"  RuntimeInvisibleTypeAnnotations: \n" + 
-//			"    #19 @B(\n" + 
-//			"      target type = 0x15 CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY\n" + 
-//			"      type index = -1\n" + 
-//			"      locations = {0}\n" + 
-//			"    )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-//	public void test008() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String value() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"C.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface C {\n" + 
-//				"	char value() default '-';\n" + 
-//				"}\n",
-//				"I.java",
-//				"interface I<T> {}\n",
-//				"J.java",
-//				"interface J<U,T> {}\n",
-//				"X.java",
-//				"public class X implements I<@A(\"Hello, World!\") String>, @B J<String, @C('(') Integer> {}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"  RuntimeVisibleTypeAnnotations: \n" + 
-//			"    #25 @A(\n" + 
-//			"      #26 value=\"Hello, World!\" (constant type)\n" + 
-//			"      target type = 0x15 CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY\n" + 
-//			"      type index = 0\n" + 
-//			"      locations = {0}\n" + 
-//			"    )\n" + 
-//			"    #28 @C(\n" + 
-//			"      #26 value=\'(\' (constant type)\n" + 
-//			"      target type = 0x15 CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY\n" + 
-//			"      type index = 1\n" + 
-//			"      locations = {1}\n" + 
-//			"    )\n" + 
-//			"  RuntimeInvisibleTypeAnnotations: \n" + 
-//			"    #23 @B(\n" + 
-//			"      target type = 0x14 CLASS_EXTENDS_IMPLEMENTS\n" + 
-//			"      type index = 1\n" + 
-//			"    )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-	// throws
-	public void test009() throws Exception {
+
+	// Enables the tests to run individually
+	protected Map getCompilerOptions() {
+		Map defaultOptions = super.getCompilerOptions();
+		defaultOptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_8);
+		defaultOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_8);
+		defaultOptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);
+		return defaultOptions;
+	}
+	
+	private static final String HELPER_CLASS =
+		"import java.lang.annotation.*;\n"+
+		"import java.lang.reflect.*;\n"+
+		"class Helper {\n"+
+		"\n"+
+		// Print type annotations on super types
+		"  public static void printTypeAnnotations(Class<?> clazz) {\n"+
+		"    System.out.println(\"Annotations on superclass of \"+clazz.getName());\n"+
+		"    AnnotatedType superat = clazz.getAnnotatedSuperclass();\n"+
+		"    Helper.printAnnos(\"  \", superat.getType(),superat.getAnnotations());\n"+
+		"    AnnotatedType[] superinterfaces = clazz.getAnnotatedInterfaces();\n"+
+		"    if (superinterfaces.length!=0) {\n"+
+		"      System.out.println(\"Annotations on superinterfaces of \"+clazz.getName());\n"+
+		"      for (int j=0;j<superinterfaces.length;j++) {\n"+
+		"        Helper.printAnnos(\"  \", superinterfaces[j].getType(),superinterfaces[j].getAnnotations());\n"+
+		"      }\n"+
+		"    }\n"+
+		"  }\n"+
+		// Print type annotations on a type
+		"  public static void printTypeAnnotations2(Class<?> clazz) {\n"+
+		"    System.out.print(clazz.getName()+\"<\");\n"+
+		"    TypeVariable<?>[] tvs = clazz.getTypeParameters();\n"+
+		"    for (int t=0;t<tvs.length;t++) {\n"+
+		"      TypeVariable<?> tv = tvs[t];\n"+
+		"      Annotation[] annos = tv.getAnnotations();\n"+
+		"      for (int a=0;a<annos.length;a++) {\n"+
+		"        System.out.print(toStringAnno(annos[a])+\" \");\n"+
+		"      }\n"+
+		"      System.out.print(tv.getName());\n"+
+		"      if ((t+1)<tvs.length) System.out.print(\",\");\n"+
+		"    }\n"+
+		"    System.out.println(\">\");\n"+
+		"  }\n"+
+		"  public static String toStringAnno(Annotation anno) {\n"+
+		"    String s = anno.toString();\n"+
+		"    if (s.endsWith(\"()\")) return s.substring(0,s.length()-2); else return s;\n"+
+		"  }\n"+
+		"  \n"+
+		"  public static void printAnnos(String header, Type t, Annotation[] annos) {\n"+
+		"    if (annos.length==0) { System.out.println(header+t+\":no annotations\"); return;} \n"+
+		"    System.out.print(header+t+\":\");\n"+
+		"    for (int i=0;i<annos.length;i++) {\n"+
+		"      System.out.print(toStringAnno(annos[i])+\" \");\n"+
+		"    }\n"+
+		"    System.out.println();\n"+
+		"  }\n"+
+		"}\n";
+	
+	// http://types.cs.washington.edu/jsr308/specification/java-annotation-design.pdf
+	//		type_annotation {
+	//			// New fields in JSR 308:
+	//			u1 target_type; // the type of the targeted program element, see Section 3.2
+	//			union {
+	//				type_parameter_target;
+	//				supertype_target;
+	//				type_parameter_bound_target;
+	//				empty_target;
+	//				method_formal_parameter_target;
+	//				throws_target;
+	//				localvar_target;
+	//				catch_target;
+	//				offset_target;
+	//				type_argument_target;
+	//				method_reference_target;
+	//			} target_info; // identifies the targeted program element, see Section 3.3
+	//			type_path target_path; // identifies targeted type in a compound type (array, generic, etc.), see Section 3.4
+	//			// Original fields from "annotation" structure:
+	//			u2 type_index;
+	//			u2 num_element_value_pairs;
+	//			{
+	//				u2 element_name_index;
+	//				element_value value;
+	//			} element_value_pairs[num_element_value_pairs];
+	//			}
+	
+	public void test001_classTypeParameter() throws Exception {
 		this.runConformTest(
-			new String[] {
-				"A.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface A {\n" + 
-				"	String value() default \"default\";\n" + 
-				"}\n",
-				"B.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(CLASS)\n" + 
-				"@interface B {\n" + 
-				"	int value() default -1;\n" + 
-				"}",
-				"C.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface C {\n" + 
-				"	char value() default '-';\n" + 
-				"}\n",
-				"E.java",
-				"class E extends RuntimeException {\n" +
-				"	private static final long serialVersionUID = 1L;\n" +
-				"}\n",
-				"E1.java",
-				"class E1 extends RuntimeException {\n" +
-				"	private static final long serialVersionUID = 1L;\n" +
-				"}\n",
-				"E2.java",
-				"class E2 extends RuntimeException {\n" +
-				"	private static final long serialVersionUID = 1L;\n" +
-				"}\n",
-				"X.java",
-				"public class X {\n" +
-				"	void foo() throws @A(\"Hello, World!\") E, E1, @B @C('(') E2 {}\n" +
-				"}",
-		},
-		"");
+				new String[] {
+					"X.java",
+					"public class X<@Marker T> {}",
+
+					"Marker.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n"+
+					"@Target(ElementType.TYPE_PARAMETER)\n" + 
+					"@interface Marker {}",					
+				},
+				"");
+		// javac-b81: 9[0 1 0 0 0 0 13 0 0]  (13=Marker annotation)
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #25 @A(\n" + 
-			"        #26 value=\"Hello, World!\" (constant type)\n" + 
-			"        target type = 0x16 THROWS\n" + 
-			"        throws index = 0\n" + 
-			"      )\n" + 
-			"      #28 @C(\n" + 
-			"        #26 value=\'(\' (constant type)\n" + 
-			"        target type = 0x16 THROWS\n" + 
-			"        throws index = 2\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #23 @B(\n" + 
-			"        target type = 0x16 THROWS\n" + 
-			"        throws index = 2\n" + 
-			"      )\n";
+			"  RuntimeVisibleTypeAnnotations: \n" + 
+			"    #21 @Marker(\n" + 
+			"      target type = 0x0 CLASS_TYPE_PARAMETER\n" + 
+			"      type parameter index = 0\n" + 
+			"    )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-//	// method receiver
-//	public void test010() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String value() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"X.java",
-//				"public class X {\n" + 
-//				"	void foo() @B(3) {}\n" + 
-//				"}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"    RuntimeInvisibleTypeAnnotations: \n" + 
-//			"      #16 @B(\n" + 
-//			"        #17 value=(int) 3 (constant type)\n" + 
-//			"        target type = 0x6 METHOD_RECEIVER\n" + 
-//			"      )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-	// method return type
-	public void test011() throws Exception {
+
+	public void test002_classTypeParameter_reflection() throws Exception {
 		this.runConformTest(
-			new String[] {
-				"A.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface A {\n" + 
-				"	String value() default \"default\";\n" + 
-				"}\n",
-				"B.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(CLASS)\n" + 
-				"@interface B {\n" + 
-				"	int value() default -1;\n" + 
-				"}",
-				"X.java",
-				"public class X {\n" + 
-				"	@B(3) @A(value=\"test\") int foo() {\n" +
-				"		return 1;\n" +
-				"	}\n" + 
-				"}",
-		},
-		"");
+				new String[] {
+					"X.java",
+					"public class X<@Marker T> {\n"+
+					"  public static void main(String[] argv) { Helper.printTypeAnnotations2(X.class);}\n"+
+					"}",
+					
+					"Helper.java",HELPER_CLASS,
+					"Marker.java",
+					"import java.lang.annotation.*;\n" + 
+					"import static java.lang.annotation.ElementType.*;\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n"+
+					"@Target(TYPE_PARAMETER)\n" + 
+					"@interface Marker {}",
+				},
+				"X<@Marker T>");
+	}
+
+	public void test003_classTypeParameter() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"public class X<@A1 T1,@A2 @A3 T2> {}",
+
+					"A1.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n"+
+					"@Target(ElementType.TYPE_PARAMETER)\n" + 
+					"@interface A1 {}",
+					
+					"A2.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n"+
+					"@Target(ElementType.TYPE_PARAMETER)\n" + 
+					"@interface A2 {}",
+					
+					"A3.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n"+
+					"@Target(ElementType.TYPE_PARAMETER)\n" + 
+					"@interface A3 {}",
+
+				},
+				"");
+		// javac-b81: 9[0 1 0 0 0 0 13 0 0]  (13=Marker)
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #21 @A(\n" + 
-			"        #18 value=\"test\" (constant type)\n" + 
-			"        target type = 0xa METHOD_RETURN_TYPE\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #17 @B(\n" + 
-			"        #18 value=(int) 3 (constant type)\n" + 
-			"        target type = 0xa METHOD_RETURN_TYPE\n" + 
-			"      )\n";
+				"  RuntimeVisibleTypeAnnotations: \n" + 
+				"    #21 @A1(\n" + 
+				"      target type = 0x0 CLASS_TYPE_PARAMETER\n" + 
+				"      type parameter index = 0\n" + 
+				"    )\n" + 
+				"    #22 @A2(\n" + 
+				"      target type = 0x0 CLASS_TYPE_PARAMETER\n" + 
+				"      type parameter index = 1\n" + 
+				"    )\n" + 
+				"    #23 @A3(\n" + 
+				"      target type = 0x0 CLASS_TYPE_PARAMETER\n" + 
+				"      type parameter index = 1\n" + 
+				"    )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// field type
-	public void test012() throws Exception {
+
+	public void test004_classTypeParameter_reflection() throws Exception {
+		this.runConformTest(
+				new String[] {
+						"X.java",
+						"public class X<@A1 T1,@A2 @A3 T2> {\n"+
+						"    public static void main(String[] argv) { Helper.printTypeAnnotations2(X.class); }\n"+
+						"}",
+						
+						"Helper.java",HELPER_CLASS,
+						"A1.java",
+						"import java.lang.annotation.*;\n" +  
+						"@Retention(RetentionPolicy.RUNTIME)\n"+
+						"@Target(ElementType.TYPE_PARAMETER)\n" + 
+						"@interface A1 {}",
+						"A2.java",
+						"import java.lang.annotation.*;\n" + 
+						"import static java.lang.annotation.ElementType.*;\n" + 
+						"@Retention(RetentionPolicy.RUNTIME)\n"+
+						"@Target(TYPE_PARAMETER)\n" + 
+						"@interface A2 {}",
+						"A3.java",
+						"import java.lang.annotation.*;\n" + 
+						"import static java.lang.annotation.ElementType.*;\n" + 
+						"@Retention(RetentionPolicy.RUNTIME)\n"+
+						"@Target(TYPE_PARAMETER)\n" + 
+						"@interface A3 {}",
+				},
+				"X<@A1 T1,@A2 @A3 T2>");
+	}
+	
+	public void test005_classTypeParameter() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"A.java",
@@ -646,7 +246,7 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"import static java.lang.annotation.ElementType.*;\n" + 
 				"import java.lang.annotation.Retention;\n" + 
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
+				"@Target(TYPE_PARAMETER)\n" + 
 				"@Retention(RUNTIME)\n" + 
 				"@interface A {\n" + 
 				"	String value() default \"default\";\n" + 
@@ -656,109 +256,31 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"import static java.lang.annotation.ElementType.*;\n" + 
 				"import java.lang.annotation.Retention;\n" + 
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
+				"@Target(TYPE_PARAMETER)\n" + 
 				"@Retention(CLASS)\n" + 
 				"@interface B {\n" + 
 				"	int value() default -1;\n" + 
 				"}",
 				"X.java",
-				"public class X {\n" + 
-				"	@B(3) @A int field;\n" +
-				"}",
+				"public class X<@A @B(3) T> {}",
 		},
 		"");
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #12 @A(\n" + 
-			"        target type = 0xe FIELD\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #8 @B(\n" + 
-			"        #9 value=(int) 3 (constant type)\n" + 
-			"        target type = 0xe FIELD\n" + 
-			"      )\n";
+			"  RuntimeVisibleTypeAnnotations: \n" + 
+			"    #25 @A(\n" + 
+			"      target type = 0x0 CLASS_TYPE_PARAMETER\n" + 
+			"      type parameter index = 0\n" + 
+			"    )\n" + 
+			"  RuntimeInvisibleTypeAnnotations: \n" + 
+			"    #21 @B(\n" + 
+			"      #22 value=(int) 3 (constant type)\n" + 
+			"      target type = 0x0 CLASS_TYPE_PARAMETER\n" + 
+			"      type parameter index = 0\n" + 
+			"    )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-//	// method parameter
-//	public void test013() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"X.java",
-//				"public class X {\n" + 
-//				"	int foo(@B(3) String s) {\n" +
-//				"		return s.length();\n" +
-//				"	}\n" + 
-//				"}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"    RuntimeInvisibleTypeAnnotations: \n" + 
-//			"      #25 @B(\n" + 
-//			"        #26 value=(int) 3 (constant type)\n" + 
-//			"        target type = 0xc METHOD_PARAMETER\n" + 
-//			"        method parameter index = 0\n" + 
-//			"      )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-//	// method parameter generic or array
-//	public void test014() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String value() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"X.java",
-//				"public class X {\n" + 
-//				"	int foo(String @A [] @B(3) [] s) {\n" +
-//				"		return s.length;\n" +
-//				"	}\n" + 
-//				"}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"    RuntimeVisibleTypeAnnotations: \n" + 
-//			"      #23 @A(\n" + 
-//			"        target type = 0xc METHOD_PARAMETER\n" + 
-//			"        method parameter index = 0\n" + 
-//			"      )\n" + 
-//			"    RuntimeInvisibleTypeAnnotations: \n" + 
-//			"      #19 @B(\n" + 
-//			"        #20 value=(int) 3 (constant type)\n" + 
-//			"        target type = 0xd METHOD_PARAMETER_GENERIC_OR_ARRAY\n" + 
-//			"        method parameter index = 0\n" + 
-//			"        locations = {0}\n" + 
-//			"      )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-	// field type generic or array
-	public void test015() throws Exception {
+	
+	public void test006_classTypeParameter() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"A.java",
@@ -766,7 +288,7 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"import static java.lang.annotation.ElementType.*;\n" + 
 				"import java.lang.annotation.Retention;\n" + 
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
+				"@Target(TYPE_PARAMETER)\n" + 
 				"@Retention(RUNTIME)\n" + 
 				"@interface A {\n" + 
 				"	String value() default \"default\";\n" + 
@@ -776,75 +298,31 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"import static java.lang.annotation.ElementType.*;\n" + 
 				"import java.lang.annotation.Retention;\n" + 
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
+				"@Target(TYPE_PARAMETER)\n" + 
 				"@Retention(CLASS)\n" + 
 				"@interface B {\n" + 
 				"	int value() default -1;\n" + 
 				"}",
 				"X.java",
-				"public class X {\n" + 
-				"	@A int [] @B(3) [] field;\n" +
-				"}",
+				"public class X<T1,T2,@A @B(3) T3> {}",
 		},
 		"");
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #12 @A(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {1}\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #8 @B(\n" + 
-			"        #9 value=(int) 3 (constant type)\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {0}\n" + 
-			"      )\n";
+			"  RuntimeVisibleTypeAnnotations: \n" + 
+			"    #25 @A(\n" + 
+			"      target type = 0x0 CLASS_TYPE_PARAMETER\n" + 
+			"      type parameter index = 2\n" + 
+			"    )\n" + 
+			"  RuntimeInvisibleTypeAnnotations: \n" + 
+			"    #21 @B(\n" + 
+			"      #22 value=(int) 3 (constant type)\n" + 
+			"      target type = 0x0 CLASS_TYPE_PARAMETER\n" + 
+			"      type parameter index = 2\n" + 
+			"    )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-//	// class type parameter
-//	public void test016() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_PARAMETER)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String value() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_PARAMETER)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"X.java",
-//				"public class X<@A @B(3) T> {}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"  RuntimeVisibleTypeAnnotations: \n" + 
-//			"    #25 @A(\n" + 
-//			"      target type = 0x22 CLASS_TYPE_PARAMETER\n" + 
-//			"      type parameter index = 0\n" + 
-//			"    )\n" + 
-//			"  RuntimeInvisibleTypeAnnotations: \n" + 
-//			"    #21 @B(\n" + 
-//			"      #22 value=(int) 3 (constant type)\n" + 
-//			"      target type = 0x22 CLASS_TYPE_PARAMETER\n" + 
-//			"      type parameter index = 0\n" + 
-//			"    )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-	// method type parameter
-	public void test017() throws Exception {
+
+	public void test007_methodTypeParameter() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"A.java",
@@ -876,126 +354,19 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 		String expectedOutput =
 			"    RuntimeVisibleTypeAnnotations: \n" + 
 			"      #27 @A(\n" + 
-			"        target type = 0x20 METHOD_TYPE_PARAMETER\n" + 
+			"        target type = 0x1 METHOD_TYPE_PARAMETER\n" + 
 			"        type parameter index = 0\n" + 
 			"      )\n" + 
 			"    RuntimeInvisibleTypeAnnotations: \n" + 
 			"      #23 @B(\n" + 
 			"        #24 value=(int) 3 (constant type)\n" + 
-			"        target type = 0x20 METHOD_TYPE_PARAMETER\n" + 
+			"        target type = 0x1 METHOD_TYPE_PARAMETER\n" + 
 			"        type parameter index = 0\n" + 
 			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-//	// class type parameter bound
-//	public void test018() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String value() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"X.java",
-//				"public class X<T extends @A String & @B(3) Cloneable> {}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"  RuntimeVisibleTypeAnnotations: \n" + 
-//			"    #25 @A(\n" + 
-//			"      target type = 0x10 CLASS_TYPE_PARAMETER_BOUND\n" + 
-//			"      type parameter index = 0 type parameter bound index = 0\n" + 
-//			"    )\n" + 
-//			"  RuntimeInvisibleTypeAnnotations: \n" + 
-//			"    #21 @B(\n" + 
-//			"      #22 value=(int) 3 (constant type)\n" + 
-//			"      target type = 0x10 CLASS_TYPE_PARAMETER_BOUND\n" + 
-//			"      type parameter index = 0 type parameter bound index = 1\n" + 
-//			"    )\n" ;
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-//	// class type parameter bound generic or array
-//	public void test019() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String value() default \"default\";\n" + 
-//				"}\n",
-//				"B.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(CLASS)\n" + 
-//				"@interface B {\n" + 
-//				"	int value() default -1;\n" + 
-//				"}",
-//				"C.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface C {\n" + 
-//				"	char value() default '-';\n" + 
-//				"}\n",
-//				"Y.java",
-//				"public class Y<T> {}",
-//				"X.java",
-//				"public class X<U, T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"  RuntimeVisibleTypeAnnotations: \n" + 
-//			"    #25 @A(\n" + 
-//			"      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY\n" + 
-//			"      type parameter index = 1 type parameter bound index = 0\n" + 
-//			"      locations = {0,2}\n" + 
-//			"    )\n" + 
-//			"    #26 @C(\n" + 
-//			"      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY\n" + 
-//			"      type parameter index = 1 type parameter bound index = 0\n" + 
-//			"      locations = {0}\n" + 
-//			"    )\n" + 
-//			"  RuntimeInvisibleTypeAnnotations: \n" + 
-//			"    #21 @B(\n" + 
-//			"      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY\n" + 
-//			"      type parameter index = 1 type parameter bound index = 0\n" + 
-//			"      locations = {0,1}\n" + 
-//			"    )\n" + 
-//			"    #21 @B(\n" + 
-//			"      #22 value=(int) 3 (constant type)\n" + 
-//			"      target type = 0x10 CLASS_TYPE_PARAMETER_BOUND\n" + 
-//			"      type parameter index = 1 type parameter bound index = 1\n" + 
-//			"    )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-	// method type parameter bound
-	public void test020() throws Exception {
+	
+	public void test008_methodTypeParameter() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"A.java",
@@ -1003,7 +374,7 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"import static java.lang.annotation.ElementType.*;\n" + 
 				"import java.lang.annotation.Retention;\n" + 
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
+				"@Target(TYPE_PARAMETER)\n" + 
 				"@Retention(RUNTIME)\n" + 
 				"@interface A {\n" + 
 				"	String value() default \"default\";\n" + 
@@ -1013,35 +384,111 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"import static java.lang.annotation.ElementType.*;\n" + 
 				"import java.lang.annotation.Retention;\n" + 
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
+				"@Target(TYPE_PARAMETER)\n" + 
 				"@Retention(CLASS)\n" + 
 				"@interface B {\n" + 
 				"	int value() default -1;\n" + 
 				"}",
-				"Z.java",
-				"public class Z {}",
 				"X.java",
-				"public class X {\n" +
-				"	<T extends @A Z & @B(3) Cloneable> void foo(T t) {}\n" +
+				"public class X {\n" + 
+				"	<T1, @A @B(3) T2> void foo(T1 t1,T2 t2) {}\n" + 
 				"}",
 		},
 		"");
 		String expectedOutput =
 			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #27 @A(\n" + 
-			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
-			"        type parameter index = 0 type parameter bound index = 0\n" + 
+			"      #29 @A(\n" + 
+			"        target type = 0x1 METHOD_TYPE_PARAMETER\n" + 
+			"        type parameter index = 1\n" + 
 			"      )\n" + 
 			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #23 @B(\n" + 
-			"        #24 value=(int) 3 (constant type)\n" + 
-			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
-			"        type parameter index = 0 type parameter bound index = 1\n" + 
+			"      #25 @B(\n" + 
+			"        #26 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x1 METHOD_TYPE_PARAMETER\n" + 
+			"        type parameter index = 1\n" + 
 			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// class type parameter bound generic or array
-	public void test021() throws Exception {
+	
+	public void test009_classExtends() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"Marker.java",
+					"import java.lang.annotation.Target;\n" + 
+					"import static java.lang.annotation.ElementType.*;\n" + 
+					"@Target(TYPE_USE)\n" + 
+					"@interface Marker {}",
+					"X.java",
+					"public class X extends @Marker Object {}",
+				},
+				"");
+		// javac-b81 annotation contents: len:10[0 1 16 -1 -1 0 0 17 0 0]
+		String expectedOutput =
+			"  RuntimeInvisibleTypeAnnotations: \n" + 
+			"    #17 @Marker(\n" + 
+			"      target type = 0x10 CLASS_EXTENDS\n" + 
+			"      type index = -1\n" + 
+			"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	public void test010_classExtends() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"Marker.java",
+					"import java.lang.annotation.*;\n" + 
+					"import static java.lang.annotation.ElementType.*;\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n"+
+					"@Target(TYPE_USE)\n" + 
+					"@interface Marker {}",
+					"X.java",
+					"public class X extends @Marker Object {}",
+				},
+				"");
+		// Bytes:10[0 1 16 -1 -1 0 0 17 0 0]
+		String expectedOutput =
+			"  RuntimeVisibleTypeAnnotations: \n" + 
+			"    #17 @Marker(\n" + 
+			"      target type = 0x10 CLASS_EXTENDS\n" + 
+			"      type index = -1\n" + 
+			"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test011_classExtends_reflection() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"public class X extends @Marker Object {public static void main(String[] argv) {Helper.printTypeAnnotations(X.class);}}",
+					"Helper.java",HELPER_CLASS,
+					"Marker.java",
+					"import java.lang.annotation.Target;\n" + 
+					"import static java.lang.annotation.ElementType.*;\n" + 
+					"@Target(TYPE_USE)\n" + 
+					"@interface Marker {}"
+				},
+				"Annotations on superclass of X\n"+
+				"  class java.lang.Object:no annotations");
+	}
+
+	public void test012_classExtends_reflection() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"public class X extends @Marker Object {public static void main(String[] argv) {Helper.printTypeAnnotations(X.class);}}",
+					"Helper.java",HELPER_CLASS,
+					"Marker.java",
+					"import java.lang.annotation.*;\n" + 
+					"import static java.lang.annotation.ElementType.*;\n" + 
+					"@Target(TYPE_USE)\n" +
+					"@Retention(RetentionPolicy.RUNTIME)\n"+
+					"@interface Marker {}"
+				},
+				"Annotations on superclass of X\n"+
+				"  class java.lang.Object:@Marker");
+	}
+
+	public void test013_classExtends_interfaces() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"A.java",
@@ -1052,7 +499,7 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"@Target(TYPE_USE)\n" + 
 				"@Retention(RUNTIME)\n" + 
 				"@interface A {\n" + 
-				"	String value() default \"default\";\n" + 
+				"	String id() default \"default\";\n" + 
 				"}\n",
 				"B.java",
 				"import java.lang.annotation.Target;\n" + 
@@ -1074,45 +521,45 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"@interface C {\n" + 
 				"	char value() default '-';\n" + 
 				"}\n",
-				"Z.java",
-				"public class Z {}",
-				"Y.java",
-				"public class Y<T> {}",
+				"I.java",
+				"interface I {}\n",
+				"J.java",
+				"interface J {}\n",
 				"X.java",
-				"public class X {\n" +
-				"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" +
-				"}",
+				"public class X implements @A(id=\"Hello, World!\") I, @B @C('(') J {}",
 		},
 		"");
+		// Output from javac b81 lambda
+		// RuntimeVisibleTypeAnnotations
+		// Bytes:28[0 2 16 0 0 0 0 13 0 1 0 14 115 0 15 16 0 1 0 0 16 0 1 0 17 67 0 18]
+		// RuntimeInvisibleTypeAnnotations
+		// Bytes:10[0 1 16 0 1 0 0 20 0 0]		
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #27 @A(\n" + 
-			"        target type = 0x13 METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY\n" + 
-			"        type parameter index = 0 type parameter bound index = 0\n" + 
-			"        locations = {0,2}\n" + 
-			"      )\n" + 
-			"      #28 @C(\n" + 
-			"        target type = 0x13 METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY\n" + 
-			"        type parameter index = 0 type parameter bound index = 0\n" + 
-			"        locations = {0}\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #23 @B(\n" + 
-			"        target type = 0x13 METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY\n" + 
-			"        type parameter index = 0 type parameter bound index = 0\n" + 
-			"        locations = {0,1}\n" + 
-			"      )\n" + 
-			"      #23 @B(\n" + 
-			"        #24 value=(int) 3 (constant type)\n" + 
-			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
-			"        type parameter index = 0 type parameter bound index = 1\n" + 
-			"      )\n";
+			"  RuntimeVisibleTypeAnnotations: \n" + 
+			"    #23 @A(\n" + 
+			"      #24 id=\"Hello, World!\" (constant type)\n" + 
+			"      target type = 0x10 CLASS_EXTENDS\n" + 
+			"      type index = 0\n" + 
+			"    )\n" + 
+			"    #26 @C(\n" + 
+			"      #27 value=\'(\' (constant type)\n" + 
+			"      target type = 0x10 CLASS_EXTENDS\n" + 
+			"      type index = 1\n" + 
+			"    )\n" + 
+			"  RuntimeInvisibleTypeAnnotations: \n" + 
+			"    #21 @B(\n" + 
+			"      target type = 0x10 CLASS_EXTENDS\n" + 
+			"      type index = 1\n" + 
+			"    )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// local variable + generic or array
-	public void test022() throws Exception {
+	
+	public void test014_classExtends_interfaces_reflection() throws Exception {
 		this.runConformTest(
 			new String[] {
+				"X.java",
+				"public class X implements @A I {public static void main(String[]argv) {Helper.printTypeAnnotations(X.class);}}",
+				"Helper.java",HELPER_CLASS,
 				"A.java",
 				"import java.lang.annotation.Target;\n" + 
 				"import static java.lang.annotation.ElementType.*;\n" + 
@@ -1121,7 +568,31 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"@Target(TYPE_USE)\n" + 
 				"@Retention(RUNTIME)\n" + 
 				"@interface A {\n" + 
-				"	String value() default \"default\";\n" + 
+				"}\n",
+				"I.java",
+				"interface I {}\n"
+		},
+		"Annotations on superclass of X\n" + 
+		"  class java.lang.Object:no annotations\n" + 
+		"Annotations on superinterfaces of X\n" + 
+		"  interface I:@A");
+	}
+	
+	public void test015_classExtends_interfaces_reflection() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X implements @A(id=\"Hello, World!\") I, @B @C('i') J {public static void main(String[] argv) { Helper.printTypeAnnotations(X.class);}}",
+				"Helper.java",HELPER_CLASS,
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String id() default \"default\";\n" + 
 				"}\n",
 				"B.java",
 				"import java.lang.annotation.Target;\n" + 
@@ -1143,103 +614,242 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"@interface C {\n" + 
 				"	char value() default '-';\n" + 
 				"}\n",
+				"I.java",
+				"interface I {}\n",
+				"J.java",
+				"interface J {}\n",
+		},
+		"Annotations on superclass of X\n" + 
+		"  class java.lang.Object:no annotations\n" + 
+		"Annotations on superinterfaces of X\n" + 
+		"  interface I:@A(id=Hello, World!) \n" + 
+		"  interface J:@C(value=i)");
+	}
+
+	public void test016_classExtends() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"Y.java",
+				"class Y<T> {}\n",
 				"X.java",
-				"public class X {\n" + 
-				"	String[][] bar() {\n" + 
-				"		return new String[][] {};" +
-				"	}\n" + 
-				"	void foo(String s) {\n" + 
-				"		@C int i;\n" + 
-				"		@A String [] @B(3)[] tab = bar();\n" + 
-				"		if (tab != null) {\n" + 
-				"			i = 0;\n" + 
-				"			System.out.println(i + tab.length);\n" + 
-				"		} else {\n" + 
-				"			System.out.println(tab.length);\n" + 
-				"		}\n" + 
-				"		i = 4;\n" + 
-				"		System.out.println(-i + tab.length);\n" + 
-				"	}\n" + 
+				"public class X extends Y<@B String> {\n" + 
 				"}",
 		},
 		"");
+		// javac-b81: Bytes:12[0 1 16 -1 -1 1 3 0 0 13 0 0] // type path: 1,3,0
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #49 @C(\n" + 
-			"        target type = 0x8 LOCAL_VARIABLE\n" + 
-			"        local variable entries:\n" + 
-			"          [pc: 11, pc: 24] index: 2\n" + 
-			"          [pc: 34, pc: 46] index: 2\n" + 
-			"      )\n" + 
-			"      #50 @A(\n" + 
-			"        target type = 0x9 LOCAL_VARIABLE_GENERIC_OR_ARRAY\n" + 
-			"        local variable entries:\n" + 
-			"          [pc: 5, pc: 46] index: 3\n" + 
-			"        locations = {1}\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #45 @B(\n" + 
-			"        #46 value=(int) 3 (constant type)\n" + 
-			"        target type = 0x9 LOCAL_VARIABLE_GENERIC_OR_ARRAY\n" + 
-			"        local variable entries:\n" + 
-			"          [pc: 5, pc: 46] index: 3\n" + 
-			"        locations = {0}\n" + 
-			"      )\n";
+				"  RuntimeVisibleTypeAnnotations: \n" + 
+				"    #19 @B(\n" + 
+				"      target type = 0x10 CLASS_EXTENDS\n" + 
+				"      type index = -1\n" + 
+				"      location = [TYPE_ARGUMENT(0)]\n" + 
+				"    )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// type argument constructor call
-	public void test023() throws Exception {
+	
+	public void test017_classExtends() throws Exception {
 		this.runConformTest(
 			new String[] {
-				"A.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface A {\n" + 
-				"	String value() default \"default\";\n" + 
-				"}\n",
-				"B.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(CLASS)\n" + 
-				"@interface B {\n" + 
-				"	int value() default -1;\n" + 
-				"}",
+				"Marker.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface Marker { }\n",
+				"I.java",
+				"interface I<T> {}\n",
 				"X.java",
-				"public class X {\n" + 
-				"	<T> X(T t) {\n" + 
-				"	}\n" + 
-				"	public Object foo() {\n" + 
-				"		X x = new <@A @B(1) String>X(null);\n" + 
-				"		return x;\n" + 
-				"	}\n" + 
+				"public class X implements I<@Marker String> {\n" + 
 				"}",
 		},
 		"");
+		// javac-b81: Bytes:12[0 1 16 0 0 1 3 0 0 14 0 0] // type path: 1,3,0
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #31 @A(\n" + 
-			"        target type = 0x18 TYPE_ARGUMENT_CONSTRUCTOR_CALL\n" + 
-			"        offset = 5\n" + 
-			"        type argument index = 0\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #27 @B(\n" + 
-			"        #28 value=(int) 1 (constant type)\n" + 
-			"        target type = 0x18 TYPE_ARGUMENT_CONSTRUCTOR_CALL\n" + 
-			"        offset = 5\n" + 
-			"        type argument index = 0\n" + 
-			"      )\n";
+				"  RuntimeVisibleTypeAnnotations: \n" + 
+				"    #21 @Marker(\n" + 
+				"      target type = 0x10 CLASS_EXTENDS\n" + 
+				"      type index = 0\n" + 
+				"      location = [TYPE_ARGUMENT(0)]\n" + 
+				"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test018_classExtends() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A { }\n",
+
+				"I.java",
+				"interface I<T1,T2> {}\n",
+				
+				"X.java",
+				"public class X implements I<Integer, @A String> {}\n"
+		},
+		"");
+		// javac-b81: Bytes:12[0 1 16 0 0 1 3 1 0 14 0 0] // type path: 1,3,1
+		String expectedOutput =
+				"  RuntimeVisibleTypeAnnotations: \n" + 
+				"    #21 @A(\n" + 
+				"      target type = 0x10 CLASS_EXTENDS\n" + 
+				"      type index = 0\n" + 
+				"      location = [TYPE_ARGUMENT(1)]\n" + 
+				"    )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// type argument constructor call generic or array
-	public void test024() throws Exception {
+	
+	public void test019_classExtends() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A { }\n",
+
+				"J.java",
+				"interface J<T> {}\n",
+				
+				"I.java",
+				"interface I<T> {}\n",
+				
+				"X.java",
+				"public class X implements I<J<@A String>> {}\n"
+		},
+		"");
+		// javac-b81: Bytes:14[0 1 16 0 0 2 3 0 3 0 0 14 0 0] // type path: 2,3,0,3,0
+		String expectedOutput =
+				"  RuntimeVisibleTypeAnnotations: \n" + 
+				"    #21 @A(\n" + 
+				"      target type = 0x10 CLASS_EXTENDS\n" + 
+				"      type index = 0\n" + 
+				"      location = [TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]\n" + 
+				"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test020_classExtends() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A { }\n",
+				
+				"I.java",
+				"interface I<T> {}\n",
+				
+				"X.java",
+				"public class X implements I<@A String[]> {}\n"
+		},
+		"");
+		// javac-b81: Bytes:14[0 1 16 0 0 2 3 0 0 0 0 14 0 0] // type path: 2,3,0,0,0
+		String expectedOutput =
+				"  RuntimeVisibleTypeAnnotations: \n" + 
+				"    #21 @A(\n" + 
+				"      target type = 0x10 CLASS_EXTENDS\n" + 
+				"      type index = 0\n" + 
+				"      location = [TYPE_ARGUMENT(0), ARRAY]\n" + 
+				"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test021_classExtends() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A { }\n",
+				
+				"I.java",
+				"interface I<T> {}\n",
+				
+				"X.java",
+				"public class X implements I<String @A[]> {}\n"
+		},
+		"");
+		// javac-b81: Bytes:12[0 1 16 0 0 1 3 0 0 14 0 0] // type path: 1,3,0
+		String expectedOutput =
+				"  RuntimeVisibleTypeAnnotations: \n" + 
+				"    #21 @A(\n" + 
+				"      target type = 0x10 CLASS_EXTENDS\n" + 
+				"      type index = 0\n" + 
+				"      location = [TYPE_ARGUMENT(0)]\n" + 
+				"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test022_classExtends() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A { }\n",
+				
+				"I.java",
+				"interface I<T> {}\n",
+				
+				"X.java",
+				"public class X implements I<String []@A[]> {}\n"
+		},
+		"");
+		// javac-b81: Bytes:14[0 1 16 0 0 2 3 0 0 0 0 14 0 0] // type path: 2,3,0,0,0
+		String expectedOutput =
+				"  RuntimeVisibleTypeAnnotations: \n" + 
+				"    #21 @A(\n" + 
+				"      target type = 0x10 CLASS_EXTENDS\n" + 
+				"      type index = 0\n" + 
+				"      location = [TYPE_ARGUMENT(0), ARRAY]\n" + 
+				"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test023_classExtends() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A { }\n",
+				
+				"I.java",
+				"interface I<T> {}\n",
+				
+				"X.java",
+				"public class X implements I<@A String [][][]> {}\n"
+		},
+		"");
+		// javac-b81: Bytes:10[0 1 16 0 0 0 0 12 0 0] // type path: 4,3,0,0,0,0,0,0,0
+		String expectedOutput =
+				"  RuntimeVisibleTypeAnnotations: \n" + 
+				"    #21 @A(\n" + 
+				"      target type = 0x10 CLASS_EXTENDS\n" + 
+				"      type index = 0\n" + 
+				"      location = [TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]\n" + 
+				"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	
+	public void test024_classExtends() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"A.java",
@@ -1272,59 +882,62 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"@interface C {\n" + 
 				"	char value() default '-';\n" + 
 				"}\n",
+				"I.java",
+				"interface I<T> {}\n",
+				"J.java",
+				"interface J<U,T> {}\n",
 				"X.java",
-				"public class X {\n" + 
-				"	<T, U> X(T t, U u) {\n" + 
-				"	}\n" + 
-				"	public Object foo() {\n" + 
-				"		X x = new <@A Integer, @A String @C [] @B(1)[]>X(null, null);\n" + 
-				"		return x;\n" + 
-				"	}\n" + 
-				"}",
+				"public class X implements I<@A(\"Hello, World!\") String>, @B J<String, @C('(') Integer> {}",
 		},
 		"");
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #33 @A(\n" + 
-			"        target type = 0x18 TYPE_ARGUMENT_CONSTRUCTOR_CALL\n" + 
-			"        offset = 6\n" + 
-			"        type argument index = 0\n" + 
-			"      )\n" + 
-			"      #33 @A(\n" + 
-			"        target type = 0x19 TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY\n" + 
-			"        offset = 6\n" + 
-			"        type argument index = 1\n" + 
-			"        locations = {1}\n" + 
-			"      )\n" + 
-			"      #34 @C(\n" + 
-			"        target type = 0x18 TYPE_ARGUMENT_CONSTRUCTOR_CALL\n" + 
-			"        offset = 6\n" + 
-			"        type argument index = 1\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #29 @B(\n" + 
-			"        #30 value=(int) 1 (constant type)\n" + 
-			"        target type = 0x19 TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY\n" + 
-			"        offset = 6\n" + 
-			"        type argument index = 1\n" + 
-			"        locations = {0}\n" + 
-			"      )\n";
+			"  RuntimeVisibleTypeAnnotations: \n" + 
+			"    #25 @A(\n" + 
+			"      #26 value=\"Hello, World!\" (constant type)\n" + 
+			"      target type = 0x10 CLASS_EXTENDS\n" + 
+			"      type index = 0\n" + 
+			"      location = [TYPE_ARGUMENT(0)]\n" + 
+			"    )\n" + 
+			"    #28 @C(\n" + 
+			"      #26 value=\'(\' (constant type)\n" + 
+			"      target type = 0x10 CLASS_EXTENDS\n" + 
+			"      type index = 1\n" + 
+			"      location = [TYPE_ARGUMENT(1)]\n" + 
+			"    )\n" + 
+			"  RuntimeInvisibleTypeAnnotations: \n" + 
+			"    #23 @B(\n" + 
+			"      target type = 0x10 CLASS_EXTENDS\n" + 
+			"      type index = 1\n" + 
+			"    )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// type argument method call
-	public void test025() throws Exception {
+	
+	public void test025_classTypeParameterBound() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"X.java",
-				"public class X {\n" +
-				"\n" +
-				"	static <T, U> T foo(T t, U u) {\n" +
-				"		return t;\n" +
-				"	}\n" +
-				"	public static void main(String[] args) {\n" +
-				"		System.out.println(X.<@A @B(1) String[], @C('-') X>foo(new String[]{\"SUCCESS\"}, null)[0]);\n" +
-				"	}\n" +
-				"}\n",
+				"public class X<T extends @A String> {}",
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {}\n"
+		},
+		"");
+		// javac-b81: Bytes:10[0 1 17 0 0 0 0 13 0 0] 
+		// [17 0 0] is CLASS_PARAMETER_BOUND type_parameter_index=0 bound_index=0
+		String expectedOutput =
+			"  RuntimeVisibleTypeAnnotations: \n" + 
+			"    #21 @A(\n" + 
+			"      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND\n" + 
+			"      type parameter index = 0 type parameter bound index = 0\n" + 
+			"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	public void test026_classTypeParameterBound() throws Exception {
+		this.runConformTest(
+			new String[] {
 				"A.java",
 				"import java.lang.annotation.Target;\n" + 
 				"import static java.lang.annotation.ElementType.*;\n" + 
@@ -1345,100 +958,558 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"@interface B {\n" + 
 				"	int value() default -1;\n" + 
 				"}",
-				"C.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface C {\n" + 
-				"	char value() default '-';\n" + 
-				"}\n",
+				"X.java",
+				"public class X<T extends @A String & @B(3) Cloneable> {}",
 		},
-		"SUCCESS");
+		"");
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #52 @A(\n" + 
-			"        target type = 0x1a TYPE_ARGUMENT_METHOD_CALL\n" + 
-			"        offset = 13\n" + 
-			"        type argument index = 0\n" + 
-			"      )\n" + 
-			"      #53 @C(\n" + 
-			"        #49 value=\'-\' (constant type)\n" + 
-			"        target type = 0x1a TYPE_ARGUMENT_METHOD_CALL\n" + 
-			"        offset = 13\n" + 
-			"        type argument index = 1\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #48 @B(\n" + 
-			"        #49 value=(int) 1 (constant type)\n" + 
-			"        target type = 0x1a TYPE_ARGUMENT_METHOD_CALL\n" + 
-			"        offset = 13\n" + 
-			"        type argument index = 0\n" + 
-			"      )\n";
+			"  RuntimeVisibleTypeAnnotations: \n" + 
+			"    #25 @A(\n" + 
+			"      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND\n" + 
+			"      type parameter index = 0 type parameter bound index = 0\n" + 
+			"    )\n" + 
+			"  RuntimeInvisibleTypeAnnotations: \n" + 
+			"    #21 @B(\n" + 
+			"      #22 value=(int) 3 (constant type)\n" + 
+			"      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND\n" + 
+			"      type parameter index = 0 type parameter bound index = 1\n" + 
+			"    )\n" ;
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// check locations
-	public void test026() throws Exception {
+	
+	public void test027_classTypeParameterBound_complex() throws Exception {
 		this.runConformTest(
 			new String[] {
-				"X.java",
-				"import java.util.Map;\n" +
-				"import java.util.List;\n" +
-				"public class X {\n" + 
-				"	@H String @E[] @F[] @G[] field;\n" + 
-				"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
-				"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
-				"}",
 				"A.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
 				"@interface A {\n" + 
 				"	String value() default \"default\";\n" + 
 				"}\n",
 				"B.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(CLASS)\n" + 
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
 				"@interface B {\n" + 
 				"	int value() default -1;\n" + 
 				"}",
 				"C.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
 				"@interface C {\n" + 
 				"	char value() default '-';\n" + 
 				"}\n",
-				"D.java",
+				"Y.java",
+				"public class Y<T> {}",
+				"X.java",
+				"public class X<U, T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}",
+		},
+		"");
+		// javac-b81:
+		// Bytes:28[0 2 17 1 0 1 3 0 0 13 0 0 17 1 0 4 3 0 0 0 0 0 0 0 0 14 0 0]
+		// Bytes:29[0 2 17 1 0 3 3 0 0 0 0 0 0 16 0 0 17 1 1 0 0 16 0 1 0 17 73 0 18]
+		String expectedOutput =
+			"  RuntimeVisibleTypeAnnotations: \n" + 
+			"    #25 @A(\n" + 
+			"      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND\n" + 
+			"      type parameter index = 1 type parameter bound index = 0\n" + 
+			"      location = [TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]\n" + 
+			"    )\n" + 
+			"    #26 @C(\n" + 
+			"      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND\n" + 
+			"      type parameter index = 1 type parameter bound index = 0\n" + 
+			"      location = [TYPE_ARGUMENT(0)]\n" + 
+			"    )\n" + 
+			"  RuntimeInvisibleTypeAnnotations: \n" + 
+			"    #21 @B(\n" + 
+			"      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND\n" + 
+			"      type parameter index = 1 type parameter bound index = 0\n" + 
+			"      location = [TYPE_ARGUMENT(0), ARRAY, ARRAY]\n" + 
+			"    )\n" + 
+			"    #21 @B(\n" + 
+			"      #22 value=(int) 3 (constant type)\n" + 
+			"      target type = 0x11 CLASS_TYPE_PARAMETER_BOUND\n" + 
+			"      type parameter index = 1 type parameter bound index = 1\n" + 
+			"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test028_methodTypeParameterBound() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"Z.java",
+				"public class Z {}",
+				"X.java",
+				"public class X {\n" +
+				"	<T extends @A Z> void foo(T t) {}\n" +
+				"}",
+		},
+		"");
+		// javac-b81: Bytes:10[0 1 18 0 0 0 0 13 0 0]
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #23 @A(\n" + 
+			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
+			"        type parameter index = 0 type parameter bound index = 0\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test029_methodTypeParameterBound() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
 				"import java.lang.annotation.Target;\n" + 
 				"import static java.lang.annotation.ElementType.*;\n" + 
 				"import java.lang.annotation.Retention;\n" + 
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
 				"@Target(TYPE_USE)\n" + 
 				"@Retention(RUNTIME)\n" + 
-				"@interface D {\n" + 
+				"@interface A {\n" + 
 				"	String value() default \"default\";\n" + 
 				"}\n",
-				"E.java",
+				"B.java",
 				"import java.lang.annotation.Target;\n" + 
 				"import static java.lang.annotation.ElementType.*;\n" + 
 				"import java.lang.annotation.Retention;\n" + 
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
 				"@Target(TYPE_USE)\n" + 
 				"@Retention(CLASS)\n" + 
-				"@interface E {\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"Z.java",
+				"public class Z {}",
+				"X.java",
+				"public class X {\n" +
+				"	<T extends @A Z & @B(3) Cloneable> void foo(T t) {}\n" +
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #27 @A(\n" + 
+			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
+			"        type parameter index = 0 type parameter bound index = 0\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #23 @B(\n" + 
+			"        #24 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
+			"        type parameter index = 0 type parameter bound index = 1\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test030_methodTypeParameterBound() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"C.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface C {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"Z.java",
+				"public class Z {}",
+				"Y.java",
+				"public class Y<T> {}",
+				"X.java",
+				"public class X {\n" +
+				"	<T extends Y<Z [][]@B[]> & Cloneable> void foo(T t) {}\n" +
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" +  
+			"      #23 @B(\n" + 
+			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
+			"        type parameter index = 0 type parameter bound index = 0\n" + 
+			"        location = [TYPE_ARGUMENT(0), ARRAY, ARRAY]\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test031_methodTypeParameterBound_complex() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"C.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface C {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"Z.java",
+				"public class Z {}",
+				"Y.java",
+				"public class Y<T> {}",
+				"X.java",
+				"public class X {\n" +
+				"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" +
+				"}",
+		},
+		"");
+		// javac-b81:
+		// Bytes:28[0 2 18 0 0 1 3 0 0 13 0 0 18 0 0 4 3 0 0 0 0 0 0 0 0 14 0 0]
+		// Bytes:29[0 2 18 0 0 3 3 0 0 0 0 0 0 16 0 0 18 0 1 0 0 16 0 1 0 17 73 0 18]
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #27 @A(\n" + 
+			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
+			"        type parameter index = 0 type parameter bound index = 0\n" + 
+			"        location = [TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]\n" + 
+			"      )\n" + 
+			"      #28 @C(\n" + 
+			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
+			"        type parameter index = 0 type parameter bound index = 0\n" + 
+			"        location = [TYPE_ARGUMENT(0)]\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" +  
+			"      #23 @B(\n" + 
+			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
+			"        type parameter index = 0 type parameter bound index = 0\n" + 
+			"        location = [TYPE_ARGUMENT(0), ARRAY, ARRAY]\n" + 
+			"      )\n" + 
+			"      #23 @B(\n" + 
+			"        #24 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
+			"        type parameter index = 0 type parameter bound index = 1\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test032_field() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {}\n",
+				
+				"X.java",
+				"public class X {\n" + 
+				"	@A int field;\n" +
+				"}",
+		},
+		"");
+		// javac-b81: Bytes:8[0 1 19 0 0 7 0 0]  19 = 0x13 (FIELD)
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #8 @A(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test033_field() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {}\n",
+				
+				"X.java",
+				"public class X {\n" + 
+				"	java.util.List<@A String> field;\n" +
+				"}",
+		},
+		"");
+		// javac-b81: Bytes:10[0 1 19 1 3 0 0 9 0 0]
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #10 @A(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(0)]\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test034_field() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"X.java",
+				"public class X {\n" + 
+				"	@B(3) @A int field;\n" +
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #12 @A(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #8 @B(\n" + 
+			"        #9 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test035_field() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {}\n",
+				
+				"X.java",
+				"public class X {\n" + 
+				"	java.util.Map<String, @A String> field;\n" +
+				"}",
+		},
+		"");
+		// javac-b81: Bytes:10[0 1 19 1 3 1 0 9 0 0]
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #10 @A(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(1)]\n" +
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test036_field() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {}\n",
+				
+				"X.java",
+				"public class X {\n" + 
+				"	java.util.List<String[][]@A[][]> field;\n" +
+				"}",
+		},
+		"");
+		// javac-b81: Bytes:14[0 1 19 3 3 0 0 0 0 0 0 9 0 0]
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #10 @A(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(0), ARRAY, ARRAY]\n" +
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test037_field() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	java.util.List<? extends @A Number> field;\n" +
+				"}",
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {}\n",
+		},
+		"");
+		// javac-b81: Bytes:12[0 1 19 2 3 0 2 0 0 9 0 0]
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #10 @A(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(0), WILDCARD]\n" +
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test038_field() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"class AA { class BB<T> {}}" + 
+				"class X {\n" +
+				"  AA.@A BB field;\n" +
+				"}\n",
+
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A { }\n",
+		},
+		"");
+		String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #8 @A(\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [INNER_TYPE]\n" + 
+				"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test039_field() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"X.java",
+				"public class X {\n" + 
+				"	@A int [] @B(3) [] field;\n" +
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #12 @A(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [ARRAY, ARRAY]\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #8 @B(\n" + 
+			"        #9 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [ARRAY]\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test040_field_complex() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.util.Map;\n" +
+				"import java.util.List;\n" +
+				"public class X {\n" + 
+				"	@H String @E[] @F[] @G[] field;\n" + 
+				"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
+				"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
+				"}",
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"C.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface C {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"D.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface D {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"E.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface E {\n" + 
 				"	int value() default -1;\n" + 
 				"}",
 				"F.java",
@@ -1448,184 +1519,1479 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
 				"@Target(TYPE_USE)\n" + 
 				"@Retention(RUNTIME)\n" + 
-				"@interface F {\n" + 
-				"	char value() default '-';\n" + 
+				"@interface F {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"G.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface G {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"H.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface H {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+		},
+		"");
+		String expectedOutput =
+			"  // Field descriptor #6 [[[Ljava/lang/String;\n" + 
+			"  java.lang.String[][][] field;\n" + 
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #11 @H(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [ARRAY, ARRAY, ARRAY]\n" + 
+			"      )\n" + 
+			"      #12 @F(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [ARRAY]\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #8 @E(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"      )\n" + 
+			"      #9 @G(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [ARRAY, ARRAY]\n" + 
+			"      )\n" + 
+			"  \n" + 
+			"  // Field descriptor #14 Ljava/util/Map;\n" + 
+			"  // Signature: Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/Object;>;>;\n" + 
+			"  java.util.Map field2;\n" + 
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #18 @A(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"      )\n" + 
+			"      #19 @C(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(1)]\n" + 
+			"      )\n" + 
+			"      #20 @D(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #17 @B(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(0)]\n" + 
+			"      )\n" + 
+			"  \n" + 
+			"  // Field descriptor #14 Ljava/util/Map;\n" + 
+			"  // Signature: Ljava/util/Map<Ljava/lang/String;[[[Ljava/lang/String;>;\n" + 
+			"  java.util.Map field3;\n" + 
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #18 @A(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"      )\n" + 
+			"      #11 @H(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(1), ARRAY, ARRAY, ARRAY]\n" + 
+			"      )\n" + 
+			"      #12 @F(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(1), ARRAY]\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #17 @B(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(0)]\n" + 
+			"      )\n" + 
+			"      #8 @E(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(1)]\n" + 
+			"      )\n" + 
+			"      #9 @G(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [TYPE_ARGUMENT(1), ARRAY, ARRAY]\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	public void test041_field() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	java.lang.@H String @E[] @F[] @G[] field;\n" + 
+				"}",
+				"E.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface E {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"F.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface F {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"G.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface G {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"H.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface H {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #11 @H(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [ARRAY, ARRAY, ARRAY]\n" + 
+			"      )\n" + 
+			"      #12 @F(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [ARRAY]\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #8 @E(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"      )\n" + 
+			"      #9 @G(\n" + 
+			"        target type = 0x13 FIELD\n" + 
+			"        location = [ARRAY, ARRAY]\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test042_methodReturnType() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"X.java",
+				"public class X {\n" + 
+				"	@B(3) @A(value=\"test\") int foo() {\n" +
+				"		return 1;\n" +
+				"	}\n" + 
+				"}",
+		},
+		"");
+		// javac-b81:
+		// Bytes:13[0 1 20 0 0 11 0 1 0 12 115 0 13]
+		// Bytes:13[0 1 20 0 0 15 0 1 0 12 73 0 16]
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #21 @A(\n" + 
+			"        #18 value=\"test\" (constant type)\n" + 
+			"        target type = 0x14 METHOD_RETURN\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #17 @B(\n" + 
+			"        #18 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x14 METHOD_RETURN\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test043_methodReceiver() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"X.java",
+				"public class X {\n" + 
+				"	void foo(@B(3) X this) {}\n" + 
+				"}",
+		},
+		"");
+		// javac-b81: Bytes:13[0 1 21 0 0 10 0 1 0 11 73 0 12]
+		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #16 @B(\n" + 
+			"        #17 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x15 METHOD_RECEIVER\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	public void test044_methodReceiver() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X<T> {\n" + 
+				"	void foo(X<@B(3) T> this) {}\n" + 
+				"}",
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+		},
+		"");
+		// javac-b81: Bytes:15[0 1 21 1 3 0 0 10 0 1 0 11 73 0 12]
+		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #18 @B(\n" + 
+			"        #19 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x15 METHOD_RECEIVER\n" + 
+			"        location = [TYPE_ARGUMENT(0)]\n" +
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	
+	public void test045_methodParameter() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	int foo(@B(3) String s) {\n" +
+				"		return s.length();\n" +
+				"	}\n" + 
+				"}",
+				
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+		},
+		"");
+		// javac-b81: Bytes:14[0 1 22 0 0 0 11 0 1 0 12 73 0 13]
+		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #25 @B(\n" + 
+			"        #26 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x16 METHOD_FORMAL_PARAMETER\n" + 
+			"        method parameter index = 0\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test046_methodParameter() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	int foo(int i, double d, @B(3) String s) {\n" +
+				"		return s.length();\n" +
+				"	}\n" + 
+				"}",
+				
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+		},
+		"");
+		// javac-b81: Bytes:14[0 1 22 1 0 0 11 0 1 0 12 73 0 13]
+		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #29 @B(\n" + 
+			"        #30 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x16 METHOD_FORMAL_PARAMETER\n" + 
+			"        method parameter index = 2\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test047_methodParameterArray() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"X.java",
+				"public class X {\n" + 
+				"	int foo(String @A [] @B(3) [] s) {\n" +
+				"		return s.length;\n" +
+				"	}\n" + 
+				"}",
+		},
+		"");
+		// javac-b81:
+		// Bytes:9[0 1 22 0 0 0 11 0 0]
+		// Bytes:16[0 1 22 0 1 0 0 0 13 0 1 0 14 73 0 15]
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #23 @A(\n" + 
+			"        target type = 0x16 METHOD_FORMAL_PARAMETER\n" + 
+			"        method parameter index = 0\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #19 @B(\n" + 
+			"        #20 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x16 METHOD_FORMAL_PARAMETER\n" + 
+			"        method parameter index = 0\n" + 
+			"        location = [ARRAY]\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	public void test048_throws() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n"+
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n"+
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"C.java",
+				"import java.lang.annotation.*;\n"+
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface C {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"E.java",
+				"class E extends RuntimeException {\n" +
+				"	private static final long serialVersionUID = 1L;\n" +
+				"}\n",
+				"E1.java",
+				"class E1 extends RuntimeException {\n" +
+				"	private static final long serialVersionUID = 1L;\n" +
+				"}\n",
+				"E2.java",
+				"class E2 extends RuntimeException {\n" +
+				"	private static final long serialVersionUID = 1L;\n" +
+				"}\n",
+				"X.java",
+				"public class X {\n" +
+				"	void foo() throws @A(\"Hello, World!\") E, E1, @B @C('(') E2 {}\n" +
+				"}",
+		},
+		"");
+		// javac-b81:
+		// Bytes:28[0 2 23 0 0 0 0 14 0 1 0 15 115 0 16 23 0 2 0 0 17 0 1 0 15 67 0 18]
+		// Bytes:10[0 1 23 0 2 0 0 20 0 0]
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #25 @A(\n" + 
+			"        #26 value=\"Hello, World!\" (constant type)\n" + 
+			"        target type = 0x17 THROWS\n" + 
+			"        throws index = 0\n" + 
+			"      )\n" + 
+			"      #28 @C(\n" + 
+			"        #26 value=\'(\' (constant type)\n" + 
+			"        target type = 0x17 THROWS\n" + 
+			"        throws index = 2\n" + 
+			"      )\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #23 @B(\n" + 
+			"        target type = 0x17 THROWS\n" + 
+			"        throws index = 2\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	
+	public void test049_codeblocks_localVariable() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"public class X {\n" + 
+				"	public static void main(String[] args) {\n" + 
+				"		@B int j = 9;\n" + 
+				"		try {\n" + 
+				"			System.out.print(\"SUCCESS\" + j);\n" + 
+				"		} catch(@A Exception e) {\n" + 
+				"		}\n" + 
+				"		@B int k = 3;\n" + 
+				"		System.out.println(k);\n" + 
+				"	}\n" + 
+				"}",
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(CLASS)\n" + 
+				"@interface B {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+		},
+		"SUCCESS93");
+		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #56 @B(\n" + 
+			"        target type = 0x40 LOCAL_VARIABLE\n" + 
+			"        local variable entries:\n" + 
+			"          [pc: 3, pc: 39] index: 1\n" + 
+			"      )\n" + 
+			"      #56 @B(\n" + 
+			"        target type = 0x40 LOCAL_VARIABLE\n" + 
+			"        local variable entries:\n" + 
+			"          [pc: 31, pc: 39] index: 2\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test050_codeblocks_localVariable() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"C.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface C {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"X.java",
+				"public class X {\n" + 
+				"	String[][] bar() {\n" + 
+				"		return new String[][] {};" +
+				"	}\n" + 
+				"	void foo(String s) {\n" + 
+				"		@C int i;\n" + 
+				"		@A String [] @B(3)[] tab = bar();\n" + 
+				"		if (tab != null) {\n" + 
+				"			i = 0;\n" + 
+				"			System.out.println(i + tab.length);\n" + 
+				"		} else {\n" + 
+				"			System.out.println(tab.length);\n" + 
+				"		}\n" + 
+				"		i = 4;\n" + 
+				"		System.out.println(-i + tab.length);\n" + 
+				"	}\n" + 
+				"}",
+		},
+		"");
+		// javac-b81:
+		// Bytes:34[0 2 64 0 1 0 34 0 12 0 2 0 0 19 0 0 64 0 1 0 5 0 41 0 3 2 0 0 0 0 0 20 0 0]
+		// Bytes:23[0 1 64 0 1 0 5 0 41 0 3 1 0 0 0 22 0 1 0 23 73 0 24]
+		// ECJ data varies a little here as it is splitting the range 
+		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #45 @B(\n" + 
+			"        #46 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x40 LOCAL_VARIABLE\n" + 
+			"        local variable entries:\n" + 
+			"          [pc: 5, pc: 46] index: 3\n" + 
+			"        location = [ARRAY]\n" + 
+			"      )\n" + 
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #49 @C(\n" + 
+			"        target type = 0x40 LOCAL_VARIABLE\n" + 
+			"        local variable entries:\n" + 
+			"          [pc: 11, pc: 24] index: 2\n" + 
+			"          [pc: 34, pc: 46] index: 2\n" + 
+			"      )\n" + 
+			"      #50 @A(\n" + 
+			"        target type = 0x40 LOCAL_VARIABLE\n" + 
+			"        local variable entries:\n" + 
+			"          [pc: 5, pc: 46] index: 3\n" + 
+			"        location = [ARRAY, ARRAY]\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test051_codeblocks_resourceVariable() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"X.java",
+				"import java.io.*;\n"+
+				"public class X {\n" + 
+				"   public static void main(String[] argv) throws Exception {\n"+
+				"     try (@A BufferedReader br1 = new BufferedReader(new FileReader(\"a\"));\n"+
+				"          @B(99) BufferedReader br2 = new BufferedReader(new FileReader(\"b\"))) {\n"+
+				"       System.out.println(br1.readLine()+br2.readLine());\n" +
+				"     }\n" +
+				"	}\n" + 
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #81 @B(\n" + 
+			"        #82 value=(int) 99 (constant type)\n" + 
+			"        target type = 0x41 RESOURCE_VARIABLE\n" + 
+			"        local variable entries:\n" + 
+			"          [pc: 39, pc: 94] index: 4\n" + 
+			"      )\n" + 
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #85 @A(\n" + 
+			"        target type = 0x41 RESOURCE_VARIABLE\n" + 
+			"        local variable entries:\n" + 
+			"          [pc: 21, pc: 135] index: 3\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void _test052_codeblocks_exceptionParameter() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.*;\n" + 
+				"public class X {\n" + 
+				"	public static void main(String[] args) {\n" + 
+				"		Exception test = new Exception() {\n" +
+				"			private static final long serialVersionUID = 1L;\n" +
+				"			@Override\n" +
+				"			public String toString() {\n" +
+				"				return \"SUCCESS\";\n" +
+				"			}\n" +
+				"		};\n" + 
+				"		try {\n" + 
+				"			System.out.println(test);\n" + 
+				"		} catch(@A Exception e) {\n" + 
+				"			e.printStackTrace();\n" + 
+				"		}\n" + 
+				"	}\n" + 
+				"}",
+				
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+		},
+		"SUCCESS");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #44 @A(\n" + 
+			"        target type = 0x42 EXCEPTION_PARAMETER\n" + 
+			"        exception table index = 0\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void _test053_codeblocks_exceptionParameter() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"public class X {\n" + 
+				"	public static void main(String[] args) {\n" + 
+				"		@A Exception test = new Exception() {\n" +
+				"			private static final long serialVersionUID = 1L;\n" +
+				"			@Override\n" +
+				"			public String toString() {\n" +
+				"				return \"SUCCESS\";\n" +
+				"			}\n" +
+				"		};\n" + 
+				"		try {\n" + 
+				"			System.out.println(test);\n" + 
+				"		} catch(@A Exception e) {\n" + 
+				"			e.printStackTrace();\n" + 
+				"		}\n" + 
+				"	}\n" + 
+				"}",
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+		},
+		"SUCCESS");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #44 @A(\n" + 
+			"        target type = 0x40 LOCAL_VARIABLE\n" + 
+			"        local variable entries:\n" + 
+			"          [pc: 8, pc: 24] index: 1\n" + 
+			"      )\n" + 
+			"      #44 @A(\n" + 
+			"        target type = 0x42 EXCEPTION_PARAMETER\n" + 
+			"        exception table index = 0\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void _test054_codeblocks_exceptionParameter() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"public class X {\n" + 
+				"	public static void main(String[] args) {\n" + 
+				"		try {\n" + 
+				"			System.out.println(42);\n" + 
+				"		} catch(@B(1) RuntimeException e) {\n" + 
+				"			e.printStackTrace();\n" + 
+				"		} catch(@B(2) Throwable t) {\n" + 
+				"			t.printStackTrace();\n" + 
+				"		}\n" + 
+				"	}\n" + 
+				"}",
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface B {\n" + 
+				"	int value() default 99;\n" + 
+				"}\n",
+		},
+		"42");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #44 @B(\n" + 
+			"        #45 value=(int) 1 (constant type)\n" + 
+			"        target type = 0x42 EXCEPTION_PARAMETER\n" + 
+			"        exception table index = 0\n" + 
+			"      )\n" + 
+			"      #44 @B(\n" + 
+			"        #45 value=(int) 2 (constant type)\n" + 
+			"        target type = 0x42 EXCEPTION_PARAMETER\n" + 
+			"        exception table index = 1\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void _test055_codeblocks_exceptionParameterMultiCatch() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"class Exc1 extends RuntimeException {" +				
+				"    private static final long serialVersionUID = 1L;\n" +
+				"}\n"+
+				"class Exc2 extends RuntimeException {" +				
+				"    private static final long serialVersionUID = 1L;\n" +
+				"}\n"+
+				"class Exc3 extends RuntimeException {" +				
+				"    private static final long serialVersionUID = 1L;\n" +
+				"}\n"+
+				"public class X {\n" + 
+				"	public static void main(String[] args) {\n" + 
+				"		try {\n" + 
+				"			System.out.println(42);\n" +
+				// @B(1) is attached to the argument, the others are attached to the type reference in the union type reference
+				// During Parsing the @B(1) is moved from the argument to Exc1
+				"		} catch(@B(1) Exc1 | Exc2 | @B(2) Exc3 t) {\n" + 
+				"			t.printStackTrace();\n" + 
+				"		}\n" + 
+				"	}\n" + 
+				"}",
+				"B.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface B {\n" + 
+				"	int value() default 99;\n" + 
+				"}\n",
+		},
+		"42");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #45 @B(\n" + 
+			"        #46 value=(int) 1 (constant type)\n" + 
+			"        target type = 0x42 EXCEPTION_PARAMETER\n" + 
+			"        exception table index = 0\n" + 
+			"      )\n" + 
+			"      #45 @B(\n" + 
+			"        #46 value=(int) 2 (constant type)\n" + 
+			"        target type = 0x42 EXCEPTION_PARAMETER\n" + 
+			"        exception table index = 2\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test056_codeblocks_instanceof() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	public void foo(Object o) {\n" + 
+				"		if (o instanceof @A String) {\n" +
+				"			String tab = (String) o;\n" +
+				"			System.out.println(tab);\n" +
+				"		}\n" + 
+				"		System.out.println(o);\n" +
+				"	}\n" + 
+				"}",
+				
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #38 @A(\n" + 
+			"        target type = 0x43 INSTANCEOF\n" + 
+			"        offset = 1\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+		
+		expectedOutput = "     1  instanceof java.lang.String [16]\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	public void test057_codeblocks_new() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"C.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface C {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"I.java",
+				"interface I {}\n",
+				"J.java",
+				"interface J {}\n",
+				"X.java",
+				"public class X {\n" + 
+				"	public boolean foo(String s) {\n" + 
+				"		System.out.println(\"xyz\");\n" +
+				"		Object o = new @B(3) Object();\n" + 
+				"		return true;\n" + 
+				"	}\n" + 
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #35 @B(\n" + 
+			"        #36 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x44 NEW\n" + 
+			"        offset = 8\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test058_codeblocks_new2() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+
+				"X.java",
+				"public class X {\n" + 
+				"	public void foo() {\n" + 
+				"       Outer o = new Outer();\n" +
+				"       o.new @B(1) Inner();\n" +
+				"	}\n" + 
+				"}\n" +
+				"class Outer { class Inner {}}\n"
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #30 @B(\n" + 
+			"        #31 value=(int) 1 (constant type)\n" + 
+			"        target type = 0x44 NEW\n" + 
+			"        offset = 8\n" +
+			"        location = [INNER_TYPE]\n" +
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test059_codeblocks_new_newArray() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"C.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface C {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"I.java",
+				"interface I {}\n",
+				"J.java",
+				"interface J {}\n",
+				"X.java",
+				"public class X {\n" + 
+				"	public boolean foo(String s) {\n" + 
+				"		System.out.println(\"xyz\");\n" +
+				"		Object o = new @A String [1];\n" +
+				"		return true;\n" + 
+				"	}\n" + 
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #37 @A(\n" + 
+			"        target type = 0x44 NEW\n" + 
+			"        offset = 9\n" + 
+			"        location = [ARRAY]\n" +
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test060_codeblocks_new_multiNewArray() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"X.java",
+				"public class X {\n" + 
+				"	public boolean foo(String s) {\n" + 
+				"		System.out.println(\"xyz\");\n" +
+				"		Object o = new @A String [2][3];\n" + 
+				"		return true;\n" + 
+				"	}\n" + 
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #37 @A(\n" + 
+			"        target type = 0x44 NEW\n" + 
+			"        offset = 10\n" + 
+			"        location = [ARRAY, ARRAY]\n" +
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test061_codeblocks_new_newArrayWithInitializer() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"C.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface C {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"I.java",
+				"interface I {}\n",
+				"J.java",
+				"interface J {}\n",
+				"X.java",
+				"public class X {\n" + 
+				"	public boolean foo(String s) {\n" + 
+				"		System.out.println(\"xyz\");\n" +
+				"		Object o = new @A String []{\"xyz\"};\n" + 
+				"		return true;\n" + 
+				"	}\n" + 
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #37 @A(\n" + 
+			"        target type = 0x44 NEW\n" + 
+			"        offset = 9\n" + 
+			"        location = [ARRAY]\n" +
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test062_codeblocks_newArray() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"C.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface C {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"I.java",
+				"interface I {}\n",
+				"J.java",
+				"interface J {}\n",
+				"X.java",
+				"public class X {\n" + 
+				"	public boolean foo(String s) {\n" + 
+				"		System.out.println(\"xyz\");\n" +
+				"		Object o = new String @A[1];\n" + 
+				"		return true;\n" + 
+				"	}\n" + 
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #37 @A(\n" + 
+			"        target type = 0x44 NEW\n" + 
+			"        offset = 9\n" +
+			// no type path expected here
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test062_codeblocks_newArrayWithInitializer() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}",
+				"C.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface C {\n" + 
+				"	char value() default '-';\n" + 
+				"}\n",
+				"I.java",
+				"interface I {}\n",
+				"J.java",
+				"interface J {}\n",
+				"X.java",
+				"public class X {\n" + 
+				"	public boolean foo(String s) {\n" + 
+				"		System.out.println(\"xyz\");\n" +
+				"		Object o = new String @A[] { \"Hello\" };\n" + 
+				"		return true;\n" + 
+				"	}\n" + 
+				"}",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #39 @A(\n" + 
+			"        target type = 0x44 NEW\n" + 
+			"        offset = 9\n" +
+			// no type path expected here
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test063_codeblocks_new_instanceof() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"A.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"import java.lang.annotation.Retention;\n" + 
+				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
+				"@Target(TYPE_USE)\n" + 
+				"@Retention(RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
 				"}\n",
-				"G.java",
+				"B.java",
 				"import java.lang.annotation.Target;\n" + 
 				"import static java.lang.annotation.ElementType.*;\n" + 
 				"import java.lang.annotation.Retention;\n" + 
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
 				"@Target(TYPE_USE)\n" + 
 				"@Retention(CLASS)\n" + 
-				"@interface G {\n" + 
+				"@interface B {\n" + 
 				"	int value() default -1;\n" + 
 				"}",
-				"H.java",
+				"C.java",
 				"import java.lang.annotation.Target;\n" + 
 				"import static java.lang.annotation.ElementType.*;\n" + 
 				"import java.lang.annotation.Retention;\n" + 
 				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
 				"@Target(TYPE_USE)\n" + 
 				"@Retention(RUNTIME)\n" + 
-				"@interface H {\n" + 
+				"@interface C {\n" + 
 				"	char value() default '-';\n" + 
 				"}\n",
+				"I.java",
+				"interface I {}\n",
+				"J.java",
+				"interface J {}\n",
+				"X.java",
+				"public class X {\n" + 
+				"	public boolean foo(Object o) {\n" + 
+				"		boolean b = (o instanceof @C('_') Object[]);\n" + 
+				"		Object o1 = new @B(3) @A(\"new Object\") Object[] {};\n" + 
+				"		return b;\n" + 
+				"	}\n" + 
+				"}",
 		},
 		"");
 		String expectedOutput =
-			"  // Field descriptor #6 [[[Ljava/lang/String;\n" + 
-			"  java.lang.String[][][] field;\n" + 
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #11 @H(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {2}\n" + 
-			"      )\n" + 
-			"      #12 @F(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {0}\n" + 
-			"      )\n" + 
 			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #8 @E(\n" + 
-			"        target type = 0xe FIELD\n" + 
-			"      )\n" + 
-			"      #9 @G(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {1}\n" + 
+			"      #24 @B(\n" + 
+			"        #25 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x44 NEW\n" + 
+			"        offset = 6\n" + 
+			"        location = [ARRAY]\n" + 
 			"      )\n" + 
-			"  \n" + 
-			"  // Field descriptor #14 Ljava/util/Map;\n" + 
-			"  // Signature: Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/Object;>;>;\n" + 
-			"  java.util.Map field2;\n" + 
 			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #18 @A(\n" + 
-			"        target type = 0xe FIELD\n" + 
-			"      )\n" + 
-			"      #19 @C(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {1}\n" + 
-			"      )\n" + 
-			"      #20 @D(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {1,0}\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #17 @B(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {0}\n" + 
+			"      #28 @C(\n" + 
+			"        #25 value=\'_\' (constant type)\n" + 
+			"        target type = 0x43 INSTANCEOF\n" + 
+			"        offset = 1\n" + 
+			"        location = [ARRAY]\n" + 
 			"      )\n" + 
-			"  \n" + 
-			"  // Field descriptor #14 Ljava/util/Map;\n" + 
-			"  // Signature: Ljava/util/Map<Ljava/lang/String;[[[Ljava/lang/String;>;\n" + 
-			"  java.util.Map field3;\n" + 
+			"      #30 @A(\n" + 
+			"        #25 value=\"new Object\" (constant type)\n" + 
+			"        target type = 0x44 NEW\n" + 
+			"        offset = 6\n" + 
+			"        location = [ARRAY]\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+
+	public void test064_codeblocks_constructorReference() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.util.*;\n" +
+				"interface MR { X process(String input); }\n"+
+				"public class X<T> {\n" + 
+				"   public X(T t) {}\n" +
+				"   public static <T> String foo(String bar) { return bar; }\n"+
+				"	public void bar() {\n" +
+				"       System.out.println(\"abc\");\n" +
+				"       MR ref = @A X::new;\n" +
+				"	}\n" + 
+				"}",
+				
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				
+		},
+		"");
+		String expectedOutput =
 			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #18 @A(\n" + 
-			"        target type = 0xe FIELD\n" + 
-			"      )\n" + 
-			"      #11 @H(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {1,2}\n" + 
-			"      )\n" + 
-			"      #12 @F(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {1,0}\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #17 @B(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {0}\n" + 
-			"      )\n" + 
-			"      #8 @E(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {1}\n" + 
+			"      #48 @A(\n" + 
+			"        target type = 0x45 CONSTRUCTOR_REFERENCE\n" + 
+			"        offset = 8\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+
+	public void test065_codeblocks_methodReference() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.util.*;\n" +
+				"interface MR { String process(String input); }\n"+
+				"public class X<T> {\n" + 
+				"   public static <T> String foo(String bar) { return bar; }\n"+
+				"	public void bar() {\n" +
+				"       System.out.println(\"abc\");\n" +
+				"       MR ref = @A X::foo;\n" +
+				"       ref.process(\"abc\");\n" +
+				"	}\n" + 
+				"}",
+				
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #48 @A(\n" + 
+			"        target type = 0x46 METHOD_REFERENCE\n" + 
+			"        offset = 8\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test066_codeblocks_methodReference() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"interface I {\n" +
+				"    Object copy(int [] ia);\n" +
+				"}\n" +
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        I i = @B(1) int @B(2)[]::<String>clone;\n" +
+				"        i.copy(new int[10]); \n" +
+				"    }\n" +
+				"}\n",
+		
+				"B.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface B {\n" + 
+				"	int value() default -1;\n" + 
+				"}\n",
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #31 @B(\n" + 
+			"        #32 value=(int) 1 (constant type)\n" + 
+			"        target type = 0x46 METHOD_REFERENCE\n" + 
+			"        offset = 0\n" + 
+			"        location = [ARRAY]\n" + 
 			"      )\n" + 
-			"      #9 @G(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {1,1}\n" + 
+			"      #31 @B(\n" + 
+			"        #32 value=(int) 2 (constant type)\n" + 
+			"        target type = 0x46 METHOD_REFERENCE\n" + 
+			"        offset = 0\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	public void test067_codeblocks_constructorReferenceTypeArgument() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"import java.util.*;\n" +
+				"interface MR { X process(String input); }\n" +
+				"public class X<T> {\n" + 
+				"   public X(T s) {};\n" +
+				"   public static <T> String foo(String bar) { return bar; }\n"+
+				"	public void bar() {\n" +
+				"       System.out.println(\"abc\");\n" +
+				"       MR ref = X::<@A String>new;\n" +
+				"       ref.process(\"abc\");\n" +
+				"	}\n" + 
+				"}",
+				
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #54 @A(\n" + 
+			"        target type = 0x4a CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT\n" + 
+			"        offset = 8\n" + 
+			"        type argument index = 0\n" + 
 			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// check locations
-	public void test027() throws Exception {
+	
+	public void test068_codeblocks_methodReferenceTypeArgument() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"X.java",
-				"public class X {\n" + 
-				"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
-				"}",
-				"E.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(CLASS)\n" + 
-				"@interface E {\n" + 
-				"	int value() default -1;\n" + 
+				"import java.util.*;\n" +
+				"interface MR { String process(String input); }\n"+
+				"public class X<T> {\n" + 
+				"   public static <T> String foo(String bar) { return bar; }\n"+
+				"	public void bar() {\n" +
+				"       System.out.println(\"abc\");\n" +
+				"       MR ref = X::<@A String>foo;\n" +
+				"       ref.process(\"abc\");\n" +
+				"	}\n" + 
 				"}",
-				"F.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface F {\n" + 
-				"	char value() default '-';\n" + 
+				
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
 				"}\n",
-				"G.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(CLASS)\n" + 
-				"@interface G {\n" + 
-				"	int value() default -1;\n" + 
+				
+		},
+		"");
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #48 @A(\n" + 
+			"        target type = 0x4b METHOD_REFERENCE_TYPE_ARGUMENT\n" + 
+			"        offset = 8\n" + 
+			"        type argument index = 0\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test069_codeblocks_cast() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	public void foo(Object o) {\n" + 
+				"		if (o instanceof String) {\n" +
+				"			String tab = (@A String) o;\n" +
+				"			System.out.println(tab);\n" +
+				"		}\n" + 
+				"		System.out.println(o);\n" +
+				"	}\n" + 
 				"}",
-				"H.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface H {\n" + 
-				"	char value() default '-';\n" + 
+				
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
 				"}\n",
+				
 		},
 		"");
+		// javac-b81: Bytes:11[0 1 71 0 7 0 0 0 16 0 0]
+		// relevant numbers '71 0 7 0' which mean 0x47 (CAST) at offset 7
 		String expectedOutput =
 			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #11 @H(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {2}\n" + 
-			"      )\n" + 
-			"      #12 @F(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {0}\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #8 @E(\n" + 
-			"        target type = 0xe FIELD\n" + 
-			"      )\n" + 
-			"      #9 @G(\n" + 
-			"        target type = 0xf FIELD_GENERIC_OR_ARRAY\n" + 
-			"        locations = {1}\n" + 
+			"      #38 @A(\n" + 
+			"        target type = 0x47 CAST\n" + 
+			"        offset = 8\n" + 
+			"        type argument index = 0\n" +
 			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// cast
-	public void test028() throws Exception {
+	
+	public void test070_codeblocks_cast_complex() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"A.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
 				"@interface A {\n" + 
 				"	String value() default \"default\";\n" + 
 				"}\n",
@@ -1665,30 +3031,36 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"}",
 		},
 		"");
+		// javac-b81:
+		// Bytes:31[0 2 71 0 7 0 1 0 0 0 16 0 0 71 0 7 0 2 0 0 0 0 0 17 0 1 0 18 67 0 19]
+		// Bytes:20[0 1 71 0 7 0 2 0 0 0 0 0 21 0 1 0 18 73 0 22]
 		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #37 @B(\n" + 
+			"        #38 value=(int) 3 (constant type)\n" + 
+			"        target type = 0x47 CAST\n" + 
+			"        offset = 8\n" + 
+			"        type argument index = 0\n" + 
+			"        location = [ARRAY, ARRAY]\n" + 
+			"      )\n" + 
 			"    RuntimeVisibleTypeAnnotations: \n" + 
 			"      #41 @C(\n" + 
 			"        #38 value=\'_\' (constant type)\n" + 
-			"        target type = 0x1 TYPE_CAST_GENERIC_OR_ARRAY\n" + 
+			"        target type = 0x47 CAST\n" + 
 			"        offset = 8\n" + 
-			"        locations = {1}\n" + 
+			"        type argument index = 0\n" + 
+			"        location = [ARRAY, ARRAY]\n" + 
 			"      )\n" + 
 			"      #43 @A(\n" + 
-			"        target type = 0x1 TYPE_CAST_GENERIC_OR_ARRAY\n" + 
+			"        target type = 0x47 CAST\n" + 
 			"        offset = 8\n" + 
-			"        locations = {0}\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #37 @B(\n" + 
-			"        #38 value=(int) 3 (constant type)\n" + 
-			"        target type = 0x1 TYPE_CAST_GENERIC_OR_ARRAY\n" + 
-			"        offset = 8\n" + 
-			"        locations = {1}\n" + 
+			"        type argument index = 0\n" + 
+			"        location = [ARRAY]\n" + 
 			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// qualified allocation expression with type arguments
-	public void test029() throws Exception {
+	
+	public void test071_codeblocks_constructorInvocationTypeArgument() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"A.java",
@@ -1711,62 +3083,35 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"@interface B {\n" + 
 				"	int value() default -1;\n" + 
 				"}",
-				"C.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface C {\n" + 
-				"	char value() default '-';\n" + 
-				"}\n",
-				"D.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface D {\n" + 
-				"	char value() default '-';\n" + 
-				"}\n",
 				"X.java",
 				"public class X {\n" + 
-				"	class Y {\n" + 
-				"		<T, U> Y(T t, U u) {}\n" + 
+				"	<T> X(T t) {\n" + 
 				"	}\n" + 
-				"	public static void main(String[] args) {\n" + 
-				"		Y y = new X().new <@D() @A(value = \"hello\") String, @B X> Y(\"SUCCESS\", null);\n" + 
-				"		System.out.println(y);\n" + 
+				"	public Object foo() {\n" + 
+				"		X x = new <@A @B(1) String>X(null);\n" + 
+				"		return x;\n" + 
 				"	}\n" + 
 				"}",
 		},
 		"");
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #47 @D(\n" + 
-			"        target type = 0x18 TYPE_ARGUMENT_CONSTRUCTOR_CALL\n" + 
-			"        offset = 19\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #27 @B(\n" + 
+			"        #28 value=(int) 1 (constant type)\n" + 
+			"        target type = 0x48 CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 5\n" + 
 			"        type argument index = 0\n" + 
 			"      )\n" + 
-			"      #48 @A(\n" + 
-			"        #49 value=\"hello\" (constant type)\n" + 
-			"        target type = 0x18 TYPE_ARGUMENT_CONSTRUCTOR_CALL\n" + 
-			"        offset = 19\n" + 
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #31 @A(\n" + 
+			"        target type = 0x48 CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 5\n" + 
 			"        type argument index = 0\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #45 @B(\n" + 
-			"        target type = 0x18 TYPE_ARGUMENT_CONSTRUCTOR_CALL\n" + 
-			"        offset = 19\n" + 
-			"        type argument index = 1\n" + 
 			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// local + wildcard
-	// qualified allocation expression with type arguments
-	public void test030() throws Exception {
+	
+	public void test072_codeblocks_constructorInvocationTypeArgument() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"A.java",
@@ -1799,156 +3144,141 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"@interface C {\n" + 
 				"	char value() default '-';\n" + 
 				"}\n",
-				"D.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface D {\n" + 
-				"	char value() default '-';\n" + 
-				"}\n",
 				"X.java",
-				"import java.util.Map;\n" +
-				"import java.util.HashMap;\n" +
-				"@SuppressWarnings({\"unchecked\",\"rawtypes\"})\n" + 
 				"public class X {\n" + 
-				"	Object newMap(Object o) {\n" + 
-				"		Map<@A Object, ? super @C Map<@B String, @D Comparable>> map;\n" + 
-				"		if (o == null) {\n" + 
-				"			map = null;\n" + 
-				"			System.out.println(map);\n" + 
-				"		} else {\n" + 
-				"			System.out.println(\"No map yet\");\n" + 
-				"		}\n" + 
-				"		map = new HashMap();\n" + 
-				"		return map;\n" + 
-				"	} \n" + 
+				"	<T, U> X(T t, U u) {\n" + 
+				"	}\n" + 
+				"	public Object foo() {\n" + 
+				"		X x = new <@A Integer, @A String @C [] @B(1)[]>X(null, null);\n" + 
+				"		return x;\n" + 
+				"	}\n" + 
 				"}",
 		},
 		"");
 		String expectedOutput =
-			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #46 @A(\n" + 
-			"        target type = 0x9 LOCAL_VARIABLE_GENERIC_OR_ARRAY\n" + 
-			"        local variable entries:\n" + 
-			"          [pc: 6, pc: 16] index: 2\n" + 
-			"          [pc: 32, pc: 34] index: 2\n" + 
-			"        locations = {0}\n" + 
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #29 @B(\n" + 
+			"        #30 value=(int) 1 (constant type)\n" + 
+			"        target type = 0x48 CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 6\n" + 
+			"        type argument index = 1\n" + 
+			"        location = [ARRAY]\n" + 
 			"      )\n" + 
-			"      #47 @C(\n" + 
-			"        target type = 0x1c WILDCARD_BOUND\n" + 
-			"        wildcard location type = 0x9 LOCAL_VARIABLE_GENERIC_OR_ARRAY\n" + 
-			"          local variable entries:\n" + 
-			"                [pc: 6, pc: 16] index: 2\n" + 
-			"                [pc: 32, pc: 34] index: 2\n" + 
-			"              wildcard locations = {1}\n" + 
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #33 @A(\n" + 
+			"        target type = 0x48 CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 6\n" + 
+			"        type argument index = 0\n" + 
 			"      )\n" + 
-			"      #48 @D(\n" + 
-			"        target type = 0x1d WILDCARD_BOUND_GENERIC_OR_ARRAY\n" + 
-			"        wildcard location type = 0x9 LOCAL_VARIABLE_GENERIC_OR_ARRAY\n" + 
-			"          local variable entries:\n" + 
-			"                [pc: 6, pc: 16] index: 2\n" + 
-			"                [pc: 32, pc: 34] index: 2\n" + 
-			"              wildcard locations = {1}\n" + 
-			"        locations = {1}\n" + 
+			"      #33 @A(\n" + 
+			"        target type = 0x48 CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 6\n" + 
+			"        type argument index = 1\n" + 
+			"        location = [ARRAY, ARRAY]\n" + 
 			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #44 @B(\n" + 
-			"        target type = 0x1d WILDCARD_BOUND_GENERIC_OR_ARRAY\n" + 
-			"        wildcard location type = 0x9 LOCAL_VARIABLE_GENERIC_OR_ARRAY\n" + 
-			"          local variable entries:\n" + 
-			"                [pc: 6, pc: 16] index: 2\n" + 
-			"                [pc: 32, pc: 34] index: 2\n" + 
-			"              wildcard locations = {1}\n" + 
-			"        locations = {0}\n" + 
+			"      #34 @C(\n" + 
+			"        target type = 0x48 CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 6\n" + 
+			"        type argument index = 1\n" + 
 			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// method type parameter bound generic or array
-	public void test031() throws Exception {
+	public void test073_codeblocks_constructorInvocationTypeArgument() throws Exception {
 		this.runConformTest(
 			new String[] {
+				"X.java",
+				"public class X<T1, T2> {\n" + 
+				"	public void bar() {\n" + 
+				"       new <String, @A T2>X();\n"+
+				"	}\n" + 
+				"}",
+				
 				"A.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
 				"@interface A {\n" + 
 				"	String value() default \"default\";\n" + 
 				"}\n",
-				"B.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(CLASS)\n" + 
-				"@interface B {\n" + 
-				"	int value() default -1;\n" + 
-				"}",
-				"C.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(CLASS)\n" + 
-				"@interface C {\n" + 
-				"	int value() default -1;\n" + 
+				
+		},
+		"");
+		// Example bytes:11[0 1 73 0 0 0 0 0 13 0 0] this would be for offset 0
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #19 @A(\n" + 
+			"        target type = 0x48 CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 3\n" + 
+			"        type argument index = 1\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test074_codeblocks_constructorInvocationTypeArgument() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X<T1,T2> {\n" + 
+				"   public static void foo(int i) {}\n"+
+				"	public void bar() {\n" + 
+				"       new <java.util.List<@A String>, T2>X();\n"+
+				"	}\n" + 
 				"}",
-				"D.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_PARAMETER)\n" + 
-				"@Retention(RUNTIME)\n" + 
-				"@interface D {\n" + 
+				
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
 				"	String value() default \"default\";\n" + 
 				"}\n",
-				"Z.java",
-				"public class Z<T> {}",
-				"X.java",
-				"public class X {\n" +
-				"	<@D U, T extends Z<@A String @C[][]@B[]> & @B(3) Cloneable> void foo(U u, T t) {}\n" +
-				"}",
+				
 		},
 		"");
+		// Example bytes:11[0 1 73 0 0 0 0 0 13 0 0] this would be for offset 0
 		String expectedOutput =
 			"    RuntimeVisibleTypeAnnotations: \n" + 
-			"      #31 @D(\n" + 
-			"        target type = 0x20 METHOD_TYPE_PARAMETER\n" + 
-			"        type parameter index = 0\n" + 
-			"      )\n" + 
-			"      #32 @A(\n" + 
-			"        target type = 0x13 METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY\n" + 
-			"        type parameter index = 1 type parameter bound index = 0\n" + 
-			"        locations = {0,2}\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #26 @C(\n" + 
-			"        target type = 0x13 METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY\n" + 
-			"        type parameter index = 1 type parameter bound index = 0\n" + 
-			"        locations = {0}\n" + 
-			"      )\n" + 
-			"      #27 @B(\n" + 
-			"        target type = 0x13 METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY\n" + 
-			"        type parameter index = 1 type parameter bound index = 0\n" + 
-			"        locations = {0,1}\n" + 
-			"      )\n" + 
-			"      #27 @B(\n" + 
-			"        #28 value=(int) 3 (constant type)\n" + 
-			"        target type = 0x12 METHOD_TYPE_PARAMETER_BOUND\n" + 
-			"        type parameter index = 1 type parameter bound index = 1\n" + 
+			"      #23 @A(\n" + 
+			"        target type = 0x48 CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 3\n" + 
+			"        type argument index = 0\n" + 
+			"        location = [TYPE_ARGUMENT(0)]\n" +
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test075_codeblocks_constructorInvocationTypeArgument() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X<T> {\n" + 
+				"	public void bar() {\n" + 
+				"       new <@A T>X();\n"+
+				"	}\n" + 
+				"}",
+				
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				
+		},
+		"");
+		// Example bytes:11[0 1 73 0 0 0 0 0 13 0 0] this would be for offset 0
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #19 @A(\n" + 
+			"        target type = 0x48 CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 3\n" + 
+			"        type argument index = 0\n" + 
 			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// type argument method call and generic or array
-	public void test032() throws Exception {
+	
+	public void test076_codeblocks_methodInvocationTypeArgument() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"X.java",
@@ -1957,8 +3287,8 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"	static <T, U> T foo(T t, U u) {\n" +
 				"		return t;\n" +
 				"	}\n" +
-				"	public static void bar() {\n" +
-				"		System.out.println(X.<@A String[] @B(1) [], @C('-') X>foo(new String[][]{{\"SUCCESS\"}}, null)[0]);\n" +
+				"	public static void main(String[] args) {\n" +
+				"		System.out.println(X.<@A @B(1) String[], @C('-') X>foo(new String[]{\"SUCCESS\"}, null)[0]);\n" +
 				"	}\n" +
 				"}\n",
 				"A.java",
@@ -1992,203 +3322,188 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 				"	char value() default '-';\n" + 
 				"}\n",
 		},
-		"");
+		"SUCCESS");
 		String expectedOutput =
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #48 @B(\n" + 
+			"        #49 value=(int) 1 (constant type)\n" + 
+			"        target type = 0x49 METHOD_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 13\n" + 
+			"        type argument index = 0\n" + 
+			"        location = [ARRAY]\n" + 
+			"      )\n" + 
 			"    RuntimeVisibleTypeAnnotations: \n" + 
 			"      #52 @A(\n" + 
-			"        target type = 0x1b TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY\n" + 
-			"        offset = 20\n" + 
+			"        target type = 0x49 METHOD_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 13\n" + 
 			"        type argument index = 0\n" + 
-			"        locations = {1}\n" + 
+			"        location = [ARRAY]\n" + 
 			"      )\n" + 
 			"      #53 @C(\n" + 
 			"        #49 value=\'-\' (constant type)\n" + 
-			"        target type = 0x1a TYPE_ARGUMENT_METHOD_CALL\n" + 
-			"        offset = 20\n" + 
+			"        target type = 0x49 METHOD_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 13\n" + 
 			"        type argument index = 1\n" + 
-			"      )\n" + 
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #48 @B(\n" + 
-			"        #49 value=(int) 1 (constant type)\n" + 
-			"        target type = 0x1b TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY\n" + 
-			"        offset = 20\n" + 
-			"        type argument index = 0\n" + 
-			"        locations = {0}\n" + 
 			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-//	// superclass
-//	public void test033() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"Marker.java",
-//				"@interface Marker {}",
-//				"X.java",
-//				"public class X extends @Marker Object {}",
-//			},
-//			"");
-//	}
-	// superclass
-	public void test034() throws Exception {
-		this.runNegativeTest(
+	
+	public void test077_codeblocks_methodInvocationTypeArgument() throws Exception {
+		this.runConformTest(
 			new String[] {
-				"Marker.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"@Target(TYPE_PARAMETER)\n" + 
-				"@interface Marker {}",
 				"X.java",
-				"public class X extends @Marker Object {}",
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 1)\n" + 
-			"	public class X extends @Marker Object {}\n" + 
-			"	                       ^^^^^^^\n" + 
-			"The annotation @Marker is disallowed for this location\n" + 
-			"----------\n");
-	}
-//	// annotation on catch variable
-//	public void test035() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"X.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"public class X {\n" + 
-//				"	public static void main(String[] args) {\n" + 
-//				"		@A Exception test = new Exception() {\n" +
-//				"			private static final long serialVersionUID = 1L;\n" +
-//				"			@Override\n" +
-//				"			public String toString() {\n" +
-//				"				return \"SUCCESS\";\n" +
-//				"			}\n" +
-//				"		};\n" + 
-//				"		try {\n" + 
-//				"			System.out.println(test);\n" + 
-//				"		} catch(@A Exception e) {\n" + 
-//				"			e.printStackTrace();\n" + 
-//				"		}\n" + 
-//				"	}\n" + 
-//				"}",
-//				"A.java",
-//				"import java.lang.annotation.Target;\n" + 
-//				"import static java.lang.annotation.ElementType.*;\n" + 
-//				"import java.lang.annotation.Retention;\n" + 
-//				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-//				"@Target(TYPE_USE)\n" + 
-//				"@Retention(RUNTIME)\n" + 
-//				"@interface A {\n" + 
-//				"	String value() default \"default\";\n" + 
-//				"}\n",
-//		},
-//		"SUCCESS");
-//		String expectedOutput =
-//			"    RuntimeVisibleTypeAnnotations: \n" + 
-//			"      #44 @A(\n" + 
-//			"        target type = 0x8 LOCAL_VARIABLE\n" + 
-//			"        local variable entries:\n" + 
-//			"          [pc: 8, pc: 24] index: 1\n" + 
-//			"      )\n" + 
-//			"      #44 @A(\n" + 
-//			"        target type = 0x8 LOCAL_VARIABLE\n" + 
-//			"        local variable entries:\n" + 
-//			"          [pc: 19, pc: 23] index: 2\n" + 
-//			"      )\n";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-	// annotation on catch variable
-	public void test036() throws Exception {
+				"public class X<T1,T2> {\n" + 
+				"   public static void foo(int i) {}\n"+
+				"	public void bar() {\n" + 
+				"       X.<String, @A T2>foo(42);\n"+
+				"	}\n" + 
+				"}",
+				
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				
+		},
+		"");
+		// Example bytes:11[0 1 73 0 0 0 0 0 13 0 0] this would be for offset 0
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #24 @A(\n" + 
+			"        target type = 0x49 METHOD_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 2\n" + 
+			"        type argument index = 1\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test078_codeblocks_methodInvocationTypeArgument() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"X.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"public class X {\n" + 
-				"	public static void main(String[] args) {\n" + 
-				"		@B int j = 9;\n" + 
-				"		try {\n" + 
-				"			System.out.print(\"SUCCESS\" + j);\n" + 
-				"		} catch(@A Exception e) {\n" + 
-				"		}\n" + 
-				"		@B int k = 3;\n" + 
-				"		System.out.println(k);\n" + 
+				"public class X<T1,T2> {\n" + 
+				"   public static void foo(int i) {}\n"+
+				"	public void bar() {\n" + 
+				"       X.<java.util.List<@A String>, T2>foo(42);\n"+
 				"	}\n" + 
 				"}",
+				
 				"A.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(RUNTIME)\n" + 
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
+				"@interface A {\n" + 
+				"	String value() default \"default\";\n" + 
+				"}\n",
+				
+		},
+		"");
+		// Example bytes:11[0 1 73 0 0 0 0 0 13 0 0] this would be for offset 0
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #24 @A(\n" + 
+			"        target type = 0x49 METHOD_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 2\n" + 
+			"        type argument index = 0\n" + 
+			"        location = [TYPE_ARGUMENT(0)]\n" +
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test079_codeblocks_methodInvocationTypeArgument() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X<T> {\n" + 
+				"   public static void foo(int i) {}\n"+
+				"	public void bar() {\n" + 
+				"       X.<@A T>foo(42);\n"+
+				"	}\n" + 
+				"}",
+				
+				"A.java",
+				"import java.lang.annotation.*;\n" + 
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
 				"@interface A {\n" + 
 				"	String value() default \"default\";\n" + 
 				"}\n",
+		},
+		"");
+		// Example bytes:11[0 1 73 0 0 0 0 0 13 0 0] this would be for offset 0
+		String expectedOutput =
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #24 @A(\n" + 
+			"        target type = 0x49 METHOD_INVOCATION_TYPE_ARGUMENT\n" + 
+			"        offset = 2\n" + 
+			"        type argument index = 0\n" + 
+			"      )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	
+	// Annotation should appear twice in this case
+	public void test080_multiuseAnnotations() throws Exception {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	 @B(1) int foo() { return 0; }\n" +
+				"}",
 				"B.java",
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"import java.lang.annotation.Retention;\n" + 
-				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
-				"@Target(TYPE_USE)\n" + 
-				"@Retention(CLASS)\n" + 
+				"import java.lang.annotation.*;\n" +   
+				"@Target({ElementType.METHOD, ElementType.TYPE_USE})\n" + 
+				"@Retention(RetentionPolicy.RUNTIME)\n" + 
 				"@interface B {\n" + 
-				"	String value() default \"default\";\n" + 
+				"	int value() default 99;\n" + 
 				"}\n",
 		},
-		"SUCCESS93");
+		"");
 		String expectedOutput =
-			"    RuntimeInvisibleTypeAnnotations: \n" + 
-			"      #56 @B(\n" + 
-			"        target type = 0x8 LOCAL_VARIABLE\n" + 
-			"        local variable entries:\n" + 
-			"          [pc: 3, pc: 39] index: 1\n" + 
+			"    RuntimeVisibleAnnotations: \n" + 
+			"      #17 @B(\n" + 
+			"        #18 value=(int) 1 (constant type)\n" + 
 			"      )\n" + 
-			"      #56 @B(\n" + 
-			"        target type = 0x8 LOCAL_VARIABLE\n" + 
-			"        local variable entries:\n" + 
-			"          [pc: 31, pc: 39] index: 2\n" + 
+			"    RuntimeVisibleTypeAnnotations: \n" + 
+			"      #17 @B(\n" + 
+			"        #18 value=(int) 1 (constant type)\n" + 
+			"        target type = 0x14 METHOD_RETURN\n" + 
 			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// make sure annotation without target appears twice when set on a method declaration
-	public void test037() throws Exception {
+	
+	public void test081_multiuseAnnotations() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"X.java",
-				"import java.lang.annotation.Target;\r\n" + 
-				"import static java.lang.annotation.ElementType.*;\r\n" + 
-				"\r\n" + 
-				"@Target(METHOD)\r\n" + 
-				"@interface Annot {\r\n" + 
-				"	int value() default 0;\r\n" + 
-				"}\r\n" + 
-				"public class X {\r\n" + 
-				"	@Annot(4)\r\n" + 
-				"	public void foo() {\r\n" + 
-				"	}\r\n" + 
+				"import java.lang.annotation.*;\n" + 
+				"@Target({ElementType.METHOD, ElementType.TYPE_USE})\n" + 
+				"@interface Annot {\n" + 
+				"	int value() default 0;\n" + 
+				"}\n" + 
+				"public class X {\n" + 
+				"	@Annot(4) public String foo() { return \"hello\"; }" +
 				"}",
 		},
 		"");
 		String expectedOutput =
-			"  public void foo();\n" + 
-			"    0  return\n" + 
-			"      Line numbers:\n" + 
-			"        [pc: 0, line: 11]\n" + 
-			"      Local variable table:\n" + 
-			"        [pc: 0, pc: 1] local: this index: 0 type: X\n" + 
 			"    RuntimeInvisibleAnnotations: \n" + 
-			"      #16 @Annot(\n" + 
-			"        #17 value=(int) 4 (constant type)\n" + 
+			"      #17 @Annot(\n" + 
+			"        #18 value=(int) 4 (constant type)\n" + 
 			"      )\n" + 
-			"}";
+			"    RuntimeInvisibleTypeAnnotations: \n" + 
+			"      #17 @Annot(\n" + 
+			"        #18 value=(int) 4 (constant type)\n" + 
+			"        target type = 0x14 METHOD_RETURN\n" + 
+			"      )\n";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-	// make sure annotation without target appears twice when set on a method declaration
-	public void test038() throws Exception {
+	
+	// When not annotated with any TYPE it assumes the Java7 set (i.e. not TYPE_USE/TYPE_PARAMETER)
+	public void test082_multiuseAnnotations() throws Exception {
 		this.runConformTest(
 			new String[] {
 				"X.java",
@@ -2218,75 +3533,856 @@ public class TypeAnnotationTest extends AbstractRegressionTest {
 			"}";
 		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
-//	// make sure annotation without target appears twice when set on a method declaration
-//	public void test039() throws Exception {
-//		this.runConformTest(
-//			new String[] {
-//				"X.java",
-//				"@interface Annot {\r\n" + 
-//				"	int value() default 0;\r\n" + 
-//				"}\r\n" + 
-//				"public class X {\r\n" + 
-//				"	@Annot(4)\r\n" + 
-//				"	public int foo() {\r\n" + 
-//				"		return 0;\r\n" + 
-//				"	}\r\n" + 
-//				"}",
-//		},
-//		"");
-//		String expectedOutput =
-//			"  public int foo();\n" + 
-//			"    0  iconst_0\n" + 
-//			"    1  ireturn\n" + 
-//			"      Line numbers:\n" + 
-//			"        [pc: 0, line: 7]\n" + 
-//			"      Local variable table:\n" + 
-//			"        [pc: 0, pc: 2] local: this index: 0 type: X\n" + 
-//			"    RuntimeInvisibleAnnotations: \n" + 
-//			"      #17 @Annot(\n" + 
-//			"        #18 value=(int) 4 (constant type)\n" + 
-//			"      )\n" + 
-//			"    RuntimeInvisibleTypeAnnotations: \n" + 
-//			"      #17 @Annot(\n" + 
-//			"        #18 value=(int) 4 (constant type)\n" + 
-//			"        target type = 0xa METHOD_RETURN_TYPE\n" + 
-//			"      )\n" + 
-//			"}";
-//		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-//	}
-	// make sure annotation without target appears twice when set on a method declaration
-	public void test040() throws Exception {
-		this.runConformTest(
-			new String[] {
-				"X.java",
-				"import java.lang.annotation.Target;\r\n" + 
-				"import static java.lang.annotation.ElementType.*;\r\n" + 
-				"\r\n" + 
-				"@Target(METHOD)\r\n" + 
-				"@interface Annot {\r\n" + 
-				"	int value() default 0;\r\n" + 
-				"}\r\n" + 
-				"public class X {\r\n" + 
-				"	@Annot(4)\r\n" + 
-				"	public int foo() {\r\n" + 
-				"		return 0;\r\n" + 
-				"	}\r\n" + 
-				"}",
-		},
-		"");
-		String expectedOutput =
-			"  public int foo();\n" + 
-			"    0  iconst_0\n" + 
-			"    1  ireturn\n" + 
-			"      Line numbers:\n" + 
-			"        [pc: 0, line: 11]\n" + 
-			"      Local variable table:\n" + 
-			"        [pc: 0, pc: 2] local: this index: 0 type: X\n" + 
-			"    RuntimeInvisibleAnnotations: \n" + 
-			"      #17 @Annot(\n" + 
-			"        #18 value=(int) 4 (constant type)\n" + 
-			"      )\n" + 
-			"}";
-		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	
+	public void test100_pqtr() throws Exception { // PQTR (ParameterizedQualifiedTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  java.util.@B(2) List<String> field2;\n" +
+					"}\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #10 @B(\n" + 
+					"        #11 value=(int) 2 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	public void test100a_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  java.util.@B(2) List<String>[] field3;\n" +
+					"}\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #10 @B(\n" + 
+					"        #11 value=(int) 2 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY]\n" +
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test100b_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  java.util.List<@B(3) String>[] field3;\n" +
+					"}\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #10 @B(\n" + 
+					"        #11 value=(int) 3 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, TYPE_ARGUMENT(0)]\n" +
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	public void test100c_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  java.util.List<String> @B(3)[] field3;\n" +
+					"}\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #10 @B(\n" + 
+					"        #11 value=(int) 3 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test100d_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  java.util.@B(2) List<@B(5) String> @B(3)[]@B(4)[] field;\n" +
+					"}\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #10 @B(\n" + 
+					"        #11 value=(int) 2 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY]\n" +
+					"      )\n" +
+					"      #10 @B(\n" + 
+					"        #11 value=(int) 3 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"      )\n" +
+					"      #10 @B(\n" + 
+					"        #11 value=(int) 4 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY]\n" +
+					"      )\n" +
+					"      #10 @B(\n" + 
+					"        #11 value=(int) 5 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, TYPE_ARGUMENT(0)]\n" +
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+
+	public void test100e_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  java.util.Map.@B(2) Entry<String,String> field;\n" +
+					"}\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test100f_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"Foo.java",
+					"class Foo {}\n",
+					
+					"Levels.java",
+					"package one.two.three;\n" +
+					"class Level1 { static class Level2 { class Level3 { class Level4 { class Level5<T> { } } } } }\n",
+					
+					"X.java",
+					"package one.two.three;\n" +
+					"class X {\n" +
+					"  one.two.three.Level1.Level2.@B(2) Level3.Level4.@B(3) Level5<String> instance;\n" +
+					"}\n",
+
+					"B.java",
+					"package one.two.three;\n" +
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @one.two.three.B(\n" + 
+				"        #11 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [INNER_TYPE]\n" + 
+				"      )\n" + 
+				"      #10 @one.two.three.B(\n" + 
+				"        #11 value=(int) 3 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [INNER_TYPE, INNER_TYPE, INNER_TYPE]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "one" + File.separator + "two" + File.separator + "three" + File.separator + "X.class", "one.two.three.X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test100g_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"Foo.java",
+					"class Foo {}\n",
+					
+					"Levels.java",
+					"package one.two.three;\n" +
+					"class Level1 { static class Level2 { class Level3 { class Level4 { class Level5<T> { } } } } }\n",
+					
+					"X.java",
+					"package one.two.three;\n" +
+					"class X {\n" +
+					"  one.two.three.Level1.Level2.@B(2) Level3.Level4.@B(3) Level5<String>[][] instance;\n" +
+					"}\n",
+
+					"B.java",
+					"package one.two.three;\n" +
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @one.two.three.B(\n" + 
+				"        #11 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY, INNER_TYPE]\n" + 
+				"      )\n" + 
+				"      #10 @one.two.three.B(\n" + 
+				"        #11 value=(int) 3 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY, INNER_TYPE, INNER_TYPE, INNER_TYPE]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "one" + File.separator + "two" + File.separator + "three" + File.separator + "X.class", "one.two.three.X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test100h_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  Level1.Level2.@B(2) Level3.Level4.@B(3) Level5<String>[][] instance;\n" +
+					"}\n",
+
+					"Levels.java",
+					"class Level1 { static class Level2 { class Level3 { class Level4 { class Level5<T> { } } } } }\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY, INNER_TYPE]\n" + 
+				"      )\n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 3 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY, INNER_TYPE, INNER_TYPE, INNER_TYPE]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test100i_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  Level1.Level2.Level3.Level4.Level5<@B(1) String>[][] instance;\n" +
+					"}\n",
+
+					"Levels.java",
+					"class Level1 { static class Level2 { class Level3 { class Level4 { class Level5<T> { } } } } }\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 1 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY, INNER_TYPE, INNER_TYPE, INNER_TYPE, TYPE_ARGUMENT(0)]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test100j_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  Level1.Level2.Level3<@B(1) String>.Level4.Level5<@B(2) String>[][] instance;\n" +
+					"}\n",
+
+					"Levels.java",
+					"class Level1 { static class Level2 { class Level3<Q> { class Level4 { class Level5<T> { } } } } }\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 1 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY, INNER_TYPE, TYPE_ARGUMENT(0)]\n" + 
+				"      )\n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY, INNER_TYPE, INNER_TYPE, INNER_TYPE, TYPE_ARGUMENT(0)]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test100k_pqtr() throws Exception {
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  Level1.@B(5) Level2.Level3<@B(1) String>.Level4.Level5<@B(2) String>[][] instance;\n" +
+					"}\n",
+
+					"Levels.java",
+					"class Level1 { static class Level2 { class Level3<Q> { class Level4 { class Level5<T> { } } } } }\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 5 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY]\n" + 
+				"      )\n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 1 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY, INNER_TYPE, TYPE_ARGUMENT(0)]\n" + 
+				"      )\n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY, INNER_TYPE, INNER_TYPE, INNER_TYPE, TYPE_ARGUMENT(0)]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test101a_qtr() throws Exception { // QTR (QualifiedTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"    com.foo.@B(2) List field2;\n" +
+					"}\n",
+					
+					"List.java",
+					"package com.foo;\n"+
+					"public class List {}\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #8 @B(\n" + 
+					"        #9 value=(int) 2 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+
+	
+	public void test101b_qtr() throws Exception { // QTR (QualifiedTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"  java.util.Map.@B(2) Entry field;\n" +
+					"}\n",
+
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #8 @B(\n" + 
+				"        #9 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test101c_qtr() throws Exception { // QTR (QualifiedTypeReference)
+		this.runConformTest(
+				new String[] {
+					"Runner.java",
+					"public class Runner {}\n",
+					
+					"B.java",
+					"package one.two.three;\n" +
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+
+					"X.java",
+					"package one.two.three;\n" +
+					"class X {\n" +
+					"    one.two.three.Level1.Level2.@B(2) Level3.Level4.@B(3) Level5 instance;\n" +
+					"}\n",
+
+					"Level1.java",
+					"package one.two.three;\n" +
+					"public class Level1 { static class Level2 { class Level3 { class Level4 { class Level5 { } } } } }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #8 @one.two.three.B(\n" + 
+				"        #9 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [INNER_TYPE]\n" + 
+				"      )\n" + 
+				"      #8 @one.two.three.B(\n" + 
+				"        #9 value=(int) 3 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [INNER_TYPE, INNER_TYPE, INNER_TYPE]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "one" + File.separator + "two" + File.separator + "three" + File.separator + "X.class", "one.two.three.X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test102a_str() throws Exception { // STR (SingleTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"    @B(1) X field;\n" +
+					"}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #8 @B(\n" + 
+					"        #9 value=(int) 1 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test102b_str() throws Exception { // STR (SingleTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"    @B(1) int field;\n" +
+					"}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #8 @B(\n" + 
+					"        #9 value=(int) 1 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test103a_atr() throws Exception { // ATR (ArrayTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"    @B(1) X[] field;\n" +
+					"}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #8 @B(\n" + 
+					"        #9 value=(int) 1 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY]\n" +
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test103b_atr() throws Exception { // ATR (ArrayTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"    X @B(2)[] field;\n" +
+					"}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #8 @B(\n" + 
+					"        #9 value=(int) 2 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test103c_atr() throws Exception { // ATR (ArrayTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"    X []@B(3)[] field;\n" +
+					"}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #8 @B(\n" + 
+					"        #9 value=(int) 3 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY]\n" +
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test103d_atr() throws Exception { // ATR (ArrayTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"    X []@B(3)[][] field;\n" +
+					"}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #8 @B(\n" + 
+					"        #9 value=(int) 3 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY]\n" +
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test103e_atr() throws Exception { // ATR (ArrayTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"    @B(1) int []@B(3)[][] field;\n" +
+					"}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+					"    RuntimeVisibleTypeAnnotations: \n" + 
+					"      #8 @B(\n" + 
+					"        #9 value=(int) 1 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY, ARRAY, ARRAY]\n" +
+					"      )\n" +
+					"      #8 @B(\n" + 
+					"        #9 value=(int) 3 (constant type)\n" + 
+					"        target type = 0x13 FIELD\n" + 
+					"        location = [ARRAY]\n" +
+					"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test104a_pstr() throws Exception { // PSTR (ParameterizedSingleTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X<T1,T2,T3> {\n" +
+					"    @B(1) X<@B(2) String, @B(3) Integer, @B(4) Boolean> field;\n" +
+					"}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 1 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"      )\n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [TYPE_ARGUMENT(0)]\n" + 
+				"      )\n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 3 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [TYPE_ARGUMENT(1)]\n" + 
+				"      )\n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 4 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [TYPE_ARGUMENT(2)]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test104b_pstr() throws Exception { // PSTR (ParameterizedSingleTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"class X<T1> {\n" +
+					"    @B(1) X<@B(2) String> @B(3)[] field;\n" +
+					"}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 1 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY]\n" + 
+				"      )\n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 3 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"      )\n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, TYPE_ARGUMENT(0)]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test105a_aqtr() throws Exception { // AQTR (ArrayQualifiedTypeReference)
+		this.runConformTest(
+				new String[] {
+					"Y.java",
+					"class Y {}",
+					
+					"X.java",
+					"package one.two.three;\n" +
+					"class X<T1> {\n" +
+					"    one.two.three.@B(1) List[] field;\n" +
+					"}\n",
+					
+					"List.java",
+					"package one.two.three;\n" +
+					"class List {}\n",
+					
+					"B.java",
+					"package one.two.three;\n" +
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #8 @one.two.three.B(\n" + 
+				"        #9 value=(int) 1 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "one" + File.separator + "two" + File.separator + "three" + File.separator +"X.class", 
+					"one.two.three.X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test105b_aqtr() throws Exception { // AQTR (ArrayQualifiedTypeReference)
+		this.runConformTest(
+				new String[] {
+					"Y.java",
+					"class Y {}",
+					
+					"X.java",
+					"package one.two.three;\n" +
+					"class X<T1> {\n" +
+					"    one.two.three.@B(2) List @B(3)[]@B(4)[] field;\n" +
+					"}\n",
+					
+					"List.java",
+					"package one.two.three;\n" +
+					"class List {}\n",
+					
+					"B.java",
+					"package one.two.three;\n" +
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #8 @one.two.three.B(\n" + 
+				"        #9 value=(int) 2 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY, ARRAY]\n" + 
+				"      )\n" +
+				"      #8 @one.two.three.B(\n" + 
+				"        #9 value=(int) 3 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"      )\n" +
+				"      #8 @one.two.three.B(\n" + 
+				"        #9 value=(int) 4 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [ARRAY]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "one" + File.separator + "two" + File.separator + "three" + File.separator +"X.class", 
+					"one.two.three.X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test106a_wtr() throws Exception { // WTR (WildcardTypeReference)
+		this.runConformTest(
+				new String[] {					
+					"X.java",
+					"import java.util.List;\n" +
+					"class X<T1> {\n" +
+					"	 List<? extends @B(1) Number> field;\n" +
+					"}\n",
+					
+					"List.java",
+					"class List {}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 1 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [TYPE_ARGUMENT(0), WILDCARD]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator +"X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	
+	public void test106b_wtr() throws Exception { // WTR (WildcardTypeReference)
+		this.runConformTest(
+				new String[] {
+					"X.java",
+					"import java.util.List;\n" +
+					"class X<T1> {\n" +
+					"	 List<? extends @B(1) Number[]> field;\n" +
+					"}\n",
+					
+					"List.java",
+					"class List {}\n",
+					
+					"B.java",
+					"import java.lang.annotation.*;\n" + 
+					"@Target(ElementType.TYPE_USE)\n" + 
+					"@Retention(RetentionPolicy.RUNTIME)\n" + 
+					"@interface B { int value() default -1; }\n",
+			},
+			"");
+			String expectedOutput =
+				"    RuntimeVisibleTypeAnnotations: \n" + 
+				"      #10 @B(\n" + 
+				"        #11 value=(int) 1 (constant type)\n" + 
+				"        target type = 0x13 FIELD\n" + 
+				"        location = [TYPE_ARGUMENT(0), WILDCARD, ARRAY]\n" + 
+				"      )\n";
+			checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
 	}
+	
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index 4e5ef34..de16a05 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -13,6 +13,8 @@
  *     IBM Corporation - initial API and implementation
  *     Jesper S Moller - Contributions for
  *							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335             
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler;
 
@@ -26,7 +28,6 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.Stack;
 
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
 import org.eclipse.jdt.core.compiler.CharOperation;
@@ -46,15 +47,13 @@ import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;
-import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
-import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
+import org.eclipse.jdt.internal.compiler.ast.Receiver;
 import org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;
 import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.AnnotationContext;
 import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
@@ -62,19 +61,19 @@ import org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants;
 import org.eclipse.jdt.internal.compiler.codegen.CodeStream;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
 import org.eclipse.jdt.internal.compiler.codegen.ExceptionLabel;
+import org.eclipse.jdt.internal.compiler.codegen.MultiCatchExceptionLabel;
 import org.eclipse.jdt.internal.compiler.codegen.Opcodes;
 import org.eclipse.jdt.internal.compiler.codegen.StackMapFrame;
 import org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream;
 import org.eclipse.jdt.internal.compiler.codegen.TypeAnnotationCodeStream;
-import org.eclipse.jdt.internal.compiler.codegen.VerificationTypeInfo;
 import org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream.ExceptionMarker;
 import org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream.StackDepthMarker;
 import org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream.StackMarker;
+import org.eclipse.jdt.internal.compiler.codegen.VerificationTypeInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.impl.StringConstant;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
-import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
@@ -250,75 +249,6 @@ public class ClassFile implements TypeConstants, TypeIds {
 		LookupEnvironment env = typeBinding.scope.environment();
 		return env.classFilePool.acquire(typeBinding);
 	}
-
-	/**
-	 * Return the location for the corresponding annotation inside the type reference, <code>null</code> if none.
-	 */
-	private static int[] getWildcardLocations(TypeReference reference, Wildcard wildcard) {
-		class LocationCollector extends ASTVisitor {
-			Stack currentIndexes;
-			boolean search = true;
-			Wildcard currentWildcard;
-			
-			public LocationCollector(Wildcard currentWildcard) {
-				this.currentIndexes = new Stack();
-				this.currentWildcard = currentWildcard;
-			}
-			public boolean visit(ParameterizedSingleTypeReference typeReference, BlockScope scope) {
-				if (!this.search) return false;
-				TypeReference[] typeReferences = typeReference.typeArguments;
-				this.currentIndexes.push(new Integer(0));
-				for (int i = 0, max = typeReferences.length; i < max; i++) {
-					typeReferences[i].traverse(this, scope);
-					if (!this.search) return false;
-					this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
-				}
-				this.currentIndexes.pop();
-				return true;
-			}
-			public boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {
-				if (!this.search) return false;
-				TypeReference[] typeReferences = typeReference.typeArguments[typeReference.typeArguments.length - 1];
-				this.currentIndexes.push(new Integer(0));
-				for (int i = 0, max = typeReferences.length; i < max; i++) {
-					typeReferences[i].traverse(this, scope);
-					if (!this.search) return false;
-					this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
-				}
-				this.currentIndexes.pop();
-				return true;
-			}
-			public boolean visit(Wildcard typeReference, BlockScope scope) {
-				if (!this.search) return false;
-				if (typeReference.equals(this.currentWildcard)) {
-					this.search = false;
-				}
-				return true;
-			}
-			public String toString() {
-				StringBuffer buffer = new StringBuffer();
-				buffer
-					.append("search location for ") //$NON-NLS-1$
-					.append(this.currentWildcard)
-					.append("\ncurrent indexes : ") //$NON-NLS-1$
-					.append(this.currentIndexes);
-				return String.valueOf(buffer);
-			}
-		}
-		if (reference == null) return null;
-		LocationCollector collector = new LocationCollector(wildcard);
-		reference.traverse(collector, (BlockScope) null);
-		if (collector.currentIndexes.isEmpty()) {
-			return null;
-		}
-		int size = collector.currentIndexes.size();
-		int[] result = new int[size];
-		for (int i = 0; i < size; i++) {
-			result[size - i - 1] = ((Integer) collector.currentIndexes.pop()).intValue();
-		}
-		return result;
-	}
-
 	/**
 	 * INTERNAL USE-ONLY
 	 * This methods creates a new instance of the receiver.
@@ -337,7 +267,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 		this.isNestedType = typeBinding.isNestedType();
 		if (this.targetJDK >= ClassFileConstants.JDK1_6) {
 			this.produceAttributes |= ClassFileConstants.ATTR_STACK_MAP_TABLE;
-			if (this.targetJDK >= ClassFileConstants.JDK1_7) {
+			if (this.targetJDK >= ClassFileConstants.JDK1_8) {
 				this.produceAttributes |= ClassFileConstants.ATTR_TYPE_ANNOTATION;
 				this.codeStream = new TypeAnnotationCodeStream(this);
 			} else {
@@ -461,6 +391,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 		}
 		
 		attributesNumber += generateTypeAnnotationAttributeForTypeDeclaration();
+		
 		// update the number of attributes
 		if (attributeOffset + 2 >= this.contents.length) {
 			resizeContents(2);
@@ -515,41 +446,40 @@ public class ClassFile implements TypeConstants, TypeIds {
 			FieldDeclaration fieldDeclaration = fieldBinding.sourceField();
 			if (fieldDeclaration != null) {
 				Annotation[] annotations = fieldDeclaration.annotations;
-				List allTypeAnnotationContexts = new ArrayList();
-				int invisibleTypeAnnotationsCounter = 0;
-				int visibleTypeAnnotationsCounter = 0;
 				if (annotations != null) {
 					attributesNumber += generateRuntimeAnnotations(annotations);
-					if ((this.produceAttributes & ClassFileConstants.ATTR_TYPE_ANNOTATION) != 0) {
-						if ((fieldDeclaration.bits & ASTNode.HasTypeAnnotations) != 0) {
-							fieldDeclaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.FIELD, allTypeAnnotationContexts);
-						}
-					}
 				}
-				TypeReference fieldType = fieldDeclaration.type;
-				if (fieldType != null 
-						&& ((this.produceAttributes & ClassFileConstants.ATTR_TYPE_ANNOTATION) != 0)
-						&& ((fieldType.bits & ASTNode.HasTypeAnnotations) != 0)) {
-					fieldType.getAllAnnotationContexts(AnnotationTargetTypeConstants.FIELD, allTypeAnnotationContexts);
-				}
-				int size = allTypeAnnotationContexts.size();
-				if (size != 0) {
-					AnnotationContext[] allTypeAnnotationContextsArray = new AnnotationContext[size];
-					allTypeAnnotationContexts.toArray(allTypeAnnotationContextsArray);
-					for (int i = 0, max = allTypeAnnotationContextsArray.length; i < max; i++) {
-						AnnotationContext annotationContext = allTypeAnnotationContextsArray[i];
-						if ((annotationContext.visibility & AnnotationContext.INVISIBLE) != 0) {
-							invisibleTypeAnnotationsCounter++;
-							allTypeAnnotationContexts.add(annotationContext);
-						} else {
-							visibleTypeAnnotationsCounter++;
-							allTypeAnnotationContexts.add(annotationContext);
+
+				if ((this.produceAttributes & ClassFileConstants.ATTR_TYPE_ANNOTATION) != 0) {
+					List allTypeAnnotationContexts = new ArrayList();
+					if (annotations != null && (fieldDeclaration.bits & ASTNode.HasTypeAnnotations) != 0) {
+						fieldDeclaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.FIELD, allTypeAnnotationContexts);
+					}
+					int invisibleTypeAnnotationsCounter = 0;
+					int visibleTypeAnnotationsCounter = 0;
+					TypeReference fieldType = fieldDeclaration.type;
+					if (fieldType != null && ((fieldType.bits & ASTNode.HasTypeAnnotations) != 0)) {
+						fieldType.getAllAnnotationContexts(AnnotationTargetTypeConstants.FIELD, allTypeAnnotationContexts);
+					}
+					int size = allTypeAnnotationContexts.size();
+					if (size != 0) {
+						AnnotationContext[] allTypeAnnotationContextsArray = new AnnotationContext[size];
+						allTypeAnnotationContexts.toArray(allTypeAnnotationContextsArray);
+						for (int i = 0, max = allTypeAnnotationContextsArray.length; i < max; i++) {
+							AnnotationContext annotationContext = allTypeAnnotationContextsArray[i];
+							if ((annotationContext.visibility & AnnotationContext.INVISIBLE) != 0) {
+								invisibleTypeAnnotationsCounter++;
+								allTypeAnnotationContexts.add(annotationContext);
+							} else {
+								visibleTypeAnnotationsCounter++;
+								allTypeAnnotationContexts.add(annotationContext);
+							}
 						}
+						attributesNumber += generateRuntimeTypeAnnotations(
+								allTypeAnnotationContextsArray,
+								visibleTypeAnnotationsCounter,
+								invisibleTypeAnnotationsCounter);
 					}
-					attributesNumber += generateRuntimeTypeAnnotations(
-							allTypeAnnotationContextsArray,
-							visibleTypeAnnotationsCounter,
-							invisibleTypeAnnotationsCounter);
 				}
 			}
 		}
@@ -1432,6 +1362,10 @@ public class ClassFile implements TypeConstants, TypeIds {
 					max_locals,
 					false);
 		}
+		
+		if ((this.produceAttributes & ClassFileConstants.ATTR_TYPE_ANNOTATION) != 0) {
+			attributesNumber += generateTypeAnnotationsOnCodeAttribute();
+		}
 
 		this.contents[codeAttributeAttributeOffset++] = (byte) (attributesNumber >> 8);
 		this.contents[codeAttributeAttributeOffset] = (byte) attributesNumber;
@@ -1443,6 +1377,62 @@ public class ClassFile implements TypeConstants, TypeIds {
 		this.contents[codeAttributeOffset + 4] = (byte) (codeAttributeLength >> 8);
 		this.contents[codeAttributeOffset + 5] = (byte) codeAttributeLength;
 	}
+	
+	public int generateTypeAnnotationsOnCodeAttribute() {
+		int attributesNumber = 0;
+		
+		List allTypeAnnotationContexts = ((TypeAnnotationCodeStream) this.codeStream).allTypeAnnotationContexts;
+		int invisibleTypeAnnotationsCounter = 0;
+		int visibleTypeAnnotationsCounter = 0;
+
+		for (int i = 0, max = this.codeStream.allLocalsCounter; i < max; i++) {
+			LocalVariableBinding localVariable = this.codeStream.locals[i];
+			if (localVariable.isCatchParameter()) continue;
+			LocalDeclaration declaration = localVariable.declaration;
+			if (declaration == null
+					|| (declaration.isArgument() && ((declaration.bits & ASTNode.IsUnionType) == 0))
+					|| (localVariable.initializationCount == 0)
+					|| ((declaration.bits & ASTNode.HasTypeAnnotations) == 0)) {
+				continue;
+			}
+			int targetType = ((localVariable.tagBits & TagBits.IsResource) == 0) ? AnnotationTargetTypeConstants.LOCAL_VARIABLE : AnnotationTargetTypeConstants.RESOURCE_VARIABLE;
+			declaration.getAllAnnotationContexts(targetType, localVariable, allTypeAnnotationContexts);
+		}
+		
+		ExceptionLabel[] exceptionLabels = this.codeStream.exceptionLabels;
+		int tableIndex = 0;
+		for (int i = 0, max = this.codeStream.exceptionLabelsCounter; i < max; i++) {
+			ExceptionLabel exceptionLabel = exceptionLabels[i];
+			if (exceptionLabel instanceof MultiCatchExceptionLabel) {
+				MultiCatchExceptionLabel multiCatchExceptionLabel = (MultiCatchExceptionLabel)exceptionLabel;
+				tableIndex += multiCatchExceptionLabel.getAllAnnotationContexts(tableIndex, allTypeAnnotationContexts);
+			} else {
+				if (exceptionLabel.exceptionTypeReference != null) { // ignore those which cannot be annotated
+					exceptionLabel.exceptionTypeReference.getAllAnnotationContexts(AnnotationTargetTypeConstants.EXCEPTION_PARAMETER, tableIndex, allTypeAnnotationContexts);
+				}
+				tableIndex++;
+			}
+		}
+		
+		int size = allTypeAnnotationContexts.size();
+		if (size != 0) {
+			AnnotationContext[] allTypeAnnotationContextsArray = new AnnotationContext[size];
+			allTypeAnnotationContexts.toArray(allTypeAnnotationContextsArray);
+			for (int j = 0, max2 = allTypeAnnotationContextsArray.length; j < max2; j++) {
+				AnnotationContext annotationContext = allTypeAnnotationContextsArray[j];
+				if ((annotationContext.visibility & AnnotationContext.INVISIBLE) != 0) {
+					invisibleTypeAnnotationsCounter++;
+				} else {
+					visibleTypeAnnotationsCounter++;
+				}
+			}
+			attributesNumber += generateRuntimeTypeAnnotations(
+					allTypeAnnotationContextsArray,
+					visibleTypeAnnotationsCounter,
+					invisibleTypeAnnotationsCounter);
+		}
+		return attributesNumber;
+	}
 
 	/**
 	 * INTERNAL USE-ONLY
@@ -2071,22 +2061,11 @@ public class ClassFile implements TypeConstants, TypeIds {
 			MethodBinding binding,
 			int methodAttributeOffset,
 			int attributesNumber) {
-
+		
 		if ((this.produceAttributes & ClassFileConstants.ATTR_TYPE_ANNOTATION) != 0) {
-			List allTypeAnnotationContexts = ((TypeAnnotationCodeStream) this.codeStream).allTypeAnnotationContexts;
+			List allTypeAnnotationContexts = new ArrayList();
 			int invisibleTypeAnnotationsCounter = 0;
 			int visibleTypeAnnotationsCounter = 0;
-			for (int i = 0, max = this.codeStream.allLocalsCounter; i < max; i++) {
-				LocalVariableBinding localVariable = this.codeStream.locals[i];
-				LocalDeclaration declaration = localVariable.declaration;
-				if (declaration == null
-						|| (declaration.isArgument() && ((declaration.bits & ASTNode.IsUnionType) == 0))
-						|| (localVariable.initializationCount == 0)
-						|| ((declaration.bits & ASTNode.HasTypeAnnotations) == 0)) {
-					continue;
-				}
-				declaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.LOCAL_VARIABLE, localVariable, allTypeAnnotationContexts);
-			}
 			AbstractMethodDeclaration methodDeclaration = binding.sourceMethod();
 			if (methodDeclaration != null) {
 				if ((methodDeclaration.bits & ASTNode.HasTypeAnnotations) != 0) {
@@ -2095,37 +2074,24 @@ public class ClassFile implements TypeConstants, TypeIds {
 						for (int i = 0, max = arguments.length; i < max; i++) {
 							Argument argument = arguments[i];
 							if ((argument.bits & ASTNode.HasTypeAnnotations) != 0) {
-								argument.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_PARAMETER, i, allTypeAnnotationContexts);
+								argument.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_FORMAL_PARAMETER, i, allTypeAnnotationContexts);
 							}
 						}
 					}
-					Annotation[] annotations = (methodDeclaration.receiver==null?null:methodDeclaration.receiver.annotations);
-					if (annotations != null) {
-						for (int i = 0, max = annotations.length; i < max; i++) {
-							Annotation annotation = annotations[i];
-							AnnotationContext annotationContext = null;
-							if (annotation.isRuntimeTypeInvisible()) {
-								annotationContext = new AnnotationContext(annotation, null, AnnotationTargetTypeConstants.METHOD_RECEIVER, null, AnnotationContext.INVISIBLE, null);
-								invisibleTypeAnnotationsCounter++;
-							} else if (annotation.isRuntimeTypeVisible()) {
-								annotationContext = new AnnotationContext(annotation, null, AnnotationTargetTypeConstants.METHOD_RECEIVER, null, AnnotationContext.VISIBLE, null);
-								visibleTypeAnnotationsCounter++;
-							}
-							if (annotationContext != null) {
-								allTypeAnnotationContexts.add(annotationContext);
-							}
-						}
+					Receiver receiver = methodDeclaration.receiver;
+					if (receiver != null && (receiver.type.bits & ASTNode.HasTypeAnnotations) != 0) {
+						receiver.type.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RECEIVER, allTypeAnnotationContexts);
 					}
 				}
 				Annotation[] annotations = methodDeclaration.annotations;
 				if (annotations != null && binding.returnType.id != T_void) {
-					methodDeclaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RETURN_TYPE, allTypeAnnotationContexts);
+					methodDeclaration.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RETURN, allTypeAnnotationContexts);
 				}
 				if (!methodDeclaration.isConstructor() && !methodDeclaration.isClinit() && binding.returnType.id != T_void) {
 					MethodDeclaration declaration = (MethodDeclaration) methodDeclaration;
 					TypeReference typeReference = declaration.returnType;
 					if ((typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
-						typeReference.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RETURN_TYPE, allTypeAnnotationContexts);
+						typeReference.getAllAnnotationContexts(AnnotationTargetTypeConstants.METHOD_RETURN, allTypeAnnotationContexts);
 					}
 				}
 				TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;
@@ -2163,21 +2129,24 @@ public class ClassFile implements TypeConstants, TypeIds {
 						invisibleTypeAnnotationsCounter);
 			}
 		}
-
 		// update the number of attributes
 		this.contents[methodAttributeOffset++] = (byte) (attributesNumber >> 8);
 		this.contents[methodAttributeOffset] = (byte) attributesNumber;
 	}
-
+	
 	private void dumpLocations(int[] locations) {
-		if (locations != null) {
+		if (locations == null) {
+			// no type path
+			if (this.contentsOffset + 1 >= this.contents.length) {
+				resizeContents(1);
+			}
+			this.contents[this.contentsOffset++] = (byte) 0;
+		} else {
 			int length = locations.length;
-			int actualSize = 2 + length;
-			if (this.contentsOffset + actualSize >= this.contents.length) {
-				resizeContents(actualSize);
+			if (this.contentsOffset + length >= this.contents.length) {
+				resizeContents(length + 1);
 			}
-			this.contents[this.contentsOffset++] = (byte) (length >> 8);
-			this.contents[this.contentsOffset++] = (byte) length;
+			this.contents[this.contentsOffset++] = (byte) (locations.length / 2);
 			for (int i = 0; i < length; i++) {
 				this.contents[this.contentsOffset++] = (byte) locations[i];
 			}
@@ -2185,22 +2154,67 @@ public class ClassFile implements TypeConstants, TypeIds {
 	}
 	private void dumpTargetTypeContents(int targetType, AnnotationContext annotationContext) {
 		switch(targetType) {
-			case AnnotationTargetTypeConstants.THROWS :
-			case AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS :
-			case AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY :
-			case AnnotationTargetTypeConstants.OBJECT_CREATION :
-			case AnnotationTargetTypeConstants.OBJECT_CREATION_GENERIC_OR_ARRAY :
-			case AnnotationTargetTypeConstants.CLASS_LITERAL :
-			case AnnotationTargetTypeConstants.CLASS_LITERAL_GENERIC_OR_ARRAY :
-			case AnnotationTargetTypeConstants.TYPE_INSTANCEOF :
-			case AnnotationTargetTypeConstants.TYPE_INSTANCEOF_GENERIC_OR_ARRAY :
-			case AnnotationTargetTypeConstants.TYPE_CAST :
-			case AnnotationTargetTypeConstants.TYPE_CAST_GENERIC_OR_ARRAY :
+			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER :
+			case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER :
+				// parameter index
+				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
+				break;
+
+			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND :
+				// type_parameter_index
+				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
+				// bound_index
+				this.contents[this.contentsOffset++] = (byte) annotationContext.info2;
+				break;				
+			case AnnotationTargetTypeConstants.FIELD :
+			case AnnotationTargetTypeConstants.METHOD_RECEIVER :
+			case AnnotationTargetTypeConstants.METHOD_RETURN :
+				 // target_info is empty_target
+				break;
+			case AnnotationTargetTypeConstants.METHOD_FORMAL_PARAMETER :
+				// target_info is parameter index
+				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
+				break;
+				
+			case AnnotationTargetTypeConstants.INSTANCEOF :
+			case AnnotationTargetTypeConstants.NEW :
+			case AnnotationTargetTypeConstants.EXCEPTION_PARAMETER :
+			case AnnotationTargetTypeConstants.CONSTRUCTOR_REFERENCE :
+			case AnnotationTargetTypeConstants.METHOD_REFERENCE :
+				// bytecode offset for new/instanceof/method_reference
+				// exception table entry index for exception_parameter
+				this.contents[this.contentsOffset++] = (byte) (annotationContext.info >> 8);
+				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
+				break;
+			case AnnotationTargetTypeConstants.CAST :
+				// bytecode offset
+				this.contents[this.contentsOffset++] = (byte) (annotationContext.info >> 8);
+				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
+				// type_argument_index not set for cast
+				this.contents[this.contentsOffset++] = (byte)0;
+				break;
+				
+			case AnnotationTargetTypeConstants.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT :
+			case AnnotationTargetTypeConstants.METHOD_INVOCATION_TYPE_ARGUMENT :
+			case AnnotationTargetTypeConstants.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT :
+			case AnnotationTargetTypeConstants.METHOD_REFERENCE_TYPE_ARGUMENT :
+				// bytecode offset
+				this.contents[this.contentsOffset++] = (byte) (annotationContext.info >> 8);
+				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
+				// type_argument_index 
+				this.contents[this.contentsOffset++] = (byte) annotationContext.info2;
+				break;
+				
+			case AnnotationTargetTypeConstants.CLASS_EXTENDS :
+			case AnnotationTargetTypeConstants.THROWS :			
+				// For CLASS_EXTENDS - info is supertype index (-1 = superclass)
+				// For THROWS - info is exception table index
 				this.contents[this.contentsOffset++] = (byte) (annotationContext.info >> 8);
 				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
 				break;
+				
 			case AnnotationTargetTypeConstants.LOCAL_VARIABLE :
-			case AnnotationTargetTypeConstants.LOCAL_VARIABLE_GENERIC_OR_ARRAY :
+			case AnnotationTargetTypeConstants.RESOURCE_VARIABLE :
 				int localVariableTableOffset = this.contentsOffset;
 				LocalVariableBinding localVariable = annotationContext.variableBinding;
 				int actualSize = 0;
@@ -2231,40 +2245,15 @@ public class ClassFile implements TypeConstants, TypeIds {
 				this.contents[localVariableTableOffset++] = (byte) (numberOfEntries >> 8);
 				this.contents[localVariableTableOffset] = (byte) numberOfEntries;
 				break;
-			case AnnotationTargetTypeConstants.METHOD_PARAMETER :
-			case AnnotationTargetTypeConstants.METHOD_PARAMETER_GENERIC_OR_ARRAY :
-				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
-				break;
-			// nothing to do
-			// case AnnotationTargetTypeConstants.METHOD_RECEIVER :
-			// case AnnotationTargetTypeConstants.METHOD_RECEIVER_GENERIC_OR_ARRAY :
-			//	break;
-			// case AnnotationTargetTypeConstants.FIELD :
-			// case AnnotationTargetTypeConstants.FIELD_GENERIC_OR_ARRAY :
-			//	break;
-			case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER :
-			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER :
-				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
-				break;
 			case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND :
-			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND :
-			case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY :
-			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY :
 				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
 				this.contents[this.contentsOffset++] = (byte) annotationContext.info2;
 				break;
-			case AnnotationTargetTypeConstants.TYPE_ARGUMENT_METHOD_CALL :
-			case AnnotationTargetTypeConstants.TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY :
-			case AnnotationTargetTypeConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL :
-			case AnnotationTargetTypeConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY :
-				// offset
-				this.contents[this.contentsOffset++] = (byte) (annotationContext.info >> 8);
-				this.contents[this.contentsOffset++] = (byte) annotationContext.info;
-				// type index
-				this.contents[this.contentsOffset++] = (byte) annotationContext.info2;
 		}
 	}
 
+
+
 	/**
 	 * INTERNAL USE-ONLY
 	 * This methods returns a char[] representing the file name of the receiver
@@ -3646,13 +3635,17 @@ public class ClassFile implements TypeConstants, TypeIds {
 		}
 		return attributesNumber;
 	}
+	
 	/**
 	 * @param annotationContexts the given annotation contexts
 	 * @param visibleTypeAnnotationsNumber the given number of visible type annotations
 	 * @param invisibleTypeAnnotationsNumber the given number of invisible type annotations
 	 * @return the number of attributes created while dumping the annotations in the .class file
 	 */
-	private int generateRuntimeTypeAnnotations(final AnnotationContext[] annotationContexts, int visibleTypeAnnotationsNumber, int invisibleTypeAnnotationsNumber) {
+	private int generateRuntimeTypeAnnotations(
+			final AnnotationContext[] annotationContexts, 
+			int visibleTypeAnnotationsNumber, 
+			int invisibleTypeAnnotationsNumber) {
 		int attributesNumber = 0;
 		final int length = annotationContexts.length;
 
@@ -4351,175 +4344,52 @@ public class ClassFile implements TypeConstants, TypeIds {
 		this.contentsOffset = localContentsOffset;
 		return 1;
 	}
-
+	
 	private void generateTypeAnnotation(AnnotationContext annotationContext, int currentOffset) {
-		int targetType = annotationContext.targetType;
 		if (annotationContext.wildcard != null) {
-			generateWilcardTypeAnnotation(annotationContext, currentOffset);
-			return;
-		}
-		// common part between type annotation and annotation
-		generateAnnotation(annotationContext.annotation, currentOffset);
-		if (this.contentsOffset == currentOffset) {
-			// error occurred while generating the annotation
+			generateWildcardTypeAnnotation(annotationContext, currentOffset);
 			return;
 		}
+		
+		int targetType = annotationContext.targetType;
+
 		int[] locations = Annotation.getLocations(
 			annotationContext.typeReference,
 			annotationContext.primaryAnnotations,
 			annotationContext.annotation,
-			annotationContext.annotationsOnDimensions);
-		if (locations != null) {
-			// convert to GENERIC_OR_ARRAY type
-			switch(targetType) {
-				case AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS :
-					targetType = AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY;
-					break;
-				case AnnotationTargetTypeConstants.LOCAL_VARIABLE :
-					targetType = AnnotationTargetTypeConstants.LOCAL_VARIABLE_GENERIC_OR_ARRAY;
-					break;
-				case AnnotationTargetTypeConstants.METHOD_PARAMETER :
-					targetType = AnnotationTargetTypeConstants.METHOD_PARAMETER_GENERIC_OR_ARRAY;
-					break;
-				case AnnotationTargetTypeConstants.FIELD :
-					targetType = AnnotationTargetTypeConstants.FIELD_GENERIC_OR_ARRAY;
-					break;
-//					case AnnotationTargetTypeConstants.METHOD_RECEIVER :
-//					// should not happen - possible extension
-//					targetType = AnnotationTargetTypeConstants.METHOD_RECEIVER_GENERIC_OR_ARRAY;
-//					break;
-//				case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER :
-//					// should not happen - possible extension
-//					targetType = AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_GENERIC_OR_ARRAY;
-//					break;
-				case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND :
-					// should not happen - possible extension
-					targetType = AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY;
-					break;
-//				case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER :
-//					// should not happen - possible extension
-//					targetType = AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_GENERIC_OR_ARRAY;
-//					break;
-				case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND :
-					// should not happen - possible extension
-					targetType = AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY;
-					break;
-//				case AnnotationTargetTypeConstants.THROWS :
-//					targetType = AnnotationTargetTypeConstants.THROWS_GENERIC_OR_ARRAY;
-				case AnnotationTargetTypeConstants.TYPE_INSTANCEOF:
-					targetType = AnnotationTargetTypeConstants.TYPE_INSTANCEOF_GENERIC_OR_ARRAY;
-					break;
-				case AnnotationTargetTypeConstants.CLASS_LITERAL:
-					targetType = AnnotationTargetTypeConstants.CLASS_LITERAL_GENERIC_OR_ARRAY;
-					break;
-				case AnnotationTargetTypeConstants.OBJECT_CREATION:
-					targetType = AnnotationTargetTypeConstants.OBJECT_CREATION_GENERIC_OR_ARRAY;
-					break;
-				case AnnotationTargetTypeConstants.TYPE_CAST:
-					targetType = AnnotationTargetTypeConstants.TYPE_CAST_GENERIC_OR_ARRAY;
-					break;
-				case AnnotationTargetTypeConstants.TYPE_ARGUMENT_METHOD_CALL :
-					targetType = AnnotationTargetTypeConstants.TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY;
-					break;
-				case AnnotationTargetTypeConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL :
-					targetType = AnnotationTargetTypeConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY;
-					break;
-				case AnnotationTargetTypeConstants.METHOD_RETURN_TYPE :
-					targetType = AnnotationTargetTypeConstants.METHOD_RETURN_TYPE_GENERIC_OR_ARRAY;
-			}
-		}
-		// reserve enough space
+			annotationContext.annotationsOnDimensions,
+			annotationContext.dimensions);
+
 		if (this.contentsOffset + 5 >= this.contents.length) {
 			resizeContents(5);
 		}
 		this.contents[this.contentsOffset++] = (byte) targetType;
 		dumpTargetTypeContents(targetType, annotationContext);
 		dumpLocations(locations);
-	}
-
-	private void generateWilcardTypeAnnotation(AnnotationContext annotationContext, int currentOffset) {
+		
 		// common part between type annotation and annotation
 		generateAnnotation(annotationContext.annotation, currentOffset);
-		if (this.contentsOffset == currentOffset) {
-			// error occurred while generating the annotation
-			return;
-		}
-		int[] wildcardLocations = getWildcardLocations(annotationContext.typeReference, annotationContext.wildcard);
+	}
+
+	private void generateWildcardTypeAnnotation(AnnotationContext annotationContext, int currentOffset) {
 		int targetType = annotationContext.targetType;
-		switch(targetType) {
-			case AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS :
-				targetType = AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY;
-				break;
-			case AnnotationTargetTypeConstants.LOCAL_VARIABLE :
-				targetType = AnnotationTargetTypeConstants.LOCAL_VARIABLE_GENERIC_OR_ARRAY;
-				break;
-			case AnnotationTargetTypeConstants.METHOD_PARAMETER :
-				targetType = AnnotationTargetTypeConstants.METHOD_PARAMETER_GENERIC_OR_ARRAY;
-				break;
-			case AnnotationTargetTypeConstants.FIELD :
-				targetType = AnnotationTargetTypeConstants.FIELD_GENERIC_OR_ARRAY;
-				break;
-//				case AnnotationTargetTypeConstants.METHOD_RECEIVER :
-//				// should not happen - possible extension
-//				targetType = AnnotationTargetTypeConstants.METHOD_RECEIVER_GENERIC_OR_ARRAY;
-//				break;
-//			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER :
-//				// should not happen - possible extension
-//				targetType = AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_GENERIC_OR_ARRAY;
-//				break;
-//			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND :
-//				// should not happen - possible extension
-//				targetType = AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY;
-//				break;
-//			case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER :
-//				// should not happen - possible extension
-//				targetType = AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_GENERIC_OR_ARRAY;
-//				break;
-//			case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND :
-//				// should not happen - possible extension
-//				targetType = AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY;
-//				break;
-//			case AnnotationTargetTypeConstants.THROWS :
-//				targetType = AnnotationTargetTypeConstants.THROWS_GENERIC_OR_ARRAY;
-			case AnnotationTargetTypeConstants.TYPE_INSTANCEOF:
-				targetType = AnnotationTargetTypeConstants.TYPE_INSTANCEOF_GENERIC_OR_ARRAY;
-				break;
-			case AnnotationTargetTypeConstants.CLASS_LITERAL:
-				targetType = AnnotationTargetTypeConstants.CLASS_LITERAL_GENERIC_OR_ARRAY;
-				break;
-			case AnnotationTargetTypeConstants.OBJECT_CREATION:
-				targetType = AnnotationTargetTypeConstants.OBJECT_CREATION_GENERIC_OR_ARRAY;
-				break;
-			case AnnotationTargetTypeConstants.TYPE_CAST:
-				targetType = AnnotationTargetTypeConstants.TYPE_CAST_GENERIC_OR_ARRAY;
-				break;
-			case AnnotationTargetTypeConstants.TYPE_ARGUMENT_METHOD_CALL :
-				targetType = AnnotationTargetTypeConstants.TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY;
-				break;
-			case AnnotationTargetTypeConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL :
-				targetType = AnnotationTargetTypeConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY;
-				break;
-			case AnnotationTargetTypeConstants.METHOD_RETURN_TYPE :
-				targetType = AnnotationTargetTypeConstants.METHOD_RETURN_TYPE_GENERIC_OR_ARRAY;
-		}
+
 		int[] locations = Annotation.getLocations(
-				annotationContext.wildcard.bound,
+				annotationContext.typeReference,
 				null,
 				annotationContext.annotation,
-				null);
+				null,
+				0);
 		// reserve enough space
 		if (this.contentsOffset + 5 >= this.contents.length) {
 			resizeContents(5);
 		}
-		this.contents[this.contentsOffset++] =
-			(byte) (locations != null ?
-					AnnotationTargetTypeConstants.WILDCARD_BOUND_GENERIC_OR_ARRAY :
-					AnnotationTargetTypeConstants.WILDCARD_BOUND);
 		this.contents[this.contentsOffset++] = (byte) targetType;
 		dumpTargetTypeContents(targetType, annotationContext);
-		dumpLocations(wildcardLocations);
 		dumpLocations(locations);
+		generateAnnotation(annotationContext.annotation, currentOffset);
 	}
+	
 	private int generateTypeAnnotationAttributeForTypeDeclaration() {
 		TypeDeclaration typeDeclaration = this.referenceBinding.scope.referenceContext;
 		if ((typeDeclaration.bits & ASTNode.HasTypeAnnotations) == 0) {
@@ -4531,7 +4401,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 		TypeReference superclass = typeDeclaration.superclass;
 		List allTypeAnnotationContexts = new ArrayList();
 		if (superclass != null && (superclass.bits & ASTNode.HasTypeAnnotations) != 0) {
-			superclass.getAllAnnotationContexts(AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS, -1, allTypeAnnotationContexts);
+			superclass.getAllAnnotationContexts(AnnotationTargetTypeConstants.CLASS_EXTENDS, -1, allTypeAnnotationContexts);
 		}
 		TypeReference[] superInterfaces = typeDeclaration.superInterfaces;
 		if (superInterfaces != null) {
@@ -4540,7 +4410,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 				if ((superInterface.bits & ASTNode.HasTypeAnnotations) == 0) {
 					continue;
 				}
-				superInterface.getAllAnnotationContexts(AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS, i, allTypeAnnotationContexts);
+				superInterface.getAllAnnotationContexts(AnnotationTargetTypeConstants.CLASS_EXTENDS, i, allTypeAnnotationContexts);
 			}
 		}
 		TypeParameter[] typeParameters = typeDeclaration.typeParameters;
@@ -4574,6 +4444,9 @@ public class ClassFile implements TypeConstants, TypeIds {
 		return attributesNumber;
 	}
 	
+	
+	
+
 	private int generateVarargsAttribute() {
 		int localContentsOffset = this.contentsOffset;
 		/*
@@ -5005,7 +4878,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 		this.produceAttributes = options.produceDebugAttributes;
 		if (this.targetJDK >= ClassFileConstants.JDK1_6) {
 			this.produceAttributes |= ClassFileConstants.ATTR_STACK_MAP_TABLE;
-			if (this.targetJDK >= ClassFileConstants.JDK1_7) {
+			if (this.targetJDK >= ClassFileConstants.JDK1_8) {
 				this.produceAttributes |= ClassFileConstants.ATTR_TYPE_ANNOTATION;
 			}
 		} else if (this.targetJDK == ClassFileConstants.CLDC_1_1) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index ed8b3f4..9152a39 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -15,6 +15,8 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
  *								bug 331649 - [compiler][null] consider null annotations for fields
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -40,47 +42,44 @@ public abstract class Annotation extends Expression {
 			final TypeReference reference,
 			final Annotation[] primaryAnnotation,
 			final Annotation annotation,
-			final Annotation[][] annotationsOnDimensionsOnExpression) {
+			final Annotation[][] annotationsOnDimensionsOnExpression,
+			final int dimensions) {
+	
 		class LocationCollector extends ASTVisitor {
-			Stack currentIndexes;
+			Stack typePathEntries;
 			Annotation currentAnnotation;
 			boolean search = true;
 			
 			public LocationCollector(Annotation currentAnnotation) {
-				this.currentIndexes = new Stack();
+				this.typePathEntries = new Stack();
 				this.currentAnnotation = currentAnnotation;
 			}
-			public boolean visit(ArrayTypeReference typeReference, BlockScope scope) {
+			
+			public boolean visit(ParameterizedSingleTypeReference typeReference, BlockScope scope) {
 				if (!this.search) return false;
+								
 				Annotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;
 				if (annotationsOnDimensions != null) {
-					// check if the annotation is located on the first dimension
-					Annotation[] annotations = annotationsOnDimensions[0];
-					if (annotations != null) {
-						for (int j = 0, max2 = annotations.length; j < max2; j++) {
-							Annotation current = annotations[j];
-							if (current == this.currentAnnotation) {
-								this.search = false;
-								return false;
-							}
-						}
-					}
-
-					this.currentIndexes.push(new Integer(0));
-					for (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {
-						annotations = annotationsOnDimensions[i];
+					for (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {
+						Annotation[] annotations = annotationsOnDimensions[i];
 						if (annotations != null) {
 							for (int j = 0, max2 = annotations.length; j < max2; j++) {
 								Annotation current = annotations[j];
 								if (current == this.currentAnnotation) {
+									// found it, push any relevant type path entries
+									for (int k = 0; k < i; k++) {
+										this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+									}
 									this.search = false;
 									return false;
 								}
 							}
 						}
-						this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
+						
 					}
 				}
+				
+				// Example cases handled here: @B(1) List<String>[]
 				Annotation[][] annotations = typeReference.annotations;
 				if (annotations == null) {
 					annotations = new Annotation[][] { primaryAnnotation };
@@ -92,91 +91,99 @@ public abstract class Annotation extends Expression {
 					for (int j = 0; j < annotationsLength; j++) {
 						if (current[j] == this.currentAnnotation) {
 							this.search = false;
+							// Found it, insert any necessary type path elements
+							for (int k = 0; k < typeReference.dimensions; k++) {
+								this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+							}
 							return false;
 						}
 					}
 				}
-				this.currentIndexes.pop();
+				
+				// If a type argument is annotated it is necessary jump past the array elements
+				if (typeReference.dimensions != 0) {
+					for (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {
+						this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+					}
+				}
+				TypeReference[] typeReferences = typeReference.typeArguments;
+				for (int i = 0, max = typeReferences.length; i < max; i++) {
+					this.typePathEntries.add(new int[]{3,i});
+					typeReferences[i].traverse(this, scope);
+					if (!this.search) {
+						return false;
+					} else {
+						this.typePathEntries.pop();
+					}
+				}
+				if (typeReference.dimensions != 0) {
+					for (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {
+						this.typePathEntries.pop();
+					}					
+				}
 				return true;
 			}
-			public boolean visit(ArrayQualifiedTypeReference typeReference, BlockScope scope) {
+
+			public boolean visit(SingleTypeReference typeReference, BlockScope scope) {
 				if (!this.search) return false;
-				Annotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;
-				if (annotationsOnDimensions != null) {
-					// check if the annotation is located on the first dimension
-					Annotation[] annotations = annotationsOnDimensions[0];
-					if (annotations != null) {
-						for (int j = 0, max2 = annotations.length; j < max2; j++) {
-							Annotation current = annotations[j];
-							if (current == this.currentAnnotation) {
-								this.search = false;
-								return false;
-							}
-						}
-					}
 
-					this.currentIndexes.push(new Integer(0));
-					for (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {
-						annotations = annotationsOnDimensions[i];
-						if (annotations != null) {
-							for (int j = 0, max2 = annotations.length; j < max2; j++) {
-								Annotation current = annotations[j];
-								if (current == this.currentAnnotation) {
-									this.search = false;
-									return false;
-								}
-							}
-						}
-						this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
+				// depth allows for the syntax "outerInstance.new @A InnerType();"
+				int depth = 0;
+				if (typeReference.resolvedType instanceof ReferenceBinding) {
+					depth = getInnerDepth((ReferenceBinding)typeReference.resolvedType);
+				}
+				
+				if (dimensions != 0) {
+					for (int k = 0; k < dimensions; k++) {
+						this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
 					}
 				}
 				Annotation[][] annotations = typeReference.annotations;
-				if (annotations == null) {
-					annotations = new Annotation[][] { primaryAnnotation };
-				}
-				int annotationsLevels = annotations.length;
+				int annotationsLevels = annotations == null ? 0 : annotations.length;
 				for (int i = 0; i < annotationsLevels; i++) {
 					Annotation [] current = annotations[i];
 					int annotationsLength = current == null ? 0 : current.length;
 					for (int j = 0; j < annotationsLength; j++) {
 						if (current[j] == this.currentAnnotation) {
+							// Found
 							this.search = false;
+							if (depth != 0) {
+								for (int k = 0; k<depth; k++) {
+									this.typePathEntries.add(TYPE_PATH_INNER_TYPE);
+								}
+							}
 							return false;
 						}
 					}
 				}
-				this.currentIndexes.pop();
-				return true;
+				if (dimensions != 0) {
+					for (int k = 0; k < dimensions; k++) {
+						this.typePathEntries.pop();
+					}
+				}
+				return false;
 			}
-			public boolean visit(ParameterizedSingleTypeReference typeReference, BlockScope scope) {
+
+			public boolean visit(ArrayTypeReference typeReference, BlockScope scope) {
 				if (!this.search) return false;
+				
 				Annotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;
 				if (annotationsOnDimensions != null) {
-					// check if the annotation is located on the first dimension
-					Annotation[] annotations = annotationsOnDimensions[0];
-					if (annotations != null) {
-						for (int j = 0, max2 = annotations.length; j < max2; j++) {
-							Annotation current = annotations[j];
-							if (current == this.currentAnnotation) {
-								this.search = false;
-								return false;
-							}
-						}
-					}
-
-					this.currentIndexes.push(new Integer(0));
-					for (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {
-						annotations = annotationsOnDimensions[i];
+					for (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {
+						Annotation[] annotations = annotationsOnDimensions[i];
 						if (annotations != null) {
 							for (int j = 0, max2 = annotations.length; j < max2; j++) {
 								Annotation current = annotations[j];
 								if (current == this.currentAnnotation) {
+									for (int k = 0; k < i; k++) {
+										this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+									}
 									this.search = false;
 									return false;
 								}
 							}
 						}
-						this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
+						
 					}
 				}
 				Annotation[][] annotations = typeReference.annotations;
@@ -189,50 +196,36 @@ public abstract class Annotation extends Expression {
 					int annotationsLength = current == null ? 0 : current.length;
 					for (int j = 0; j < annotationsLength; j++) {
 						if (current[j] == this.currentAnnotation) {
+							for (int k = 0, maxk=typeReference.dimensions; k < maxk; k++) {
+								this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+							}
 							this.search = false;
 							return false;
 						}
 					}
 				}
-				TypeReference[] typeReferences = typeReference.typeArguments;
-				this.currentIndexes.push(new Integer(0));
-				for (int i = 0, max = typeReferences.length; i < max; i++) {
-					typeReferences[i].traverse(this, scope);
-					if (!this.search) return false;
-					this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
-				}
-				this.currentIndexes.pop();
 				return true;
 			}
-			public boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {
+			
+			public boolean visit(ArrayQualifiedTypeReference typeReference, BlockScope scope) {
 				if (!this.search) return false;
 				Annotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;
 				if (annotationsOnDimensions != null) {
-					// check if the annotation is located on the first dimension
-					Annotation[] annotations = annotationsOnDimensions[0];
-					if (annotations != null) {
-						for (int j = 0, max2 = annotations.length; j < max2; j++) {
-							Annotation current = annotations[j];
-							if (current == this.currentAnnotation) {
-								this.search = false;
-								return false;
-							}
-						}
-					}
-
-					this.currentIndexes.push(new Integer(0));
-					for (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {
-						annotations = annotationsOnDimensions[i];
+					for (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {
+						Annotation[] annotations = annotationsOnDimensions[i];
 						if (annotations != null) {
 							for (int j = 0, max2 = annotations.length; j < max2; j++) {
 								Annotation current = annotations[j];
 								if (current == this.currentAnnotation) {
 									this.search = false;
+									// Found it, insert relevant type path elements
+									for (int k = 0, maxk = i; k < maxk; k++) {
+										this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+									}
 									return false;
 								}
 							}
 						}
-						this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
 					}
 				}
 				Annotation[][] annotations = typeReference.annotations;
@@ -246,130 +239,230 @@ public abstract class Annotation extends Expression {
 					for (int j = 0; j < annotationsLength; j++) {
 						if (current[j] == this.currentAnnotation) {
 							this.search = false;
+							for (int k = 0, maxk=typeReference.dimensions; k < maxk; k++) {
+								this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+							}
 							return false;
 						}
 					}
 				}
-				//TODO it is unclear how to manage annotations located in the first type arguments
-				TypeReference[] typeReferences = typeReference.typeArguments[typeReference.typeArguments.length - 1];
-				this.currentIndexes.push(new Integer(0));
-				for (int i = 0, max = typeReferences.length; i < max; i++) {
-					typeReferences[i].traverse(this, scope);
-					if (!this.search) return false;
-					this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
-				}
-				this.currentIndexes.pop();
 				return true;
 			}
-			public boolean visit(SingleTypeReference typeReference, BlockScope scope) {
+			
+			public boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {
 				if (!this.search) return false;
-				Annotation[][] annotationsOnDimensions = annotationsOnDimensionsOnExpression;
+				
+				// Example case handled by this block: java.util.List<String>[]@A[]
+				Annotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;
 				if (annotationsOnDimensions != null) {
-					// check if the annotation is located on the first dimension
-					Annotation[] annotations = annotationsOnDimensions[0];
-					if (annotations != null) {
-						for (int j = 0, max2 = annotations.length; j < max2; j++) {
-							Annotation current = annotations[j];
-							if (current == this.currentAnnotation) {
-								this.search = false;
-								return false;
-							}
-						}
-					}
-
-					this.currentIndexes.push(new Integer(0));
-					for (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {
-						annotations = annotationsOnDimensions[i];
+					for (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {
+						Annotation[] annotations = annotationsOnDimensions[i];
 						if (annotations != null) {
 							for (int j = 0, max2 = annotations.length; j < max2; j++) {
 								Annotation current = annotations[j];
 								if (current == this.currentAnnotation) {
 									this.search = false;
+									// Found it, insert relevant type path elements
+									for (int k = 0, maxk = i; k < maxk; k++) {
+										this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+									}
 									return false;
 								}
 							}
 						}
-						this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
 					}
 				}
+
+				boolean[] needsInnerEntryInfo = computeInnerEntryInfo(typeReference);
+
+				// Example cases handled by this block:
+				// java.util.@A List<String>[][], com.demo.@A Outer.@B Inner<String>, java.util.Map.@A Entry<String,String>
 				Annotation[][] annotations = typeReference.annotations;
-				int annotationsLevels = annotations == null ? 0 : annotations.length;
+				if (annotations == null) {
+					annotations = new Annotation[][] { primaryAnnotation };
+				}
+				int annotationsLevels = annotations.length;
 				for (int i = 0; i < annotationsLevels; i++) {
 					Annotation [] current = annotations[i];
 					int annotationsLength = current == null ? 0 : current.length;
 					for (int j = 0; j < annotationsLength; j++) {
 						if (current[j] == this.currentAnnotation) {
 							this.search = false;
+							// Found, insert any relevant type path elements
+							for (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {
+								this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+							}
+							// Found, insert any relevant type path elements
+							if (needsInnerEntryInfo != null) {
+								for (int k = 0; k <= i; k++) {
+									if (needsInnerEntryInfo[k]) {
+										this.typePathEntries.push(TYPE_PATH_INNER_TYPE);
+									}
+								}
+							}
 							return false;
 						}
 					}
 				}
-				return false;
+				
+				// Example cases handled by this block:
+				// java.util.List<@A String>
+				if (typeReference.dimensions != 0) {
+					for (int k = 0, maxk = typeReference.dimensions; k < maxk; k++) {
+						this.typePathEntries.push(TYPE_PATH_ELEMENT_ARRAY);
+					}
+				}
+				int toPop = 0;
+				for (int i = 0, max = typeReference.typeArguments.length; i < max; i++) {
+					TypeReference[] typeArgumentsForComponent = typeReference.typeArguments[i];
+					if (needsInnerEntryInfo != null && needsInnerEntryInfo[i]) { 
+						this.typePathEntries.push(TYPE_PATH_INNER_TYPE);
+						toPop++;
+					}
+					if (typeArgumentsForComponent != null) {
+						for (int j = 0, max2 = typeArgumentsForComponent.length; j < max2; j++) {
+							this.typePathEntries.push(new int[]{3,j});
+							typeArgumentsForComponent[j].traverse(this,scope);
+							if (!this.search) return false;
+							this.typePathEntries.pop();
+						}
+					}
+				}
+				toPop += typeReference.dimensions;
+				for (int k = 0, maxk = toPop; k < maxk; k++) {
+					this.typePathEntries.pop();
+				}
+				return true;
 			}
+			
 			public boolean visit(Wildcard typeReference, BlockScope scope) {
 				if (!this.search) return false;
 				TypeReference bound = typeReference.bound;
+				this.typePathEntries.push(TYPE_PATH_ANNOTATION_ON_WILDCARD_BOUND);
 				bound.traverse(this, scope);
+				if (!this.search) {
+					return false;
+				}
+				this.typePathEntries.pop();
 				return true;
 			}
+			
+			private boolean[] computeInnerEntryInfo(QualifiedTypeReference typeReference) {
+				ReferenceBinding resolvedType = (ReferenceBinding) 
+						(typeReference.resolvedType instanceof ArrayBinding ? typeReference.resolvedType.leafComponentType() : typeReference.resolvedType);
+				boolean[] needsInnerEntryInfo = null;
+				if (resolvedType != null && resolvedType.isNestedType()) {
+					// Work backwards computing whether a INNER_TYPE entry is required for each level
+					needsInnerEntryInfo = new boolean[typeReference.tokens.length];
+					int counter = needsInnerEntryInfo.length - 1;
+					ReferenceBinding type = resolvedType;//resolvedType.enclosingType();
+					while (type != null) {
+						needsInnerEntryInfo[counter--] = !type.isStatic();
+						type = type.enclosingType();
+					}
+				}
+				return needsInnerEntryInfo;
+			}
+			
+			private int getInnerDepth(ReferenceBinding resolvedType) {
+				int depth = 0;
+				ReferenceBinding type = resolvedType;
+				while (type != null) {
+					depth += (type.isStatic())?0:1;
+					type = type.enclosingType();
+				}
+				return depth;
+			}
+			
 			public boolean visit(QualifiedTypeReference typeReference, BlockScope scope) {
 				if (!this.search) return false;
+				boolean[] needsInnerEntryInfo = computeInnerEntryInfo(typeReference);
+				
+				// Example cases handled by this block:
+				// java.util.@A List, com.demo.@A Outer.@B Inner, java.util.Map.@A Entry
 				Annotation[][] annotations = typeReference.annotations;
-				int annotationsLevels = annotations == null ? 0 : annotations.length;
+				if (annotations == null) {
+					annotations = new Annotation[][] { primaryAnnotation };
+				}
+				int annotationsLevels = annotations.length;
 				for (int i = 0; i < annotationsLevels; i++) {
 					Annotation [] current = annotations[i];
 					int annotationsLength = current == null ? 0 : current.length;
 					for (int j = 0; j < annotationsLength; j++) {
 						if (current[j] == this.currentAnnotation) {
 							this.search = false;
+							// Found, insert any relevant type path elements
+							if (needsInnerEntryInfo != null) {
+								for (int k = 0; k <= i; k++) {
+									if (needsInnerEntryInfo[k]) {
+										this.typePathEntries.push(TYPE_PATH_INNER_TYPE);
+									}
+								}
+							}
 							return false;
 						}
 					}
 				}
 				return true;
 			}
+			
 			public String toString() {
 				StringBuffer buffer = new StringBuffer();
 				buffer
 					.append("search location for ") //$NON-NLS-1$
 					.append(this.currentAnnotation)
-					.append("\ncurrent indexes : ") //$NON-NLS-1$
-					.append(this.currentIndexes);
+					.append("\ncurrent type_path entries : "); //$NON-NLS-1$
+				for (int i = 0, maxi = this.typePathEntries.size(); i < maxi; i++) {
+					int[] typePathEntry = (int[]) this.typePathEntries.get(i);
+					buffer
+						.append('(')
+						.append(typePathEntry[0])
+						.append(',')
+						.append(typePathEntry[1])
+						.append(')');
+				}
 				return String.valueOf(buffer);
 			}
 		}
 		if (reference == null) return null;
 		LocationCollector collector = new LocationCollector(annotation);
 		reference.traverse(collector, (BlockScope) null);
-		if (collector.currentIndexes.isEmpty()) {
+		if (collector.typePathEntries.isEmpty()) {
 			return null;
 		}
-		int size = collector.currentIndexes.size();
-		int[] result = new int[size];
+		int size = collector.typePathEntries.size();
+		int[] result = new int[size*2];
+		int offset=0;
 		for (int i = 0; i < size; i++) {
-			result[size - i - 1] = ((Integer) collector.currentIndexes.pop()).intValue();
+			int[] pathElement = (int[])collector.typePathEntries.get(i);
+			result[offset++] = pathElement[0];
+			result[offset++] = pathElement[1];
 		}
 		return result;
 	}
-	
-	    // jsr 308
-		public static class TypeUseBinding extends ReferenceBinding {
-			private int kind;
-			public TypeUseBinding(int kind) {
-				this.tagBits = 0L;
-				this.kind = kind;
-			}
-			public int kind() {
-				return this.kind;
-			}
-			public boolean hasTypeBit(int bit) {
-				return false;
-			}
+		
+    // jsr 308
+	public static class TypeUseBinding extends ReferenceBinding {
+		private int kind;
+		public TypeUseBinding(int kind) {
+			this.tagBits = 0L;
+			this.kind = kind;
+		}
+		public int kind() {
+			return this.kind;
 		}
+		public boolean hasTypeBit(int bit) {
+			return false;
+		}
+	}
 
 	final static MemberValuePair[] NoValuePairs = new MemberValuePair[0];
 	private static final long TAGBITS_NULLABLE_OR_NONNULL = TagBits.AnnotationNullable|TagBits.AnnotationNonNull;
 
+	static final int[] TYPE_PATH_ELEMENT_ARRAY = new int[]{0,0};
+	static final int[] TYPE_PATH_INNER_TYPE = new int[]{1,0};
+	static final int[] TYPE_PATH_ANNOTATION_ON_WILDCARD_BOUND = new int[]{2,0};
+	
 	public int declarationSourceEnd;
 	public Binding recipient;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
index 9bb15e8..3edbaee 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
@@ -15,6 +15,9 @@
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+ *     Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+ *
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -58,7 +61,7 @@ public class ArrayAllocationExpression extends Expression {
 		int pc = codeStream.position;
 
 		if (this.initializer != null) {
-			this.initializer.generateCode(currentScope, codeStream, valueRequired);
+			this.initializer.generateCode(this.type, this.annotationsOnDimensions, currentScope, codeStream, valueRequired);
 			return;
 		}
 
@@ -73,10 +76,10 @@ public class ArrayAllocationExpression extends Expression {
 		// array allocation
 		if (explicitDimCount == 1) {
 			// Mono-dimensional array
-			codeStream.newArray((ArrayBinding)this.resolvedType);
+			codeStream.newArray(this.type, this.annotationsOnDimensions, (ArrayBinding)this.resolvedType);
 		} else {
 			// Multi-dimensional array
-			codeStream.multianewarray(this.resolvedType, explicitDimCount);
+			codeStream.multianewarray(this.type, this.resolvedType, this.dimensions.length, this.annotationsOnDimensions);
 		}
 		if (valueRequired) {
 			codeStream.generateImplicitConversion(this.implicitConversion);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
index 0a4d71b..dfa763d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
@@ -15,6 +15,8 @@
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -52,16 +54,20 @@ public class ArrayInitializer extends Expression {
 		return flowInfo;
 	}
 
+	public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {
+		generateCode(null, null, currentScope, codeStream, valueRequired);
+	}
+	
 	/**
 	 * Code generation for a array initializer
 	 */
-	public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {
+	public void generateCode(TypeReference typeReference, Annotation[][] annotationsOnDimensions, BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {
 
 		// Flatten the values and compute the dimensions, by iterating in depth into nested array initializers
 		int pc = codeStream.position;
 		int expressionLength = (this.expressions == null) ? 0: this.expressions.length;
 		codeStream.generateInlinedValue(expressionLength);
-		codeStream.newArray(null, this.binding);
+		codeStream.newArray(typeReference, annotationsOnDimensions, this.binding);
 		if (this.expressions != null) {
 			// binding is an ArrayType, so I can just deal with the dimension
 			int elementsTypeID = this.binding.dimensions > 1 ? -1 : this.binding.leafComponentType.id;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index a9134aa..d78f7c7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -17,6 +17,8 @@
  *	   Stephan Herrmann - Contribution for
  *							bug 402028 - [1.8][compiler] null analysis for reference expressions 
  *							bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super via I.super.m() syntax
+ *        Andy Clement - Contribution for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.ast;
@@ -144,7 +146,8 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		buffer.append(this.resolvedType.constantPoolName());
 		buffer.append(';');
 		int invokeDynamicNumber = codeStream.classFile.recordBootstrapMethod(this);
-		codeStream.invokeDynamic(invokeDynamicNumber, argumentsSize, 1, LAMBDA, buffer.toString().toCharArray());
+		codeStream.invokeDynamic(invokeDynamicNumber, argumentsSize, 1, LAMBDA, buffer.toString().toCharArray(), 
+				this.isConstructorReference(), (this.lhs instanceof TypeReference? (TypeReference) this.lhs : null), this.typeArguments);
 		codeStream.recordPositionsFrom(pc, this.sourceStart);
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index 8ce261f..7a5693b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -25,6 +25,10 @@
  *								bug 384380 - False positive on a ?? Potential null pointer access ?? after a continue
  *     Jesper Steen Moller - Contributions for
  *								bug 404146 - [1.7][compiler] nested try-catch-finally-blocks leads to unrunnable Java byte code
+ *
+ *     Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+ *
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -498,7 +502,7 @@ public void generateCode(BlockScope currentScope, CodeStream codeStream) {
 				multiCatchExceptionLabel.initialize((UnionTypeReference) argument.type);
 				exceptionLabel = multiCatchExceptionLabel;
 			} else {
-				exceptionLabel = new ExceptionLabel(codeStream, argument.binding.type);
+				exceptionLabel = new ExceptionLabel(codeStream, argument.binding.type, argument.type);
 			}
 			exceptionLabel.placeStart();
 			exceptionLabels[i] = exceptionLabel;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index 31f72cf..406fb58 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -14,6 +14,8 @@
  *     Stephan Herrmann - Contribution for
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -53,6 +55,7 @@ static class AnnotationCollector extends ASTVisitor {
 	int info2 = -1;
 	LocalVariableBinding localVariable;
 	Annotation[][] annotationsOnDimensions;
+	int dimensions;
 	Wildcard currentWildcard;
 
 	public AnnotationCollector(
@@ -145,32 +148,42 @@ static class AnnotationCollector extends ASTVisitor {
 			int targetType,
 			int info,
 			List annotationContexts,
-			Annotation[][] annotationsOnDimensions) {
+			Annotation[][] annotationsOnDimensions,
+			int dimensions) {
 		this.annotationContexts = annotationContexts;
 		this.typeReference = typeReference;
 		this.info = info;
 		this.targetType = targetType;
 		this.annotationsOnDimensions = annotationsOnDimensions;
-	}
+		// Array references like 'new String[]' manifest as an ArrayAllocationExpression
+		// with a 'type' of String.  When the type is not carrying the dimensions count
+		// it is passed in via the dimensions parameter.  It is not possible to use
+		// annotationsOnDimensions as it will be null if there are no annotations on any
+		// of the dimensions.
+		this.dimensions = dimensions;
+	}
+	
 	private boolean internalVisit(Annotation annotation) {
 		AnnotationContext annotationContext = null;
 		if (annotation.isRuntimeTypeInvisible()) {
-			annotationContext = new AnnotationContext(annotation, this.typeReference, this.targetType, this.primaryAnnotations, AnnotationContext.INVISIBLE, this.annotationsOnDimensions);
+			annotationContext = new AnnotationContext(annotation, this.typeReference, this.targetType, this.primaryAnnotations, AnnotationContext.INVISIBLE, this.annotationsOnDimensions, this.dimensions);
 		} else if (annotation.isRuntimeTypeVisible()) {
-			annotationContext = new AnnotationContext(annotation, this.typeReference, this.targetType, this.primaryAnnotations, AnnotationContext.VISIBLE, this.annotationsOnDimensions);
+			annotationContext = new AnnotationContext(annotation, this.typeReference, this.targetType, this.primaryAnnotations, AnnotationContext.VISIBLE, this.annotationsOnDimensions, this.dimensions);
 		}
 		if (annotationContext != null) {
 			annotationContext.wildcard = this.currentWildcard;
 			switch(this.targetType) {
-				case AnnotationTargetTypeConstants.THROWS :
 				case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER :
 				case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER :
-				case AnnotationTargetTypeConstants.METHOD_PARAMETER :
-				case AnnotationTargetTypeConstants.TYPE_CAST :
-				case AnnotationTargetTypeConstants.TYPE_INSTANCEOF :
-				case AnnotationTargetTypeConstants.OBJECT_CREATION :
-				case AnnotationTargetTypeConstants.CLASS_LITERAL :
-				case AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS:
+				case AnnotationTargetTypeConstants.CLASS_EXTENDS:
+				case AnnotationTargetTypeConstants.METHOD_FORMAL_PARAMETER :
+				case AnnotationTargetTypeConstants.THROWS :
+				case AnnotationTargetTypeConstants.EXCEPTION_PARAMETER :
+				case AnnotationTargetTypeConstants.INSTANCEOF:
+				case AnnotationTargetTypeConstants.NEW :
+				case AnnotationTargetTypeConstants.CONSTRUCTOR_REFERENCE :
+				case AnnotationTargetTypeConstants.METHOD_REFERENCE :
+				case AnnotationTargetTypeConstants.CAST:
 					annotationContext.info = this.info;
 					break;
 				case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND :
@@ -179,12 +192,21 @@ static class AnnotationCollector extends ASTVisitor {
 					annotationContext.info = this.info;
 					break;
 				case AnnotationTargetTypeConstants.LOCAL_VARIABLE :
+				case AnnotationTargetTypeConstants.RESOURCE_VARIABLE :
 					annotationContext.variableBinding = this.localVariable;
 					break;
-				case AnnotationTargetTypeConstants.TYPE_ARGUMENT_METHOD_CALL :
-				case AnnotationTargetTypeConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL :
+				case AnnotationTargetTypeConstants.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT :
+				case AnnotationTargetTypeConstants.METHOD_INVOCATION_TYPE_ARGUMENT :
+				case AnnotationTargetTypeConstants.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT :
+				case AnnotationTargetTypeConstants.METHOD_REFERENCE_TYPE_ARGUMENT :
 					annotationContext.info2 = this.info2;
 					annotationContext.info = this.info;
+					break;
+				case AnnotationTargetTypeConstants.FIELD :
+				case AnnotationTargetTypeConstants.METHOD_RETURN :
+				case AnnotationTargetTypeConstants.METHOD_RECEIVER :
+					break;
+					
 			}
 			this.annotationContexts.add(annotationContext);
 		}
@@ -328,12 +350,9 @@ public void getAllAnnotationContexts(int targetType, int info, List allAnnotatio
 }
 /**
  * info can be either a type index (superclass/superinterfaces) or a pc into the bytecode
- * @param targetType
- * @param info
- * @param allAnnotationContexts
  */
-public void getAllAnnotationContexts(int targetType, int info, List allAnnotationContexts, Annotation[][] annotationsOnDimensions) {
-	AnnotationCollector collector = new AnnotationCollector(this, targetType, info, allAnnotationContexts, annotationsOnDimensions);
+public void getAllAnnotationContexts(int targetType, int info, List allAnnotationContexts, Annotation[][] annotationsOnDimensions, int dimensions) {
+	AnnotationCollector collector = new AnnotationCollector(this, targetType, info, allAnnotationContexts, annotationsOnDimensions, dimensions);
 	this.traverse(collector, (BlockScope) null);
 	if (annotationsOnDimensions != null) {
 		for (int i = 0, max = annotationsOnDimensions.length; i < max; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
index 75de873..1bc0469 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012 IBM Corporation and others.
+ * Copyright (c) 2012, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,8 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
 
@@ -32,6 +34,9 @@ public class AnnotationContext {
 	public LocalVariableBinding variableBinding;
 	public Annotation[][] annotationsOnDimensions;
 	public Wildcard wildcard;
+	// annotationsOnDimensions might be null but the dimensions may still be important. In some
+	// cases they are not on the reference.
+	public int dimensions;
 
 	public AnnotationContext(
 			Annotation annotation,
@@ -39,13 +44,15 @@ public class AnnotationContext {
 			int targetType,
 			Annotation[] primaryAnnotations,
 			int visibility,
-			Annotation[][] annotationsOnDimensions) {
+			Annotation[][] annotationsOnDimensions,
+			int dimensions) {
 		this.annotation = annotation;
 		this.typeReference = typeReference;
 		this.targetType = targetType;
 		this.primaryAnnotations = primaryAnnotations;
 		this.visibility = visibility;
 		this.annotationsOnDimensions = annotationsOnDimensions;
+		this.dimensions = dimensions;
 	}
 
 	public String toString() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationTargetTypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationTargetTypeConstants.java
index ad66617..6538d19 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationTargetTypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationTargetTypeConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012 IBM Corporation and others.
+ * Copyright (c) 2012, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,44 +11,39 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
 
 public interface AnnotationTargetTypeConstants {
-	int METHOD_RECEIVER = 0x06;
-	int METHOD_RECEIVER_GENERIC_OR_ARRAY = 0x07;
-	int METHOD_RETURN_TYPE = 0x0A;
-	int METHOD_RETURN_TYPE_GENERIC_OR_ARRAY = 0x0B;
-	int METHOD_PARAMETER = 0x0C;
-	int METHOD_PARAMETER_GENERIC_OR_ARRAY = 0x0D;
-	int FIELD = 0x0E;
-	int FIELD_GENERIC_OR_ARRAY = 0x0F;
-	int CLASS_TYPE_PARAMETER_BOUND = 0x10;
-	int CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY = 0x11;
-	int METHOD_TYPE_PARAMETER_BOUND = 0x12;
-	int METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY = 0x13;
-	int CLASS_EXTENDS_IMPLEMENTS = 0x14;
-	int CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY = 0x15;
-	int THROWS = 0x16;
-	int THROWS_GENERIC_OR_ARRAY = 0x17;
-	int WILDCARD_BOUND = 0x1C;
-	int WILDCARD_BOUND_GENERIC_OR_ARRAY = 0x1D;
-	int METHOD_TYPE_PARAMETER = 0x20;
-	int METHOD_TYPE_PARAMETER_GENERIC_OR_ARRAY = 0x21;
-	int CLASS_TYPE_PARAMETER = 0x22;
-	int CLASS_TYPE_PARAMETER_GENERIC_OR_ARRAY = 0x23;
-	int TYPE_CAST = 0x00;
-	int TYPE_CAST_GENERIC_OR_ARRAY = 0x01;
-	int TYPE_INSTANCEOF = 0x02;
-	int TYPE_INSTANCEOF_GENERIC_OR_ARRAY = 0x03;
-	int OBJECT_CREATION = 0x04;
-	int OBJECT_CREATION_GENERIC_OR_ARRAY = 0x05;
-	int LOCAL_VARIABLE = 0x08;
-	int LOCAL_VARIABLE_GENERIC_OR_ARRAY = 0x09;
-	int TYPE_ARGUMENT_CONSTRUCTOR_CALL = 0x18;
-	int TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY = 0x19;
-	int TYPE_ARGUMENT_METHOD_CALL = 0x1A;
-	int TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY = 0x1B;
-	int CLASS_LITERAL = 0x1E;
-	int CLASS_LITERAL_GENERIC_OR_ARRAY = 0x1F;
+
+	// Targets for type parameter declarations
+	int CLASS_TYPE_PARAMETER                 = 0x00;
+	int METHOD_TYPE_PARAMETER                = 0x01;
+
+	// Targets that may be externally visible in classes and members
+	int CLASS_EXTENDS                        = 0x10;
+	int CLASS_TYPE_PARAMETER_BOUND           = 0x11;
+	int METHOD_TYPE_PARAMETER_BOUND          = 0x12;
+	int FIELD                                = 0x13;
+	int METHOD_RETURN                        = 0x14;
+	int METHOD_RECEIVER                      = 0x15;
+	int METHOD_FORMAL_PARAMETER              = 0x16;
+	int THROWS                               = 0x17;
+
+	// Targets for type uses that occur only within code blocks
+	int LOCAL_VARIABLE                       = 0x40;
+	int RESOURCE_VARIABLE                    = 0x41;
+	int EXCEPTION_PARAMETER                  = 0x42;
+	int INSTANCEOF                           = 0x43;
+	int NEW                                  = 0x44;
+	int CONSTRUCTOR_REFERENCE                = 0x45;
+	int METHOD_REFERENCE                     = 0x46;
+	int CAST                                 = 0x47;
+	int CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = 0x48;
+	int METHOD_INVOCATION_TYPE_ARGUMENT      = 0x49;
+	int CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT  = 0x4A;
+	int METHOD_REFERENCE_TYPE_ARGUMENT       = 0x4B;
+
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
index 611b7d7..809f130 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
@@ -9,10 +9,6 @@
  * Community Process (JCP) and is made available for testing and evaluation purposes
  * only. The code is not compatible with any specification of the JCP.
  *
- * This is an implementation of an early-draft specification developed under the Java
- * Community Process (JCP) and is made available for testing and evaluation purposes
- * only. The code is not compatible with any specification of the JCP.
- * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
@@ -20,10 +16,11 @@
  *								bug 391376 - [1.8] check interaction of default methods with bridge methods and generics
  *     Jesper S Moller - Contributions for
  *							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335        
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
 
-
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
@@ -649,9 +646,11 @@ public void checkcast(int baseId) {
 			writeUnsignedShort(this.constantPool.literalIndexForType(ConstantPool.JavaLangBooleanConstantPoolName));
 	}
 }
+
 public void checkcast(TypeBinding typeBinding) {
 	this.checkcast(null, typeBinding);
 }
+
 public void checkcast(TypeReference typeReference, TypeBinding typeBinding) {
 	/* We use a slightly sub-optimal generation for intersection casts by resorting to a runtime cast for every intersecting type, but in
 	   reality this should not matter. In its intended use form such as (I & Serializable) () -> {}, no cast is emitted at all
@@ -667,6 +666,7 @@ public void checkcast(TypeReference typeReference, TypeBinding typeBinding) {
 		writeUnsignedShort(this.constantPool.literalIndexForType(types[i]));
 	}
 }
+
 public void d2f() {
 	this.countLabels = 0;
 	this.stackDepth--;
@@ -1715,13 +1715,11 @@ public void generateBoxingConversion(int unboxedTypeID) {
             }
     }
 }
-public void generateClassLiteralAccessForType(TypeBinding accessedType, FieldBinding syntheticFieldBinding) {
-	this.generateClassLiteralAccessForType(null, accessedType, syntheticFieldBinding);
-}
+
 /**
  * Macro for building a class descriptor object
  */
-public void generateClassLiteralAccessForType(TypeReference typeReference, TypeBinding accessedType, FieldBinding syntheticFieldBinding) {
+public void generateClassLiteralAccessForType(TypeBinding accessedType, FieldBinding syntheticFieldBinding) {
 	if (accessedType.isBaseType() && accessedType != TypeBinding.NULL) {
 		getTYPE(accessedType.id);
 		return;
@@ -2504,7 +2502,7 @@ public void generateSyntheticBodyForFactoryMethod(SyntheticMethodBinding methodB
 public void generateSyntheticBodyForEnumValueOf(SyntheticMethodBinding methodBinding) {
 	initializeMaxLocals(methodBinding);
 	final ReferenceBinding declaringClass = methodBinding.declaringClass;
-	generateClassLiteralAccessForType(null, declaringClass, null);
+	generateClassLiteralAccessForType(declaringClass, null);
 	aload_0();
 	invokeJavaLangEnumvalueOf(declaringClass);
 	this.checkcast(declaringClass);
@@ -3925,11 +3923,17 @@ public boolean inlineForwardReferencesFromLabelsTargeting(BranchLabel targetLabe
 	}
 	return (chaining & (L_OPTIMIZABLE|L_CANNOT_OPTIMIZE)) == L_OPTIMIZABLE; // check was some standards, and no case/recursive
 }
+
+/**
+ * We didn't call it instanceof because there is a conflict with the
+ * instanceof keyword
+ */
 public void instance_of(TypeBinding typeBinding) {
 	this.instance_of(null, typeBinding);
 }
+
 /**
- * We didn't call it instanceof because there is a conflit with the
+ * We didn't call it instanceof because there is a conflict with the
  * instanceof keyword
  */
 public void instance_of(TypeReference typeReference, TypeBinding typeBinding) {
@@ -3970,7 +3974,12 @@ protected void invoke(byte opcode, int receiverAndArgsSize, int returnTypeSize,
 		this.stackMax = this.stackDepth;
 	}
 }
+
 public void invokeDynamic(int bootStrapIndex, int argsSize, int returnTypeSize, char[] selector, char[] signature) {
+	this.invokeDynamic(bootStrapIndex, argsSize, returnTypeSize, selector, signature, false, null, null);
+}
+
+public void invokeDynamic(int bootStrapIndex, int argsSize, int returnTypeSize, char[] selector, char[] signature, boolean isConstructorReference, TypeReference lhsTypeReference, TypeReference [] typeArguments) {
 	if (this.classFileOffset + 4 >= this.bCodeStream.length) {
 		resizeByteArray();
 	}
@@ -3985,6 +3994,11 @@ public void invokeDynamic(int bootStrapIndex, int argsSize, int returnTypeSize,
 		this.stackMax = this.stackDepth;
 	}
 }
+
+public void invoke(byte opcode, MethodBinding methodBinding, TypeBinding declaringClass) {
+	this.invoke(opcode, methodBinding, declaringClass, null);
+}
+
 public void invoke(byte opcode, MethodBinding methodBinding, TypeBinding declaringClass, TypeReference[] typeArguments) {
 	if (declaringClass == null) declaringClass = methodBinding.declaringClass;
 	if ((declaringClass.tagBits & TagBits.ContainsNestedTypeReferences) != 0) {
@@ -4019,7 +4033,7 @@ public void invoke(byte opcode, MethodBinding methodBinding, TypeBinding declari
 								default: 
 									receiverAndArgsSize++;
 									break;
-							}
+							}    						
 						}
 					}
 				}
@@ -4066,9 +4080,6 @@ public void invoke(byte opcode, MethodBinding methodBinding, TypeBinding declari
 			methodBinding.selector, 
 			methodBinding.signature(this.classFile));
 }
-public void invoke(byte opcode, MethodBinding methodBinding, TypeBinding declaringClass) {
-	this.invoke(opcode, methodBinding, declaringClass, null);
-}
 
 protected void invokeAccessibleObjectSetAccessible() {
 	// invokevirtual: java.lang.reflect.AccessibleObject.setAccessible(Z)V;
@@ -5695,9 +5706,11 @@ public void monitorexit() {
 	this.position++;
 	this.bCodeStream[this.classFileOffset++] = Opcodes.OPC_monitorexit;
 }
+
 public void multianewarray(TypeBinding typeBinding, int dimensions) {
 	this.multianewarray(null, typeBinding, dimensions, null);
 }
+
 public void multianewarray(
 		TypeReference typeReference,
 		TypeBinding typeBinding,
@@ -5713,9 +5726,12 @@ public void multianewarray(
 	writeUnsignedShort(this.constantPool.literalIndexForType(typeBinding));
 	this.bCodeStream[this.classFileOffset++] = (byte) dimensions;
 }
+
+// We didn't call it new, because there is a conflit with the new keyword
 public void new_(TypeBinding typeBinding) {
 	this.new_(null, typeBinding);
 }
+
 // We didn't call it new, because there is a conflit with the new keyword
 public void new_(TypeReference typeReference, TypeBinding typeBinding) {
 	this.countLabels = 0;
@@ -5739,10 +5755,16 @@ public void newarray(int array_Type) {
 	this.bCodeStream[this.classFileOffset++] = Opcodes.OPC_newarray;
 	this.bCodeStream[this.classFileOffset++] = (byte) array_Type;
 }
+
 public void newArray(ArrayBinding arrayBinding) {
 	this.newArray(null, arrayBinding);
 }
+
 public void newArray(TypeReference typeReference, ArrayBinding arrayBinding) {
+	this.newArray(null, null, arrayBinding);
+}
+
+public void newArray(TypeReference typeReference, Annotation[][] annotationsOnDimensions, ArrayBinding arrayBinding) {
 	TypeBinding component = arrayBinding.elementsType();
 	switch (component.id) {
 		case TypeIds.T_int :
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
index 7c26397..9af117f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
@@ -1,16 +1,23 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
 public class ExceptionLabel extends Label {
@@ -18,6 +25,13 @@ public class ExceptionLabel extends Label {
 	public int ranges[] = {POS_NOT_SET,POS_NOT_SET};
 	private int count = 0; // incremented each time placeStart or placeEnd is called
 	public TypeBinding exceptionType;
+	public TypeReference exceptionTypeReference;
+
+public ExceptionLabel(CodeStream codeStream, TypeBinding exceptionType, TypeReference exceptionTypeReference) {
+	super(codeStream);
+	this.exceptionType = exceptionType;
+	this.exceptionTypeReference = exceptionTypeReference;
+}
 
 public ExceptionLabel(CodeStream codeStream, TypeBinding exceptionType) {
 	super(codeStream);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
index 2d0fc54..3c90ed2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
@@ -1,15 +1,23 @@
 /*******************************************************************************
- * Copyright (c) 2011 IBM Corporation and others.
+ * Copyright (c) 2011, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
 
+import java.util.List;
+
 import org.eclipse.jdt.internal.compiler.ast.UnionTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
@@ -27,7 +35,7 @@ public class MultiCatchExceptionLabel extends ExceptionLabel {
 		int length = typeReferences.length;
 		this.exceptionLabels = new ExceptionLabel[length];
 		for (int i = 0; i < length; i++) {
-			this.exceptionLabels[i] = new ExceptionLabel(this.codeStream, typeReferences[i].resolvedType);
+			this.exceptionLabels[i] = new ExceptionLabel(this.codeStream, typeReferences[i].resolvedType, typeReferences[i]);
 		}
 	}
 	public void place() {
@@ -52,4 +60,16 @@ public class MultiCatchExceptionLabel extends ExceptionLabel {
 		}
 		return temp;
 	}
+
+	public int getAllAnnotationContexts(int tableIndex, List allTypeAnnotationContexts) {
+		int localCount = 0;
+		for (int i = 0, max = this.exceptionLabels.length; i < max; i++) {
+			ExceptionLabel exceptionLabel = this.exceptionLabels[i];
+			if (exceptionLabel.exceptionTypeReference != null) { // ignore those which cannot be annotated
+				exceptionLabel.exceptionTypeReference.getAllAnnotationContexts(AnnotationTargetTypeConstants.EXCEPTION_PARAMETER, tableIndex + localCount, allTypeAnnotationContexts);
+			}
+			tableIndex++;
+		}
+		return localCount;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
index aab6d3a..c5554fd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012 IBM Corporation and others.
+ * Copyright (c) 2012, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,8 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
 
@@ -23,7 +25,6 @@ import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
-import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
@@ -35,82 +36,104 @@ public class TypeAnnotationCodeStream extends StackMapFrameCodeStream {
 		this.generateAttributes |= ClassFileConstants.ATTR_TYPE_ANNOTATION;
 		this.allTypeAnnotationContexts = new ArrayList();
 	}
-	private void addAnnotationContext(TypeReference typeReference, int info, int targetType, Annotation[][] annotationsOnDimensions) {
-//		if (this.allTypeAnnotationContexts == null) {
-//			this.allTypeAnnotationContexts = new ArrayList();
-//		}
-		typeReference.getAllAnnotationContexts(targetType, info, this.allTypeAnnotationContexts, annotationsOnDimensions);
+	
+	private void addAnnotationContext(TypeReference typeReference, int info, int targetType, Annotation[][] annotationsOnDimensions, int dimensions) {
+		typeReference.getAllAnnotationContexts(targetType, info, this.allTypeAnnotationContexts, annotationsOnDimensions, dimensions);
 	}
+	
 	private void addAnnotationContext(TypeReference typeReference, int info, int targetType) {
-//		if (this.allTypeAnnotationContexts == null) {
-//			this.allTypeAnnotationContexts = new ArrayList();
-//		}
 		typeReference.getAllAnnotationContexts(targetType, info, this.allTypeAnnotationContexts);
 	}
+
 	private void addAnnotationContext(TypeReference typeReference, int info, int typeIndex, int targetType) {
-//		if (this.allTypeAnnotationContexts == null) {
-//			this.allTypeAnnotationContexts = new ArrayList();
-//		}
 		typeReference.getAllAnnotationContexts(targetType, info, typeIndex, this.allTypeAnnotationContexts);
 	}
+	
 	public void instance_of(TypeReference typeReference, TypeBinding typeBinding) {
 		if (typeReference != null && (typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
-			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.TYPE_INSTANCEOF);
+			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.INSTANCEOF);
 		}
 		super.instance_of(typeReference, typeBinding);
 	}
+	
 	public void multianewarray(
 			TypeReference typeReference,
 			TypeBinding typeBinding,
 			int dimensions,
 			Annotation [][] annotationsOnDimensions) {
 		if (typeReference != null && (typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
-			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.OBJECT_CREATION, annotationsOnDimensions);
+			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.NEW, annotationsOnDimensions, dimensions);
 		}
 		super.multianewarray(typeReference, typeBinding, dimensions, annotationsOnDimensions);
 	}
+
 	public void new_(TypeReference typeReference, TypeBinding typeBinding) {
 		if (typeReference != null && (typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
-			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.OBJECT_CREATION);
+			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.NEW);
 		}
 		super.new_(typeReference, typeBinding);
 	}
-	public void newArray(TypeReference typeReference, ArrayBinding arrayBinding) {
-		if (typeReference != null && (typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
-			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.OBJECT_CREATION);
-		}
-		super.newArray(typeReference, arrayBinding);
-	}
-	public void generateClassLiteralAccessForType(TypeReference typeReference, TypeBinding accessedType, FieldBinding syntheticFieldBinding) {
+	
+	public void newArray(TypeReference typeReference, Annotation[][] annotationsOnDimensions, ArrayBinding arrayBinding) {
 		if (typeReference != null && (typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
-			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.CLASS_LITERAL);
+			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.NEW, annotationsOnDimensions, 1);
 		}
-		super.generateClassLiteralAccessForType(typeReference, accessedType, syntheticFieldBinding);
+		super.newArray(typeReference, annotationsOnDimensions, arrayBinding);
 	}
+	
 	public void checkcast(TypeReference typeReference, TypeBinding typeBinding) {
 		if (typeReference != null && (typeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
-			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.TYPE_CAST);
+			addAnnotationContext(typeReference, this.position, AnnotationTargetTypeConstants.CAST);
 		}
 		super.checkcast(typeReference, typeBinding);
 	}
-	public void reset(ClassFile givenClassFile) {
-		super.reset(givenClassFile);
-		this.allTypeAnnotationContexts = new ArrayList();
-	}
-	public void init(ClassFile targetClassFile) {
-		super.init(targetClassFile);
-		this.allTypeAnnotationContexts = new ArrayList();
-	}
+	
 	public void invoke(byte opcode, MethodBinding methodBinding, TypeBinding declaringClass, TypeReference[] typeArguments) {
 		if (typeArguments != null) {
 			int targetType = methodBinding.isConstructor()
-					? AnnotationTargetTypeConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL
-					: AnnotationTargetTypeConstants.TYPE_ARGUMENT_METHOD_CALL;
+					? AnnotationTargetTypeConstants.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
+					: AnnotationTargetTypeConstants.METHOD_INVOCATION_TYPE_ARGUMENT;
 			for (int i = 0, max = typeArguments.length; i < max; i++) {
 				TypeReference typeArgument = typeArguments[i];
-				addAnnotationContext(typeArgument, this.position, i, targetType);
+				if ((typeArgument.bits & ASTNode.HasTypeAnnotations) != 0) { // TODO can check this at a higher level?
+					addAnnotationContext(typeArgument, this.position, i, targetType);
+				}
 			}
 		}
 		super.invoke(opcode, methodBinding, declaringClass, typeArguments);
 	}
+	
+	public void invokeDynamic(int bootStrapIndex, int argsSize, int returnTypeSize, char[] selector, char[] signature, 
+			boolean isConstructorReference, TypeReference lhsTypeReference, TypeReference [] typeArguments) {
+		if (lhsTypeReference != null && (lhsTypeReference.bits & ASTNode.HasTypeAnnotations) != 0) {
+			if (isConstructorReference) {
+				addAnnotationContext(lhsTypeReference, this.position, 0, AnnotationTargetTypeConstants.CONSTRUCTOR_REFERENCE);
+			} else {
+				addAnnotationContext(lhsTypeReference, this.position, 0, AnnotationTargetTypeConstants.METHOD_REFERENCE);
+			}
+		}
+		if (typeArguments != null) {
+			int targetType = 
+					isConstructorReference
+					? AnnotationTargetTypeConstants.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
+					: AnnotationTargetTypeConstants.METHOD_REFERENCE_TYPE_ARGUMENT;
+			for (int i = 0, max = typeArguments.length; i < max; i++) {
+				TypeReference typeArgument = typeArguments[i];
+				if ((typeArgument.bits & ASTNode.HasTypeAnnotations) != 0) {
+					addAnnotationContext(typeArgument, this.position, i, targetType);
+				}
+			}
+		}
+		super.invokeDynamic(bootStrapIndex, argsSize, returnTypeSize, selector, signature, isConstructorReference, lhsTypeReference, typeArguments);
+	}
+
+	public void reset(ClassFile givenClassFile) {
+		super.reset(givenClassFile);
+		this.allTypeAnnotationContexts = new ArrayList();
+	}
+	
+	public void init(ClassFile targetClassFile) {
+		super.init(targetClassFile);
+		this.allTypeAnnotationContexts = new ArrayList();
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotation.java
index a143b4c..689661e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012 IBM Corporation and others.
+ * Copyright (c) 2012, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,16 +11,18 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.core.util;
 
 /**
  * Description of an extended annotation structure as described in the JVM specifications
- * (added in JavaSE-1.7).
+ * (added in JavaSE-1.8).
  *
  * This interface may be implemented by clients.
  *
- * @since 3.9
+ * @since 3.9 BETA_JAVA8
  */
 public interface IExtendedAnnotation extends IAnnotation {
 	/**
@@ -40,18 +42,18 @@ public interface IExtendedAnnotation extends IAnnotation {
 	 * <th>offset description</th>
 	 * </tr>
 	 * <tr>
-	 * <td>0x00, 0x02, 0x04, 0x1E</td>
-	 * <td>The offset within the bytecodes of the containing method of the <code>checkcast</code> 
-	 * bytecode emitted for a typecast, the <code>instanceof</code> bytecode for the type tests, 
-	 * the <code>new</code> bytecode emitted for the object creation expression, the <code>ldc(_w)</code>
-	 * bytecode emitted for class literal, or the <code>getstatic</code> bytecode emitted for primitive
-	 * class literals.</td>
+	 * <td>0x43 (INSTANCE_OF), 0x44 (NEW), 0x45 (CONSTRUCTOR_REFERENCE), 0x46 (METHOD_REFERENCE)</td>
+	 * <td>The offset within the bytecodes of the <code>instanceof</code> bytecode for INSTANCE_OF,
+	 * the <code>new</code> bytecode for NEW and the implementing instruction for either a
+	 * CONSTRUCTOR_REFERENCE or METHOD_REFERENCE.</td>
 	 * </tr>
 	 * <tr>
-	 * <td>0x18, 0x1A</td>
-	 * <td>The offset within the bytecodes of the containing method of the <code>new</code> 
-	 * bytecode emitted for a constructor call, or the <code>invoke{interface|special|static|virtual}</code>
-	 * bytecode emitted for a method invocation.</td>
+	 * <td>0x47 (CAST), 0x48 (CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT), 0x49 (METHOD_INVOCATION_TYPE_ARGUMENT),
+	 * 0x4A (CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT), 0x4B (METHOD_REFERENCE_TYPE_ARGUMENT)</td>
+	 * <td>The offset within the bytecodes of the <code>new</code> bytecode for constructor call, or the
+	 * relevant bytecode for method invocation or method reference. For CAST the offset may
+	 * point to the <code>checkcast</code> or another instruction as it is possible the cast
+	 * may have been discarded by the compiler if it were a no-op.</td>
 	 * </tr>
 	 * </table>
 	 * 
@@ -61,6 +63,13 @@ public interface IExtendedAnnotation extends IAnnotation {
 	int getOffset();
 	
 	/**
+	 * Answer back the exception table index when the target_type is EXCEPTION_PARAMETER.
+	 * 
+	 * @return the exception table index
+	 */
+	int getExceptionTableIndex();
+	
+	/**
 	 * Answer back the local variable reference info table length of this entry as specified in
 	 * the JVM specifications.
 	 * 
@@ -92,20 +101,20 @@ public interface IExtendedAnnotation extends IAnnotation {
 	int getParameterIndex();
 
 	/**
-	 * Answer back the method type parameter index.
+	 * Answer back the index of the type parameter of the class or method
 	 * 
 	 * <p>The index is 0-based.</p>
 	 * 
-	 * @return the method type parameter index
+	 * @return the index of the type parameter of the class or method
 	 */
 	int getTypeParameterIndex();
 
 	/**
-	 * Answer back the method type parameter bound index.
+	 * Answer back the index of the bound of the type parameter of the method or class
 	 * 
 	 * <p>The index is 0-based.</p>
 	 * 
-	 * @return the method type parameter bound index
+	 * @return the index of the bound of the type parameter of the method or class
 	 */
 	int getTypeParameterBoundIndex();
 
@@ -120,45 +129,33 @@ public interface IExtendedAnnotation extends IAnnotation {
 	 * <th>offset description</th>
 	 * </tr>
 	 * <tr>
-	 * <td>0x18, 0x1A</td>
-	 * <td>the type argument index in the expression</td>
-	 * </tr>
-	 * <tr>
-	 * <td>0x14</td>
-	 * <td>the index of the type in the clause: <code>-1 (255)</code> is used if the annotation is on 
+	 * <td>0x10 (CLASS_EXTENDS)</td>
+	 * <td>the index of the type in the clause: <code>-1 (65535)</code> is used if the annotation is on 
 	 * the superclass type, and the value <code>i</code> is used if the annotation is on the <code>i</code>th
 	 * superinterface type (counting from zero).</td>
 	 * </tr>
 	 * <tr>
-	 * <td>0x16</td>
+	 * <td>0x17 (THROWS)</td>
 	 * <td>the index of the exception type in the clause: the value <code>i</code> denotes an annotation of the 
 	 * <code>i</code>th exception type (counting from zero).</td>
 	 * </tr>
+	 * <tr>
+	 * <td>0x47 (CAST), 0x48 (CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT), 0x49 (METHOD_INVOCATION_TYPE_ARGUMENT),
+	 * 0x4A (CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT), 0x4B (METHOD_REFERENCE_TYPE_ARGUMENT)</td>
+	 * <td>the type argument index in the expression</td>
+	 * </tr>
 	 * </table>
 	 * @return the index in the given different situations
 	 */
 	int getAnnotationTypeIndex();
 	
 	/**
-	 * Answer back the target type of the location of the wildcard as described in the JVM specifications.
-	 *
-	 * @return the target type of the location of the wildcard
-	 */
-	int getWildcardLocationType();
-	
-	/**
-	 * Answer back the locations of the wildcard type as described in the JVM specifications.
-	 *
-	 * @return the locations of the wildcard type
-	 */
-	int[] getWildcardLocations();
-	
-	/**
 	 * Answer back the locations of the annotated type as described in the JVM specifications.
 	 * 
 	 * <p>This is used for parameterized and array types.</p>
 	 *
 	 * @return the locations of the annotated type
 	 */
-	int[] getLocations();
+	int[][] getTypePath();
+	
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotationConstants.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotationConstants.java
index 15d2647..6996de6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotationConstants.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotationConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012 IBM Corporation and others.
+ * Copyright (c) 2012, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,8 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.core.util;
 
@@ -18,47 +20,42 @@ import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
 
 /**
  * Description of an extended annotation target types constants as described in the JVM specifications
- * (added in JavaSE-1.7).
+ * (added in JavaSE-1.8).
  *
- * @since 3.9
+ * @since 3.9 BETA_JAVA8
  * @noimplement This interface is not intended to be implemented by clients.
  * @noextend This interface is not intended to be extended by clients.
  */
 public interface IExtendedAnnotationConstants {
-	int METHOD_RECEIVER = AnnotationTargetTypeConstants.METHOD_RECEIVER;
-	int METHOD_RECEIVER_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.METHOD_RECEIVER_GENERIC_OR_ARRAY;
-	int METHOD_RETURN_TYPE = AnnotationTargetTypeConstants.METHOD_RETURN_TYPE;
-	int METHOD_RETURN_TYPE_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.METHOD_RETURN_TYPE_GENERIC_OR_ARRAY;
-	int METHOD_PARAMETER = AnnotationTargetTypeConstants.METHOD_PARAMETER;
-	int METHOD_PARAMETER_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.METHOD_PARAMETER_GENERIC_OR_ARRAY;
-	int FIELD = AnnotationTargetTypeConstants.FIELD;
-	int FIELD_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.FIELD_GENERIC_OR_ARRAY;
+	
+	int CLASS_TYPE_PARAMETER = AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER;
+	int METHOD_TYPE_PARAMETER = AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER;
+
+	int CLASS_EXTENDS = AnnotationTargetTypeConstants.CLASS_EXTENDS;
 	int CLASS_TYPE_PARAMETER_BOUND = AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND;
-	int CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY;
 	int METHOD_TYPE_PARAMETER_BOUND = AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND;
-	int METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY;
-	int CLASS_EXTENDS_IMPLEMENTS = AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS;
-	int CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY;
+	int FIELD = AnnotationTargetTypeConstants.FIELD;
+	int METHOD_RETURN = AnnotationTargetTypeConstants.METHOD_RETURN;
+	int METHOD_RECEIVER = AnnotationTargetTypeConstants.METHOD_RECEIVER;
+	int METHOD_FORMAL_PARAMETER = AnnotationTargetTypeConstants.METHOD_FORMAL_PARAMETER;
 	int THROWS = AnnotationTargetTypeConstants.THROWS;
-	int THROWS_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.THROWS_GENERIC_OR_ARRAY;
-	int WILDCARD_BOUND = AnnotationTargetTypeConstants.WILDCARD_BOUND;
-	int WILDCARD_BOUND_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.WILDCARD_BOUND_GENERIC_OR_ARRAY;
-	int METHOD_TYPE_PARAMETER = AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER;
-	int METHOD_TYPE_PARAMETER_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_GENERIC_OR_ARRAY;
-	int CLASS_TYPE_PARAMETER = AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER;
-	int CLASS_TYPE_PARAMETER_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_GENERIC_OR_ARRAY;
-	int TYPE_CAST = AnnotationTargetTypeConstants.TYPE_CAST;
-	int TYPE_CAST_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.TYPE_CAST_GENERIC_OR_ARRAY;
-	int TYPE_INSTANCEOF = AnnotationTargetTypeConstants.TYPE_INSTANCEOF;
-	int TYPE_INSTANCEOF_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.TYPE_INSTANCEOF_GENERIC_OR_ARRAY;
-	int OBJECT_CREATION = AnnotationTargetTypeConstants.OBJECT_CREATION;
-	int OBJECT_CREATION_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.OBJECT_CREATION_GENERIC_OR_ARRAY;
+
 	int LOCAL_VARIABLE = AnnotationTargetTypeConstants.LOCAL_VARIABLE;
-	int LOCAL_VARIABLE_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.LOCAL_VARIABLE_GENERIC_OR_ARRAY;
-	int TYPE_ARGUMENT_CONSTRUCTOR_CALL = AnnotationTargetTypeConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL;
-	int TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY;
-	int TYPE_ARGUMENT_METHOD_CALL = AnnotationTargetTypeConstants.TYPE_ARGUMENT_METHOD_CALL;
-	int TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY;
-	int CLASS_LITERAL = AnnotationTargetTypeConstants.CLASS_LITERAL;
-	int CLASS_LITERAL_GENERIC_OR_ARRAY = AnnotationTargetTypeConstants.CLASS_LITERAL_GENERIC_OR_ARRAY;
+	int RESOURCE_VARIABLE = AnnotationTargetTypeConstants.RESOURCE_VARIABLE;
+	int EXCEPTION_PARAMETER = AnnotationTargetTypeConstants.EXCEPTION_PARAMETER;
+	int INSTANCEOF = AnnotationTargetTypeConstants.INSTANCEOF;
+	int NEW = AnnotationTargetTypeConstants.NEW;
+	int CONSTRUCTOR_REFERENCE = AnnotationTargetTypeConstants.CONSTRUCTOR_REFERENCE;
+	int METHOD_REFERENCE = AnnotationTargetTypeConstants.METHOD_REFERENCE;
+	int CAST = AnnotationTargetTypeConstants.CAST;
+	int CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = AnnotationTargetTypeConstants.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT;
+	int METHOD_INVOCATION_TYPE_ARGUMENT = AnnotationTargetTypeConstants.METHOD_INVOCATION_TYPE_ARGUMENT;
+	int CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT = AnnotationTargetTypeConstants.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT;
+	int METHOD_REFERENCE_TYPE_ARGUMENT = AnnotationTargetTypeConstants.METHOD_REFERENCE_TYPE_ARGUMENT;
+	
+	// Type path entry kinds
+	int TYPE_PATH_DEEPER_IN_ARRAY = 0;
+	int TYPE_PATH_DEEPER_IN_INNER_TYPE = 1;
+	int TYPE_PATH_ANNOTATION_ON_WILDCARD_BOUND = 2;
+	int TYPE_PATH_TYPE_ARGUMENT_INDEX = 3;
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeAttribute.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeAttribute.java
index a281ab0..47be053 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeAttribute.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeAttribute.java
@@ -1,12 +1,18 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
 
@@ -86,6 +92,10 @@ public class CodeAttribute extends ClassFileAttribute implements ICodeAttribute
 				this.attributes[attributesIndex++] = new StackMapTableAttribute(classFileBytes, constantPool, offset + readOffset);
 			} else if (equals(attributeName, IAttributeNamesConstants.STACK_MAP)) {
 				this.attributes[attributesIndex++] = new StackMapAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (equals(attributeName, IAttributeNamesConstants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS)) {
+				this.attributes[attributesIndex++] = new RuntimeVisibleTypeAnnotationsAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (equals(attributeName, IAttributeNamesConstants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS)) {
+				this.attributes[attributesIndex++] = new RuntimeInvisibleTypeAnnotationsAttribute(classFileBytes, constantPool, offset + readOffset);
 			} else {
 				this.attributes[attributesIndex++] = new ClassFileAttribute(classFileBytes, constantPool, offset + readOffset);
 			}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
index 32f5c01..a302f88 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
@@ -8,9 +8,11 @@
  * This is an implementation of an early-draft specification developed under the Java
  * Community Process (JCP) and is made available for testing and evaluation purposes
  * only. The code is not compatible with any specification of the JCP.
- * 
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
 
@@ -262,7 +264,7 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		writeNewLine(buffer, lineSeparator, tabNumber + 1);
 		buffer.append(Messages.disassembler_annotationentryend);
 	}
-
+	
 	private void disassemble(IExtendedAnnotation extendedAnnotation, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
 		writeNewLine(buffer, lineSeparator, tabNumber + 1);
 		final int typeIndex = extendedAnnotation.getTypeIndex();
@@ -285,102 +287,30 @@ public class Disassembler extends ClassFileBytesDisassembler {
 				}));
 		switch(targetType) {
 			case IExtendedAnnotationConstants.METHOD_RECEIVER :
-			case IExtendedAnnotationConstants.METHOD_RETURN_TYPE :
+			case IExtendedAnnotationConstants.METHOD_RETURN:
 			case IExtendedAnnotationConstants.FIELD :
 				break;
 			default:
 				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-		}
-		
-		switch(targetType) {
-			case IExtendedAnnotationConstants.WILDCARD_BOUND :
-				int wildcardLocationType = extendedAnnotation.getWildcardLocationType();
-				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_wildcardlocationtype, new String[] {
-							Integer.toString(wildcardLocationType),
-							getTargetType(wildcardLocationType),
-						}));
-				writeNewLine(buffer, lineSeparator, tabNumber + 3);
-				disassembleTargetTypeContents(true, wildcardLocationType, extendedAnnotation, buffer, lineSeparator, tabNumber + 3, mode);
-				break;
-			case IExtendedAnnotationConstants.WILDCARD_BOUND_GENERIC_OR_ARRAY :
-				wildcardLocationType = extendedAnnotation.getWildcardLocationType();
-				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_wildcardlocationtype, new String[] {
-							Integer.toString(wildcardLocationType),
-							getTargetType(wildcardLocationType),
-						}));
-				writeNewLine(buffer, lineSeparator, tabNumber + 3);
-				disassembleTargetTypeContents(true, wildcardLocationType, extendedAnnotation, buffer, lineSeparator, tabNumber + 3, mode);
-				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_locations, new String[] {
-							toString(extendedAnnotation.getLocations()),
-						}));
-				break;
-			default:
 				disassembleTargetTypeContents(false, targetType, extendedAnnotation, buffer, lineSeparator, tabNumber, mode);
 		}
+		disassembleTypePathContents(targetType, extendedAnnotation, buffer, lineSeparator, tabNumber, mode);
 		writeNewLine(buffer, lineSeparator, tabNumber + 1);
 		buffer.append(Messages.disassembler_extendedannotationentryend);
 	}
 
+	private void disassembleTypePathContents(int targetType, IExtendedAnnotation extendedAnnotation,StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		int[][] typepath = extendedAnnotation.getTypePath();
+		if (typepath.length != 0) {
+			writeNewLine(buffer, lineSeparator, tabNumber + 2);
+			buffer.append(
+				Messages.bind(Messages.disassembler_extendedannotation_typepath, new String[] {
+						toTypePathString(typepath),
+				}));
+		}
+	}
 	private void disassembleTargetTypeContents(boolean insideWildcard, int targetType, IExtendedAnnotation extendedAnnotation, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
 		switch(targetType) {
-			case IExtendedAnnotationConstants.CLASS_EXTENDS_IMPLEMENTS :
-				buffer.append(
-					Messages.bind(Messages.disassembler_extendedannotation_classextendsimplements, new String[] {
-						Integer.toString(extendedAnnotation.getAnnotationTypeIndex()),
-					}));
-				break;
-			case IExtendedAnnotationConstants.CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY :
-				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_classextendsimplements, new String[] {
-							Integer.toString(extendedAnnotation.getAnnotationTypeIndex()),
-						}));
-				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-				if (insideWildcard) {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_wildcardlocations, new String[] {
-								toString(extendedAnnotation.getWildcardLocations()),
-							}));
-				} else {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_locations, new String[] {
-								toString(extendedAnnotation.getLocations()),
-							}));
-				}
-				break;
-			case IExtendedAnnotationConstants.TYPE_CAST :
-			case IExtendedAnnotationConstants.TYPE_INSTANCEOF :
-			case IExtendedAnnotationConstants.OBJECT_CREATION :
-			case IExtendedAnnotationConstants.CLASS_LITERAL :
-				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_offset, new String[] {
-							Integer.toString(extendedAnnotation.getOffset()),
-						}));
-				break;
-			case IExtendedAnnotationConstants.TYPE_CAST_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.TYPE_INSTANCEOF_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.OBJECT_CREATION_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.CLASS_LITERAL_GENERIC_OR_ARRAY :
-				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_offset, new String[] {
-							Integer.toString(extendedAnnotation.getOffset()),
-						}));
-				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-				if (insideWildcard) {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_wildcardlocations, new String[] {
-								toString(extendedAnnotation.getWildcardLocations()),
-							}));
-				} else {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_locations, new String[] {
-								toString(extendedAnnotation.getLocations()),
-							}));
-				}
-				break;
 			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER :
 			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER :
 				buffer.append(
@@ -388,54 +318,40 @@ public class Disassembler extends ClassFileBytesDisassembler {
 							Integer.toString(extendedAnnotation.getTypeParameterIndex()),
 						}));
 				break;
-			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_GENERIC_OR_ARRAY :
+			case IExtendedAnnotationConstants.CLASS_EXTENDS :
 				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_type_parameter, new String[] {
-							Integer.toString(extendedAnnotation.getTypeParameterIndex()),
-						}));
-				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-				if (insideWildcard) {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_wildcardlocations, new String[] {
-								toString(extendedAnnotation.getWildcardLocations()),
-							}));
-				} else {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_locations, new String[] {
-								toString(extendedAnnotation.getLocations()),
-							}));
-				}
+					Messages.bind(Messages.disassembler_extendedannotation_classextendsimplements, new String[] {
+						Integer.toString(extendedAnnotation.getAnnotationTypeIndex()),
+					}));
 				break;
-			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_BOUND :
+				
 			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER_BOUND :
+			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_BOUND :
 				buffer.append(
 						Messages.bind(Messages.disassembler_extendedannotation_type_parameter_with_bound, new String[] {
 							Integer.toString(extendedAnnotation.getTypeParameterIndex()),
 							Integer.toString(extendedAnnotation.getTypeParameterBoundIndex()),
 						}));
+				break;				
+			case IExtendedAnnotationConstants.FIELD :
+			case IExtendedAnnotationConstants.METHOD_RETURN :
+			case IExtendedAnnotationConstants.METHOD_RECEIVER :
 				break;
-			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY :
+			case IExtendedAnnotationConstants.METHOD_FORMAL_PARAMETER :
 				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_type_parameter_with_bound, new String[] {
-							Integer.toString(extendedAnnotation.getTypeParameterIndex()),
-							Integer.toString(extendedAnnotation.getTypeParameterBoundIndex()),
+						Messages.bind(Messages.disassembler_extendedannotation_method_parameter, new String[] {
+							Integer.toString(extendedAnnotation.getParameterIndex()),
 						}));
-				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-				if (insideWildcard) {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_wildcardlocations, new String[] {
-								toString(extendedAnnotation.getWildcardLocations()),
-							}));
-				} else {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_locations, new String[] {
-								toString(extendedAnnotation.getLocations()),
-							}));
-				}
 				break;
+			case IExtendedAnnotationConstants.THROWS :
+				buffer.append(
+						Messages.bind(Messages.disassembler_extendedannotation_throws, new String[] {
+							Integer.toString(extendedAnnotation.getAnnotationTypeIndex()),
+						}));
+				break;
+
 			case IExtendedAnnotationConstants.LOCAL_VARIABLE :
+			case IExtendedAnnotationConstants.RESOURCE_VARIABLE :
 				buffer.append(Messages.disassembler_localvariabletargetheader);
 				writeNewLine(buffer, lineSeparator, tabNumber + 3);
 				int localVariableTableSize = extendedAnnotation.getLocalVariableRefenceInfoLength();
@@ -456,92 +372,27 @@ public class Disassembler extends ClassFileBytesDisassembler {
 						}));
 				}
 				break;
-			case IExtendedAnnotationConstants.LOCAL_VARIABLE_GENERIC_OR_ARRAY :
-				buffer.append(Messages.disassembler_localvariabletargetheader);
-				writeNewLine(buffer, lineSeparator, tabNumber + 3);
-				localVariableTableSize = extendedAnnotation.getLocalVariableRefenceInfoLength();
-				localVariableTable = extendedAnnotation.getLocalVariableTable();
-				for (int i = 0; i < localVariableTableSize; i++) {
-					if (i != 0) {
-						writeNewLine(buffer, lineSeparator, tabNumber + 3);
-					}
-					ILocalVariableReferenceInfo info = localVariableTable[i];
-					int index= info.getIndex();
-					int startPC = info.getStartPC();
-					int length  = info.getLength();
-					buffer.append(Messages.bind(Messages.classfileformat_localvariablereferenceinfoentry,
-						new String[] {
-							Integer.toString(startPC),
-							Integer.toString(startPC + length),
-							Integer.toString(index),
-						}));
-				}
-				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-				if (insideWildcard) {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_wildcardlocations, new String[] {
-								toString(extendedAnnotation.getWildcardLocations()),
-							}));
-				} else {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_locations, new String[] {
-								toString(extendedAnnotation.getLocations()),
-							}));
-				}
-				break;
-			case IExtendedAnnotationConstants.METHOD_PARAMETER :
+			case IExtendedAnnotationConstants.EXCEPTION_PARAMETER :
 				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_method_parameter, new String[] {
-							Integer.toString(extendedAnnotation.getTypeParameterIndex()),
+						Messages.bind(Messages.disassembler_extendedannotation_exception_table_index, new String[] {
+							Integer.toString(extendedAnnotation.getExceptionTableIndex()),
 						}));
 				break;
-			case IExtendedAnnotationConstants.METHOD_PARAMETER_GENERIC_OR_ARRAY :
-				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_method_parameter, new String[] {
-							Integer.toString(extendedAnnotation.getTypeParameterIndex()),
-						}));
-				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-				if (insideWildcard) {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_wildcardlocations, new String[] {
-								toString(extendedAnnotation.getWildcardLocations()),
-							}));
-				} else {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_locations, new String[] {
-								toString(extendedAnnotation.getLocations()),
-							}));
-				}
-				break;
-			case IExtendedAnnotationConstants.METHOD_RECEIVER_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.METHOD_RETURN_TYPE_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.FIELD_GENERIC_OR_ARRAY :
-				if (insideWildcard) {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_wildcardlocations, new String[] {
-								toString(extendedAnnotation.getWildcardLocations()),
-							}));
-				} else {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_locations, new String[] {
-								toString(extendedAnnotation.getLocations()),
-							}));
-				}
-				break;
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL :
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_METHOD_CALL :
+				
+			case IExtendedAnnotationConstants.INSTANCEOF :
+			case IExtendedAnnotationConstants.NEW :
+			case IExtendedAnnotationConstants.CONSTRUCTOR_REFERENCE :
+			case IExtendedAnnotationConstants.METHOD_REFERENCE :
 				buffer.append(
 						Messages.bind(Messages.disassembler_extendedannotation_offset, new String[] {
 							Integer.toString(extendedAnnotation.getOffset()),
 						}));
-				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_type_argument, new String[] {
-							Integer.toString(extendedAnnotation.getAnnotationTypeIndex()),
-						}));
 				break;
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY :
+			case IExtendedAnnotationConstants.CAST :
+			case IExtendedAnnotationConstants.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT :
+			case IExtendedAnnotationConstants.METHOD_INVOCATION_TYPE_ARGUMENT :
+			case IExtendedAnnotationConstants.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT :
+			case IExtendedAnnotationConstants.METHOD_REFERENCE_TYPE_ARGUMENT :
 				buffer.append(
 						Messages.bind(Messages.disassembler_extendedannotation_offset, new String[] {
 							Integer.toString(extendedAnnotation.getOffset()),
@@ -551,124 +402,63 @@ public class Disassembler extends ClassFileBytesDisassembler {
 						Messages.bind(Messages.disassembler_extendedannotation_type_argument, new String[] {
 							Integer.toString(extendedAnnotation.getAnnotationTypeIndex()),
 						}));
-				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-				if (insideWildcard) {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_wildcardlocations, new String[] {
-								toString(extendedAnnotation.getWildcardLocations()),
-							}));
-				} else {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_locations, new String[] {
-								toString(extendedAnnotation.getLocations()),
-							}));
-				}
-				break;
-			case IExtendedAnnotationConstants.THROWS :
-				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_throws, new String[] {
-							Integer.toString(extendedAnnotation.getAnnotationTypeIndex()),
-						}));
-				break;
-			case IExtendedAnnotationConstants.THROWS_GENERIC_OR_ARRAY :
-				buffer.append(
-						Messages.bind(Messages.disassembler_extendedannotation_throws, new String[] {
-							Integer.toString(extendedAnnotation.getAnnotationTypeIndex()),
-						}));
-				writeNewLine(buffer, lineSeparator, tabNumber + 2);
-				if (insideWildcard) {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_wildcardlocations, new String[] {
-								toString(extendedAnnotation.getWildcardLocations()),
-							}));
-				} else {
-					buffer.append(
-							Messages.bind(Messages.disassembler_extendedannotation_locations, new String[] {
-								toString(extendedAnnotation.getLocations()),
-							}));
-				}
 				break;
 		}
 	}
 	private String getTargetType(int targetType) {
 		switch(targetType) {
-			case IExtendedAnnotationConstants.CLASS_EXTENDS_IMPLEMENTS :
-				return "CLASS_EXTENDS_IMPLEMENTS"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY :
-				return "CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.TYPE_CAST :
-				return "TYPE_CAST"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.TYPE_INSTANCEOF :
-				return "TYPE_INSTANCEOF"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.OBJECT_CREATION :
-				return "OBJECT_CREATION"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.CLASS_LITERAL :
-				return "CLASS_LITERAL"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.TYPE_CAST_GENERIC_OR_ARRAY :
-				return "TYPE_CAST_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.TYPE_INSTANCEOF_GENERIC_OR_ARRAY :
-				return "TYPE_INSTANCEOF_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.OBJECT_CREATION_GENERIC_OR_ARRAY :
-				return "OBJECT_CREATION_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.CLASS_LITERAL_GENERIC_OR_ARRAY :
-				return "CLASS_LITERAL_GENERIC_OR_ARRAY"; //$NON-NLS-1$
 			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER :
 				return "CLASS_TYPE_PARAMETER"; //$NON-NLS-1$
 			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER :
 				return "METHOD_TYPE_PARAMETER"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER_GENERIC_OR_ARRAY :
-				return "CLASS_TYPE_PARAMETER_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_GENERIC_OR_ARRAY :
-				return "METHOD_TYPE_PARAMETER_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_BOUND :
-				return "METHOD_TYPE_PARAMETER_BOUND"; //$NON-NLS-1$
+
+			case IExtendedAnnotationConstants.CLASS_EXTENDS :
+				return "CLASS_EXTENDS"; //$NON-NLS-1$
 			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER_BOUND :
 				return "CLASS_TYPE_PARAMETER_BOUND"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY :
-				return "METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY :
-				return "CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.LOCAL_VARIABLE :
-				return "LOCAL_VARIABLE"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.LOCAL_VARIABLE_GENERIC_OR_ARRAY :
-				return "LOCAL_VARIABLE_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.METHOD_PARAMETER :
-				return "METHOD_PARAMETER"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.METHOD_PARAMETER_GENERIC_OR_ARRAY :
-				return "METHOD_PARAMETER_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.METHOD_RECEIVER_GENERIC_OR_ARRAY :
-				return "METHOD_RECEIVER_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.METHOD_RETURN_TYPE_GENERIC_OR_ARRAY :
-				return "METHOD_RETURN_TYPE_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.METHOD_RECEIVER :
-				return "METHOD_RECEIVER"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.METHOD_RETURN_TYPE :
-				return "METHOD_RETURN_TYPE"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_BOUND :
+				return "METHOD_TYPE_PARAMETER_BOUND"; //$NON-NLS-1$
 			case IExtendedAnnotationConstants.FIELD :
 				return "FIELD"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.FIELD_GENERIC_OR_ARRAY :
-				return "FIELD_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL :
-				return "TYPE_ARGUMENT_CONSTRUCTOR_CALL"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_METHOD_CALL :
-				return "TYPE_ARGUMENT_METHOD_CALL"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY :
-				return "TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY :
-				return "TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.METHOD_RETURN :
+				return "METHOD_RETURN"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.METHOD_RECEIVER :
+				return "METHOD_RECEIVER"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.METHOD_FORMAL_PARAMETER :
+				return "METHOD_FORMAL_PARAMETER"; //$NON-NLS-1$
 			case IExtendedAnnotationConstants.THROWS :
 				return "THROWS"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.THROWS_GENERIC_OR_ARRAY :
-				return "THROWS_GENERIC_OR_ARRAY"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.WILDCARD_BOUND :
-				return "WILDCARD_BOUND"; //$NON-NLS-1$
-			case IExtendedAnnotationConstants.WILDCARD_BOUND_GENERIC_OR_ARRAY :
-				return "WILDCARD_BOUND_GENERIC_OR_ARRAY"; //$NON-NLS-1$
+
+			case IExtendedAnnotationConstants.LOCAL_VARIABLE :
+				return "LOCAL_VARIABLE"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.RESOURCE_VARIABLE :
+				return "RESOURCE_VARIABLE"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.EXCEPTION_PARAMETER :
+				return "EXCEPTION_PARAMETER"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.INSTANCEOF :
+				return "INSTANCEOF"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.NEW :
+				return "NEW"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.CONSTRUCTOR_REFERENCE :
+				return "CONSTRUCTOR_REFERENCE"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.METHOD_REFERENCE :
+				return "METHOD_REFERENCE"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.CAST :
+				return "CAST"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT :
+				return "CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.METHOD_INVOCATION_TYPE_ARGUMENT :
+				return "METHOD_INVOCATION_TYPE_ARGUMENT"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT :
+				return "CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT"; //$NON-NLS-1$
+			case IExtendedAnnotationConstants.METHOD_REFERENCE_TYPE_ARGUMENT :
+				return "METHOD_REFERENCE_TYPE_ARGUMENT"; //$NON-NLS-1$
 			default:
 				return "UNKNOWN"; //$NON-NLS-1$
 		}
 	}
 
+
 	private void disassemble(IAnnotationComponent annotationComponent, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
 		writeNewLine(buffer, lineSeparator, tabNumber + 1);
 		buffer.append(
@@ -1128,7 +918,7 @@ public class Disassembler extends ClassFileBytesDisassembler {
 			}
 			if (runtimeInvisibleTypeAnnotationsAttribute != null) {
 				disassemble((IRuntimeInvisibleTypeAnnotationsAttribute) runtimeInvisibleTypeAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
-			}
+ 			}
 		}
 	}
 
@@ -1222,7 +1012,9 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		IInnerClassesAttribute innerClassesAttribute = classFileReader.getInnerClassesAttribute();
 		IClassFileAttribute runtimeVisibleAnnotationsAttribute = Util.getAttribute(classFileReader, IAttributeNamesConstants.RUNTIME_VISIBLE_ANNOTATIONS);
 		IClassFileAttribute runtimeInvisibleAnnotationsAttribute = Util.getAttribute(classFileReader, IAttributeNamesConstants.RUNTIME_INVISIBLE_ANNOTATIONS);
-	
+		IClassFileAttribute runtimeVisibleTypeAnnotationsAttribute = Util.getAttribute(classFileReader, IAttributeNamesConstants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);
+		IClassFileAttribute runtimeInvisibleTypeAnnotationsAttribute = Util.getAttribute(classFileReader, IAttributeNamesConstants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
+
 		IClassFileAttribute bootstrapMethods = Util.getAttribute(classFileReader, IAttributeNamesConstants.BOOTSTRAP_METHODS);
 	
 		if (checkMode(mode, DETAILED)) {
@@ -1369,6 +1161,12 @@ public class Disassembler extends ClassFileBytesDisassembler {
 				if (runtimeInvisibleAnnotationsAttribute != null) {
 					disassemble((IRuntimeInvisibleAnnotationsAttribute) runtimeInvisibleAnnotationsAttribute, buffer, lineSeparator, 0, mode);
 				}
+				if (runtimeVisibleTypeAnnotationsAttribute != null) {
+					disassemble((IRuntimeVisibleTypeAnnotationsAttribute) runtimeVisibleTypeAnnotationsAttribute, buffer, lineSeparator, 0, mode);
+				}
+				if (runtimeInvisibleTypeAnnotationsAttribute != null) {
+					disassemble((IRuntimeInvisibleTypeAnnotationsAttribute) runtimeInvisibleTypeAnnotationsAttribute, buffer, lineSeparator, 0, mode);
+	 			}
 				if (length != 0) {
 					for (int i = 0; i < length; i++) {
 						IClassFileAttribute attribute = attributes[i];
@@ -1378,6 +1176,8 @@ public class Disassembler extends ClassFileBytesDisassembler {
 								&& attribute != enclosingMethodAttribute
 								&& attribute != runtimeInvisibleAnnotationsAttribute
 								&& attribute != runtimeVisibleAnnotationsAttribute
+								&& attribute != runtimeInvisibleTypeAnnotationsAttribute
+								&& attribute != runtimeVisibleTypeAnnotationsAttribute
 								&& !CharOperation.equals(attribute.getAttributeName(), IAttributeNamesConstants.DEPRECATED)
 								&& !CharOperation.equals(attribute.getAttributeName(), IAttributeNamesConstants.SYNTHETIC)
 								&& attribute != bootstrapMethods) {
@@ -1602,6 +1402,10 @@ public class Disassembler extends ClassFileBytesDisassembler {
 					if (numberOfEntries != 0) {
 						disassemble(stackMapAttribute, buffer, lineSeparator, tabNumber, mode);
 					}
+				} else if (CharOperation.equals(attribute.getAttributeName(),IAttributeNamesConstants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS)) {
+					disassemble((IRuntimeVisibleTypeAnnotationsAttribute) attribute, buffer, lineSeparator, tabNumber, mode);
+				} else if (CharOperation.equals(attribute.getAttributeName(),IAttributeNamesConstants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS)) {
+					disassemble((IRuntimeInvisibleTypeAnnotationsAttribute) attribute, buffer, lineSeparator, tabNumber, mode);					
 				} else if (attribute != lineNumberAttribute
 						&& attribute != localVariableAttribute
 						&& attribute != localVariableTypeAttribute) {
@@ -2113,7 +1917,7 @@ public class Disassembler extends ClassFileBytesDisassembler {
 			}
 			if (runtimeInvisibleTypeAnnotationsAttribute != null) {
 				disassemble((IRuntimeInvisibleTypeAnnotationsAttribute) runtimeInvisibleTypeAnnotationsAttribute, buffer, lineSeparator, tabNumber, mode);
-			}
+ 			}
 		}
 	}
 
@@ -2247,16 +2051,7 @@ public class Disassembler extends ClassFileBytesDisassembler {
 			disassemble(i, parameterAnnotations[i], buffer, lineSeparator, tabNumber + 1, mode);
 		}
 	}
-
-	private void disassemble(IRuntimeVisibleAnnotationsAttribute runtimeVisibleAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
-		writeNewLine(buffer, lineSeparator, tabNumber + 1);
-		buffer.append(Messages.disassembler_runtimevisibleannotationsattributeheader);
-		IAnnotation[] annotations = runtimeVisibleAnnotationsAttribute.getAnnotations();
-		for (int i = 0, max = annotations.length; i < max; i++) {
-			disassemble(annotations[i], buffer, lineSeparator, tabNumber + 1, mode);
-		}
-	}
-
+	
 	private void disassemble(IRuntimeInvisibleTypeAnnotationsAttribute runtimeInvisibleTypeAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
 		writeNewLine(buffer, lineSeparator, tabNumber + 1);
 		buffer.append(Messages.disassembler_runtimeinvisibletypeannotationsattributeheader);
@@ -2265,13 +2060,13 @@ public class Disassembler extends ClassFileBytesDisassembler {
 			disassemble(extendedAnnotations[i], buffer, lineSeparator, tabNumber + 1, mode);
 		}
 	}
-
-	private void disassemble(IRuntimeVisibleTypeAnnotationsAttribute runtimeVisibleTypeAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		
+	private void disassemble(IRuntimeVisibleAnnotationsAttribute runtimeVisibleAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
 		writeNewLine(buffer, lineSeparator, tabNumber + 1);
-		buffer.append(Messages.disassembler_runtimevisibletypeannotationsattributeheader);
-		IExtendedAnnotation[] extendedAnnotations = runtimeVisibleTypeAnnotationsAttribute.getExtendedAnnotations();
-		for (int i = 0, max = extendedAnnotations.length; i < max; i++) {
-			disassemble(extendedAnnotations[i], buffer, lineSeparator, tabNumber + 1, mode);
+		buffer.append(Messages.disassembler_runtimevisibleannotationsattributeheader);
+		IAnnotation[] annotations = runtimeVisibleAnnotationsAttribute.getAnnotations();
+		for (int i = 0, max = annotations.length; i < max; i++) {
+			disassemble(annotations[i], buffer, lineSeparator, tabNumber + 1, mode);
 		}
 	}
 
@@ -2283,6 +2078,15 @@ public class Disassembler extends ClassFileBytesDisassembler {
 			disassemble(i, parameterAnnotations[i], buffer, lineSeparator, tabNumber + 1, mode);
 		}
 	}
+	
+	private void disassemble(IRuntimeVisibleTypeAnnotationsAttribute runtimeVisibleTypeAnnotationsAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		writeNewLine(buffer, lineSeparator, tabNumber + 1);
+		buffer.append(Messages.disassembler_runtimevisibletypeannotationsattributeheader);
+		IExtendedAnnotation[] extendedAnnotations = runtimeVisibleTypeAnnotationsAttribute.getExtendedAnnotations();
+		for (int i = 0, max = extendedAnnotations.length; i < max; i++) {
+			disassemble(extendedAnnotations[i], buffer, lineSeparator, tabNumber + 1, mode);
+ 		}
+ 	}
 
 	private String disassemble(IVerificationTypeInfo[] infos, int mode) {
 		StringBuffer buffer = new StringBuffer();
@@ -2718,16 +2522,37 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		dumpTab(tabNumber, buffer);
 	}
 	
-	private String toString(int[] tab) {
+	private String toTypePathString(int[][] typepath) {
 		StringBuffer buffer = new StringBuffer();
-		buffer.append('{');
-		for (int i = 0, max = tab.length; i < max; i++) {
+		buffer.append('[');
+		for (int i = 0, max = typepath.length; i < max; i++) {
+			int[] typepathElement = typepath[i];
 			if (i > 0) {
-				buffer.append(',');
+				buffer.append(',').append(' ');
+			}
+			switch (typepathElement[0]) {
+				case IExtendedAnnotationConstants.TYPE_PATH_DEEPER_IN_ARRAY:
+					buffer.append(Messages.disassembler_extendedannotation_typepath_array);
+					break;
+				case IExtendedAnnotationConstants.TYPE_PATH_DEEPER_IN_INNER_TYPE:
+					buffer.append(Messages.disassembler_extendedannotation_typepath_innertype);
+					break;
+				case IExtendedAnnotationConstants.TYPE_PATH_ANNOTATION_ON_WILDCARD_BOUND:
+					buffer.append(Messages.disassembler_extendedannotation_typepath_wildcard);
+					break;
+				case IExtendedAnnotationConstants.TYPE_PATH_TYPE_ARGUMENT_INDEX:
+					buffer.append(
+							Messages.bind(Messages.disassembler_extendedannotation_typepath_typeargument,
+								new String[] {
+									Integer.toString(typepathElement[1])
+								}));
+					break;
+				default:
+					throw new IllegalStateException("Unrecognized type_path_kind: "+typepathElement[0]); //$NON-NLS-1$
 			}
-			buffer.append(tab[i]);
 		}
-		buffer.append('}');
-		return String.valueOf(buffer);
+		buffer.append(']');
+		return String.valueOf(buffer);	
 	}
+
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java
index aa42977..b1ca559 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012 IBM Corporation and others.
+ * Copyright (c) 2012, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,8 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
 
@@ -23,30 +25,58 @@ import org.eclipse.jdt.core.util.IExtendedAnnotation;
 import org.eclipse.jdt.core.util.IExtendedAnnotationConstants;
 import org.eclipse.jdt.core.util.ILocalVariableReferenceInfo;
 
+/* http://types.cs.washington.edu/jsr308/specification/java-annotation-design.pdf
+ type_annotation {
+   // New fields in JSR 308:
+   u1 target_type; // the type of the targeted program element, see Section 3.2
+   union {
+     type_parameter_target;
+     supertype_target;
+     type_parameter_bound_target;
+     empty_target;
+     method_formal_parameter_target;
+     throws_target;
+     localvar_target;
+     catch_target;
+     offset_target;
+     type_argument_target;
+     method_reference_target;
+   } target_info; // identifies the targeted program element, see Section 3.3
+   type_path target_path; // identifies targeted type in a compound type (array, generic, etc.), see Section 3.4
+   // Original fields from "annotation" structure:
+   u2 type_index;
+   u2 num_element_value_pairs;
+   {
+     u2 element_name_index;
+     element_value value;
+   } element_value_pairs[num_element_value_pairs];
+*/
 /**
- * Default implementation of IAnnotation
+ * @since 3.9 BETA_JAVA8
  */
 public class ExtendedAnnotation extends ClassFileStruct implements IExtendedAnnotation {
 
 	private static final IAnnotationComponent[] NO_ENTRIES = new IAnnotationComponent[0];
+	private final static int[][] NO_TYPEPATH = new int[0][0];
+
+	private int targetType;
+	private int annotationTypeIndex;
+	private int[][] typePath;
 
 	private int typeIndex;
 	private char[] typeName;
 	private int componentsNumber;
 	private IAnnotationComponent[] components;
 	private int readOffset;
-	private int targetType;
-	private int annotationTypeIndex;
 	private int offset;
 	private int typeParameterIndex;
 	private int typeParameterBoundIndex;
 	private int parameterIndex;
-	private int wildcardLocationType;
+	private int exceptionTableIndex;
 	private ILocalVariableReferenceInfo[] localVariableTable;
-	private int[] locations;
-	private int[] wildcardLocations;
+	
 	/**
-	 * Constructor for Annotation.
+	 * Constructor for ExtendedAnnotation, builds an annotation from the supplied bytestream.
 	 *
 	 * @param classFileBytes
 	 * @param constantPool
@@ -58,8 +88,32 @@ public class ExtendedAnnotation extends ClassFileStruct implements IExtendedAnno
 			IConstantPool constantPool,
 			int offset) throws ClassFormatException {
 
-		int index = u2At(classFileBytes, 0, offset);
+		// Read target_type
+		int index = u1At(classFileBytes,0,offset);
+		this.targetType = index;
+		this.readOffset = 1;
+		
+		readTargetInfo(index, classFileBytes, constantPool, offset);
+
+		// Read type_path
+		index = u1At(classFileBytes, this.readOffset, offset);
+		this.readOffset++;
+		int typePathEntryCount = index;
+		if (typePathEntryCount == 0) {
+			this.typePath = NO_TYPEPATH;
+		} else {
+			this.typePath = new int[typePathEntryCount][];
+			for (int i = 0; i < typePathEntryCount; i++) {
+				int[] typePathEntry = (this.typePath[i] = new int[2]);
+				typePathEntry[0] = u1At(classFileBytes, this.readOffset++, offset);
+				typePathEntry[1] = u1At(classFileBytes, this.readOffset++, offset);
+			}
+		}
+		
+		// Read annotation
+		index = u2At(classFileBytes, this.readOffset, offset);
 		this.typeIndex = index;
+		this.readOffset+=2;
 		if (index != 0) {
 			IConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(index);
 			if (constantPoolEntry.getKind() != IConstantPoolConstant.CONSTANT_Utf8) {
@@ -69,9 +123,9 @@ public class ExtendedAnnotation extends ClassFileStruct implements IExtendedAnno
 		} else {
 			throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
 		}
-		final int length = u2At(classFileBytes, 2, offset);
+		final int length = u2At(classFileBytes, this.readOffset, offset);
 		this.componentsNumber = length;
-		this.readOffset = 4;
+		this.readOffset+=2;
 		if (length != 0) {
 			this.components = new IAnnotationComponent[length];
 			for (int i = 0; i < length; i++) {
@@ -82,122 +136,55 @@ public class ExtendedAnnotation extends ClassFileStruct implements IExtendedAnno
 		} else {
 			this.components = NO_ENTRIES;
 		}
-		index = u1At(classFileBytes, this.readOffset, offset);
-		this.readOffset++;
-		this.targetType = index;
-		switch(index) {
-			case IExtendedAnnotationConstants.WILDCARD_BOUND :
-				this.wildcardLocationType = u1At(classFileBytes, this.readOffset, offset);
-				this.readOffset++;
-				internalDecoding(this.wildcardLocationType, classFileBytes, constantPool, offset);
-				// copy the location back into the wildcard location
-				int size = this.locations.length;
-				System.arraycopy(this.locations, 0, (this.wildcardLocations = new int[size]), 0, size);
-				this.locations = null;
-				break;
-			case IExtendedAnnotationConstants.WILDCARD_BOUND_GENERIC_OR_ARRAY :
-				this.wildcardLocationType = u1At(classFileBytes, this.readOffset, offset);
-				this.readOffset++;
-				internalDecoding(this.wildcardLocationType, classFileBytes, constantPool, offset);
-				size = this.locations.length;
-				System.arraycopy(this.locations, 0, (this.wildcardLocations = new int[size]), 0, size);
-				int locationLength = u2At(classFileBytes, this.readOffset, offset);
-				this.readOffset += 2;
-				this.locations = new int[locationLength];
-				for (int i = 0; i < locationLength; i++) {
-					this.locations[i] = u1At(classFileBytes, this.readOffset, offset);
-					this.readOffset++;
-				}
-				break;
-			default:
-				internalDecoding(index, classFileBytes, constantPool, offset);
-		}
 		if (this.annotationTypeIndex == 0xFFFF) {
 			this.annotationTypeIndex = -1;
 		}
 	}
 	
-	private void internalDecoding(
+	private void readTargetInfo(
 			int localTargetType,
 			byte[] classFileBytes,
 			IConstantPool constantPool,
 			int localOffset) throws ClassFormatException {
 		switch(localTargetType) {
-			case IExtendedAnnotationConstants.CLASS_EXTENDS_IMPLEMENTS :
-				this.annotationTypeIndex = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset+=2;
-				break;
-			case IExtendedAnnotationConstants.CLASS_EXTENDS_IMPLEMENTS_GENERIC_OR_ARRAY :
-				this.annotationTypeIndex = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset+=2;
-				int locationLength = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				this.locations = new int[locationLength];
-				for (int i = 0; i < locationLength; i++) {
-					this.locations[i] = u1At(classFileBytes, this.readOffset, localOffset);
-					this.readOffset++;
-				}
-				break;
-			case IExtendedAnnotationConstants.TYPE_CAST :
-			case IExtendedAnnotationConstants.TYPE_INSTANCEOF :
-			case IExtendedAnnotationConstants.OBJECT_CREATION :
-			case IExtendedAnnotationConstants.CLASS_LITERAL :
-				this.offset = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				break;
-			case IExtendedAnnotationConstants.TYPE_CAST_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.TYPE_INSTANCEOF_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.OBJECT_CREATION_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.CLASS_LITERAL_GENERIC_OR_ARRAY :
-				this.offset = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				locationLength = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				this.locations = new int[locationLength];
-				for (int i = 0; i < locationLength; i++) {
-					this.locations[i] = u1At(classFileBytes, this.readOffset, localOffset);
-					this.readOffset++;
-				}
-				break;
 			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER :
 			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER :
 				this.typeParameterIndex = u1At(classFileBytes, this.readOffset, localOffset);
 				this.readOffset++;
 				break;
-			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_GENERIC_OR_ARRAY :
-				this.typeParameterIndex = u1At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset++;
-				locationLength = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				this.locations = new int[locationLength];
-				for (int i = 0; i < locationLength; i++) {
-					this.locations[i] = u1At(classFileBytes, this.readOffset, localOffset);
-					this.readOffset++;
-				}
+
+			case IExtendedAnnotationConstants.CLASS_EXTENDS :
+				this.annotationTypeIndex = u2At(classFileBytes, this.readOffset, localOffset);
+				this.readOffset+=2;
 				break;
-			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_BOUND :
+
 			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER_BOUND :
+			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_BOUND :
 				this.typeParameterIndex = u1At(classFileBytes, this.readOffset, localOffset);
 				this.readOffset++;
 				this.typeParameterBoundIndex = u1At(classFileBytes, this.readOffset, localOffset);
 				this.readOffset++;
 				break;
-			case IExtendedAnnotationConstants.METHOD_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.CLASS_TYPE_PARAMETER_BOUND_GENERIC_OR_ARRAY :
-				this.typeParameterIndex = u1At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset++;
-				this.typeParameterBoundIndex = u1At(classFileBytes, this.readOffset, localOffset);
+				
+			case IExtendedAnnotationConstants.FIELD :
+			case IExtendedAnnotationConstants.METHOD_RETURN :
+			case IExtendedAnnotationConstants.METHOD_RECEIVER :
+				// nothing to do, target_info is empty_target
+				break;
+				
+			case IExtendedAnnotationConstants.METHOD_FORMAL_PARAMETER :
+				this.parameterIndex = u1At(classFileBytes, this.readOffset, localOffset);
 				this.readOffset++;
-				locationLength = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				this.locations = new int[locationLength];
-				for (int i = 0; i < locationLength; i++) {
-					this.locations[i] = u1At(classFileBytes, this.readOffset, localOffset);
-					this.readOffset++;
-				}
 				break;
+				
+			case IExtendedAnnotationConstants.THROWS :
+				this.annotationTypeIndex = u2At(classFileBytes, this.readOffset, localOffset);
+				this.readOffset+=2;
+				break;
+
+				
 			case IExtendedAnnotationConstants.LOCAL_VARIABLE :
+			case IExtendedAnnotationConstants.RESOURCE_VARIABLE :
 				int tableLength = u2At(classFileBytes, this.readOffset, localOffset);
 				this.readOffset += 2;
 				this.localVariableTable = new LocalVariableReferenceInfo[tableLength];
@@ -206,83 +193,34 @@ public class ExtendedAnnotation extends ClassFileStruct implements IExtendedAnno
 					this.readOffset += 6;
 				}
 				break;
-			case IExtendedAnnotationConstants.LOCAL_VARIABLE_GENERIC_OR_ARRAY :
-				tableLength = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				this.localVariableTable = new LocalVariableReferenceInfo[tableLength];
-				for (int i = 0; i < tableLength; i++) {
-					this.localVariableTable[i] = new LocalVariableReferenceInfo(classFileBytes, constantPool, this.readOffset + localOffset);
-					this.readOffset += 6;
-				}
-				locationLength = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				this.locations = new int[locationLength];
-				for (int i = 0; i < locationLength; i++) {
-					this.locations[i] = u1At(classFileBytes, this.readOffset, localOffset);
-					this.readOffset++;
-				}
-				break;
-			case IExtendedAnnotationConstants.METHOD_PARAMETER :
-				this.parameterIndex = u1At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset++;
-				break;
-			case IExtendedAnnotationConstants.METHOD_PARAMETER_GENERIC_OR_ARRAY :
-				this.parameterIndex = u1At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset++;
-				locationLength = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				this.locations = new int[locationLength];
-				for (int i = 0; i < locationLength; i++) {
-					this.locations[i] = u1At(classFileBytes, this.readOffset, localOffset);
-					this.readOffset++;
-				}
-				break;
-			case IExtendedAnnotationConstants.METHOD_RECEIVER_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.METHOD_RETURN_TYPE_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.FIELD_GENERIC_OR_ARRAY :
-				locationLength = u2At(classFileBytes, this.readOffset, localOffset);
+
+			case IExtendedAnnotationConstants.EXCEPTION_PARAMETER :
+				this.exceptionTableIndex = u2At(classFileBytes, this.readOffset, localOffset);
 				this.readOffset += 2;
-				this.locations = new int[locationLength];
-				for (int i = 0; i < locationLength; i++) {
-					this.locations[i] = u1At(classFileBytes, this.readOffset, localOffset);
-					this.readOffset++;
-				}
 				break;
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL :
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_METHOD_CALL :
+
+			case IExtendedAnnotationConstants.NEW :
+			case IExtendedAnnotationConstants.INSTANCEOF :
+			case IExtendedAnnotationConstants.METHOD_REFERENCE :
+			case IExtendedAnnotationConstants.CONSTRUCTOR_REFERENCE :
 				this.offset = u2At(classFileBytes, this.readOffset, localOffset);
 				this.readOffset += 2;
-				this.annotationTypeIndex = u1At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset++;
+				break;	
+
+			case IExtendedAnnotationConstants.CAST :
+				this.offset = u2At(classFileBytes, this.readOffset, localOffset);
+				this.readOffset += 3; // skipping the 3rd byte which will be 0 for CAST
 				break;
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_CONSTRUCTOR_CALL_GENERIC_OR_ARRAY :
-			case IExtendedAnnotationConstants.TYPE_ARGUMENT_METHOD_CALL_GENERIC_OR_ARRAY :
+
+			case IExtendedAnnotationConstants.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT :
+			case IExtendedAnnotationConstants.METHOD_INVOCATION_TYPE_ARGUMENT :
+			case IExtendedAnnotationConstants.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT :
+			case IExtendedAnnotationConstants.METHOD_REFERENCE_TYPE_ARGUMENT :
 				this.offset = u2At(classFileBytes, this.readOffset, localOffset);
 				this.readOffset += 2;
+				// read type_argument_index
 				this.annotationTypeIndex = u1At(classFileBytes, this.readOffset, localOffset);
 				this.readOffset++;
-				locationLength = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				this.locations = new int[locationLength];
-				for (int i = 0; i < locationLength; i++) {
-					this.locations[i] = u1At(classFileBytes, this.readOffset, localOffset);
-					this.readOffset++;
-				}
-				break;
-			case IExtendedAnnotationConstants.THROWS :
-				this.annotationTypeIndex = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset+=2;
-				break;
-			case IExtendedAnnotationConstants.THROWS_GENERIC_OR_ARRAY :
-				this.annotationTypeIndex = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset+=2;
-				locationLength = u2At(classFileBytes, this.readOffset, localOffset);
-				this.readOffset += 2;
-				this.locations = new int[locationLength];
-				for (int i = 0; i < locationLength; i++) {
-					this.locations[i] = u1At(classFileBytes, this.readOffset, localOffset);
-					this.readOffset++;
-				}
 				break;
 		}
 	}
@@ -319,6 +257,10 @@ public class ExtendedAnnotation extends ClassFileStruct implements IExtendedAnno
 	public int getTargetType() {
 		return this.targetType;
 	}
+	
+	public int getExceptionTableIndex() {
+		return this.exceptionTableIndex;
+	}
 
 	public int getOffset() {
 		return this.offset;
@@ -344,16 +286,8 @@ public class ExtendedAnnotation extends ClassFileStruct implements IExtendedAnno
 		return this.typeParameterBoundIndex;
 	}
 
-	public int getWildcardLocationType() {
-		return this.wildcardLocationType;
-	}
-
-	public int[] getWildcardLocations() {
-		return this.wildcardLocations;
-	}
-
-	public int[] getLocations() {
-		return this.locations;
+	public int[][] getTypePath() {
+		return this.typePath;
 	}
 
 	public int getAnnotationTypeIndex() {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
index 1edfa5f..eb74932 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,9 +8,11 @@
  * This is an implementation of an early-draft specification developed under the Java
  * Community Process (JCP) and is made available for testing and evaluation purposes
  * only. The code is not compatible with any specification of the JCP.
- * 
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *        Andy Clement - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
 
@@ -304,7 +306,7 @@ public final class Messages extends NLS {
 	public static String disassembler_runtimevisibletypeannotationsattributeheader;
 	public static String disassembler_runtimeinvisibletypeannotationsattributeheader;
 	public static String disassembler_extendedannotation_classextendsimplements;
-	public static String disassembler_extendedannotation_locations;
+	public static String disassembler_extendedannotation_typepath;
 	public static String disassembler_extendedannotation_method_parameter;
 	public static String disassembler_extendedannotation_offset;
 	public static String disassembler_extendedannotation_throws;
@@ -314,8 +316,12 @@ public final class Messages extends NLS {
 	public static String disassembler_extendedannotation_wildcardlocationtype;
 	public static String disassembler_extendedannotation_targetType;
 	public static String disassembler_extendedannotation_wildcardlocations;
+	public static String disassembler_extendedannotation_exception_table_index;
+	public static String disassembler_extendedannotation_typepath_array;
+	public static String disassembler_extendedannotation_typepath_wildcard;
+	public static String disassembler_extendedannotation_typepath_typeargument;
+	public static String disassembler_extendedannotation_typepath_innertype;
 	public static String disassembler_localvariabletargetheader;
-	public static String classfileformat_localvariablereferenceinfoentry;
 
 	public static String disassembler_runtimevisibleannotationsattributeheader;
 	public static String disassembler_runtimeinvisibleannotationsattributeheader;
@@ -331,6 +337,9 @@ public final class Messages extends NLS {
 	public static String classfileformat_superflagisnotset;
 	public static String classfileformat_superflagisset;
 	public static String classfileformat_clinitname;
+	// jsr308
+	public static String classfileformat_localvariablereferenceinfoentry;
+
 	public static String classformat_classformatexception;
 	public static String classformat_anewarray;
 	public static String classformat_checkcast;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
index 748f5c1..e6ff7c2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
@@ -1,5 +1,5 @@
 ###############################################################################
-# Copyright (c) 2000, 2011 IBM Corporation and others.
+# Copyright (c) 2000, 2013 IBM Corporation and others.
 # All rights reserved. This program and the accompanying materials
 # are made available under the terms of the Eclipse Public License v1.0
 # which accompanies this distribution, and is available at
@@ -8,9 +8,11 @@
 # This is an implementation of an early-draft specification developed under the Java
 # Community Process (JCP) and is made available for testing and evaluation purposes
 # only. The code is not compatible with any specification of the JCP.
-# 
+#
 # Contributors:
 #     IBM Corporation - initial API and implementation
+#        Andy Clement - Contributions for
+#                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
 ###############################################################################
 
 ### JavaModel messages.
@@ -323,12 +325,13 @@ disassembler_annotationarrayvaluestart = [
 disassembler_annotationarrayvalueend = ]
 disassembler_annotationentrystart = #{0} @{1}(
 disassembler_annotationentryend = )
-# jsr308
+# jsr308 (next two)
 disassembler_extendedannotationentrystart=#{0} @{1}(
 disassembler_extendedannotationentryend= )
 disassembler_annotationcomponent = #{0} {1}=
 disassembler_runtimevisibleannotationsattributeheader= RuntimeVisibleAnnotations:\ 
 disassembler_runtimeinvisibleannotationsattributeheader= RuntimeInvisibleAnnotations:\ 
+# jsr308 (next two)
 disassembler_runtimevisibletypeannotationsattributeheader= RuntimeVisibleTypeAnnotations:\ 
 disassembler_runtimeinvisibletypeannotationsattributeheader= RuntimeInvisibleTypeAnnotations:\ 
 disassembler_runtimevisibleparameterannotationsattributeheader= RuntimeVisibleParameterAnnotations:\ 
@@ -356,11 +359,10 @@ disassembler_method_type_ref_newinvokespecial = newinvokespecial ({0})
 disassembler_frame_full_frame=[pc: {0}, full, stack: {4}, locals: {2}]
 disassembler_frame_same_frame=[pc: {0}, same]
 disassembler_frame_same_locals_1_stack_item=[pc: {0}, same_locals_1_stack_item, stack: {1}]
-
-# jsr 308
+# jsr308
 disassembler_extendedannotation_targetType=target type = 0x{0} {1}
 disassembler_extendedannotation_classextendsimplements=type index = {0}
-disassembler_extendedannotation_locations=locations = {0}
+disassembler_extendedannotation_typepath=location = {0}
 disassembler_extendedannotation_method_parameter=method parameter index = {0}
 disassembler_extendedannotation_offset=offset = {0}
 disassembler_extendedannotation_throws=throws index = {0}
@@ -369,7 +371,12 @@ disassembler_extendedannotation_type_parameter=type parameter index = {0}
 disassembler_extendedannotation_type_parameter_with_bound=type parameter index = {0} type parameter bound index = {1}
 disassembler_extendedannotation_wildcardlocationtype=wildcard location type = 0x{0} {1}
 disassembler_extendedannotation_wildcardlocations=wildcard locations = {0}
+disassembler_extendedannotation_exception_table_index=exception table index = {0}
 disassembler_localvariabletargetheader=local variable entries:
+disassembler_extendedannotation_typepath_array=ARRAY
+disassembler_extendedannotation_typepath_innertype=INNER_TYPE
+disassembler_extendedannotation_typepath_wildcard=WILDCARD
+disassembler_extendedannotation_typepath_typeargument=TYPE_ARGUMENT({0})
 
 ### classfileformat decoding
 classfileformat_versiondetails =\ (version {0} : {1}.{2}, {3})
commit 26e96a017b590b444a246c8fba814dc78fd85b77
Author: Andrew Clement <aclement@gopivotal.com>
Date:   Thu May 30 06:49:53 2013 +0530

    Copyright updates for Bug 383624 - [1.8][compiler] Revive code
    generation support for type annotations (from Olivier's work)

1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
1	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationTargetTypeConstants.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotation.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotationConstants.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeAttribute.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
index d823d7b..3dbd435 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
@@ -11,7 +11,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.parser;
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
index b16cc6d..ccb9fde 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TypeAnnotationTest.java
@@ -11,7 +11,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index de16a05..b3547fb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -13,7 +13,7 @@
  *     IBM Corporation - initial API and implementation
  *     Jesper S Moller - Contributions for
  *							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335             
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 9152a39..cd7b8f9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -15,7 +15,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
  *								bug 331649 - [compiler][null] consider null annotations for fields
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
index 3edbaee..47cdc77 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayAllocationExpression.java
@@ -15,7 +15,7 @@
  *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
- *     Andy Clement - Contributions for
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *
  *******************************************************************************/
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
index dfa763d..d39eeef 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ArrayInitializer.java
@@ -15,7 +15,7 @@
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index d78f7c7..ee461e6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -17,7 +17,7 @@
  *	   Stephan Herrmann - Contribution for
  *							bug 402028 - [1.8][compiler] null analysis for reference expressions 
  *							bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super via I.super.m() syntax
- *        Andy Clement - Contribution for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contribution for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index 7a5693b..32dd3d8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -25,8 +25,7 @@
  *								bug 384380 - False positive on a ?? Potential null pointer access ?? after a continue
  *     Jesper Steen Moller - Contributions for
  *								bug 404146 - [1.7][compiler] nested try-catch-finally-blocks leads to unrunnable Java byte code
- *
- *     Andy Clement - Contributions for
+ *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *
  *******************************************************************************/
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index 406fb58..615cfa5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -14,7 +14,7 @@
  *     Stephan Herrmann - Contribution for
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
index 1bc0469..c743d43 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationContext.java
@@ -11,7 +11,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationTargetTypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationTargetTypeConstants.java
index 6538d19..919247a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationTargetTypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AnnotationTargetTypeConstants.java
@@ -11,7 +11,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
index 809f130..f6715da 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
@@ -16,7 +16,7 @@
  *								bug 391376 - [1.8] check interaction of default methods with bridge methods and generics
  *     Jesper S Moller - Contributions for
  *							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335        
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
index 9af117f..e6e619d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ExceptionLabel.java
@@ -11,7 +11,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
index 3c90ed2..21fc79f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/MultiCatchExceptionLabel.java
@@ -11,7 +11,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
index c5554fd..e1fb841 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/TypeAnnotationCodeStream.java
@@ -11,7 +11,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.codegen;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotation.java
index 689661e..d6eb7df 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotation.java
@@ -11,7 +11,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.core.util;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotationConstants.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotationConstants.java
index 6996de6..c849076 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotationConstants.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IExtendedAnnotationConstants.java
@@ -11,7 +11,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.core.util;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeAttribute.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeAttribute.java
index 47be053..4339375 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeAttribute.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CodeAttribute.java
@@ -11,7 +11,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
index a302f88..c7960b4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
@@ -11,7 +11,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java
index b1ca559..902b329 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/ExtendedAnnotation.java
@@ -11,7 +11,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
index eb74932..2de3362 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
@@ -11,7 +11,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *        Andy Clement - Contributions for
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
index e6ff7c2..30fad38 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
@@ -11,7 +11,7 @@
 #
 # Contributors:
 #     IBM Corporation - initial API and implementation
-#        Andy Clement - Contributions for
+#        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
 #                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
 ###############################################################################
 
