commit dee658b9081a58fda5dde28cf93d4ce67448b764
Author: Jesper S Moller <jesper@selskabet.org>
Date:   Mon Mar 4 20:42:10 2013 +0530

    Enabling changes for Bug 402173 - [1.8][formatter] Code formatter should
    understand lambda expressions.

4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 71e635c..529057e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -391,6 +391,10 @@ public class LambdaExpression extends FunctionalExpression {
 			visitor.endVisit(this, blockScope);
 	}
 	
+	public MethodScope getScope() {
+		return this.scope;
+	}
+		
 	protected boolean shapeAnalysisComplete() {
 		return this.original.shapeAnalysisComplete;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
index ade60c9..8e948be 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Jesper S Moller  -. Contribution for bug 400830: [1.8][formatter] Code formatter for Java 8
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.parser;
 
@@ -3837,7 +3838,7 @@ public String toString() {
 	if (this.currentPosition > this.eofPosition)
 		return "behind the EOF\n\n" + new String(this.source); //$NON-NLS-1$
 	if (this.currentPosition <= 0)
-		return "NOT started!\n\n"+ new String(this.source); //$NON-NLS-1$
+		return "NOT started!\n\n"+ (this.source != null ? new String(this.source) : ""); //$NON-NLS-1$ //$NON-NLS-2$
 
 	StringBuffer buffer = new StringBuffer();
 	if (this.startPosition < 1000) {
commit b64275d5d6005c49a64e53460529203088ebb2bb
Author: Jesper S Moller <jesper@selskabet.org>
Date:   Sun Mar 10 00:08:27 2013 -0500

    Fix and tests for Bug 402173 - [1.8][formatter] Code formatter should
    understand lambda expressions.

3	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
7	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunFormatterTests.java
167	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/Formatter18Tests.java
6	0	org.eclipse.jdt.core.tests.model/workspace/Formatter18/.classpath
17	0	org.eclipse.jdt.core.tests.model/workspace/Formatter18/.project
40	0	org.eclipse.jdt.core.tests.model/workspace/Formatter18/testLambda/A_in.java
47	0	org.eclipse.jdt.core.tests.model/workspace/Formatter18/testLambda/A_out.java
49	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
69	3	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
34	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
index 103fa88..0cc04f9 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunAllJava8Tests.java
@@ -44,6 +44,7 @@ import org.eclipse.jdt.core.tests.dom.ASTConverterBugsTestJLS8;
 import org.eclipse.jdt.core.tests.dom.ASTConverterTestAST8_2;
 import org.eclipse.jdt.core.tests.dom.ConverterTestSetup;
 import org.eclipse.jdt.core.tests.dom.TypeAnnotationsConverterTest;
+import org.eclipse.jdt.core.tests.formatter.Formatter18Tests;
 import org.eclipse.jdt.core.tests.rewrite.describing.ASTRewritingTest;
 
 public class RunAllJava8Tests extends TestCase {
@@ -64,7 +65,8 @@ public class RunAllJava8Tests extends TestCase {
 			NullTypeAnnotationTest.class,
 			CompilerInvocationTests.class,
 			ExpressionContextTests.class,
-			FlowAnalysisTest8.class
+			FlowAnalysisTest8.class,
+			Formatter18Tests.class,
 		};
 	}
 	
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunFormatterTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunFormatterTests.java
index da72556..ab84eb1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunFormatterTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunFormatterTests.java
@@ -1,12 +1,17 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2009 IBM Corporation and others.
+ * Copyright (c) 2005, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Jesper S Moller - Contribution for bug 402173
  *******************************************************************************/
 package org.eclipse.jdt.core.tests;
 
@@ -31,6 +36,7 @@ public class RunFormatterTests extends junit.framework.TestCase {
 	static {
 		TEST_SUITES.add(FormatterCommentsBugsTest.class);
 		TEST_SUITES.add(FormatterCommentsTests.class);
+		TEST_SUITES.add(Formatter18Tests.class);
 		TEST_SUITES.add(FormatterCommentsClearBlankLinesTests.class);
 		TEST_SUITES.add(FormatterJavadocDontIndentTagsTests.class);
 		TEST_SUITES.add(FormatterJavadocDontIndentTagsDescriptionTests.class);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/Formatter18Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/Formatter18Tests.java
new file mode 100644
index 0000000..93589e1
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/Formatter18Tests.java
@@ -0,0 +1,167 @@
+/*******************************************************************************
+ * Copyright (c) 2013 Jesper Steen Moller and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     Jesper Steen Moller - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.formatter;
+
+import java.util.Map;
+
+import junit.framework.Test;
+
+import org.eclipse.core.resources.IWorkspaceDescription;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.formatter.CodeFormatter;
+import org.eclipse.jdt.core.tests.model.AbstractJavaModelTests;
+import org.eclipse.jdt.core.tests.util.Util;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.formatter.DefaultCodeFormatter;
+import org.eclipse.jdt.internal.formatter.DefaultCodeFormatterOptions;
+import org.eclipse.text.edits.TextEdit;
+
+public class Formatter18Tests extends AbstractJavaModelTests {
+
+	protected static IJavaProject JAVA_PROJECT;
+
+	public static final int UNKNOWN_KIND = 0;
+	public static final String IN = "_in";
+	public static final String OUT = "_out";
+	public static final boolean DEBUG = false;
+	static final String LINE_SEPARATOR = System.getProperty("line.separator");
+	private static final String PROJECT_NAME = "Formatter18"; 
+
+	DefaultCodeFormatterOptions formatterPrefs;
+	Map formatterOptions;
+
+	static {
+//		TESTS_NUMBERS = new int[] { 783 };
+//		TESTS_RANGE = new int[] { 734, -1 };
+	}
+	public static Test suite() {
+		return buildModelTestSuite(Formatter18Tests.class);
+	}
+
+	public Formatter18Tests(String name) {
+		super(name);
+	}
+
+	/**
+	 * Init formatter preferences with Eclipse default settings.
+	 */
+	protected void setUp() throws Exception {
+	    super.setUp();
+		this.formatterPrefs = DefaultCodeFormatterOptions.getEclipseDefaultSettings();
+		if (JAVA_PROJECT != null) {
+			this.formatterOptions = JAVA_PROJECT.getOptions(true);
+		}
+		this.formatterOptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_8);
+		this.formatterOptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);
+		this.formatterOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_8);
+	}
+
+	/**
+	 * Create project and set the jar placeholder.
+	 */
+	public void setUpSuite() throws Exception {
+		// ensure autobuilding is turned off
+		IWorkspaceDescription description = getWorkspace().getDescription();
+		if (description.isAutoBuilding()) {
+			description.setAutoBuilding(false);
+			getWorkspace().setDescription(description);
+		}
+
+		if (JAVA_PROJECT == null) {
+			JAVA_PROJECT = setUpJavaProject(PROJECT_NAME, "1.8"); //$NON-NLS-1$
+		}
+	}
+
+	/**
+	 * Reset the jar placeholder and delete project.
+	 */
+	public void tearDownSuite() throws Exception {
+		deleteProject(JAVA_PROJECT); //$NON-NLS-1$
+		JAVA_PROJECT = null;
+		super.tearDownSuite();
+	}
+
+	String runFormatter(CodeFormatter codeFormatter, String source, int kind, int indentationLevel, int offset, int length, String lineSeparator, boolean repeat) {
+		TextEdit edit = codeFormatter.format(kind, source, offset, length, indentationLevel, lineSeparator);//$NON-NLS-1$
+		if (edit == null) return null;
+		String result = org.eclipse.jdt.internal.core.util.Util.editedString(source, edit);
+
+		if (repeat && length == source.length()) {
+			edit = codeFormatter.format(kind, result, 0, result.length(), indentationLevel, lineSeparator);//$NON-NLS-1$
+			if (edit == null) return null;
+			final String result2 = org.eclipse.jdt.internal.core.util.Util.editedString(result, edit);
+			if (!result.equals(result2)) {
+				assertSourceEquals("Second formatting is different from first one!", Util.convertToIndependantLineDelimiter(result), Util.convertToIndependantLineDelimiter(result2));
+			}
+		}
+		return result;
+	}
+
+	private String getIn(String compilationUnitName) {
+		assertNotNull(compilationUnitName);
+		int dotIndex = compilationUnitName.indexOf('.');
+		assertTrue(dotIndex != -1);
+		return compilationUnitName.substring(0, dotIndex) + IN + compilationUnitName.substring(dotIndex);
+	}
+
+	private String getOut(String compilationUnitName) {
+		assertNotNull(compilationUnitName);
+		int dotIndex = compilationUnitName.indexOf('.');
+		assertTrue(dotIndex != -1);
+		return compilationUnitName.substring(0, dotIndex) + OUT + compilationUnitName.substring(dotIndex);
+	}
+
+	void assertLineEquals(String actualContents, String originalSource, String expectedContents, boolean checkNull) {
+		if (actualContents == null) {
+			assertTrue("actualContents is null", checkNull);
+			assertEquals(expectedContents, originalSource);
+			return;
+		}
+		assertSourceEquals("Different number of length", Util.convertToIndependantLineDelimiter(expectedContents), actualContents);
+	}
+	private void runTest(String packageName, String compilationUnitName) {
+		DefaultCodeFormatter codeFormatter = new DefaultCodeFormatter(this.formatterPrefs, this.formatterOptions);
+		runTest(codeFormatter, packageName, compilationUnitName, CodeFormatter.K_COMPILATION_UNIT, 0);
+	}
+	private void runTest(CodeFormatter codeFormatter, String packageName, String compilationUnitName, int kind, int indentationLevel) {
+		runTest(codeFormatter, packageName, compilationUnitName, kind, indentationLevel, false, 0, -1, null);
+	}
+	private void runTest(CodeFormatter codeFormatter, String packageName, String compilationUnitName, int kind, int indentationLevel, boolean checkNull, int offset, int length, String lineSeparator) {
+		try {
+			ICompilationUnit sourceUnit = getCompilationUnit(PROJECT_NAME , "", packageName, getIn(compilationUnitName)); //$NON-NLS-1$ //$NON-NLS-2$
+			String source = sourceUnit.getSource();
+			assertNotNull(source);
+			ICompilationUnit outputUnit = getCompilationUnit(PROJECT_NAME , "", packageName, getOut(compilationUnitName)); //$NON-NLS-1$ //$NON-NLS-2$
+			assertNotNull(outputUnit);
+			String result;
+			if (length == -1) {
+				result = runFormatter(codeFormatter, source, kind, indentationLevel, offset, source.length(), lineSeparator, true);
+			} else {
+				result = runFormatter(codeFormatter, source, kind, indentationLevel, offset, length, lineSeparator, true);
+			}
+			assertLineEquals(result, source, outputUnit.getSource(), checkNull);
+		} catch (JavaModelException e) {
+			e.printStackTrace();
+			assertTrue(false);
+		}
+	}
+
+	public void testLambda() {
+		runTest("testLambda", "A.java");//$NON-NLS-1$ //$NON-NLS-2$
+	}
+
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter18/.classpath b/org.eclipse.jdt.core.tests.model/workspace/Formatter18/.classpath
new file mode 100644
index 0000000..e4ac611
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter18/.classpath
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+    <classpathentry kind="src" path=""/>
+    <classpathentry kind="var" path="JCL18_LIB" sourcepath="JCL18_SRC" rootpath="JCL_SRC18ROOT"/>
+    <classpathentry kind="output" path="bin"/>
+</classpath>
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter18/.project b/org.eclipse.jdt.core.tests.model/workspace/Formatter18/.project
new file mode 100644
index 0000000..33a2435
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter18/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>FormatterJsr308</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter18/testLambda/A_in.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter18/testLambda/A_in.java
new file mode 100644
index 0000000..37a16ab
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter18/testLambda/A_in.java
@@ -0,0 +1,40 @@
+package p1.p2.test;
+
+import java.io.Serializable;
+import java.io.IOException;
+
+public abstract class A extends java.lang.Object implements Runnable, Cloneable, Serializable {
+	public void run() {
+	}
+
+	public void lambdas() {
+		Runnable a = () -> {
+			thisIsCrazy();
+			iJustMet(you);
+			here.number.callMe();
+		};
+
+		Func idA = x -> x;
+
+		Func idB = x -> { return x; };
+		
+		Func idC = x   ->   x;
+
+		Func id2 = x -> {
+			if (x == null)
+			{
+				return null;
+			}
+			else
+				return x;
+		};
+		
+		ImaginableFunction<String, Integer> f =
+			(String input) -> input.length();
+
+			ImaginableFunction<String, Integer> f2 = (String input) -> { return input.length() + new LetsPretend() { int howMany() { return 42; } }
+					
+.howMany(); };
+	}
+
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter18/testLambda/A_out.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter18/testLambda/A_out.java
new file mode 100644
index 0000000..6ca70f7
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter18/testLambda/A_out.java
@@ -0,0 +1,47 @@
+package p1.p2.test;
+
+import java.io.Serializable;
+import java.io.IOException;
+
+public abstract class A extends java.lang.Object implements Runnable,
+		Cloneable, Serializable {
+	public void run() {
+	}
+
+	public void lambdas() {
+		Runnable a = () -> {
+			thisIsCrazy();
+			iJustMet(you);
+			here.number.callMe();
+		};
+
+		Func idA = x -> x;
+
+		Func idB = x -> {
+			return x;
+		};
+
+		Func idC = x -> x;
+
+		Func id2 = x -> {
+			if (x == null) {
+				return null;
+			} else
+				return x;
+		};
+
+		ImaginableFunction<String, Integer> f = (String input) -> input
+				.length();
+
+		ImaginableFunction<String, Integer> f2 = (String input) -> {
+			return input.length() + new LetsPretend() {
+				int howMany() {
+					return 42;
+				}
+			}
+
+			.howMany();
+		};
+	}
+
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
index 1694b48..7ea0ead 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/core/formatter/DefaultCodeFormatterConstants.java
@@ -1,14 +1,19 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation  - initial API and implementation
  *     Brock Janiczak   - Contribution for bug 150741
  *     Ray V. (voidstar@gmail.com) - Contribution for bug 282988
+ *     Jesper S Moller - Contribution for bug 402173
  *******************************************************************************/
 package org.eclipse.jdt.core.formatter;
 
@@ -39,6 +44,7 @@ public class DefaultCodeFormatterConstants {
  	 * @see #FORMATTER_BRACE_POSITION_FOR_METHOD_DECLARATION
  	 * @see #FORMATTER_BRACE_POSITION_FOR_SWITCH
 	 * @see #FORMATTER_BRACE_POSITION_FOR_TYPE_DECLARATION
+	 * @see #FORMATTER_BRACE_POSITION_FOR_LAMBDA_BODY
 	 * @since 3.0
 	 */
 	public static final String END_OF_LINE = "end_of_line";	//$NON-NLS-1$
@@ -609,6 +615,21 @@ public class DefaultCodeFormatterConstants {
 
 	/**
 	 * <pre>
+	 * FORMATTER / Option to position the braces of a lambda block
+	 *     - option id:         "org.eclipse.jdt.core.formatter.brace_position_for_lambda_body"
+	 *     - possible values:   { END_OF_LINE, NEXT_LINE, NEXT_LINE_SHIFTED, NEXT_LINE_ON_WRAP }
+	 *     - default:           END_OF_LINE
+	 * </pre>
+	 * @see #END_OF_LINE
+	 * @see #NEXT_LINE
+	 * @see #NEXT_LINE_SHIFTED
+	 * @see #NEXT_LINE_ON_WRAP
+	 * @since 3.9
+	 */
+	public static final String FORMATTER_BRACE_POSITION_FOR_LAMBDA_BODY = JavaCore.PLUGIN_ID + ".formatter.brace_position_for_lambda_body";	//$NON-NLS-1$
+
+	/**
+	 * <pre>
 	 * FORMATTER / Option to control whether blank lines are cleared inside comments
 	 *     - option id:         "org.eclipse.jdt.core.formatter.comment.clear_blank_lines"
 	 *     - possible values:   { TRUE, FALSE }
@@ -2002,6 +2023,18 @@ public class DefaultCodeFormatterConstants {
 	public static final String FORMATTER_INSERT_SPACE_AFTER_ELLIPSIS  = JavaCore.PLUGIN_ID + ".formatter.insert_space_after_ellipsis";	//$NON-NLS-1$
 	/**
 	 * <pre>
+	 * FORMATTER / Option to insert a space after the -> in lambda expressions
+	 *     - option id:         "org.eclipse.jdt.core.formatter.insert_space_after_lambda_arrow"
+	 *     - possible values:   { INSERT, DO_NOT_INSERT }
+	 *     - default:           INSERT
+	 * </pre>
+	 * @see JavaCore#INSERT
+	 * @see JavaCore#DO_NOT_INSERT
+	 * @since 3.9
+	 */
+	public static final String FORMATTER_INSERT_SPACE_AFTER_LAMBDA_ARROW  = JavaCore.PLUGIN_ID + ".formatter.insert_space_after_lambda_arrow";	//$NON-NLS-1$
+	/**
+	 * <pre>
 	 * FORMATTER / Option to insert a space after the opening angle bracket in parameterized type reference
 	 *     - option id:         "org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference"
 	 *     - possible values:   { INSERT, DO_NOT_INSERT }
@@ -2927,6 +2960,18 @@ public class DefaultCodeFormatterConstants {
 	public static final String FORMATTER_INSERT_SPACE_BEFORE_ELLIPSIS  = JavaCore.PLUGIN_ID + ".formatter.insert_space_before_ellipsis";	//$NON-NLS-1$
 	/**
 	 * <pre>
+	 * FORMATTER / Option to insert a space before lambda ->
+	 *     - option id:         "org.eclipse.jdt.core.formatter.insert_space_before_lambda_arrow"
+	 *     - possible values:   { INSERT, DO_NOT_INSERT }
+	 *     - default:           INSERT
+	 * </pre>
+	 * @see JavaCore#INSERT
+	 * @see JavaCore#DO_NOT_INSERT
+	 * @since 3.9
+	 */
+	public static final String FORMATTER_INSERT_SPACE_BEFORE_LAMBDA_ARROW = JavaCore.PLUGIN_ID + ".formatter.insert_space_before_lambda_arrow";	//$NON-NLS-1$
+	/**
+	 * <pre>
 	 * FORMATTER / Option to insert a space before the opening angle bracket in parameterized type reference
 	 *     - option id:         "org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference"
 	 *     - possible values:   { INSERT, DO_NOT_INSERT }
@@ -3838,6 +3883,7 @@ public class DefaultCodeFormatterConstants {
  	 * @see #FORMATTER_BRACE_POSITION_FOR_METHOD_DECLARATION
  	 * @see #FORMATTER_BRACE_POSITION_FOR_SWITCH
 	 * @see #FORMATTER_BRACE_POSITION_FOR_TYPE_DECLARATION
+	 * @see #FORMATTER_BRACE_POSITION_FOR_LAMBDA_BODY
 	 * @since 3.0
 	 */
 	public static final String NEXT_LINE = "next_line"; //$NON-NLS-1$
@@ -3853,6 +3899,7 @@ public class DefaultCodeFormatterConstants {
  	 * @see #FORMATTER_BRACE_POSITION_FOR_METHOD_DECLARATION
  	 * @see #FORMATTER_BRACE_POSITION_FOR_SWITCH
 	 * @see #FORMATTER_BRACE_POSITION_FOR_TYPE_DECLARATION
+	 * @see #FORMATTER_BRACE_POSITION_FOR_LAMBDA_BODY
 	 * @since 3.0
 	 */
     public static final String NEXT_LINE_ON_WRAP = "next_line_on_wrap"; //$NON-NLS-1$
@@ -3868,6 +3915,7 @@ public class DefaultCodeFormatterConstants {
  	 * @see #FORMATTER_BRACE_POSITION_FOR_METHOD_DECLARATION
  	 * @see #FORMATTER_BRACE_POSITION_FOR_SWITCH
 	 * @see #FORMATTER_BRACE_POSITION_FOR_TYPE_DECLARATION
+	 * @see #FORMATTER_BRACE_POSITION_FOR_LAMBDA_BODY
 	 * @since 3.0
 	 */
 	public static final String NEXT_LINE_SHIFTED = "next_line_shifted";	//$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
index 30a8fce..19b8387 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
@@ -1,14 +1,19 @@
 /*******************************************************************************
- * Copyright (c) 2002, 2012 IBM Corporation and others.
+ * Copyright (c) 2002, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Brock Janiczak - Contribution for bug 150741
  *     Nanda Firdausi - Contribution for bug 298844
+ *     Jesper S Moller - Contribution for bug 402173
  *******************************************************************************/
 package org.eclipse.jdt.internal.formatter;
 
@@ -49,6 +54,7 @@ import org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;
 import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
 import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ContinueStatement;
+import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
 import org.eclipse.jdt.internal.compiler.ast.UnionTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.DoStatement;
 import org.eclipse.jdt.internal.compiler.ast.DoubleLiteral;
@@ -1898,10 +1904,30 @@ public class CodeFormatterVisitor extends ASTVisitor {
 			boolean spaceBeforeComma,
 			boolean spaceAfterComma,
 			int methodDeclarationParametersAlignment) {
+		formatMethodArguments(
+				methodDeclaration.arguments,
+				methodDeclaration.scope,
+				spaceBeforeOpenParen,
+				spaceBetweenEmptyParameters,
+				spaceBeforeClosingParen,
+				spaceBeforeFirstParameter,
+				spaceBeforeComma,
+				spaceAfterComma,
+				methodDeclarationParametersAlignment);
+	}
+	private void formatMethodArguments(
+			final Argument[] arguments,
+			MethodScope scope,
+			boolean spaceBeforeOpenParen,
+			boolean spaceBetweenEmptyParameters,
+			boolean spaceBeforeClosingParen,
+			boolean spaceBeforeFirstParameter,
+			boolean spaceBeforeComma,
+			boolean spaceAfterComma,
+			int methodDeclarationParametersAlignment) {
 
 		this.scribe.printNextToken(TerminalTokens.TokenNameLPAREN, spaceBeforeOpenParen);
 
-		final Argument[] arguments = methodDeclaration.arguments;
 		if (arguments != null) {
 			if (spaceBeforeFirstParameter) {
 				this.scribe.space();
@@ -1941,7 +1967,7 @@ public class CodeFormatterVisitor extends ASTVisitor {
 						} else if (spaceAfterComma) {
 							this.scribe.space();
 						}
-						arguments[i].traverse(this, methodDeclaration.scope);
+						arguments[i].traverse(this, scope);
 						argumentsAlignment.startingColumn = -1;
 					}
 					ok = true;
@@ -4240,6 +4266,46 @@ public class CodeFormatterVisitor extends ASTVisitor {
 	}
 
 	/**
+	 * @see org.eclipse.jdt.internal.compiler.ASTVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LambdaExpression, org.eclipse.jdt.internal.compiler.lookup.BlockScope)
+	 */
+	public boolean visit(LambdaExpression lambdaExpression, BlockScope scope) {
+		
+		final int numberOfParens = (lambdaExpression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;
+		if (numberOfParens > 0) {
+			manageOpeningParenthesizedExpression(lambdaExpression, numberOfParens);
+		}
+		if (isNextToken(TerminalTokens.TokenNameLPAREN)) {
+			// Format arguments
+			formatMethodArguments(
+				lambdaExpression.arguments,
+				lambdaExpression.getScope(),
+				this.preferences.insert_space_before_opening_paren_in_method_declaration,
+				this.preferences.insert_space_between_empty_parens_in_method_declaration,
+				this.preferences.insert_space_before_closing_paren_in_method_declaration,
+				this.preferences.insert_space_after_opening_paren_in_method_declaration,
+				this.preferences.insert_space_before_comma_in_method_declaration_parameters,
+				this.preferences.insert_space_after_comma_in_method_declaration_parameters,
+				this.preferences.alignment_for_parameters_in_method_declaration);
+		} else {
+			// This MUST be a single, untyped parameter
+			this.scribe.printNextToken(TerminalTokens.TokenNameIdentifier);
+		}
+		if (this.preferences.insert_space_before_lambda_arrow) this.scribe.space();
+		this.scribe.printNextToken(TerminalTokens.TokenNameARROW);
+		if (this.preferences.insert_space_after_lambda_arrow) this.scribe.space();
+		if (lambdaExpression.body instanceof Block) {
+			formatBlock((Block) lambdaExpression.body, scope, this.preferences.brace_position_for_lambda_body, this.preferences.insert_space_before_opening_brace_in_block);
+		} else {
+			lambdaExpression.body.traverse(this, scope);
+		}
+
+		if (numberOfParens > 0) {
+			manageClosingParenthesizedExpression(lambdaExpression, numberOfParens);
+		}
+		return false;
+	}
+	
+	/**
 	 * @see org.eclipse.jdt.internal.compiler.ASTVisitor#visit(org.eclipse.jdt.internal.compiler.ast.LocalDeclaration, org.eclipse.jdt.internal.compiler.lookup.BlockScope)
 	 */
 	public boolean visit(LocalDeclaration localDeclaration, BlockScope scope) {
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
index 6c3579c..95be5f3 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
@@ -1,14 +1,19 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Brock Janiczak - Contribution for bug 150741
  *     Ray V. (voidstar@gmail.com) - Contribution for bug 282988
+ *     Jesper S Moller - Contribution for bug 402173
  *******************************************************************************/
 package org.eclipse.jdt.internal.formatter;
 
@@ -83,6 +88,7 @@ public class DefaultCodeFormatterOptions {
 	public String brace_position_for_constructor_declaration;
 	public String brace_position_for_enum_constant;
 	public String brace_position_for_enum_declaration;
+	public String brace_position_for_lambda_body;
 	public String brace_position_for_method_declaration;
 	public String brace_position_for_type_declaration;
 	public String brace_position_for_switch;
@@ -194,6 +200,7 @@ public class DefaultCodeFormatterOptions {
 	public boolean insert_space_after_comma_in_type_arguments;
 	public boolean insert_space_after_comma_in_type_parameters;
 	public boolean insert_space_after_ellipsis;
+	public boolean insert_space_after_lambda_arrow;
 	public boolean insert_space_after_opening_angle_bracket_in_parameterized_type_reference;
 	public boolean insert_space_after_opening_angle_bracket_in_type_arguments;
 	public boolean insert_space_after_opening_angle_bracket_in_type_parameters;
@@ -271,6 +278,7 @@ public class DefaultCodeFormatterOptions {
 	public boolean insert_space_before_comma_in_type_arguments;
 	public boolean insert_space_before_comma_in_type_parameters;
 	public boolean insert_space_before_ellipsis;
+	public boolean insert_space_before_lambda_arrow;
 	public boolean insert_space_before_parenthesized_expression_in_return;
 	public boolean insert_space_before_parenthesized_expression_in_throw;
 	public boolean insert_space_before_question_in_wilcard;
@@ -394,6 +402,7 @@ public class DefaultCodeFormatterOptions {
 		options.put(DefaultCodeFormatterConstants.FORMATTER_BRACE_POSITION_FOR_ENUM_DECLARATION, this.brace_position_for_enum_declaration);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_BRACE_POSITION_FOR_METHOD_DECLARATION, this.brace_position_for_method_declaration);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_BRACE_POSITION_FOR_TYPE_DECLARATION, this.brace_position_for_type_declaration);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_BRACE_POSITION_FOR_LAMBDA_BODY, this.brace_position_for_lambda_body);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_BRACE_POSITION_FOR_SWITCH, this.brace_position_for_switch);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_COMMENT_CLEAR_BLANK_LINES_IN_BLOCK_COMMENT, this.comment_clear_blank_lines_in_block_comment ? DefaultCodeFormatterConstants.TRUE : DefaultCodeFormatterConstants.FALSE);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_COMMENT_CLEAR_BLANK_LINES_IN_JAVADOC_COMMENT, this.comment_clear_blank_lines_in_javadoc_comment ? DefaultCodeFormatterConstants.TRUE : DefaultCodeFormatterConstants.FALSE);
@@ -493,6 +502,7 @@ public class DefaultCodeFormatterOptions {
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_COMMA_IN_TYPE_PARAMETERS, this.insert_space_after_comma_in_type_parameters ? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_BRACKET_IN_ARRAY_ALLOCATION_EXPRESSION, this.insert_space_after_opening_bracket_in_array_allocation_expression? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_ELLIPSIS, this.insert_space_after_ellipsis ? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_LAMBDA_ARROW, this.insert_space_after_lambda_arrow ? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_ANGLE_BRACKET_IN_PARAMETERIZED_TYPE_REFERENCE, this.insert_space_after_opening_angle_bracket_in_parameterized_type_reference? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_ANGLE_BRACKET_IN_TYPE_ARGUMENTS, this.insert_space_after_opening_angle_bracket_in_type_arguments? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_ANGLE_BRACKET_IN_TYPE_PARAMETERS, this.insert_space_after_opening_angle_bracket_in_type_parameters? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
@@ -569,6 +579,7 @@ public class DefaultCodeFormatterOptions {
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_COMMA_IN_TYPE_PARAMETERS, this.insert_space_before_comma_in_type_parameters? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_COMMA_IN_PARAMETERIZED_TYPE_REFERENCE, this.insert_space_before_comma_in_parameterized_type_reference? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_ELLIPSIS, this.insert_space_before_ellipsis ? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
+		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_LAMBDA_ARROW, this.insert_space_before_lambda_arrow ? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_ANGLE_BRACKET_IN_PARAMETERIZED_TYPE_REFERENCE, this.insert_space_before_opening_angle_bracket_in_parameterized_type_reference? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_ANGLE_BRACKET_IN_TYPE_ARGUMENTS, this.insert_space_before_opening_angle_bracket_in_type_arguments? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
 		options.put(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_ANGLE_BRACKET_IN_TYPE_PARAMETERS, this.insert_space_before_opening_angle_bracket_in_type_parameters? JavaCore.INSERT : JavaCore.DO_NOT_INSERT);
@@ -961,6 +972,14 @@ public class DefaultCodeFormatterOptions {
 				this.brace_position_for_enum_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 			}
 		}
+		final Object bracePositionForLambdaDeclarationOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_BRACE_POSITION_FOR_LAMBDA_BODY);
+		if (bracePositionForLambdaDeclarationOption != null) {
+			try {
+				this.brace_position_for_lambda_body = (String) bracePositionForLambdaDeclarationOption;
+			} catch(ClassCastException e) {
+				this.brace_position_for_lambda_body = DefaultCodeFormatterConstants.END_OF_LINE;
+			}
+		}
 		final Object bracePositionForMethodDeclarationOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_BRACE_POSITION_FOR_METHOD_DECLARATION);
 		if (bracePositionForMethodDeclarationOption != null) {
 			try {
@@ -1438,6 +1457,10 @@ public class DefaultCodeFormatterOptions {
 		if (insertSpaceAfterEllipsisOption != null) {
 			this.insert_space_after_ellipsis = JavaCore.INSERT.equals(insertSpaceAfterEllipsisOption);
 		}
+		final Object insertSpaceAfterLambdaArrowOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_LAMBDA_ARROW);
+		if (insertSpaceAfterLambdaArrowOption != null) {
+			this.insert_space_after_lambda_arrow = JavaCore.INSERT.equals(insertSpaceAfterLambdaArrowOption);
+		}
 		final Object insertSpaceAfterOpeningAngleBracketInParameterizedTypeReferenceOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_AFTER_OPENING_ANGLE_BRACKET_IN_PARAMETERIZED_TYPE_REFERENCE);
 		if (insertSpaceAfterOpeningAngleBracketInParameterizedTypeReferenceOption != null) {
 			this.insert_space_after_opening_angle_bracket_in_parameterized_type_reference = JavaCore.INSERT.equals(insertSpaceAfterOpeningAngleBracketInParameterizedTypeReferenceOption);
@@ -1746,6 +1769,10 @@ public class DefaultCodeFormatterOptions {
 		if (insertSpaceBeforeEllipsisOption != null) {
 			this.insert_space_before_ellipsis = JavaCore.INSERT.equals(insertSpaceBeforeEllipsisOption);
 		}
+		final Object insertSpaceBeforeLambdaArrowOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_LAMBDA_ARROW);
+		if (insertSpaceBeforeLambdaArrowOption != null) {
+			this.insert_space_before_lambda_arrow = JavaCore.INSERT.equals(insertSpaceBeforeLambdaArrowOption);
+		}
 		final Object insertSpaceBeforeOpeningAngleBrackerInParameterizedTypeReferenceOption = settings.get(DefaultCodeFormatterConstants.FORMATTER_INSERT_SPACE_BEFORE_OPENING_ANGLE_BRACKET_IN_PARAMETERIZED_TYPE_REFERENCE);
 		if (insertSpaceBeforeOpeningAngleBrackerInParameterizedTypeReferenceOption != null) {
 			this.insert_space_before_opening_angle_bracket_in_parameterized_type_reference = JavaCore.INSERT.equals(insertSpaceBeforeOpeningAngleBrackerInParameterizedTypeReferenceOption);
@@ -2204,6 +2231,7 @@ public class DefaultCodeFormatterOptions {
 		this.brace_position_for_constructor_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_enum_constant = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_enum_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
+		this.brace_position_for_lambda_body = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_method_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_type_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_switch = DefaultCodeFormatterConstants.END_OF_LINE;
@@ -2303,6 +2331,7 @@ public class DefaultCodeFormatterOptions {
 		this.insert_space_after_comma_in_type_arguments = true;
 		this.insert_space_after_comma_in_type_parameters = true;
 		this.insert_space_after_ellipsis = true;
+		this.insert_space_after_lambda_arrow = true;
 		this.insert_space_after_opening_angle_bracket_in_parameterized_type_reference = false;
 		this.insert_space_after_opening_angle_bracket_in_type_arguments = false;
 		this.insert_space_after_opening_angle_bracket_in_type_parameters = false;
@@ -2379,6 +2408,7 @@ public class DefaultCodeFormatterOptions {
 		this.insert_space_before_comma_in_type_arguments = false;
 		this.insert_space_before_comma_in_type_parameters = false;
 		this.insert_space_before_ellipsis = false;
+		this.insert_space_before_lambda_arrow = true;
 		this.insert_space_before_parenthesized_expression_in_return = true;
 		this.insert_space_before_parenthesized_expression_in_throw = true;
 		this.insert_space_before_opening_angle_bracket_in_parameterized_type_reference = false;
@@ -2491,6 +2521,7 @@ public class DefaultCodeFormatterOptions {
 		this.brace_position_for_constructor_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_enum_constant = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_enum_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
+		this.brace_position_for_lambda_body = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_method_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_type_declaration = DefaultCodeFormatterConstants.END_OF_LINE;
 		this.brace_position_for_switch = DefaultCodeFormatterConstants.END_OF_LINE;
@@ -2590,6 +2621,7 @@ public class DefaultCodeFormatterOptions {
 		this.insert_space_after_comma_in_type_arguments = true;
 		this.insert_space_after_comma_in_type_parameters = true;
 		this.insert_space_after_ellipsis = true;
+		this.insert_space_after_lambda_arrow = true;
 		this.insert_space_after_opening_angle_bracket_in_parameterized_type_reference = false;
 		this.insert_space_after_opening_angle_bracket_in_type_arguments = false;
 		this.insert_space_after_opening_angle_bracket_in_type_parameters = false;
@@ -2666,6 +2698,7 @@ public class DefaultCodeFormatterOptions {
 		this.insert_space_before_comma_in_type_arguments = false;
 		this.insert_space_before_comma_in_type_parameters = false;
 		this.insert_space_before_ellipsis = false;
+		this.insert_space_before_lambda_arrow = true;
 		this.insert_space_before_parenthesized_expression_in_return = true;
 		this.insert_space_before_parenthesized_expression_in_throw = true;
 		this.insert_space_before_opening_angle_bracket_in_parameterized_type_reference = false;
commit cf072eeff121940a541295553114f490c9a9bb69
Author: Jesper S Moller <jesper@selskabet.org>
Date:   Tue Mar 19 09:46:44 2013 -0400

    Fix for issue raised during code review for Bug 402173 -
    [1.8][formatter] Code formatter should understand lambda expressions.

8	0	org.eclipse.jdt.core.tests.model/workspace/FormatterJSR335/testLambda/A_in.java
8	0	org.eclipse.jdt.core.tests.model/workspace/FormatterJSR335/testLambda/A_out.java
1	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
diff --git a/org.eclipse.jdt.core.tests.model/workspace/FormatterJSR335/testLambda/A_in.java b/org.eclipse.jdt.core.tests.model/workspace/FormatterJSR335/testLambda/A_in.java
index 37a16ab..2ba8f99 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/FormatterJSR335/testLambda/A_in.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/FormatterJSR335/testLambda/A_in.java
@@ -3,10 +3,18 @@ package p1.p2.test;
 import java.io.Serializable;
 import java.io.IOException;
 
+interface I {
+	int id(int x, int y);
+}
+
 public abstract class A extends java.lang.Object implements Runnable, Cloneable, Serializable {
 	public void run() {
 	}
 
+	public static class X {
+		I i = (x,y) -> x;
+	}
+	
 	public void lambdas() {
 		Runnable a = () -> {
 			thisIsCrazy();
diff --git a/org.eclipse.jdt.core.tests.model/workspace/FormatterJSR335/testLambda/A_out.java b/org.eclipse.jdt.core.tests.model/workspace/FormatterJSR335/testLambda/A_out.java
index 6ca70f7..a2cc95f 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/FormatterJSR335/testLambda/A_out.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/FormatterJSR335/testLambda/A_out.java
@@ -3,11 +3,19 @@ package p1.p2.test;
 import java.io.Serializable;
 import java.io.IOException;
 
+interface I {
+	int id(int x, int y);
+}
+
 public abstract class A extends java.lang.Object implements Runnable,
 		Cloneable, Serializable {
 	public void run() {
 	}
 
+	public static class X {
+		I i = (x, y) -> x;
+	}
+
 	public void lambdas() {
 		Runnable a = () -> {
 			thisIsCrazy();
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
index 3b49d3d..f79cafc 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java
@@ -2678,7 +2678,7 @@ public class CodeFormatterVisitor extends ASTVisitor {
 			/*
 			 * Print the argument name
 			 */
-			this.scribe.printNextToken(TerminalTokens.TokenNameIdentifier, true);
+			this.scribe.printNextToken(TerminalTokens.TokenNameIdentifier, argument.type != null);
 		}
 
 
