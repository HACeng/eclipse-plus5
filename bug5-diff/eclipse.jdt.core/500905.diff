commit 3917b238722d6cf18d30ee4070f2ee641bd1b38b
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Tue Feb 14 19:15:18 2017 +0530

    Bug 500905 - [9] Read modules from JMOD
    
    Change-Id: Ic5a81b7e965fb4c0403757ce1e35a48e4ab53fbf
    Signed-off-by: Jay Arthanareeswaran <jarthana@in.ibm.com>

71	32	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
36	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
1	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
4	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
1	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationDecorator.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/SuffixConstants.java
11	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
1	2	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
10	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryModule.java
5	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
17	9	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
67	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JModPackageFragmentRoot.java
8	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
10	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
13	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
4	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
1	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
4	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
1	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
8	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
1	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
index d13884c..6b5eba1 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/Java9ElementTests.java
@@ -14,7 +14,9 @@
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
+import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.IClasspathEntry;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
@@ -27,6 +29,7 @@ import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.tests.util.AbstractCompilerTest;
+import org.eclipse.jdt.internal.core.BinaryModule;
 
 import junit.framework.Test;
 
@@ -44,7 +47,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test001() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 				String fileContent =  "module my.mod{}\n";
 				createFile(	"/Java9Elements/src/module-info.java",	fileContent);
@@ -65,7 +68,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test002() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 				String fileContent =  "module my.mod{\n" +
 						 "	exports p.q.r;" +
@@ -101,7 +104,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test003() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 				String fileContent =  
 						"module my.mod{\n" +
@@ -139,7 +142,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test004() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 				String fileContent =  
 						"module my.mod{\n" +
@@ -175,7 +178,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test005() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 				String fileContent =  
 						"module my.mod{\n" +
@@ -206,7 +209,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test006() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 			String fileContent =  
 					"module my.mod{\n" +
@@ -217,7 +220,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 					"}";
 			createFile(	"/Java9Elements/src/module-info.java",	fileContent);
 
-			project = createJavaProject("Java9Elements2", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			project = createJavaProject("Java9Elements2", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 			fileContent =  "module your.mod{\n" +
 					"	requires my.mod;\n" +
@@ -239,7 +242,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test007() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 			String fileContent =  
 					"module my.mod{\n" +
@@ -248,7 +251,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 					"}";
 			createFile(	"/Java9Elements/src/module-info.java",	fileContent);
 
-			project = createJavaProject("Java9Elements2", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			project = createJavaProject("Java9Elements2", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 			fileContent =  
 					"module your.mod{\n" +
@@ -270,7 +273,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test008() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 			String fileContent =  "module my.mod {\n" +
 					"	exports p.q.r to your.mod;" +
@@ -279,7 +282,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 			createFile(	"/Java9Elements/src/module-info.java",	fileContent);
 			int start = fileContent.indexOf("your.mod");
 
-			project = createJavaProject("Java9Elements2", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			project = createJavaProject("Java9Elements2", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 			fileContent =  "module your.mod{\n" +
 					"	requires my.mod;\n" +
@@ -300,7 +303,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test009() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 			String fileContent =  "module my.mod {\n" +
 					"	exports p.q.r;" +
@@ -324,7 +327,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test010() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 			String fileContent =  "// A very simple module" +
 					 "module my.mod {\n" +
@@ -345,7 +348,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test011() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 				String fileContent =  "module my.mod{" +
 									"	provides a.b.C with a.b.CImpl, a.b.DImpl;\n" + 
@@ -387,7 +390,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test012() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 				String fileContent =  "module my.mod{" +
 									"	provides a.b.C with a.b.CImpl, a.b.DImpl;\n" + 
@@ -421,7 +424,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test013() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 				String fileContent =  "module my.mod{" +
 									"	opens a.b to java.base, java.sql;" +
@@ -452,7 +455,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void test014() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			project.open(null);
 				String fileContent =  "module my.mod{" +
 									"	exports a.b to java.base, java.sql;" +
@@ -480,7 +483,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void testBug510339_001_since_9() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			addClasspathEntry(project, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			project.open(null);
 			String fileContent =
@@ -508,7 +511,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	public void testBug510339_002_since_9() throws Exception {
 		try {
 
-			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project1.open(null);
 			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String fileContent =
@@ -523,7 +526,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 					"package pack1;\n" +
 					"public class X11 {}\n");
 
-			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project2.open(null);
 			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String secondFile =
@@ -551,7 +554,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void testBug510339_003_since_9() throws Exception {
 		try {
-			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "1.9");
+			IJavaProject project = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "1.9");
 			addClasspathEntry(project, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			project.open(null);
 			String fileContent =
@@ -579,7 +582,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	public void testBug510339_004_since_9() throws Exception {
 		try {
 
-			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project1.open(null);
 			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String fileContent =
@@ -592,7 +595,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 					"package pack1;\n" +
 					"public class X11 {}\n");
 
-			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project2.open(null);
 			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String secondFile =
@@ -623,7 +626,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	public void testBug510339_005_since_9() throws Exception {
 		try {
 
-			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project1.open(null);
 			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String fileContent =
@@ -637,7 +640,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 					"package pack11;\n" +
 					"public class X11 implements pack22.I22 {}\n");
 
-			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project2.open(null);
 			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String secondFile =
@@ -672,7 +675,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	public void testBug510339_006_since_9() throws Exception {
 		try {
 
-			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project1.open(null);
 			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String fileContent =
@@ -686,7 +689,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 					"package pack11;\n" +
 					"public class X11 implements pack22.I22 {}\n");
 
-			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project2.open(null);
 			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String secondFile =
@@ -721,7 +724,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	public void testBug510339_007_since_9() throws Exception {
 		try {
 
-			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project1.open(null);
 			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String fileContent =
@@ -753,7 +756,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	public void testBug510339_008_since_9() throws Exception {
 		try {
 
-			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project1.open(null);
 			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String fileContent =
@@ -767,7 +770,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 					"package pack11;\n" +
 					"public class X11 implements pack22.I22 {}\n");
 
-			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project2.open(null);
 			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String secondFile =
@@ -802,7 +805,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	public void testBug510339_009_since_9() throws Exception {
 		try {
 
-			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project1.open(null);
 			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String fileContent =
@@ -833,7 +836,7 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 	}
 	public void testBug510339_010_since_9() throws Exception {
 		try {
-			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			IJavaProject project1 = createJavaProject("Java9Elements", new String[] {"src"}, new String[] {"JCL19_LIB"}, "bin", "9");
 			project1.open(null);
 			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
 			String fileContent =
@@ -862,4 +865,40 @@ public class Java9ElementTests extends AbstractJavaModelTests {
 			deleteProject("Java9Elements");
 		}
 	}
+	public void testSystemLibAsJMod() throws Exception {
+		try {
+			IJavaProject project1 = createJava9Project("Java9Elements", new String[] {"src"});
+			project1.open(null);
+			IClasspathEntry[] rawClasspath = project1.getRawClasspath();
+			for (int i = 0; i < rawClasspath.length; i++) {
+				IPath path = rawClasspath[i].getPath();
+				if (path.lastSegment().equals("jrt-fs.jar")) {
+					path = path.removeLastSegments(2).append("jmods").append("java.base.jmod");
+					IClasspathEntry newEntry = JavaCore.newLibraryEntry(path, rawClasspath[i].getSourceAttachmentPath(), new Path("java.base"));
+					rawClasspath[i] = newEntry;
+				}
+			}
+			project1.setRawClasspath(rawClasspath, null);
+			String fileContent =
+					"module first {\n" +
+					"    requires java.base;\n" +
+					"    uses pack11.X11;\n" +
+					"}\n";
+				createFile("/Java9Elements/src/module-info.java", fileContent);
+
+			ICompilationUnit unit = getCompilationUnit("/Java9Elements/src/module-info.java");
+			String selection = "java.base";
+			int start = fileContent.lastIndexOf(selection);
+			IJavaElement[] elements = unit.codeSelect(start, selection.length());
+			assertEquals("Incorrect no of elements", 1, elements.length);
+			assertTrue("Invalid selection result", (elements[0] instanceof BinaryModule));
+			BinaryModule mod = (BinaryModule) elements[0];
+			IPackageExport[] exportedPackages = mod.getExportedPackages();
+			assertNotNull("missing package exports", exportedPackages);
+			assertTrue("missing package exports", exportedPackages.length > 0);
+		}
+		finally {
+			deleteProject("Java9Elements");
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index dac6058..487f74e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -99,7 +99,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			IPackageFragmentRoot base = null;
 			for (IPackageFragmentRoot iRoot : roots) {
 				IModuleDescription moduleDescription = iRoot.getModuleDescription();
-				if (moduleDescription != null) {
+				if (moduleDescription != null && moduleDescription.getElementName().equals("java.base")) {
 					base = iRoot;
 					break;
 				}
@@ -2535,6 +2535,41 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			deleteProject("com.greetings");
 		}
 	}
+	public void testSystemLibAsJMod() throws CoreException {
+		if (!isJRE9) return;
+		try {
+			IJavaProject project = createJava9Project("Test01", new String[]{"src"});
+			IClasspathEntry[] rawClasspath = project.getRawClasspath();
+			for (int i = 0; i < rawClasspath.length; i++) {
+				IPath path = rawClasspath[i].getPath();
+				if (path.lastSegment().equals("jrt-fs.jar")) {
+					path = path.removeLastSegments(2).append("jmods").append("java.base.jmod");
+					IClasspathEntry newEntry = JavaCore.newLibraryEntry(path, rawClasspath[i].getSourceAttachmentPath(), new Path("java.base"));
+					rawClasspath[i] = newEntry;
+				}
+			}
+			project.setRawClasspath(rawClasspath, null);
+			this.createFile("Test01/src/module-info.java", "");
+			this.createFolder("Test01/src/com/greetings");
+			this.createFile("Test01/src/com/greetings/Main.java", "");
+			waitForManualRefresh();
+			waitForAutoBuild();
+			project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IPackageFragmentRoot[] roots = project.getPackageFragmentRoots();
+			IPackageFragmentRoot base = null;
+			for (IPackageFragmentRoot iRoot : roots) {
+				IModuleDescription moduleDescription = iRoot.getModuleDescription();
+				if (moduleDescription != null) {
+					base = iRoot;
+					break;
+				}
+			}
+			assertNotNull("Java.base module should not null", base);
+			assertMarkers("Unexpected markers", "", project);
+		} finally {
+			deleteProject("Test01");
+		}
+	}
 	// sort by CHAR_START
 	protected void sortMarkers(IMarker[] markers) {
 		Arrays.sort(markers, (a,b) -> a.getAttribute(IMarker.CHAR_START, 0) - b.getAttribute(IMarker.CHAR_START, 0)); 
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
index 3573276..9236663 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
@@ -114,8 +114,7 @@ public class ClasspathJrt extends ClasspathLocation implements IMultiModuleEntry
 						}
 					}
 				}
-				char[] modName = reader.getModule() == null ? null : reader.getModule().name();
-				return new NameEnvironmentAnswer(reader, fetchAccessRestriction(qualifiedBinaryFileName), modName);
+				return new NameEnvironmentAnswer(reader, fetchAccessRestriction(qualifiedBinaryFileName), reader.getModule());
 			}
 		} catch(ClassFormatException e) {
 			// treat as if class file is missing
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
index 4af8a25..e97e9b4 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
@@ -215,7 +215,7 @@ public static Classpath getClasspath(String classpathName, String encoding,
 		}
 	} else {
 		int format = Util.archiveFormat(classpathName);
-		if (format >= Util.ZIP_FILE) {
+		if (format == Util.ZIP_FILE) {
 			if (isSourceOnly) {
 				// source only mode
 				result = new ClasspathSourceJar(file, true, accessRuleSet,
@@ -244,7 +244,10 @@ public static Classpath getClasspath(String classpathName, String encoding,
 					result = new ClasspathJar(file, true, accessRuleSet, null);
 				}
 			}
+		} else if (format == Util.JMOD_FILE) {
+			// TODO BETA_JAVA9: we need new type of classpath to handle Jmod files in batch compiler.
 		}
+
 	}
 	return result;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index 0dd5d0f..c7bc52e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -616,8 +616,8 @@ public IBinaryField[] getFields() {
 /**
  * @see IBinaryType#getModule()
  */
-public IModule getModule() {
-	return this.moduleDeclaration;
+public char[] getModule() {
+	return this.moduleName;
 }
 /**
  * Returns the module declaration that this class file represents. This will be 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationDecorator.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationDecorator.java
index aa940ac..eea6557 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationDecorator.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationDecorator.java
@@ -23,7 +23,6 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
-import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
@@ -290,7 +289,7 @@ public class ExternalAnnotationDecorator implements IBinaryType {
 	}
 
 	@Override
-	public IModule getModule() {
+	public char[] getModule() {
 		// TODO Auto-generated method stub
 		return null;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
index 20e93de..7e03eed 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
@@ -67,7 +67,7 @@ IBinaryField[] getFields();
  *
  * @return the module
  */
-IModule getModule();
+char[] getModule();
 /**
  * Answer the receiver's ClassSignature, which describes the type parameters,
  * super class, and super interfaces as specified in section "4.7.9.1 Signatures"
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
index 51d0dea..c27309e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
@@ -23,6 +23,7 @@ package org.eclipse.jdt.internal.compiler.env;
  * @see IModulePathEntry#getLookupEnvironmentFor(IModule)
  */
 public interface IModuleEnvironment {
+	static String MODULE_INFO = "module-info"; //$NON-NLS-1$
 	static String MODULE_INFO_JAVA = "module-info.java"; //$NON-NLS-1$
 	static String MODULE_INFO_CLASS = "module-info.class"; //$NON-NLS-1$
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
index 70182ec..90922d3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
@@ -29,7 +29,7 @@ public class NameEnvironmentAnswer {
 	public NameEnvironmentAnswer(IBinaryType binaryType, AccessRestriction accessRestriction) {
 		this.binaryType = binaryType;
 		this.accessRestriction = accessRestriction;
-		this.module = binaryType.getModule() != null ? binaryType.getModule().name() : null;
+		this.module = binaryType.getModule();
 	}
 
 	public NameEnvironmentAnswer(IBinaryType binaryType, AccessRestriction accessRestriction, char[] module) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/SuffixConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/SuffixConstants.java
index 2b45d3e..5ae3006 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/SuffixConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/SuffixConstants.java
@@ -19,6 +19,8 @@ public interface SuffixConstants {
 	public final static String EXTENSION_CLASS = "CLASS"; //$NON-NLS-1$
 	public final static String EXTENSION_java = "java"; //$NON-NLS-1$
 	public final static String EXTENSION_JAVA = "JAVA"; //$NON-NLS-1$
+	public final static String EXTENSION_jmod = "jmod"; //$NON-NLS-1$
+	public final static String EXTENSION_JMOD = "JMOD"; //$NON-NLS-1$
 
 	public final static String SUFFIX_STRING_class = "." + EXTENSION_class; //$NON-NLS-1$
 	public final static String SUFFIX_STRING_CLASS = "." + EXTENSION_CLASS; //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index a58e02a..3d53757 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -755,10 +755,11 @@ public class Util implements SuffixConstants {
 	}
 	
 	public static final int ZIP_FILE = 0;
+	public static final int JMOD_FILE = 1;
 	
 	/**
-	 * Returns whether the given name is potentially a zip archive file name
-	 * (it has a file extension and it is not ".java" nor ".class")
+	 * Returns the kind of archive this file is. The format is one of
+	 * #ZIP_FILE or {@link #JMOD_FILE}
 	 */
 	public final static int archiveFormat(String name) {
 		int lastDot = name.lastIndexOf('.');
@@ -787,6 +788,14 @@ public class Util implements SuffixConstants {
 			}
 			return -1; // it is a ".class" file, it cannot be a zip archive name
 		}
+		if (extensionLength == EXTENSION_jmod.length()) {
+			for (int i = extensionLength-1; i >=0; i--) {
+				if (Character.toLowerCase(name.charAt(length - extensionLength + i)) != EXTENSION_jmod.charAt(i)) {
+					return ZIP_FILE; // not a ".jmod" file, so this is a potential archive name
+				}
+			}
+			return JMOD_FILE;
+		}
 		return ZIP_FILE; // it is neither a ".java" file nor a ".class" file, so this is a potential archive name
 	}
 
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
index 222d373..b7c0b2e 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
@@ -29,7 +29,6 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
-import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
@@ -204,7 +203,7 @@ public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWal
 	return walker;
 }
 @Override
-public IModule getModule() {
+public char[] getModule() {
 	// TODO BETA_JAVA9 Auto-generated method stub
 	return null;
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryModule.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryModule.java
index 1b7730a..d4f1811 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryModule.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryModule.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation.
+ * Copyright (c) 2016, 2017 IBM Corporation.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,6 +16,7 @@ package org.eclipse.jdt.internal.core;
 
 import java.util.ArrayList;
 
+import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IModuleDescription;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
@@ -62,6 +63,14 @@ public class BinaryModule extends BinaryMember implements IModuleDescription {
 		list.toArray(array);
 		return array;
 	}
+	/*
+	 * @see IParent#getChildren()
+	 */
+	public IJavaElement[] getChildren() throws JavaModelException {
+		ClassFile cf = (ClassFile) this.parent;
+		ClassFileInfo cfi = (ClassFileInfo) cf.getElementInfo();
+		return cfi.binaryChildren;
+	}
 	@Override
 	public int getFlags() throws JavaModelException {
 		ModuleDescriptionInfo info = (ModuleDescriptionInfo) getElementInfo();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index 1d2cf29..d667518 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -330,6 +330,7 @@ public byte[] getBytes() throws JavaModelException {
 		JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
 		try {
 			String entryName = Util.concatWith(((PackageFragment) pkg).names, getElementName(), '/');
+			entryName = root.getClassFilePath(entryName);
 			return getClassFileContent(root, entryName);
 			// BETA_JAVA9 - The below exception is not thrown in new scheme of things. Could cause issues?
 //			throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.ELEMENT_DOES_NOT_EXIST, this));
@@ -386,10 +387,10 @@ private IBinaryType getJarBinaryTypeInfo() throws CoreException, IOException, Cl
 	IBinaryType result = null;
 	IPackageFragmentRoot root = getPackageFragmentRoot();
 	if (getPackageFragmentRoot() instanceof JarPackageFragmentRoot) {
-		PackageFragment pkg = (PackageFragment) getParent();
-		JarPackageFragmentRoot jarRoot = (JarPackageFragmentRoot) getPackageFragmentRoot();
-		String entryName = Util.concatWith(pkg.names, getElementName(), '/');
-		if (root instanceof JrtPackageFragmentRoot || entryName.equals(IModuleEnvironment.MODULE_INFO_CLASS)) {
+		if (root instanceof JrtPackageFragmentRoot || this.name.equals(IModuleEnvironment.MODULE_INFO)) {
+			PackageFragment pkg = (PackageFragment) getParent();
+			JarPackageFragmentRoot jarRoot = (JarPackageFragmentRoot) getPackageFragmentRoot();
+			String entryName = jarRoot.getClassFilePath(Util.concatWith(pkg.names, getElementName(), '/'));
 			byte[] contents = getClassFileContent(jarRoot, entryName);
 			if (contents != null) {
 				String fileName;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
index bce4558..077f548 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFileInfo.java
@@ -258,15 +258,18 @@ private void generateInnerClassHandles(IType type, IBinaryType typeInfo, ArrayLi
 		}
 	}
 }
-private void generateModuleInfos(ClassFile classFile, ClassFileReader info, HashMap newElements, ArrayList childrenHandles) {
-	IModule modDecl = info.getModuleDeclaration();
+private void generateModuleInfos(ClassFile classFile, IBinaryType info, HashMap newElements, ArrayList childrenHandles) {
+	// TODO: The following needs fix once we can get ModuleDeclaration from IndexBinaryType
+	IModule modDecl = (info instanceof ClassFileReader) ? ((ClassFileReader) info).getModuleDeclaration() : null;
 	if (modDecl != null) {
 		char[] modName = modDecl.name();
 		BinaryModule handle = new BinaryModule(classFile, new String(modName));
 		ModuleDescriptionInfo moduleInfo = new ModuleDescriptionInfo();
 		moduleInfo.name = modName;
-		childrenHandles.add(handle);
-		// Rest of the construction goes here
+		// It is illegal to add module to ClassFile's children because
+		// we use ClassFile itself to store binary children of BinaryModule,
+		// which means module can't be part of its own children list.
+		// childrenHandles.add(handle); 
 		IPackageExport[] exportedPackages = modDecl.exports();
 		if (exportedPackages != null) {
 			for (IPackageExport iPackageExport : exportedPackages) {
@@ -296,7 +299,7 @@ private void generateModuleInfos(ClassFile classFile, ClassFileReader info, Hash
 		newElements.put(handle, moduleInfo);
 	}
 }
-private void generateServiceInfos(BinaryModule parentHandle, HashMap newElements, char[] serviceName, char[][] implNames, ArrayList requiresHandles) {
+private void generateServiceInfos(BinaryModule parentHandle, HashMap newElements, char[] serviceName, char[][] implNames, ArrayList childrenHandles) {
 	ServiceInfo info = new ServiceInfo();
 	info.serviceName = serviceName;
 	String[] implementations = new String[implNames.length];
@@ -308,8 +311,10 @@ private void generateServiceInfos(BinaryModule parentHandle, HashMap newElements
 	while (newElements.containsKey(service))
 		service.occurrenceCount++;
 	newElements.put(service, info);
+	childrenHandles.add(service);
+	
 }
-private void generateModuleRequirementInfos(BinaryModule parentHandle, HashMap newElements, char[] moduleName, int modifiers, ArrayList requiresHandles) {
+private void generateModuleRequirementInfos(BinaryModule parentHandle, HashMap newElements, char[] moduleName, int modifiers, ArrayList childrenHandles) {
 	ModuleRequirement requirement = new ModuleRequirement(parentHandle, new String(moduleName));
 	ModuleReferenceInfo info = new ModuleReferenceInfo();
 	info.name = moduleName;
@@ -317,8 +322,9 @@ private void generateModuleRequirementInfos(BinaryModule parentHandle, HashMap n
 	while (newElements.containsKey(requirement))
 		requirement.occurrenceCount++;
 	newElements.put(requirement, info);
+	childrenHandles.add(requirement);
 }
-private void generatePackageExportInfos(BinaryModule parentHandle, HashMap newElements, char[] pkgName, char[][] target, ArrayList requiresHandles) {
+private void generatePackageExportInfos(BinaryModule parentHandle, HashMap newElements, char[] pkgName, char[][] target, ArrayList childrenHandles) {
 	PackageExport exportStmt = new PackageExport(parentHandle, new String(pkgName));
 	ModuleDescriptionInfo.PackageExportInfo info = new ModuleDescriptionInfo.PackageExportInfo();
 	info.pack = pkgName;
@@ -326,8 +332,9 @@ private void generatePackageExportInfos(BinaryModule parentHandle, HashMap newEl
 	while (newElements.containsKey(exportStmt))
 		exportStmt.occurrenceCount++;
 	newElements.put(exportStmt, info);
+	childrenHandles.add(exportStmt);
 }
-private void generatOpensInfos(BinaryModule parentHandle, HashMap newElements, char[] pkgName, char[][] target, ArrayList requiresHandles) {
+private void generatOpensInfos(BinaryModule parentHandle, HashMap newElements, char[] pkgName, char[][] target, ArrayList childrenHandles) {
 	OpenPackageStatement openStmt = new OpenPackageStatement(parentHandle, new String(pkgName));
 	ModuleDescriptionInfo.PackageExportInfo info = new ModuleDescriptionInfo.PackageExportInfo();
 	info.pack = pkgName;
@@ -335,6 +342,7 @@ private void generatOpensInfos(BinaryModule parentHandle, HashMap newElements, c
 	while (newElements.containsKey(openStmt))
 		openStmt.occurrenceCount++;
 	newElements.put(openStmt, info);
+	childrenHandles.add(openStmt);
 }
 /**
  * Creates the handles and infos for the methods of the given binary type.
@@ -517,7 +525,7 @@ protected void readBinaryChildren(ClassFile classFile, HashMap newElements, IBin
 		generateMethodInfos(type, typeInfo, newElements, childrenHandles, typeParameterHandles);
 		generateInnerClassHandles(type, typeInfo, childrenHandles); // Note inner class are separate openables that are not opened here: no need to pass in newElements
 		if (TypeDeclaration.kind(typeInfo.getModifiers()) == TypeDeclaration.MODULE_DECL) {
-			generateModuleInfos(classFile, ((ClassFileReader) typeInfo), newElements, childrenHandles);
+			generateModuleInfos(classFile, typeInfo, newElements, childrenHandles);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JModPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JModPackageFragmentRoot.java
new file mode 100644
index 0000000..26d1609
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JModPackageFragmentRoot.java
@@ -0,0 +1,67 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.core.builder.ClasspathJMod;
+import org.eclipse.jdt.internal.core.util.HashtableOfArrayToObject;
+
+/**
+ * A package fragment root that corresponds to a JMod file.
+ *
+ * <p>NOTE: The only visible entries from a Jmod package fragment root
+ * are .class files. The sub folder "classes" where the .class files are nested under
+ * is hidden from clients. THe package fragments appear to be directly under the 
+ * package fragment roots.
+ * <p>NOTE: A JMod package fragment root may or may not have an associated resource.
+ *
+ * @see org.eclipse.jdt.core.IPackageFragmentRoot
+ * @see org.eclipse.jdt.internal.core.JarPackageFragmentRootInfo
+ */
+public class JModPackageFragmentRoot extends JarPackageFragmentRoot {
+
+	/**
+	 * Constructs a package fragment root which is the root of the Java package directory hierarchy
+	 * based on a JMOD file that is not contained in a <code>IJavaProject</code> and
+	 * does not have an associated <code>IResource</code>.
+	 */
+	protected JModPackageFragmentRoot(IPath externalPath, JavaProject project) {
+		super(externalPath, project);
+	}
+	/**
+	 * Constructs a package fragment root which is the root of the Java package directory hierarchy
+	 * based on a JMOD file.
+	 */
+	protected JModPackageFragmentRoot(IResource resource, JavaProject project) {
+		super(resource, project);
+	}
+
+	/**
+	 * @see PackageFragmentRoot#getClassFilePath(String)
+	 */
+	public String getClassFilePath(String entryName) {
+		char[] name = CharOperation.append(ClasspathJMod.CLASSES_FOLDER, entryName.toCharArray());
+		return new String(name);
+	}
+	protected void initRawPackageInfo(HashtableOfArrayToObject rawPackageInfo, String entryName, boolean isDirectory, String compliance) {
+		char[] name = entryName.toCharArray();
+		if (CharOperation.prefixEquals(ClasspathJMod.CLASSES_FOLDER, name)) {
+			name = CharOperation.subarray(name, ClasspathJMod.CLASSES_FOLDER.length, name.length);
+		}
+		super.initRawPackageInfo(rawPackageInfo, new String(name), isDirectory, compliance);
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
index e970f65..881fdd4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModel.java
@@ -31,6 +31,7 @@ import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Path;
 import org.eclipse.jdt.core.*;
+import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.util.MementoTokenizer;
 import org.eclipse.jdt.internal.core.util.Messages;
 
@@ -368,6 +369,13 @@ public static boolean isFile(Object target) {
 public static boolean isJimage(File file) {
 	return JavaModelManager.isJrt(file.getPath());
 }
+public static boolean isJmod(File file) {
+	IPath path = Path.fromOSString(file.getPath());
+	if (path.getFileExtension().equalsIgnoreCase(SuffixConstants.EXTENSION_jmod)) {
+		return true;
+	}
+	return false;
+}
 
 /**
  * Returns whether the provided path is an external file, checking and updating the
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
index 7614524..3fe2dba 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
@@ -651,7 +651,10 @@ public class JavaProject
 							} else {
 								accumulatedRoots.addAll(info.jrtRoots.get(entryPath));
 							}
-						} else {
+						} else if (JavaModel.isJmod((File) target)) {
+							root = new JModPackageFragmentRoot(entryPath, this);
+						}
+						else {
 							root = new JarPackageFragmentRoot(entryPath, this);
 						}
 					} else if (((File) target).isDirectory()) {
@@ -1942,6 +1945,12 @@ public class JavaProject
 		if (JavaModelManager.isJrt(externalLibraryPath)) {
 			return this.new JImageModuleFragmentBridge(externalLibraryPath);
 		}
+		Object target = JavaModel.getTarget(externalLibraryPath, true/*check existency*/);
+		if (target instanceof File && JavaModel.isFile(target)) {
+			if (JavaModel.isJmod((File) target)) {
+				return new JModPackageFragmentRoot(externalLibraryPath, this);
+			}
+		}
 		return new JarPackageFragmentRoot(externalLibraryPath, this);
 	}
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index 40b91ca..f64a590 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -841,6 +841,18 @@ protected void verifyAttachSource(IPath sourcePath) throws JavaModelException {
 		throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, sourcePath));
 	}
 }
+/**
+ * Returns the relative path within an archive for the given class file name. In certain
+ * kind of archives, such as a JMOD file, class files are stored in a nested folder, as opposed
+ * to directly under the root. It is the responsibility of such package fragment roots to
+ * provide the custom behavior.
+ *
+ * @param classname
+ * @return the relative path for the class file within the archive
+ */
+public String getClassFilePath(String classname) {
+	return classname;
+}
 public IModuleDescription getModuleDescription() {
 	try {
 		IJavaElement[] pkgs = getChildren();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
index 51dab52..5de8cf9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
@@ -30,7 +30,6 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationDecorator;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
-import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
@@ -39,7 +38,8 @@ import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class ClasspathJMod extends ClasspathJar {
 
-	private static char[] CLASSES = "classes".toCharArray(); //$NON-NLS-1$
+	public static char[] CLASSES = "classes".toCharArray(); //$NON-NLS-1$
+	public static char[] CLASSES_FOLDER = "classes/".toCharArray(); //$NON-NLS-1$
 	private static int MODULE_DESCRIPTOR_NAME_LENGTH = MODULE_INFO_CLASS.length();
 
 	ClasspathJMod(String zipFilename, long lastModified, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env) {
@@ -47,11 +47,12 @@ public class ClasspathJMod extends ClasspathJar {
 	}
 
 
-	public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String qualifiedBinaryFileName, IModule mod) {
+	public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String qualifiedBinaryFileName, boolean asBinaryOnly) {
 		// TOOD: BETA_JAVA9 - Should really check for packages with the module context
 		if (!isPackage(qualifiedPackageName)) return null; // most common case
 
 		try {
+			qualifiedBinaryFileName = new String(CharOperation.append(CLASSES_FOLDER, qualifiedBinaryFileName.toCharArray()));
 			IBinaryType reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
 			if (reader != null) {
 				if (reader instanceof ClassFileReader) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
index 52824fd..276b14f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
@@ -219,8 +219,7 @@ private NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedP
 					// don't let error on annotations fail class reading
 				}
 			}
-			char[] modName = reader.getModule() == null ? null : reader.getModule().name();
-			return new NameEnvironmentAnswer(reader, null, modName);
+			return new NameEnvironmentAnswer(reader, null, reader.getModule());
 		}
 	} catch (IOException e) { // treat as if class file is missing
 	} catch (ClassFormatException e) { // treat as if class file is missing
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
index f4ca97c..d3ae218 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
@@ -58,7 +58,10 @@ static ClasspathLocation forLibrary(String libraryPathname,
 										boolean autoModule) {
 	return Util.isJrt(libraryPathname) ?
 			new ClasspathJrt(libraryPathname, annotationsPath, env) :
-			new ClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath, env, autoModule);
+				Util.archiveFormat(libraryPathname) == Util.JMOD_FILE ?
+					new ClasspathJMod(libraryPathname, lastModified, accessRuleSet, annotationsPath, env) :
+			new ClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath, env, false);
+
 }
 
 public static ClasspathLocation forLibrary(String libraryPathname, AccessRuleSet accessRuleSet, IPath annotationsPath,
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
index b2331ea..a6d173c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
@@ -28,7 +28,6 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
-import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
@@ -306,7 +305,7 @@ public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWal
 	return walker;
 }
 @Override
-public IModule getModule() {
+public char[] getModule() {
 	// TODO BETA_JAVA9 Auto-generated method stub
 	return null;
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
index f46fd1f..61e2990 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/BinaryTypeFactory.java
@@ -25,7 +25,6 @@ import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.Path;
 import org.eclipse.jdt.core.IClassFile;
-import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaModelStatusConstants;
 import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.JavaModelException;
@@ -38,6 +37,7 @@ import org.eclipse.jdt.internal.core.ClassFile;
 import org.eclipse.jdt.internal.core.JarPackageFragmentRoot;
 import org.eclipse.jdt.internal.core.JavaModelManager;
 import org.eclipse.jdt.internal.core.PackageFragment;
+import org.eclipse.jdt.internal.core.PackageFragmentRoot;
 import org.eclipse.jdt.internal.core.nd.IReader;
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.IndexException;
@@ -64,19 +64,20 @@ public class BinaryTypeFactory {
 	 */
 	private static BinaryTypeDescriptor createDescriptor(PackageFragment pkg, ClassFile classFile) {
 		String name = classFile.getName();
-		IJavaElement root = pkg.getParent();
+		PackageFragmentRoot root = (PackageFragmentRoot) pkg.getParent();
 		IPath location = JavaIndex.getLocationForElement(root);
+		if (location == null) {
+			return null;
+		}
+		name = root.getClassFilePath(Util.concatWith(pkg.names, name, '/'));
 		String entryName = Util.concatWith(pkg.names, classFile.getElementName(), '/');
 		char[] fieldDescriptor = CharArrayUtils.concat(new char[] { 'L' },
-				Util.concatWith(pkg.names, name, '/').toCharArray(), new char[] { ';' });
+				name.toCharArray(), new char[] { ';' });
 		IPath workspacePath = root.getPath();
 		String indexPath;
 
-		if (location == null) {
-			return null;
-		}
-
 		if (root instanceof JarPackageFragmentRoot) {
+			entryName = ((JarPackageFragmentRoot) root).getClassFilePath(entryName);
 			// The old version returned this, but it doesn't conform to the spec on IBinaryType.getFileName():
 			indexPath = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
 			// Version that conforms to the JavaDoc spec on IBinaryType.getFileName() -- note that this breaks
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index 4262165..bd17859 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -26,7 +26,6 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
-import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
@@ -672,7 +671,7 @@ public class IndexBinaryType implements IBinaryType {
 	}
 
 	@Override
-	public IModule getModule() {
+	public char[] getModule() {
 		// TODO Auto-generated method stub
 		return null;
 	}
