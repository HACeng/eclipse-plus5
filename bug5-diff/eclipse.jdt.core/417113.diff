commit dfa40837336948a1f985e74dddef96333913f44c
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sun Sep 29 16:30:55 2013 +0530

    [1.8] Follow ups to Bug 417113 - [1.8][compiler] Encoding of type
    annotations in compiler bindings.
    
    Signed-off-by: ssankaran <srikanth_sankaran@in.ibm.com>

5	18	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
75	25	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotationBinding.java
11	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
32	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
59	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
34	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnannotatedTypeSystem.java
9	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedAnnotationBinding.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
index 1b7b52e..e77920b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
@@ -16,7 +16,6 @@ package org.eclipse.jdt.internal.compiler.classfmt;
 
 import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
-import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
 
 /**
@@ -36,12 +35,13 @@ public class TypeAnnotationWalker {
 	 * At the end of any walk an empty array of annotations is returned.
 	 */
 	public static final TypeAnnotationWalker EMPTY_ANNOTATION_WALKER = new TypeAnnotationWalker(new IBinaryTypeAnnotation[0], 0L) {
+		public TypeAnnotationWalker toField() { return this; }
 		public TypeAnnotationWalker toTarget(int targetType) { return this; }
 		public TypeAnnotationWalker toThrows(int rank) { return this; }
 		public TypeAnnotationWalker toTypeArgument(int rank) { return this; }
 		public TypeAnnotationWalker toMethodParameter(short index) { return this; }
 		public TypeAnnotationWalker toSupertype(short index) { return this; }
-		public TypeAnnotationWalker toTypeBarameterBounds(boolean isClassTypeParameter, int parameterRank) { return this; }
+		public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) { return this; }
 		public TypeAnnotationWalker toTypeBound(short boundIndex) { return this; }
 		public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) { return this; }
 		public TypeAnnotationWalker toNextDetail(int detailKind) { return this; }
@@ -53,7 +53,7 @@ public class TypeAnnotationWalker {
 	final private int pathPtr;							// pointer into the typePath
 
 	// precondition: not-empty typeAnnotations
-	private TypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations) {
+	public TypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations) {
 		this(typeAnnotations, -1L >>> (64-typeAnnotations.length)); // initialize so lowest length bits are 1
 	}
 	TypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations, long matchBits) {
@@ -72,19 +72,6 @@ public class TypeAnnotationWalker {
 		return new TypeAnnotationWalker(this.typeAnnotations, newMatches, newPathPtr);
 	}
 
-	/** Answer a walker for the given type annotations initialized to the root of the tree. */
-	public static TypeAnnotationWalker create(IBinaryTypeAnnotation[] typeAnnotations) {
-		if (typeAnnotations == null || typeAnnotations.length == 0)
-			return EMPTY_ANNOTATION_WALKER;
-		return new TypeAnnotationWalker(typeAnnotations);
-	}
-	/** Answer a walker for the type annotations of the given method initialized to the root of the tree. */
-	public static TypeAnnotationWalker create(IBinaryMethod method) {
-		if (method instanceof MethodInfoWithAnnotations)
-			return create(((MethodInfoWithAnnotations) method).getTypeAnnotations());
-		return EMPTY_ANNOTATION_WALKER;
-	}
-	
 	// ==== filter by top-level targetType: ====
 	
 	/** Walk to a field. */
@@ -146,7 +133,7 @@ public class TypeAnnotationWalker {
 	 * @param isClassTypeParameter whether we are looking at a class type parameter (else: method type type parameter)
 	 * @param parameterRank rank of the type parameter.
 	 */
-	public TypeAnnotationWalker toTypeBarameterBounds(boolean isClassTypeParameter, int parameterRank) {
+	public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -162,7 +149,7 @@ public class TypeAnnotationWalker {
 		return restrict(newMatches, 0);	
 	}
 	/**
-	 * Detail of {@link #toTypeBarameterBounds(boolean, int)}: walk to the bounds
+	 * Detail of {@link #toTypeParameterBounds(boolean, int)}: walk to the bounds
 	 * of the previously selected type parameter. 
 	 * @param boundIndex
 	 */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 411ad1c..74c2960 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -1639,6 +1639,7 @@ public class CompilerOptions {
 			this.isAnnotationBasedNullAnalysisEnabled = ENABLED.equals(optionValue);
 		}
 		if (this.isAnnotationBasedNullAnalysisEnabled) {
+			this.storeAnnotations = true;
 			if ((optionValue = optionsMap.get(OPTION_ReportNullSpecViolation)) != null) {
 				if (ERROR.equals(optionValue)) {
 					this.errorThreshold.set(NullSpecViolation);
@@ -1779,7 +1780,8 @@ public class CompilerOptions {
 				this.storeAnnotations = true; // annotation processing requires annotation to be stored
 			} else if (DISABLED.equals(optionValue)) {
 				this.processAnnotations = false;
-				this.storeAnnotations = false;
+				if (!this.isAnnotationBasedNullAnalysisEnabled)
+					this.storeAnnotations = false;
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
index a9204ad..bec0c7c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
@@ -28,7 +28,7 @@ import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
  	
    We do not keep track of unannotated types here, that is done by UTS whose handle we maintain.
 */
-public class AnnotatableTypeSystem {
+public class AnnotatableTypeSystem extends TypeSystem {
 
 	LookupEnvironment environment;
 	UnannotatedTypeSystem unannotatedTypeSystem;
@@ -45,39 +45,50 @@ public class AnnotatableTypeSystem {
 		return this.unannotatedTypeSystem.getUnannotatedType(type);
 	}
 	
+	public ArrayBinding getArrayType(TypeBinding leaftType, int dimensions) {
+		return getArrayType(leaftType, dimensions, Binding.NO_ANNOTATIONS);
+	}
+
 	/* This method replaces the version that used to sit in LE. The parameter `annotations' is a flattened sequence of annotations, 
 	   where each dimension's annotations end with a sentinel null.
 	*/
-	public ArrayBinding getArrayType(TypeBinding leafType, int dimensions, AnnotationBinding [] annotations) {
+	public ArrayBinding getArrayType(TypeBinding leafComponentType, int dimensions, AnnotationBinding [] annotations) {
 		
-		if (!haveTypeAnnotations(leafType, annotations))
-			return this.unannotatedTypeSystem.getArrayType(leafType, dimensions);
+		if (!haveTypeAnnotations(leafComponentType, annotations))
+			return this.unannotatedTypeSystem.getArrayType(leafComponentType, dimensions);
 		
-		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(leafType);
+		//  Leaf component type can be an annotated type.
+		TypeBinding keyType = getUnannotatedType(leafComponentType);
+		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(keyType);  // unannotated key promotes better instance sharing.
 		int index = 0;
 		if (cachedInfo != null) {
 			for (int max = cachedInfo.length; index < max; index++) {
 				TypeBinding cachedType = cachedInfo[index];
 				if (cachedType == null) break;
+				if (cachedType.leafComponentType() != leafComponentType) continue;
 				if (cachedType.isArrayType() && cachedType.dimensions() == dimensions && Util.effectivelyEqual(cachedType.getTypeAnnotations(), annotations)) 
 					return (ArrayBinding) cachedType;
 			}
 		} else {
-			this.annotatedTypes.put(leafType, cachedInfo = new TypeBinding[4]);
+			this.annotatedTypes.put(keyType, cachedInfo = new TypeBinding[4]);
 		}
 		
 		int length = cachedInfo.length;
 		if (index == length) {
 			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
-			this.annotatedTypes.put(leafType, cachedInfo);
+			this.annotatedTypes.put(keyType, cachedInfo);
 		}
 		// Add the newcomer, ensuring its identity is the same as the naked version of it.
-		ArrayBinding unannotatedArrayType = this.unannotatedTypeSystem.getArrayType(leafType, dimensions);
-		TypeBinding arrayBinding = new ArrayBinding(leafType, dimensions, this.environment);
+		ArrayBinding unannotatedArrayType = this.unannotatedTypeSystem.getArrayType(leafComponentType, dimensions);
+		TypeBinding arrayBinding = new ArrayBinding(leafComponentType, dimensions, this.environment);
 		arrayBinding.id = unannotatedArrayType.id;
 		arrayBinding.setTypeAnnotations(annotations, this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled);
 		return (ArrayBinding) (cachedInfo[index] = arrayBinding);
 	}
+	
+	public ParameterizedTypeBinding getParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, ReferenceBinding enclosingType) {
+		return getParameterizedType(genericType, typeArguments, enclosingType, Binding.NO_ANNOTATIONS);
+	}
 
 	public ParameterizedTypeBinding getParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, ReferenceBinding enclosingType, AnnotationBinding [] annotations) {
 		
@@ -88,7 +99,7 @@ public class AnnotatableTypeSystem {
 		   really belong to the parameterized type that is being created just now. e.g @T List<String> => comes in as (@T List)<String>. The question really 
 		   is List being parameterized by String and then the resultant type is annotated or is "@T List" being parameterized with String ? We don't care one
 		   way or other except that we would want a uniform treatment. As a stop gap, we "repair" the situation here, so it is consistent with treatment of 
-		   type references in source code. Probably need similar treatment for raw types and wildcards ?
+		   type references in source code.
 		*/
 		AnnotationBinding [] misplacedAnnotations = genericType.getTypeAnnotations();
 		if (misplacedAnnotations != null && misplacedAnnotations != Binding.NO_ANNOTATIONS) {
@@ -97,9 +108,11 @@ public class AnnotatableTypeSystem {
 			annotations = misplacedAnnotations;
 			genericType = (ReferenceBinding) this.unannotatedTypeSystem.getUnannotatedType(genericType);
 		}
-			
+		// generic type is expected to come in unannotated, if it came in with any misattributed annotations, they have been duly re-attributed and it is unannotated now.	
+		
 		int index = 0;
-		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(genericType);
+		TypeBinding keyType = getUnannotatedType(genericType);
+		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(keyType); // promotes better instance sharing
 		if (cachedInfo != null) {
 			for (int max = cachedInfo.length; index < max; index++){
 				TypeBinding cachedType = cachedInfo[index];
@@ -111,12 +124,12 @@ public class AnnotatableTypeSystem {
 					return (ParameterizedTypeBinding) cachedType;
 			}
 		} else {
-			this.annotatedTypes.put(genericType, cachedInfo = new TypeBinding[4]);
+			this.annotatedTypes.put(keyType, cachedInfo = new TypeBinding[4]);
 		}
 		int length = cachedInfo.length;
 		if (index == length) {
 			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
-			this.annotatedTypes.put(genericType, cachedInfo);
+			this.annotatedTypes.put(keyType, cachedInfo);
 		}
 		// Add the new comer, retaining the same type binding id as the naked type.
 		ParameterizedTypeBinding unannotatedParameterizedType = this.unannotatedTypeSystem.getParameterizedType(genericType, typeArguments, enclosingType);
@@ -126,12 +139,27 @@ public class AnnotatableTypeSystem {
 		return (ParameterizedTypeBinding) (cachedInfo[index] = parameterizedType);
 	}
 	
+	public RawTypeBinding getRawType(ReferenceBinding genericType, ReferenceBinding enclosingType) {
+		return getRawType(genericType, enclosingType, Binding.NO_ANNOTATIONS);
+	}
+	
 	public RawTypeBinding getRawType(ReferenceBinding genericType, ReferenceBinding enclosingType, AnnotationBinding [] annotations) {
 		
 		if (!haveTypeAnnotations(genericType, enclosingType, null, annotations))
 			return this.unannotatedTypeSystem.getRawType(genericType, enclosingType);
 		
-		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(genericType);
+		// See explanation on misplaced annotations in getParameterizedType.
+		AnnotationBinding [] misplacedAnnotations = genericType.getTypeAnnotations();
+		if (misplacedAnnotations != null && misplacedAnnotations != Binding.NO_ANNOTATIONS) {
+			if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
+				throw new IllegalStateException(); // cannot cut both ways.
+			annotations = misplacedAnnotations;
+			genericType = (ReferenceBinding) this.unannotatedTypeSystem.getUnannotatedType(genericType);
+		}
+		// generic type is expected to come in unannotated, if it came in with any misattributed annotations, they have been duly re-attributed and it is unannotated now.	
+		
+		TypeBinding keyType = getUnannotatedType(genericType);
+		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(keyType);
 		int index = 0;
 		if (cachedInfo != null) {
 			for (int max = cachedInfo.length; index < max; index++) {
@@ -142,13 +170,13 @@ public class AnnotatableTypeSystem {
 					return (RawTypeBinding) cachedType;
 			}
 		} else {
-			this.annotatedTypes.put(genericType, cachedInfo = new TypeBinding[4]);
+			this.annotatedTypes.put(keyType, cachedInfo = new TypeBinding[4]);
 		}
 		
 		int length = cachedInfo.length;
 		if (index == length) {
 			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
-			this.annotatedTypes.put(genericType, cachedInfo);
+			this.annotatedTypes.put(keyType, cachedInfo);
 		}
 		// Add the new comer, retaining the same type binding id as the naked type.
 		RawTypeBinding unannotatedRawType = this.unannotatedTypeSystem.getRawType(genericType, enclosingType);
@@ -158,6 +186,10 @@ public class AnnotatableTypeSystem {
 		return (RawTypeBinding) (cachedInfo[index] = rawType);
 	}
 		
+	public WildcardBinding getWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind) {
+		return getWildcard(genericType, rank, bound, otherBounds, boundKind, Binding.NO_ANNOTATIONS);
+	}
+
 	public WildcardBinding getWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind, AnnotationBinding [] annotations) {
 		
 		if (!haveTypeAnnotations(genericType, bound, otherBounds, annotations))
@@ -166,7 +198,18 @@ public class AnnotatableTypeSystem {
 		if (genericType == null) // pseudo wildcard denoting composite bounds for lub computation
 			genericType = ReferenceBinding.LUB_GENERIC;
 
-		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(genericType);
+		// See explanation on misplaced annotations in getParameterizedType.
+		AnnotationBinding [] misplacedAnnotations = genericType.getTypeAnnotations();
+		if (misplacedAnnotations != null && misplacedAnnotations != Binding.NO_ANNOTATIONS) {
+			if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
+				throw new IllegalStateException(); // cannot cut both ways.
+			annotations = misplacedAnnotations;
+			genericType = (ReferenceBinding) this.unannotatedTypeSystem.getUnannotatedType(genericType);
+		}
+		// generic type is expected to come in unannotated, if it came in with any misattributed annotations, they have been duly re-attributed and it is unannotated now.	
+		
+		TypeBinding keyType = getUnannotatedType(genericType);		
+		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(keyType);  // promotes better instance sharing.
 		int index = 0;
 		if (cachedInfo != null) {
 			for (int max = cachedInfo.length; index < max; index++) {
@@ -181,13 +224,13 @@ public class AnnotatableTypeSystem {
 					return (WildcardBinding) cachedType;
 			}
 		} else {
-			this.annotatedTypes.put(genericType, cachedInfo = new TypeBinding[4]);
+			this.annotatedTypes.put(keyType, cachedInfo = new TypeBinding[4]);
 		}
 
 		int length = cachedInfo.length;
 		if (index == length) {
 			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
-			this.annotatedTypes.put(genericType, cachedInfo);
+			this.annotatedTypes.put(keyType, cachedInfo);
 		}
 		// Add the new comer, retaining the same type binding id as the naked type.
 		TypeBinding unannotatedWildcard = this.unannotatedTypeSystem.getWildcard(genericType, rank, bound, otherBounds, boundKind);
@@ -199,7 +242,8 @@ public class AnnotatableTypeSystem {
 
 	// Private subroutine for getAnnotatedType(TypeBinding type, AnnotationBinding[][] annotations)
 	private TypeBinding getAnnotatedType(TypeBinding type, TypeBinding enclosingType, TypeBinding [] typeArguments, AnnotationBinding[] annotations) {
-		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(type);
+		TypeBinding keyType = getUnannotatedType(type);
+		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(keyType);
 		int i = 0;
 		if (cachedInfo != null) {
 			for (int length = cachedInfo.length; i < length; i++) {
@@ -212,12 +256,12 @@ public class AnnotatableTypeSystem {
 				}
 			}
 		} else {
-			this.annotatedTypes.put(type, cachedInfo = new TypeBinding[4]);
+			this.annotatedTypes.put(keyType, cachedInfo = new TypeBinding[4]);
 		}
 		int length = cachedInfo.length;
 		if (i == length) {
 			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
-			this.annotatedTypes.put(type, cachedInfo);
+			this.annotatedTypes.put(keyType, cachedInfo);
 		}
 		/* Add the new comer, retaining the same type binding id as the naked type. To materialize the new comer we can't use new since this is a general
 		   purpose method designed to deal type bindings of all types. "Clone" the incoming type, specializing for any enclosing type and type arguments
@@ -282,12 +326,14 @@ public class AnnotatableTypeSystem {
 					enclosingType = annotatedType;
 				}
 				break;
+			default:
+				throw new IllegalStateException();
 		}
 		return annotatedType;
 	}
 
-	public AnnotationBinding getAnnotationType(ReferenceBinding annotationType) {
-		return this.unannotatedTypeSystem.getAnnotationType(annotationType); // deflect, annotation type uses cannot be type annotated.
+	public AnnotationBinding getAnnotationType(ReferenceBinding annotationType, boolean requireResolved) {
+		return this.unannotatedTypeSystem.getAnnotationType(annotationType, requireResolved); // deflect, annotation type uses cannot be type annotated.
 	}
 
 	private boolean haveTypeAnnotations(TypeBinding baseType, TypeBinding someType, TypeBinding[] someTypes, AnnotationBinding[] annotations) {
@@ -357,4 +403,8 @@ public class AnnotatableTypeSystem {
 		}
 		this.unannotatedTypeSystem.updateCaches(unresolvedType.prototype, unresolvedType.prototype.resolvedType);
 	}
+	
+	public boolean isAnnotatedTypeSystem() {
+		return true;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotationBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotationBinding.java
index 038c5ad..e9f1d86 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotationBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotationBinding.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -195,6 +199,10 @@ public ReferenceBinding getAnnotationType() {
 	return this.type;
 }
 
+public void resolve() {
+	// Nothing to do, this is already resolved.
+}
+
 public ElementValuePair[] getElementValuePairs() {
 	return this.pairs;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index be49ec7..b6f2381 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -366,7 +366,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 		   and/or super interfaces in order to be able to detect overriding in the presence
 		   of generics.
 		 */
-		TypeAnnotationWalker walker = sourceLevel >= ClassFileConstants.JDK1_8 ? TypeAnnotationWalker.create(binaryType.getTypeAnnotations()) : TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		TypeAnnotationWalker walker = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
 		char[] typeSignature = binaryType.getGenericSignature(); // use generic signature even in 1.4
 		this.tagBits |= binaryType.getTagBits();
 		
@@ -479,6 +479,13 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 	}
 }
 
+private TypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] annotations) {
+	if (annotations == null || annotations.length == 0)
+		return TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+	
+	return this.environment.usesAnnotatedTypeSystem() ? new TypeAnnotationWalker(annotations) : TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+}
+
 private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] missingTypeNames) {
 	this.fields = Binding.NO_FIELDS;
 	if (iFields != null) {
@@ -486,13 +493,12 @@ private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] m
 		if (size > 0) {
 			this.fields = new FieldBinding[size];
 			boolean use15specifics = sourceLevel >= ClassFileConstants.JDK1_5;
-			boolean use18specifics = sourceLevel >= ClassFileConstants.JDK1_8;
 			boolean hasRestrictedAccess = hasRestrictedAccess();
 			int firstAnnotatedFieldIndex = -1;
 			for (int i = 0; i < size; i++) {
 				IBinaryField binaryField = iFields[i];
 				char[] fieldSignature = use15specifics ? binaryField.getGenericSignature() : null;
-				TypeAnnotationWalker walker = use18specifics ? TypeAnnotationWalker.create(binaryField.getTypeAnnotations()).toField() : TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+				TypeAnnotationWalker walker = getTypeAnnotationWalker(binaryField.getTypeAnnotations()).toField();
 				TypeBinding type = fieldSignature == null
 					? this.environment.getTypeFromSignature(binaryField.getTypeName(), 0, -1, false, this, missingTypeNames, walker)
 					: this.environment.getTypeFromTypeSignature(new SignatureWrapper(fieldSignature), Binding.NO_TYPE_VARIABLES, this, missingTypeNames, walker);
@@ -553,7 +559,7 @@ private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[
 	   variables properly in order to be able to apply substitutions and thus be able to detect
 	   overriding in the presence of generics. Seeing the erased form is not good enough.
 	 */
-	TypeAnnotationWalker walker = sourceLevel >= ClassFileConstants.JDK1_8  ? TypeAnnotationWalker.create(method) : TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+	TypeAnnotationWalker walker = getTypeAnnotationWalker(method.getTypeAnnotations());
 	char[] methodSignature = method.getGenericSignature(); // always use generic signature, even in 1.4
 	if (methodSignature == null) { // no generics
 		char[] methodDescriptor = method.getMethodDescriptor();   // of the form (I[Ljava/jang/String;)V
@@ -821,7 +827,7 @@ private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, bool
 	if (assignVariables)
 		this.typeVariables = result;
 	for (int i = 0; i < rank; i++) {
-		initializeTypeVariable(result[i], result, wrapper, missingTypeNames, walker.toTypeBarameterBounds(isClassTypeParameter, i));
+		initializeTypeVariable(result[i], result, wrapper, missingTypeNames, walker.toTypeParameterBounds(isClassTypeParameter, i));
 	}
 	return result;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 585d623..e7d38f4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -61,7 +61,7 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 	private int lastCompletedUnitIndex = -1;
 	private int lastUnitIndex = -1;
 
-	private AnnotatableTypeSystem typeSystem;
+	private TypeSystem typeSystem;
 	
 	public INameEnvironment nameEnvironment;
 	public CompilerOptions globalOptions;
@@ -125,7 +125,12 @@ public LookupEnvironment(ITypeRequestor typeRequestor, CompilerOptions globalOpt
 	this.accessRestrictions = new HashMap(3);
 	this.classFilePool = ClassFilePool.newInstance();
 	this.typesBeingConnected = new HashSet();
-	this.typeSystem = new AnnotatableTypeSystem(this);
+	boolean stillTesting = true;
+	if (this.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8 && (stillTesting || this.globalOptions.storeAnnotations)) {
+		this.typeSystem = new AnnotatableTypeSystem(this);
+	} else {
+		this.typeSystem = new UnannotatedTypeSystem(this);
+	}
 }
 
 /**
@@ -636,22 +641,32 @@ public TypeBinding convertUnresolvedBinaryToRawType(TypeBinding type) {
 	}
 	return type;
 }
-/*
- *  Used to guarantee annotation identity: we do that only for marker annotations. We don't have the machinery for the general case as of now.
- */
+/* Used to guarantee annotation identity: we do that only for marker annotations and others with all default values.
+   We don't have the machinery for the general case as of now.
+*/
 public AnnotationBinding createAnnotation(ReferenceBinding annotationType, ElementValuePair[] pairs) {
 	if (pairs.length != 0) {
 		AnnotationBinding.setMethodBindings(annotationType, pairs);
 		return new AnnotationBinding(annotationType, pairs);
 	}
-	return this.typeSystem.getAnnotationType(annotationType);
+	return this.typeSystem.getAnnotationType(annotationType, true);
+}
+
+/* Used to guarantee annotation identity: we do that only for marker annotations and others with all default values.
+   We don't have the machinery for the general case as of now.
+*/
+public AnnotationBinding createUnresolvedAnnotation(ReferenceBinding annotationType, ElementValuePair[] pairs) {
+	if (pairs.length != 0) {
+		return new UnresolvedAnnotationBinding(annotationType, pairs, this);
+	}
+	return this.typeSystem.getAnnotationType(annotationType, false);
 }
 
 /*
  *  Used to guarantee array type identity.
  */
 public ArrayBinding createArrayType(TypeBinding leafComponentType, int dimensionCount) {
-	return this.typeSystem.getArrayType(leafComponentType, dimensionCount, Binding.NO_ANNOTATIONS);
+	return this.typeSystem.getArrayType(leafComponentType, dimensionCount);
 }
 
 public ArrayBinding createArrayType(TypeBinding leafComponentType, int dimensionCount, AnnotationBinding [] annotations) {
@@ -907,6 +922,11 @@ public PolymorphicMethodBinding createPolymorphicMethod(MethodBinding originalPo
 	cachedInfo[index] = polymorphicMethod;
 	return polymorphicMethod;
 }
+
+public boolean usesAnnotatedTypeSystem() {
+	return this.typeSystem.isAnnotatedTypeSystem();
+}
+
 public MethodBinding updatePolymorphicMethodReturnType(PolymorphicMethodBinding binding, TypeBinding typeBinding) {
 	// update the return type to be the given return type, but reuse existing binding if one can match
 	String key = new String(binding.selector);
@@ -961,7 +981,7 @@ public ParameterizedMethodBinding createGetClassMethod(TypeBinding receiverType,
 }
 
 public ParameterizedTypeBinding createParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, ReferenceBinding enclosingType) {
-	return this.typeSystem.getParameterizedType(genericType, typeArguments, enclosingType, Binding.NO_ANNOTATIONS);
+	return this.typeSystem.getParameterizedType(genericType, typeArguments, enclosingType);
 }
 
 public ParameterizedTypeBinding createParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, ReferenceBinding enclosingType, AnnotationBinding [] annotations) {
@@ -990,7 +1010,7 @@ public TypeBinding createAnnotatedType(TypeBinding type, AnnotationBinding[] new
 }
 
 public RawTypeBinding createRawType(ReferenceBinding genericType, ReferenceBinding enclosingType) {
-	return this.typeSystem.getRawType(genericType, enclosingType, Binding.NO_ANNOTATIONS);
+	return this.typeSystem.getRawType(genericType, enclosingType);
 }
 
 public RawTypeBinding createRawType(ReferenceBinding genericType, ReferenceBinding enclosingType, AnnotationBinding [] annotations) {
@@ -998,7 +1018,7 @@ public RawTypeBinding createRawType(ReferenceBinding genericType, ReferenceBindi
 }
 
 public WildcardBinding createWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind) {
-	return this.typeSystem.getWildcard(genericType, rank, bound, otherBounds, boundKind, Binding.NO_ANNOTATIONS);
+	return this.typeSystem.getWildcard(genericType, rank, bound, otherBounds, boundKind);
 }
 
 public WildcardBinding createWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind, AnnotationBinding [] annotations) {
@@ -1038,7 +1058,7 @@ public AnnotationBinding getNullableAnnotation() {
 	if (this.nullableAnnotation != null)
 		return this.nullableAnnotation;
 	ReferenceBinding nullable = getResolvedType(this.globalOptions.nullableAnnotationName, null);
-	return this.nullableAnnotation = this.typeSystem.getAnnotationType(nullable);
+	return this.nullableAnnotation = this.typeSystem.getAnnotationType(nullable, true);
 }
 
 public char[][] getNullableAnnotationName() {
@@ -1049,7 +1069,7 @@ public AnnotationBinding getNonNullAnnotation() {
 	if (this.nonNullAnnotation != null) 
 		return this.nonNullAnnotation;
 	ReferenceBinding nonNull = getResolvedType(this.globalOptions.nonNullAnnotationName, null);
-	return this.nonNullAnnotation = this.typeSystem.getAnnotationType(nonNull);
+	return this.nonNullAnnotation = this.typeSystem.getAnnotationType(nonNull, true);
 }
 
 public AnnotationBinding[] nullAnnotationsFromTagBits(long nullTagBits) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 407baef..7d39089 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -2058,7 +2058,7 @@ SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 	if (forceInitialize && this.storedAnnotations == null && this.scope != null) { // scope null when no annotation cached, and type got processed fully (159631)
 		this.scope.referenceCompilationUnit().compilationResult.hasAnnotations = true;
 		final CompilerOptions globalOptions = this.scope.environment().globalOptions;
-		if (!globalOptions.storeAnnotations && !globalOptions.isAnnotationBasedNullAnalysisEnabled)
+		if (!globalOptions.storeAnnotations)
 			return null; // not supported during this compile
 		this.storedAnnotations = new SimpleLookupTable(3);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
new file mode 100644
index 0000000..142f5d0
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.lookup;
+
+public abstract class TypeSystem {
+	
+	public boolean isAnnotatedTypeSystem() {
+		return false;
+	}
+
+	public abstract AnnotationBinding getAnnotationType(ReferenceBinding annotationType, boolean requireResolved);
+	
+	public abstract ArrayBinding getArrayType(TypeBinding leafComponentType, int dimensions);
+	
+	public ArrayBinding getArrayType(TypeBinding leafComponentType, int dimensions, AnnotationBinding[] annotations) {
+		return getArrayType(leafComponentType, dimensions);
+	}
+
+	public abstract ParameterizedTypeBinding getParameterizedType (ReferenceBinding genericType, TypeBinding[] typeArguments, ReferenceBinding enclosingType);
+	
+	public ParameterizedTypeBinding getParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, ReferenceBinding enclosingType, AnnotationBinding[] annotations) {
+		return getParameterizedType(genericType, typeArguments, enclosingType);
+	}
+
+	public abstract RawTypeBinding getRawType(ReferenceBinding genericType, ReferenceBinding enclosingType);
+	
+	public RawTypeBinding getRawType(ReferenceBinding genericType, ReferenceBinding enclosingType, AnnotationBinding[] annotations) {
+		return getRawType(genericType, enclosingType);
+	}
+
+	public abstract WildcardBinding getWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind);
+	
+	public WildcardBinding getWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind, AnnotationBinding[] annotations) {
+		return getWildcard(genericType, rank, bound, otherBounds, boundKind);
+	}
+
+	public TypeBinding getAnnotatedType(TypeBinding type, AnnotationBinding[][] annotations) {
+		return type;
+	}
+
+	
+	public abstract void reset();
+
+	public abstract void updateCaches(UnresolvedReferenceBinding unresolvedType, ReferenceBinding resolvedType);
+
+	public abstract TypeBinding getUnannotatedType(TypeBinding type);
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnannotatedTypeSystem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnannotatedTypeSystem.java
index 9a24ab4..7397dc8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnannotatedTypeSystem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnannotatedTypeSystem.java
@@ -29,12 +29,12 @@ import org.eclipse.jdt.internal.compiler.util.Util;
    Map<@T4 String, @T5 Object> and @T6 Map<String, Object> and @T7 Map<String, @T8 Object> and Map<String, @T9 Object> would all share the same id since
    the unadorned naked type in each case is the same: Map<String, Object>. None of this would share the id with Map<String, String>. Briefly put, if you
    take a certain annotated type and strip it of all annotations to come up with the naked type, that naked type and the annotated type would have the
-   same id. Alternately, if you take a certain naked type and arrive at the set of all differently annotated types, they would all share the same id while
+   same id. Alternately, if you take a certain naked type and arrive at the universe of all differently annotated types, they would all share the same id while
    their bindings could be different - would be different unless they are identically annotated.
    
    Thus subsystems that are annotation agnostic could quickly ascertain binding equality by comparing the id field.
 */
-public class UnannotatedTypeSystem {
+public class UnannotatedTypeSystem extends TypeSystem {
 	
 	private int typeid = TypeIds.T_LastWellKnownTypeId;
 	private TypeBinding [][] types; 
@@ -48,7 +48,7 @@ public class UnannotatedTypeSystem {
 		this.types = new TypeBinding[TypeIds.T_LastWellKnownTypeId * 2][]; 
 	}
 
-	TypeBinding getUnannotatedType(TypeBinding type) {
+	public TypeBinding getUnannotatedType(TypeBinding type) {
 		if (type.id == TypeIds.NoId) {
 			if (type.hasTypeAnnotations() && !type.isTypeVariable())
 				throw new IllegalStateException();
@@ -68,6 +68,9 @@ public class UnannotatedTypeSystem {
 		return this.types[type.id][0] = type;
 	}
 	
+	/* Note: parameters will not have type type annotations if lookup environment directly uses UTS as its typeSystem. However if this UTS is the underlying type system
+	   for an ATS, they may and we need to materialize the unannotated versions and work on them.
+	*/ 
 	public ArrayBinding getArrayType(TypeBinding leafType, int dimensions) {
 		TypeBinding unannotatedLeafType = getUnannotatedType(leafType);
 		TypeBinding[] cachedInfo = this.types[unannotatedLeafType.id];  // by construction, cachedInfo != null now.
@@ -96,6 +99,9 @@ public class UnannotatedTypeSystem {
 		return (ArrayBinding) (this.types[arrayType.id = this.typeid++][0] = arrayType);
 	}
 
+	/* Note: parameters will not have type type annotations if lookup environment directly uses UTS as its typeSystem. However if this UTS is the underlying type system
+	   for an ATS, they may and we need to materialize the unannotated versions and work on them.
+	*/ 
 	public ParameterizedTypeBinding getParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, ReferenceBinding enclosingType) {
 		ReferenceBinding unannotatedGenericType = (ReferenceBinding) getUnannotatedType(genericType);
 		int typeArgumentsLength = typeArguments == null ? 0: typeArguments.length;
@@ -131,6 +137,9 @@ public class UnannotatedTypeSystem {
 		return (ParameterizedTypeBinding) (this.types[parameterizedType.id = this.typeid++][0] = parameterizedType);
 	}
 
+	/* Note: parameters will not have type type annotations if lookup environment directly uses UTS as its typeSystem. However if this UTS is the underlying type system
+	   for an ATS, they may and we need to materialize the unannotated versions and work on them.
+	*/ 
 	public RawTypeBinding getRawType(ReferenceBinding genericType, ReferenceBinding enclosingType) {
 		ReferenceBinding unannotatedGenericType = (ReferenceBinding) getUnannotatedType(genericType);
 		ReferenceBinding unannotatedEnclosingType = enclosingType == null ? null : (ReferenceBinding) getUnannotatedType(enclosingType);
@@ -161,7 +170,9 @@ public class UnannotatedTypeSystem {
 		return (RawTypeBinding) (this.types[rawTytpe.id = this.typeid++][0] = rawTytpe);
 	}
 
-
+	/* Note: parameters will not have type type annotations if lookup environment directly uses UTS as its typeSystem. However if this UTS is the underlying type system
+	   for an ATS, they may and we need to materialize the unannotated versions and work on them.
+	*/ 
 	public WildcardBinding getWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind) {
 		if (genericType == null) // pseudo wildcard denoting composite bounds for lub computation
 			genericType = ReferenceBinding.LUB_GENERIC;
@@ -202,13 +213,20 @@ public class UnannotatedTypeSystem {
 		return (WildcardBinding) (this.types[wildcard.id = this.typeid++][0] = wildcard);
 	}
 
-
-	public AnnotationBinding getAnnotationType(ReferenceBinding annotationType) {
+	/* Return a unique annotation binding for an annotation with either no or all default element-value pairs.
+	   We may return a resolved annotation when requested for unresolved one, but not vice versa. 
+	*/
+	public AnnotationBinding getAnnotationType(ReferenceBinding annotationType, boolean requiredResolved) {
 		AnnotationBinding annotation = (AnnotationBinding) this.annotationTypes.get(annotationType);
 		if (annotation == null) {
-			annotation = new AnnotationBinding(annotationType, Binding.NO_ELEMENT_VALUE_PAIRS);
+			if (requiredResolved)
+				annotation = new AnnotationBinding(annotationType, Binding.NO_ELEMENT_VALUE_PAIRS);
+			else 
+				annotation = new UnresolvedAnnotationBinding(annotationType, Binding.NO_ELEMENT_VALUE_PAIRS, this.environment);
 			this.annotationTypes.put(annotationType, annotation);
 		}
+		if (requiredResolved)
+			annotation.resolve();
 		return annotation;
 	}
 
@@ -226,5 +244,14 @@ public class UnannotatedTypeSystem {
 			resolvedType.id = unresolvedTypeId;
 			this.types[unresolvedTypeId][0] = resolvedType;
 		}
+		if (this.annotationTypes.get(unresolvedType) != null) { // update the key
+			Object[] keys = this.annotationTypes.keyTable;
+			for (int i = 0, l = keys.length; i < l; i++) {
+				if (keys[i] == unresolvedType) {
+					keys[i] = resolvedType; // hashCode is based on compoundName so this works.
+					break;
+				}
+			}
+		}
 	}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedAnnotationBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedAnnotationBinding.java
index 57952ea..b859167 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedAnnotationBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/UnresolvedAnnotationBinding.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -19,7 +23,7 @@ UnresolvedAnnotationBinding(ReferenceBinding type, ElementValuePair[] pairs, Loo
 	this.env = env;
 }
 
-public ReferenceBinding getAnnotationType() {
+public void resolve() { // in place resolution.
 	if (this.typeUnresolved) { // the type is resolved when requested
 		boolean wasToleratingMissingTypeProcessingAnnotations = this.env.mayTolerateMissingType;
 		this.env.mayTolerateMissingType = true; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=388042
@@ -31,13 +35,16 @@ public ReferenceBinding getAnnotationType() {
 		}
 		this.typeUnresolved = false;
 	}
+}
+public ReferenceBinding getAnnotationType() {
+	resolve();
 	return this.type;
 }
 
 public ElementValuePair[] getElementValuePairs() {
 	if (this.env != null) {
 		if (this.typeUnresolved) {
-			getAnnotationType(); // resolve the annotation type
+			resolve();
 		}
 		// resolve method binding and value type (if unresolved) for each pair
 		for (int i = this.pairs.length; --i >= 0;) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
index 9e4510e..89259e4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java
@@ -132,7 +132,8 @@ public class CompilationUnitProblemFinder extends Compiler {
 		compilerOptions.performMethodsFullRecovery = statementsRecovery;
 		compilerOptions.performStatementsRecovery = statementsRecovery;
 		compilerOptions.parseLiteralExpressionsAsConstants = !creatingAST; /*parse literal expressions as constants only if not creating a DOM AST*/
-		compilerOptions.storeAnnotations = creatingAST; /*store annotations in the bindings if creating a DOM AST*/
+		if (creatingAST)
+			compilerOptions.storeAnnotations = true; /* store annotations in the bindings if creating a DOM AST */
 		return compilerOptions;
 	}
 
commit 7f8c41fdd4e487762406a2cb6aaa3aa1d260201c
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Wed Oct 2 20:58:30 2013 +0530

    Follow up changes to Bug 417113 - [1.8][compiler] Encoding of type
    annotations in compiler bindings.

160	9	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
8	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
16	45	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
10	21	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
index 3983a9a..3f56730 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
@@ -1090,7 +1090,7 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a)"});
 	}
 	
-	public void _testAnnotatedBinaryMemberType() throws CoreException, IOException {
+	public void _testAnnotatedBinaryType() throws CoreException, IOException {
 		String jarName = "TypeBindingTests308.jar";
 		String srcName = "TypeBindingTests308_src.zip";
 		IJavaProject javaProject = getJavaProject("Converter18");
@@ -1112,9 +1112,6 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 		
 			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
 			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			libraryOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_8);
-			libraryOptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_8);
-			libraryOptions.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_8);
 			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
 			
 			String contents = 
@@ -1146,7 +1143,7 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 				removeLibrary(javaProject, jarName, srcName);
 		}
 	}
-	public void _testAnnotatedBinaryMemberType2() throws CoreException, IOException {
+	public void _testAnnotatedBinaryType2() throws CoreException, IOException {
 		String jarName = "TypeBindingTests308.jar";
 		String srcName = "TypeBindingTests308_src.zip";
 		IJavaProject javaProject = getJavaProject("Converter18");
@@ -1194,12 +1191,12 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 			Assignment assignment = (Assignment) stmt.getExpression();
 			Expression left = assignment.getLeftHandSide();
 			ITypeBinding type = left.resolveTypeBinding();
-			assertEquals("Wrong type", "@Marker{ value = (String)\"Outer\"} Outer.Middle.@Marker{ value = (String)\"Middle\"} @Marker{ value = (String)\"Inner\"} Inner @Marker{ value = (String)\"Extended []\"} [] @Marker{ value = (String)\"Prefix []\"} []", type.toString());		
+			assertEquals("Wrong type", "@Marker{ value = (String)\"Outer\"} Outer.@Marker{ value = (String)\"Middle\"} Middle.@Marker{ value = (String)\"Inner\"} Inner @Marker{ value = (String)\"Extended []\"} [] @Marker{ value = (String)\"Prefix []\"} []", type.toString());		
 		} finally {
 				removeLibrary(javaProject, jarName, srcName);
 		}
 	}
-	public void _testAnnotatedBinaryMemberType3() throws CoreException, IOException {
+	public void _testAnnotatedBinaryType3() throws CoreException, IOException {
 		String jarName = "TypeBindingTests308.jar";
 		String srcName = "TypeBindingTests308_src.zip";
 		final IJavaProject javaProject = getJavaProject("Converter18");
@@ -1216,7 +1213,7 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 				"	int value();\n" +
 				"}\n"
 			};
-			// Outer<@T(2) String>.Inner<@T(2) Integer> @T(1) @T(6) [] @T(5) []
+			
 			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
 			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
 			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
@@ -1245,9 +1242,163 @@ public class TypeBindingTests308 extends ConverterTestSetup {
 			Assignment assignment = (Assignment) stmt.getExpression();
 			Expression left = assignment.getLeftHandSide();
 			ITypeBinding type = left.resolveTypeBinding();
-			assertEquals("Wrong type", "@Marker{ value = (String)\"Outer\"} Outer.Middle.@Marker{ value = (String)\"Middle\"} @Marker{ value = (String)\"Inner\"} Inner @Marker{ value = (String)\"Extended []\"} [] @Marker{ value = (String)\"Prefix []\"} []", type.toString());		
+			assertEquals("Wrong type", "@T{ value = (int)1} Outer<@T{ value = (int)2} String>.@T{ value = (int)3} Inner<@T{ value = (int)4} Integer> @T{ value = (int)6} [] @T{ value = (int)5} []", type.toString());		
+		} finally {
+				removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	
+	public void _testAnnotatedBinaryType4() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer<K>  {\n" +
+				"	class Inner<P> {\n" +
+				"	}\n" +
+				"	@T(1) K @T(2) [] f @T(3) [];\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value();\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Outer<String> o) {\n" +
+					"        o.f = null;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			assertEquals("Wrong type", "@T{ value = (int)1} String @T{ value = (int)3} [] @T{ value = (int)2} []", type.toString());		
 		} finally {
 				removeLibrary(javaProject, jarName, srcName);
 		}
 	}
+	public void _testAnnotatedBinaryType5() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer<K>  {\n" +
+				"	class Inner<P> {\n" +
+				"	}\n" +
+				"	@T(1) Outer<@T(2) ? extends @T(3) String>.@T(4) Inner<@T(5) ? super @T(6) Integer> @T(7) [] f @T(8) [];\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value();\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Outer<String> o) {\n" +
+					"        o.f = null;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			assertEquals("Wrong type", "@T{ value = (int)1} Outer<@T{ value = (int)2} ? extends @T{ value = (int)3} String>.@T{ value = (int)4} Inner<@T{ value = (int)5} ? super @T{ value = (int)6} Integer> @T{ value = (int)8} [] @T{ value = (int)7} []", type.toString());		
+		} finally {
+				removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void _testAnnotatedBinaryType6() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer<K>  {\n" +
+				"	class Inner<P> {\n" +
+				"	}\n" +
+				"	@T(1) Outer.@T(2) Inner @T(3) [] f @T(4) [];\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value();\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Outer<String> o) {\n" +
+					"        o.f = null;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			assertEquals("Wrong type", "@T{ value = (int)1} Outer#RAW.@T{ value = (int)2} Inner#RAW @T{ value = (int)4} [] @T{ value = (int)3} []", type.toString());		
+		} finally {
+				removeLibrary(javaProject, jarName, srcName);
+		}
+	}	
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
index 6d10741..634b046 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
@@ -401,7 +401,7 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 
 	}
 	protected void addExternalLibrary(IJavaProject javaProject, String jarPath, String[] pathAndContents, String[] nonJavaResources, String compliance) throws Exception {
-		String[] claspath = get15LibraryIfNeeded(compliance);
+		String[] claspath = getJCL15PlusLibraryIfNeeded(compliance);
 		org.eclipse.jdt.core.tests.util.Util.createJar(pathAndContents, nonJavaResources, jarPath, claspath, compliance);
 		addLibraryEntry(javaProject, new Path(jarPath), true/*exported*/);
 	}
@@ -460,7 +460,7 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 		IProject project = javaProject.getProject();
 		String projectLocation = project.getLocation().toOSString();
 		String jarPath = projectLocation + File.separator + jarName;
-		String[] claspath = get15LibraryIfNeeded(compliance);
+		String[] claspath = getJCL15PlusLibraryIfNeeded(compliance);
 		org.eclipse.jdt.core.tests.util.Util.createJar(pathAndContents, nonJavaResources, jarPath, claspath, compliance, options);
 		if (pathAndContents != null && pathAndContents.length != 0) {
 			String sourceZipPath = projectLocation + File.separator + sourceZipName;
@@ -1835,7 +1835,12 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 			assertTrue("Did not find sibling", found);
 		}
 	}
-	protected String[] get15LibraryIfNeeded(String compliance) throws JavaModelException, IOException {
+	protected String[] getJCL15PlusLibraryIfNeeded(String compliance) throws JavaModelException, IOException {
+		if (compliance.charAt(compliance.length()-1) >= '8' && (AbstractCompilerTest.getPossibleComplianceLevels() & AbstractCompilerTest.F_1_8) == 0) {
+			// ensure that the JCL 18 lib is setup (i.e. that the jclMin18.jar is copied)
+			setUpJCLClasspathVariables("1.8");
+			return new String[] {getExternalJCLPathString("1.8")};
+		}
 		if (compliance.charAt(compliance.length()-1) >= '5' && (AbstractCompilerTest.getPossibleComplianceLevels() & AbstractCompilerTest.F_1_5) == 0) {
 			// ensure that the JCL 15 lib is setup (i.e. that the jclMin15.jar is copied)
 			setUpJCLClasspathVariables("1.5");
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
index 20d37bb..7723fc2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotatableTypeSystem.java
@@ -124,24 +124,11 @@ public class AnnotatableTypeSystem extends TypeSystem {
 		if (!haveTypeAnnotations(genericType, enclosingType, typeArguments, annotations))
 			return this.unannotatedTypeSystem.getParameterizedType(genericType, typeArguments, enclosingType);
 		
-		/* When restoring annotations from class files, we encounter a situation where the generic type comes in attributed with the annotations that should
-		   really belong to the parameterized type that is being created just now. e.g @T List<String> => comes in as (@T List)<String>. The question really 
-		   is List being parameterized by String and then the resultant type is annotated or is "@T List" being parameterized with String ? We don't care one
-		   way or other except that we would want a uniform treatment. As a stop gap, we "repair" the situation here, so it is consistent with treatment of 
-		   type references in source code.
-		*/
-		AnnotationBinding [] misplacedAnnotations = genericType.getTypeAnnotations();
-		if (misplacedAnnotations != null && misplacedAnnotations != Binding.NO_ANNOTATIONS) {
-			if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
-				throw new IllegalStateException(); // cannot cut both ways.
-			annotations = misplacedAnnotations;
-			genericType = (ReferenceBinding) this.unannotatedTypeSystem.getUnannotatedType(genericType);
-		}
-		// generic type is expected to come in unannotated, if it came in with any misattributed annotations, they have been duly re-attributed and it is unannotated now.	
+		if (genericType.hasTypeAnnotations())
+			throw new IllegalStateException();
 		
 		int index = 0;
-		TypeBinding keyType = getUnannotatedType(genericType);
-		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(keyType); // promotes better instance sharing
+		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(genericType);
 		if (cachedInfo != null) {
 			for (int max = cachedInfo.length; index < max; index++){
 				TypeBinding cachedType = cachedInfo[index];
@@ -153,12 +140,12 @@ public class AnnotatableTypeSystem extends TypeSystem {
 					return (ParameterizedTypeBinding) cachedType;
 			}
 		} else {
-			this.annotatedTypes.put(keyType, cachedInfo = new TypeBinding[4]);
+			this.annotatedTypes.put(genericType, cachedInfo = new TypeBinding[4]);
 		}
 		int length = cachedInfo.length;
 		if (index == length) {
 			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
-			this.annotatedTypes.put(keyType, cachedInfo);
+			this.annotatedTypes.put(genericType, cachedInfo);
 		}
 		// Add the new comer, retaining the same type binding id as the naked type.
 		ParameterizedTypeBinding unannotatedParameterizedType = this.unannotatedTypeSystem.getParameterizedType(genericType, typeArguments, enclosingType);
@@ -177,18 +164,10 @@ public class AnnotatableTypeSystem extends TypeSystem {
 		if (!haveTypeAnnotations(genericType, enclosingType, null, annotations))
 			return this.unannotatedTypeSystem.getRawType(genericType, enclosingType);
 		
-		// See explanation on misplaced annotations in getParameterizedType.
-		AnnotationBinding [] misplacedAnnotations = genericType.getTypeAnnotations();
-		if (misplacedAnnotations != null && misplacedAnnotations != Binding.NO_ANNOTATIONS) {
-			if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
-				throw new IllegalStateException(); // cannot cut both ways.
-			annotations = misplacedAnnotations;
-			genericType = (ReferenceBinding) this.unannotatedTypeSystem.getUnannotatedType(genericType);
-		}
-		// generic type is expected to come in unannotated, if it came in with any misattributed annotations, they have been duly re-attributed and it is unannotated now.	
+		if (genericType.hasTypeAnnotations())
+			throw new IllegalStateException();
 		
-		TypeBinding keyType = getUnannotatedType(genericType);
-		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(keyType);
+		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(genericType);
 		int index = 0;
 		if (cachedInfo != null) {
 			for (int max = cachedInfo.length; index < max; index++) {
@@ -199,13 +178,13 @@ public class AnnotatableTypeSystem extends TypeSystem {
 					return (RawTypeBinding) cachedType;
 			}
 		} else {
-			this.annotatedTypes.put(keyType, cachedInfo = new TypeBinding[4]);
+			this.annotatedTypes.put(genericType, cachedInfo = new TypeBinding[4]);
 		}
 		
 		int length = cachedInfo.length;
 		if (index == length) {
 			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
-			this.annotatedTypes.put(keyType, cachedInfo);
+			this.annotatedTypes.put(genericType, cachedInfo);
 		}
 		// Add the new comer, retaining the same type binding id as the naked type.
 		RawTypeBinding unannotatedRawType = this.unannotatedTypeSystem.getRawType(genericType, enclosingType);
@@ -227,18 +206,10 @@ public class AnnotatableTypeSystem extends TypeSystem {
 		if (genericType == null) // pseudo wildcard denoting composite bounds for lub computation
 			genericType = ReferenceBinding.LUB_GENERIC;
 
-		// See explanation on misplaced annotations in getParameterizedType.
-		AnnotationBinding [] misplacedAnnotations = genericType.getTypeAnnotations();
-		if (misplacedAnnotations != null && misplacedAnnotations != Binding.NO_ANNOTATIONS) {
-			if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
-				throw new IllegalStateException(); // cannot cut both ways.
-			annotations = misplacedAnnotations;
-			genericType = (ReferenceBinding) this.unannotatedTypeSystem.getUnannotatedType(genericType);
-		}
-		// generic type is expected to come in unannotated, if it came in with any misattributed annotations, they have been duly re-attributed and it is unannotated now.	
+		if (genericType.hasTypeAnnotations())
+			throw new IllegalStateException();
 		
-		TypeBinding keyType = getUnannotatedType(genericType);		
-		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(keyType);  // promotes better instance sharing.
+		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(genericType);  // promotes better instance sharing.
 		int index = 0;
 		if (cachedInfo != null) {
 			for (int max = cachedInfo.length; index < max; index++) {
@@ -253,13 +224,13 @@ public class AnnotatableTypeSystem extends TypeSystem {
 					return (WildcardBinding) cachedType;
 			}
 		} else {
-			this.annotatedTypes.put(keyType, cachedInfo = new TypeBinding[4]);
+			this.annotatedTypes.put(genericType, cachedInfo = new TypeBinding[4]);
 		}
 
 		int length = cachedInfo.length;
 		if (index == length) {
 			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
-			this.annotatedTypes.put(keyType, cachedInfo);
+			this.annotatedTypes.put(genericType, cachedInfo);
 		}
 		// Add the new comer, retaining the same type binding id as the naked type.
 		TypeBinding unannotatedWildcard = this.unannotatedTypeSystem.getWildcard(genericType, rank, bound, otherBounds, boundKind);
@@ -334,7 +305,7 @@ public class AnnotatableTypeSystem extends TypeSystem {
 				 */
 				
 				if (type.isUnresolvedType() && CharOperation.indexOf('$', type.sourceName()) > 0)
-				    type = BinaryTypeBinding.resolveType(type, this.environment, false /* no raw conversion */); // must resolve member types before asking for enclosingType
+				    type = BinaryTypeBinding.resolveType(type, this.environment, true); // must resolve member types before asking for enclosingType
 				
 				int levels = type.depth() + 1;
 				TypeBinding [] types = new TypeBinding[levels];
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index a683562..46332ff 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -1395,7 +1395,7 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 	    int varEnd = wrapper.computeEnd();
 		for (int i = staticVariables.length; --i >= 0;)
 			if (CharOperation.equals(staticVariables[i].sourceName, wrapper.signature, varStart, varEnd))
-				return getTypeFromTypeVariable(staticVariables[i], dimension, walker, missingTypeNames);
+				return getTypeFromTypeVariable(staticVariables[i], dimension, annotationsOnDimensions, walker, missingTypeNames);
 	    ReferenceBinding initialType = enclosingType;
 		do {
 			TypeVariableBinding[] enclosingTypeVariables;
@@ -1406,7 +1406,7 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 			}
 			for (int i = enclosingTypeVariables.length; --i >= 0;)
 				if (CharOperation.equals(enclosingTypeVariables[i].sourceName, wrapper.signature, varStart, varEnd))
-					return getTypeFromTypeVariable(enclosingTypeVariables[i], dimension, walker, missingTypeNames);
+					return getTypeFromTypeVariable(enclosingTypeVariables[i], dimension, annotationsOnDimensions, walker, missingTypeNames);
 		} while ((enclosingType = enclosingType.enclosingType()) != null);
 		this.problemReporter.undefinedTypeVariableSignature(CharOperation.subarray(wrapper.signature, varStart, varEnd), initialType);
 		return null; // cannot reach this, since previous problem will abort compilation
@@ -1426,8 +1426,9 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 	if (actualEnclosing != null) { // convert needed if read some static member type
 		actualEnclosing = (ReferenceBinding) convertToRawType(actualEnclosing, false /*do not force conversion of enclosing types*/);
 	}
+	AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(), this, missingTypeNames);
 	TypeBinding[] typeArguments = getTypeArgumentsFromSignature(wrapper, staticVariables, enclosingType, actualType, missingTypeNames, walker);
-	ParameterizedTypeBinding parameterizedType = createParameterizedType(actualType, typeArguments, actualEnclosing);
+	ParameterizedTypeBinding parameterizedType = createParameterizedType(actualType, typeArguments, actualEnclosing, annotations);
 
 	while (wrapper.signature[wrapper.start] == '.') {
 		wrapper.start++; // skip '.'
@@ -1438,37 +1439,25 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 		// need to protect against the member type being null when the signature is invalid
 		if (memberType == null)
 			this.problemReporter.corruptedSignature(parameterizedType, wrapper.signature, memberStart); // aborts
+		walker = walker.toNextNestedType();
+		annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(), this, missingTypeNames);
 		if (wrapper.signature[wrapper.start] == '<') {
 			wrapper.start++; // skip '<'
 			typeArguments = getTypeArgumentsFromSignature(wrapper, staticVariables, enclosingType, memberType, missingTypeNames, walker);
 		} else {
 			typeArguments = null;
 		}
-		parameterizedType = createParameterizedType(memberType, typeArguments, parameterizedType);
+		parameterizedType = createParameterizedType(memberType, typeArguments, parameterizedType, annotations);
 	}
 	wrapper.start++; // skip ';'
 	return dimension == 0 ? (TypeBinding) parameterizedType : createArrayType(parameterizedType, dimension, AnnotatableTypeSystem.flattenedAnnotations(annotationsOnDimensions));
 }
 
-private TypeBinding getTypeFromTypeVariable(TypeVariableBinding typeVariableBinding, int dimension, TypeAnnotationWalker walker, char [][][] missingTypeNames) {
-	AnnotationBinding [] annotations;
-	AnnotationBinding [][] annotationsOnDimensions = null;
-	if (walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
-		for (int i = 0; i < dimension; i++) {
-			annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(), this, missingTypeNames);
-			if (annotations != Binding.NO_ANNOTATIONS) { 
-				if (annotationsOnDimensions == null)
-					annotationsOnDimensions = new AnnotationBinding[dimension][];
-				annotationsOnDimensions[i] = annotations;
-			}
-			walker = walker.toNextArrayDimension();
-		}
-	}
-	
-	annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(), this, missingTypeNames);
+private TypeBinding getTypeFromTypeVariable(TypeVariableBinding typeVariableBinding, int dimension, AnnotationBinding [][] annotationsOnDimensions, TypeAnnotationWalker walker, char [][][] missingTypeNames) {
+	AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(), this, missingTypeNames);
 	if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
 		typeVariableBinding = (TypeVariableBinding) createAnnotatedType(typeVariableBinding, new AnnotationBinding [][] { annotations });
-	
+
 	if (dimension == 0) {
 		return typeVariableBinding;
 	}
