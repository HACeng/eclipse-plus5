commit f44833f9e9c6c61508713666b8c272384401715c
Author: David Audel <daudel>
Date:   Thu Apr 3 11:18:00 2008 +0000

    HEAD -  bug 133005

6	4	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SnippetCompletionTests_1_5.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
1	1	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
4	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
2	524	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
557	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/TypeConverter.java
94	60	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryTypeConverter.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SnippetCompletionTests_1_5.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SnippetCompletionTests_1_5.java
index d9cc623..dbdd2cc 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SnippetCompletionTests_1_5.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/SnippetCompletionTests_1_5.java
@@ -60,8 +60,9 @@ public void testCodeSnippetAssistForBug132665() throws JavaModelException {
 	type.codeComplete(snippet.toCharArray(), -1, snippet.length(), typeNames, names, modifiers, false, requestor);
 	
 	assertResults(
-		"foo1[METHOD_REF]{foo1(), Lbug132665.Bug132665;, ()V, foo1, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
-		"foo3[METHOD_REF]{foo3(), Lbug132665.Bug132665;, ()V, foo3, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+		"foo1[METHOD_REF]{foo1(), Lbug132665.Bug132665<TT;>;, ()V, foo1, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+		"foo2[METHOD_REF]{foo2(), Lbug132665.Bug132665<TT;>;, ()Lbug132665.Bug132665<+Ljava.lang.Object;>;, foo2, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+		"foo3[METHOD_REF]{foo3(), Lbug132665.Bug132665<TT;>;, ()V, foo3, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
 		requestor.getResults());
 }
 public void testCodeSnippetAssistForBug223878() throws JavaModelException {
@@ -79,8 +80,9 @@ public void testCodeSnippetAssistForBug223878() throws JavaModelException {
 	type.codeComplete(snippet.toCharArray(), -1, snippet.length(), typeNames, names, modifiers, false, requestor);
 	
 	assertResults(
-		"foo1[METHOD_REF]{foo1(), Lbug223878.Bug223878;, ()V, foo1, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
-		"foo3[METHOD_REF]{foo3(), Lbug223878.Bug223878;, ()V, foo3, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+		"foo1[METHOD_REF]{foo1(), Lbug223878.Bug223878<TT;>;, ()V, foo1, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+		"foo2[METHOD_REF]{foo2(), Lbug223878.Bug223878<TT;>;, (Lbug223878.Bug223878<+Ljava.lang.Object;>;)V, foo2, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}\n"+
+		"foo3[METHOD_REF]{foo3(), Lbug223878.Bug223878<TT;>;, ()V, foo3, "+(R_DEFAULT + R_RESOLVED + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
 		requestor.getResults());
 }
 }
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index b27cd3d..6d196f4 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -48,7 +48,9 @@ Eclipse SDK 3.4M7 - %date% - 3.4 MILESTONE 7
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=224351">224351</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=133005">133005</a>
+BinaryTypeConverter cannot convert generic type reference.
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=224351">224351</a>
 Regression in performance test FullSourceWorkspaceModelTests#testFindType
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=215975">215975</a>
 new field declaration CompletionProposal cuts changes initial prefix
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 9ffff18..475b5fa 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -2197,7 +2197,7 @@ public final class CompletionEngine
 					typeDeclaration = compilationUnit.types[0];
 			} else {
 				compilationUnit = new CompilationUnitDeclaration(this.problemReporter, compilationResult, 0);
-				typeDeclaration = BinaryTypeConverter.buildTypeDeclaration(type, compilationUnit, compilationResult, null/*no need to remember type names*/);
+				typeDeclaration = new BinaryTypeConverter(this.parser.problemReporter(), compilationResult, null/*no need to remember type names*/).buildTypeDeclaration(type, compilationUnit);
 			}
 		
 			if(typeDeclaration != null) {	
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
index 40af943..1345ce3 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
@@ -1137,8 +1137,10 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				CompilationResult result = new CompilationResult(reader.getFileName(), 1, 1, this.compilerOptions.maxProblemsPerUnit);
 				parsedUnit = new CompilationUnitDeclaration(this.parser.problemReporter(), result, 0);
 				HashSetOfCharArrayArray typeNames = new HashSetOfCharArrayArray();
-				typeDeclaration = BinaryTypeConverter.buildTypeDeclaration(context, parsedUnit, result, typeNames);
-				parsedUnit.imports = BinaryTypeConverter.buildImports(typeNames, reader);
+				
+				BinaryTypeConverter converter = new BinaryTypeConverter(this.parser.problemReporter(), result, typeNames);
+				typeDeclaration = converter.buildTypeDeclaration(context, parsedUnit);
+				parsedUnit.imports = converter.buildImports(reader);
 			}
 
 			if (typeDeclaration != null) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
index 015e147..62640a9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
@@ -23,15 +23,12 @@ package org.eclipse.jdt.internal.compiler.parser;
  *
  */
 
-import java.util.ArrayList;
-
 import org.eclipse.jdt.core.IAnnotatable;
 import org.eclipse.jdt.core.IAnnotation;
 import org.eclipse.jdt.core.IImportDeclaration;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.ISourceRange;
 import org.eclipse.jdt.core.JavaModelException;
-import org.eclipse.jdt.core.Signature;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.ast.*;
@@ -42,13 +39,11 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.*;
 
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
-import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
-import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.core.*;
 import org.eclipse.jdt.internal.core.util.Util;
 
-public class SourceTypeConverter {
+public class SourceTypeConverter extends TypeConverter {
 	
 	/* 
 	 * Exception thrown while converting an anonymous type of a member type
@@ -71,17 +66,12 @@ public class SourceTypeConverter {
 	private int flags;
 	private CompilationUnitDeclaration unit;
 	private Parser parser;
-	private ProblemReporter problemReporter;
 	private ICompilationUnit cu;
 	private char[] source;
-	private boolean has1_5Compliance;
-	
-	int namePos;
 	
 	private SourceTypeConverter(int flags, ProblemReporter problemReporter) {
+		super(problemReporter);
 		this.flags = flags;
-		this.problemReporter = problemReporter;
-		this.has1_5Compliance = problemReporter.options.complianceLevel >= ClassFileConstants.JDK1_5;
 	}
 
 	/*
@@ -170,15 +160,6 @@ public class SourceTypeConverter {
 		}
 	}
 	
-	private void addIdentifiers(String typeSignature, int start, int endExclusive, int identCount, ArrayList fragments) {
-		if (identCount == 1) {
-			char[] identifier;
-			typeSignature.getChars(start, endExclusive, identifier = new char[endExclusive-start], 0);
-			fragments.add(identifier);
-		} else
-			fragments.add(extractIdentifiers(typeSignature, start, endExclusive-1, identCount));
-	}
-	
 	/*
 	 * Convert an initializerinfo into a parsed initializer declaration
 	 */
@@ -624,509 +605,6 @@ public class SourceTypeConverter {
 		}
 		return astAnnotations;
 	}
-
-	/*
-	 * Build an import reference from an import name, e.g. java.lang.*
-	 */
-	private ImportReference createImportReference(
-		String[] importName,
-		int start,
-		int end, 
-		boolean onDemand,
-		int modifiers) {
-	
-		int length = importName.length;
-		long[] positions = new long[length];
-		long position = ((long) start << 32) + end;
-		char[][] qImportName = new char[length][];
-		for (int i = 0; i < length; i++) {
-			qImportName[i] = importName[i].toCharArray();
-			positions[i] = position; // dummy positions
-		}
-		return new ImportReference(
-			qImportName,
-			positions,
-			onDemand,
-			modifiers);
-	}
-
-	private TypeParameter createTypeParameter(char[] typeParameterName, char[][] typeParameterBounds, int start, int end) {
-
-		TypeParameter parameter = new TypeParameter();
-		parameter.name = typeParameterName;
-		parameter.sourceStart = start;
-		parameter.sourceEnd = end;
-		if (typeParameterBounds != null) {
-			int length = typeParameterBounds.length;
-			if (length > 0) {
-				parameter.type = createTypeReference(typeParameterBounds[0], start, end);
-				if (length > 1) {
-					parameter.bounds = new TypeReference[length-1];
-					for (int i = 1; i < length; i++) {
-						TypeReference bound = createTypeReference(typeParameterBounds[i], start, end);
-						bound.bits |= ASTNode.IsSuperType;
-						parameter.bounds[i-1] = bound;
-					}
-				}
-			}
-		}
-		return parameter;
-	}
-	
-	/*
-	 * Build a type reference from a readable name, e.g. java.lang.Object[][]
-	 */
-	private TypeReference createTypeReference(
-		char[] typeName,
-		int start,
-		int end) {
-
-		int length = typeName.length;
-		this.namePos = 0;
-		return decodeType(typeName, length, start, end);
-	}
-	
-	/*
-	 * Build a type reference from a type signature, e.g. Ljava.lang.Object;
-	 */
-	private TypeReference createTypeReference(
-			String typeSignature,
-			int start,
-			int end) {
-		
-		int length = typeSignature.length();
-		this.namePos = 0;
-		return decodeType(typeSignature, length, start, end);
-	}
-	
-	private TypeReference decodeType(String typeSignature, int length, int start, int end) {
-		int identCount = 1;
-		int dim = 0;
-		int nameFragmentStart = this.namePos, nameFragmentEnd = -1;
-		boolean nameStarted = false;
-		ArrayList fragments = null;
-		typeLoop: while (this.namePos < length) {
-			char currentChar = typeSignature.charAt(this.namePos);
-			switch (currentChar) {
-				case Signature.C_BOOLEAN :
-					if (!nameStarted) {
-						this.namePos++;
-						if (dim == 0)
-							return new SingleTypeReference(TypeBinding.BOOLEAN.simpleName, ((long) start << 32) + end);
-						else
-							return new ArrayTypeReference(TypeBinding.BOOLEAN.simpleName, dim, ((long) start << 32) + end);
-					} 
-					break;
-				case Signature.C_BYTE :
-					if (!nameStarted) {
-						this.namePos++;
-						if (dim == 0)
-							return new SingleTypeReference(TypeBinding.BYTE.simpleName, ((long) start << 32) + end);
-						else
-							return new ArrayTypeReference(TypeBinding.BYTE.simpleName, dim, ((long) start << 32) + end);				
-					}
-					break;
-				case Signature.C_CHAR :
-					if (!nameStarted) {
-						this.namePos++;
-						if (dim == 0)
-							return new SingleTypeReference(TypeBinding.CHAR.simpleName, ((long) start << 32) + end);
-						else
-							return new ArrayTypeReference(TypeBinding.CHAR.simpleName, dim, ((long) start << 32) + end);
-					}
-					break;
-				case Signature.C_DOUBLE :
-					if (!nameStarted) {
-						this.namePos++;
-						if (dim == 0)
-							return new SingleTypeReference(TypeBinding.DOUBLE.simpleName, ((long) start << 32) + end);
-						else
-							return new ArrayTypeReference(TypeBinding.DOUBLE.simpleName, dim, ((long) start << 32) + end);				
-					}
-					break;
-				case Signature.C_FLOAT :
-					if (!nameStarted) {
-						this.namePos++;
-						if (dim == 0)
-							return new SingleTypeReference(TypeBinding.FLOAT.simpleName, ((long) start << 32) + end);
-						else
-							return new ArrayTypeReference(TypeBinding.FLOAT.simpleName, dim, ((long) start << 32) + end);				
-					}
-					break;
-				case Signature.C_INT :
-					if (!nameStarted) {
-						this.namePos++;
-						if (dim == 0)
-							return new SingleTypeReference(TypeBinding.INT.simpleName, ((long) start << 32) + end);
-						else
-							return new ArrayTypeReference(TypeBinding.INT.simpleName, dim, ((long) start << 32) + end);				
-					}
-					break;
-				case Signature.C_LONG :
-					if (!nameStarted) {
-						this.namePos++;
-						if (dim == 0)
-							return new SingleTypeReference(TypeBinding.LONG.simpleName, ((long) start << 32) + end);
-						else
-							return new ArrayTypeReference(TypeBinding.LONG.simpleName, dim, ((long) start << 32) + end);				
-					}
-					break;
-				case Signature.C_SHORT :
-					if (!nameStarted) {
-						this.namePos++;
-						if (dim == 0)
-							return new SingleTypeReference(TypeBinding.SHORT.simpleName, ((long) start << 32) + end);
-						else
-							return new ArrayTypeReference(TypeBinding.SHORT.simpleName, dim, ((long) start << 32) + end);				
-					}
-					break;
-				case Signature.C_VOID :
-					if (!nameStarted) {
-						this.namePos++;
-						new SingleTypeReference(TypeBinding.VOID.simpleName, ((long) start << 32) + end);
-					}
-					break;
-				case Signature.C_RESOLVED :
-				case Signature.C_UNRESOLVED :
-					if (!nameStarted) {
-						nameFragmentStart = this.namePos+1;
-						nameStarted = true;
-					}
-					break;
-				case Signature.C_STAR:
-					this.namePos++;
-					Wildcard result = new Wildcard(Wildcard.UNBOUND);
-					result.sourceStart = start;
-					result.sourceEnd = end;
-					return result;
-				case Signature.C_EXTENDS:
-					this.namePos++;
-					result = new Wildcard(Wildcard.EXTENDS);
-					result.bound = decodeType(typeSignature, length, start, end);
-					result.sourceStart = start;
-					result.sourceEnd = end;
-					return result;
-				case Signature.C_SUPER:
-					this.namePos++;
-					result = new Wildcard(Wildcard.SUPER);
-					result.bound = decodeType(typeSignature, length, start, end);
-					result.sourceStart = start;
-					result.sourceEnd = end;
-					return result;
-				case Signature.C_ARRAY :
-					dim++;
-					break;
-				case Signature.C_GENERIC_END :
-				case Signature.C_SEMICOLON :
-					nameFragmentEnd = this.namePos-1;
-					this.namePos++;
-					break typeLoop;
-				case Signature.C_DOT :
-				case Signature.C_DOLLAR:
-					if (!nameStarted) {
-						nameFragmentStart = this.namePos+1;
-						nameStarted = true;
-					} else if (this.namePos > nameFragmentStart) // handle name starting with a $ (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=91709)
-						identCount ++;
-					break;
-				case Signature.C_GENERIC_START :
-					nameFragmentEnd = this.namePos-1;
-					// convert 1.5 specific constructs only if compliance is 1.5 or above
-					if (!this.has1_5Compliance) 
-						break typeLoop;
-					if (fragments == null) fragments = new ArrayList(2);
-					addIdentifiers(typeSignature, nameFragmentStart, nameFragmentEnd + 1, identCount, fragments);
-					this.namePos++; // skip '<'
-					TypeReference[] arguments = decodeTypeArguments(typeSignature, length, start, end); // positionned on '>' at end
-					fragments.add(arguments);
-					identCount = 1;
-					nameStarted = false;
-					// next increment will skip '>'
-					break;
-			}
-			this.namePos++;
-		}
-		if (fragments == null) { // non parameterized 
-			/* rebuild identifiers and dimensions */
-			if (identCount == 1) { // simple type reference
-				if (dim == 0) {
-					char[] nameFragment = new char[nameFragmentEnd - nameFragmentStart + 1];
-					typeSignature.getChars(nameFragmentStart, nameFragmentEnd +1, nameFragment, 0);
-					return new SingleTypeReference(nameFragment, ((long) start << 32) + end);
-				} else {
-					char[] nameFragment = new char[nameFragmentEnd - nameFragmentStart + 1];
-					typeSignature.getChars(nameFragmentStart, nameFragmentEnd +1, nameFragment, 0);
-					return new ArrayTypeReference(nameFragment, dim, ((long) start << 32) + end);
-				}
-			} else { // qualified type reference
-				long[] positions = new long[identCount];
-				long pos = ((long) start << 32) + end;
-				for (int i = 0; i < identCount; i++) {
-					positions[i] = pos;
-				}
-				char[][] identifiers = extractIdentifiers(typeSignature, nameFragmentStart, nameFragmentEnd, identCount);
-				if (dim == 0) {
-					return new QualifiedTypeReference(identifiers, positions);
-				} else {
-					return new ArrayQualifiedTypeReference(identifiers, dim, positions);
-				}
-			}
-		} else { // parameterized
-			// rebuild type reference from available fragments: char[][], arguments, char[][], arguments...
-			// check trailing qualified name
-			if (nameStarted) {
-				addIdentifiers(typeSignature, nameFragmentStart, nameFragmentEnd + 1, identCount, fragments);
-			}
-			int fragmentLength = fragments.size();
-			if (fragmentLength == 2) {
-				Object firstFragment = fragments.get(0);
-				if (firstFragment instanceof char[]) {
-					// parameterized single type
-					return new ParameterizedSingleTypeReference((char[]) firstFragment, (TypeReference[]) fragments.get(1), dim, ((long) start << 32) + end);
-				}
-			}
-			// parameterized qualified type
-			identCount = 0;
-			for (int i = 0; i < fragmentLength; i ++) {
-				Object element = fragments.get(i);
-				if (element instanceof char[][]) {
-					identCount += ((char[][])element).length;
-				} else if (element instanceof char[])
-					identCount++;
-			}
-			char[][] tokens = new char[identCount][];
-			TypeReference[][] arguments = new TypeReference[identCount][];
-			int index = 0;
-			for (int i = 0; i < fragmentLength; i ++) {
-				Object element = fragments.get(i);
-				if (element instanceof char[][]) {
-					char[][] fragmentTokens = (char[][]) element;
-					int fragmentTokenLength = fragmentTokens.length;
-					System.arraycopy(fragmentTokens, 0, tokens, index, fragmentTokenLength);
-					index += fragmentTokenLength;
-				} else if (element instanceof char[]) {
-					tokens[index++] = (char[]) element;
-				} else {
-					arguments[index-1] = (TypeReference[]) element;
-				}
-			}
-			long[] positions = new long[identCount];
-			long pos = ((long) start << 32) + end;
-			for (int i = 0; i < identCount; i++) {
-				positions[i] = pos;
-			}
-			return new ParameterizedQualifiedTypeReference(tokens, arguments, dim, positions);
-		}
-	}
-	
-	private TypeReference decodeType(char[] typeName, int length, int start, int end) {
-		int identCount = 1;
-		int dim = 0;
-		int nameFragmentStart = this.namePos, nameFragmentEnd = -1;
-		ArrayList fragments = null;
-		typeLoop: while (this.namePos < length) {
-			char currentChar = typeName[this.namePos];
-			switch (currentChar) {
-				case '?' :
-					this.namePos++; // skip '?'
-					while (typeName[this.namePos] == ' ') this.namePos++;
-					switch(typeName[this.namePos]) {
-						case 's' :
-							checkSuper: {
-								int max = TypeConstants.WILDCARD_SUPER.length-1;
-								for (int ahead = 1; ahead < max; ahead++) {
-									if (typeName[this.namePos+ahead] != TypeConstants.WILDCARD_SUPER[ahead+1]) {
-										break checkSuper;
-									}
-								}
-								this.namePos += max;
-								Wildcard result = new Wildcard(Wildcard.SUPER);
-								result.bound = decodeType(typeName, length, start, end);
-								result.sourceStart = start;
-								result.sourceEnd = end;
-								return result;
-							}
-							break;
-						case 'e' :
-							checkExtends: {
-								int max = TypeConstants.WILDCARD_EXTENDS.length-1;
-								for (int ahead = 1; ahead < max; ahead++) {
-									if (typeName[this.namePos+ahead] != TypeConstants.WILDCARD_EXTENDS[ahead+1]) {
-										break checkExtends;
-									}
-								}
-								this.namePos += max;
-								Wildcard result = new Wildcard(Wildcard.EXTENDS);
-								result.bound = decodeType(typeName, length, start, end);
-								result.sourceStart = start;
-								result.sourceEnd = end;
-								return result;
-							}
-							break;
-					}
-					Wildcard result = new Wildcard(Wildcard.UNBOUND);
-					result.sourceStart = start;
-					result.sourceEnd = end;
-					return result;
-				case '[' :
-					if (dim == 0) nameFragmentEnd = this.namePos-1;
-					dim++;
-					break;
-				case ']' :
-					break;
-				case '>' :
-				case ',' :
-					break typeLoop;
-				case '.' :
-					if (nameFragmentStart < 0) nameFragmentStart = this.namePos+1; // member type name
-					identCount ++;
-					break;
-				case '<' :
-					// convert 1.5 specific constructs only if compliance is 1.5 or above
-					if (!this.has1_5Compliance) 
-						break typeLoop;
-					if (fragments == null) fragments = new ArrayList(2);
-					nameFragmentEnd = this.namePos-1;
-					char[][] identifiers = CharOperation.splitOn('.', typeName, nameFragmentStart, this.namePos);
-					fragments.add(identifiers);
-					this.namePos++; // skip '<'
-					TypeReference[] arguments = decodeTypeArguments(typeName, length, start, end); // positionned on '>' at end
-					fragments.add(arguments);
-					identCount = 0;
-					nameFragmentStart = -1;
-					nameFragmentEnd = -1;
-					// next increment will skip '>'
-					break;
-			}
-			this.namePos++;
-		}
-		if (nameFragmentEnd < 0) nameFragmentEnd = this.namePos-1;
-		if (fragments == null) { // non parameterized 
-			/* rebuild identifiers and dimensions */
-			if (identCount == 1) { // simple type reference
-				if (dim == 0) {
-					char[] nameFragment;
-					if (nameFragmentStart != 0 || nameFragmentEnd >= 0) {
-						int nameFragmentLength = nameFragmentEnd - nameFragmentStart + 1;
-						System.arraycopy(typeName, nameFragmentStart, nameFragment = new char[nameFragmentLength], 0, nameFragmentLength);						
-					} else {
-						nameFragment = typeName;
-					}
-					return new SingleTypeReference(nameFragment, ((long) start << 32) + end);
-				} else {
-					int nameFragmentLength = nameFragmentEnd - nameFragmentStart + 1;
-					char[] nameFragment = new char[nameFragmentLength];
-					System.arraycopy(typeName, nameFragmentStart, nameFragment, 0, nameFragmentLength);
-					return new ArrayTypeReference(nameFragment, dim, ((long) start << 32) + end);
-				}
-			} else { // qualified type reference
-				long[] positions = new long[identCount];
-				long pos = ((long) start << 32) + end;
-				for (int i = 0; i < identCount; i++) {
-					positions[i] = pos;
-				}
-				char[][] identifiers = CharOperation.splitOn('.', typeName, nameFragmentStart, nameFragmentEnd+1);
-				if (dim == 0) {
-					return new QualifiedTypeReference(identifiers, positions);
-				} else {
-					return new ArrayQualifiedTypeReference(identifiers, dim, positions);
-				}
-			}
-		} else { // parameterized
-			// rebuild type reference from available fragments: char[][], arguments, char[][], arguments...
-			// check trailing qualified name
-			if (nameFragmentStart > 0 && nameFragmentStart < length) {
-				char[][] identifiers = CharOperation.splitOn('.', typeName, nameFragmentStart, nameFragmentEnd+1);
-				fragments.add(identifiers);
-			}
-			int fragmentLength = fragments.size();
-			if (fragmentLength == 2) {
-				char[][] firstFragment = (char[][]) fragments.get(0);
-				if (firstFragment.length == 1) {
-					// parameterized single type
-					return new ParameterizedSingleTypeReference(firstFragment[0], (TypeReference[]) fragments.get(1), dim, ((long) start << 32) + end);
-				}
-			}
-			// parameterized qualified type
-			identCount = 0;
-			for (int i = 0; i < fragmentLength; i ++) {
-				Object element = fragments.get(i);
-				if (element instanceof char[][]) {
-					identCount += ((char[][])element).length;
-				}
-			}
-			char[][] tokens = new char[identCount][];
-			TypeReference[][] arguments = new TypeReference[identCount][];
-			int index = 0;
-			for (int i = 0; i < fragmentLength; i ++) {
-				Object element = fragments.get(i);
-				if (element instanceof char[][]) {
-					char[][] fragmentTokens = (char[][]) element;
-					int fragmentTokenLength = fragmentTokens.length;
-					System.arraycopy(fragmentTokens, 0, tokens, index, fragmentTokenLength);
-					index += fragmentTokenLength;
-				} else {
-					arguments[index-1] = (TypeReference[]) element;
-				}
-			}
-			long[] positions = new long[identCount];
-			long pos = ((long) start << 32) + end;
-			for (int i = 0; i < identCount; i++) {
-				positions[i] = pos;
-			}
-			return new ParameterizedQualifiedTypeReference(tokens, arguments, dim, positions);
-		}
-	}
-	
-	private TypeReference[] decodeTypeArguments(char[] typeName, int length, int start, int end) {
-		ArrayList argumentList = new ArrayList(1);
-		int count = 0;
-		argumentsLoop: while (this.namePos < length) {
-			TypeReference argument = decodeType(typeName, length, start, end);
-			count++;
-			argumentList.add(argument);
-			if (this.namePos >= length) break argumentsLoop;
-			if (typeName[this.namePos] == '>') {
-				break argumentsLoop;
-			}
-			this.namePos++; // skip ','
-		}
-		TypeReference[] typeArguments = new TypeReference[count];
-		argumentList.toArray(typeArguments);
-		return typeArguments;
-	}
-	
-	private TypeReference[] decodeTypeArguments(String typeSignature, int length, int start, int end) {
-		ArrayList argumentList = new ArrayList(1);
-		int count = 0;
-		argumentsLoop: while (this.namePos < length) {
-			TypeReference argument = decodeType(typeSignature, length, start, end);
-			count++;
-			argumentList.add(argument);
-			if (this.namePos >= length) break argumentsLoop;
-			if (typeSignature.charAt(this.namePos) == '>') {
-				break argumentsLoop;
-			}
-		}
-		TypeReference[] typeArguments = new TypeReference[count];
-		argumentList.toArray(typeArguments);
-		return typeArguments;
-	}
-	
-	private char[][] extractIdentifiers(String typeSignature, int start, int endInclusive, int identCount) {
-		char[][] result = new char[identCount][];
-		int charIndex = start;
-		int i = 0;
-		while (charIndex < endInclusive) {
-			if (typeSignature.charAt(charIndex) == '.') {
-				typeSignature.getChars(start, charIndex, result[i++] = new char[charIndex - start], 0); 
-				start = ++charIndex;
-			} else
-				charIndex++;
-		}
-		typeSignature.getChars(start, charIndex + 1, result[i++] = new char[charIndex - start + 1], 0); 
-		return result;
-	}
 	
 	private char[] getSource() {
 		if (this.source == null)
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/TypeConverter.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/TypeConverter.java
new file mode 100644
index 0000000..6cd071e
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/TypeConverter.java
@@ -0,0 +1,557 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.parser;
+
+import java.util.ArrayList;
+
+import org.eclipse.jdt.core.Signature;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.ImportReference;
+import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.ast.Wildcard;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
+
+public abstract class TypeConverter {
+	
+	int namePos;
+	
+	protected ProblemReporter problemReporter;
+	protected boolean has1_5Compliance;
+	
+	protected TypeConverter(ProblemReporter problemReporter) {
+		this.problemReporter = problemReporter;
+		this.has1_5Compliance = problemReporter.options.complianceLevel >= ClassFileConstants.JDK1_5;
+	}
+	
+	private void addIdentifiers(String typeSignature, int start, int endExclusive, int identCount, ArrayList fragments) {
+		if (identCount == 1) {
+			char[] identifier;
+			typeSignature.getChars(start, endExclusive, identifier = new char[endExclusive-start], 0);
+			fragments.add(identifier);
+		} else
+			fragments.add(extractIdentifiers(typeSignature, start, endExclusive-1, identCount));
+	}
+	
+	/*
+	 * Build an import reference from an import name, e.g. java.lang.*
+	 */
+	protected ImportReference createImportReference(
+		String[] importName,
+		int start,
+		int end, 
+		boolean onDemand,
+		int modifiers) {
+	
+		int length = importName.length;
+		long[] positions = new long[length];
+		long position = ((long) start << 32) + end;
+		char[][] qImportName = new char[length][];
+		for (int i = 0; i < length; i++) {
+			qImportName[i] = importName[i].toCharArray();
+			positions[i] = position; // dummy positions
+		}
+		return new ImportReference(
+			qImportName,
+			positions,
+			onDemand,
+			modifiers);
+	}
+
+	protected TypeParameter createTypeParameter(char[] typeParameterName, char[][] typeParameterBounds, int start, int end) {
+
+		TypeParameter parameter = new TypeParameter();
+		parameter.name = typeParameterName;
+		parameter.sourceStart = start;
+		parameter.sourceEnd = end;
+		if (typeParameterBounds != null) {
+			int length = typeParameterBounds.length;
+			if (length > 0) {
+				parameter.type = createTypeReference(typeParameterBounds[0], start, end);
+				if (length > 1) {
+					parameter.bounds = new TypeReference[length-1];
+					for (int i = 1; i < length; i++) {
+						TypeReference bound = createTypeReference(typeParameterBounds[i], start, end);
+						bound.bits |= ASTNode.IsSuperType;
+						parameter.bounds[i-1] = bound;
+					}
+				}
+			}
+		}
+		return parameter;
+	}
+	
+	/*
+	 * Build a type reference from a readable name, e.g. java.lang.Object[][]
+	 */
+	protected TypeReference createTypeReference(
+		char[] typeName,
+		int start,
+		int end) {
+
+		int length = typeName.length;
+		this.namePos = 0;
+		return decodeType(typeName, length, start, end);
+	}
+	
+	/*
+	 * Build a type reference from a type signature, e.g. Ljava.lang.Object;
+	 */
+	protected TypeReference createTypeReference(
+			String typeSignature,
+			int start,
+			int end) {
+		
+		int length = typeSignature.length();
+		this.namePos = 0;
+		return decodeType(typeSignature, length, start, end);
+	}
+	
+	private TypeReference decodeType(String typeSignature, int length, int start, int end) {
+		int identCount = 1;
+		int dim = 0;
+		int nameFragmentStart = this.namePos, nameFragmentEnd = -1;
+		boolean nameStarted = false;
+		ArrayList fragments = null;
+		typeLoop: while (this.namePos < length) {
+			char currentChar = typeSignature.charAt(this.namePos);
+			switch (currentChar) {
+				case Signature.C_BOOLEAN :
+					if (!nameStarted) {
+						this.namePos++;
+						if (dim == 0)
+							return new SingleTypeReference(TypeBinding.BOOLEAN.simpleName, ((long) start << 32) + end);
+						else
+							return new ArrayTypeReference(TypeBinding.BOOLEAN.simpleName, dim, ((long) start << 32) + end);
+					} 
+					break;
+				case Signature.C_BYTE :
+					if (!nameStarted) {
+						this.namePos++;
+						if (dim == 0)
+							return new SingleTypeReference(TypeBinding.BYTE.simpleName, ((long) start << 32) + end);
+						else
+							return new ArrayTypeReference(TypeBinding.BYTE.simpleName, dim, ((long) start << 32) + end);				
+					}
+					break;
+				case Signature.C_CHAR :
+					if (!nameStarted) {
+						this.namePos++;
+						if (dim == 0)
+							return new SingleTypeReference(TypeBinding.CHAR.simpleName, ((long) start << 32) + end);
+						else
+							return new ArrayTypeReference(TypeBinding.CHAR.simpleName, dim, ((long) start << 32) + end);
+					}
+					break;
+				case Signature.C_DOUBLE :
+					if (!nameStarted) {
+						this.namePos++;
+						if (dim == 0)
+							return new SingleTypeReference(TypeBinding.DOUBLE.simpleName, ((long) start << 32) + end);
+						else
+							return new ArrayTypeReference(TypeBinding.DOUBLE.simpleName, dim, ((long) start << 32) + end);				
+					}
+					break;
+				case Signature.C_FLOAT :
+					if (!nameStarted) {
+						this.namePos++;
+						if (dim == 0)
+							return new SingleTypeReference(TypeBinding.FLOAT.simpleName, ((long) start << 32) + end);
+						else
+							return new ArrayTypeReference(TypeBinding.FLOAT.simpleName, dim, ((long) start << 32) + end);				
+					}
+					break;
+				case Signature.C_INT :
+					if (!nameStarted) {
+						this.namePos++;
+						if (dim == 0)
+							return new SingleTypeReference(TypeBinding.INT.simpleName, ((long) start << 32) + end);
+						else
+							return new ArrayTypeReference(TypeBinding.INT.simpleName, dim, ((long) start << 32) + end);				
+					}
+					break;
+				case Signature.C_LONG :
+					if (!nameStarted) {
+						this.namePos++;
+						if (dim == 0)
+							return new SingleTypeReference(TypeBinding.LONG.simpleName, ((long) start << 32) + end);
+						else
+							return new ArrayTypeReference(TypeBinding.LONG.simpleName, dim, ((long) start << 32) + end);				
+					}
+					break;
+				case Signature.C_SHORT :
+					if (!nameStarted) {
+						this.namePos++;
+						if (dim == 0)
+							return new SingleTypeReference(TypeBinding.SHORT.simpleName, ((long) start << 32) + end);
+						else
+							return new ArrayTypeReference(TypeBinding.SHORT.simpleName, dim, ((long) start << 32) + end);				
+					}
+					break;
+				case Signature.C_VOID :
+					if (!nameStarted) {
+						this.namePos++;
+						return new SingleTypeReference(TypeBinding.VOID.simpleName, ((long) start << 32) + end);
+					}
+					break;
+				case Signature.C_RESOLVED :
+				case Signature.C_UNRESOLVED :
+				case Signature.C_TYPE_VARIABLE :
+					if (!nameStarted) {
+						nameFragmentStart = this.namePos+1;
+						nameStarted = true;
+					}
+					break;
+				case Signature.C_STAR:
+					this.namePos++;
+					Wildcard result = new Wildcard(Wildcard.UNBOUND);
+					result.sourceStart = start;
+					result.sourceEnd = end;
+					return result;
+				case Signature.C_EXTENDS:
+					this.namePos++;
+					result = new Wildcard(Wildcard.EXTENDS);
+					result.bound = decodeType(typeSignature, length, start, end);
+					result.sourceStart = start;
+					result.sourceEnd = end;
+					return result;
+				case Signature.C_SUPER:
+					this.namePos++;
+					result = new Wildcard(Wildcard.SUPER);
+					result.bound = decodeType(typeSignature, length, start, end);
+					result.sourceStart = start;
+					result.sourceEnd = end;
+					return result;
+				case Signature.C_ARRAY :
+					dim++;
+					break;
+				case Signature.C_GENERIC_END :
+				case Signature.C_SEMICOLON :
+					nameFragmentEnd = this.namePos-1;
+					this.namePos++;
+					break typeLoop;
+				case Signature.C_DOT :
+				case Signature.C_DOLLAR:
+					if (!nameStarted) {
+						nameFragmentStart = this.namePos+1;
+						nameStarted = true;
+					} else if (this.namePos > nameFragmentStart) // handle name starting with a $ (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=91709)
+						identCount ++;
+					break;
+				case Signature.C_GENERIC_START :
+					nameFragmentEnd = this.namePos-1;
+					// convert 1.5 specific constructs only if compliance is 1.5 or above
+					if (!this.has1_5Compliance) 
+						break typeLoop;
+					if (fragments == null) fragments = new ArrayList(2);
+					addIdentifiers(typeSignature, nameFragmentStart, nameFragmentEnd + 1, identCount, fragments);
+					this.namePos++; // skip '<'
+					TypeReference[] arguments = decodeTypeArguments(typeSignature, length, start, end); // positionned on '>' at end
+					fragments.add(arguments);
+					identCount = 1;
+					nameStarted = false;
+					// next increment will skip '>'
+					break;
+			}
+			this.namePos++;
+		}
+		if (fragments == null) { // non parameterized 
+			/* rebuild identifiers and dimensions */
+			if (identCount == 1) { // simple type reference
+				if (dim == 0) {
+					char[] nameFragment = new char[nameFragmentEnd - nameFragmentStart + 1];
+					typeSignature.getChars(nameFragmentStart, nameFragmentEnd +1, nameFragment, 0);
+					return new SingleTypeReference(nameFragment, ((long) start << 32) + end);
+				} else {
+					char[] nameFragment = new char[nameFragmentEnd - nameFragmentStart + 1];
+					typeSignature.getChars(nameFragmentStart, nameFragmentEnd +1, nameFragment, 0);
+					return new ArrayTypeReference(nameFragment, dim, ((long) start << 32) + end);
+				}
+			} else { // qualified type reference
+				long[] positions = new long[identCount];
+				long pos = ((long) start << 32) + end;
+				for (int i = 0; i < identCount; i++) {
+					positions[i] = pos;
+				}
+				char[][] identifiers = extractIdentifiers(typeSignature, nameFragmentStart, nameFragmentEnd, identCount);
+				if (dim == 0) {
+					return new QualifiedTypeReference(identifiers, positions);
+				} else {
+					return new ArrayQualifiedTypeReference(identifiers, dim, positions);
+				}
+			}
+		} else { // parameterized
+			// rebuild type reference from available fragments: char[][], arguments, char[][], arguments...
+			// check trailing qualified name
+			if (nameStarted) {
+				addIdentifiers(typeSignature, nameFragmentStart, nameFragmentEnd + 1, identCount, fragments);
+			}
+			int fragmentLength = fragments.size();
+			if (fragmentLength == 2) {
+				Object firstFragment = fragments.get(0);
+				if (firstFragment instanceof char[]) {
+					// parameterized single type
+					return new ParameterizedSingleTypeReference((char[]) firstFragment, (TypeReference[]) fragments.get(1), dim, ((long) start << 32) + end);
+				}
+			}
+			// parameterized qualified type
+			identCount = 0;
+			for (int i = 0; i < fragmentLength; i ++) {
+				Object element = fragments.get(i);
+				if (element instanceof char[][]) {
+					identCount += ((char[][])element).length;
+				} else if (element instanceof char[])
+					identCount++;
+			}
+			char[][] tokens = new char[identCount][];
+			TypeReference[][] arguments = new TypeReference[identCount][];
+			int index = 0;
+			for (int i = 0; i < fragmentLength; i ++) {
+				Object element = fragments.get(i);
+				if (element instanceof char[][]) {
+					char[][] fragmentTokens = (char[][]) element;
+					int fragmentTokenLength = fragmentTokens.length;
+					System.arraycopy(fragmentTokens, 0, tokens, index, fragmentTokenLength);
+					index += fragmentTokenLength;
+				} else if (element instanceof char[]) {
+					tokens[index++] = (char[]) element;
+				} else {
+					arguments[index-1] = (TypeReference[]) element;
+				}
+			}
+			long[] positions = new long[identCount];
+			long pos = ((long) start << 32) + end;
+			for (int i = 0; i < identCount; i++) {
+				positions[i] = pos;
+			}
+			return new ParameterizedQualifiedTypeReference(tokens, arguments, dim, positions);
+		}
+	}
+	
+	private TypeReference decodeType(char[] typeName, int length, int start, int end) {
+		int identCount = 1;
+		int dim = 0;
+		int nameFragmentStart = this.namePos, nameFragmentEnd = -1;
+		ArrayList fragments = null;
+		typeLoop: while (this.namePos < length) {
+			char currentChar = typeName[this.namePos];
+			switch (currentChar) {
+				case '?' :
+					this.namePos++; // skip '?'
+					while (typeName[this.namePos] == ' ') this.namePos++;
+					switch(typeName[this.namePos]) {
+						case 's' :
+							checkSuper: {
+								int max = TypeConstants.WILDCARD_SUPER.length-1;
+								for (int ahead = 1; ahead < max; ahead++) {
+									if (typeName[this.namePos+ahead] != TypeConstants.WILDCARD_SUPER[ahead+1]) {
+										break checkSuper;
+									}
+								}
+								this.namePos += max;
+								Wildcard result = new Wildcard(Wildcard.SUPER);
+								result.bound = decodeType(typeName, length, start, end);
+								result.sourceStart = start;
+								result.sourceEnd = end;
+								return result;
+							}
+							break;
+						case 'e' :
+							checkExtends: {
+								int max = TypeConstants.WILDCARD_EXTENDS.length-1;
+								for (int ahead = 1; ahead < max; ahead++) {
+									if (typeName[this.namePos+ahead] != TypeConstants.WILDCARD_EXTENDS[ahead+1]) {
+										break checkExtends;
+									}
+								}
+								this.namePos += max;
+								Wildcard result = new Wildcard(Wildcard.EXTENDS);
+								result.bound = decodeType(typeName, length, start, end);
+								result.sourceStart = start;
+								result.sourceEnd = end;
+								return result;
+							}
+							break;
+					}
+					Wildcard result = new Wildcard(Wildcard.UNBOUND);
+					result.sourceStart = start;
+					result.sourceEnd = end;
+					return result;
+				case '[' :
+					if (dim == 0) nameFragmentEnd = this.namePos-1;
+					dim++;
+					break;
+				case ']' :
+					break;
+				case '>' :
+				case ',' :
+					break typeLoop;
+				case '.' :
+					if (nameFragmentStart < 0) nameFragmentStart = this.namePos+1; // member type name
+					identCount ++;
+					break;
+				case '<' :
+					// convert 1.5 specific constructs only if compliance is 1.5 or above
+					if (!this.has1_5Compliance) 
+						break typeLoop;
+					if (fragments == null) fragments = new ArrayList(2);
+					nameFragmentEnd = this.namePos-1;
+					char[][] identifiers = CharOperation.splitOn('.', typeName, nameFragmentStart, this.namePos);
+					fragments.add(identifiers);
+					this.namePos++; // skip '<'
+					TypeReference[] arguments = decodeTypeArguments(typeName, length, start, end); // positionned on '>' at end
+					fragments.add(arguments);
+					identCount = 0;
+					nameFragmentStart = -1;
+					nameFragmentEnd = -1;
+					// next increment will skip '>'
+					break;
+			}
+			this.namePos++;
+		}
+		if (nameFragmentEnd < 0) nameFragmentEnd = this.namePos-1;
+		if (fragments == null) { // non parameterized 
+			/* rebuild identifiers and dimensions */
+			if (identCount == 1) { // simple type reference
+				if (dim == 0) {
+					char[] nameFragment;
+					if (nameFragmentStart != 0 || nameFragmentEnd >= 0) {
+						int nameFragmentLength = nameFragmentEnd - nameFragmentStart + 1;
+						System.arraycopy(typeName, nameFragmentStart, nameFragment = new char[nameFragmentLength], 0, nameFragmentLength);						
+					} else {
+						nameFragment = typeName;
+					}
+					return new SingleTypeReference(nameFragment, ((long) start << 32) + end);
+				} else {
+					int nameFragmentLength = nameFragmentEnd - nameFragmentStart + 1;
+					char[] nameFragment = new char[nameFragmentLength];
+					System.arraycopy(typeName, nameFragmentStart, nameFragment, 0, nameFragmentLength);
+					return new ArrayTypeReference(nameFragment, dim, ((long) start << 32) + end);
+				}
+			} else { // qualified type reference
+				long[] positions = new long[identCount];
+				long pos = ((long) start << 32) + end;
+				for (int i = 0; i < identCount; i++) {
+					positions[i] = pos;
+				}
+				char[][] identifiers = CharOperation.splitOn('.', typeName, nameFragmentStart, nameFragmentEnd+1);
+				if (dim == 0) {
+					return new QualifiedTypeReference(identifiers, positions);
+				} else {
+					return new ArrayQualifiedTypeReference(identifiers, dim, positions);
+				}
+			}
+		} else { // parameterized
+			// rebuild type reference from available fragments: char[][], arguments, char[][], arguments...
+			// check trailing qualified name
+			if (nameFragmentStart > 0 && nameFragmentStart < length) {
+				char[][] identifiers = CharOperation.splitOn('.', typeName, nameFragmentStart, nameFragmentEnd+1);
+				fragments.add(identifiers);
+			}
+			int fragmentLength = fragments.size();
+			if (fragmentLength == 2) {
+				char[][] firstFragment = (char[][]) fragments.get(0);
+				if (firstFragment.length == 1) {
+					// parameterized single type
+					return new ParameterizedSingleTypeReference(firstFragment[0], (TypeReference[]) fragments.get(1), dim, ((long) start << 32) + end);
+				}
+			}
+			// parameterized qualified type
+			identCount = 0;
+			for (int i = 0; i < fragmentLength; i ++) {
+				Object element = fragments.get(i);
+				if (element instanceof char[][]) {
+					identCount += ((char[][])element).length;
+				}
+			}
+			char[][] tokens = new char[identCount][];
+			TypeReference[][] arguments = new TypeReference[identCount][];
+			int index = 0;
+			for (int i = 0; i < fragmentLength; i ++) {
+				Object element = fragments.get(i);
+				if (element instanceof char[][]) {
+					char[][] fragmentTokens = (char[][]) element;
+					int fragmentTokenLength = fragmentTokens.length;
+					System.arraycopy(fragmentTokens, 0, tokens, index, fragmentTokenLength);
+					index += fragmentTokenLength;
+				} else {
+					arguments[index-1] = (TypeReference[]) element;
+				}
+			}
+			long[] positions = new long[identCount];
+			long pos = ((long) start << 32) + end;
+			for (int i = 0; i < identCount; i++) {
+				positions[i] = pos;
+			}
+			return new ParameterizedQualifiedTypeReference(tokens, arguments, dim, positions);
+		}
+	}
+	
+	private TypeReference[] decodeTypeArguments(char[] typeName, int length, int start, int end) {
+		ArrayList argumentList = new ArrayList(1);
+		int count = 0;
+		argumentsLoop: while (this.namePos < length) {
+			TypeReference argument = decodeType(typeName, length, start, end);
+			count++;
+			argumentList.add(argument);
+			if (this.namePos >= length) break argumentsLoop;
+			if (typeName[this.namePos] == '>') {
+				break argumentsLoop;
+			}
+			this.namePos++; // skip ','
+		}
+		TypeReference[] typeArguments = new TypeReference[count];
+		argumentList.toArray(typeArguments);
+		return typeArguments;
+	}
+	
+	private TypeReference[] decodeTypeArguments(String typeSignature, int length, int start, int end) {
+		ArrayList argumentList = new ArrayList(1);
+		int count = 0;
+		argumentsLoop: while (this.namePos < length) {
+			TypeReference argument = decodeType(typeSignature, length, start, end);
+			count++;
+			argumentList.add(argument);
+			if (this.namePos >= length) break argumentsLoop;
+			if (typeSignature.charAt(this.namePos) == Signature.C_GENERIC_END) {
+				break argumentsLoop;
+			}
+		}
+		TypeReference[] typeArguments = new TypeReference[count];
+		argumentList.toArray(typeArguments);
+		return typeArguments;
+	}
+	
+	private char[][] extractIdentifiers(String typeSignature, int start, int endInclusive, int identCount) {
+		char[][] result = new char[identCount][];
+		int charIndex = start;
+		int i = 0;
+		while (charIndex < endInclusive) {
+			if (typeSignature.charAt(charIndex) == Signature.C_DOT || typeSignature.charAt(charIndex) == Signature.C_DOLLAR) {
+				typeSignature.getChars(start, charIndex, result[i++] = new char[charIndex - start], 0); 
+				start = ++charIndex;
+			} else
+				charIndex++;
+		}
+		typeSignature.getChars(start, charIndex + 1, result[i++] = new char[charIndex - start + 1], 0); 
+		return result;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryTypeConverter.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryTypeConverter.java
index 65b57c0..5b052e2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryTypeConverter.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryTypeConverter.java
@@ -14,37 +14,45 @@ import org.eclipse.jdt.core.Flags;
 import org.eclipse.jdt.core.IField;
 import org.eclipse.jdt.core.IMethod;
 import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeParameter;
 import org.eclipse.jdt.core.JavaModelException;
-import org.eclipse.jdt.core.Signature;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
-import org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;
-import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
-import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
+import org.eclipse.jdt.internal.compiler.parser.TypeConverter;
+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.core.util.HashSetOfCharArrayArray;
 import org.eclipse.jdt.internal.core.util.Util;
 
 /**
  * Converter from a binary type to an AST type declaration.
  */
-public class BinaryTypeConverter {
+public class BinaryTypeConverter extends TypeConverter {
 	
-	public static ImportReference[] buildImports(HashSetOfCharArrayArray typeNames, ClassFileReader reader) {
+	private CompilationResult compilationResult;
+	private HashSetOfCharArrayArray typeNames;
+	
+	public BinaryTypeConverter(ProblemReporter problemReporter, CompilationResult compilationResult, HashSetOfCharArrayArray typeNames) {
+		super(problemReporter);
+		this.compilationResult = compilationResult;
+		this.typeNames = typeNames;
+	}
+	
+	public ImportReference[] buildImports(ClassFileReader reader) {
 		// add remaining references to the list of type names
 		// (code extracted from BinaryIndexer#extractReferenceFromConstantPool(...))
 		int[] constantPoolOffsets = reader.getConstantPoolOffsets();
@@ -86,7 +94,7 @@ public class BinaryTypeConverter {
 	/**
 	 * Convert a binary type into an AST type declaration and put it in the given compilation unit.
 	 */
-	public static TypeDeclaration buildTypeDeclaration(IType type, CompilationUnitDeclaration compilationUnit, CompilationResult compilationResult, HashSetOfCharArrayArray typeNames)  throws JavaModelException {
+	public TypeDeclaration buildTypeDeclaration(IType type, CompilationUnitDeclaration compilationUnit)  throws JavaModelException {
 		PackageFragment pkg = (PackageFragment) type.getPackageFragment();
 		char[][] packageName = Util.toCharArrays(pkg.names);
 		
@@ -95,13 +103,13 @@ public class BinaryTypeConverter {
 		}
 	
 		/* convert type */
-		TypeDeclaration typeDeclaration = convert(type, null, null, compilationResult, typeNames);
+		TypeDeclaration typeDeclaration = convert(type, null, null);
 		
 		IType alreadyComputedMember = type;
 		IType parent = type.getDeclaringType();
 		TypeDeclaration previousDeclaration = typeDeclaration;
 		while(parent != null) {
-			TypeDeclaration declaration = convert(parent, alreadyComputedMember, previousDeclaration, compilationResult, typeNames);
+			TypeDeclaration declaration = convert(parent, alreadyComputedMember, previousDeclaration);
 			
 			alreadyComputedMember = parent;
 			previousDeclaration = declaration;
@@ -113,8 +121,8 @@ public class BinaryTypeConverter {
 		return typeDeclaration;
 	}
 	
-	private static FieldDeclaration convert(IField field, IType type, HashSetOfCharArrayArray typeNames) throws JavaModelException {
-		TypeReference typeReference = createTypeReference(Signature.toString(field.getTypeSignature()).toCharArray(), typeNames);
+	private FieldDeclaration convert(IField field, IType type) throws JavaModelException {
+		TypeReference typeReference = createTypeReference(field.getTypeSignature());
 		if (typeReference == null) return null;
 		FieldDeclaration fieldDeclaration = new FieldDeclaration();
 
@@ -125,20 +133,43 @@ public class BinaryTypeConverter {
 		return fieldDeclaration;
 	}
 	
-	private static AbstractMethodDeclaration convert(IMethod method, IType type, CompilationResult compilationResult, HashSetOfCharArrayArray typeNames) throws JavaModelException {
+	private AbstractMethodDeclaration convert(IMethod method, IType type) throws JavaModelException {
 
 		AbstractMethodDeclaration methodDeclaration;
+		
+		org.eclipse.jdt.internal.compiler.ast.TypeParameter[] typeParams = null;
+		
+		// convert 1.5 specific constructs only if compliance is 1.5 or above
+		if (this.has1_5Compliance) {
+			/* convert type parameters */
+			ITypeParameter[] typeParameters = method.getTypeParameters();
+			if (typeParameters != null && typeParameters.length > 0) {
+				int parameterCount = typeParameters.length;
+				typeParams = new org.eclipse.jdt.internal.compiler.ast.TypeParameter[parameterCount];
+				for (int i = 0; i < parameterCount; i++) {
+					ITypeParameter typeParameter = typeParameters[i];
+					typeParams[i] = 
+						createTypeParameter(
+								typeParameter.getElementName().toCharArray(), 
+								stringArrayToCharArray(typeParameter.getBounds()),
+								0,
+								0);
+				}
+			}
+		}
 
 		if (method.isConstructor()) {
 			ConstructorDeclaration decl = new ConstructorDeclaration(compilationResult);
 			decl.bits &= ~ASTNode.IsDefaultConstructor;
+			decl.typeParameters = typeParams;
 			methodDeclaration = decl;
 		} else {
 			MethodDeclaration decl = type.isAnnotation() ? new AnnotationMethodDeclaration(compilationResult) : new MethodDeclaration(compilationResult);
 			/* convert return type */
-			TypeReference typeReference = createTypeReference(Signature.toString(method.getReturnType()).toCharArray(), typeNames);
+			TypeReference typeReference = createTypeReference(method.getReturnType());
 			if (typeReference == null) return null;
 			decl.returnType = typeReference;
+			decl.typeParameters = typeParams;
 			methodDeclaration = decl;
 		}
 		methodDeclaration.selector = method.getElementName().toCharArray();
@@ -156,7 +187,7 @@ public class BinaryTypeConverter {
 		methodDeclaration.arguments = new Argument[argumentCount];
 		for (int i = 0; i < argumentCount; i++) {
 			String argumentTypeName = argumentTypeNames[startIndex+i];
-			TypeReference typeReference = createTypeReference(Signature.toString(argumentTypeName).toCharArray(), typeNames);
+			TypeReference typeReference = createTypeReference(argumentTypeName);
 			if (typeReference == null) return null;
 			if (isVarargs && i == argumentCount-1) {
 				typeReference.bits |= ASTNode.IsVarArgs;
@@ -175,7 +206,7 @@ public class BinaryTypeConverter {
 		if(exceptionCount > 0) {
 			methodDeclaration.thrownExceptions = new TypeReference[exceptionCount];
 			for (int i = 0; i < exceptionCount; i++) {
-				TypeReference typeReference = createTypeReference(Signature.toString(exceptionTypeNames[i]).toCharArray(), typeNames);
+				TypeReference typeReference = createTypeReference(exceptionTypeNames[i]);
 				if (typeReference == null) return null;
 				methodDeclaration.thrownExceptions[i] = typeReference;
 			}
@@ -183,7 +214,7 @@ public class BinaryTypeConverter {
 		return methodDeclaration;
 	}
 	
-	private static TypeDeclaration convert(IType type, IType alreadyComputedMember,TypeDeclaration alreadyComputedMemberDeclaration, CompilationResult compilationResult, HashSetOfCharArrayArray typeNames) throws JavaModelException {
+	private TypeDeclaration convert(IType type, IType alreadyComputedMember,TypeDeclaration alreadyComputedMemberDeclaration) throws JavaModelException {
 		/* create type declaration - can be member type */
 		TypeDeclaration typeDeclaration = new TypeDeclaration(compilationResult);
 
@@ -196,19 +227,19 @@ public class BinaryTypeConverter {
 
 		/* set superclass and superinterfaces */
 		if (type.getSuperclassName() != null) {
-			TypeReference typeReference = createTypeReference(type.getSuperclassName().toCharArray(), typeNames);
+			TypeReference typeReference = createTypeReference(type.getSuperclassTypeSignature());
 			if (typeReference != null) {
 				typeDeclaration.superclass = typeReference;
 				typeDeclaration.superclass.bits |= ASTNode.IsSuperType;
 			}
 		}
 		
-		String[] interfaceNames = type.getSuperInterfaceNames();
-		int interfaceCount = interfaceNames == null ? 0 : interfaceNames.length;
+		String[] interfaceTypes = type.getSuperInterfaceTypeSignatures();
+		int interfaceCount = interfaceTypes == null ? 0 : interfaceTypes.length;
 		typeDeclaration.superInterfaces = new TypeReference[interfaceCount];
 		int count = 0;
 		for (int i = 0; i < interfaceCount; i++) {
-			TypeReference typeReference = createTypeReference(interfaceNames[i].toCharArray(), typeNames);
+			TypeReference typeReference = createTypeReference(interfaceTypes[i]);
 			if (typeReference != null) {
 				typeDeclaration.superInterfaces[count] = typeReference;
 				typeDeclaration.superInterfaces[count++].bits |= ASTNode.IsSuperType;
@@ -218,6 +249,28 @@ public class BinaryTypeConverter {
 			System.arraycopy(typeDeclaration.fields, 0, typeDeclaration.superInterfaces = new TypeReference[interfaceCount], 0, interfaceCount);
 		}
 		
+		// convert 1.5 specific constructs only if compliance is 1.5 or above
+		if (this.has1_5Compliance) {
+			
+			/* convert type parameters */
+			ITypeParameter[] typeParameters = type.getTypeParameters();
+			if (typeParameters != null && typeParameters.length > 0) {
+				int parameterCount = typeParameters.length;
+				org.eclipse.jdt.internal.compiler.ast.TypeParameter[] typeParams = new org.eclipse.jdt.internal.compiler.ast.TypeParameter[parameterCount];
+				for (int i = 0; i < parameterCount; i++) {
+					ITypeParameter typeParameter = typeParameters[i];
+					typeParams[i] = 
+						createTypeParameter(
+								typeParameter.getElementName().toCharArray(), 
+								stringArrayToCharArray(typeParameter.getBounds()),
+								0,
+								0);
+				}
+				
+				typeDeclaration.typeParameters = typeParams;
+			}
+		}
+		
 		/* convert member types */
 		IType[] memberTypes = type.getTypes();
 		int memberTypeCount =	memberTypes == null ? 0 : memberTypes.length;
@@ -226,7 +279,7 @@ public class BinaryTypeConverter {
 			if(alreadyComputedMember != null && alreadyComputedMember.getFullyQualifiedName().equals(memberTypes[i].getFullyQualifiedName())) {
 				typeDeclaration.memberTypes[i] = alreadyComputedMemberDeclaration;
 			} else {
-				typeDeclaration.memberTypes[i] = convert(memberTypes[i], null, null, compilationResult, typeNames);
+				typeDeclaration.memberTypes[i] = convert(memberTypes[i], null, null);
 			}
 		}
 
@@ -236,7 +289,7 @@ public class BinaryTypeConverter {
 		typeDeclaration.fields = new FieldDeclaration[fieldCount];
 		count = 0;
 		for (int i = 0; i < fieldCount; i++) {
-			FieldDeclaration fieldDeclaration = convert(fields[i], type, typeNames);
+			FieldDeclaration fieldDeclaration = convert(fields[i], type);
 			if (fieldDeclaration != null) {
 				typeDeclaration.fields[count++] = fieldDeclaration;
 			}
@@ -268,7 +321,7 @@ public class BinaryTypeConverter {
 		boolean hasAbstractMethods = false;
 		count = 0;
 		for (int i = 0; i < methodCount; i++) {
-			AbstractMethodDeclaration method = convert(methods[i], type, compilationResult, typeNames);
+			AbstractMethodDeclaration method = convert(methods[i], type);
 			if (method != null) {
 				boolean isAbstract;
 				if ((isAbstract = method.isAbstract()) || isInterface) { // fix-up flag 
@@ -289,44 +342,25 @@ public class BinaryTypeConverter {
 		return typeDeclaration;
 	}
 	
-	private static TypeReference createTypeReference(char[] type, HashSetOfCharArrayArray typeNames) {
-		/* count identifiers and dimensions */
-		int max = type.length;
-		int dimStart = max;
-		int dim = 0;
-		int identCount = 1;
-		for (int i = 0; i < max; i++) {
-			switch (type[i]) {
-				case '<' :
-					return null;
-				case '[' :
-					if (dim == 0)
-						dimStart = i;
-					dim++;
-					break;
-				case '.' :
-					identCount++;
-					break;
-			}
+	private static char[][] stringArrayToCharArray(String[] strings) {
+		if (strings == null) return null;
+		
+		int length = strings.length;
+		if (length == 0) return CharOperation.NO_CHAR_CHAR;
+		
+		char[][] result = new char [length][];
+		for (int i = 0; i < length; i++) {
+			result[i] = strings[i].toCharArray();
 		}
-		/* rebuild identifiers and dimensions */
-		if (identCount == 1) { // simple type reference
-			if (dim == 0) {
-				return new SingleTypeReference(type, 0);
-			} else {
-				char[] identifier = new char[dimStart];
-				System.arraycopy(type, 0, identifier, 0, dimStart);
-				return new ArrayTypeReference(identifier, dim, 0);
-			}
-		} else { // qualified type reference
-			char[][] identifiers =	CharOperation.splitOn('.', type, 0, dimStart);
-			if (typeNames != null)
-				typeNames.add(identifiers);
-			if (dim == 0) {
-				return new QualifiedTypeReference(identifiers, new long[identifiers.length]);
-			} else {
-				return new ArrayQualifiedTypeReference(identifiers, dim, new long[identifiers.length]);
-			}
+		
+		return result;
+	}
+	
+	private TypeReference createTypeReference(String typeSignature) {
+		TypeReference result = createTypeReference(typeSignature, 0, 0);
+		if (typeNames != null && result instanceof QualifiedTypeReference) {
+			typeNames.add(((QualifiedTypeReference)result).tokens);
 		}
+		return result;
 	}
 }
