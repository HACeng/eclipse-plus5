commit 316ebf3c8778d533770eaa12593a9b983e065138
Author: Jesper S Moller <jesper@selskabet.org>
Date:   Sat Mar 9 09:10:54 2013 -0500

    Fix and tests for Bug 378674 - "The method can be declared as static" is
    wrong

13	13	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
7	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
index a053da7..5ef1b36 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
@@ -8163,7 +8163,7 @@ private void runStaticWarningConformTest(String fileName, String body) {
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
 //Can be static warning shown in the wrong places, i.e. if the type parameter is used in the signature
-public void _test378674_comment0() {
+public void test378674_comment0() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test<T> {\n" + 
@@ -8186,7 +8186,7 @@ public void _test378674_comment0() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment1b() {
+public void test378674_comment1b() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"import java.util.Collection;\n" +
@@ -8200,7 +8200,7 @@ public void _test378674_comment1b() {
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
 //Can be static warning shown in the wrong places
-public void _test378674_comment1c() {
+public void test378674_comment1c() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"import java.util.Collection;\n" +
@@ -8215,7 +8215,7 @@ public void _test378674_comment1c() {
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
 //Can be static warning shown in the wrong places
-public void _test378674_comment2() {
+public void test378674_comment2() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"public class X<T> {\n" + 
@@ -8227,7 +8227,7 @@ public void _test378674_comment2() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment3() {
+public void test378674_comment3() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test {\n" + 
@@ -8245,7 +8245,7 @@ public void _test378674_comment3() {
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
 //Can be static warning shown in the wrong places
-public void _test378674_comment5a() {
+public void test378674_comment5a() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test<T> {\n" + 
@@ -8268,7 +8268,7 @@ public void _test378674_comment5a() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment5b() {
+public void test378674_comment5b() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test<T> {\n" + 
@@ -8287,7 +8287,7 @@ public void _test378674_comment5b() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment9() {
+public void test378674_comment9() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test<T> {\n" + 
@@ -8305,7 +8305,7 @@ public void _test378674_comment9() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment11() {
+public void test378674_comment11() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test<T> {\n" + 
@@ -8328,7 +8328,7 @@ public void _test378674_comment11() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment21a() {
+public void test378674_comment21a() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"public class X<P extends Exception> {\n" +
@@ -8339,7 +8339,7 @@ public void _test378674_comment21a() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment21b() {
+public void test378674_comment21b() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"public class X<P extends Exception> {\n" +
@@ -8349,7 +8349,7 @@ public void _test378674_comment21b() {
 		"}\n"
 	);
 }//https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment21c() {
+public void test378674_comment21c() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"public class X<P extends Exception> {\n" +
@@ -8362,7 +8362,7 @@ public void _test378674_comment21c() {
 		"}\n"
 	);
 }//https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment21d() {
+public void test378674_comment21d() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"public class X<P extends Exception> {\n" +
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index c121c22..5c61125 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -13,6 +13,8 @@
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -24,7 +26,6 @@ import org.eclipse.jdt.internal.compiler.flow.ExceptionHandlingFlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
@@ -47,6 +48,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 	 */
 	public MethodDeclaration(CompilationResult compilationResult) {
 		super(compilationResult);
+		this.bits |= ASTNode.CanBeStatic; // Start with this assumption, will course correct during resolve.
 	}
 
 	public void analyseCode(ClassScope classScope, FlowContext flowContext, FlowInfo flowInfo) {
@@ -97,17 +99,6 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 			// nullity and mark as assigned
 			analyseArguments(flowInfo);
 
-			if (this.arguments != null) {
-				for (int i = 0, count = this.arguments.length; i < count; i++) {
-					// if this method uses a type parameter declared by the declaring class,
-					// it can't be static. https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-					if (this.arguments[i].binding != null && (this.arguments[i].binding.type instanceof TypeVariableBinding)) {
-						Binding declaringElement = ((TypeVariableBinding)this.arguments[i].binding.type).declaringElement;
-						if (this.binding != null && this.binding.declaringClass == declaringElement)
-							this.bits &= ~ASTNode.CanBeStatic;
-					}
-				}
-			}
 			if (this.binding.declaringClass instanceof MemberTypeBinding && !this.binding.declaringClass.isStatic()) {
 				// method of a non-static member type can't be static.
 				this.bits &= ~ASTNode.CanBeStatic;
@@ -265,9 +256,9 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 					// the method HAS a body --> abstract native modifiers are forbiden
 					if (((this.modifiers & ClassFileConstants.AccNative) != 0) || ((this.modifiers & ClassFileConstants.AccAbstract) != 0))
 						this.scope.problemReporter().methodNeedingNoBody(this);
-					else if (this.binding != null && !this.binding.isStatic() && !(this.binding.declaringClass instanceof LocalTypeBinding) && !returnsUndeclTypeVar) {
-						// Not a method of local type - can be static
-						this.bits |= ASTNode.CanBeStatic;
+					else if (this.binding == null || this.binding.isStatic() || (this.binding.declaringClass instanceof LocalTypeBinding) || returnsUndeclTypeVar) {
+						// Cannot be static for one of the reasons stated above
+						this.bits &= ~ASTNode.CanBeStatic;
 					}
 				}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
index 0145ad3..fc05dc4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
@@ -56,6 +56,7 @@ public class ThisReference extends Reference {
 			methodScope.problemReporter().errorThisSuperInStatic(this);
 			return false;
 		}
+		methodScope.resetEnclosingMethodStaticFlag();
 		return true;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index cdfba59..18faf32 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -12,6 +12,8 @@
  *								bug 387612 - Unreachable catch block...exception is never thrown from the try
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 401456 - Code compiles from javac/intellij, but fails from eclipse
+ *     Jesper S Moller - Contributions for
+ *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -2613,6 +2615,7 @@ public abstract class Scope {
 	*/
 	final Binding getTypeOrPackage(char[] name, int mask, boolean needResolve) {
 		Scope scope = this;
+		MethodScope methodScope = null;
 		ReferenceBinding foundType = null;
 		boolean insideStaticContext = false;
 		boolean insideTypeAnnotation = false;
@@ -2625,7 +2628,7 @@ public abstract class Scope {
 			done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
 				switch (scope.kind) {
 					case METHOD_SCOPE :
-						MethodScope methodScope = (MethodScope) scope;
+						methodScope = (MethodScope) scope;
 						AbstractMethodDeclaration methodDecl = methodScope.referenceMethod();
 						if (methodDecl != null) {
 							if (methodDecl.binding != null) {
@@ -2699,6 +2702,8 @@ public abstract class Scope {
 						if (typeVariable != null) {
 							if (insideStaticContext) // do not consider this type modifiers: access is legite within same type
 								return new ProblemReferenceBinding(new char[][]{name}, typeVariable, ProblemReasons.NonStaticReferenceInStaticContext);
+							else if (methodScope != null)
+								methodScope.resetEnclosingMethodStaticFlag();
 							return typeVariable;
 						}
 						insideStaticContext |= sourceType.isStatic();
commit fd61d3d365e4129ad38d13ee5d665ea318749efb
Author: Jesper S Moller <jesper@selskabet.org>
Date:   Tue Mar 12 07:21:56 2013 -0400

    Fixed Bug 378674 - "The method can be declared as static" is wrong

3	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
3	37	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
2	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
3	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SuperReference.java
3	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
9	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
4	1	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetThisReference.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index fa04bbf..b356327 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,8 @@
  *								bug 185682 - Increment/decrement operators mark local variables as read
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller - Contributions for
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -148,12 +150,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		if (this.receiver.isThis()) {
 			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
 		}
-	} else if (this.receiver.isThis()) {
-		if ((this.receiver.bits & ASTNode.IsImplicitThis) == 0) {
-			// explicit this receiver, not allowed in static context
-			// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-			currentScope.resetEnclosingMethodStaticFlag();
-		}
 	}
 
 	if (valueRequired || currentScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index 988bc5c..942ee02 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -20,6 +20,8 @@
  *							bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller - Contributions for
+ *							Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -50,42 +52,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
 		this.bits |= ASTNode.IsLocalDeclarationReachable; // only set if actually reached
 	}
-	if (this.binding != null && this.type.resolvedType instanceof TypeVariableBinding) {
-		TypeVariableBinding typeVariableBinding = (TypeVariableBinding) this.type.resolvedType;
-		MethodScope methodScope= this.binding.declaringScope.methodScope();
-		if (methodScope != null && methodScope.referenceContext instanceof TypeDeclaration) {
-			// initialization scope
-			methodScope = methodScope.enclosingMethodScope();
-		}
-		AbstractMethodDeclaration methodDeclaration = (methodScope != null) ? methodScope.referenceMethod() : null;
-		if (methodDeclaration != null && methodDeclaration.binding != null) {
-			TypeVariableBinding[] typeVariables = methodDeclaration.binding.typeVariables();
-			if (typeVariables == null) typeVariables = Binding.NO_TYPE_VARIABLES;
-			if (typeVariables == Binding.NO_TYPE_VARIABLES) {
-				// Method declares no type variables.
-				if (typeVariableBinding != null && typeVariableBinding.declaringElement instanceof TypeBinding)
-					currentScope.resetDeclaringClassMethodStaticFlag((TypeBinding) typeVariableBinding.declaringElement);
-				else
-					currentScope.resetEnclosingMethodStaticFlag();
-			} else {
-				// to check whether the resolved type for this is declared by enclosing method as a type variable
-				boolean usesEnclosingTypeVar = false; 
-				for (int i = 0; i < typeVariables.length ; i ++) {
-					if (typeVariables[i] == this.type.resolvedType){
-						usesEnclosingTypeVar = true;
-						break;
-					}
-				}
-				if (!usesEnclosingTypeVar) {
-					// uses a type variable not declared by enclosing method
-					if (typeVariableBinding != null && typeVariableBinding.declaringElement instanceof TypeBinding)
-						currentScope.resetDeclaringClassMethodStaticFlag((TypeBinding) typeVariableBinding.declaringElement);
-					else
-						currentScope.resetEnclosingMethodStaticFlag();
-				}
-			}
-		}
-	}
 	if (this.initialization == null) {
 		return flowInfo;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index a6e6bdb..eccddf4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -24,6 +24,8 @@
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
+ *     Jesper S Moller - Contributions for
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -122,11 +124,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			// accessing non-static method without an object
 			currentScope.resetDeclaringClassMethodStaticFlag(this.actualReceiverType);
 		}
-	} else if (this.receiver.isThis()) {
-		if ((this.receiver.bits & ASTNode.IsImplicitThis) == 0) {
-			// explicit this receiver, not allowed in static context
-			currentScope.resetEnclosingMethodStaticFlag();
-		}
 	}
 
 	if (this.arguments != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 5c61125..3675b46 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -48,7 +48,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 	 */
 	public MethodDeclaration(CompilationResult compilationResult) {
 		super(compilationResult);
-		this.bits |= ASTNode.CanBeStatic; // Start with this assumption, will course correct during resolve.
+		this.bits |= ASTNode.CanBeStatic; // Start with this assumption, will course correct during resolve and analyseCode.
 	}
 
 	public void analyseCode(ClassScope classScope, FlowContext flowContext, FlowInfo flowInfo) {
@@ -253,7 +253,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 						if ((this.modifiers & ClassFileConstants.AccAbstract) == 0)
 							this.scope.problemReporter().methodNeedBody(this);
 				} else {
-					// the method HAS a body --> abstract native modifiers are forbiden
+					// the method HAS a body --> abstract native modifiers are forbidden
 					if (((this.modifiers & ClassFileConstants.AccNative) != 0) || ((this.modifiers & ClassFileConstants.AccAbstract) != 0))
 						this.scope.problemReporter().methodNeedingNoBody(this);
 					else if (this.binding == null || this.binding.isStatic() || (this.binding.declaringClass instanceof LocalTypeBinding) || returnsUndeclTypeVar) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SuperReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SuperReference.java
index 5444d2a..6dafc92 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SuperReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SuperReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,12 +7,12 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Jesper S Moller - Contributions for
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
-import org.eclipse.jdt.internal.compiler.flow.FlowContext;
-import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
@@ -68,9 +68,4 @@ public class SuperReference extends ThisReference {
 		visitor.visit(this, blockScope);
 		visitor.endVisit(this, blockScope);
 	}
-	
-	public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, boolean valueRequired) {
-		currentScope.resetEnclosingMethodStaticFlag();
-		return analyseCode(currentScope, flowContext, flowInfo);
-	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
index fc05dc4..9fc8015 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,8 @@
  *     Stephan Herrmann - Contribution for
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller - Contributions for
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -131,13 +133,4 @@ public class ThisReference extends Reference {
 		visitor.visit(this, blockScope);
 		visitor.endVisit(this, blockScope);
 	}
-
-	public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
-		if (!isImplicitThis()) {
-			// explicit this reference, not allowed in static context
-			// https://bugs.eclipse.org/bugs/show_bug.cgi?id=335780
-			currentScope.resetEnclosingMethodStaticFlag();
-		}
-		return super.analyseCode(currentScope, flowContext, flowInfo);
-	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 18faf32..63ffa15 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -13,7 +13,7 @@
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 401456 - Code compiles from javac/intellij, but fails from eclipse
  *     Jesper S Moller - Contributions for
- *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1712,13 +1712,14 @@ public abstract class Scope {
 				ProblemFieldBinding foundInsideProblem = null;
 				// inside Constructor call or inside static context
 				Scope scope = this;
+				MethodScope methodScope = null;
 				int depth = 0;
 				int foundDepth = 0;
 				ReferenceBinding foundActualReceiverType = null;
 				done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
 					switch (scope.kind) {
 						case METHOD_SCOPE :
-							MethodScope methodScope = (MethodScope) scope;
+							methodScope = (MethodScope) scope;
 							insideStaticContext |= methodScope.isStatic;
 							insideConstructorCall |= methodScope.isConstructorCall;
 							insideTypeAnnotation = methodScope.insideTypeAnnotation;
@@ -1777,6 +1778,8 @@ public abstract class Scope {
 														fieldBinding.declaringClass,
 														name,
 														ProblemReasons.NonStaticReferenceInStaticContext);
+											} else if (methodScope != null) {
+												methodScope.resetEnclosingMethodStaticFlag();
 											}
 										}
 										if (receiverType == fieldBinding.declaringClass || compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4) {
@@ -2078,6 +2081,7 @@ public abstract class Scope {
 		MethodBinding foundProblem = null;
 		boolean foundProblemVisible = false;
 		Scope scope = this;
+		MethodScope methodScope = null;
 		int depth = 0;
 		// in 1.4 mode (inherited visible shadows enclosing)
 		CompilerOptions options;
@@ -2086,7 +2090,7 @@ public abstract class Scope {
 		done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
 			switch (scope.kind) {
 				case METHOD_SCOPE :
-					MethodScope methodScope = (MethodScope) scope;
+					methodScope = (MethodScope) scope;
 					insideStaticContext |= methodScope.isStatic;
 					insideConstructorCall |= methodScope.isConstructorCall;
 					insideTypeAnnotation = methodScope.insideTypeAnnotation;
@@ -2113,6 +2117,8 @@ public abstract class Scope {
 											insideConstructorCall
 												? ProblemReasons.NonStaticReferenceInConstructorInvocation
 												: ProblemReasons.NonStaticReferenceInStaticContext);
+									} else if (!methodBinding.isStatic() && methodScope != null) {
+										methodScope.resetDeclaringClassMethodStaticFlag(receiverType);
 									}
 									if (inheritedHasPrecedence
 											|| receiverType == methodBinding.declaringClass
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetThisReference.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetThisReference.java
index bf04e4d..53b874a 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetThisReference.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetThisReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Jesper S Moller - Contributions for
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.eval;
 
@@ -54,6 +56,7 @@ public class CodeSnippetThisReference extends ThisReference implements Evaluatio
 			methodScope.problemReporter().errorThisSuperInStatic(this);
 			return false;
 		}
+		methodScope.resetEnclosingMethodStaticFlag();
 		return true;
 	}
 	
commit 0e5525e75974b87507b4096f39e2bf9ccadfbfad
Author: Jesper S Moller <jesper@selskabet.org>
Date:   Sat Mar 16 05:59:32 2013 -0400

    Fixed Bug 378674 - "The method can be declared as static" is wrong

5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
0	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
0	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
6	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
3	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java
3	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
5	1	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 84a0d64..5c60a59 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,6 +17,8 @@
  *							bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *							bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -93,6 +95,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		// allocating a non-static member type without an enclosing instance of parent type
 		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=335845
 		currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass.enclosingType());
+		// Reviewed for https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674 :
+		// The corresponding problem (when called from static) is not produced until during code generation
 	}
 	manageEnclosingInstanceAccessIfNecessary(currentScope, flowInfo);
 	manageSyntheticAccessIfNecessary(currentScope, flowInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index b356327..446c8f0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -123,17 +123,6 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			flowInfo.markAsDefinitelyAssigned(this.binding);
 		}		
 	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-	if (!this.binding.isStatic()) {
-		if (this.receiver.isThis()) {
-			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
-		}
-	} else if (this.receiver.isThis()) {
-		if ((this.receiver.bits & ASTNode.IsImplicitThis) == 0) {
-			// explicit this, not allowed in static context
-			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
-		}
-	}
 	return flowInfo;
 }
 
@@ -146,10 +135,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	this.receiver.analyseCode(currentScope, flowContext, flowInfo, nonStatic);
 	if (nonStatic) {
 		this.receiver.checkNPE(currentScope, flowContext, flowInfo);
-		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-		if (this.receiver.isThis()) {
-			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
-		}
 	}
 
 	if (valueRequired || currentScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index eccddf4..55ab21b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -119,11 +119,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 
 	if (nonStatic) {
 		this.receiver.checkNPE(currentScope, flowContext, flowInfo);
-		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-		if (this.receiver.isThis() || this.receiver.isSuper()) {
-			// accessing non-static method without an object
-			currentScope.resetDeclaringClassMethodStaticFlag(this.actualReceiverType);
-		}
 	}
 
 	if (this.arguments != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 462688d..178d838 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,7 +16,9 @@
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 395977 - [compiler][resource] Resource leak warning behavior possibly incorrect for anonymous inner class
- *******************************************************************************/
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
+ ******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
@@ -73,6 +75,8 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				if (superclass != null && superclass.isMemberType() && !superclass.isStatic()) {
 					// creating an anonymous type of a non-static member type without an enclosing instance of parent type
 					currentScope.resetDeclaringClassMethodStaticFlag(superclass.enclosingType());
+					// Reviewed for https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674 :
+					// The corresponding problem (when called from static) is not produced until during code generation
 				}
 			}
 			
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index 60aa97f..13a8c1d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,6 +15,8 @@
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -88,9 +90,6 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 					currentScope.problemReporter().uninitializedBlankFinalField(lastFieldBinding, this);
 				}
 			}
-			if (!lastFieldBinding.isStatic()) {
-				currentScope.resetDeclaringClassMethodStaticFlag(lastFieldBinding.declaringClass);
-			}
 			break;
 		case Binding.LOCAL :
 			// first binding is a local variable
@@ -198,9 +197,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 					}
 				}
 			}
-			if (!fieldBinding.isStatic()) {
-				currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
-			}
 			break;
 		case Binding.LOCAL : // reading a local variable
 			LocalVariableBinding localBinding;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java
index 10e964c..687225f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -102,6 +104,9 @@ public class QualifiedThisReference extends ThisReference {
 		if (this.currentCompatibleType == null) {
 			scope.problemReporter().noSuchEnclosingInstance(type, this, false);
 			return this.resolvedType;
+		} else {
+			// Mark all methods between here and the declared type as not static
+			scope.resetDeclaringClassMethodStaticFlag(this.currentCompatibleType);
 		}
 
 		// Ensure one cannot write code like: B() { super(B.this); }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
index 411f14b..65de136 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,8 @@
  *								bug 185682 - Increment/decrement operators mark local variables as read
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -74,10 +76,6 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 						currentScope.problemReporter().uninitializedBlankFinalField(fieldBinding, this);
 					}
 				}
-				if (!fieldBinding.isStatic()) {
-					// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-					currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
-				}
 				manageSyntheticAccessIfNecessary(currentScope, flowInfo, true /*read-access*/);
 				break;
 			case Binding.LOCAL : // reading a local variable
@@ -125,10 +123,6 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				// record assignment for detecting uninitialized non-null fields:
 				flowInfo.markAsDefinitelyAssigned(fieldBinding);
 			}
-			if (!fieldBinding.isStatic()) {
-				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-				currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
-			}
 			break;
 		case Binding.LOCAL : // assigning to a local variable
 			LocalVariableBinding localBinding = (LocalVariableBinding) this.binding;
@@ -178,10 +172,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 					currentScope.problemReporter().uninitializedBlankFinalField(fieldBinding, this);
 				}
 			}
-			if (!fieldBinding.isStatic()) {
-				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-				currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
-			}
 			break;
 		case Binding.LOCAL : // reading a local variable
 			LocalVariableBinding localBinding;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
index 40bdb8e..950a2d4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,6 +16,8 @@
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 379784 - [compiler] "Method can be static" is not getting reported
  *								bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -550,6 +552,8 @@ public Binding getBinding(char[][] compoundName, int mask, InvocationSite invoca
 				field.declaringClass,
 				CharOperation.concatWith(CharOperation.subarray(compoundName, 0, currentIndex), '.'),
 				ProblemReasons.NonStaticReferenceInStaticContext);
+		// Since a qualified reference must be for a static member, it won't affect static-ness of the enclosing method, 
+		// so we don't have to call resetEnclosingMethodStaticFlag() in this case
 		return binding;
 	}
 	if ((mask & Binding.TYPE) != 0 && (binding instanceof ReferenceBinding)) {
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
index 4ec8e3e..9d96645 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.eval;
 
@@ -503,6 +505,8 @@ public Binding getBinding(char[][] compoundName, int mask, InvocationSite invoca
 					CharOperation.concatWith(CharOperation.subarray(compoundName, 0, currentIndex), '.'),
 					ProblemReasons.NonStaticReferenceInStaticContext);
 		}
+		// Since a qualified reference must be for a static member, it won't affect static-ness of the enclosing method, 
+		// so we don't have to call resetEnclosingMethodStaticFlag() in this case
 		return binding;
 	}
 	if ((mask & Binding.TYPE) != 0 && (binding instanceof ReferenceBinding)) { // was looking for a type and found a type
commit fd21f493e3168b87fbe342edd55057dcfebdb3df
Author: Jesper S Moller <jesper@selskabet.org>
Date:   Sat Mar 9 09:10:54 2013 -0500

    Fix and tests for Bug 378674 - "The method can be declared as static" is
    wrong

13	13	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
6	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
5	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
index a053da7..5ef1b36 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProblemTypeAndMethodTest.java
@@ -8163,7 +8163,7 @@ private void runStaticWarningConformTest(String fileName, String body) {
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
 //Can be static warning shown in the wrong places, i.e. if the type parameter is used in the signature
-public void _test378674_comment0() {
+public void test378674_comment0() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test<T> {\n" + 
@@ -8186,7 +8186,7 @@ public void _test378674_comment0() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment1b() {
+public void test378674_comment1b() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"import java.util.Collection;\n" +
@@ -8200,7 +8200,7 @@ public void _test378674_comment1b() {
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
 //Can be static warning shown in the wrong places
-public void _test378674_comment1c() {
+public void test378674_comment1c() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"import java.util.Collection;\n" +
@@ -8215,7 +8215,7 @@ public void _test378674_comment1c() {
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
 //Can be static warning shown in the wrong places
-public void _test378674_comment2() {
+public void test378674_comment2() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"public class X<T> {\n" + 
@@ -8227,7 +8227,7 @@ public void _test378674_comment2() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment3() {
+public void test378674_comment3() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test {\n" + 
@@ -8245,7 +8245,7 @@ public void _test378674_comment3() {
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
 //Can be static warning shown in the wrong places
-public void _test378674_comment5a() {
+public void test378674_comment5a() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test<T> {\n" + 
@@ -8268,7 +8268,7 @@ public void _test378674_comment5a() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment5b() {
+public void test378674_comment5b() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test<T> {\n" + 
@@ -8287,7 +8287,7 @@ public void _test378674_comment5b() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment9() {
+public void test378674_comment9() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test<T> {\n" + 
@@ -8305,7 +8305,7 @@ public void _test378674_comment9() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment11() {
+public void test378674_comment11() {
 	runStaticWarningConformTest(
 		"Test.java", 
 		"public class Test<T> {\n" + 
@@ -8328,7 +8328,7 @@ public void _test378674_comment11() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment21a() {
+public void test378674_comment21a() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"public class X<P extends Exception> {\n" +
@@ -8339,7 +8339,7 @@ public void _test378674_comment21a() {
 	);
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment21b() {
+public void test378674_comment21b() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"public class X<P extends Exception> {\n" +
@@ -8349,7 +8349,7 @@ public void _test378674_comment21b() {
 		"}\n"
 	);
 }//https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment21c() {
+public void test378674_comment21c() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"public class X<P extends Exception> {\n" +
@@ -8362,7 +8362,7 @@ public void _test378674_comment21c() {
 		"}\n"
 	);
 }//https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674
-public void _test378674_comment21d() {
+public void test378674_comment21d() {
 	runStaticWarningConformTest(
 		"X.java", 
 		"public class X<P extends Exception> {\n" +
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index e7f7ba2..b9e3535 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -18,6 +18,8 @@
  *								bug 368546 - [compiler][resource] Avoid remaining false positives found when compiling the Eclipse SDK
  *								bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -31,7 +33,6 @@ import org.eclipse.jdt.internal.compiler.flow.ExceptionHandlingFlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
@@ -56,6 +57,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 	 */
 	public MethodDeclaration(CompilationResult compilationResult) {
 		super(compilationResult);
+		this.bits |= ASTNode.CanBeStatic; // Start with this assumption, will course correct during resolve.
 	}
 
 	public void analyseCode(ClassScope classScope, FlowContext flowContext, FlowInfo flowInfo) {
@@ -106,18 +108,6 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 			// nullity and mark as assigned
 			analyseArguments(flowInfo, this.arguments, this.binding);
 
-			if (this.arguments != null) {
-				for (int i = 0, count = this.arguments.length; i < count; i++) {
-					this.bits |= (this.arguments[i].bits & ASTNode.HasTypeAnnotations);
-					// if this method uses a type parameter declared by the declaring class,
-					// it can't be static. https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-					if (this.arguments[i].binding != null && (this.arguments[i].binding.type instanceof TypeVariableBinding)) {
-						Binding declaringElement = ((TypeVariableBinding)this.arguments[i].binding.type).declaringElement;
-						if (this.binding != null && this.binding.declaringClass == declaringElement)
-							this.bits &= ~ASTNode.CanBeStatic;
-					}
-				}
-			}
 			if (this.binding.declaringClass instanceof MemberTypeBinding && !this.binding.declaringClass.isStatic()) {
 				// method of a non-static member type can't be static.
 				this.bits &= ~ASTNode.CanBeStatic;
@@ -289,9 +279,9 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 					// the method HAS a body --> abstract native modifiers are forbiden
 					if (((this.modifiers & ClassFileConstants.AccNative) != 0) || ((this.modifiers & ClassFileConstants.AccAbstract) != 0))
 						this.scope.problemReporter().methodNeedingNoBody(this);
-					else if (this.binding != null && !this.binding.isStatic() && !(this.binding.declaringClass instanceof LocalTypeBinding) && !returnsUndeclTypeVar) {
-						// Not a method of local type - can be static
-						this.bits |= ASTNode.CanBeStatic;
+					else if (this.binding == null || this.binding.isStatic() || (this.binding.declaringClass instanceof LocalTypeBinding) || returnsUndeclTypeVar) {
+						// Cannot be static for one of the reasons stated above
+						this.bits &= ~ASTNode.CanBeStatic;
 					}
 				}
 				break;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
index 8e676fb..b7f8d4d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
@@ -56,6 +56,7 @@ public class ThisReference extends Reference {
 			methodScope.problemReporter().errorThisSuperInStatic(this);
 			return false;
 		}
+		methodScope.resetEnclosingMethodStaticFlag();
 		return true;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 80a1b6a..b5a51ea 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -15,12 +15,9 @@
  *	 							bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 387612 - Unreachable catch block...exception is never thrown from the try
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
-<<<<<<< BETA_JAVA8
+ *								bug 401456 - Code compiles from javac/intellij, but fails from eclipse
  *     Jesper S Moller - Contributions for
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
-=======
- *								bug 401456 - Code compiles from javac/intellij, but fails from eclipse
->>>>>>> 8200b6c Bug 401456 - Code compiles from javac/intellij, but fails from eclipse
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -2667,6 +2664,7 @@ public abstract class Scope {
 	*/
 	final Binding getTypeOrPackage(char[] name, int mask, boolean needResolve) {
 		Scope scope = this;
+		MethodScope methodScope = null;
 		ReferenceBinding foundType = null;
 		boolean insideStaticContext = false;
 		boolean insideTypeAnnotation = false;
@@ -2679,7 +2677,7 @@ public abstract class Scope {
 			done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
 				switch (scope.kind) {
 					case METHOD_SCOPE :
-						MethodScope methodScope = (MethodScope) scope;
+						methodScope = (MethodScope) scope;
 						AbstractMethodDeclaration methodDecl = methodScope.referenceMethod();
 						if (methodDecl != null) {
 							if (methodDecl.binding != null) {
@@ -2753,6 +2751,8 @@ public abstract class Scope {
 						if (typeVariable != null) {
 							if (insideStaticContext) // do not consider this type modifiers: access is legite within same type
 								return new ProblemReferenceBinding(new char[][]{name}, typeVariable, ProblemReasons.NonStaticReferenceInStaticContext);
+							else if (methodScope != null)
+								methodScope.resetEnclosingMethodStaticFlag();
 							return typeVariable;
 						}
 						insideStaticContext |= sourceType.isStatic();
commit 97db7e90ccc840cc657b10cff644c6263b14fb3a
Author: Jesper S Moller <jesper@selskabet.org>
Date:   Tue Mar 12 07:21:56 2013 -0400

    Fixed Bug 378674 - "The method can be declared as static" is wrong

3	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
2	36	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
2	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
3	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SuperReference.java
3	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
9	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
4	1	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetThisReference.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index 7f6393d..e195511 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -11,6 +11,8 @@
  *								bug 185682 - Increment/decrement operators mark local variables as read
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller - Contributions for
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -148,12 +150,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		if (this.receiver.isThis()) {
 			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
 		}
-	} else if (this.receiver.isThis()) {
-		if ((this.receiver.bits & ASTNode.IsImplicitThis) == 0) {
-			// explicit this receiver, not allowed in static context
-			// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-			currentScope.resetEnclosingMethodStaticFlag();
-		}
 	}
 
 	if (valueRequired || currentScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index 8dd6c14..0393635 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -24,6 +24,8 @@
  *							bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *							bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *							bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller - Contributions for
+ *							Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -57,42 +59,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
 		this.bits |= ASTNode.IsLocalDeclarationReachable; // only set if actually reached
 	}
-	if (this.binding != null && this.type.resolvedType instanceof TypeVariableBinding) {
-		TypeVariableBinding typeVariableBinding = (TypeVariableBinding) this.type.resolvedType;
-		MethodScope methodScope= this.binding.declaringScope.methodScope();
-		if (methodScope != null && methodScope.referenceContext instanceof TypeDeclaration) {
-			// initialization scope
-			methodScope = methodScope.enclosingMethodScope();
-		}
-		AbstractMethodDeclaration methodDeclaration = (methodScope != null) ? methodScope.referenceMethod() : null;
-		if (methodDeclaration != null && methodDeclaration.binding != null) {
-			TypeVariableBinding[] typeVariables = methodDeclaration.binding.typeVariables();
-			if (typeVariables == null) typeVariables = Binding.NO_TYPE_VARIABLES;
-			if (typeVariables == Binding.NO_TYPE_VARIABLES) {
-				// Method declares no type variables.
-				if (typeVariableBinding != null && typeVariableBinding.declaringElement instanceof TypeBinding)
-					currentScope.resetDeclaringClassMethodStaticFlag((TypeBinding) typeVariableBinding.declaringElement);
-				else
-					currentScope.resetEnclosingMethodStaticFlag();
-			} else {
-				// to check whether the resolved type for this is declared by enclosing method as a type variable
-				boolean usesEnclosingTypeVar = false; 
-				for (int i = 0; i < typeVariables.length ; i ++) {
-					if (typeVariables[i] == this.type.resolvedType){
-						usesEnclosingTypeVar = true;
-						break;
-					}
-				}
-				if (!usesEnclosingTypeVar) {
-					// uses a type variable not declared by enclosing method
-					if (typeVariableBinding != null && typeVariableBinding.declaringElement instanceof TypeBinding)
-						currentScope.resetDeclaringClassMethodStaticFlag((TypeBinding) typeVariableBinding.declaringElement);
-					else
-						currentScope.resetEnclosingMethodStaticFlag();
-				}
-			}
-		}
-	}
 	if (this.initialization == null) {
 		return flowInfo;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 726fcfe..0ef3fc3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -31,6 +31,8 @@
  *								bug 382069 - [null] Make the null analysis consider JUnit's assertNotNull similarly to assertions
  *								bug 382350 - [1.8][compiler] Unable to invoke inherited default method via I.super.m() syntax
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
+ *     Jesper S Moller - Contributions for
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -132,11 +134,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			// accessing non-static method without an object
 			currentScope.resetDeclaringClassMethodStaticFlag(this.actualReceiverType);
 		}
-	} else if (this.receiver.isThis()) {
-		if ((this.receiver.bits & ASTNode.IsImplicitThis) == 0) {
-			// explicit this receiver, not allowed in static context
-			currentScope.resetEnclosingMethodStaticFlag();
-		}
 	}
 
 	if (this.arguments != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index b9e3535..c68500d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -57,7 +57,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 	 */
 	public MethodDeclaration(CompilationResult compilationResult) {
 		super(compilationResult);
-		this.bits |= ASTNode.CanBeStatic; // Start with this assumption, will course correct during resolve.
+		this.bits |= ASTNode.CanBeStatic; // Start with this assumption, will course correct during resolve and analyseCode.
 	}
 
 	public void analyseCode(ClassScope classScope, FlowContext flowContext, FlowInfo flowInfo) {
@@ -276,7 +276,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 						if ((this.modifiers & ClassFileConstants.AccAbstract) == 0)
 							this.scope.problemReporter().methodNeedBody(this);
 				} else {
-					// the method HAS a body --> abstract native modifiers are forbiden
+					// the method HAS a body --> abstract native modifiers are forbidden
 					if (((this.modifiers & ClassFileConstants.AccNative) != 0) || ((this.modifiers & ClassFileConstants.AccAbstract) != 0))
 						this.scope.problemReporter().methodNeedingNoBody(this);
 					else if (this.binding == null || this.binding.isStatic() || (this.binding.declaringClass instanceof LocalTypeBinding) || returnsUndeclTypeVar) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SuperReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SuperReference.java
index 5444d2a..6dafc92 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SuperReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SuperReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,12 +7,12 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Jesper S Moller - Contributions for
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
-import org.eclipse.jdt.internal.compiler.flow.FlowContext;
-import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
@@ -68,9 +68,4 @@ public class SuperReference extends ThisReference {
 		visitor.visit(this, blockScope);
 		visitor.endVisit(this, blockScope);
 	}
-	
-	public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, boolean valueRequired) {
-		currentScope.resetEnclosingMethodStaticFlag();
-		return analyseCode(currentScope, flowContext, flowInfo);
-	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
index b7f8d4d..d5c019a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThisReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,8 @@
  *     Stephan Herrmann - Contribution for
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller - Contributions for
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -135,13 +137,4 @@ public class ThisReference extends Reference {
 		visitor.visit(this, blockScope);
 		visitor.endVisit(this, blockScope);
 	}
-
-	public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
-		if (!isImplicitThis()) {
-			// explicit this reference, not allowed in static context
-			// https://bugs.eclipse.org/bugs/show_bug.cgi?id=335780
-			currentScope.resetEnclosingMethodStaticFlag();
-		}
-		return super.analyseCode(currentScope, flowContext, flowInfo);
-	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index b5a51ea..ddefbf9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -17,7 +17,7 @@
  *								bug 395002 - Self bound generic class doesn't resolve bounds properly for wildcards for certain parametrisation.
  *								bug 401456 - Code compiles from javac/intellij, but fails from eclipse
  *     Jesper S Moller - Contributions for
- *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1748,6 +1748,7 @@ public abstract class Scope {
 				ProblemFieldBinding foundInsideProblem = null;
 				// inside Constructor call or inside static context
 				Scope scope = this;
+				MethodScope methodScope = null;
 				int depth = 0;
 				int foundDepth = 0;
 				boolean shouldTrackOuterLocals = false;
@@ -1755,7 +1756,7 @@ public abstract class Scope {
 				done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
 					switch (scope.kind) {
 						case METHOD_SCOPE :
-							MethodScope methodScope = (MethodScope) scope;
+							methodScope = (MethodScope) scope;
 							insideStaticContext |= methodScope.isStatic;
 							insideConstructorCall |= methodScope.isConstructorCall;
 							insideTypeAnnotation = methodScope.insideTypeAnnotation;
@@ -1823,6 +1824,8 @@ public abstract class Scope {
 														fieldBinding.declaringClass,
 														name,
 														ProblemReasons.NonStaticReferenceInStaticContext);
+											} else if (methodScope != null) {
+												methodScope.resetEnclosingMethodStaticFlag();
 											}
 										}
 										if (receiverType == fieldBinding.declaringClass || compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4) {
@@ -2127,6 +2130,7 @@ public abstract class Scope {
 		MethodBinding foundProblem = null;
 		boolean foundProblemVisible = false;
 		Scope scope = this;
+		MethodScope methodScope = null;
 		int depth = 0;
 		// in 1.4 mode (inherited visible shadows enclosing)
 		CompilerOptions options;
@@ -2135,7 +2139,7 @@ public abstract class Scope {
 		done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
 			switch (scope.kind) {
 				case METHOD_SCOPE :
-					MethodScope methodScope = (MethodScope) scope;
+					methodScope = (MethodScope) scope;
 					insideStaticContext |= methodScope.isStatic;
 					insideConstructorCall |= methodScope.isConstructorCall;
 					insideTypeAnnotation = methodScope.insideTypeAnnotation;
@@ -2162,6 +2166,8 @@ public abstract class Scope {
 											insideConstructorCall
 												? ProblemReasons.NonStaticReferenceInConstructorInvocation
 												: ProblemReasons.NonStaticReferenceInStaticContext);
+									} else if (!methodBinding.isStatic() && methodScope != null) {
+										methodScope.resetDeclaringClassMethodStaticFlag(receiverType);
 									}
 									if (inheritedHasPrecedence
 											|| receiverType == methodBinding.declaringClass
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetThisReference.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetThisReference.java
index bf04e4d..53b874a 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetThisReference.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetThisReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Jesper S Moller - Contributions for
+ *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.eval;
 
@@ -54,6 +56,7 @@ public class CodeSnippetThisReference extends ThisReference implements Evaluatio
 			methodScope.problemReporter().errorThisSuperInStatic(this);
 			return false;
 		}
+		methodScope.resetEnclosingMethodStaticFlag();
 		return true;
 	}
 	
commit eeafa6d90df04799bdbc84b253f50d4f1ea630a2
Author: Jesper S Moller <jesper@selskabet.org>
Date:   Wed Apr 3 11:54:58 2013 +0530

    Fixed Bug 378674 - "The method can be declared as static" is wrong

4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
0	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
0	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
2	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java
3	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
5	1	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 2e81bd0..895a7f8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -21,6 +21,8 @@
  *							bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *							bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -98,6 +100,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		// allocating a non-static member type without an enclosing instance of parent type
 		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=335845
 		currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass.enclosingType());
+		// Reviewed for https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674 :
+		// The corresponding problem (when called from static) is not produced until during code generation
 	}
 	manageEnclosingInstanceAccessIfNecessary(currentScope, flowInfo);
 	manageSyntheticAccessIfNecessary(currentScope, flowInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index e195511..772bb94 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -123,17 +123,6 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 			flowInfo.markAsDefinitelyAssigned(this.binding);
 		}		
 	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-	if (!this.binding.isStatic()) {
-		if (this.receiver.isThis()) {
-			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
-		}
-	} else if (this.receiver.isThis()) {
-		if ((this.receiver.bits & ASTNode.IsImplicitThis) == 0) {
-			// explicit this, not allowed in static context
-			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
-		}
-	}
 	return flowInfo;
 }
 
@@ -146,10 +135,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	this.receiver.analyseCode(currentScope, flowContext, flowInfo, nonStatic);
 	if (nonStatic) {
 		this.receiver.checkNPE(currentScope, flowContext, flowInfo);
-		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-		if (this.receiver.isThis()) {
-			currentScope.resetDeclaringClassMethodStaticFlag(this.binding.declaringClass);
-		}
 	}
 
 	if (valueRequired || currentScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 0ef3fc3..3e824dd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -129,11 +129,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 
 	if (nonStatic) {
 		this.receiver.checkNPE(currentScope, flowContext, flowInfo);
-		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-		if (this.receiver.isThis() || this.receiver.isSuper()) {
-			// accessing non-static method without an object
-			currentScope.resetDeclaringClassMethodStaticFlag(this.actualReceiverType);
-		}
 	}
 
 	if (this.arguments != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index f9c0032..995a17b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -20,7 +20,9 @@
  *								bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *								bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *								bug 395977 - [compiler][resource] Resource leak warning behavior possibly incorrect for anonymous inner class
- *******************************************************************************/
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
+ ******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
@@ -78,6 +80,8 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				if (superclass != null && superclass.isMemberType() && !superclass.isStatic()) {
 					// creating an anonymous type of a non-static member type without an enclosing instance of parent type
 					currentScope.resetDeclaringClassMethodStaticFlag(superclass.enclosingType());
+					// Reviewed for https://bugs.eclipse.org/bugs/show_bug.cgi?id=378674 :
+					// The corresponding problem (when called from static) is not produced until during code generation
 				}
 			}
 			
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index 7ad4ca6..2352a77 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -21,6 +21,8 @@
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -94,9 +96,6 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 					currentScope.problemReporter().uninitializedBlankFinalField(lastFieldBinding, this);
 				}
 			}
-			if (!lastFieldBinding.isStatic()) {
-				currentScope.resetDeclaringClassMethodStaticFlag(lastFieldBinding.declaringClass);
-			}
 			break;
 		case Binding.LOCAL :
 			// first binding is a local variable
@@ -204,9 +203,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 					}
 				}
 			}
-			if (!fieldBinding.isStatic()) {
-				currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
-			}
 			break;
 		case Binding.LOCAL : // reading a local variable
 			LocalVariableBinding localBinding;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java
index 11a3e96..0acbf4e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedThisReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,6 +14,8 @@
  *     Stephan Herrmann - Contribution for
  *								bug 382350 - [1.8][compiler] Unable to invoke inherited default method via I.super.m() syntax
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -106,6 +108,9 @@ public class QualifiedThisReference extends ThisReference {
 				scope.problemReporter().noSuchEnclosingInstance(type, this, false);
 			// otherwise problem will be reported by the caller
 			return this.resolvedType;
+		} else {
+			// Mark all methods between here and the declared type as not static
+			scope.resetDeclaringClassMethodStaticFlag(this.currentCompatibleType);
 		}
 
 		// Ensure one cannot write code like: B() { super(B.this); }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
index 78feed1..7b24a77 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
@@ -16,7 +16,9 @@
  *								bug 185682 - Increment/decrement operators mark local variables as read
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
- *     Jesper S Moller - <jesper@selskabet.org>   - Contributions for bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
+ *     Jesper S Moller - <jesper@selskabet.org>   - Contributions for 
+ *     							bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -79,10 +81,6 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 						currentScope.problemReporter().uninitializedBlankFinalField(fieldBinding, this);
 					}
 				}
-				if (!fieldBinding.isStatic()) {
-					// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-					currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
-				}
 				manageSyntheticAccessIfNecessary(currentScope, flowInfo, true /*read-access*/);
 				break;
 			case Binding.LOCAL : // reading a local variable
@@ -130,10 +128,6 @@ public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowConte
 				// record assignment for detecting uninitialized non-null fields:
 				flowInfo.markAsDefinitelyAssigned(fieldBinding);
 			}
-			if (!fieldBinding.isStatic()) {
-				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-				currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
-			}
 			break;
 		case Binding.LOCAL : // assigning to a local variable
 			LocalVariableBinding localBinding = (LocalVariableBinding) this.binding;
@@ -190,10 +184,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 					currentScope.problemReporter().uninitializedBlankFinalField(fieldBinding, this);
 				}
 			}
-			if (!fieldBinding.isStatic()) {
-				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
-				currentScope.resetDeclaringClassMethodStaticFlag(fieldBinding.declaringClass);
-			}
 			break;
 		case Binding.LOCAL : // reading a local variable
 			LocalVariableBinding localBinding;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
index e2eab17..4949b26 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,6 +17,8 @@
  *								bug 379784 - [compiler] "Method can be static" is not getting reported
  *								bug 394768 - [compiler][resource] Incorrect resource leak warning when creating stream in conditional
  *								bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -551,6 +553,8 @@ public Binding getBinding(char[][] compoundName, int mask, InvocationSite invoca
 				field.declaringClass,
 				CharOperation.concatWith(CharOperation.subarray(compoundName, 0, currentIndex), '.'),
 				ProblemReasons.NonStaticReferenceInStaticContext);
+		// Since a qualified reference must be for a static member, it won't affect static-ness of the enclosing method, 
+		// so we don't have to call resetEnclosingMethodStaticFlag() in this case
 		return binding;
 	}
 	if ((mask & Binding.TYPE) != 0 && (binding instanceof ReferenceBinding)) {
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
index 4ec8e3e..9d96645 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Jesper S Moller <jesper@selskabet.org> - Contributions for
+ *								bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
 package org.eclipse.jdt.internal.eval;
 
@@ -503,6 +505,8 @@ public Binding getBinding(char[][] compoundName, int mask, InvocationSite invoca
 					CharOperation.concatWith(CharOperation.subarray(compoundName, 0, currentIndex), '.'),
 					ProblemReasons.NonStaticReferenceInStaticContext);
 		}
+		// Since a qualified reference must be for a static member, it won't affect static-ness of the enclosing method, 
+		// so we don't have to call resetEnclosingMethodStaticFlag() in this case
 		return binding;
 	}
 	if ((mask & Binding.TYPE) != 0 && (binding instanceof ReferenceBinding)) { // was looking for a type and found a type
