commit ff2b96761b3897e8f6c8feeb8c31198c182dd190
Author: Ayushman Jain <ajain>
Date:   Sat Mar 5 17:18:44 2011 +0000

    HEAD- Fixed bug 326950: [compiler][null]Do not optimize code generation based on static analysis (dead code)

125	121	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConstantTest.java
171	4	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
3	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
4	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
32	32	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
2	2	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetFieldReference.java
2	2	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
2	2	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSingleNameReference.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConstantTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConstantTest.java
index d961b54..fbb9f44 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConstantTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConstantTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2003, 2010 IBM Corporation and others.
+ * Copyright (c) 2003, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -360,129 +360,133 @@ public void test009() throws Exception {
 
 	String expectedOutput =
 		"  // Method descriptor #15 ([Ljava/lang/String;)V\n" +
-		"  // Stack: 3, Locals: 4\n" +
-		"  public static void main(java.lang.String[] args);\n" +
-		"     0  getstatic java.lang.System.out : java.io.PrintStream [16]\n" +
-		"     3  ldc <String \"1\"> [22]\n" +
-		"     5  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" +
-		"     8  aconst_null\n" +
-		"     9  goto 13\n" +
-		"    12  aconst_null\n" +
-		"    13  aconst_null\n" +
-		"    14  goto 18\n" +
-		"    17  aconst_null\n" +
-		"    18  if_acmpne 29\n" +
-		"    21  getstatic java.lang.System.out : java.io.PrintStream [16]\n" +
-		"    24  ldc <String \"2\"> [30]\n" +
-		"    26  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" +
-		"    29  new java.lang.StringBuffer [32]\n" +
-		"    32  dup\n" +
-		"    33  ldc <String \"[\"> [34]\n" +
-		"    35  invokespecial java.lang.StringBuffer(java.lang.String) [36]\n" +
-		"    38  aconst_null\n" +
-		"    39  invokevirtual java.lang.StringBuffer.append(java.lang.Object) : java.lang.StringBuffer [38]\n" +
-		"    42  ldc <String \"]\"> [42]\n" +
-		"    44  invokevirtual java.lang.StringBuffer.append(java.lang.String) : java.lang.StringBuffer [44]\n" +
-		"    47  invokevirtual java.lang.StringBuffer.toString() : java.lang.String [47]\n" +
-		"    50  ldc <String \"[null]\"> [51]\n" +
-		"    52  if_acmpne 59\n" +
-		"    55  iconst_1\n" +
-		"    56  goto 60\n" +
-		"    59  iconst_0\n" +
-		"    60  istore_1 [b]\n" +
-		"    61  getstatic java.lang.System.out : java.io.PrintStream [16]\n" +
-		"    64  ldc <String \"3\"> [53]\n" +
-		"    66  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" +
-		"    69  aconst_null\n" +
-		"    70  astore_2 [s]\n" +
-		"    71  getstatic java.lang.System.out : java.io.PrintStream [16]\n" +
-		"    74  ldc <String \"4\"> [55]\n" +
-		"    76  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" +
-		"    79  ldc <String \"aaa\"> [57]\n" +
-		"    81  astore_3 [s2]\n" +
-		"    82  getstatic java.lang.System.out : java.io.PrintStream [16]\n" +
-		"    85  ldc <String \"5\"> [59]\n" +
-		"    87  invokevirtual java.io.PrintStream.println(java.lang.String) : void [61]\n" +
-		"    90  return\n" +
-		"      Line numbers:\n" +
-		"        [pc: 0, line: 3]\n" +
-		"        [pc: 8, line: 4]\n" +
-		"        [pc: 21, line: 5]\n" +
-		"        [pc: 29, line: 6]\n" +
-		"        [pc: 61, line: 7]\n" +
-		"        [pc: 69, line: 8]\n" +
-		"        [pc: 71, line: 9]\n" +
-		"        [pc: 79, line: 10]\n" +
-		"        [pc: 82, line: 11]\n" +
-		"        [pc: 90, line: 12]\n" +
-		"      Local variable table:\n" +
-		"        [pc: 0, pc: 91] local: args index: 0 type: java.lang.String[]\n" +
-		"        [pc: 61, pc: 91] local: b index: 1 type: boolean\n" +
-		"        [pc: 71, pc: 91] local: s index: 2 type: java.lang.String\n" +
-		"        [pc: 82, pc: 91] local: s2 index: 3 type: java.lang.String\n";
+		"  // Stack: 3, Locals: 4\n" + 
+		"  public static void main(java.lang.String[] args);\n" + 
+		"     0  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"     3  ldc <String \"1\"> [22]\n" + 
+		"     5  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" + 
+		"     8  aconst_null\n" + 
+		"     9  goto 13\n" + 
+		"    12  aconst_null\n" + 
+		"    13  aconst_null\n" + 
+		"    14  goto 18\n" + 
+		"    17  aconst_null\n" + 
+		"    18  if_acmpne 29\n" + 
+		"    21  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    24  ldc <String \"2\"> [30]\n" + 
+		"    26  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" + 
+		"    29  new java.lang.StringBuffer [32]\n" + 
+		"    32  dup\n" + 
+		"    33  ldc <String \"[\"> [34]\n" + 
+		"    35  invokespecial java.lang.StringBuffer(java.lang.String) [36]\n" + 
+		"    38  aconst_null\n" + 
+		"    39  invokevirtual java.lang.StringBuffer.append(java.lang.Object) : java.lang.StringBuffer [38]\n" + 
+		"    42  ldc <String \"]\"> [42]\n" + 
+		"    44  invokevirtual java.lang.StringBuffer.append(java.lang.String) : java.lang.StringBuffer [44]\n" + 
+		"    47  invokevirtual java.lang.StringBuffer.toString() : java.lang.String [47]\n" + 
+		"    50  ldc <String \"[null]\"> [51]\n" + 
+		"    52  if_acmpne 59\n" + 
+		"    55  iconst_1\n" + 
+		"    56  goto 60\n" + 
+		"    59  iconst_0\n" + 
+		"    60  istore_1 [b]\n" + 
+		"    61  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    64  ldc <String \"3\"> [53]\n" + 
+		"    66  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" + 
+		"    69  aconst_null\n" + 
+		"    70  astore_2 [s]\n" + 
+		"    71  aload_2 [s]\n" + 
+		"    72  ifnonnull 83\n" + 
+		"    75  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    78  ldc <String \"4\"> [55]\n" + 
+		"    80  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" + 
+		"    83  ldc <String \"aaa\"> [57]\n" + 
+		"    85  astore_3 [s2]\n" + 
+		"    86  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    89  ldc <String \"5\"> [59]\n" + 
+		"    91  invokevirtual java.io.PrintStream.println(java.lang.String) : void [61]\n" + 
+		"    94  return\n" + 
+		"      Line numbers:\n" + 
+		"        [pc: 0, line: 3]\n" + 
+		"        [pc: 8, line: 4]\n" + 
+		"        [pc: 21, line: 5]\n" + 
+		"        [pc: 29, line: 6]\n" + 
+		"        [pc: 61, line: 7]\n" + 
+		"        [pc: 69, line: 8]\n" + 
+		"        [pc: 71, line: 9]\n" + 
+		"        [pc: 83, line: 10]\n" + 
+		"        [pc: 86, line: 11]\n" + 
+		"        [pc: 94, line: 12]\n" + 
+		"      Local variable table:\n" + 
+		"        [pc: 0, pc: 95] local: args index: 0 type: java.lang.String[]\n" + 
+		"        [pc: 61, pc: 95] local: b index: 1 type: boolean\n" + 
+		"        [pc: 71, pc: 95] local: s index: 2 type: java.lang.String\n" + 
+		"        [pc: 86, pc: 95] local: s2 index: 3 type: java.lang.String\n";
 
 	String expectedOutput15 =
 		"  // Method descriptor #15 ([Ljava/lang/String;)V\n" +
-		"  // Stack: 3, Locals: 4\n" +
-		"  public static void main(java.lang.String[] args);\n" +
-		"     0  getstatic java.lang.System.out : java.io.PrintStream [16]\n" +
-		"     3  ldc <String \"1\"> [22]\n" +
-		"     5  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" +
-		"     8  aconst_null\n" +
-		"     9  goto 13\n" +
-		"    12  aconst_null\n" +
-		"    13  aconst_null\n" +
-		"    14  goto 18\n" +
-		"    17  aconst_null\n" +
-		"    18  if_acmpne 29\n" +
-		"    21  getstatic java.lang.System.out : java.io.PrintStream [16]\n" +
-		"    24  ldc <String \"2\"> [30]\n" +
-		"    26  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" +
-		"    29  new java.lang.StringBuilder [32]\n" +
-		"    32  dup\n" +
-		"    33  ldc <String \"[\"> [34]\n" +
-		"    35  invokespecial java.lang.StringBuilder(java.lang.String) [36]\n" +
-		"    38  aconst_null\n" +
-		"    39  invokevirtual java.lang.StringBuilder.append(java.lang.Object) : java.lang.StringBuilder [38]\n" +
-		"    42  ldc <String \"]\"> [42]\n" +
-		"    44  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [44]\n" +
-		"    47  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [47]\n" +
-		"    50  ldc <String \"[null]\"> [51]\n" +
-		"    52  if_acmpne 59\n" +
-		"    55  iconst_1\n" +
-		"    56  goto 60\n" +
-		"    59  iconst_0\n" +
-		"    60  istore_1 [b]\n" +
-		"    61  getstatic java.lang.System.out : java.io.PrintStream [16]\n" +
-		"    64  ldc <String \"3\"> [53]\n" +
-		"    66  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" +
-		"    69  aconst_null\n" +
-		"    70  astore_2 [s]\n" +
-		"    71  getstatic java.lang.System.out : java.io.PrintStream [16]\n" +
-		"    74  ldc <String \"4\"> [55]\n" +
-		"    76  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" +
-		"    79  ldc <String \"aaa\"> [57]\n" +
-		"    81  astore_3 [s2]\n" +
-		"    82  getstatic java.lang.System.out : java.io.PrintStream [16]\n" +
-		"    85  ldc <String \"5\"> [59]\n" +
-		"    87  invokevirtual java.io.PrintStream.println(java.lang.String) : void [61]\n" +
-		"    90  return\n" +
-		"      Line numbers:\n" +
-		"        [pc: 0, line: 3]\n" +
-		"        [pc: 8, line: 4]\n" +
-		"        [pc: 21, line: 5]\n" +
-		"        [pc: 29, line: 6]\n" +
-		"        [pc: 61, line: 7]\n" +
-		"        [pc: 69, line: 8]\n" +
-		"        [pc: 71, line: 9]\n" +
-		"        [pc: 79, line: 10]\n" +
-		"        [pc: 82, line: 11]\n" +
-		"        [pc: 90, line: 12]\n" +
-		"      Local variable table:\n" +
-		"        [pc: 0, pc: 91] local: args index: 0 type: java.lang.String[]\n" +
-		"        [pc: 61, pc: 91] local: b index: 1 type: boolean\n" +
-		"        [pc: 71, pc: 91] local: s index: 2 type: java.lang.String\n" +
-		"        [pc: 82, pc: 91] local: s2 index: 3 type: java.lang.String\n";
+		"  // Stack: 3, Locals: 4\n" + 
+		"  public static void main(java.lang.String[] args);\n" + 
+		"     0  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"     3  ldc <String \"1\"> [22]\n" + 
+		"     5  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" + 
+		"     8  aconst_null\n" + 
+		"     9  goto 13\n" + 
+		"    12  aconst_null\n" + 
+		"    13  aconst_null\n" + 
+		"    14  goto 18\n" + 
+		"    17  aconst_null\n" + 
+		"    18  if_acmpne 29\n" + 
+		"    21  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    24  ldc <String \"2\"> [30]\n" + 
+		"    26  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" + 
+		"    29  new java.lang.StringBuilder [32]\n" + 
+		"    32  dup\n" + 
+		"    33  ldc <String \"[\"> [34]\n" + 
+		"    35  invokespecial java.lang.StringBuilder(java.lang.String) [36]\n" + 
+		"    38  aconst_null\n" + 
+		"    39  invokevirtual java.lang.StringBuilder.append(java.lang.Object) : java.lang.StringBuilder [38]\n" + 
+		"    42  ldc <String \"]\"> [42]\n" + 
+		"    44  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [44]\n" + 
+		"    47  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [47]\n" + 
+		"    50  ldc <String \"[null]\"> [51]\n" + 
+		"    52  if_acmpne 59\n" + 
+		"    55  iconst_1\n" + 
+		"    56  goto 60\n" + 
+		"    59  iconst_0\n" + 
+		"    60  istore_1 [b]\n" + 
+		"    61  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    64  ldc <String \"3\"> [53]\n" + 
+		"    66  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" + 
+		"    69  aconst_null\n" + 
+		"    70  astore_2 [s]\n" + 
+		"    71  aload_2 [s]\n" + 
+		"    72  ifnonnull 83\n" + 
+		"    75  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    78  ldc <String \"4\"> [55]\n" + 
+		"    80  invokevirtual java.io.PrintStream.print(java.lang.String) : void [24]\n" + 
+		"    83  ldc <String \"aaa\"> [57]\n" + 
+		"    85  astore_3 [s2]\n" + 
+		"    86  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    89  ldc <String \"5\"> [59]\n" + 
+		"    91  invokevirtual java.io.PrintStream.println(java.lang.String) : void [61]\n" + 
+		"    94  return\n" + 
+		"      Line numbers:\n" + 
+		"        [pc: 0, line: 3]\n" + 
+		"        [pc: 8, line: 4]\n" + 
+		"        [pc: 21, line: 5]\n" + 
+		"        [pc: 29, line: 6]\n" + 
+		"        [pc: 61, line: 7]\n" + 
+		"        [pc: 69, line: 8]\n" + 
+		"        [pc: 71, line: 9]\n" + 
+		"        [pc: 83, line: 10]\n" + 
+		"        [pc: 86, line: 11]\n" + 
+		"        [pc: 94, line: 12]\n" + 
+		"      Local variable table:\n" + 
+		"        [pc: 0, pc: 95] local: args index: 0 type: java.lang.String[]\n" + 
+		"        [pc: 61, pc: 95] local: b index: 1 type: boolean\n" + 
+		"        [pc: 71, pc: 95] local: s index: 2 type: java.lang.String\n" + 
+		"        [pc: 86, pc: 95] local: s2 index: 3 type: java.lang.String\n";
 
 	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
 		int index = actualOutput.indexOf(expectedOutput15);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index d706c42..c446c1b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -11782,10 +11782,16 @@ public void testBug304416() throws Exception {
 		"     2  aconst_null\n" + 
 		"     3  astore_2 [s2]\n" + 
 		"     4  aload_1 [s]\n" + 
-		"     5  ifnull 12\n" + 
+		"     5  ifnull 26\n" + 
 		"     8  aload_2 [s2]\n" + 
-		"     9  ifnull 12\n" + 
-		"    12  return\n";
+		"     9  ifnull 26\n" + 
+		"    12  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    15  aload_1 [s]\n" + 
+		"    16  invokevirtual java.io.PrintStream.println(java.lang.String) : void [22]\n" + 
+		"    19  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    22  aload_2 [s2]\n" + 
+		"    23  invokevirtual java.io.PrintStream.println(java.lang.String) : void [22]\n" + 
+		"    26  return\n";
 	checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput);
 }
 
@@ -14273,5 +14279,166 @@ public void testBug324178a() {
 		},
 		"");
 }
-
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=326950
+public void testBug326950a() throws Exception {
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportPotentialNullReference, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.WARNING);
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		String s = null;\n" +
+			"		if (s == null) {\n" + 
+			"			System.out.println(\"SUCCESS\");\n" + 
+			"		} else {\n" +
+			"			System.out.println(\"Dead code, but don't optimize me out\");\n" +
+			"		}\n" + 
+			"	}\n" + 
+			"}",
+		},
+		"SUCCESS",
+		null,
+		true,
+		null,
+		options,
+		null);
+	String expectedOutput =
+		"  public static void main(java.lang.String[] args);\n" + 
+		"     0  aconst_null\n" + 
+		"     1  astore_1 [s]\n" + 
+		"     2  aload_1 [s]\n" + 
+		"     3  ifnonnull 17\n" + 
+		"     6  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"     9  ldc <String \"SUCCESS\"> [22]\n" + 
+		"    11  invokevirtual java.io.PrintStream.println(java.lang.String) : void [24]\n" + 
+		"    14  goto 25\n" + 
+		"    17  getstatic java.lang.System.out : java.io.PrintStream [16]\n" + 
+		"    20  ldc <String \"Dead code, but don\'t optimize me out\"> [30]\n" + 
+		"    22  invokevirtual java.io.PrintStream.println(java.lang.String) : void [24]\n" + 
+		"    25  return\n";
+	checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=326950
+// Code marked dead due to if(false), etc. can be optimized out
+public void testBug326950b() throws Exception {
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportPotentialNullReference, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.WARNING);
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" + 
+			"	public static void main(String[] args) {\n" +
+			"		int i = 0;\n" + 
+			"		if (false) {\n" + 
+			"			System.out.println(\"Deadcode and you can optimize me out\");\n" + 
+			"		}\n" +
+			"		if (true) {\n" +
+			"			i++;\n" +
+			"		} else {\n" +
+			"			System.out.println(\"Deadcode and you can optimize me out\");\n" +
+			"		}\n" +
+			"	}\n" + 
+			"}",
+		},
+		"",
+		null,
+		true,
+		null,
+		options,
+		null);
+	String expectedOutput =
+		"  public static void main(java.lang.String[] args);\n" + 
+		"    0  iconst_0\n" + 
+		"    1  istore_1 [i]\n" + 
+		"    2  iinc 1 1 [i]\n" + 
+		"    5  return\n";
+	checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=326950
+// Free return should be generated for a method even if it ends with dead code
+public void testBug326950c() throws Exception {
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportPotentialNullReference, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.WARNING);
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" + 
+			"	public void foo(String[] args) {\n" + 
+			"		String s = \"\";\n" +
+			"		int i = 0;\n" +
+			"		if (s != null) {\n" + 
+			"			return;\n" + 
+			"		}\n" +
+			"		i++;\n" +
+			"	}\n" + 
+			"}",
+		},
+		"",
+		null,
+		true,
+		null,
+		options,
+		null);
+	String expectedOutput =
+		"  public void foo(java.lang.String[] args);\n" + 
+		"     0  ldc <String \"\"> [16]\n" + 
+		"     2  astore_2 [s]\n" + 
+		"     3  iconst_0\n" + 
+		"     4  istore_3 [i]\n" + 
+		"     5  aload_2 [s]\n" + 
+		"     6  ifnull 10\n" + 
+		"     9  return\n" + 
+		"    10  iinc 3 1 [i]\n" + 
+		"    13  return\n";
+	checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=326950
+// Free return should be generated for a constructor even if it ends with dead code
+public void testBug326950d() throws Exception {
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportPotentialNullReference, CompilerOptions.WARNING);
+	options.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.WARNING);
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" + 
+			"	X() {\n" + 
+			"		String s = \"\";\n" +
+			"		int i = 0;\n" +
+			"		if (s != null) {\n" + 
+			"			return;\n" + 
+			"		}\n" +
+			"		i++;\n" +
+			"	}\n" + 
+			"}",
+		},
+		"",
+		null,
+		true,
+		null,
+		options,
+		null);
+	String expectedOutput =
+		"  X();\n" + 
+		"     0  aload_0 [this]\n" + 
+		"     1  invokespecial java.lang.Object() [8]\n" + 
+		"     4  ldc <String \"\"> [10]\n" + 
+		"     6  astore_1 [s]\n" + 
+		"     7  iconst_0\n" + 
+		"     8  istore_2 [i]\n" + 
+		"     9  aload_1 [s]\n" + 
+		"    10  ifnull 14\n" + 
+		"    13  return\n" + 
+		"    14  iinc 2 1 [i]\n" + 
+		"    17  return\n";
+	checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput);
+}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index e8f908b..079fb49 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -51,7 +51,9 @@ Eclipse SDK 3.7M6 - %date% - 3.7.0 M6
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=324178">324178</a>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=326950">326950</a>
+[compiler][null]Do not optimize code generation based on static analysis (dead code)
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=324178">324178</a>
 [null] ConditionalExpression.nullStatus(..) doesn't take into account the analysis of condition itself
 <br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=338006">338006</a>
 IJavaProject#getPackageFragmentRoots() should return roots in order
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 7e2025b..8033bc7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -184,7 +184,7 @@ public boolean isTypeAccess() {
  * exact need.
  */
 public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) return;
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) return;
 	ReferenceBinding allocatedTypeErasure = (ReferenceBinding) this.binding.declaringClass.erasure();
 
 	// perform some emulation work in case there is some and we are inside a local type only
@@ -203,7 +203,7 @@ public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, Fl
 }
 
 public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) return;
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) return;
 	// if constructor from parameterized type got found, use the original constructor at codegen time
 	MethodBinding codegenBinding = this.binding.original();
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
index 329c997..efef338 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AssertStatement.java
@@ -174,7 +174,7 @@ public void traverse(ASTVisitor visitor, BlockScope scope) {
 }
 
 public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) {
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
 		// need assertion flag: $assertionsDisabled on outer most source clas
 		// (in case of static member of interface, will use the outermost static member - bug 22334)
 		SourceTypeBinding outerMostClass = currentScope.enclosingSourceType();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
index 98006a5..d7558e1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Clinit.java
@@ -61,7 +61,7 @@ public class Clinit extends AbstractMethodDeclaration {
 					FlowInfo.DEAD_END);
 
 			// check for missing returning path
-			if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) {
+			if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
 				this.bits |= ASTNode.NeedFreeReturn;
 			}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
index 2193eda..d518d73 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
@@ -156,7 +156,7 @@ public void analyseCode(ClassScope classScope, InitializationFlowContext initial
 			}
 		}
 		// check for missing returning path
-		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) {
+		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
 			this.bits |= ASTNode.NeedFreeReturn;
 		}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
index cf09127..5806ce8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -72,7 +72,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		// code generation can be optimized when no need to continue in the loop
 		if ((actionInfo.tagBits &
 				loopingContext.initsOnContinue.tagBits &
-				FlowInfo.UNREACHABLE) != 0) {
+				FlowInfo.UNREACHABLE_OR_DEAD) != 0) {
 			this.continueLabel = null;
 		}
 		if ((this.condition.implicitConversion & TypeIds.UNBOXING) != 0) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
index 80c92fb..ba2219f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -196,7 +196,7 @@ public class ExplicitConstructorCall extends Statement implements InvocationSite
 	void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
 		ReferenceBinding superTypeErasure = (ReferenceBinding) this.binding.declaringClass.erasure();
 
-		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0)	{
+		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0)	{
 		// perform some emulation work in case there is some and we are inside a local type only
 		if (superTypeErasure.isNestedType()
 			&& currentScope.enclosingSourceType().isLocalType()) {
@@ -212,7 +212,7 @@ public class ExplicitConstructorCall extends Statement implements InvocationSite
 	}
 
 	public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
-		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0)	{
+		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0)	{
 			// if constructor from parameterized type got found, use the original constructor at codegen time
 			MethodBinding codegenBinding = this.binding.original();
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
index 8c4d2e8..66f16b6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -439,7 +439,7 @@ public boolean isTypeAccess() {
  * No need to emulate access to protected fields since not implicitly accessed
  */
 public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)	return;
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0)	return;
 	
 	// if field from parameterized type got found, use the original field at codegen time
 	FieldBinding codegenBinding = this.binding.original();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
index b9b8e34..41e569b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
@@ -145,7 +145,7 @@ public class ForStatement extends Statement {
 			// code generation can be optimized when no need to continue in the loop
 			if ((actionInfo.tagBits &
 					loopingContext.initsOnContinue.tagBits &
-					FlowInfo.UNREACHABLE) != 0) {
+					FlowInfo.UNREACHABLE_OR_DEAD) != 0) {
 				this.continueLabel = null;
 			}
 			else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
index 3717122..17693c8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -108,7 +108,7 @@ public class ForeachStatement extends Statement {
 			addInitializationsFrom(condInfo.initsWhenFalse());
 			// TODO (maxime) no need to test when false: can optimize (same for action being unreachable above)
 			if ((actionInfo.tagBits & loopingContext.initsOnContinue.tagBits &
-					FlowInfo.UNREACHABLE) != 0) {
+					FlowInfo.UNREACHABLE_OR_DEAD) != 0) {
 				this.continueLabel = null;
 			} else {
 				actionInfo = actionInfo.mergedWith(loopingContext.initsOnContinue);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index 2341d1d..2f3b1a7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -99,7 +99,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		thenFlowInfo = this.thenStatement.analyseCode(currentScope, flowContext, thenFlowInfo);
 	}
 	// code gen: optimizing the jump around the ELSE part
-	if ((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) {
+	if ((thenFlowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) {
 		this.bits |= ASTNode.ThenExit;
 	}
 
@@ -164,10 +164,7 @@ public void generateCode(BlockScope currentScope, CodeStream codeStream) {
 	if (hasThenPart) {
 		BranchLabel falseLabel = null;
 		// generate boolean condition only if needed
-		if (((this.bits & ASTNode.IsElseStatementUnreachable) != 0) ||
-				(cst != Constant.NotAConstant && cst.booleanValue() == true)) {
-			// No need to generate if condition statement when we know that only the then action
-			// will be executed
+		if (cst != Constant.NotAConstant && cst.booleanValue() == true) {
 			this.condition.generateCode(currentScope, codeStream, false);
 		} else {
 			this.condition.generateOptimizedBoolean(
@@ -206,10 +203,7 @@ public void generateCode(BlockScope currentScope, CodeStream codeStream) {
 		}
 	} else if (hasElsePart) {
 		// generate boolean condition only if needed
-		if (((this.bits & ASTNode.IsThenStatementUnreachable) != 0) ||
-				(cst != Constant.NotAConstant && cst.booleanValue() == false)) {
-			// No need to generate if condition statement when we know that only the else action
-			// will be executed
+		if (cst != Constant.NotAConstant && cst.booleanValue() == false) {
 			this.condition.generateCode(currentScope, codeStream, false);
 		} else {
 			this.condition.generateOptimizedBoolean(
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 0e4e8dc..7217393 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -214,7 +214,7 @@ public boolean isTypeAccess() {
 }
 public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo){
 
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)	return;
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0)	return;
 
 	// if method from parameterized type got found, use the original method at codegen time
 	MethodBinding codegenBinding = this.binding.original();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 5b64c83..53fade3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -111,7 +111,7 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 			// check for missing returning path
 			TypeBinding returnTypeBinding = this.binding.returnType;
 			if ((returnTypeBinding == TypeBinding.VOID) || isAbstract()) {
-				if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) {
+				if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
 					this.bits |= ASTNode.NeedFreeReturn;
 				}
 			} else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 29fbc3b..7a9ea09 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -192,7 +192,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 	 * exact need.
 	 */
 	public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
-		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0)	{
+		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0)	{
 		ReferenceBinding allocatedTypeErasure = (ReferenceBinding) this.binding.declaringClass.erasure();
 
 		// perform some extra emulation work in case there is some and we are inside a local type only
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index feb534d..1b4a530 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -807,7 +807,7 @@ public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, Fl
  * index is <0 to denote write access emulation
  */
 public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FieldBinding fieldBinding, int index, FlowInfo flowInfo) {
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) return;
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) return;
 	// index == 0 denotes the first fieldBinding, index > 0 denotes one of the 'otherBindings', index < 0 denotes a write access (to last binding)
 	if (fieldBinding.constant() != Constant.NotAConstant)
 		return;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
index e879d6e..a2cdd89 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -829,7 +829,7 @@ public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, Fl
 }
 
 public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess) {
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0)	return;
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0)	return;
 
 	//If inlinable field, forget the access emulation, the code gen will directly target it
 	if (this.constant != Constant.NotAConstant)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index f569c88..85e465a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -72,7 +72,8 @@ public void branchChainTo(BranchLabel label) {
 // complaintLevel = 0 if was reachable up until now, 1 if fake reachable (deadcode), 2 if fatal unreachable (error)
 public int complainIfUnreachable(FlowInfo flowInfo, BlockScope scope, int previousComplaintLevel) {
 	if ((flowInfo.reachMode() & FlowInfo.UNREACHABLE) != 0) {
-		this.bits &= ~ASTNode.IsReachable;
+		if ((flowInfo.reachMode() & FlowInfo.UNREACHABLE_OR_DEAD) != 0)
+			this.bits &= ~ASTNode.IsReachable;
 		if (flowInfo == FlowInfo.DEAD_END) {
 			if (previousComplaintLevel < COMPLAINED_UNREACHABLE) {
 				scope.problemReporter().unreachableCode(this);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
index 1ce89ee..b2c6dfd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -64,7 +64,7 @@ public FlowInfo analyseCode(
 		currentScope.methodScope().recordInitializationStates(flowInfo);
 
 	// optimizing code gen
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) {
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) {
 		this.bits |= ASTNode.BlockExit;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index 5dc426a..41f8957 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -101,7 +101,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			tryInfo = flowInfo;
 		} else {
 			tryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());
-			if ((tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0)
+			if ((tryInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0)
 				this.bits |= ASTNode.IsTryBlockExiting;
 		}
 
@@ -210,7 +210,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			tryInfo = flowInfo;
 		} else {
 			tryInfo = this.tryBlock.analyseCode(currentScope, handlingContext, flowInfo.copy());
-			if ((tryInfo.tagBits & FlowInfo.UNREACHABLE) != 0)
+			if ((tryInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0)
 				this.bits |= ASTNode.IsTryBlockExiting;
 		}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
index 371b65a..b475932 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
@@ -192,7 +192,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	if (this.ignoreFurtherInvestigation)
 		return flowInfo;
 	try {
-		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) {
+		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
 			this.bits |= ASTNode.IsReachable;
 			LocalTypeBinding localType = (LocalTypeBinding) this.binding;
 			localType.setConstantPoolName(currentScope.compilationUnitScope().computeConstantPoolName(localType));
@@ -230,7 +230,7 @@ public void analyseCode(ClassScope currentScope, FlowContext flowContext, FlowIn
 	if (this.ignoreFurtherInvestigation)
 		return;
 	try {
-		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) {
+		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
 			this.bits |= ASTNode.IsReachable;
 			LocalTypeBinding localType = (LocalTypeBinding) this.binding;
 			localType.setConstantPoolName(currentScope.compilationUnitScope().computeConstantPoolName(localType));
@@ -633,7 +633,7 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 		for (int i = 0, count = this.fields.length; i < count; i++) {
 			FieldDeclaration field = this.fields[i];
 			if (field.isStatic()) {
-				if ((staticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)
+				if ((staticFieldInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0)
 					field.bits &= ~ASTNode.IsReachable;
 
 				/*if (field.isField()){
@@ -649,7 +649,7 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 					staticFieldInfo = FlowInfo.initial(this.maxFieldCount).setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
 				}
 			} else {
-				if ((nonStaticFieldInfo.tagBits & FlowInfo.UNREACHABLE) != 0)
+				if ((nonStaticFieldInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0)
 					field.bits &= ~ASTNode.IsReachable;
 
 				/*if (field.isField()){
@@ -725,7 +725,7 @@ public final static int kind(int flags) {
  * 15.9.2
  */
 public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) return;
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) return;
 	NestedTypeBinding nestedType = (NestedTypeBinding) this.binding;
 
 	MethodScope methodScope = currentScope.methodScope();
@@ -776,7 +776,7 @@ public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope, Fl
  * Local member cannot be static.
  */
 public void manageEnclosingInstanceAccessIfNecessary(ClassScope currentScope, FlowInfo flowInfo) {
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) {
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
 	NestedTypeBinding nestedType = (NestedTypeBinding) this.binding;
 	nestedType.addSyntheticArgumentAndField(this.binding.enclosingType());
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
index 2e0acb9..c51042e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
@@ -120,11 +120,10 @@ public class WhileStatement extends Statement {
 			// code generation can be optimized when no need to continue in the loop
 			exitBranch = flowInfo.copy();
 			// need to start over from flowInfo so as to get null inits
-
-			if ((actionInfo.tagBits &
-					loopingContext.initsOnContinue.tagBits &
-					FlowInfo.UNREACHABLE) != 0) {
-				this.continueLabel = null;
+            int combinedTagBits = actionInfo.tagBits & loopingContext.initsOnContinue.tagBits;
+			if ((combinedTagBits & FlowInfo.UNREACHABLE) != 0) {
+				if ((combinedTagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0)
+					this.continueLabel = null;
 				exitBranch.addInitializationsFrom(condInfo.initsWhenFalse());
 			} else {
 				condLoopContext.complainOnDeferredFinalChecks(currentScope,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index b8e570f..c1a2b5f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -386,41 +386,41 @@ public void recordBreakTo(FlowContext targetContext) {
 
 public void recordContinueFrom(FlowContext innerFlowContext, FlowInfo flowInfo) {
 	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0)	{
-	if ((this.initsOnContinue.tagBits & FlowInfo.UNREACHABLE) == 0) {
-		this.initsOnContinue = this.initsOnContinue.
-			mergedWith(flowInfo.unconditionalInitsWithoutSideEffect());
-	}
-	else {
-		this.initsOnContinue = flowInfo.unconditionalCopy();
-	}
-	FlowContext inner = innerFlowContext;
-	while (inner != this && !(inner instanceof LoopingFlowContext)) {
-		inner = inner.parent;
-	}
-	if (inner == this) {
-		this.upstreamNullFlowInfo.
+		if ((this.initsOnContinue.tagBits & FlowInfo.UNREACHABLE) == 0) {
+			this.initsOnContinue = this.initsOnContinue.
+					mergedWith(flowInfo.unconditionalInitsWithoutSideEffect());
+		}
+		else {
+			this.initsOnContinue = flowInfo.unconditionalCopy();
+		}
+		FlowContext inner = innerFlowContext;
+		while (inner != this && !(inner instanceof LoopingFlowContext)) {
+			inner = inner.parent;
+		}
+		if (inner == this) {
+			this.upstreamNullFlowInfo.
 			addPotentialNullInfoFrom(
-				flowInfo.unconditionalInitsWithoutSideEffect());
-	}
-	else {
-		int length = 0;
-		if (this.innerFlowContexts == null) {
-			this.innerFlowContexts = new LoopingFlowContext[5];
-			this.innerFlowInfos = new UnconditionalFlowInfo[5];
+					flowInfo.unconditionalInitsWithoutSideEffect());
 		}
-		else if (this.innerFlowContextsCount ==
-				(length = this.innerFlowContexts.length) - 1) {
-			System.arraycopy(this.innerFlowContexts, 0,
-				(this.innerFlowContexts = new LoopingFlowContext[length + 5]),
-				0, length);
-			System.arraycopy(this.innerFlowInfos, 0,
-				(this.innerFlowInfos= new UnconditionalFlowInfo[length + 5]),
-				0, length);
+		else {
+			int length = 0;
+			if (this.innerFlowContexts == null) {
+				this.innerFlowContexts = new LoopingFlowContext[5];
+				this.innerFlowInfos = new UnconditionalFlowInfo[5];
+			}
+			else if (this.innerFlowContextsCount ==
+					(length = this.innerFlowContexts.length) - 1) {
+				System.arraycopy(this.innerFlowContexts, 0,
+						(this.innerFlowContexts = new LoopingFlowContext[length + 5]),
+						0, length);
+				System.arraycopy(this.innerFlowInfos, 0,
+						(this.innerFlowInfos= new UnconditionalFlowInfo[length + 5]),
+						0, length);
+			}
+			this.innerFlowContexts[this.innerFlowContextsCount] = (LoopingFlowContext) inner;
+			this.innerFlowInfos[this.innerFlowContextsCount++] =
+					flowInfo.unconditionalInitsWithoutSideEffect();
 		}
-		this.innerFlowContexts[this.innerFlowContextsCount] = (LoopingFlowContext) inner;
-		this.innerFlowInfos[this.innerFlowContextsCount++] =
-			flowInfo.unconditionalInitsWithoutSideEffect();
-	}
 	}
 }
 
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetFieldReference.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetFieldReference.java
index 71c2942..ea7fb3a 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetFieldReference.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetFieldReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -278,7 +278,7 @@ public void generatePostIncrement(BlockScope currentScope, CodeStream codeStream
 public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo, boolean isReadAccess){
 	// The private access will be managed through the code generation
 
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) return;
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) return;
 }
 public TypeBinding resolveType(BlockScope scope) {
 	// Answer the signature type of the field.
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
index c21755c..fa30c00 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -168,7 +168,7 @@ public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean
 }
 public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
 
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) {
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
 		// if method from parameterized type got found, use the original method at codegen time
 		MethodBinding codegenBinding = this.binding.original();
 		if (codegenBinding != this.binding) {
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSingleNameReference.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSingleNameReference.java
index 151a215..ea2877b 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSingleNameReference.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSingleNameReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -576,7 +576,7 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 		return;
 	}
 
-	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) return;
+	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) != 0) return;
 	//If inlinable field, forget the access emulation, the code gen will directly target it
 	if (this.constant != Constant.NotAConstant)
 		return;
