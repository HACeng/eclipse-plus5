commit 488811f5b30befaaae3f5995fcfa0b0505629e6e
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sat Apr 18 01:12:25 2015 +0200

    Bug 429813 - [1.8][dom ast] IMethodBinding#getJavaElement() should
    return IMethod for lambda
    
    Change-Id: If8be7ce39348c168be47eb510a4378ceb5bd4acc
    Signed-off-by: Stephan Herrmann <stephan.herrmann@berlin.de>
    Also-by: Jay Arthanareeswaran <jarthana@in.ibm.com>

60	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
17	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Initializer.java
77	8	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
30	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IMethodBinding.java
27	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ITypeBinding.java
76	3	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java
11	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
40	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
6	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
15	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DOMFinder.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
index dc14743..c13eec8 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter18Test.java
@@ -27,6 +27,7 @@ import org.eclipse.jdt.core.IMethod;
 import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.core.ResolvedBinaryMethod;
 
 @SuppressWarnings({"rawtypes"})
@@ -1579,7 +1580,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		assertEquals("vlambda -> {\n  return 200;\n}\n", lambdaExpression.toString());
 		assertTrue(lambdaExpression.parameters().size() == 1);
 		IMethodBinding binding = lambdaExpression.resolveMethodBinding();
-		assertEquals("private static int lambda$0(int) ", binding.toString());
+		assertEquals("public int foo(int) ", binding.toString());
+		assertEquals("real modifiers", ClassFileConstants.AccPublic, binding.getModifiers());
 		VariableDeclaration variableDeclaration = (VariableDeclaration) lambdaExpression.parameters().get(0);
 		assertTrue(variableDeclaration instanceof VariableDeclarationFragment);
 		fragment = (VariableDeclarationFragment)variableDeclaration;
@@ -1614,7 +1616,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		LambdaExpression lambdaExpression = (LambdaExpression)expression;
 		assertEquals("vlambda -> 200", lambdaExpression.toString());
 		IMethodBinding binding = lambdaExpression.resolveMethodBinding();
-		assertEquals("private static int lambda$0(int) ", binding.toString());
+		assertEquals("public int foo(int) ", binding.toString());
+		assertEquals("real modifiers", ClassFileConstants.AccPublic, binding.getModifiers());
 		assertTrue(lambdaExpression.parameters().size() == 1);
 		VariableDeclaration variableDeclaration = (VariableDeclaration) lambdaExpression.parameters().get(0);
 		assertTrue(variableDeclaration instanceof VariableDeclarationFragment);
@@ -1648,7 +1651,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		LambdaExpression lambdaExpression = (LambdaExpression)expression;
 		assertEquals("(int[] ia) -> {\n  return ia.clone();\n}\n", lambdaExpression.toString());
 		IMethodBinding binding = lambdaExpression.resolveMethodBinding();
-		assertEquals("private static java.lang.Object lambda$0(int[]) ", binding.toString());
+		assertEquals("public java.lang.Object foo(int[]) ", binding.toString());
+		assertEquals("real modifiers", ClassFileConstants.AccPublic, binding.getModifiers());
 		assertTrue(lambdaExpression.parameters().size() == 1);
 		VariableDeclaration variableDeclaration = (VariableDeclaration) lambdaExpression.parameters().get(0);
 		assertTrue(variableDeclaration instanceof SingleVariableDeclaration);
@@ -1690,7 +1694,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		LambdaExpression lambdaExpression = (LambdaExpression)expression;
 		assertEquals("() -> {\n  System.out.println(this);\n  I j=() -> {\n    System.out.println(this);\n    I k=() -> {\n      System.out.println(this);\n    }\n;\n  }\n;\n}\n", lambdaExpression.toString());
 		IMethodBinding binding = lambdaExpression.resolveMethodBinding();
-		assertEquals("private void lambda$0() ", binding.toString());
+		assertEquals("public void doit() ", binding.toString());
+		assertEquals("real modifiers", ClassFileConstants.AccPublic, binding.getModifiers());
 		assertTrue(lambdaExpression.parameters().size() == 0);
 	}
 
@@ -1943,7 +1948,8 @@ public class ASTConverter18Test extends ConverterTestSetup {
 		LambdaExpression lambdaExpression = (LambdaExpression)expression;
 		assertEquals("() -> () -> 10", lambdaExpression.toString());
 		IMethodBinding binding = lambdaExpression.resolveMethodBinding();
-		assertEquals("private static test399793.J lambda$0() ", binding.toString());
+		assertEquals("public test399793.J foo() ", binding.toString());
+		assertEquals("real modifiers", ClassFileConstants.AccPublic, binding.getModifiers());
 		assertTrue(lambdaExpression.parameters().size() == 0);
 	}	
 	
@@ -5137,4 +5143,53 @@ public void testBug443232() throws JavaModelException {
 		assertTrue("Test Failed", false);
 	}
 }
+/**
+ * https://bugs.eclipse.org/bugs/show_bug.cgi?id=429813
+ * 
+ * @throws JavaModelException
+ */
+public void test429813() throws JavaModelException {
+	this.workingCopy = getWorkingCopy("/Converter18/src/test429813/Snippet.java",
+			true/* resolve */);
+	String contents = "package test429813;"
+			+ "public class Snippet {\n"
+			+ "		Function<Integer, int[]> m1L = n -> new int[n];\n"
+			+ "}"
+			+ "interface Function<T, R> {\n"
+			+ "   public R apply(T t);\n"
+			+ "}\n";
+	CompilationUnit cu = (CompilationUnit) buildAST(contents, this.workingCopy);
+	TypeDeclaration typedeclaration = (TypeDeclaration) getASTNode(cu, 0);
+	FieldDeclaration fieldDeclaration = (FieldDeclaration) typedeclaration.bodyDeclarations().get(0);
+	VariableDeclarationFragment fragment = (VariableDeclarationFragment)fieldDeclaration.fragments().get(0);
+	Expression expression = fragment.getInitializer();
+	assertTrue(expression instanceof LambdaExpression);
+	LambdaExpression lambdaExpression = (LambdaExpression)expression;
+	IMethodBinding binding = lambdaExpression.resolveMethodBinding();
+	IJavaElement element = binding.getJavaElement();
+	assertEquals("Not a method", IJavaElement.METHOD, element.getElementType());
+	assertFalse("Should not be a synthetic", binding.isSynthetic());
+}
+
+public void test429813a() throws JavaModelException {
+	this.workingCopy = getWorkingCopy("/Converter18/src/test429813/Snippet.java",
+			true/* resolve */);
+	String contents = "package test429813;"
+			+ "interface FTest {\n"
+			+ "		Object foo (int[]... ints);\n"
+			+ "};"
+			+ "class TestX {"
+			+ "		FTest fi= ints -> null;\n"
+			+ "}\n";
+	CompilationUnit cu = (CompilationUnit) buildAST(contents, this.workingCopy);
+	TypeDeclaration typedeclaration = (TypeDeclaration) getASTNode(cu, 1);
+	FieldDeclaration fieldDeclaration = (FieldDeclaration) typedeclaration.bodyDeclarations().get(0);
+	VariableDeclarationFragment fragment = (VariableDeclarationFragment)fieldDeclaration.fragments().get(0);
+	Expression expression = fragment.getInitializer();
+	assertTrue(expression instanceof LambdaExpression);
+	LambdaExpression lambdaExpression = (LambdaExpression)expression;
+	IMethodBinding binding = lambdaExpression.resolveMethodBinding();
+	assertTrue("Should be a varargs", binding.isVarargs());
+}
+
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Initializer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Initializer.java
index ef60d25..3e72271 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Initializer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Initializer.java
@@ -1,14 +1,17 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429813 - [1.8][dom ast] IMethodBinding#getJavaElement() should return IMethod for lambda
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.*;
@@ -23,6 +26,8 @@ public class Initializer extends FieldDeclaration {
 	public int bodyStart;
 	public int bodyEnd;
 
+	private MethodBinding methodBinding;
+
 	public Initializer(Block block, int modifiers) {
 		this.block = block;
 		this.modifiers = modifiers;
@@ -125,6 +130,17 @@ public class Initializer extends FieldDeclaration {
 		}
 	}
 
+	/** Method used only by DOM to support bindings of initializers. */
+	public MethodBinding getMethodBinding() {
+		if (this.methodBinding == null) {
+			Scope scope = this.block.scope;
+			this.methodBinding = isStatic() 
+					? new MethodBinding(ClassFileConstants.AccStatic, CharOperation.NO_CHAR, TypeBinding.VOID, Binding.NO_PARAMETERS, Binding.NO_EXCEPTIONS, scope.enclosingSourceType())
+					: new MethodBinding(0, CharOperation.NO_CHAR, TypeBinding.VOID, Binding.NO_PARAMETERS, Binding.NO_EXCEPTIONS, scope.enclosingSourceType());
+		}
+		return this.methodBinding;
+	}
+
 	public void traverse(ASTVisitor visitor, MethodScope scope) {
 		if (visitor.visit(this, scope)) {
 			if (this.block != null) this.block.traverse(visitor, scope);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
index 90fb62f..8d724bc 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for Bug 342671 - ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding
+ *     Stephan Herrmann - Contribution for
+ *								Bug 342671 - ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding
+ *								Bug 429813 - [1.8][dom ast] IMethodBinding#getJavaElement() should return IMethod for lambda
  *******************************************************************************/
 package org.eclipse.jdt.core.dom;
 
@@ -23,6 +25,7 @@ import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
 import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
+import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.FieldReference;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;
 import org.eclipse.jdt.internal.compiler.ast.JavadocAllocationExpression;
@@ -54,6 +57,7 @@ import org.eclipse.jdt.internal.compiler.lookup.ElementValuePair;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemFieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
@@ -249,6 +253,13 @@ class DefaultBindingResolver extends BindingResolver {
 	 * Method declared on BindingResolver.
 	 */
 	synchronized IMethodBinding getMethodBinding(org.eclipse.jdt.internal.compiler.lookup.MethodBinding methodBinding) {
+		return getMethodOrLambdaBinding(methodBinding, null, null);
+	}
+
+	private synchronized IMethodBinding getMethodOrLambdaBinding(org.eclipse.jdt.internal.compiler.lookup.MethodBinding methodBinding,
+													org.eclipse.jdt.internal.compiler.lookup.MethodBinding descriptor,
+													IBinding enclosingBinding)
+	{
  		if (methodBinding != null && !methodBinding.isValidBinding()) {
 			org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding problemMethodBinding =
 				(org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding) methodBinding;
@@ -263,7 +274,11 @@ class DefaultBindingResolver extends BindingResolver {
 			if (binding != null) {
 				return binding;
 			}
-			binding = new MethodBinding(this, methodBinding);
+			if (descriptor != null && enclosingBinding != null) {
+				binding = new MethodBinding.LambdaMethod(this, descriptor, methodBinding, enclosingBinding);
+			} else {
+				binding = new MethodBinding(this, methodBinding);
+			}
 			this.bindingTables.compilerBindingsToASTBindings.put(methodBinding, binding);
 			return binding;
 		}
@@ -356,6 +371,11 @@ class DefaultBindingResolver extends BindingResolver {
 	 * Method declared on BindingResolver.
 	 */
 	synchronized ITypeBinding getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.TypeBinding referenceBinding) {
+		return internalGetTypeBinding(referenceBinding, null);
+	}
+
+	private synchronized ITypeBinding internalGetTypeBinding(org.eclipse.jdt.internal.compiler.lookup.TypeBinding referenceBinding, IBinding declaringMember) {
+		// may also create an TypeBinding.AnonymousTypeBinding
 		if (referenceBinding == null) {
 			return null;
 		} else if (!referenceBinding.isValidBinding()) {
@@ -369,7 +389,7 @@ class DefaultBindingResolver extends BindingResolver {
 						if (binding != null) {
 							return binding;
 						}
-						binding = new TypeBinding(this, binding2);
+						binding = TypeBinding.createTypeBinding(this, binding2, declaringMember);
 						this.bindingTables.compilerBindingsToASTBindings.put(binding2, binding);
 						return binding;
 					}
@@ -383,7 +403,7 @@ class DefaultBindingResolver extends BindingResolver {
 						return binding;
 					}
 					if ((referenceBinding.tagBits & TagBits.HasMissingType) != 0) {
-						binding = new TypeBinding(this, referenceBinding);
+						binding = TypeBinding.createTypeBinding(this, referenceBinding, declaringMember);
 					} else {
 						binding = new RecoveredTypeBinding(this, referenceBinding);
 					}
@@ -399,7 +419,7 @@ class DefaultBindingResolver extends BindingResolver {
 			if (binding != null) {
 				return binding;
 			}
-			binding = new TypeBinding(this, referenceBinding);
+			binding = TypeBinding.createTypeBinding(this, referenceBinding, declaringMember);
 			this.bindingTables.compilerBindingsToASTBindings.put(referenceBinding, binding);
 			return binding;
 		}
@@ -905,7 +925,12 @@ class DefaultBindingResolver extends BindingResolver {
 		Object oldNode = this.newAstToOldAst.get(lambda);
 		if (oldNode instanceof org.eclipse.jdt.internal.compiler.ast.LambdaExpression) {
 			org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression = (org.eclipse.jdt.internal.compiler.ast.LambdaExpression) oldNode;
-			IMethodBinding methodBinding = getMethodBinding(lambdaExpression.getMethodBinding());
+			IMethodBinding methodBinding = null;
+			if (lambdaExpression.descriptor != null) {
+				IBinding declaringMember = getDeclaringMember(lambdaExpression, lambdaExpression.enclosingScope);
+				if (declaringMember != null)
+					methodBinding = getMethodOrLambdaBinding(lambdaExpression.getMethodBinding(), lambdaExpression.descriptor, declaringMember);
+			}
 			if (methodBinding == null) {
 				return null;
 			}
@@ -918,6 +943,48 @@ class DefaultBindingResolver extends BindingResolver {
 		}
 		return null;
 	}
+
+	private IBinding getDeclaringMember(org.eclipse.jdt.internal.compiler.ast.ASTNode node, Scope currentScope) {
+		MethodScope methodScope = currentScope != null ? currentScope.methodScope() : null;
+		if (methodScope != null) {
+			if (methodScope.isInsideInitializer()) {
+				org.eclipse.jdt.internal.compiler.ast.TypeDeclaration enclosingType = methodScope.referenceType();
+				if (enclosingType.fields != null) {
+					for (int i = 0; i < enclosingType.fields.length; i++) {
+						FieldDeclaration field = enclosingType.fields[i];
+						if (field.declarationSourceStart <= node.sourceStart && node.sourceEnd <= field.declarationSourceEnd) {
+							if (field instanceof org.eclipse.jdt.internal.compiler.ast.Initializer)
+								return getMethodBinding(((org.eclipse.jdt.internal.compiler.ast.Initializer) field).getMethodBinding());
+							else
+								return getVariableBinding(field.binding);
+						}
+					}
+				}
+			} else {
+				if (methodScope.isLambdaScope()) {
+					org.eclipse.jdt.internal.compiler.ast.LambdaExpression lambdaExpression = (org.eclipse.jdt.internal.compiler.ast.LambdaExpression) methodScope.referenceContext;
+					IMethodBinding methodBinding = null;
+					if (lambdaExpression.descriptor != null) {
+						IBinding declaringMember = getDeclaringMember(lambdaExpression, lambdaExpression.enclosingScope);
+						if (declaringMember != null)
+							methodBinding = getMethodOrLambdaBinding(lambdaExpression.getMethodBinding(), lambdaExpression.descriptor, declaringMember);
+					}
+					if (methodBinding == null) {
+						return null;
+					}
+					String key = methodBinding.getKey();
+					if (key != null) {
+						this.bindingTables.bindingKeysToBindings.put(key, methodBinding);
+					}
+					return methodBinding;
+				} else {
+					return getMethodBinding(methodScope.referenceMethodBinding());
+				}
+			}
+		}
+		return null;
+	}
+
 	/*
 	 * Method declared on BindingResolver.
 	 */
@@ -1568,7 +1635,8 @@ class DefaultBindingResolver extends BindingResolver {
 		org.eclipse.jdt.internal.compiler.ast.ASTNode node = (org.eclipse.jdt.internal.compiler.ast.ASTNode) this.newAstToOldAst.get(type);
 		if (node != null && (node.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.IsAnonymousType) != 0) {
 			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration anonymousLocalTypeDeclaration = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) node;
-			ITypeBinding typeBinding = this.getTypeBinding(anonymousLocalTypeDeclaration.binding);
+			IBinding declaringMember = getDeclaringMember(anonymousLocalTypeDeclaration, anonymousLocalTypeDeclaration.scope);
+			ITypeBinding typeBinding = internalGetTypeBinding(anonymousLocalTypeDeclaration.binding, declaringMember);
 			if (typeBinding == null) {
 				return null;
 			}
@@ -1729,7 +1797,8 @@ class DefaultBindingResolver extends BindingResolver {
 		final Object node = this.newAstToOldAst.get(type);
 		if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {
 			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) node;
-			ITypeBinding typeBinding = this.getTypeBinding(typeDeclaration.binding);
+			IBinding declaringMember = getDeclaringMember(typeDeclaration, typeDeclaration.scope);
+			ITypeBinding typeBinding = internalGetTypeBinding(typeDeclaration.binding, declaringMember);
 			if (typeBinding == null) {
 				return null;
 			}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IMethodBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IMethodBinding.java
index 6c424c5..fbca95d 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IMethodBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IMethodBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429813 - [1.8][dom ast] IMethodBinding#getJavaElement() should return IMethod for lambda
  *******************************************************************************/
 
 package org.eclipse.jdt.core.dom;
@@ -86,6 +88,31 @@ public interface IMethodBinding extends IBinding {
 	public ITypeBinding getDeclaringClass();
 
 	/**
+	 * If this method binding represents a lambda expression then:
+	 * <ul>
+	 * <li>If the lambda expression is declared in the body of a method,
+	 *   answers the binding of that declaring method.
+	 * </li>
+	 * <li>Otherwise, if the lambda expression is declared in the 
+	 *   initializer of a field, answers the binding of that declaring field.
+	 * </li>
+	 * <li>Otherwise, if the lambda expression is declared in a static initializer or an
+	 *   instance initializer, a method binding is returned to represent that initializer
+	 *   (selector is an empty string in this case).
+	 * </li>
+	 * </ul>
+	 * <p>
+	 * If this method binding does not represent a lambda expression,
+	 * <code>null</code> is returned.
+	 * </p>
+	 * @return a method binding or field binding representing the member that
+	 * contains the lambda expression represented by this method binding,
+	 * or null for regular method bindings.
+	 * @since 3.11
+	 */
+	public IBinding getDeclaringMember();
+
+	/**
 	 * Returns the resolved default value of an annotation type member,
 	 * or <code>null</code> if the member has no default value, or if this
 	 * is not the binding for an annotation type member.
@@ -292,6 +319,8 @@ public interface IMethodBinding extends IBinding {
 	 * <li>For references to a signature polymorphic method from class MethodHandle,
 	 * returns the declaration of the method. In the reference binding, the parameter types and
 	 * the return type are determined by the concrete invocation context.</li>
+	 * <li>For lambda methods, returns the (possibly parameterized) single abstract method
+	 * of the functional type.</li>
 	 * <li>For other method bindings, this returns the same binding.</li>
 	 * </ul>
 	 *
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ITypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ITypeBinding.java
index efde304..4786097 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ITypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ITypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429813 - [1.8][dom ast] IMethodBinding#getJavaElement() should return IMethod for lambda
  *******************************************************************************/
 
 package org.eclipse.jdt.core.dom;
@@ -251,6 +253,30 @@ public interface ITypeBinding extends IBinding {
 	public IMethodBinding getDeclaringMethod();
 
 	/**
+	 * If this type binding represents a local type, possibly an anonymous class, then:
+	 * <ul>
+	 * <li>If the local type is declared in the body of a method,
+	 *   answers the binding of that declaring method.
+	 * </li>
+	 * <li>Otherwise, if the local type (an anonymous class in this case) is declared
+	 *   in the initializer of a field, answers the binding of that declaring field.
+	 * </li>
+	 * <li>Otherwise, if the local type is declared in a static initializer or
+	 *   an instance initializer, a method binding is returned to represent that initializer
+	 *   (selector is an empty string in this case).
+	 * </li>
+	 * </ul>
+	 * <p>
+	 * If this type binding does not represent a local type, <code>null</code> is returned.
+	 * </p>
+	 * @return a method binding or field binding representing the member that
+	 * contains the local type represented by this type binding,
+	 * or null for non-local type bindings.
+	 * @since 3.11
+	 */
+	public IBinding getDeclaringMember();
+
+	/**
 	 * Returns the dimensionality of this array type, or <code>0</code> if this
 	 * is not an array type binding.
 	 *
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java
index 3a0f5d5..23cba7b 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,12 +7,15 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429813 - [1.8][dom ast] IMethodBinding#getJavaElement() should return IMethod for lambda
  *******************************************************************************/
 
 package org.eclipse.jdt.core.dom;
 
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
@@ -34,8 +37,8 @@ class MethodBinding implements IMethodBinding {
 		Modifier.ABSTRACT | Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.NATIVE |
 		Modifier.STRICTFP | Modifier.DEFAULT;
 	private static final ITypeBinding[] NO_TYPE_BINDINGS = new ITypeBinding[0];
-	private org.eclipse.jdt.internal.compiler.lookup.MethodBinding binding;
-	private BindingResolver resolver;
+	protected org.eclipse.jdt.internal.compiler.lookup.MethodBinding binding;
+	protected BindingResolver resolver;
 	private ITypeBinding[] parameterTypes;
 	private ITypeBinding[] exceptionTypes;
 	private String name;
@@ -114,6 +117,11 @@ class MethodBinding implements IMethodBinding {
 		return this.declaringClass;
 	}
 
+	@Override
+	public IBinding getDeclaringMember() {
+		return null;
+	}
+
 	public IAnnotationBinding[] getParameterAnnotations(int index) {
 		if (getParameterTypes() == NO_TYPE_BINDINGS) {
 			return AnnotationBinding.NoAnnotations;
@@ -463,4 +471,69 @@ class MethodBinding implements IMethodBinding {
 	public String toString() {
 		return this.binding.toString();
 	}
+
+	/*
+	 * Method binding representing a lambda expression.
+	 * Most properties are read from the SAM descriptor,
+	 * but key, parameter types, and annotations are taken from the lambda implementation.
+	 * Additionally we store the declaring member (see #getDeclaringMember()).
+	 */
+	static class LambdaMethod extends MethodBinding {
+
+		private MethodBinding implementation;
+		private IBinding declaringMember;
+
+		public LambdaMethod(DefaultBindingResolver resolver,
+							org.eclipse.jdt.internal.compiler.lookup.MethodBinding lambdaDescriptor,
+							org.eclipse.jdt.internal.compiler.lookup.MethodBinding implementation,
+							IBinding declaringMember)
+		{
+			super(resolver, lambdaDescriptor);
+			this.implementation = new MethodBinding(resolver, implementation);
+			this.declaringMember = declaringMember;
+		}
+
+		/**
+		 * @see IBinding#getModifiers()
+		 */
+		public int getModifiers() {
+			return super.getModifiers() & ~ClassFileConstants.AccAbstract;
+		}
+
+		/**
+		 * @see IBinding#getKey()
+		 */
+		public String getKey() {
+			return this.implementation.getKey();
+		}
+
+		@Override
+		public ITypeBinding[] getParameterTypes() {
+			return this.implementation.getParameterTypes();
+		}
+
+		@Override
+		public IAnnotationBinding[] getParameterAnnotations(int paramIndex) {
+			return this.implementation.getParameterAnnotations(paramIndex);
+		}
+
+		public IAnnotationBinding[] getAnnotations() {
+			return this.implementation.getAnnotations();
+		}
+
+		@Override
+		public IBinding getDeclaringMember() {
+			return this.declaringMember;
+		}
+
+		@Override
+		public IMethodBinding getMethodDeclaration() {
+			return this.resolver.getMethodBinding(this.binding);
+		}
+
+		@Override
+		public String toString() {
+			return super.toString().replace("public abstract ", "public ");  //$NON-NLS-1$//$NON-NLS-2$
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
index fe2cb25..c126584 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/RecoveredTypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2014 IBM Corporation and others.
+ * Copyright (c) 2007, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429813 - [1.8][dom ast] IMethodBinding#getJavaElement() should return IMethod for lambda
  *******************************************************************************/
 
 package org.eclipse.jdt.core.dom;
@@ -155,6 +157,14 @@ class RecoveredTypeBinding implements ITypeBinding {
 	}
 
 	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.dom.ITypeBinding#getDeclaringMember()
+	 */
+	@Override
+	public IBinding getDeclaringMember() {
+		return null;
+	}
+
+	/* (non-Javadoc)
 	 * @see org.eclipse.jdt.core.dom.ITypeBinding#getDimensions()
 	 */
 	public int getDimensions() {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
index 94e2d48..1fdc509 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
+ *								Bug 429813 - [1.8][dom ast] IMethodBinding#getJavaElement() should return IMethod for lambda
  *******************************************************************************/
 
 package org.eclipse.jdt.core.dom;
@@ -25,7 +26,6 @@ import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
-import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
@@ -60,7 +60,7 @@ class TypeBinding implements ITypeBinding {
 	org.eclipse.jdt.internal.compiler.lookup.TypeBinding binding;
 	private TypeBinding prototype = null;
 	private String key;
-	private BindingResolver resolver;
+	protected BindingResolver resolver;
 	private IVariableBinding[] fields;
 	private IAnnotationBinding[] annotations;
 	private IAnnotationBinding[] typeAnnotations;
@@ -71,6 +71,18 @@ class TypeBinding implements ITypeBinding {
 	private ITypeBinding[] bounds;
 	private ITypeBinding[] typeParameters;
 
+	/**
+	 * Create either a regular TypeBinding or an AnonymousTypeBinding (if declaringMember is given).
+	 */
+	public static TypeBinding createTypeBinding(BindingResolver resolver,
+												org.eclipse.jdt.internal.compiler.lookup.TypeBinding referenceBinding,
+												IBinding declaringMember)
+	{
+		return declaringMember != null
+					? new LocalTypeBinding(resolver, referenceBinding, declaringMember)
+					: new TypeBinding(resolver, referenceBinding);
+	}
+
 	public TypeBinding(BindingResolver resolver, org.eclipse.jdt.internal.compiler.lookup.TypeBinding binding) {
 		this.binding = binding;
 		this.resolver = resolver;
@@ -369,8 +381,8 @@ class TypeBinding implements ITypeBinding {
 	 * @see ITypeBinding#getDeclaringMethod()
 	 */
 	public synchronized IMethodBinding getDeclaringMethod() {
-		if (this.binding instanceof LocalTypeBinding) {
-			LocalTypeBinding localTypeBinding = (LocalTypeBinding) this.binding;
+		if (this.binding instanceof org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding) {
+			org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding localTypeBinding = (org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding) this.binding;
 			MethodBinding methodBinding = localTypeBinding.enclosingMethod;
 			if (methodBinding != null) {
 				try {
@@ -440,6 +452,11 @@ class TypeBinding implements ITypeBinding {
 		return null;
 	}
 
+	@Override
+	public IBinding getDeclaringMember() {
+		return null;
+	}
+
 	/*
 	 * @see ITypeBinding#getDimensions()
 	 */
@@ -1345,4 +1362,22 @@ class TypeBinding implements ITypeBinding {
 		this.typeAnnotations = resolveAnnotationBindings(this.binding.getTypeAnnotations(), true);
 		return this.typeAnnotations;
 	}
+
+	static class LocalTypeBinding extends TypeBinding {
+
+		private IBinding declaringMember;
+
+		public LocalTypeBinding(BindingResolver resolver,
+									org.eclipse.jdt.internal.compiler.lookup.TypeBinding binding,
+									IBinding declaringMember)
+		{
+			super(resolver, binding);
+			this.declaringMember = declaringMember;
+		}
+
+		@Override
+		public IBinding getDeclaringMember() {
+			return this.declaringMember;
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
index 1b511e8..7e27571 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 429813 - [1.8][dom ast] IMethodBinding#getJavaElement() should return IMethod for lambda
  *******************************************************************************/
 
 package org.eclipse.jdt.core.dom;
@@ -152,6 +154,9 @@ class VariableBinding implements IVariableBinding {
 					case ASTNode.METHOD_DECLARATION :
 						MethodDeclaration methodDeclaration = (MethodDeclaration) node;
 						return methodDeclaration.resolveBinding();
+					case ASTNode.LAMBDA_EXPRESSION :
+						LambdaExpression lambdaExpression = (LambdaExpression) node;
+						return lambdaExpression.resolveMethodBinding();
 					default:
 						node = node.getParent();
 				}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DOMFinder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DOMFinder.java
index d27901f..19629a2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DOMFinder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DOMFinder.java
@@ -10,10 +10,12 @@
  *     Stephan Herrmann - Contributions for
  *								Bug 463330 - [dom] DOMFinder doesn't find the VariableBinding corresponding to a method argument
  *								Bug 464463 - [dom] DOMFinder doesn't find an ITypeParameter
+ *								Bug 429813 - [1.8][dom ast] IMethodBinding#getJavaElement() should return IMethod for lambda
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
 
 import org.eclipse.jdt.core.IInitializer;
+import org.eclipse.jdt.core.ILocalVariable;
 import org.eclipse.jdt.core.IMember;
 import org.eclipse.jdt.core.ISourceRange;
 import org.eclipse.jdt.core.ITypeParameter;
@@ -30,6 +32,7 @@ import org.eclipse.jdt.core.dom.EnumDeclaration;
 import org.eclipse.jdt.core.dom.IBinding;
 import org.eclipse.jdt.core.dom.ImportDeclaration;
 import org.eclipse.jdt.core.dom.Initializer;
+import org.eclipse.jdt.core.dom.LambdaExpression;
 import org.eclipse.jdt.core.dom.MarkerAnnotation;
 import org.eclipse.jdt.core.dom.MethodDeclaration;
 import org.eclipse.jdt.core.dom.NormalAnnotation;
@@ -40,6 +43,7 @@ import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
 import org.eclipse.jdt.core.dom.TypeDeclaration;
 import org.eclipse.jdt.core.dom.TypeParameter;
 import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
+import org.eclipse.jdt.internal.core.LambdaMethod;
 import org.eclipse.jdt.internal.core.SourceRefElement;
 
 public class DOMFinder extends ASTVisitor {
@@ -68,10 +72,11 @@ public class DOMFinder extends ASTVisitor {
 
 	public ASTNode search() throws JavaModelException {
 		ISourceRange range = null;
-		if (this.element instanceof IMember && !(this.element instanceof IInitializer))
+		if (this.element instanceof IMember && !(this.element instanceof IInitializer)
+				&& !(this.element instanceof LambdaMethod) && !(this.element instanceof org.eclipse.jdt.internal.core.LambdaExpression))
 			range = ((IMember) this.element).getNameRange();
-		else if (this.element instanceof ITypeParameter)
-			range = ((ITypeParameter) this.element).getNameRange();
+		else if (this.element instanceof ITypeParameter || this.element instanceof ILocalVariable)
+			range = this.element.getNameRange();
 		else
 			range = this.element.getSourceRange();
 		this.rangeStart = range.getOffset();
@@ -186,8 +191,14 @@ public class DOMFinder extends ASTVisitor {
 	}
 
 	public boolean visit(SingleVariableDeclaration node) {
-		if (found(node, node) && this.resolveBinding)
+		if (found(node, node.getName()) && this.resolveBinding)
 			this.foundBinding = node.resolveBinding();
 		return true;		
 	}
+
+	public boolean visit(LambdaExpression node) {
+		if (found(node, node) && this.resolveBinding)
+			this.foundBinding = node.resolveMethodBinding();
+		return true;
+	}
 }
