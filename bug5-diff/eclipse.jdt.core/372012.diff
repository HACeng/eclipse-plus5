commit a234173ab4d645c8990c97cafa00ec82ce0a909f
Author: Ayushman Jain <ajain>
Date:   Wed Mar 7 13:30:58 2012 +0530

    Fixed bug 372012: [compiler][null] Warn when defaults not specified

253	2	org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/PackageInfoTest.java
86	64	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
4	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
59	59	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
33	9	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
2	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
2	3	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
14	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
8	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
26	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
36	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
13	12	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
35	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
4	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
diff --git a/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/PackageInfoTest.java b/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/PackageInfoTest.java
index 8a47ebd..a412e09 100644
--- a/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/PackageInfoTest.java
+++ b/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/PackageInfoTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,6 +10,8 @@
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.builder;
 
+import java.io.File;
+import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.Arrays;
@@ -17,7 +19,13 @@ import java.util.Arrays;
 import junit.framework.Test;
 
 import org.eclipse.core.resources.IMarker;
+import org.eclipse.core.runtime.FileLocator;
 import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.core.runtime.Platform;
+import org.eclipse.jdt.core.IClasspathEntry;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
 import org.eclipse.jdt.core.tests.util.Util;
@@ -30,7 +38,7 @@ public PackageInfoTest(String name) {
 // Static initializer to specify tests subset using TESTS_* static variables
 // All specified tests which does not belong to the class are skipped...
 static {
-//	TESTS_NAMES = new String[] { "test000" };
+//	TESTS_NAMES = new String[] { "testBug372012" };
 //	TESTS_NUMBERS = new int[] { 3 };
 //	TESTS_RANGE = new int[] { 21, 50 };
 }
@@ -276,6 +284,249 @@ public void test323785a () throws JavaModelException {
 			new Problem("X.java", "The type X cannot subclass the final class Y", xJavaPath, 16, 17, CategorizedProblem.CAT_TYPE, IMarker.SEVERITY_ERROR));
 	
 }
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
+// test missing default nullness annotation for a package without package-info
+// test when the package-info is added with the default annotation, the problem disappears
+public void testBug372012() throws JavaModelException, IOException {
+	
+	IPath projectPath = env.addProject("Project", "1.5"); 
+	env.addExternalJars(projectPath, Util.getJavaClassLibs());
+	fullBuild(projectPath);
+
+	// remove old package fragment root so that names don't collide
+	env.removePackageFragmentRoot(projectPath, ""); 
+
+	IPath srcRoot = env.addPackageFragmentRoot(projectPath, "src");
+	env.setOutputFolder(projectPath, "bin"); 
+	// prepare the project:
+	setupProjectForNullAnnotations(projectPath);
+	env.getJavaProject(projectPath).setOption(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION, JavaCore.ERROR);
+	env.getJavaProject(projectPath).setOption(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION, JavaCore.ERROR);
+	String test1Code = "package p1;\n"	+
+		"public class Test1 {\n" +
+		"    public void foo() {\n" +
+		"        new Test2().bar(\"\");\n" +
+		"    }\n" +
+		"	 class Test1Inner{}\n" +
+		"}";
+	String test2Code = "package p1;\n" +
+		"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+		"public class Test2 {\n" +
+		"    public void bar(String str) {}\n" +
+		"}";
+	String test3Code = "package p1;\n" +
+			"public class Test3 {\n" +
+			"    public void bar(String str) {}\n" +
+			"}";
+
+	IPath test1Path = env.addClass(srcRoot, "p1", "Test1", test1Code);
+	env.addClass(srcRoot, "p1", "Test2", test2Code);
+	env.addClass(srcRoot, "p1", "Test3", test3Code);
+	
+	fullBuild(projectPath);
+	expectingNoProblemsFor(test1Path);
+	// should have only one marker
+	expectingProblemsFor(srcRoot, 
+			"Problem : A default nullness annotation has not been specified for the package p1 [ resource : </Project/src/p1> range : <8,10> category : <90> severity : <2>]");
+
+	// add package-info.java with default annotation
+	String packageInfoCode = "@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+		"package p1;\n";
+	env.addClass(srcRoot, "p1", "package-info", packageInfoCode);
+	incrementalBuild(projectPath);
+	expectingProblemsFor(projectPath,
+			"Problem : Nullness default is redundant with a default specified for the enclosing package p1 [ resource : </Project/src/p1/Test2.java> range : <12,56> category : <120> severity : <2>]");
+
+	// verify that all package CU's were recompiled
+	expectingUniqueCompiledClasses(new String[] { "p1.Test1", "p1.Test1$Test1Inner", "p1.Test2", "p1.Test3", "p1.package-info" });
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
+// test missing default nullness annotation for a package without package-info
+// test when the the default annotations are added to all top level types, the problem stays
+public void testBug372012a() throws JavaModelException, IOException {
+	
+	IPath projectPath = env.addProject("Project", "1.5"); 
+	env.addExternalJars(projectPath, Util.getJavaClassLibs());
+	fullBuild(projectPath);
+
+	// remove old package fragment root so that names don't collide
+	env.removePackageFragmentRoot(projectPath, ""); 
+
+	IPath srcRoot = env.addPackageFragmentRoot(projectPath, "src");
+	env.setOutputFolder(projectPath, "bin"); 
+	// prepare the project:
+	setupProjectForNullAnnotations(projectPath);
+	env.getJavaProject(projectPath).setOption(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION, JavaCore.ERROR);
+	env.getJavaProject(projectPath).setOption(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION, JavaCore.ERROR);
+	String test1Code = "package p1;\n"	+
+		"public class Test1 {\n" +
+		"    public void foo() {\n" +
+		"        new Test2().bar(\"\");\n" +
+		"    }\n" +
+		"	 class Test1Inner{}\n" +
+		"}";
+	String test2Code = "package p1;\n" +
+		"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+		"public class Test2 {\n" +
+		"    public void bar(String str) {}\n" +
+		"}";
+
+	IPath test1Path = env.addClass(srcRoot, "p1", "Test1", test1Code);
+	env.addClass(srcRoot, "p1", "Test2", test2Code);
+	
+	fullBuild(projectPath);
+	expectingNoProblemsFor(test1Path);
+	// should have only one marker
+	expectingProblemsFor(srcRoot, 
+			"Problem : A default nullness annotation has not been specified for the package p1 [ resource : </Project/src/p1> range : <8,10> category : <90> severity : <2>]");
+
+	// add default annotation to Test1
+	test1Code = "package p1;\n"	+
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"public class Test1 {\n" +
+			"    public void foo() {\n" +
+			"        new Test2().bar(\"\");\n" +
+			"    }\n" +
+			"	 class Test1Inner{}\n" +
+			"}";
+	env.addClass(srcRoot, "p1", "Test1", test1Code);
+	incrementalBuild(projectPath);
+	// should have only one marker
+	expectingProblemsFor(srcRoot, 
+			"Problem : A default nullness annotation has not been specified for the package p1 [ resource : </Project/src/p1> range : <8,10> category : <90> severity : <2>]");
+
+	// verify that all package CU's were recompiled
+	expectingUniqueCompiledClasses(new String[] { "p1.Test1", "p1.Test1$Test1Inner"});
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
+// test missing default nullness annotation for a package without package-info
+// test when the the default annotations is added to only 1 top level type, the problem stays
+public void testBug372012b() throws JavaModelException, IOException {
+	
+	IPath projectPath = env.addProject("Project", "1.5"); 
+	env.addExternalJars(projectPath, Util.getJavaClassLibs());
+	fullBuild(projectPath);
+
+	// remove old package fragment root so that names don't collide
+	env.removePackageFragmentRoot(projectPath, ""); 
+
+	IPath srcRoot = env.addPackageFragmentRoot(projectPath, "src");
+	env.setOutputFolder(projectPath, "bin"); 
+	// prepare the project:
+	setupProjectForNullAnnotations(projectPath);
+	env.getJavaProject(projectPath).setOption(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION, JavaCore.ERROR);
+	env.getJavaProject(projectPath).setOption(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION, JavaCore.ERROR);
+	String test1Code = "package p1;\n"	+
+		"public class Test1 {\n" +
+		"    public void foo() {\n" +
+		"        new Test2().bar(\"\");\n" +
+		"    }\n" +
+		"	 class Test1Inner{}\n" +
+		"}";
+	String test2Code = "package p1;\n" +
+		"public class Test2 {\n" +
+		"    public void bar(String str) {}\n" +
+		"}";
+
+	IPath test1Path = env.addClass(srcRoot, "p1", "Test1", test1Code);
+	env.addClass(srcRoot, "p1", "Test2", test2Code);
+	
+	fullBuild(projectPath);
+	expectingNoProblemsFor(test1Path);
+	// should have only one marker
+	expectingProblemsFor(srcRoot, 
+			"Problem : A default nullness annotation has not been specified for the package p1 [ resource : </Project/src/p1> range : <8,10> category : <90> severity : <2>]");
+
+	// add default annotation to Test1
+	test1Code = "package p1;\n"	+
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"public class Test1 {\n" +
+			"    public void foo() {\n" +
+			"        new Test2().bar(\"\");\n" +
+			"    }\n" +
+			"	 class Test1Inner{}\n" +
+			"}";
+	env.addClass(srcRoot, "p1", "Test1", test1Code);
+	incrementalBuild(projectPath);
+	// should have only one marker
+	expectingProblemsFor(srcRoot, 
+			"Problem : A default nullness annotation has not been specified for the package p1 [ resource : </Project/src/p1> range : <8,10> category : <90> severity : <2>]");
+
+	// verify that only Test1's CU's were recompiled
+	expectingUniqueCompiledClasses(new String[] { "p1.Test1", "p1.Test1$Test1Inner"});
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
+// test missing default nullness annotation for a package with package-info
+// test when the the default annotation is removed from package-info, the problem comes back
+public void testBug372012c() throws JavaModelException, IOException {
+	
+	IPath projectPath = env.addProject("Project", "1.5"); 
+	env.addExternalJars(projectPath, Util.getJavaClassLibs());
+	fullBuild(projectPath);
+
+	// remove old package fragment root so that names don't collide
+	env.removePackageFragmentRoot(projectPath, ""); 
+
+	IPath srcRoot = env.addPackageFragmentRoot(projectPath, "src");
+	env.setOutputFolder(projectPath, "bin"); 
+	// prepare the project:
+	setupProjectForNullAnnotations(projectPath);
+	env.getJavaProject(projectPath).setOption(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION, JavaCore.ERROR);
+	env.getJavaProject(projectPath).setOption(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION, JavaCore.ERROR);
+	String test1Code = "package p1;\n"	+
+		"public class Test1 {\n" +
+		"    public void foo() {\n" +
+		"        new Test2().bar(\"\");\n" +
+		"    }\n" +
+		"	 class Test1Inner{}\n" +
+		"}";
+	String test2Code = "package p1;\n" +
+		"public class Test2 {\n" +
+		"    public void bar(String str) {}\n" +
+		"}";
+	// add package-info.java with default annotation
+	String packageInfoCode = "@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+		"package p1;\n";
+	env.addClass(srcRoot, "p1", "package-info", packageInfoCode);
+
+	env.addClass(srcRoot, "p1", "Test1", test1Code);
+	env.addClass(srcRoot, "p1", "Test2", test2Code);
+	env.addClass(srcRoot, "p1", "package-info", packageInfoCode);
+	
+	fullBuild(projectPath);
+	// default annotation present, so no problem
+	expectingNoProblemsFor(srcRoot);
+
+	// add package-info.java with default annotation
+	packageInfoCode =
+		"package p1;\n";
+	env.addClass(srcRoot, "p1", "package-info", packageInfoCode);
+	incrementalBuild(projectPath);
+	expectingProblemsFor(projectPath,
+			"Problem : A default nullness annotation has not been specified for the package p1 [ resource : </Project/src/p1/package-info.java> range : <8,10> category : <90> severity : <2>]");
+
+	// verify that all package CU's were recompiled
+	expectingUniqueCompiledClasses(new String[] { "p1.Test1", "p1.Test1$Test1Inner", "p1.Test2", "p1.package-info" });
+}
+
+void setupProjectForNullAnnotations(IPath projectPath) throws IOException, JavaModelException {
+	// add the org.eclipse.jdt.annotation library (bin/ folder or jar) to the project:
+	File bundleFile = FileLocator.getBundleFile(Platform.getBundle("org.eclipse.jdt.annotation"));
+	String annotationsLib = bundleFile.isDirectory() ? bundleFile.getPath()+"/bin" : bundleFile.getPath();
+	IJavaProject javaProject = env.getJavaProject(projectPath);
+	IClasspathEntry[] rawClasspath = javaProject.getRawClasspath();
+	int len = rawClasspath.length;
+	System.arraycopy(rawClasspath, 0, rawClasspath = new IClasspathEntry[len+1], 0, len);
+	rawClasspath[len] = JavaCore.newLibraryEntry(new Path(annotationsLib), null, null);
+	javaProject.setRawClasspath(rawClasspath, null);
+
+	javaProject.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+}
+
 protected void assertSourceEquals(String message, String expected, String actual) {
 	if (actual == null) {
 		assertEquals(message, expected, null);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 030f0fd..2bce5c6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -79,7 +79,7 @@ public class BatchCompilerTest extends AbstractRegressionTest {
 			"}\n";
 
 	static {
-//		TESTS_NAMES = new String[] { "test31" };
+		TESTS_NAMES = new String[] { "test315_warn_options_a" };
 //		TESTS_NUMBERS = new int[] { 306 };
 //		TESTS_RANGE = new int[] { 298, -1 };
 	}
@@ -1644,9 +1644,8 @@ public void test012(){
         "    -enableJavadoc     consider references in javadoc\n" +
         "    -Xemacs            used to enable emacs-style output in the console.\n" +
         "                       It does not affect the xml log output\n" +
-        "    -nonNullByDefault  for annotation based null analysis assume nonnull\n" + 
-        "                       as the global default\n" + 
-        " \n" +
+        "    -missingNullDefault  report missing default nullness annotation\n" + 
+        " \n" + 
         "    -? -help           print this help message\n" +
         "    -v -version        print compiler version\n" +
         "    -showversion       print compiler version and continue\n" +
@@ -1838,9 +1837,9 @@ public void test012b(){
 			"		<argument value=\"---OUTPUT_DIR_PLACEHOLDER---\"/>\n" + 
 			"	</command_line>\n" + 
 			"	<options>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.nonnull\" value=\"org.eclipse.jdt.annotation.NonNull\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.nonnullbydefault\" value=\"org.eclipse.jdt.annotation.NonNullByDefault\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.nonnullisdefault\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.nullable\" value=\"org.eclipse.jdt.annotation.Nullable\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.nullanalysis\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode\" value=\"disabled\"/>\n" + 
@@ -12597,32 +12596,28 @@ public void test314_warn_options() {
 		true);
 }
 
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=325342
-// -warn option - regression tests to check option nullAnnot
-// Null warnings because of annotations, global nonNullByDefault
-// DISABLED due to dysfunctional global default after Bug 366063 - Compiler should not add synthetic @NonNull annotations
-public void _test315_warn_options() {
+// -warn option - regression tests to check option nullAnnot and missingNullDefault
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
+public void test315_warn_options() {
 	this.runConformTest(
 		new String[] {
+				"p/package-info.java",
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+				"package p;\n",
 				"p/X.java",
 				"package p;\n" +
-				"import org.eclipse.jdt.annotation.*;\n" +
-				"@SuppressWarnings(\"unused\")\n" +
 				"public class X {\n" +
-				"  Object foo(@Nullable Object o, Object o2) {\n" +
-				"    if (o.toString() == \"\"){ return null;}\n" +
-				"    if (o2 == null) {}\n" +
-				"    goo(null).toString();\n" +
-				"	 return null;\n" +
-				"  }\n" +
-				"  @Nullable Object goo(Object o2) {\n" +
-				"    return new Object();\n" +
-				"  }\n" +
-				"  @NonNullByDefault Object hoo(Object o2) {\n" + // redundant
-				"    if (o2 == null)\n" +
-				"	    return null;\n" +
-				"    return this;\n" +
-				"  }\n" +
+				"}\n",
+				"p1/X1.java",
+				"package p1;\n" +
+				"public class X1 {\n" +
+				"}\n",
+				"p1/X1a.java",
+				"package p1;\n" +
+				"public class X1a {\n" +
+				"}\n",
+				"Default1.java",
+				"public class Default1 {\n" +
 				"}\n",
 				"org/eclipse/jdt/annotation/NonNull.java",
 				NONNULL_ANNOTATION_CONTENT,
@@ -12634,50 +12629,77 @@ public void _test315_warn_options() {
 		"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
 		+ " -sourcepath \"" + OUTPUT_DIR + "\""
 		+ " -1.5"
-		+ " -warn:+nullAnnot -warn:+null -nonNullByDefault -proc:none -d \"" + OUTPUT_DIR + "\"",
+		+ " -warn:+nullAnnot -warn:+null -missingNullDefault -proc:none -d \"" + OUTPUT_DIR + "\"",
+		"",
+		"",
+		true);
+}
+
+// -warn option - regression tests to check option nullAnnot and missingNullDefault
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
+public void test315_warn_options_a() {
+	this.runConformTest(
+		new String[] {
+				"p1/X1.java",
+				"package p1;\n" +
+				"public class X1 {\n" +
+				"   class Inner{};\n" +
+				"}\n",
+				"org/eclipse/jdt/annotation/NonNull.java",
+				NONNULL_ANNOTATION_CONTENT,
+				"org/eclipse/jdt/annotation/Nullable.java",
+				NULLABLE_ANNOTATION_CONTENT,
+				"org/eclipse/jdt/annotation/NonNullByDefault.java",				
+				NONNULL_BY_DEFAULT_ANNOTATION_CONTENT
+		},
+		"\"" + OUTPUT_DIR +  File.separator + "p1" + File.separator + "X1.java\""
+		+ " -sourcepath \"" + OUTPUT_DIR + "\""
+		+ " -1.5"
+		+ " -warn:+nullAnnot -warn:+null -missingNullDefault -proc:none -d \"" + OUTPUT_DIR + "\"",
 		"",
 		"----------\n" + 
-		"1. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 6)\n" + 
-		"	if (o.toString() == \"\"){ return null;}\n" + 
-		"	    ^\n" + 
-		"Potential null pointer access: The variable o may be null at this location\n" + 
-		"----------\n" + 
-		"2. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 6)\n" + 
-		"	if (o.toString() == \"\"){ return null;}\n" + 
-		"	                                ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
-		"----------\n" + 
-		"3. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 7)\n" + 
-		"	if (o2 == null) {}\n" + 
-		"	    ^^\n" + 
-		"Null comparison always yields false: The variable o2 cannot be null at this location\n" + 
-		"----------\n" + 
-		"4. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 8)\n" + 
-		"	goo(null).toString();\n" + 
-		"	^^^^^^^^^\n" + 
-		"Potential null pointer access: The method goo(Object) may return null\n" + 
-		"----------\n" + 
-		"5. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 8)\n" + 
-		"	goo(null).toString();\n" + 
-		"	    ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"1. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p1/X1.java (at line 1)\n" + 
+		"	package p1;\n" + 
+		"	        ^^\n" + 
+		"A default nullness annotation has not been specified for the package p1\n" + 
 		"----------\n" + 
-		"6. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 9)\n" + 
-		"	return null;\n" + 
-		"	       ^^^^\n" + 
-		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"1 problem (1 warning)", 
+		true);
+}
+
+// -warn option - regression tests to check option nullAnnot and missingNullDefault
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
+public void test315_warn_options_b() {
+	this.runNegativeTest(
+		new String[] {
+				"X1.java",
+				"public class X1 {\n" +
+				"	Zork;\n" +
+				"}\n",
+				"org/eclipse/jdt/annotation/NonNull.java",
+				NONNULL_ANNOTATION_CONTENT,
+				"org/eclipse/jdt/annotation/Nullable.java",
+				NULLABLE_ANNOTATION_CONTENT,
+				"org/eclipse/jdt/annotation/NonNullByDefault.java",				
+				NONNULL_BY_DEFAULT_ANNOTATION_CONTENT
+		},
+		"\"" + OUTPUT_DIR +  File.separator + "X1.java\""
+		+ " -sourcepath \"" + OUTPUT_DIR + "\""
+		+ " -1.5"
+		+ " -warn:+nullAnnot -warn:+null -missingNullDefault -proc:none -d \"" + OUTPUT_DIR + "\"",
+		"",
 		"----------\n" + 
-		"7. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 14)\n" + 
-		"	@NonNullByDefault Object hoo(Object o2) {\n" + 
-		"	^^^^^^^^^^^^^^^^^\n" + 
-		"Nullness default is redundant with the global default\n" + 
+		"1. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/X1.java (at line 1)\n" + 
+		"	public class X1 {\n" + 
+		"	             ^^\n" + 
+		"A default nullness annotation has not been specified for the type X1\n" + 
 		"----------\n" + 
-		"8. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/p/X.java (at line 15)\n" + 
-		"	if (o2 == null)\n" + 
-		"	    ^^\n" + 
-		"Null comparison always yields false: The variable o2 cannot be null at this location\n" + 
+		"2. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/X1.java (at line 2)\n" + 
+		"	Zork;\n" + 
+		"	^^^^\n" + 
+		"Syntax error on token \"Zork\", VariableDeclarator expected after this token\n" + 
 		"----------\n" + 
-		"8 problems (8 warnings)", 
+		"2 problems (1 error, 1 warning)", 
 		true);
 }
 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 23dcb7b..f86c58a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -698,6 +698,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("MissingEnclosingInstanceForConstructorCall", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("MissingEnumConstantCase", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("MissingEnumDefaultCase", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("MissingNonNullByDefaultAnnotationOnPackage", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("MissingNonNullByDefaultAnnotationOnType", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("MissingOverrideAnnotation", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("MissingOverrideAnnotationForInterfaceMethodImplementation", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("MissingReturnType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
@@ -1393,6 +1395,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("MissingEnclosingInstanceForConstructorCall", SKIP);
 		expectedProblemAttributes.put("MissingEnumConstantCase", new ProblemAttributes(JavaCore.COMPILER_PB_INCOMPLETE_ENUM_SWITCH));
 		expectedProblemAttributes.put("MissingEnumDefaultCase", new ProblemAttributes(JavaCore.COMPILER_PB_INCOMPLETE_ENUM_SWITCH));
+		expectedProblemAttributes.put("MissingNonNullByDefaultAnnotationOnPackage", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION));
+		expectedProblemAttributes.put("MissingNonNullByDefaultAnnotationOnType", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION));
 		expectedProblemAttributes.put("MissingOverrideAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_OVERRIDE_ANNOTATION));
 		expectedProblemAttributes.put("MissingOverrideAnnotationForInterfaceMethodImplementation", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_OVERRIDE_ANNOTATION));
 		expectedProblemAttributes.put("MissingReturnType", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index b64e5e8..738bfdd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -53,7 +53,7 @@ public NullAnnotationTest(String name) {
 // Static initializer to specify tests subset using TESTS_* static variables
 // All specified tests which do not belong to the class are skipped...
 static {
-//		TESTS_NAMES = new String[] { "testBug372011" };
+//		TESTS_NAMES = new String[] { "test_missing_default_annotation_03" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -1914,29 +1914,6 @@ public void test_annotation_import_006() {
 		"----------\n",
 		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
-// using nullness defaulting to nonnull, missing annotation types, no longer a problem
-public void test_annotation_import_007() {
-	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
-	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.MayBeNull");
-	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.MustNotBeNull");
-	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
-	runConformTestWithLibs(
-		new String[] {
-			"Lib.java",
-			"public class Lib {\n" +
-			"    Object getObject() { return new Object(); }\n" +
-			"}\n",
-			"X.java",
-			"public class X {\n" +
-			"    Object getObject(Lib l) {\n" +
-			"        return l.getObject();\n" +
-			"    }\n" +
-			"}\n"
-		},
-		customOptions,
-		"");
-}
 
 // a null annotation is illegally used on a class:
 public void test_illegal_annotation_001() {
@@ -2409,7 +2386,7 @@ public void test_default_nullness_006() {
 public void _test_default_nullness_007() {
 	Map customOptions = getCompilerOptions();
 //	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
-	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
+//	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
 	runNegativeTestWithLibs(
 		new String[] {
 			"X.java",
@@ -2860,48 +2837,75 @@ public void test_redundant_annotation_02g() {
 		"----------\n");
 }
 
-// redundant default annotations - package / class / method vs global default
-// DISABLED due to dysfunctional global default after Bug 366063 - Compiler should not add synthetic @NonNull annotations
-public void _test_redundant_annotation_03() {
+// test missing default nullness annotation for types in default package
+public void test_missing_default_annotation_01() {
 	Map customOptions = getCompilerOptions();
-	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
-	runConformTestWithLibs(
+	customOptions.put(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION, JavaCore.ERROR);
+	runNegativeTestWithLibs(
 		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"public class X {\n" +
+			"	 class XInner{}\n" +  // don't warn for inner types
+			"    Object getObject(Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in Lib.java (at line 1)\n" + 
+		"	public class Lib {\n" + 
+		"	             ^^^\n" + 
+		"A default nullness annotation has not been specified for the type Lib\n" + 
+		"----------\n" + 
+		"----------\n" + 
+		"1. ERROR in X.java (at line 1)\n" + 
+		"	public class X {\n" + 
+		"	             ^\n" + 
+		"A default nullness annotation has not been specified for the type X\n" + 
+		"----------\n");
+}
+
+// test missing default nullness annotation for a package with package-info
+public void test_missing_default_annotation_02() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"p2/package-info.java",
+			"package p2;\n",
 			"p2/Y.java",
 			"package p2;\n" +
 			"import org.eclipse.jdt.annotation.*;\n" +
 			"@NonNullByDefault\n" +
 			"public class Y {\n" +
-			"    @NonNullByDefault void foo() {}\n" +
-			"}\n" +
-			"class Z {\n" +
-			"    @NonNullByDefault void bar() {}\n" +
+			"   void foo() {}\n" +
 			"}\n",
 			"p3/package-info.java",
-			"@org.eclipse.jdt.annotation.NonNullByDefault package p3;\n"
+			"@org.eclipse.jdt.annotation.NonNullByDefault package p3;\n",
+			"p3/Z.java",
+			"package p3;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Z {\n" +
+			"    @NonNullByDefault void bar() {}\n" +
+			"}\n",
 		},
 		customOptions,
 		"----------\n" + 
-		"1. WARNING in p2\\Y.java (at line 3)\n" +
-		"	@NonNullByDefault\n" +
-		"	^^^^^^^^^^^^^^^^^\n" +
-		"Nullness default is redundant with the global default\n" +
-		"----------\n" +
-		"2. WARNING in p2\\Y.java (at line 5)\n" +
-		"	@NonNullByDefault void foo() {}\n" +
-		"	^^^^^^^^^^^^^^^^^\n" +
-		"Nullness default is redundant with a default specified for the enclosing type Y\n" +
-		"----------\n" +
-		"3. WARNING in p2\\Y.java (at line 8)\n" +
-		"	@NonNullByDefault void bar() {}\n" +
-		"	^^^^^^^^^^^^^^^^^\n" +
-		"Nullness default is redundant with the global default\n" +
-		"----------\n" +
-		"----------\n" +
-		"1. WARNING in p3\\package-info.java (at line 1)\n" +
-		"	@org.eclipse.jdt.annotation.NonNullByDefault package p3;\n" +
-		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-		"Nullness default is redundant with the global default\n" +
+		"1. ERROR in p2\\package-info.java (at line 1)\n" + 
+		"	package p2;\n" + 
+		"	        ^^\n" + 
+		"A default nullness annotation has not been specified for the package p2\n" + 
+		"----------\n" + 
+		"----------\n" + 
+		"1. WARNING in p3\\Z.java (at line 4)\n" + 
+		"	@NonNullByDefault void bar() {}\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Nullness default is redundant with a default specified for the enclosing package p3\n" + 
 		"----------\n");
 }
 
@@ -3090,8 +3094,6 @@ public void test_nonnull_var_in_constrol_structure_2() {
 // a nonnull variable is dereferenced in a finally block inside a loop
 public void test_nonnull_var_in_constrol_structure_3() {
 	Map customOptions = getCompilerOptions();
-//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
-	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
 	customOptions.put(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION, JavaCore.IGNORE);
 	runNegativeTestWithLibs(
 		new String[] {
@@ -3271,8 +3273,6 @@ public void test_message_send_in_control_structure_03() {
 }
 public void test_assignment_expression_1() {
 	Map customOptions = getCompilerOptions();
-//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
-	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
 	customOptions.put(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK, JavaCore.ERROR);
 	runConformTestWithLibs(
 		new String[] {
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
index 82e5422..0b7944a 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
@@ -30,6 +30,7 @@ import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaModelMarker;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.IProblem;
 import org.eclipse.jdt.core.dom.AST;
 import org.eclipse.jdt.core.dom.ASTParser;
@@ -53,7 +54,7 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 	}
 
 	static {
-//		TESTS_NAMES = new String[] { "testMissingAnnotation5" };
+//		TESTS_NAMES = new String[] { "testConvertedSourceType1" };
 	}
 
 	public void setUp() throws Exception {
@@ -67,18 +68,17 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 		return FileLocator.toFileURL(libEntry).getPath();
 	}
 
-	// DISABLED due to dysfunctional global default after Bug 366063 - Compiler should not add synthetic @NonNull annotations
-	public void _testConvertedSourceType1() throws CoreException, InterruptedException {
+	public void testConvertedSourceType1() throws CoreException, InterruptedException {
     	try {
 			// Resources creation
 			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
 			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
-			p.setOption(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
 
 			this.createFolder("/P/p1");
 			String c1SourceString =
 				"package p1;\n" +
 				"import org.eclipse.jdt.annotation.*;\n" +
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
 				"public class C1 {\n" +
 				"	 public String foo(@Nullable Object arg) {\n" + // this is consumed via SourceTypeConverter
 				"		return arg == null ? \"\" : arg.toString();\n" +
@@ -91,6 +91,7 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 			this.createFolder("/P/p2");
 			String c2SourceString =
 				"package p2;\n" +
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
 				"public class C2 {\n" +
 				"	 String bar(p1.C1 c, C2 c2) {;\n" +
 				"        return c.foo(null);\n" + // don't complain despite default nonnull, foo has explicit @Nullable
@@ -109,7 +110,7 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 			getCompilationUnit("/P/p2/C2.java").getWorkingCopy(this.wcOwner, null);
 
 			assertProblems("Unexpected problems", "----------\n" +
-					"1. WARNING in /P/p2/C2.java (at line 7)\n" +
+					"1. WARNING in /P/p2/C2.java (at line 8)\n" +
 					"	return arg == null ? null : arg.toString();\n" +
 					"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
 					"Potential type mismatch: required \'@NonNull String\' but nullness of the provided value is unknown\n" +
@@ -119,21 +120,20 @@ public class NullAnnotationModelTests extends ReconcilerTests {
     	}
     }
 
-	// DISABLED due to dysfunctional global default after Bug 366063 - Compiler should not add synthetic @NonNull annotations
-	public void _testBinaryType1() throws CoreException, InterruptedException, IOException {
+	public void testBinaryType1() throws CoreException, InterruptedException, IOException {
     	try {
 			// Resources creation
 			IJavaProject p = createJavaProject("P", new String[] {""},
 											   new String[] {"JCL15_LIB", this.ANNOTATION_LIB, testJarPath("example.jar")},
 											   "bin", "1.5");
 			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
-			p.setOption(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
 
 			// example.jar contains p1/C1.java just like testConvertedSourceType1()
 
 			this.createFolder("/P/p2");
 			String c2SourceString =
 				"package p2;\n" +
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
 				"public class C2 {\n" +
 				"	 String bar(p1.C1 c) {;\n" +
 				"        return c.foo(null);\n" + // don't complain despite default nonnull, foo has explicit @Nullable
@@ -152,7 +152,7 @@ public class NullAnnotationModelTests extends ReconcilerTests {
 			getCompilationUnit("/P/p2/C2.java").getWorkingCopy(this.wcOwner, null);
 
 			assertProblems("Unexpected problems", "----------\n" +
-					"1. WARNING in /P/p2/C2.java (at line 7)\n" +
+					"1. WARNING in /P/p2/C2.java (at line 8)\n" +
 					"	return arg == null ? null : arg.toString();\n" +
 					"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
 					"Potential type mismatch: required \'@NonNull String\' but nullness of the provided value is unknown\n" +
@@ -486,4 +486,28 @@ public class NullAnnotationModelTests extends ReconcilerTests {
     		deleteProject("P");
     	}
 	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
+	// no problem should be created for a compilation unit in a package missing package-info when the warning is enabled
+	public void testBug372012() throws JavaModelException, IOException, CoreException, InterruptedException {
+		try {
+			// Resources creation
+			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
+			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+			p.setOption(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "in.valid");
+			p.setOption(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION, JavaCore.ERROR);
+
+			this.createFolder("/P/p1");
+			String c1SourceString =
+				"package p1;\n" +
+				"public class C1 {\n" +
+				"	 public String foo(Object arg) {\n" +
+				"		return arg == null ? \"\" : arg.toString();\n" +
+				"	 }\n" +
+				"}\n";
+
+			assertNoProblem(c1SourceString.toCharArray(), getCompilationUnit("/P/p1/C1.java"));
+    	} finally {
+    		deleteProject("P");
+    	}
+	}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 97a9654..f51a2bc 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -2412,8 +2412,8 @@ public void configure(String[] argv) {
 					mode = INSIDE_WARNINGS_PROPERTIES;
 					continue;
 				}
-				if (currentArg.equals("-nonNullByDefault")) { //$NON-NLS-1$
-					this.options.put(CompilerOptions.OPTION_NonNullIsDefault, CompilerOptions.ENABLED);
+				if (currentArg.equals("-missingNullDefault")) { //$NON-NLS-1$
+					this.options.put(CompilerOptions.OPTION_ReportMissingNonNullByDefaultAnnotation, CompilerOptions.WARNING);
 					continue;
 				}
 				break;
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index b1cbf89..812a7e8 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -20,7 +20,7 @@
 #Format: compiler.name = word1 word2 word3
 compiler.name = Eclipse Compiler for Java(TM)
 #Format: compiler.version = 0.XXX[, other words (don't forget the comma if adding other words)]
-compiler.version = 0.C37, 3.8.0 M6
+compiler.version = 0.C38, 3.8.0 M6
 compiler.copyright = Copyright IBM Corp 2000, 2011. All rights reserved.
 
 ### progress
@@ -255,8 +255,7 @@ misc.usage = {1} {2}\n\
 \    -enableJavadoc     consider references in javadoc\n\
 \    -Xemacs            used to enable emacs-style output in the console.\n\
 \                       It does not affect the xml log output\n\
-\    -nonNullByDefault  for annotation based null analysis assume nonnull\n\
-\                       as the global default\n\
+\    -missingNullDefault  report missing default nullness annotation\n\
 \ \n\
 \    -? -help           print this help message\n\
 \    -v -version        print compiler version\n\
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index ece8c17..1965b5c 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -42,11 +42,24 @@
 	</td>
   </tr>
 </table>
+<a name="v_C38"></a>
+<hr><h1>
+Eclipse Platform Build Notes<br>
+Java development tools core</h1>
+Eclipse SDK 3.8.0 - %date% - 3.8.0 M6
+<br>Project org.eclipse.jdt.core v_C38
+(<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_C38">cvs</a>).
+<h2>What's new in this drop</h2>
+
+<h3>Problem Reports Fixed</h3>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012">372012</a>
+[compiler][null] Warn when defaults not specified
+
 <a name="v_C37"></a>
 <hr><h1>
 Eclipse Platform Build Notes<br>
 Java development tools core</h1>
-Eclipse SDK 3.8.0 - March 6, 2012 - 3.8.0 M6
+Eclipse SDK 3.8.0 - March 6, 2012
 <br>
 <h2>What's new in this drop</h2>
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 937a190..b88354d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1444,7 +1444,8 @@ void setSourceStart(int sourceStart);
 	int RequiredNonNullButProvidedPotentialNull = TypeRelated + 911;
 	/** @since 3.8 */
 	int RequiredNonNullButProvidedUnknown = TypeRelated + 912;
-	// removed during 3.8 M6: ImportRelated + 913 
+	/** @since 3.8 */
+	int MissingNonNullByDefaultAnnotationOnPackage = Internal + 913; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
 	/** @since 3.8 */
 	int IllegalReturnNullityRedefinition = MethodRelated + 914;
 	/** @since 3.8 */
@@ -1475,6 +1476,8 @@ void setSourceStart(int sourceStart);
 	int RedundantNullDefaultAnnotationMethod = Internal + 928;
 	/** @since 3.8 */
 	int ContradictoryNullAnnotations = Internal + 929;
+	/** @since 3.8 */
+	int MissingNonNullByDefaultAnnotationOnType = Internal + 930; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
 
 	/**
 	 * External problems -- These are problems defined by other plugins
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index c76441b..5eb0dc7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -29,7 +29,6 @@ import org.eclipse.jdt.internal.compiler.Compiler;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
-import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
@@ -158,7 +157,7 @@ public class CompilerOptions {
 	static final char[][] DEFAULT_NULLABLE_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.Nullable".toCharArray()); //$NON-NLS-1$
 	static final char[][] DEFAULT_NONNULL_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNull".toCharArray()); //$NON-NLS-1$
 	static final char[][] DEFAULT_NONNULLBYDEFAULT_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNullByDefault".toCharArray()); //$NON-NLS-1$
-	public static final String OPTION_NonNullIsDefault = "org.eclipse.jdt.core.compiler.annotation.nonnullisdefault";  //$NON-NLS-1$
+	public static final String OPTION_ReportMissingNonNullByDefaultAnnotation = "org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation";  //$NON-NLS-1$
 	/**
 	 * Possible values for configurable options
 	 */
@@ -269,6 +268,7 @@ public class CompilerOptions {
 	public static final int PotentialNullSpecViolation = IrritantSet.GROUP2 | ASTNode.Bit12;
 	public static final int NullSpecInsufficientInfo = IrritantSet.GROUP2 | ASTNode.Bit13;
 	public static final int RedundantNullAnnotation = IrritantSet.GROUP2 | ASTNode.Bit14;
+	public static final int MissingNonNullByDefaultAnnotation = IrritantSet.GROUP2 | ASTNode.Bit15;
 
 	// Severity level for handlers
 	/** 
@@ -598,6 +598,8 @@ public class CompilerOptions {
 				return OPTION_ReportMethodCanBeStatic;
 			case MethodCanBePotentiallyStatic :
 				return OPTION_ReportMethodCanBePotentiallyStatic;
+			case MissingNonNullByDefaultAnnotation :
+				return OPTION_ReportMissingNonNullByDefaultAnnotation;
 			case RedundantSpecificationOfTypeArguments :
 				return OPTION_ReportRedundantSpecificationOfTypeArguments;
 			case UnclosedCloseable :
@@ -784,7 +786,7 @@ public class CompilerOptions {
 			OPTION_NonNullAnnotationName,
 			OPTION_NullableAnnotationName,
 			OPTION_NonNullByDefaultAnnotationName,
-			OPTION_NonNullIsDefault,
+			OPTION_ReportMissingNonNullByDefaultAnnotation,
 			OPTION_ReportNullSpecViolation,
 			OPTION_ReportPotentialNullSpecViolation,
 			OPTION_ReportNullSpecInsufficientInfo,
@@ -855,6 +857,7 @@ public class CompilerOptions {
 			case PotentialNullSpecViolation :
 			case NullSpecInsufficientInfo :
 			case RedundantNullAnnotation :
+			case MissingNonNullByDefaultAnnotation:
 				return "null"; //$NON-NLS-1$
 			case FallthroughCase :
 				return "fallthrough"; //$NON-NLS-1$
@@ -1080,10 +1083,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_NullableAnnotationName, String.valueOf(CharOperation.concatWith(this.nullableAnnotationName, '.')));
 		optionsMap.put(OPTION_NonNullAnnotationName, String.valueOf(CharOperation.concatWith(this.nonNullAnnotationName, '.')));
 		optionsMap.put(OPTION_NonNullByDefaultAnnotationName, String.valueOf(CharOperation.concatWith(this.nonNullByDefaultAnnotationName, '.')));
-		if (this.intendedDefaultNonNullness == TagBits.AnnotationNonNull)
-			optionsMap.put(OPTION_NonNullIsDefault, CompilerOptions.ENABLED);
-		else
-			optionsMap.put(OPTION_NonNullIsDefault, CompilerOptions.DISABLED);
+		optionsMap.put(OPTION_ReportMissingNonNullByDefaultAnnotation, getSeverityString(MissingNonNullByDefaultAnnotation));
 		return optionsMap;
 	}
 
@@ -1560,12 +1560,7 @@ public class CompilerOptions {
 			if ((optionValue = optionsMap.get(OPTION_NonNullByDefaultAnnotationName)) != null) {
 				this.nonNullByDefaultAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
 			}
-			if ((optionValue = optionsMap.get(OPTION_NonNullIsDefault)) != null) {
-				if (CompilerOptions.ENABLED.equals(optionValue))
-					this.intendedDefaultNonNullness = TagBits.AnnotationNonNull;
-				else if (CompilerOptions.DISABLED.equals(optionValue))
-					this.intendedDefaultNonNullness = 0;
-			}
+			if ((optionValue = optionsMap.get(OPTION_ReportMissingNonNullByDefaultAnnotation)) != null) updateSeverity(MissingNonNullByDefaultAnnotation, optionValue);
 		}
 
 		// Javadoc options
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 53a2b1b..7426d67 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -1633,6 +1633,26 @@ private void createArgumentBindings(MethodBinding method) {
 private void evaluateNullAnnotations(long annotationTagBits) {
 	if (this.nullnessDefaultInitialized > 0 || !this.scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled)
 		return;
+	boolean isPackageInfo = CharOperation.equals(this.sourceName, TypeConstants.PACKAGE_INFO_NAME);
+	PackageBinding pkg = getPackage();
+	boolean isInDefaultPkg = (pkg.compoundName == CharOperation.NO_CHAR_CHAR);
+	if (!isPackageInfo) {
+		boolean isInNullnessAnnotationPackage = 
+				pkg == this.scope.environment().nonnullAnnotationPackage
+				|| pkg == this.scope.environment().nullableAnnotationPackage
+				|| pkg == this.scope.environment().nonnullByDefaultAnnotationPackage;
+		if (pkg.defaultNullness == NO_NULL_DEFAULT && !isInDefaultPkg && !isInNullnessAnnotationPackage && !(this instanceof NestedTypeBinding)) {
+			ReferenceBinding packageInfo = pkg.getType(TypeConstants.PACKAGE_INFO_NAME);
+			if (packageInfo == null) {
+				// no pkgInfo - complain
+				this.scope.problemReporter().missingNonNullByDefaultAnnotation(this.scope.referenceContext);
+				pkg.defaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
+			} else {
+				// if pkgInfo has no default annot. - complain
+				packageInfo.getAnnotationTagBits();
+			}
+		}
+	}
 	this.nullnessDefaultInitialized = 1;
 	// transfer nullness info from tagBits to this.nullnessDefaultAnnotation
 	int newDefaultNullness = NO_NULL_DEFAULT;
@@ -1641,14 +1661,18 @@ private void evaluateNullAnnotations(long annotationTagBits) {
 	else if ((annotationTagBits & TagBits.AnnotationNonNullByDefault) != 0)
 		newDefaultNullness = NONNULL_BY_DEFAULT;
 	if (newDefaultNullness != NO_NULL_DEFAULT) {
-		if (CharOperation.equals(this.sourceName, TypeConstants.PACKAGE_INFO_NAME)) {
-			getPackage().defaultNullness = newDefaultNullness;
+		if (isPackageInfo) {
+			pkg.defaultNullness = newDefaultNullness;
 		} else {
 			this.defaultNullness = newDefaultNullness;
 			TypeDeclaration typeDecl = this.scope.referenceContext;
 			long nullDefaultBits = annotationTagBits & (TagBits.AnnotationNullUnspecifiedByDefault|TagBits.AnnotationNonNullByDefault);
 			checkRedundantNullnessDefaultRecurse(typeDecl, typeDecl.annotations, nullDefaultBits);
 		}
+	} else if (isPackageInfo || (isInDefaultPkg && !(this instanceof NestedTypeBinding))) {
+		this.scope.problemReporter().missingNonNullByDefaultAnnotation(this.scope.referenceContext);
+		if (!isInDefaultPkg)
+			pkg.defaultNullness = NULL_UNSPECIFIED_BY_DEFAULT;
 	}
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 379f232..3f4647f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -469,6 +469,10 @@ public static int getIrritant(int problemID) {
 				
 		case IProblem.RedundantSpecificationOfTypeArguments:
 			return CompilerOptions.RedundantSpecificationOfTypeArguments;
+			
+		case IProblem.MissingNonNullByDefaultAnnotationOnPackage:
+		case IProblem.MissingNonNullByDefaultAnnotationOnType:
+			return CompilerOptions.MissingNonNullByDefaultAnnotation;
 	}
 	return 0;
 }
@@ -574,6 +578,7 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.NullSpecViolation :
 			case CompilerOptions.PotentialNullSpecViolation :
 			case CompilerOptions.NullSpecInsufficientInfo :
+			case CompilerOptions.MissingNonNullByDefaultAnnotation:
 				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
 			case CompilerOptions.RedundantNullAnnotation :
 				return CategorizedProblem.CAT_UNNECESSARY_CODE;
@@ -8180,9 +8185,7 @@ public void parameterLackingNullAnnotation(Argument argument, ReferenceBinding d
 		argument.type.sourceStart,
 		argument.type.sourceEnd);
 }
-public void illegalReturnRedefinition(AbstractMethodDeclaration abstractMethodDecl,
-									  MethodBinding inheritedMethod, char[][] nonNullAnnotationName)
-{
+public void illegalReturnRedefinition(AbstractMethodDeclaration abstractMethodDecl, MethodBinding inheritedMethod, char[][] nonNullAnnotationName) {
 	MethodDeclaration methodDecl = (MethodDeclaration) abstractMethodDecl;
 	StringBuffer methodSignature = new StringBuffer();
 	methodSignature
@@ -8328,4 +8331,34 @@ private Annotation findAnnotation(Annotation[] annotations, int typeId) {
 	}
 	return null;
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=372012
+public void missingNonNullByDefaultAnnotation(TypeDeclaration type) {
+	int severity;
+	CompilationUnitDeclaration compUnitDecl = type.getCompilationUnitDeclaration();
+	String[] arguments;
+	if (compUnitDecl.currentPackage == null) {
+		severity = computeSeverity(IProblem.MissingNonNullByDefaultAnnotationOnType);
+		if (severity == ProblemSeverities.Ignore) return;
+		// Default package
+		TypeBinding binding = type.binding;
+		this.handle(
+				IProblem.MissingNonNullByDefaultAnnotationOnType,
+				new String[] {new String(binding.readableName()), },
+				new String[] {new String(binding.shortReadableName()),},
+				severity,
+				type.sourceStart,
+				type.sourceEnd);
+	} else {
+		severity = computeSeverity(IProblem.MissingNonNullByDefaultAnnotationOnPackage);
+		if (severity == ProblemSeverities.Ignore) return;
+		arguments = new String[] {CharOperation.toString(compUnitDecl.currentPackage.tokens)};
+		this.handle(
+			IProblem.MissingNonNullByDefaultAnnotationOnPackage,
+			arguments,
+			arguments,
+			severity,
+			compUnitDecl.currentPackage.sourceStart,
+			compUnitDecl.currentPackage.sourceEnd);
+	}
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index ab8a751..8a5d4ef 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -663,7 +663,7 @@
 910 = Type mismatch: required ''@{0} {1}'' but the provided value is null
 911 = Type mismatch: required ''@{0} {1}'' but the provided value can be null
 912 = Potential type mismatch: required ''@{0} {1}'' but nullness of the provided value is unknown
-#913 removed
+913 = A default nullness annotation has not been specified for the package {0}
 914 = The return type is incompatible with the @{1} return from {0}
 915 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as @{2}
 916 = Illegal redefinition of parameter {0}, inherited method from {1} does not constrain this parameter
@@ -679,6 +679,7 @@
 927 = Nullness default is redundant with a default specified for the enclosing type {0}
 928 = Nullness default is redundant with a default specified for the enclosing method {0}
 929 = Contradictory null specification; only one of @{0} and @{1} can be specified at any location
+930 = A default nullness annotation has not been specified for the type {0}
 
 ### ELABORATIONS
 ## Access restrictions
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index f8d795d..9de477f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1494,9 +1494,7 @@ public final class JavaCore extends Plugin {
 	 *    within the annotated element will be treated as if they were specified with the non-null annotation
 	 *    (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</p>
 	 * <p>If the annotation is applied with the constant <code>false</code> as its argument
-	 *    all corresponding defaults at outer scopes will be canceled for the annotated element.
-	 *    This includes defaults specified using this annotation type or a default defined using
-	 *    the compiler option {@link #COMPILER_NONNULL_IS_DEFAULT}.</p>
+	 *    all corresponding defaults at outer scopes will be canceled for the annotated element.</p>
 	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnullbydefault"</code></dd>
@@ -1509,19 +1507,23 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME = PLUGIN_ID + ".compiler.annotation.nonnullbydefault"; //$NON-NLS-1$
 	/**
-	 * Compiler option ID: Globally specify non-null as the assumed default for unannotated types.
-	 * <p>When enabled, this option globally achieves the same effect 
-	 *    as specifying {@link #COMPILER_NONNULL_ANNOTATION_NAME} does for individual elements.</p>
+	 * Compiler option ID: Reporting missing default nullness annotation.
+	 * <p>When enabled, the compiler will issue an error or a warning in the following cases:</p>
+	 * <ul>
+	 * <li> When a package does not contain a default nullness annotation, as a result of missing package-info.java 
+	 * or missing default nullness annotation in package-info.java.</li>
+	 * <li> When a type inside a default package does not contain a default nullness annotation.</li>
+	 * </ul>
 	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
-	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnullisdefault"</code></dd>
-	 * <dt>Possible values:</dt><dd><code>{ "disabled", "enabled" }</code>.</dd>
-	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code>.</dd>
+	 * <dt>Default:</dt><dd><code>"ignore"</code></dd>
 	 * </dl>
 	 * @since 3.8
 	 * @category CompilerOptionID
 	 */
-	public static final String COMPILER_NONNULL_IS_DEFAULT = PLUGIN_ID + ".compiler.annotation.nonnullisdefault"; //$NON-NLS-1$
+	public static final String COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION = PLUGIN_ID + ".compiler.annotation.missingNonNullByDefaultAnnotation"; //$NON-NLS-1$
 	/**
 	 * Compiler option ID: Reporting Violations of Null Specifications.
 	 * <p>Depending on this option, the compiler will issue either an error or a warning
@@ -1623,8 +1625,7 @@ public final class JavaCore extends Plugin {
 	 * <p>When enabled, the compiler will issue an error or a warning when a non-null annotation
 	 *    (see {@link #COMPILER_NONNULL_ANNOTATION_NAME})
 	 *    is applied although the same effect is already achieved by a default applicable at the
-	 *    current location. Such a default may be set by enabling the option
-	 *    {@link #COMPILER_NONNULL_IS_DEFAULT} or by using the annotation specified by the option
+	 *    current location. Such a default may be set by using the annotation specified by the option
 	 *    {@link #COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME}.
 	 * </p>
 	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
index 531b2b5..83014eb 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/AbstractImageBuilder.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -25,6 +25,7 @@ import org.eclipse.jdt.internal.compiler.problem.*;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.JavaModelManager;
+import org.eclipse.jdt.internal.core.PackageFragment;
 import org.eclipse.jdt.internal.core.util.Messages;
 import org.eclipse.jdt.internal.core.util.Util;
 
@@ -673,7 +674,7 @@ protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] prob
 
 	IResource resource = sourceFile.resource;
 	HashSet managedMarkerTypes = JavaModelManager.getJavaModelManager().compilationParticipants.managedMarkerTypes();
-	for (int i = 0, l = problems.length; i < l; i++) {
+	problems: for (int i = 0, l = problems.length; i < l; i++) {
 		CategorizedProblem problem = problems[i];
 		int id = problem.getID();
 
@@ -706,6 +707,38 @@ protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] prob
 		boolean managedProblem = false;
 		if (IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER.equals(markerType)
 				|| (managedProblem = managedMarkerTypes.contains(markerType))) {
+			if (id == IProblem.MissingNonNullByDefaultAnnotationOnPackage && !(CharOperation.equals(sourceFile.getMainTypeName(), TypeConstants.PACKAGE_INFO_NAME))) {
+				// for this kind of problem, marker needs to be created on the package instead of on the source file
+				// see bug 372012
+				char[] fileName = sourceFile.getFileName();
+				int pkgEnd = CharOperation.lastIndexOf('/', fileName);
+				if (pkgEnd == -1)
+					pkgEnd = CharOperation.lastIndexOf(File.separatorChar, fileName);
+				PackageFragment pkg = null;
+				if (pkgEnd != -1)
+					pkg = (PackageFragment) Util.getPackageFragment(sourceFile.getFileName(), pkgEnd, -1 /*no jar separator for java files*/);
+				
+				if (pkg != null) {
+					try {
+						IMarker[] existingMarkers = pkg.resource().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_ZERO);
+						int len = existingMarkers.length;
+						for (int j=0; j < len; j++) {
+							if (((Integer)existingMarkers[j].getAttribute(IJavaModelMarker.ID)).intValue() == IProblem.MissingNonNullByDefaultAnnotationOnPackage) {
+								continue problems; // marker already present
+							}
+						}
+					} catch (CoreException e) {
+						// marker retrieval failed, cannot do much
+						if (JavaModelManager.VERBOSE) {
+							e.printStackTrace();
+						}
+					}
+					IResource tempRes = pkg.resource();
+					if (tempRes != null) {
+						resource = tempRes;
+					}
+				}
+			}
 			IMarker marker = resource.createMarker(markerType);
 
 			String[] attributeNames = JAVA_PROBLEM_MARKER_ATTRIBUTE_NAMES;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java
index 136d8a5..1ee5f87 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java
@@ -797,6 +797,10 @@ protected void resetCollections() {
 }
 
 protected void updateProblemsFor(SourceFile sourceFile, CompilationResult result) throws CoreException {
+	if (CharOperation.equals(sourceFile.getMainTypeName(), TypeConstants.PACKAGE_INFO_NAME)) {
+		IResource pkgResource = sourceFile.resource.getParent();
+		pkgResource.deleteMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
+	}
 	IMarker[] markers = JavaBuilder.getProblemsFor(sourceFile.resource);
 	CategorizedProblem[] problems = result.getProblems();
 	if (problems == null && markers.length == 0) return;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
index 2023954..e45e873 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -940,7 +940,7 @@ public class Util {
 		return lineSeparator;
 	}
 
-	private static IPackageFragment getPackageFragment(char[] fileName, int pkgEnd, int jarSeparator) {
+	public static IPackageFragment getPackageFragment(char[] fileName, int pkgEnd, int jarSeparator) {
 		if (jarSeparator != -1) {
 			String jarMemento = new String(fileName, 0, jarSeparator);
 			PackageFragmentRoot root = (PackageFragmentRoot) JavaCore.create(jarMemento);
