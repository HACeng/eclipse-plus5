commit d08e87c35b21123010227cf2729df51d820e4d50
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sat Jul 26 18:07:33 2014 +0200

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - initial draft, works for selected scenarii of full build

3	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
5	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
139	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
6	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.classpath
17	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.project
4	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/annots/java/util/Collection.eea
13	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/src/test1/Test1.java
4	3	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
21	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
179	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
7	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
32	45	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
20	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java
114	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
24	16	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
13	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
10	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathEntry.java
162	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
39	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
8	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
38	10	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
9	7	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
5	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
4	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
5	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
index 0fdea20..d1eb8aa 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
@@ -2840,6 +2842,7 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 							new Path(newJclLibString),
 							new Path(newJclSrcString),
 							entry.getSourceAttachmentRootPath(),
+							entry.getExternalAnnotationPath(),
 							entry.getAccessRules(),
 							new IClasspathAttribute[0],
 							entry.isExported());
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
index 47c14fc..5e55e9e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
@@ -9,7 +9,10 @@
  *     IBM Corporation - initial API and implementation
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425,
  *     									   Fup of 357425: ensure all reported regressions are witnessed by tests, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=361922
- *     Thirumala Reddy Mutchukota <thirumala@google.com> - Contribution to bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=411423
+ *     Thirumala Reddy Mutchukota <thirumala@google.com> - Contribution for
+ *     							Bug 411423 - JavaProject.resolveClasspath is spending more than 90% time on ExternalFoldersManager.isExternalFolderPath
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
@@ -5843,6 +5846,7 @@ public void testBug55992a() throws CoreException {
 			ClasspathEntry.EXCLUDE_NONE,
 			new Path("TEST_SRC"),
 			null,
+			null,
 			null, // specific output folder
 			false,
 			(IAccessRule[]) null,
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
new file mode 100644
index 0000000..b72b78a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
@@ -0,0 +1,139 @@
+/*******************************************************************************
+ * Copyright (c) 2014 GK Software AG, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.model;
+
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URL;
+import java.util.Map;
+
+import org.eclipse.core.resources.IMarker;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IncrementalProjectBuilder;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.FileLocator;
+import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.jdt.core.IClasspathAttribute;
+import org.eclipse.jdt.core.IClasspathEntry;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaModelMarker;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.osgi.framework.Bundle;
+
+import junit.framework.Test;
+
+public class ExternalAnnotations18Test extends ModifyingResourceTests {
+
+	private IJavaProject project;
+	private IPackageFragmentRoot root;
+	private String ANNOTATION_LIB;
+
+	public ExternalAnnotations18Test(String name) {
+		super(name);
+	}
+	
+// Use this static initializer to specify subset for tests
+// All specified tests which do not belong to the class are skipped...
+	static {
+		// Names of tests to run: can be "testBugXXXX" or "BugXXXX")
+//		TESTS_PREFIX = "testClasspathDuplicateExtraAttribute";
+//		TESTS_NAMES = new String[] {"testClasspathValidation42"};
+//		TESTS_NUMBERS = new int[] { 23, 28, 38 };
+//		TESTS_RANGE = new int[] { 21, 38 };
+	}
+	public static Test suite() {
+		return buildModelTestSuite(ExternalAnnotations18Test.class, BYTECODE_DECLARATION_ORDER);
+	}
+
+	/**
+	 * @deprecated indirectly uses deprecated class PackageAdmin
+	 */
+	public void setUpSuite() throws Exception {
+		super.setUpSuite();
+		
+		Bundle[] bundles = org.eclipse.jdt.core.tests.Activator.getPackageAdmin().getBundles("org.eclipse.jdt.annotation", "[2.0.0,3.0.0)");
+		File bundleFile = FileLocator.getBundleFile(bundles[0]);
+		this.ANNOTATION_LIB = bundleFile.isDirectory() ? bundleFile.getPath()+"/bin" : bundleFile.getPath();
+
+		this.project = setUpJavaProject("ExternalAnnotations18", "1.8"); //$NON-NLS-1$
+		addLibraryEntry(this.project, this.ANNOTATION_LIB, false);
+		Map options = this.project.getOptions(true);
+		options.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+		this.project.setOptions(options);
+
+		IPackageFragmentRoot[] roots = this.project.getAllPackageFragmentRoots();
+		int count = 0;
+		for (int i = 0, max = roots.length; i < max; i++) {
+			final IPackageFragmentRoot packageFragmentRoot = roots[i];
+			switch(packageFragmentRoot.getKind()) {
+				case IPackageFragmentRoot.K_SOURCE :
+					count++;
+					if (this.root == null) {
+						this.root = packageFragmentRoot;
+					}
+			}
+		}
+		assertEquals("Wrong value", 1, count); //$NON-NLS-1$
+		assertNotNull("Should not be null", this.root); //$NON-NLS-1$
+
+	}
+	
+	// TODO: using this copy from AttachedJavadocTests test also programmatically setting the external annotation location:
+	private void setExternalAnnotationsAttribute(String folderName) throws JavaModelException {
+		IClasspathEntry[] entries = this.project.getRawClasspath();
+		IResource resource = this.project.getProject().findMember("/"+folderName+"/"); //$NON-NLS-1$
+		assertNotNull("annotations folder cannot be null", resource); //$NON-NLS-1$
+		URI locationURI = resource.getLocationURI();
+		assertNotNull("annotations folder cannot be null", locationURI); //$NON-NLS-1$
+		URL annotationsUrl = null;
+		try {
+			annotationsUrl = locationURI.toURL();
+		} catch (MalformedURLException e) {
+			assertTrue("Should not happen", false); //$NON-NLS-1$
+		} catch(IllegalArgumentException e) {
+			assertTrue("Should not happen", false); //$NON-NLS-1$
+		}
+		IClasspathAttribute attribute = JavaCore.newClasspathAttribute(IClasspathAttribute.JAVADOC_LOCATION_ATTRIBUTE_NAME, annotationsUrl.toExternalForm());
+		for (int i = 0, max = entries.length; i < max; i++) {
+			final IClasspathEntry entry = entries[i];
+			if (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY
+					&& entry.getContentKind() == IPackageFragmentRoot.K_BINARY
+					&& "/AttachedJavadocProject/lib/test6.jar".equals(entry.getPath().toString())) { //$NON-NLS-1$
+				entries[i] = JavaCore.newLibraryEntry(entry.getPath(), entry.getSourceAttachmentPath(), entry.getSourceAttachmentRootPath(), entry.getAccessRules(), new IClasspathAttribute[] { attribute}, entry.isExported());
+			}
+		}
+		this.project.setRawClasspath(entries, null);
+	}
+	
+	/** Perform full build. */
+	public void test1() throws CoreException, InterruptedException {
+		this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+		IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
+		assertEquals("Number of markers", 0, markers.length);
+	}
+	
+	/** Reconcile an individual CU. */ // FIXME: needs more capability in SearchableNameEnvironment
+	public void _test2() throws CoreException, InterruptedException {
+		IPackageFragment fragment = this.root.getPackageFragment("test1");
+		ICompilationUnit unit = fragment.getCompilationUnit("Test1.java").getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertEquals("Number of problems", 0, problems.length);
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.classpath
new file mode 100644
index 0000000..8c0b66a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.classpath
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="var" path="JCL18_LIB" annotationpath="annots"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.project
new file mode 100644
index 0000000..1271329
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ExternalAnnotations18</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/annots/java/util/Collection.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/annots/java/util/Collection.eea
new file mode 100644
index 0000000..8415ab5
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/annots/java/util/Collection.eea
@@ -0,0 +1,4 @@
+class <T:>Collection
+
+get(I)TT;=(I)T0T;
+iterator()Ljava.util.Iterator<TT;>;=iterator()L1java.util.Iterator<TT;>;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/src/test1/Test1.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/src/test1/Test1.java
new file mode 100644
index 0000000..558ab97
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/src/test1/Test1.java
@@ -0,0 +1,13 @@
+package test1;
+
+import java.util.Collection;
+import org.eclipse.jdt.annotation.*;
+
+@NonNullByDefault
+public class Test1 {
+	void test(Collection<String> map, int key) {
+		String v = map.get(key);
+		if (v == null)
+			throw new RuntimeException(); // should not be reported as dead code, although map is a Collection<@NonNull String>
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
index 6a02d3b..02b7d13 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2013 IBM Corporation and others.
+ * Copyright (c) 2008, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								Bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.codeassist;
 
@@ -38,7 +39,7 @@ import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
@@ -338,7 +339,7 @@ public class InternalExtendedCompletionContext {
 
 			SignatureWrapper wrapper = new SignatureWrapper(replacePackagesDot(typeSignature.toCharArray()));
 			// FIXME(stephan): do we interpret type annotations here?
-			assignableTypeBinding = this.lookupEnvironment.getTypeFromTypeSignature(wrapper, typeVariables, this.assistScope.enclosingClassScope().referenceContext.binding, null, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+			assignableTypeBinding = this.lookupEnvironment.getTypeFromTypeSignature(wrapper, typeVariables, this.assistScope.enclosingClassScope().referenceContext.binding, null, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 			assignableTypeBinding = BinaryTypeBinding.resolveType(assignableTypeBinding, this.lookupEnvironment, true);
 		} catch (AbortCompilation e) {
 			assignableTypeBinding = null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index a643a36..c728752 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,9 +7,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 365992 - [builder] [null] Change of nullness for a parameter doesn't trigger a build for the files that call the method
+ *     Stephan Herrmann - Contribution for
+ *								Bug 365992 - [builder] [null] Change of nullness for a parameter doesn't trigger a build for the files that call the method
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
- *         bug 407191 - [1.8] Binary access support for type annotations
+ *         						bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
@@ -22,7 +24,9 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants;
 import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
@@ -56,6 +60,7 @@ public class ClassFileReader extends ClassFileStruct implements IBinaryType {
 	private char[][][] missingTypeNames;
 	private int enclosingNameAndTypeIndex;
 	private char[] enclosingMethod;
+	private IExternalAnnotationProvider annotationProvider;
 
 private static String printTypeModifiers(int modifiers) {
 	java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream();
@@ -396,6 +401,19 @@ public ClassFileReader(byte[] classFileBytes, char[] fileName, boolean fullyInit
 	}
 }
 
+/** Create and remember a provider for external annotations using the given text file. */
+public void setAnnotationProvider(File annotFile) throws IOException {
+	this.annotationProvider = new ExternalAnnotationProvider(annotFile);
+}
+
+/** If a provider for external annotations has been registered try to retrieve an annotation walker for the given method. */
+public ITypeAnnotationWalker getAnnotationsForMethod(IBinaryMethod method, char[] methodSignature, LookupEnvironment environment) {
+	if (this.annotationProvider != null) {
+		return this.annotationProvider.forMethod(method.isConstructor() ? TypeConstants.INIT : method.getSelector(), methodSignature, environment);
+	}
+	return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+}
+
 /**
  * Answer the receiver's access flags.  The value of the access_flags
  *	item is a mask of modifiers used with class and interface declarations.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
new file mode 100644
index 0000000..f430256
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -0,0 +1,179 @@
+/*******************************************************************************
+ * Copyright (c) 2014 GK Software AG.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.classfmt;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
+import org.eclipse.jdt.internal.compiler.env.IExternalAnnotationProvider;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+
+public class ExternalAnnotationProvider implements IExternalAnnotationProvider {
+
+	private File annotationSource;
+	private Map<String,String> methodAnnotationSources;
+	
+	public ExternalAnnotationProvider(File annotationSource) throws IOException {
+		this.annotationSource = annotationSource;
+		this.methodAnnotationSources = new HashMap<String, String>();
+		initialize();
+	}
+	
+	private void initialize() throws IOException {
+		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(this.annotationSource)));
+		try {
+			String line = reader.readLine();
+			if (!line.startsWith("class ")) // TODO properly evaluate class header //$NON-NLS-1$
+				throw new IOException("missing class header in annotation file"); //$NON-NLS-1$
+			while ((line = reader.readLine()) != null) {
+				if (line.isEmpty()) continue;
+				int pos=line.indexOf('=');
+				if (pos == -1) throw new IOException("Illegal format for annotation file, missing '='"); //$NON-NLS-1$
+				this.methodAnnotationSources.put(line.substring(0, pos), line.substring(pos+1));
+			}
+		} finally {
+			reader.close();
+		}
+	}
+
+	@Override
+	public ITypeAnnotationWalker forMethod(char[] selector, char[] signature, LookupEnvironment environment) {
+		String source = this.methodAnnotationSources.get(String.valueOf(CharOperation.concat(selector, signature)));
+		if (source != null)
+			return new MethodAnnotationWalker(source.toCharArray(), 0, environment);
+		return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+	}
+	
+	abstract class SingleMarkerAnnotation implements IBinaryAnnotation {
+		@Override
+		public IBinaryElementValuePair[] getElementValuePairs() {
+			return ElementValuePairInfo.NoMembers;
+		}
+		protected char[] getBinaryTypeName(char[][] name) {
+			return CharOperation.concat('L', CharOperation.concatWith(name, '/'), ';');
+		}
+	}
+
+	class MethodAnnotationWalker implements ITypeAnnotationWalker {
+
+		private SingleMarkerAnnotation NULLABLE = new SingleMarkerAnnotation() {
+			@Override public char[] getTypeName() { return getBinaryTypeName(MethodAnnotationWalker.this.environment.getNullableAnnotationName()); }
+		};
+		private SingleMarkerAnnotation NONNULL = new SingleMarkerAnnotation() {
+			@Override public char[] getTypeName() { return getBinaryTypeName(MethodAnnotationWalker.this.environment.getNonNullAnnotationName()); }
+		};
+
+		char[] source;
+		int pos;
+		LookupEnvironment environment;
+
+		MethodAnnotationWalker(char[] source, int pos, LookupEnvironment environment) {
+			super();
+			this.source = source;
+			this.pos = pos;
+			this.environment = environment;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toMethodReturn() {
+			int close = CharOperation.indexOf(')', this.source);
+			if (close != -1)
+				return new MethodAnnotationWalker(this.source, close+1, this.environment);
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toReceiver() {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeBound(short boundIndex) {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toSupertype(short index) {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toMethodParameter(short index) {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toThrows(int index) {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeArgument(int rank) {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toWildcardBound() {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toNextArrayDimension() {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toNextNestedType() {
+			return this;
+		}
+
+		@Override
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
+			if (this.pos != -1 && this.pos < this.source.length-2) {
+				switch (this.source[this.pos]) {
+					case 'T':
+					case 'L':
+						switch (this.source[this.pos+1]) {
+							case '0':
+								return new IBinaryAnnotation[]{ this.NULLABLE };
+							case '1':
+								return new IBinaryAnnotation[]{ this.NONNULL };
+						}
+				}				
+			}
+			return null;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toField() {
+			throw new UnsupportedOperationException("Methods have no fields"); //$NON-NLS-1$
+		}		
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
index cac02c8..95d996e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
@@ -14,6 +14,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
@@ -101,21 +102,21 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 	
 	@Override
-	public TypeAnnotationWalker toMethodParameter(short index) {
+	public ITypeAnnotationWalker toMethodParameter(short index) {
 		// don't set nextIsDefaultLocation, because signature-level nullness is handled by ImplicitNullAnnotationVerifier
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toMethodParameter(index);
 	}
 
 	@Override
-	public TypeAnnotationWalker toMethodReturn() {
+	public ITypeAnnotationWalker toMethodReturn() {
 		// don't set nextIsDefaultLocation, because signature-level nullness is handled by ImplicitNullAnnotationVerifier
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toMethodReturn();
 	}
 
 	@Override
-	public TypeAnnotationWalker toTypeBound(short boundIndex) {
+	public ITypeAnnotationWalker toTypeBound(short boundIndex) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
 		this.nextIsTypeBound = true;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
@@ -123,7 +124,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 
 	@Override
-	public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+	public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
 		this.nextIsTypeBound = true;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
@@ -131,7 +132,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 
 	@Override
-	public TypeAnnotationWalker toTypeArgument(int rank) {
+	public ITypeAnnotationWalker toTypeArgument(int rank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeArgument) != 0;
 		this.nextIsTypeBound = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
@@ -139,7 +140,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 
 	@Override
-	public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+	public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeParameter) != 0;
 		this.nextIsTypeBound = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
index 3e525b7..7f4e388 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
@@ -13,37 +13,11 @@ package org.eclipse.jdt.internal.compiler.classfmt;
 import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 
-/**
- * A TypeAnnotationWalker is initialized with all type annotations found at a given element.
- * It can be used to walk into the types at the given element and finally answer the
- * actual annotations at any node of the walk.
- * 
- * The walker is implemented as immutable objects. During the walk either new instances
- * are created, or the current instance is shared if no difference is encountered.
- */
-public class TypeAnnotationWalker {
+/** Type annotation walker implementation based an actual annotations decoded from a .class file. */
+public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 
-	public static final IBinaryAnnotation[] NO_ANNOTATIONS = new IBinaryAnnotation[0];
-
-	/**
-	 * A no-effect annotation walker, all walking methods are implemented as identity-functions.
-	 * At the end of any walk an empty array of annotations is returned.
-	 */
-	public static final TypeAnnotationWalker EMPTY_ANNOTATION_WALKER = new TypeAnnotationWalker(new IBinaryTypeAnnotation[0], 0L) {
-		public TypeAnnotationWalker toField() { return this; }
-		public TypeAnnotationWalker toTarget(int targetType) { return this; }
-		public TypeAnnotationWalker toThrows(int rank) { return this; }
-		public TypeAnnotationWalker toTypeArgument(int rank) { return this; }
-		public TypeAnnotationWalker toMethodParameter(short index) { return this; }
-		public TypeAnnotationWalker toSupertype(short index) { return this; }
-		public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) { return this; }
-		public TypeAnnotationWalker toTypeBound(short boundIndex) { return this; }
-		public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) { return this; }
-		public TypeAnnotationWalker toNextDetail(int detailKind) { return this; }
-		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) { return NO_ANNOTATIONS; }
-	};
-	
 	final protected IBinaryTypeAnnotation[] typeAnnotations;	// the actual material we're managing here
 	final protected long matches;								// bit mask of indices into typeAnnotations, 1 means active, 0 is filtered during the walk
 	final protected int pathPtr;								// pointer into the typePath
@@ -61,7 +35,7 @@ public class TypeAnnotationWalker {
 		this.pathPtr = pathPtr;
 	}
 
-	protected TypeAnnotationWalker restrict(long newMatches, int newPathPtr) {
+	protected ITypeAnnotationWalker restrict(long newMatches, int newPathPtr) {
 		if (this.matches == newMatches && this.pathPtr == newPathPtr) return this;
 		if (newMatches == 0 || this.typeAnnotations == null || this.typeAnnotations.length == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -71,12 +45,13 @@ public class TypeAnnotationWalker {
 	// ==== filter by top-level targetType: ====
 	
 	/** Walk to a field. */
-	public TypeAnnotationWalker toField() {
+	public ITypeAnnotationWalker toField() {
 		return toTarget(AnnotationTargetTypeConstants.FIELD);
 	}
 
 	/** Walk to the return type of a method. */
-	public TypeAnnotationWalker toMethodReturn() {
+	@Override
+	public ITypeAnnotationWalker toMethodReturn() {
 		return toTarget(AnnotationTargetTypeConstants.METHOD_RETURN);
 	}
 
@@ -84,14 +59,15 @@ public class TypeAnnotationWalker {
 	 * Walk to the receiver type of a method.
 	 * Note: Type annotations on receiver are not currently used by the compiler.
 	 */
-	public TypeAnnotationWalker toReceiver() {
+	@Override
+	public ITypeAnnotationWalker toReceiver() {
 		return toTarget(AnnotationTargetTypeConstants.METHOD_RECEIVER);
 	}
 
 	/*
 	 * Implementation for walking to methodReturn, receiver type or field.
 	 */
-	protected TypeAnnotationWalker toTarget(int targetType) {
+	protected ITypeAnnotationWalker toTarget(int targetType) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -109,7 +85,8 @@ public class TypeAnnotationWalker {
 	 * @param isClassTypeParameter whether we are looking for a class type parameter (else: method type type parameter)
 	 * @param rank rank of the type parameter
 	 */
-	public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+	@Override
+	public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -131,7 +108,8 @@ public class TypeAnnotationWalker {
 	 * @param isClassTypeParameter whether we are looking at a class type parameter (else: method type type parameter)
 	 * @param parameterRank rank of the type parameter.
 	 */
-	public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+	@Override
+	public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -152,7 +130,8 @@ public class TypeAnnotationWalker {
 	 * of the previously selected type parameter. 
 	 * @param boundIndex
 	 */
-	public TypeAnnotationWalker toTypeBound(short boundIndex) {
+	@Override
+	public ITypeAnnotationWalker toTypeBound(short boundIndex) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -169,7 +148,8 @@ public class TypeAnnotationWalker {
 	
 	
 	/** Walk to the specified supertype: -1 is superclass, else the superinterface at the given index. */
-	public TypeAnnotationWalker toSupertype(short index) {
+	@Override
+	public ITypeAnnotationWalker toSupertype(short index) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -185,7 +165,8 @@ public class TypeAnnotationWalker {
 	}
 
 	/** Walk to the index'th visible formal method parameter (i.e., not counting synthetic args). */
-	public TypeAnnotationWalker toMethodParameter(short index) {
+	@Override
+	public ITypeAnnotationWalker toMethodParameter(short index) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -203,7 +184,8 @@ public class TypeAnnotationWalker {
 	/**
 	 * Walk to the throws type at the given index.
 	 */
-	public TypeAnnotationWalker toThrows(int index) {
+	@Override
+	public ITypeAnnotationWalker toThrows(int index) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -221,7 +203,8 @@ public class TypeAnnotationWalker {
 	// ==== descending into details: ====
 
 	/** Walk to the type argument of the given rank. */
-	public TypeAnnotationWalker toTypeArgument(int rank) {
+	@Override
+	public ITypeAnnotationWalker toTypeArgument(int rank) {
 		// like toNextDetail() but also checking byte 2 against rank
 		long newMatches = this.matches;
 		if (newMatches == 0)
@@ -241,7 +224,8 @@ public class TypeAnnotationWalker {
 	}
 
 	/** Walk to the bound of a wildcard. */
-	public TypeAnnotationWalker toWildcardBound() {
+	@Override
+	public ITypeAnnotationWalker toWildcardBound() {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -261,14 +245,16 @@ public class TypeAnnotationWalker {
 	/**
 	 * Descend down one level of array dimensions.
 	 */
-	public TypeAnnotationWalker toNextArrayDimension() {
+	@Override
+	public ITypeAnnotationWalker toNextArrayDimension() {
 		return toNextDetail(AnnotationTargetTypeConstants.NEXT_ARRAY_DIMENSION);
 	}
 	
 	/**
 	 * Descend down one level of type nesting.
 	 */
-	public TypeAnnotationWalker toNextNestedType() {
+	@Override
+	public ITypeAnnotationWalker toNextNestedType() {
 		return toNextDetail(AnnotationTargetTypeConstants.NEXT_NESTED_TYPE);
 	}
 
@@ -276,7 +262,7 @@ public class TypeAnnotationWalker {
 	 * Implementation for walking along the type_path for array dimensions & nested types.
 	 * FIXME(stephan): support wildcard bounds.
 	 */
-	protected TypeAnnotationWalker toNextDetail(int detailKind) {
+	protected ITypeAnnotationWalker toNextDetail(int detailKind) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -298,6 +284,7 @@ public class TypeAnnotationWalker {
 	 * Retrieve the type annotations at the current position
 	 * reached by invocations of toXYZ() methods.
 	 */
+	@Override
 	public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
 		int length = this.typeAnnotations.length;
 		IBinaryAnnotation[] filtered = new IBinaryAnnotation[length];
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java
new file mode 100644
index 0000000..05a0241
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java
@@ -0,0 +1,20 @@
+/*******************************************************************************
+ * Copyright (c) 2014 GK Software AG, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.env;
+
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+
+/** An instance of of this type answers external annotations for the methods and fields of a given class. */
+public interface IExternalAnnotationProvider {
+	
+	ITypeAnnotationWalker forMethod(char[] selector, char[] signature, LookupEnvironment environment);
+
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
new file mode 100644
index 0000000..26e95b7
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
@@ -0,0 +1,114 @@
+/*******************************************************************************
+ * Copyright (c) 2014 GK Software AG.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.env;
+
+
+/**
+ * A TypeAnnotationWalker is initialized with all type annotations found at a given element.
+ * It can be used to walk into the types at the given element and finally answer the
+ * actual annotations at any node of the walk.
+ * 
+ * The walker is implemented as immutable objects. During the walk either new instances
+ * are created, or the current instance is shared if no difference is encountered.
+ */
+public interface ITypeAnnotationWalker {
+
+	public static final IBinaryAnnotation[] NO_ANNOTATIONS = new IBinaryAnnotation[0];
+	/**
+	 * A no-effect annotation walker, all walking methods are implemented as identity-functions.
+	 * At the end of any walk an empty array of annotations is returned.
+	 */
+	public static final ITypeAnnotationWalker EMPTY_ANNOTATION_WALKER = new ITypeAnnotationWalker() {
+		public ITypeAnnotationWalker toField() { return this; }
+		public ITypeAnnotationWalker toThrows(int rank) { return this; }
+		public ITypeAnnotationWalker toTypeArgument(int rank) { return this; }
+		public ITypeAnnotationWalker toMethodParameter(short index) { return this; }
+		public ITypeAnnotationWalker toSupertype(short index) { return this; }
+		public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) { return this; }
+		public ITypeAnnotationWalker toTypeBound(short boundIndex) { return this; }
+		public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) { return this; }
+		public ITypeAnnotationWalker toMethodReturn() { return this; }
+		public ITypeAnnotationWalker toReceiver() { return this; }
+		public ITypeAnnotationWalker toWildcardBound() { return this; }
+		public ITypeAnnotationWalker toNextArrayDimension() { return this; }
+		public ITypeAnnotationWalker toNextNestedType() { return this; }
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) { return NO_ANNOTATIONS; }
+	};
+
+	/** Walk to a field. */
+	public abstract ITypeAnnotationWalker toField();
+
+
+	/** Walk to the return type of a method. */
+	public abstract ITypeAnnotationWalker toMethodReturn();
+
+	/**
+	 * Walk to the receiver type of a method.
+	 * Note: Type annotations on receiver are not currently used by the compiler.
+	 */
+	public abstract ITypeAnnotationWalker toReceiver();
+
+	/**
+	 * Walk to the type parameter of the given rank.
+	 * @param isClassTypeParameter whether we are looking for a class type parameter (else: method type type parameter)
+	 * @param rank rank of the type parameter
+	 */
+	public abstract ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank);
+
+	/**
+	 * Walk to the bounds of a type parameter of either a class or a method (signaled by isClassTypeParameter).
+	 * Clients must then call {@link #toTypeBound(short)} on the resulting walker.
+	 * @param isClassTypeParameter whether we are looking at a class type parameter (else: method type type parameter)
+	 * @param parameterRank rank of the type parameter.
+	 */
+	public abstract ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank);
+
+	/**
+	 * Detail of {@link #toTypeParameterBounds(boolean, int)}: walk to the bounds
+	 * of the previously selected type parameter. 
+	 * @param boundIndex
+	 */
+	public abstract ITypeAnnotationWalker toTypeBound(short boundIndex);
+
+	/** Walk to the specified supertype: -1 is superclass, else the superinterface at the given index. */
+	public abstract ITypeAnnotationWalker toSupertype(short index);
+
+	/** Walk to the index'th visible formal method parameter (i.e., not counting synthetic args). */
+	public abstract ITypeAnnotationWalker toMethodParameter(short index);
+
+	/**
+	 * Walk to the throws type at the given index.
+	 */
+	public abstract ITypeAnnotationWalker toThrows(int index);
+
+	/** Walk to the type argument of the given rank. */
+	public abstract ITypeAnnotationWalker toTypeArgument(int rank);
+
+	/** Walk to the bound of a wildcard. */
+	public abstract ITypeAnnotationWalker toWildcardBound();
+
+	/**
+	 * Descend down one level of array dimensions.
+	 */
+	public abstract ITypeAnnotationWalker toNextArrayDimension();
+
+	/**
+	 * Descend down one level of type nesting.
+	 */
+	public abstract ITypeAnnotationWalker toNextNestedType();
+
+	/**
+	 * Retrieve the type annotations at the current position
+	 * reached by invocations of toXYZ() methods.
+	 */
+	public abstract IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId);
+
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index baf0271..a3a82ff 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -29,6 +29,7 @@
  *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *								Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
  *								Bug 434602 - Possible error with inferred null annotations leading to contradictory null annotations
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *    Jesper Steen Moller - Contributions for
  *								Bug 412150 [1.8] [compiler] Enable reflected parameter names during annotation processing
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -40,6 +41,7 @@ import java.util.ArrayList;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.NonNullDefaultAwareTypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
@@ -90,12 +92,12 @@ static Object convertMemberValue(Object binaryValue, LookupEnvironment env, char
 	if (binaryValue instanceof Constant)
 		return binaryValue;
 	if (binaryValue instanceof ClassSignature)
-		return env.getTypeFromSignature(((ClassSignature) binaryValue).getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+		return env.getTypeFromSignature(((ClassSignature) binaryValue).getTypeName(), 0, -1, false, null, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 	if (binaryValue instanceof IBinaryAnnotation)
 		return createAnnotation((IBinaryAnnotation) binaryValue, env, missingTypeNames);
 	if (binaryValue instanceof EnumConstantSignature) {
 		EnumConstantSignature ref = (EnumConstantSignature) binaryValue;
-		ReferenceBinding enumType = (ReferenceBinding) env.getTypeFromSignature(ref.getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+		ReferenceBinding enumType = (ReferenceBinding) env.getTypeFromSignature(ref.getTypeName(), 0, -1, false, null, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 		if (enumType.isUnresolvedType() && !resolveEnumConstants)
 			return new ElementValuePair.UnresolvedEnumConstant(enumType, env, ref.getEnumConstantName());
 		enumType = (ReferenceBinding) resolveType(enumType, env, false /* no raw conversion */);
@@ -403,7 +405,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 			// need annotations on the type before processing null annotations on members respecting any @NonNullByDefault:
 			scanTypeForNullDefaultAnnotation(binaryType, this.fPackage, this);
 		}
-		TypeAnnotationWalker walker = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
+		ITypeAnnotationWalker walker = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
 		char[] typeSignature = binaryType.getGenericSignature(); // use generic signature even in 1.4
 		this.tagBits |= binaryType.getTagBits();
 		
@@ -473,7 +475,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 		if (needFieldsAndMethods) {
 			IBinaryField[] iFields = binaryType.getFields();
 			createFields(iFields, sourceLevel, missingTypeNames);
-			IBinaryMethod[] iMethods = createMethods(binaryType.getMethods(), sourceLevel, missingTypeNames);
+			IBinaryMethod[] iMethods = createMethods(binaryType.getMethods(), binaryType, sourceLevel, missingTypeNames);
 			boolean isViewedAsDeprecated = isViewedAsDeprecated();
 			if (isViewedAsDeprecated) {
 				for (int i = 0, max = this.fields.length; i < max; i++) {
@@ -513,7 +515,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 	}
 }
 
-private TypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] annotations) {
+private ITypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] annotations) {
 	if (!isPrototype()) throw new IllegalStateException();
 	if (annotations == null || annotations.length == 0 || !this.environment.usesAnnotatedTypeSystem()) {
 		if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
@@ -521,7 +523,7 @@ private TypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] ann
 			if (nullness > Binding.NULL_UNSPECIFIED_BY_DEFAULT)
 				return new NonNullDefaultAwareTypeAnnotationWalker(nullness, this.environment);
 		}
-		return TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
 	}
 	if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
 		int nullness = getNullDefault();
@@ -544,7 +546,7 @@ private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] m
 			for (int i = 0; i < size; i++) {
 				IBinaryField binaryField = iFields[i];
 				char[] fieldSignature = use15specifics ? binaryField.getGenericSignature() : null;
-				TypeAnnotationWalker walker = getTypeAnnotationWalker(binaryField.getTypeAnnotations()).toField();
+				ITypeAnnotationWalker walker = getTypeAnnotationWalker(binaryField.getTypeAnnotations()).toField();
 				TypeBinding type = fieldSignature == null
 					? this.environment.getTypeFromSignature(binaryField.getTypeName(), 0, -1, false, this, missingTypeNames, walker)
 					: this.environment.getTypeFromTypeSignature(new SignatureWrapper(fieldSignature), Binding.NO_TYPE_VARIABLES, this, missingTypeNames, walker);
@@ -580,7 +582,7 @@ private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] m
 	}
 }
 
-private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[][][] missingTypeNames) {
+private MethodBinding createMethod(IBinaryMethod method, IBinaryType binaryType, long sourceLevel, char[][][] missingTypeNames) {
 	if (!isPrototype()) throw new IllegalStateException();
 	int methodModifiers = method.getModifiers() | ExtraCompilerModifiers.AccUnresolved;
 	if (sourceLevel < ClassFileConstants.JDK1_5)
@@ -606,10 +608,13 @@ private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[
 	   variables properly in order to be able to apply substitutions and thus be able to detect
 	   overriding in the presence of generics. Seeing the erased form is not good enough.
 	 */
-	TypeAnnotationWalker walker = getTypeAnnotationWalker(method.getTypeAnnotations());
+	ITypeAnnotationWalker walker = getTypeAnnotationWalker(method.getTypeAnnotations());
 	char[] methodSignature = method.getGenericSignature(); // always use generic signature, even in 1.4
 	if (methodSignature == null) { // no generics
 		char[] methodDescriptor = method.getMethodDescriptor();   // of the form (I[Ljava/jang/String;)V
+		if (walker == ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER && binaryType instanceof ClassFileReader) {// TODO: avoid cast? add method to IBinaryType?
+			walker = ((ClassFileReader)binaryType).getAnnotationsForMethod(method, methodDescriptor, this.environment);
+		}
 		int numOfParams = 0;
 		char nextChar;
 		int index = 0; // first character is always '(' so skip it
@@ -683,6 +688,9 @@ private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[
 		}
 
 	} else {
+		if (walker == ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER && binaryType instanceof ClassFileReader) {// TODO: avoid cast? add method to IBinaryType?
+			walker = ((ClassFileReader)binaryType).getAnnotationsForMethod(method, methodSignature, this.environment);
+		}
 		methodModifiers |= ExtraCompilerModifiers.AccGenericSignature;
 		// MethodTypeSignature = ParameterPart(optional) '(' TypeSignatures ')' return_typeSignature ['^' TypeSignature (optional)]
 		SignatureWrapper wrapper = new SignatureWrapper(methodSignature, use15specifics);
@@ -780,7 +788,7 @@ private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[
  * As some iMethods may be ignored in this process we return the matching array of those
  * iMethods for which MethodBindings have been created; indices match those in this.methods.
  */
-private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, long sourceLevel, char[][][] missingTypeNames) {
+private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, IBinaryType binaryType, long sourceLevel, char[][][] missingTypeNames) {
 	if (!isPrototype()) throw new IllegalStateException();
 	int total = 0, initialTotal = 0, iClinit = -1;
 	int[] toSkip = null;
@@ -815,7 +823,7 @@ private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, long sourceLevel
 	this.methods = new MethodBinding[total];
 	if (total == initialTotal) {
 		for (int i = 0; i < initialTotal; i++) {
-			MethodBinding method = createMethod(iMethods[i], sourceLevel, missingTypeNames);
+			MethodBinding method = createMethod(iMethods[i], binaryType, sourceLevel, missingTypeNames);
 			if (hasRestrictedAccess)
 				method.modifiers |= ExtraCompilerModifiers.AccRestrictedAccess;
 			this.methods[i] = method;
@@ -825,7 +833,7 @@ private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, long sourceLevel
 		IBinaryMethod[] mappedBinaryMethods = new IBinaryMethod[total];
 		for (int i = 0, index = 0; i < initialTotal; i++) {
 			if (iClinit != i && (toSkip == null || toSkip[i] != -1)) {
-				MethodBinding method = createMethod(iMethods[i], sourceLevel, missingTypeNames);
+				MethodBinding method = createMethod(iMethods[i], binaryType, sourceLevel, missingTypeNames);
 				if (hasRestrictedAccess)
 					method.modifiers |= ExtraCompilerModifiers.AccRestrictedAccess;
 				mappedBinaryMethods[index] = iMethods[i];
@@ -837,7 +845,7 @@ private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, long sourceLevel
 }
 
 private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, boolean assignVariables, char[][][] missingTypeNames,
-													TypeAnnotationWalker walker, boolean isClassTypeParameter)
+													ITypeAnnotationWalker walker, boolean isClassTypeParameter)
 {
 	if (!isPrototype()) throw new IllegalStateException();
 	// detect all type variables first
@@ -954,7 +962,7 @@ private MethodBinding findMethod(char[] methodDescriptor, char[][][] missingType
 				while ((nextChar = methodDescriptor[++end]) != Util.C_NAME_END){/*empty*/}
 
 			// not interested in type annotations, type will be used for comparison only, and erasure() is used if needed
-			TypeBinding param = this.environment.getTypeFromSignature(methodDescriptor, index, end, false, this, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+			TypeBinding param = this.environment.getTypeFromSignature(methodDescriptor, index, end, false, this, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 			if (param instanceof UnresolvedReferenceBinding) {
 				param = resolveType(param, this.environment, true /* raw conversion */);
 			}
@@ -1225,7 +1233,7 @@ public boolean hasTypeBit(int bit) {
 	}
 	return (this.typeBits & bit) != 0;
 }
-private void initializeTypeVariable(TypeVariableBinding variable, TypeVariableBinding[] existingVariables, SignatureWrapper wrapper, char[][][] missingTypeNames, TypeAnnotationWalker walker) {
+private void initializeTypeVariable(TypeVariableBinding variable, TypeVariableBinding[] existingVariables, SignatureWrapper wrapper, char[][][] missingTypeNames, ITypeAnnotationWalker walker) {
 	if (!isPrototype()) throw new IllegalStateException();
 	// ParameterSignature = Identifier ':' TypeSignature
 	//   or Identifier ':' TypeSignature(optional) InterfaceBound(s)
@@ -1742,7 +1750,7 @@ private void scanTypeForContainerAnnotation(IBinaryType binaryType, char[][][] m
 				if (elementValuePairs != null && elementValuePairs.length == 1) {
 					Object value = elementValuePairs[0].getValue();
 					if (value instanceof ClassSignature) {
-						this.containerAnnotationType = (ReferenceBinding) this.environment.getTypeFromSignature(((ClassSignature)value).getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+						this.containerAnnotationType = (ReferenceBinding) this.environment.getTypeFromSignature(((ClassSignature)value).getTypeName(), 0, -1, false, null, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 					}
 				}
 				break;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 8144e21..53da641 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -27,6 +27,7 @@
  *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *								Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
  *								Bug 434602 - Possible error with inferred null annotations leading to contradictory null annotations
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -41,7 +42,6 @@ import org.eclipse.jdt.internal.compiler.ClassFilePool;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.ITypeRequestor;
@@ -1164,7 +1164,7 @@ public ReferenceBinding getType(char[][] compoundName) {
 }
 
 private TypeBinding[] getTypeArgumentsFromSignature(SignatureWrapper wrapper, TypeVariableBinding[] staticVariables, ReferenceBinding enclosingType, ReferenceBinding genericType,
-		char[][][] missingTypeNames, TypeAnnotationWalker walker)
+		char[][][] missingTypeNames, ITypeAnnotationWalker walker)
 {
 	java.util.ArrayList args = new java.util.ArrayList(2);
 	int rank = 0;
@@ -1217,7 +1217,7 @@ private ReferenceBinding getTypeFromCompoundName(char[][] compoundName, boolean
 *
 * NOTE: Does NOT answer base types nor array types!
 */
-ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int end, boolean isParameterized, char[][][] missingTypeNames, TypeAnnotationWalker walker) {
+ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int end, boolean isParameterized, char[][][] missingTypeNames, ITypeAnnotationWalker walker) {
 	if (end == -1)
 		end = signature.length;
 	char[][] compoundName = CharOperation.splitOn('/', signature, start, end);
@@ -1231,14 +1231,14 @@ ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int en
 		}
 	}
 	ReferenceBinding binding = getTypeFromCompoundName(compoundName, isParameterized, wasMissingType);
-	if (walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		binding = (ReferenceBinding) annotateType(binding, walker, missingTypeNames);
 	}
 	return binding;
 }
 
 ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int end, boolean isParameterized, char[][][] missingTypeNames) {
-	return getTypeFromConstantPoolName(signature, start, end, isParameterized, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+	return getTypeFromConstantPoolName(signature, start, end, isParameterized, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 }
 
 /* Answer the type corresponding to the signature from the binary file.
@@ -1248,7 +1248,7 @@ ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int en
 * NOTE: Does answer base types & array types.
 */
 TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean isParameterized, TypeBinding enclosingType, 
-		char[][][] missingTypeNames, TypeAnnotationWalker walker)
+		char[][][] missingTypeNames, ITypeAnnotationWalker walker)
 {
 	int dimension = 0;
 	while (signature[start] == '[') {
@@ -1257,7 +1257,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 	}
 	// annotations on dimensions?
 	AnnotationBinding [][] annotationsOnDimensions = null;
-	if (dimension > 0 && walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (dimension > 0 && walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		for (int i = 0; i < dimension; i++) {
 			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0), this, missingTypeNames);
 			if (annotations != Binding.NO_ANNOTATIONS) { 
@@ -1317,7 +1317,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 		return binding;
 	}
 	
-	if (walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		binding = annotateType(binding, walker, missingTypeNames);
 	}
 	
@@ -1327,7 +1327,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 	return binding;
 }
 
-private TypeBinding annotateType(TypeBinding binding, TypeAnnotationWalker walker, char[][][] missingTypeNames) {
+private TypeBinding annotateType(TypeBinding binding, ITypeAnnotationWalker walker, char[][][] missingTypeNames) {
 	int depth = binding.depth() + 1;
 	if (depth > 1) {
 		// need to count non-static nesting levels, resolved binding required for precision
@@ -1373,7 +1373,7 @@ boolean qualifiedNameMatchesSignature(char[][] name, char[] signature) {
 }
 
 public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariableBinding[] staticVariables, ReferenceBinding enclosingType, 
-		char[][][] missingTypeNames, TypeAnnotationWalker walker) 
+		char[][][] missingTypeNames, ITypeAnnotationWalker walker) 
 {
 	// TypeVariableSignature = 'T' Identifier ';'
 	// ArrayTypeSignature = '[' TypeSignature
@@ -1387,7 +1387,7 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 	}
 	// annotations on dimensions?
 	AnnotationBinding [][] annotationsOnDimensions = null;
-	if (dimension > 0 && walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (dimension > 0 && walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		for (int i = 0; i < dimension; i++) {
 			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0), this, missingTypeNames);
 			if (annotations != Binding.NO_ANNOTATIONS) { 
@@ -1461,7 +1461,7 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 	return dimension == 0 ? (TypeBinding) parameterizedType : createArrayType(parameterizedType, dimension, AnnotatableTypeSystem.flattenedAnnotations(annotationsOnDimensions));
 }
 
-private TypeBinding getTypeFromTypeVariable(TypeVariableBinding typeVariableBinding, int dimension, AnnotationBinding [][] annotationsOnDimensions, TypeAnnotationWalker walker, char [][][] missingTypeNames) {
+private TypeBinding getTypeFromTypeVariable(TypeVariableBinding typeVariableBinding, int dimension, AnnotationBinding [][] annotationsOnDimensions, ITypeAnnotationWalker walker, char [][][] missingTypeNames) {
 	AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0), this, missingTypeNames);
 	if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
 		typeVariableBinding = (TypeVariableBinding) createAnnotatedType(typeVariableBinding, new AnnotationBinding [][] { annotations });
@@ -1479,7 +1479,7 @@ TypeBinding getTypeFromVariantTypeSignature(
 		ReferenceBinding genericType,
 		int rank,
 		char[][][] missingTypeNames,
-		TypeAnnotationWalker walker) {
+		ITypeAnnotationWalker walker) {
 	// VariantTypeSignature = '-' TypeSignature
 	//   or '+' TypeSignature
 	//   or TypeSignature
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathEntry.java
index 8c882fd..0aa30ad 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathEntry.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.core;
 
@@ -472,4 +474,11 @@ public interface IClasspathEntry {
 	 * @deprecated Use {@link JavaCore#getResolvedClasspathEntry(IClasspathEntry)} instead
 	 */
 	IClasspathEntry getResolvedEntry();
+
+	/**
+	 * Returns the location where external annotation files can be found to assist
+	 * annotation based null analysis of 3rd party libraries.
+	 * @since 3.11
+	 */
+	IPath getExternalAnnotationPath();
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index f34eba2..b2da3e7 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -98,6 +98,8 @@
  *									COMPILER_INHERIT_NULL_ANNOTATIONS
  *									COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED
  *									COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *     Jesper S Moller   - Contributions for bug 381345 : [1.8] Take care of the Java 8 major version
  *                       - added the following constants:
  *									COMPILER_CODEGEN_METHOD_PARAMETERS_ATTR
@@ -4470,6 +4472,7 @@ public final class JavaCore extends Plugin {
 			ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 			null, // source attachment
 			null, // source attachment root
+			null, // external annotation path
 			null, // specific output folder
 			isExported,
 			accessRules,
@@ -4653,6 +4656,86 @@ public final class JavaCore extends Plugin {
 			IAccessRule[] accessRules,
 			IClasspathAttribute[] extraAttributes,
 			boolean isExported) {
+		return newLibraryEntry(path, sourceAttachmentPath, sourceAttachmentRootPath, null, accessRules, extraAttributes, isExported);
+	}
+
+	/**
+	 * Creates and returns a new classpath entry of kind <code>CPE_LIBRARY</code> for the JAR or folder
+	 * identified by the given absolute path. This specifies that all package fragments within the root
+	 * will have children of type <code>IClassFile</code>.
+	 * <p>
+	 * A library entry is used to denote a prerequisite JAR or root folder containing binaries.
+	 * The target JAR can either be defined internally to the workspace (absolute path relative
+	 * to the workspace root), or externally to the workspace (absolute path in the file system).
+	 * The target root folder can also be defined internally to the workspace (absolute path relative
+	 * to the workspace root), or - since 3.4 - externally to the workspace (absolute path in the file system).
+	 * Since 3.5, the path to the library can also be relative to the project using ".." as the first segment. 
+	 * </p>
+	 * <p>
+	 * e.g. Here are some examples of binary path usage
+	 * </p>
+	 *	<ul>
+	 *	<li><code> "c:\jdk1.2.2\jre\lib\rt.jar" </code> - reference to an external JAR on Windows</li>
+	 *	<li><code> "/Project/someLib.jar" </code> - reference to an internal JAR on Windows or Linux</li>
+	 *	<li><code> "/Project/classes/" </code> - reference to an internal binary folder on Windows or Linux</li>
+	 *	<li><code> "/home/usr/classes" </code> - reference to an external binary folder on Linux</li>
+	 *	<li><code> "../../lib/someLib.jar" </code> - reference to an external JAR that is a sibling of the workspace on either platform</li>
+	 * </ul>
+	 * Note that on non-Windows platform, a path <code>"/some/lib.jar"</code> is ambiguous.
+	 * It can be a path to an external JAR (its file system path being <code>"/some/lib.jar"</code>)
+	 * or it can be a path to an internal JAR (<code>"some"</code> being a project in the workspace).
+	 * Such an ambiguity is solved when the classpath entry is used (e.g. in {@link IJavaProject#getPackageFragmentRoots()}).
+	 * If the resource <code>"lib.jar"</code> exists in project <code>"some"</code>, then it is considered an
+	 * internal JAR. Otherwise it is an external JAR.
+	 * <p>Also note that this operation does not attempt to validate or access the
+	 * resources at the given paths.
+	 * </p><p>
+	 * The access rules determine the set of accessible class files
+	 * in the library. If the list of access rules is empty then all files
+	 * in this library are accessible.
+	 * See {@link IAccessRule} for a detailed description of access
+	 * rules.
+	 * </p>
+	 * <p>
+	 * The <code>extraAttributes</code> list contains name/value pairs that must be persisted with
+	 * this entry. If no extra attributes are provided, an empty array must be passed in.<br>
+	 * Note that this list should not contain any duplicate name.
+	 * </p>
+	 * <p>
+	 * The <code>isExported</code> flag indicates whether this entry is contributed to dependent
+	 * projects. If not exported, dependent projects will not see any of the classes from this entry.
+	 * If exported, dependent projects will concatenate the accessible files patterns of this entry with the
+	 * accessible files patterns of the projects, and they will concatenate the non accessible files patterns of this entry
+	 * with the non accessible files patterns of the project.
+	 * </p>
+	 * <p>
+	 * Since 3.5, if the library is a ZIP archive, the "Class-Path" clause (if any) in the "META-INF/MANIFEST.MF" is read
+	 * and referenced ZIP archives are added to the {@link IJavaProject#getResolvedClasspath(boolean) resolved classpath}.
+	 * </p>
+	 *
+	 * @param path the path to the library
+	 * @param sourceAttachmentPath the absolute path of the corresponding source archive or folder,
+	 *    or <code>null</code> if none. Note, since 3.0, an empty path is allowed to denote no source attachment.
+	 *   and will be automatically converted to <code>null</code>. Since 3.4, this path can also denote a path external
+	 *   to the workspace.
+	 * @param sourceAttachmentRootPath the location of the root of the source files within the source archive or folder
+	 *    or <code>null</code> if this location should be automatically detected.
+	 * @param externalAnnotationPath the location where external annotations are found for annotation based null analysis
+	 * @param accessRules the possibly empty list of access rules for this entry
+	 * @param extraAttributes the possibly empty list of extra attributes to persist with this entry
+	 * @param isExported indicates whether this entry is contributed to dependent
+	 * 	  projects in addition to the output location
+	 * @return a new library classpath entry
+	 * @since 3.11
+	 */
+	public static IClasspathEntry newLibraryEntry(
+			IPath path,
+			IPath sourceAttachmentPath,
+			IPath sourceAttachmentRootPath,
+			IPath externalAnnotationPath,
+			IAccessRule[] accessRules,
+			IClasspathAttribute[] extraAttributes,
+			boolean isExported) {
 
 		if (path == null) throw new ClasspathEntry.AssertionFailedException("Library path cannot be null"); //$NON-NLS-1$
 		if (accessRules == null) {
@@ -4680,6 +4763,7 @@ public final class JavaCore extends Plugin {
 			ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 			sourceAttachmentPath,
 			sourceAttachmentRootPath,
+			externalAnnotationPath,
 			null, // specific output folder
 			isExported,
 			accessRules,
@@ -4800,6 +4884,7 @@ public final class JavaCore extends Plugin {
 			ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 			null, // source attachment
 			null, // source attachment root
+			null, // external annotation path
 			null, // specific output folder
 			isExported,
 			accessRules,
@@ -5011,6 +5096,7 @@ public final class JavaCore extends Plugin {
 			exclusionPatterns,
 			null, // source attachment
 			null, // source attachment root
+			null, // external annotation path
 			specificOutputLocation, // custom output location
 			false,
 			null,
@@ -5145,6 +5231,80 @@ public final class JavaCore extends Plugin {
 			IAccessRule[] accessRules,
 			IClasspathAttribute[] extraAttributes,
 			boolean isExported) {
+		return newVariableEntry(variablePath, variableSourceAttachmentPath, variableSourceAttachmentRootPath, null, accessRules, extraAttributes, isExported);
+	}
+
+	/**
+	 * Creates and returns a new classpath entry of kind <code>CPE_VARIABLE</code>
+	 * for the given path. The first segment of the path is the name of a classpath variable.
+	 * The trailing segments of the path will be appended to resolved variable path.
+	 * <p>
+	 * A variable entry allows to express indirect references on a classpath to other projects or libraries,
+	 * depending on what the classpath variable is referring.
+	 * </p>
+	 * <p>
+	 * It is possible to register an automatic initializer (<code>ClasspathVariableInitializer</code>),
+	 * which will be invoked through the extension point "org.eclipse.jdt.core.classpathVariableInitializer".
+	 * After resolution, a classpath variable entry may either correspond to a project or a library entry.
+	 * </p>
+	 * <p>
+	 * e.g. Here are some examples of variable path usage
+	 * </p>
+	 * <ul>
+	 * <li> "JDTCORE" where variable <code>JDTCORE</code> is
+	 *		bound to "c:/jars/jdtcore.jar". The resolved classpath entry is denoting the library "c:\jars\jdtcore.jar"</li>
+	 * <li> "JDTCORE" where variable <code>JDTCORE</code> is
+	 *		bound to "/Project_JDTCORE". The resolved classpath entry is denoting the project "/Project_JDTCORE"</li>
+	 * <li> "PLUGINS/com.example/example.jar" where variable <code>PLUGINS</code>
+	 *      is bound to "c:/eclipse/plugins". The resolved classpath entry is denoting the library "c:\eclipse\plugins\com.example\example.jar"</li>
+	 * </ul>
+	 * <p>
+	 * The access rules determine the set of accessible class files
+	 * in the project or library. If the list of access rules is empty then all files
+	 * in this project or library are accessible.
+	 * See {@link IAccessRule} for a detailed description of access rules.
+	 * </p>
+	 * <p>
+	 * The <code>extraAttributes</code> list contains name/value pairs that must be persisted with
+	 * this entry. If no extra attributes are provided, an empty array must be passed in.<br>
+	 * Note that this list should not contain any duplicate name.
+	 * </p>
+	 * <p>
+	 * The <code>isExported</code> flag indicates whether this entry is contributed to dependent
+	 * projects. If not exported, dependent projects will not see any of the classes from this entry.
+	 * If exported, dependent projects will concatenate the accessible files patterns of this entry with the
+	 * accessible files patterns of the projects, and they will concatenate the non accessible files patterns of this entry
+	 * with the non accessible files patterns of the project.
+	 * </p>
+	 * <p>
+	 * Note that this operation does not attempt to validate classpath variables
+	 * or access the resources at the given paths.
+	 * </p>
+	 *
+	 * @param variablePath the path of the binary archive; first segment is the
+	 *   name of a classpath variable
+	 * @param variableSourceAttachmentPath the path of the corresponding source archive,
+	 *    or <code>null</code> if none; if present, the first segment is the
+	 *    name of a classpath variable (not necessarily the same variable
+	 *    as the one that begins <code>variablePath</code>)
+	 * @param variableSourceAttachmentRootPath the location of the root of the source files within the source archive
+	 *    or <code>null</code> if <code>variableSourceAttachmentPath</code> is also <code>null</code>
+	 * @param externalAnnotationPath the location where external annotations are found for annotation based null analysis
+	 * @param accessRules the possibly empty list of access rules for this entry
+	 * @param extraAttributes the possibly empty list of extra attributes to persist with this entry
+	 * @param isExported indicates whether this entry is contributed to dependent
+	 * 	  projects in addition to the output location
+	 * @return a new variable classpath entry
+	 * @since 3.11
+	 */
+	public static IClasspathEntry newVariableEntry(
+			IPath variablePath,
+			IPath variableSourceAttachmentPath,
+			IPath variableSourceAttachmentRootPath,
+			IPath externalAnnotationPath, 
+			IAccessRule[] accessRules, 
+			IClasspathAttribute[] extraAttributes,
+			boolean isExported) {
 
 		if (variablePath == null) throw new ClasspathEntry.AssertionFailedException("Variable path cannot be null"); //$NON-NLS-1$
 		if (variablePath.segmentCount() < 1) {
@@ -5165,13 +5325,14 @@ public final class JavaCore extends Plugin {
 			ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 			variableSourceAttachmentPath, // source attachment
 			variableSourceAttachmentRootPath, // source attachment root
+			externalAnnotationPath,
 			null, // specific output folder
 			isExported,
 			accessRules,
 			false, // no access rules to combine
 			extraAttributes);
 	}
-	
+
 	/**
 	 * Returns an array of classpath entries that are referenced directly or indirectly 
 	 * by a given classpath entry. For the entry kind {@link IClasspathEntry#CPE_LIBRARY}, 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
index af3a661..a97b3ee 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,6 +9,8 @@
  *     IBM Corporation - initial API and implementation
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425
  *     Thirumala Reddy Mutchukota <thirumala@google.com> - Avoid optional library classpath entries validation - https://bugs.eclipse.org/bugs/show_bug.cgi?id=412882
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
@@ -86,6 +88,7 @@ public class ClasspathEntry implements IClasspathEntry {
 	public static final String TAG_OUTPUT = "output"; //$NON-NLS-1$
 	public static final String TAG_KIND = "kind"; //$NON-NLS-1$
 	public static final String TAG_PATH = "path"; //$NON-NLS-1$
+	public static final String TAG_ANNOTATION_PATH = "annotationpath"; //$NON-NLS-1$
 	public static final String TAG_SOURCEPATH = "sourcepath"; //$NON-NLS-1$
 	public static final String TAG_ROOTPATH = "rootpath"; //$NON-NLS-1$
 	public static final String TAG_EXPORTED = "exported"; //$NON-NLS-1$
@@ -139,6 +142,8 @@ public class ClasspathEntry implements IClasspathEntry {
 	 */
 	public IPath path;
 
+	private IPath externalAnnotationPath;
+
 	/**
 	 * Patterns allowing to include/exclude portions of the resource tree denoted by this entry path.
 	 */
@@ -239,6 +244,7 @@ public class ClasspathEntry implements IClasspathEntry {
 			IPath[] exclusionPatterns,
 			IPath sourceAttachmentPath,
 			IPath sourceAttachmentRootPath,
+			IPath externalAnnotationPath,
 			IPath specificOutputLocation,
 			boolean isExported,
 			IAccessRule[] accessRules,
@@ -252,6 +258,7 @@ public class ClasspathEntry implements IClasspathEntry {
 				exclusionPatterns, 
 				sourceAttachmentPath, 
 				sourceAttachmentRootPath, 
+				externalAnnotationPath,
 				specificOutputLocation,
 				null,
 				isExported,
@@ -271,6 +278,7 @@ public class ClasspathEntry implements IClasspathEntry {
 		IPath[] exclusionPatterns,
 		IPath sourceAttachmentPath,
 		IPath sourceAttachmentRootPath,
+		IPath externalAnnotationPath,
 		IPath specificOutputLocation,
 		IClasspathEntry referencingEntry,
 		boolean isExported,
@@ -321,6 +329,7 @@ public class ClasspathEntry implements IClasspathEntry {
 	    }
 		this.sourceAttachmentPath = sourceAttachmentPath;
 		this.sourceAttachmentRootPath = sourceAttachmentRootPath;
+		this.externalAnnotationPath = externalAnnotationPath;
 		this.specificOutputLocation = specificOutputLocation;
 		this.isExported = isExported;
 	}
@@ -344,6 +353,7 @@ public class ClasspathEntry implements IClasspathEntry {
 								this.exclusionPatterns,
 								getSourceAttachmentPath(),
 								getSourceAttachmentRootPath(),
+								getExternalAnnotationPath(),
 								getOutputLocation(),
 								referringEntry.isExported() || this.isExported, // duplicate container entry for tagging it as exported
 								combine(referringEntry.getAccessRules(), getAccessRules(), combine),
@@ -566,6 +576,9 @@ public class ClasspathEntry implements IClasspathEntry {
 		if (this.sourceAttachmentRootPath != null) {
 			parameters.put(TAG_ROOTPATH, String.valueOf(this.sourceAttachmentRootPath));
 		}
+		if (this.externalAnnotationPath != null) {
+			parameters.put(TAG_ANNOTATION_PATH, String.valueOf(this.externalAnnotationPath));
+		}
 		if (this.isExported) {
 			parameters.put(TAG_EXPORTED, "true");//$NON-NLS-1$
 		}
@@ -678,6 +691,7 @@ public class ClasspathEntry implements IClasspathEntry {
 		boolean[] foundChildren = new boolean[children.getLength()];
 		String kindAttr = removeAttribute(TAG_KIND, attributes);
 		String pathAttr = removeAttribute(TAG_PATH, attributes);
+		String annotationPathAttr = removeAttribute(TAG_ANNOTATION_PATH, attributes);
 
 		// ensure path is absolute
 		IPath path = new Path(pathAttr);
@@ -687,6 +701,12 @@ public class ClasspathEntry implements IClasspathEntry {
 				path = projectPath.append(path);
 			}
 		}
+		IPath annotationPath = annotationPathAttr.isEmpty() ? null : new Path(annotationPathAttr);
+		if (annotationPath != null && !annotationPath.isAbsolute()) {
+			if (!(annotationPath.segmentCount() > 0 && annotationPath.segment(0).equals(ClasspathEntry.DOT_DOT))) {
+				annotationPath = project.getProject().getLocation().append(annotationPath);
+			}
+		}
 		// source attachment info (optional)
 		IPath sourceAttachmentPath =
 			element.hasAttribute(TAG_SOURCEPATH)
@@ -772,6 +792,7 @@ public class ClasspathEntry implements IClasspathEntry {
 												ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 												null, // source attachment
 												null, // source attachment root
+												null, // external annotation path
 												null, // specific output folder
 												isExported,
 												accessRules,
@@ -843,6 +864,7 @@ public class ClasspathEntry implements IClasspathEntry {
 												EXCLUDE_NONE,
 												null, // source attachment
 												null, // source attachment root
+												null, // external annotation path
 												null, // custom output location
 												false,
 												null, // no access rules
@@ -860,6 +882,8 @@ public class ClasspathEntry implements IClasspathEntry {
 			unknownElements.put(path, unknownXmlElements);
 		}
 
+		if (entry instanceof ClasspathEntry && kind != ClasspathEntry.K_OUTPUT && annotationPath != null)
+			((ClasspathEntry)entry).externalAnnotationPath = annotationPath;
 		return entry;
 	}
 	
@@ -1245,6 +1269,13 @@ public class ClasspathEntry implements IClasspathEntry {
 		return this.sourceAttachmentRootPath;
 	}
 
+	/**
+	 * @see IClasspathEntry
+	 */
+	public IPath getExternalAnnotationPath() {
+		return this.externalAnnotationPath;
+	}
+
 
 	public IClasspathEntry getReferencingEntry() {
 		return this.referencingEntry;
@@ -1394,6 +1425,11 @@ public class ClasspathEntry implements IClasspathEntry {
 			buffer.append(getSourceAttachmentRootPath());
 			buffer.append(']');
 		}
+		if (getExternalAnnotationPath() != null) {
+			buffer.append("[annotationPath:"); //$NON-NLS-1$
+			buffer.append(getExternalAnnotationPath());
+			buffer.append(']');
+		}
 		buffer.append("[isExported:"); //$NON-NLS-1$
 		buffer.append(this.isExported);
 		buffer.append(']');
@@ -1460,6 +1496,7 @@ public class ClasspathEntry implements IClasspathEntry {
 							this.exclusionPatterns,
 							getSourceAttachmentPath(),
 							getSourceAttachmentRootPath(),
+							getExternalAnnotationPath(),
 							getOutputLocation(),
 							this.getReferencingEntry(),
 							this.isExported,
@@ -1488,6 +1525,7 @@ public class ClasspathEntry implements IClasspathEntry {
 					this.exclusionPatterns,
 					null,
 					null,
+					null,
 					getOutputLocation(),
 					this,
 					this.isExported,
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index 30bc98a..d3525dd 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -10,7 +10,9 @@
  *     Theodora Yeung (tyeung@bea.com) - ensure that JarPackageFragmentRoot make it into cache
  *                                                           before its contents
  *                                                           (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=102422)
- *     Stephan Herrmann - Contribution for Bug 346010 - [model] strange initialization dependency in OptionTests
+ *     Stephan Herrmann - Contribution for
+ *								Bug 346010 - [model] strange initialization dependency in OptionTests
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425
  *     Thirumala Reddy Mutchukota <thirumala@google.com> - Contribution to bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=411423
  *     Terry Parker <tparker@google.com> - [performance] Low hit rates in JavaModel caches - https://bugs.eclipse.org/421165
@@ -2556,6 +2558,8 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 						resolvedPath,
 						getResolvedVariablePath(entry.getSourceAttachmentPath(), usePreviousSession),
 						getResolvedVariablePath(entry.getSourceAttachmentRootPath(), usePreviousSession),
+						entry.getExternalAnnotationPath(),
+//TODO:var resolving?	getResolvedVariablePath(entry.getAnnotationPath(), usePreviousSession),
 						entry.getAccessRules(),
 						entry.getExtraAttributes(),
 						entry.isExported());
@@ -2566,6 +2570,8 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 							resolvedPath,
 							getResolvedVariablePath(entry.getSourceAttachmentPath(), usePreviousSession),
 							getResolvedVariablePath(entry.getSourceAttachmentRootPath(), usePreviousSession),
+							entry.getExternalAnnotationPath(),
+//TODO:var resolving?		getResolvedVariablePath(entry.getAnnotationPath(), usePreviousSession),
 							entry.getAccessRules(),
 							entry.getExtraAttributes(),
 							entry.isExported());
@@ -3556,7 +3562,7 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 
 			IClasspathEntry entry = new ClasspathEntry(contentKind, entryKind,
 					path, inclusionPatterns, exclusionPatterns,
-					sourceAttachmentPath, sourceAttachmentRootPath,
+					sourceAttachmentPath, sourceAttachmentRootPath, null, // FIXME(SH): persistent external annotation location
 					specificOutputLocation, isExported, accessRules,
 					combineAccessRules, extraAttributes);
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 47e3e8f..c13ec95 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,12 +8,21 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Tal Lev-Ami - added package cache for zip files
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
-import org.eclipse.core.resources.IFile;
-import org.eclipse.core.runtime.*;
+import java.io.File;
+import java.io.IOException;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
 
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
@@ -23,13 +32,11 @@ import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.util.Util;
 
-import java.io.*;
-import java.util.*;
-import java.util.zip.*;
-
 @SuppressWarnings("rawtypes")
 public class ClasspathJar extends ClasspathLocation {
 
+private static final String ANNOTATION_FILE_SUFFIX = ".eea"; //$NON-NLS-1$ // FIXME(SH): define file extension
+
 static class PackageCacheEntry {
 	long lastModified;
 	long fileSize;
@@ -85,8 +92,9 @@ long lastModified;
 boolean closeZipFileAtEnd;
 SimpleSet knownPackageNames;
 AccessRuleSet accessRuleSet;
+String externalAnnotationDir;
 
-ClasspathJar(IFile resource, AccessRuleSet accessRuleSet) {
+ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
 	this.resource = resource;
 	try {
 		java.net.URI location = resource.getLocationURI();
@@ -102,22 +110,28 @@ ClasspathJar(IFile resource, AccessRuleSet accessRuleSet) {
 	this.zipFile = null;
 	this.knownPackageNames = null;
 	this.accessRuleSet = accessRuleSet;
+	if (externalAnnotationPath != null)
+		this.externalAnnotationDir = externalAnnotationPath.toString();
 }
 
-ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet) {
+ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
 	this.zipFilename = zipFilename;
 	this.lastModified = lastModified;
 	this.zipFile = null;
 	this.knownPackageNames = null;
 	this.accessRuleSet = accessRuleSet;
+	if (externalAnnotationPath != null)
+		this.externalAnnotationDir = externalAnnotationPath.toString();
 }
 
-public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet) {
+public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
 	this.zipFilename = zipFile.getName();
 	this.zipFile = zipFile;
 	this.closeZipFileAtEnd = false;
 	this.knownPackageNames = null;
 	this.accessRuleSet = accessRuleSet;
+	if (externalAnnotationPath != null)
+		this.externalAnnotationDir = externalAnnotationPath.toString();
 }
 
 public void cleanup() {
@@ -148,6 +162,8 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 	try {
 		ClassFileReader reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
 		if (reader != null) {
+			if (this.externalAnnotationDir != null)
+				setExternalAnnotationProvider(reader);
 			if (this.accessRuleSet == null)
 				return new NameEnvironmentAnswer(reader, null);
 			String fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);
@@ -159,6 +175,18 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 	return null;
 }
 
+private void setExternalAnnotationProvider(ClassFileReader reader) {
+	File annotFile = new File(this.externalAnnotationDir+File.separatorChar+String.valueOf(reader.getName())+ANNOTATION_FILE_SUFFIX);
+	if (annotFile.exists()) {
+		try {
+			reader.setAnnotationProvider(annotFile);
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+}
+
 public IPath getProjectRelativePath() {
 	if (this.resource == null) return null;
 	return	this.resource.getProjectRelativePath();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
index aef33e1..d20f0a8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
@@ -26,16 +28,16 @@ public static ClasspathLocation forBinaryFolder(IContainer binaryFolder, boolean
 	return new ClasspathDirectory(binaryFolder, isOutputFolder, accessRuleSet);
 }
 
-static ClasspathLocation forLibrary(String libraryPathname, long lastModified, AccessRuleSet accessRuleSet) {
-	return new ClasspathJar(libraryPathname, lastModified, accessRuleSet);
+static ClasspathLocation forLibrary(String libraryPathname, long lastModified, AccessRuleSet accessRuleSet, IPath annotationsPath) {
+	return new ClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath);
 }
 
-static ClasspathLocation forLibrary(String libraryPathname, AccessRuleSet accessRuleSet) {
-	return forLibrary(libraryPathname, 0, accessRuleSet);
+static ClasspathLocation forLibrary(String libraryPathname, AccessRuleSet accessRuleSet, IPath annotationsPath) {
+	return forLibrary(libraryPathname, 0, accessRuleSet, annotationsPath);
 }
 
-static ClasspathLocation forLibrary(IFile library, AccessRuleSet accessRuleSet) {
-	return new ClasspathJar(library, accessRuleSet);
+static ClasspathLocation forLibrary(IFile library, AccessRuleSet accessRuleSet, IPath annotationsPath) {
+	return new ClasspathJar(library, accessRuleSet, annotationsPath);
 }
 
 public abstract NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String qualifiedBinaryFileName);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index a3dc10a..6ad6ba2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *           -  Another problem with inner classes referenced from jars or class folders: "The type ... cannot be resolved"
  *     Stephan Herrmann - Contribution for
  *								Bug 392727 - Cannot compile project when a java file contains $ in its file name
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
@@ -103,6 +104,7 @@ private void computeClasspathLocations(
 		ClasspathEntry entry = (ClasspathEntry) classpathEntries[i];
 		IPath path = entry.getPath();
 		Object target = JavaModel.getTarget(path, true);
+		IPath externalAnnotationPath = entry.getExternalAnnotationPath();
 		if (target == null) continue nextEntry;
 
 		switch(entry.getEntryKind()) {
@@ -172,7 +174,7 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-						bLocation = ClasspathLocation.forLibrary((IFile) resource, accessRuleSet);
+						bLocation = ClasspathLocation.forLibrary((IFile) resource, accessRuleSet, externalAnnotationPath);
 					} else if (resource instanceof IContainer) {
 						AccessRuleSet accessRuleSet =
 							(JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE, true))
@@ -200,7 +202,7 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-					bLocations.add(ClasspathLocation.forLibrary(path.toString(), accessRuleSet));
+					bLocations.add(ClasspathLocation.forLibrary(path.toString(), accessRuleSet, externalAnnotationPath));
 				}
 				continue nextEntry;
 		}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
index 30cb7db..6a5a293 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
@@ -269,10 +271,10 @@ static State read(IProject project, DataInputStream in) throws IOException {
 				newState.binaryLocations[i] = ClasspathLocation.forBinaryFolder(outputFolder, in.readBoolean(), readRestriction(in));
 				break;
 			case EXTERNAL_JAR :
-				newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(), readRestriction(in));
+				newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(), readRestriction(in), null/*annotationsPath*/); // FIXME
 				break;
 			case INTERNAL_JAR :
-				newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())), readRestriction(in));
+				newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())), readRestriction(in), null/*annotationsPath*/); // FIXME
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index b0ba183..56c24d6 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.search.matching;
 
@@ -95,9 +97,10 @@ private void computeClasspathLocations(IWorkspaceRoot workspaceRoot, JavaProject
 		PackageFragmentRoot root = (PackageFragmentRoot) roots[i];
 		IPath path = root.getPath();
 		try {
+			ClasspathEntry classpathEntry = (ClasspathEntry) root.getRawClasspathEntry();
 			if (root.isArchive()) {
 				ZipFile zipFile = manager.getZipFile(path);
-				cpLocations[index++] = new ClasspathJar(zipFile, ((ClasspathEntry) root.getRawClasspathEntry()).getAccessRuleSet());
+				cpLocations[index++] = new ClasspathJar(zipFile, classpathEntry.getAccessRuleSet(), classpathEntry.getExternalAnnotationPath());
 			} else {
 				Object target = JavaModel.getTarget(path, true);
 				if (target == null) {
@@ -107,7 +110,7 @@ private void computeClasspathLocations(IWorkspaceRoot workspaceRoot, JavaProject
 				} else if (root.getKind() == IPackageFragmentRoot.K_SOURCE) {
 					cpLocations[index++] = new ClasspathSourceDirectory((IContainer)target, root.fullExclusionPatternChars(), root.fullInclusionPatternChars());
 				} else {
-					cpLocations[index++] = ClasspathLocation.forBinaryFolder((IContainer) target, false, ((ClasspathEntry) root.getRawClasspathEntry()).getAccessRuleSet());
+					cpLocations[index++] = ClasspathLocation.forBinaryFolder((IContainer) target, false, classpathEntry.getAccessRuleSet());
 				}
 			}
 		} catch (CoreException e1) {
commit 48a2d2499344bebca223a2f8c964ed5900cd0012
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sat Jul 26 20:30:05 2014 +0200

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - support reconciler by feeding annot-path through IPackageFragmentRoot

2	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
33	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java
16	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
4	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
40	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
1	15	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
index b72b78a..a9b362c 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
@@ -53,7 +53,7 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 	static {
 		// Names of tests to run: can be "testBugXXXX" or "BugXXXX")
 //		TESTS_PREFIX = "testClasspathDuplicateExtraAttribute";
-//		TESTS_NAMES = new String[] {"testClasspathValidation42"};
+//		TESTS_NAMES = new String[] {"test2"};
 //		TESTS_NUMBERS = new int[] { 23, 28, 38 };
 //		TESTS_RANGE = new int[] { 21, 38 };
 	}
@@ -129,7 +129,7 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 	}
 	
 	/** Reconcile an individual CU. */ // FIXME: needs more capability in SearchableNameEnvironment
-	public void _test2() throws CoreException, InterruptedException {
+	public void test2() throws CoreException, InterruptedException {
 		IPackageFragment fragment = this.root.getPackageFragment("test1");
 		ICompilationUnit unit = fragment.getCompilationUnit("Test1.java").getWorkingCopy(new NullProgressMonitor());
 		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index c728752..54a09a7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -16,10 +16,12 @@
 package org.eclipse.jdt.internal.compiler.classfmt;
 
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Arrays;
 
+import org.eclipse.core.runtime.IPath;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants;
 import org.eclipse.jdt.internal.compiler.env.*;
@@ -401,9 +403,38 @@ public ClassFileReader(byte[] classFileBytes, char[] fileName, boolean fullyInit
 	}
 }
 
+/**
+ * @param classFileBytes byte[]
+ * 		Actual bytes of a .class file
+ *
+ * @param fileName char[]
+ * 		Actual name of the file that contains the bytes, can be null
+ *
+ * @param fullyInitialize boolean
+ * 		Flag to fully initialize the new object
+ * 
+ * @param externalAnnotationPath
+ * 		Path to external annotations as used for null analysis
+ * 
+ * @exception ClassFormatException
+ */
+public ClassFileReader(byte[] classFileBytes, char[] fileName, boolean fullyInitialize, IPath externalAnnotationPath) throws ClassFormatException {
+	this(classFileBytes, fileName, fullyInitialize);
+	if (externalAnnotationPath != null)
+		setExternalAnnotationProvider(externalAnnotationPath.toString());
+}
+
 /** Create and remember a provider for external annotations using the given text file. */
-public void setAnnotationProvider(File annotFile) throws IOException {
-	this.annotationProvider = new ExternalAnnotationProvider(annotFile);
+public void setExternalAnnotationProvider(String externalAnnotationDir) {
+	File annotFile = new File(externalAnnotationDir+File.separatorChar+String.valueOf(getName())+IExternalAnnotationProvider.ANNOTATION_FILE_SUFFIX);
+	try {
+		this.annotationProvider = new ExternalAnnotationProvider(annotFile);
+	} catch (FileNotFoundException e) {
+		// silent
+	} catch (IOException e) {
+		// TODO Auto-generated catch block
+		e.printStackTrace();
+	}
 }
 
 /** If a provider for external annotations has been registered try to retrieve an annotation walker for the given method. */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
index f430256..1a11430 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -13,6 +13,7 @@ package org.eclipse.jdt.internal.compiler.classfmt;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.util.HashMap;
@@ -31,6 +32,7 @@ public class ExternalAnnotationProvider implements IExternalAnnotationProvider {
 	private Map<String,String> methodAnnotationSources;
 	
 	public ExternalAnnotationProvider(File annotationSource) throws IOException {
+		if (!annotationSource.exists()) throw new FileNotFoundException(annotationSource.getAbsolutePath());
 		this.annotationSource = annotationSource;
 		this.methodAnnotationSources = new HashMap<String, String>();
 		initialize();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java
index 05a0241..a9e596b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java
@@ -15,6 +15,8 @@ import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 /** An instance of of this type answers external annotations for the methods and fields of a given class. */
 public interface IExternalAnnotationProvider {
 	
+	String ANNOTATION_FILE_SUFFIX = ".eea"; //$NON-NLS-1$ // FIXME(SH): define file extension
+
 	ITypeAnnotationWalker forMethod(char[] selector, char[] signature, LookupEnvironment environment);
 
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
index c1ed588..320dafa 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,6 +15,8 @@
  *     IBM Corporation - added NO_RESOURCE_MODIFICATION
  *     IBM Corporation - added REPLACE
  *     IBM Corporation - added ORIGINATING_PROJECT_CLASSPATH
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.core;
 
@@ -350,6 +352,19 @@ public interface IPackageFragmentRoot
 	IPath getSourceAttachmentRootPath() throws JavaModelException;
 
 	/**
+	 * Returns the absolute path to the location where external annotations can be
+	 * found to support annotation based null analysis involving 3rd party libraries.
+	 * 
+	 * @return the absolute path to the corresponding external annotations,
+	 *   or <code>null</code> if this package fragment root's binary archive
+	 *   has no corresponding external annotations, or if this package fragment root
+	 *   is not a binary archive
+	 * @exception JavaModelException if this operation fails
+	 * @since 3.11
+	 */
+	IPath getExternalAnnotationPath() throws JavaModelException;
+	
+	/**
 	 * Returns whether this package fragment root's underlying
 	 * resource is a binary archive (a JAR or zip file).
 	 * <p>
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index fde3a86..b94678e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
@@ -347,7 +349,7 @@ private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyIniti
 		if (ze != null) {
 			byte contents[] = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
 			String fileName = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
-			return new ClassFileReader(contents, fileName.toCharArray(), fullyInitialize);
+			return new ClassFileReader(contents, fileName.toCharArray(), fullyInitialize, root.getExternalAnnotationPath());
 		}
 	} finally {
 		JavaModelManager.getJavaModelManager().closeZipFile(zip);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index beba74d..4412328 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
@@ -629,6 +631,44 @@ public IPath getSourceAttachmentPath() throws JavaModelException {
 }
 
 /**
+ * @see IPackageFragmentRoot
+ */
+public IPath getExternalAnnotationPath() throws JavaModelException {
+	if (getKind() != K_BINARY) return null;
+
+	// partially modeled after getSourceAttachmentPath()
+/*
+	// 1) look source attachment property (set iff attachSource(...) was called
+	IPath path = getPath();
+	String serverPathString= Util.getSourceAttachmentProperty(path);
+	if (serverPathString != null) {
+		int index= serverPathString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER);
+		if (index < 0) {
+			// no root path specified
+			return new Path(serverPathString);
+		} else {
+			String serverSourcePathString= serverPathString.substring(0, index);
+			return new Path(serverSourcePathString);
+		}
+	}
+*/
+	
+	// 2) look at classpath entry
+	IClasspathEntry entry = ((JavaProject) getParent()).getClasspathEntryFor(getPath());
+	IPath externalAnnotationPath;
+	if (entry != null && (externalAnnotationPath = entry.getExternalAnnotationPath()) != null)
+		return externalAnnotationPath;
+/*
+	// 3) look for a recommendation
+	entry = findSourceAttachmentRecommendation();
+	if (entry != null && (externalAnnotationPath = entry.getSourceAttachmentPath()) != null) {
+		return externalAnnotationPath;
+	}
+*/
+	return null;
+}
+
+/**
  * For use by <code>AttachSourceOperation</code> only.
  * Sets the source mapper associated with this root.
  */
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index c13ec95..7cb730a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -35,8 +35,6 @@ import org.eclipse.jdt.internal.core.util.Util;
 @SuppressWarnings("rawtypes")
 public class ClasspathJar extends ClasspathLocation {
 
-private static final String ANNOTATION_FILE_SUFFIX = ".eea"; //$NON-NLS-1$ // FIXME(SH): define file extension
-
 static class PackageCacheEntry {
 	long lastModified;
 	long fileSize;
@@ -163,7 +161,7 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 		ClassFileReader reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
 		if (reader != null) {
 			if (this.externalAnnotationDir != null)
-				setExternalAnnotationProvider(reader);
+				reader.setExternalAnnotationProvider(this.externalAnnotationDir);
 			if (this.accessRuleSet == null)
 				return new NameEnvironmentAnswer(reader, null);
 			String fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);
@@ -175,18 +173,6 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 	return null;
 }
 
-private void setExternalAnnotationProvider(ClassFileReader reader) {
-	File annotFile = new File(this.externalAnnotationDir+File.separatorChar+String.valueOf(reader.getName())+ANNOTATION_FILE_SUFFIX);
-	if (annotFile.exists()) {
-		try {
-			reader.setAnnotationProvider(annotFile);
-		} catch (IOException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-	}
-}
-
 public IPath getProjectRelativePath() {
 	if (this.resource == null) return null;
 	return	this.resource.getProjectRelativePath();
commit 6c085192f8ca1a30dcc3f8eecf0c1b2085d19f7e
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Jul 27 00:00:31 2014 +0200

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - support real JRE *container*, combining entries with referrer
    - persist & restore annotation path in State (& incremented VERSION).

-	-	org.eclipse.jdt.core.tests.model/JCL/jclMin1.8.jar
-	-	org.eclipse.jdt.core.tests.model/JCL/jclMin1.8src.zip
2	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
53	11	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
0	6	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.classpath
0	17	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.project
6	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath
17	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project
5	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea
13	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java
8	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath
17	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project
5	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
13	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java
0	4	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/annots/java/util/Collection.eea
0	13	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/src/test1/Test1.java
87	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
5	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
4	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
diff --git a/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8.jar b/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8.jar
index 2b78416..e412b3a 100644
Binary files a/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8.jar and b/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8.jar differ
diff --git a/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8src.zip b/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8src.zip
index 0757f3a..3105da0 100644
Binary files a/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8src.zip and b/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8src.zip differ
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
index 2048e88..d8a08c7 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
@@ -193,6 +193,8 @@ private static Class[] getAllTestClasses() {
 		
 		// Tests regarding null-annotations:
 		NullAnnotationModelTests.class,
+		ExternalAnnotations18Test.class,
+
 		// Java model changes related to Java 8
 		JavaElement8Tests.class,
 	};
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
index a9b362c..2a1c0f5 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
@@ -11,11 +11,15 @@
 package org.eclipse.jdt.core.tests.model;
 
 import java.io.File;
+import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URL;
+import java.util.Hashtable;
 import java.util.Map;
 
+import junit.framework.Test;
+
 import org.eclipse.core.resources.IMarker;
 import org.eclipse.core.resources.IResource;
 import org.eclipse.core.resources.IncrementalProjectBuilder;
@@ -36,8 +40,6 @@ import org.eclipse.jdt.core.dom.AST;
 import org.eclipse.jdt.core.dom.CompilationUnit;
 import org.osgi.framework.Bundle;
 
-import junit.framework.Test;
-
 public class ExternalAnnotations18Test extends ModifyingResourceTests {
 
 	private IJavaProject project;
@@ -53,7 +55,7 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 	static {
 		// Names of tests to run: can be "testBugXXXX" or "BugXXXX")
 //		TESTS_PREFIX = "testClasspathDuplicateExtraAttribute";
-//		TESTS_NAMES = new String[] {"test2"};
+//		TESTS_NAMES = new String[] {"test3"};
 //		TESTS_NUMBERS = new int[] { 23, 28, 38 };
 //		TESTS_RANGE = new int[] { 21, 38 };
 	}
@@ -70,8 +72,15 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 		Bundle[] bundles = org.eclipse.jdt.core.tests.Activator.getPackageAdmin().getBundles("org.eclipse.jdt.annotation", "[2.0.0,3.0.0)");
 		File bundleFile = FileLocator.getBundleFile(bundles[0]);
 		this.ANNOTATION_LIB = bundleFile.isDirectory() ? bundleFile.getPath()+"/bin" : bundleFile.getPath();
+	}
+	
+	public String getSourceWorkspacePath() {
+		// we read individual projects from within this folder:
+		return super.getSourceWorkspacePath()+"/ExternalAnnotations18";
+	}
 
-		this.project = setUpJavaProject("ExternalAnnotations18", "1.8"); //$NON-NLS-1$
+	void setupJavaProject(String name) throws CoreException, IOException {
+		this.project = setUpJavaProject(name, "1.8"); //$NON-NLS-1$
 		addLibraryEntry(this.project, this.ANNOTATION_LIB, false);
 		Map options = this.project.getOptions(true);
 		options.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
@@ -91,7 +100,12 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 		}
 		assertEquals("Wrong value", 1, count); //$NON-NLS-1$
 		assertNotNull("Should not be null", this.root); //$NON-NLS-1$
-
+	}
+	
+	protected void tearDown() throws Exception {
+		this.project.getProject().delete(true, true, null);
+		this.project = null;
+		super.tearDown();
 	}
 	
 	// TODO: using this copy from AttachedJavadocTests test also programmatically setting the external annotation location:
@@ -120,20 +134,48 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 		}
 		this.project.setRawClasspath(entries, null);
 	}
+
+	private void assertNoMarkers(IMarker[] markers) throws CoreException {
+		for (int i = 0; i < markers.length; i++)
+			System.err.println("Unexpected marker: "+markers[i].getAttributes().entrySet());
+		assertEquals("Number of markers", 0, markers.length);
+	}
 	
+	private void assertNoProblems(IProblem[] problems) throws CoreException {
+		for (int i = 0; i < problems.length; i++)
+			System.err.println("Unexpected marker: "+problems[i]);
+		assertEquals("Number of markers", 0, problems.length);
+	}
+
 	/** Perform full build. */
-	public void test1() throws CoreException, InterruptedException {
+	public void test1FullBuild() throws Exception {
+		setupJavaProject("Test1");
 		this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
 		IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
-		assertEquals("Number of markers", 0, markers.length);
+		assertNoMarkers(markers);
 	}
-	
-	/** Reconcile an individual CU. */ // FIXME: needs more capability in SearchableNameEnvironment
-	public void test2() throws CoreException, InterruptedException {
+
+	/** Reconcile an individual CU. */
+	public void test1Reconcile() throws Exception {
+		setupJavaProject("Test1");
 		IPackageFragment fragment = this.root.getPackageFragment("test1");
 		ICompilationUnit unit = fragment.getCompilationUnit("Test1.java").getWorkingCopy(new NullProgressMonitor());
 		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
 		IProblem[] problems = reconciled.getProblems();
-		assertEquals("Number of problems", 0, problems.length);
+		assertNoProblems(problems);
+	}
+
+	/** Project with real JRE8. */
+	public void test2() throws Exception {
+		Hashtable options = JavaCore.getOptions();
+		try {
+			setupJavaProject("Test2");
+			this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
+			assertNoMarkers(markers);
+		} finally {
+			// project using a full JRE container initializes global options to 1.8 -- must reset now:
+			JavaCore.setOptions(options);
+		}
 	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.classpath
deleted file mode 100644
index 8c0b66a..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.classpath
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="var" path="JCL18_LIB" annotationpath="annots"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.project
deleted file mode 100644
index 1271329..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>ExternalAnnotations18</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath
new file mode 100644
index 0000000..8c0b66a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="var" path="JCL18_LIB" annotationpath="annots"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project
new file mode 100644
index 0000000..bd0683a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Test1</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea
new file mode 100644
index 0000000..6699601
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea
@@ -0,0 +1,5 @@
+class <K:V:>Map
+
+get(Ljava/lang/Object;)TV;=get(Ljava/lang/Object;)T0V;
+put(TK;TV;)TV;=put(TK;TV;)T0V;
+remove(Ljava/lang/Object;)TV;=remove(Ljava/lang/Object;)T0V;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java
new file mode 100644
index 0000000..e483874
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java
@@ -0,0 +1,13 @@
+package test1;
+
+import java.util.Map;
+import org.eclipse.jdt.annotation.*;
+
+@NonNullByDefault
+public class Test1 {
+	void test(Map<String,Test1> map, String key) {
+		Test1 v = map.get(key);
+		if (v == null)
+			throw new RuntimeException(); // should not be reported as dead code, although V is a '@NonNull Test1'
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath
new file mode 100644
index 0000000..51499da
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" 
+			path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8" 
+			annotationpath="annots"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project
new file mode 100644
index 0000000..1b369ff
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Test2</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
new file mode 100644
index 0000000..6699601
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
@@ -0,0 +1,5 @@
+class <K:V:>Map
+
+get(Ljava/lang/Object;)TV;=get(Ljava/lang/Object;)T0V;
+put(TK;TV;)TV;=put(TK;TV;)T0V;
+remove(Ljava/lang/Object;)TV;=remove(Ljava/lang/Object;)T0V;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java
new file mode 100644
index 0000000..e483874
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java
@@ -0,0 +1,13 @@
+package test1;
+
+import java.util.Map;
+import org.eclipse.jdt.annotation.*;
+
+@NonNullByDefault
+public class Test1 {
+	void test(Map<String,Test1> map, String key) {
+		Test1 v = map.get(key);
+		if (v == null)
+			throw new RuntimeException(); // should not be reported as dead code, although V is a '@NonNull Test1'
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/annots/java/util/Collection.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/annots/java/util/Collection.eea
deleted file mode 100644
index 8415ab5..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/annots/java/util/Collection.eea
+++ /dev/null
@@ -1,4 +0,0 @@
-class <T:>Collection
-
-get(I)TT;=(I)T0T;
-iterator()Ljava.util.Iterator<TT;>;=iterator()L1java.util.Iterator<TT;>;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/src/test1/Test1.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/src/test1/Test1.java
deleted file mode 100644
index 558ab97..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/src/test1/Test1.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package test1;
-
-import java.util.Collection;
-import org.eclipse.jdt.annotation.*;
-
-@NonNullByDefault
-public class Test1 {
-	void test(Collection<String> map, int key) {
-		String v = map.get(key);
-		if (v == null)
-			throw new RuntimeException(); // should not be reported as dead code, although map is a Collection<@NonNull String>
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index b2da3e7..9d7f43a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -4452,6 +4452,92 @@ public final class JavaCore extends Plugin {
 			IAccessRule[] accessRules,
 			IClasspathAttribute[] extraAttributes,
 			boolean isExported) {
+		return newContainerEntry(containerPath, accessRules, null, extraAttributes, isExported);
+	}
+
+	/**
+	 * Creates and returns a new classpath entry of kind <code>CPE_CONTAINER</code>
+	 * for the given path. The path of the container will be used during resolution so as to map this
+	 * container entry to a set of other classpath entries the container is acting for.
+	 * <p>
+	 * A container entry allows to express indirect references to a set of libraries, projects and variable entries,
+	 * which can be interpreted differently for each Java project where it is used.
+	 * A classpath container entry can be resolved using <code>JavaCore.getResolvedClasspathContainer</code>,
+	 * and updated with <code>JavaCore.classpathContainerChanged</code>
+	 * </p>
+	 * <p>
+	 * A container is exclusively resolved by a <code>ClasspathContainerInitializer</code> registered onto the
+	 * extension point "org.eclipse.jdt.core.classpathContainerInitializer".
+	 * </p>
+	 * <p>
+	 * A container path must be formed of at least one segment, where:
+	 * </p>
+	 * <ul>
+	 * <li> the first segment is a unique ID identifying the target container, there must be a container initializer registered
+	 * 	onto this ID through the extension point  "org.eclipse.jdt.core.classpathContainerInitializer". </li>
+	 * <li> the remaining segments will be passed onto the initializer, and can be used as additional
+	 * 	hints during the initialization phase. </li>
+	 * </ul>
+	 * <p>
+	 * Example of an ClasspathContainerInitializer for a classpath container denoting a default JDK container:
+	 * </p>
+	 * <pre>
+	 * containerEntry = JavaCore.newContainerEntry(new Path("MyProvidedJDK/default"));
+	 *
+	 * &lt;extension
+	 *    point="org.eclipse.jdt.core.classpathContainerInitializer"&gt;
+	 *    &lt;containerInitializer
+	 *       id="MyProvidedJDK"
+	 *       class="com.example.MyInitializer"/&gt;
+	 * </pre>
+	 * <p>
+	 * The access rules determine the set of accessible source and class files
+	 * in the container. If the list of access rules is empty, then all files
+	 * in this container are accessible.
+	 * See {@link IAccessRule} for a detailed description of access
+	 * rules. Note that if an entry defined by the container defines access rules,
+	 * then these access rules are combined with the given access rules.
+	 * The given access rules are considered first, then the entry's access rules are
+	 * considered.
+	 * </p>
+	 * <p>
+	 * The <code>extraAttributes</code> list contains name/value pairs that must be persisted with
+	 * this entry. If no extra attributes are provided, an empty array must be passed in.<br>
+	 * Note that this list should not contain any duplicate name.
+	 * </p>
+	 * <p>
+	 * The <code>isExported</code> flag indicates whether this entry is contributed to dependent
+	 * projects. If not exported, dependent projects will not see any of the classes from this entry.
+	 * If exported, dependent projects will concatenate the accessible files patterns of this entry with the
+	 * accessible files patterns of the projects, and they will concatenate the non accessible files patterns of this entry
+	 * with the non accessible files patterns of the project.
+	 * </p>
+	 * <p>
+	 * Note that this operation does not attempt to validate classpath containers
+	 * or access the resources at the given paths.
+	 * </p>
+	 *
+	 * @param containerPath the path identifying the container, it must be formed of at least
+	 * 	one segment (ID+hints)
+	 * @param accessRules the possibly empty list of access rules for this entry
+	 * @param externalAnnotationPath the location where external annotations are found for annotation based null analysis
+	 * @param extraAttributes the possibly empty list of extra attributes to persist with this entry
+	 * @param isExported a boolean indicating whether this entry is contributed to dependent
+	 *    projects in addition to the output location
+	 * @return a new container classpath entry
+	 *
+	 * @see JavaCore#getClasspathContainer(IPath, IJavaProject)
+	 * @see JavaCore#setClasspathContainer(IPath, IJavaProject[], IClasspathContainer[], IProgressMonitor)
+	 * @see JavaCore#newContainerEntry(IPath, boolean)
+	 * @see JavaCore#newAccessRule(IPath, int)
+	 * @since 3.11
+	 */
+	public static IClasspathEntry newContainerEntry(
+			IPath containerPath,
+			IAccessRule[] accessRules,
+			IPath externalAnnotationPath,
+			IClasspathAttribute[] extraAttributes,
+			boolean isExported) {
 
 		if (containerPath == null) {
 			throw new ClasspathEntry.AssertionFailedException("Container path cannot be null"); //$NON-NLS-1$
@@ -4472,7 +4558,7 @@ public final class JavaCore extends Plugin {
 			ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 			null, // source attachment
 			null, // source attachment root
-			null, // external annotation path
+			externalAnnotationPath,
 			null, // specific output folder
 			isExported,
 			accessRules,
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
index a97b3ee..837d37c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
@@ -343,8 +343,11 @@ public class ClasspathEntry implements IClasspathEntry {
 	 */
 	public ClasspathEntry combineWith(ClasspathEntry referringEntry) {
 		if (referringEntry == null) return this;
-		if (referringEntry.isExported() || referringEntry.getAccessRuleSet() != null ) {
+		if (referringEntry.isExported() || referringEntry.getAccessRuleSet() != null || referringEntry.getExternalAnnotationPath() != null) {
 			boolean combine = this.entryKind == CPE_SOURCE || referringEntry.combineAccessRules();
+			IPath externalAnnotations = referringEntry.getExternalAnnotationPath(); // give precedence to this one
+			if (externalAnnotations == null)
+				externalAnnotations = getExternalAnnotationPath();
 			return new ClasspathEntry(
 								getContentKind(),
 								getEntryKind(),
@@ -353,7 +356,7 @@ public class ClasspathEntry implements IClasspathEntry {
 								this.exclusionPatterns,
 								getSourceAttachmentPath(),
 								getSourceAttachmentRootPath(),
-								getExternalAnnotationPath(),
+								externalAnnotations,
 								getOutputLocation(),
 								referringEntry.isExported() || this.isExported, // duplicate container entry for tagging it as exported
 								combine(referringEntry.getAccessRules(), getAccessRules(), combine),
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
index 6a5a293..90e9741 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
@@ -47,7 +47,7 @@ private long previousStructuralBuildTime;
 private StringSet structurallyChangedTypes;
 public static int MaxStructurallyChangedTypes = 100; // keep track of ? structurally changed types, otherwise consider all to be changed
 
-public static final byte VERSION = 0x001B;
+public static final byte VERSION = 0x001C;
 
 static final byte SOURCE_FOLDER = 1;
 static final byte BINARY_FOLDER = 2;
@@ -271,10 +271,10 @@ static State read(IProject project, DataInputStream in) throws IOException {
 				newState.binaryLocations[i] = ClasspathLocation.forBinaryFolder(outputFolder, in.readBoolean(), readRestriction(in));
 				break;
 			case EXTERNAL_JAR :
-				newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(), readRestriction(in), null/*annotationsPath*/); // FIXME
+				newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(), readRestriction(in), new Path(in.readUTF()));
 				break;
 			case INTERNAL_JAR :
-				newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())), readRestriction(in), null/*annotationsPath*/); // FIXME
+				newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())), readRestriction(in), new Path(in.readUTF()));
 		}
 	}
 
@@ -465,6 +465,7 @@ void write(DataOutputStream out) throws IOException {
 				out.writeUTF(jar.resource.getFullPath().toString());
 			}
 			writeRestriction(jar.accessRuleSet, out);
+			out.writeUTF(jar.externalAnnotationDir != null ? jar.externalAnnotationDir : ""); //$NON-NLS-1$
 		}
 	}
 
commit b1d9b2131096901775539a68eb3d7a7d50bc45d5
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Jul 27 01:54:31 2014 +0200

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - remove one interface that's not really used, and more minor cleanup

2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
6	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
0	22	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index 54a09a7..f950b82 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -62,7 +62,7 @@ public class ClassFileReader extends ClassFileStruct implements IBinaryType {
 	private char[][][] missingTypeNames;
 	private int enclosingNameAndTypeIndex;
 	private char[] enclosingMethod;
-	private IExternalAnnotationProvider annotationProvider;
+	private ExternalAnnotationProvider annotationProvider;
 
 private static String printTypeModifiers(int modifiers) {
 	java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream();
@@ -426,9 +426,8 @@ public ClassFileReader(byte[] classFileBytes, char[] fileName, boolean fullyInit
 
 /** Create and remember a provider for external annotations using the given text file. */
 public void setExternalAnnotationProvider(String externalAnnotationDir) {
-	File annotFile = new File(externalAnnotationDir+File.separatorChar+String.valueOf(getName())+IExternalAnnotationProvider.ANNOTATION_FILE_SUFFIX);
 	try {
-		this.annotationProvider = new ExternalAnnotationProvider(annotFile);
+		this.annotationProvider = new ExternalAnnotationProvider(externalAnnotationDir, String.valueOf(getName()));
 	} catch (FileNotFoundException e) {
 		// silent
 	} catch (IOException e) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
index 1a11430..f09ee86 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -22,18 +22,19 @@ import java.util.Map;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
-import org.eclipse.jdt.internal.compiler.env.IExternalAnnotationProvider;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 
-public class ExternalAnnotationProvider implements IExternalAnnotationProvider {
+public class ExternalAnnotationProvider {
+
+	public static final String ANNOTATION_FILE_SUFFIX = ".eea"; //$NON-NLS-1$ // FIXME(SH): define file extension
 
 	private File annotationSource;
 	private Map<String,String> methodAnnotationSources;
 	
-	public ExternalAnnotationProvider(File annotationSource) throws IOException {
-		if (!annotationSource.exists()) throw new FileNotFoundException(annotationSource.getAbsolutePath());
-		this.annotationSource = annotationSource;
+	public ExternalAnnotationProvider(String baseDir, String typeName) throws IOException {
+		this.annotationSource = new File(baseDir+File.separatorChar+typeName+ANNOTATION_FILE_SUFFIX);
+		if (!this.annotationSource.exists()) throw new FileNotFoundException(this.annotationSource.getAbsolutePath());
 		this.methodAnnotationSources = new HashMap<String, String>();
 		initialize();
 	}
@@ -55,7 +56,6 @@ public class ExternalAnnotationProvider implements IExternalAnnotationProvider {
 		}
 	}
 
-	@Override
 	public ITypeAnnotationWalker forMethod(char[] selector, char[] signature, LookupEnvironment environment) {
 		String source = this.methodAnnotationSources.get(String.valueOf(CharOperation.concat(selector, signature)));
 		if (source != null)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java
deleted file mode 100644
index a9e596b..0000000
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IExternalAnnotationProvider.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2014 GK Software AG, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     Stephan Herrmann - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.compiler.env;
-
-import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
-
-/** An instance of of this type answers external annotations for the methods and fields of a given class. */
-public interface IExternalAnnotationProvider {
-	
-	String ANNOTATION_FILE_SUFFIX = ".eea"; //$NON-NLS-1$ // FIXME(SH): define file extension
-
-	ITypeAnnotationWalker forMethod(char[] selector, char[] signature, LookupEnvironment environment);
-
-}
commit 61e83b56b3e206ca02d211f1803679e0adee4981
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Jul 27 16:12:07 2014 +0200

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - handle more annotation locations (type argument, wildcard bound)

16	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
8	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath
17	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project
4	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
16	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java
57	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
index 2a1c0f5..0389c0d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
@@ -178,4 +178,20 @@ public class ExternalAnnotations18Test extends ModifyingResourceTests {
 			JavaCore.setOptions(options);
 		}
 	}
+
+	/** Project with real JRE8.
+	 * More interesting work with generics
+	 */
+	public void test3() throws Exception {
+		Hashtable options = JavaCore.getOptions();
+		try {
+			setupJavaProject("Test3");
+			this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
+			assertNoMarkers(markers);
+		} finally {
+			// project using a full JRE container initializes global options to 1.8 -- must reset now:
+			JavaCore.setOptions(options);
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath
new file mode 100644
index 0000000..51499da
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" 
+			path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8" 
+			annotationpath="annots"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project
new file mode 100644
index 0000000..ea7fde1
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Test3</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
new file mode 100644
index 0000000..9eefab4
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
@@ -0,0 +1,4 @@
+class <T:R:>Function
+
+compose<V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+TT;>;)Ljava/util/function/Function<TV;TR;>;=<V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+T0T;>;)Ljava/util/function/Function<TV;TR;>;
+compose<V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+TT;>;)Ljava/util/function/Function<TV;TR;>;=<V:>(LA1<-TV;+T0T;>;)LR<TV;TR;>;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java
new file mode 100644
index 0000000..4e025c6
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java
@@ -0,0 +1,16 @@
+package test1;
+
+import org.eclipse.jdt.annotation.*;
+import java.util.function.*;
+
+
+class A {}
+class B {}
+class C {}
+
+@NonNullByDefault
+public class Test3 {
+	C test(Function<A,@Nullable B> f1, Function<B,C> f2, A a) {
+		return f2.compose(f1).apply(a); // actually incompatible, but we tweak compose to pretend it's compatible
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
index f09ee86..cafd15c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -24,6 +24,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+import org.eclipse.jdt.internal.compiler.lookup.SignatureWrapper;
 
 public class ExternalAnnotationProvider {
 
@@ -83,7 +84,10 @@ public class ExternalAnnotationProvider {
 		};
 
 		char[] source;
+		SignatureWrapper wrapper;
 		int pos;
+		int prevParamStart;
+		int prevTypeArgStart;
 		LookupEnvironment environment;
 
 		MethodAnnotationWalker(char[] source, int pos, LookupEnvironment environment) {
@@ -92,6 +96,24 @@ public class ExternalAnnotationProvider {
 			this.pos = pos;
 			this.environment = environment;
 		}
+		
+		SignatureWrapper wrapperWithStart(int start) {
+			if (this.wrapper == null)
+				this.wrapper = new SignatureWrapper(this.source);
+			this.wrapper.start = start;
+			return this.wrapper;
+		}
+
+		int typeEnd(int start) {
+			while (this.source[start] == '[') {
+				start++;
+				char an = this.source[start];
+				if (an == '0' || an == '1')
+					start++;
+			}
+			int end = wrapperWithStart(start).computeEnd();
+			return end;
+		}
 
 		@Override
 		public ITypeAnnotationWalker toMethodReturn() {
@@ -128,7 +150,15 @@ public class ExternalAnnotationProvider {
 
 		@Override
 		public ITypeAnnotationWalker toMethodParameter(short index) {
-			return this;
+			if (index == 0) {
+				int start = CharOperation.indexOf('(', this.source) + 1;
+				this.prevParamStart = start;
+				return new MethodAnnotationWalker(this.source, start, this.environment);
+			}
+			int end = typeEnd(this.prevParamStart);
+			end++;
+		    this.prevParamStart = end;
+		    return new MethodAnnotationWalker(this.source, end, this.environment);
 		}
 
 		@Override
@@ -138,12 +168,36 @@ public class ExternalAnnotationProvider {
 
 		@Override
 		public ITypeAnnotationWalker toTypeArgument(int rank) {
-			return this;
+			if (rank == 0) {
+				int start = CharOperation.indexOf('<', this.source, this.pos) + 1;
+				this.prevTypeArgStart = start;
+				return new MethodAnnotationWalker(this.source, start, this.environment);
+			}
+			int next = this.prevTypeArgStart;
+			switch (this.source[next]) {
+				case '*': 
+					break;
+				case '-': 
+				case '+':
+					next++;
+					//$FALL-THROUGH$
+				default:
+					next = wrapperWithStart(next).computeEnd();
+			}
+			next++;
+		    this.prevTypeArgStart = next;
+		    return new MethodAnnotationWalker(this.source, next,	this.environment);
 		}
 
 		@Override
 		public ITypeAnnotationWalker toWildcardBound() {
-			return this;
+			switch (this.source[this.pos]) {
+				case '-': 
+				case '+':
+					return new MethodAnnotationWalker(this.source, this.pos+1, this.environment);
+				default: // includes unbounded '*'
+					return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+			}			
 		}
 
 		@Override
commit b39f3a5a9fadba74f50d9dc16813d561f779e994
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Jul 27 16:42:21 2014 +0200

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - slightly changed the layout of annotation files

10	4	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea
10	4	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
4	3	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
39	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea
index 6699601..85e172b 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea
@@ -1,5 +1,11 @@
-class <K:V:>Map
+class <K:V:>java/util/Map
 
-get(Ljava/lang/Object;)TV;=get(Ljava/lang/Object;)T0V;
-put(TK;TV;)TV;=put(TK;TV;)T0V;
-remove(Ljava/lang/Object;)TV;=remove(Ljava/lang/Object;)T0V;
+get
+ (Ljava/lang/Object;)TV;
+ (Ljava/lang/Object;)T0V;
+put
+ (TK;TV;)TV;
+ (TK;TV;)T0V;
+remove
+ (Ljava/lang/Object;)TV;
+ (Ljava/lang/Object;)T0V;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
index 6699601..85e172b 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
@@ -1,5 +1,11 @@
-class <K:V:>Map
+class <K:V:>java/util/Map
 
-get(Ljava/lang/Object;)TV;=get(Ljava/lang/Object;)T0V;
-put(TK;TV;)TV;=put(TK;TV;)T0V;
-remove(Ljava/lang/Object;)TV;=remove(Ljava/lang/Object;)T0V;
+get
+ (Ljava/lang/Object;)TV;
+ (Ljava/lang/Object;)T0V;
+put
+ (TK;TV;)TV;
+ (TK;TV;)T0V;
+remove
+ (Ljava/lang/Object;)TV;
+ (Ljava/lang/Object;)T0V;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
index 9eefab4..40e900b 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
@@ -1,4 +1,5 @@
-class <T:R:>Function
+class <T:R:>java/util/function/Function
 
-compose<V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+TT;>;)Ljava/util/function/Function<TV;TR;>;=<V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+T0T;>;)Ljava/util/function/Function<TV;TR;>;
-compose<V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+TT;>;)Ljava/util/function/Function<TV;TR;>;=<V:>(LA1<-TV;+T0T;>;)LR<TV;TR;>;
+compose
+ <V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+TT;>;)Ljava/util/function/Function<TV;TR;>;
+ <V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+T0T;>;)Ljava/util/function/Function<TV;TR;>;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
index cafd15c..ae62af0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -10,14 +10,15 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
-import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStreamReader;
+import java.io.LineNumberReader;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Map.Entry;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
@@ -37,20 +38,42 @@ public class ExternalAnnotationProvider {
 		this.annotationSource = new File(baseDir+File.separatorChar+typeName+ANNOTATION_FILE_SUFFIX);
 		if (!this.annotationSource.exists()) throw new FileNotFoundException(this.annotationSource.getAbsolutePath());
 		this.methodAnnotationSources = new HashMap<String, String>();
-		initialize();
+		initialize(typeName);
 	}
 	
-	private void initialize() throws IOException {
-		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(this.annotationSource)));
+	private void initialize(String typeName) throws IOException {
+		LineNumberReader reader = new LineNumberReader(new InputStreamReader(new FileInputStream(this.annotationSource)));
 		try {
 			String line = reader.readLine();
 			if (!line.startsWith("class ")) // TODO properly evaluate class header //$NON-NLS-1$
 				throw new IOException("missing class header in annotation file"); //$NON-NLS-1$
+			if (!line.endsWith(typeName))
+				throw new IOException("mismatching class name in annotation file, expected "+typeName+", but header said "+line); //$NON-NLS-1$ //$NON-NLS-2$
 			while ((line = reader.readLine()) != null) {
 				if (line.isEmpty()) continue;
-				int pos=line.indexOf('=');
-				if (pos == -1) throw new IOException("Illegal format for annotation file, missing '='"); //$NON-NLS-1$
-				this.methodAnnotationSources.put(line.substring(0, pos), line.substring(pos+1));
+				String rawSig = null, annotSig = null;
+				// selector:
+				String selector = line;
+				int errLine = -1;
+				try {
+					// raw signature:
+					line = reader.readLine();
+					if (line.charAt(0) == ' ')
+						rawSig = line.substring(1);
+					else
+						errLine = reader.getLineNumber();
+					// annotated signature:
+					line = reader.readLine();
+					if (line.charAt(0) == ' ')
+						annotSig = line.substring(1);
+				} catch (Exception ex) {
+					// continue to escalate below
+				}
+				if (rawSig == null || annotSig == null) {
+					if (errLine == -1) errLine = reader.getLineNumber();
+					throw new IOException("Illegal format for annotation file at line "+errLine); //$NON-NLS-1$
+				}
+				this.methodAnnotationSources.put(selector+rawSig, annotSig);
 			}
 		} finally {
 			reader.close();
@@ -64,6 +87,15 @@ public class ExternalAnnotationProvider {
 		return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
 	}
 	
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		sb.append("External Annotations from "+this.annotationSource.getAbsolutePath()).append('\n'); //$NON-NLS-1$
+		sb.append("Methods:\n"); //$NON-NLS-1$
+		for (Entry<String,String> e : this.methodAnnotationSources.entrySet())
+			sb.append('\t').append(e.getKey()).append('\n');
+		return sb.toString();
+	}
+
 	abstract class SingleMarkerAnnotation implements IBinaryAnnotation {
 		@Override
 		public IBinaryElementValuePair[] getElementValuePairs() {
commit efd3b1f31e7f6af67fb63e84ece49ae3c1341055
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Jul 27 16:49:00 2014 +0200

    Revert changes for Bug 440477 that were meant for branch
    sherrmann/ExternalAnnotations
    
    This reverts commit b39f3a5a9fadba74f50d9dc16813d561f779e994.
    This reverts commit 61e83b56b3e206ca02d211f1803679e0adee4981.
    This reverts commit b1d9b2131096901775539a68eb3d7a7d50bc45d5.
    This reverts commit 6c085192f8ca1a30dcc3f8eecf0c1b2085d19f7e.
    This reverts commit 48a2d2499344bebca223a2f8c964ed5900cd0012.
    This reverts commit d08e87c35b21123010227cf2729df51d820e4d50.

-	-	org.eclipse.jdt.core.tests.model/JCL/jclMin1.8.jar
-	-	org.eclipse.jdt.core.tests.model/JCL/jclMin1.8src.zip
0	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
0	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
1	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
0	197	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
0	6	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath
0	17	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project
0	11	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea
0	13	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java
0	8	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath
0	17	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project
0	11	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
0	13	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java
0	8	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath
0	17	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project
0	5	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
0	16	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java
3	4	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
3	51	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
0	267	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
6	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
45	32	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
0	114	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
16	24	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
13	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
1	10	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathEntry.java
1	16	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
1	248	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
2	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
2	43	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
2	8	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
0	40	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
10	24	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
7	9	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
3	5	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
3	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
2	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8.jar b/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8.jar
index e412b3a..2b78416 100644
Binary files a/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8.jar and b/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8.jar differ
diff --git a/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8src.zip b/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8src.zip
index 3105da0..0757f3a 100644
Binary files a/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8src.zip and b/org.eclipse.jdt.core.tests.model/JCL/jclMin1.8src.zip differ
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
index d1eb8aa..0fdea20 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
@@ -7,8 +7,6 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
@@ -2842,7 +2840,6 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 							new Path(newJclLibString),
 							new Path(newJclSrcString),
 							entry.getSourceAttachmentRootPath(),
-							entry.getExternalAnnotationPath(),
 							entry.getAccessRules(),
 							new IClasspathAttribute[0],
 							entry.isExported());
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
index d8a08c7..2048e88 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
@@ -193,8 +193,6 @@ private static Class[] getAllTestClasses() {
 		
 		// Tests regarding null-annotations:
 		NullAnnotationModelTests.class,
-		ExternalAnnotations18Test.class,
-
 		// Java model changes related to Java 8
 		JavaElement8Tests.class,
 	};
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
index 5e55e9e..47c14fc 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
@@ -9,10 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425,
  *     									   Fup of 357425: ensure all reported regressions are witnessed by tests, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=361922
- *     Thirumala Reddy Mutchukota <thirumala@google.com> - Contribution for
- *     							Bug 411423 - JavaProject.resolveClasspath is spending more than 90% time on ExternalFoldersManager.isExternalFolderPath
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
+ *     Thirumala Reddy Mutchukota <thirumala@google.com> - Contribution to bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=411423
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
@@ -5846,7 +5843,6 @@ public void testBug55992a() throws CoreException {
 			ClasspathEntry.EXCLUDE_NONE,
 			new Path("TEST_SRC"),
 			null,
-			null,
 			null, // specific output folder
 			false,
 			(IAccessRule[]) null,
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
deleted file mode 100644
index 0389c0d..0000000
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2014 GK Software AG, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     Stephan Herrmann - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.tests.model;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.net.URL;
-import java.util.Hashtable;
-import java.util.Map;
-
-import junit.framework.Test;
-
-import org.eclipse.core.resources.IMarker;
-import org.eclipse.core.resources.IResource;
-import org.eclipse.core.resources.IncrementalProjectBuilder;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.FileLocator;
-import org.eclipse.core.runtime.NullProgressMonitor;
-import org.eclipse.jdt.core.IClasspathAttribute;
-import org.eclipse.jdt.core.IClasspathEntry;
-import org.eclipse.jdt.core.ICompilationUnit;
-import org.eclipse.jdt.core.IJavaModelMarker;
-import org.eclipse.jdt.core.IJavaProject;
-import org.eclipse.jdt.core.IPackageFragment;
-import org.eclipse.jdt.core.IPackageFragmentRoot;
-import org.eclipse.jdt.core.JavaCore;
-import org.eclipse.jdt.core.JavaModelException;
-import org.eclipse.jdt.core.compiler.IProblem;
-import org.eclipse.jdt.core.dom.AST;
-import org.eclipse.jdt.core.dom.CompilationUnit;
-import org.osgi.framework.Bundle;
-
-public class ExternalAnnotations18Test extends ModifyingResourceTests {
-
-	private IJavaProject project;
-	private IPackageFragmentRoot root;
-	private String ANNOTATION_LIB;
-
-	public ExternalAnnotations18Test(String name) {
-		super(name);
-	}
-	
-// Use this static initializer to specify subset for tests
-// All specified tests which do not belong to the class are skipped...
-	static {
-		// Names of tests to run: can be "testBugXXXX" or "BugXXXX")
-//		TESTS_PREFIX = "testClasspathDuplicateExtraAttribute";
-//		TESTS_NAMES = new String[] {"test3"};
-//		TESTS_NUMBERS = new int[] { 23, 28, 38 };
-//		TESTS_RANGE = new int[] { 21, 38 };
-	}
-	public static Test suite() {
-		return buildModelTestSuite(ExternalAnnotations18Test.class, BYTECODE_DECLARATION_ORDER);
-	}
-
-	/**
-	 * @deprecated indirectly uses deprecated class PackageAdmin
-	 */
-	public void setUpSuite() throws Exception {
-		super.setUpSuite();
-		
-		Bundle[] bundles = org.eclipse.jdt.core.tests.Activator.getPackageAdmin().getBundles("org.eclipse.jdt.annotation", "[2.0.0,3.0.0)");
-		File bundleFile = FileLocator.getBundleFile(bundles[0]);
-		this.ANNOTATION_LIB = bundleFile.isDirectory() ? bundleFile.getPath()+"/bin" : bundleFile.getPath();
-	}
-	
-	public String getSourceWorkspacePath() {
-		// we read individual projects from within this folder:
-		return super.getSourceWorkspacePath()+"/ExternalAnnotations18";
-	}
-
-	void setupJavaProject(String name) throws CoreException, IOException {
-		this.project = setUpJavaProject(name, "1.8"); //$NON-NLS-1$
-		addLibraryEntry(this.project, this.ANNOTATION_LIB, false);
-		Map options = this.project.getOptions(true);
-		options.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
-		this.project.setOptions(options);
-
-		IPackageFragmentRoot[] roots = this.project.getAllPackageFragmentRoots();
-		int count = 0;
-		for (int i = 0, max = roots.length; i < max; i++) {
-			final IPackageFragmentRoot packageFragmentRoot = roots[i];
-			switch(packageFragmentRoot.getKind()) {
-				case IPackageFragmentRoot.K_SOURCE :
-					count++;
-					if (this.root == null) {
-						this.root = packageFragmentRoot;
-					}
-			}
-		}
-		assertEquals("Wrong value", 1, count); //$NON-NLS-1$
-		assertNotNull("Should not be null", this.root); //$NON-NLS-1$
-	}
-	
-	protected void tearDown() throws Exception {
-		this.project.getProject().delete(true, true, null);
-		this.project = null;
-		super.tearDown();
-	}
-	
-	// TODO: using this copy from AttachedJavadocTests test also programmatically setting the external annotation location:
-	private void setExternalAnnotationsAttribute(String folderName) throws JavaModelException {
-		IClasspathEntry[] entries = this.project.getRawClasspath();
-		IResource resource = this.project.getProject().findMember("/"+folderName+"/"); //$NON-NLS-1$
-		assertNotNull("annotations folder cannot be null", resource); //$NON-NLS-1$
-		URI locationURI = resource.getLocationURI();
-		assertNotNull("annotations folder cannot be null", locationURI); //$NON-NLS-1$
-		URL annotationsUrl = null;
-		try {
-			annotationsUrl = locationURI.toURL();
-		} catch (MalformedURLException e) {
-			assertTrue("Should not happen", false); //$NON-NLS-1$
-		} catch(IllegalArgumentException e) {
-			assertTrue("Should not happen", false); //$NON-NLS-1$
-		}
-		IClasspathAttribute attribute = JavaCore.newClasspathAttribute(IClasspathAttribute.JAVADOC_LOCATION_ATTRIBUTE_NAME, annotationsUrl.toExternalForm());
-		for (int i = 0, max = entries.length; i < max; i++) {
-			final IClasspathEntry entry = entries[i];
-			if (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY
-					&& entry.getContentKind() == IPackageFragmentRoot.K_BINARY
-					&& "/AttachedJavadocProject/lib/test6.jar".equals(entry.getPath().toString())) { //$NON-NLS-1$
-				entries[i] = JavaCore.newLibraryEntry(entry.getPath(), entry.getSourceAttachmentPath(), entry.getSourceAttachmentRootPath(), entry.getAccessRules(), new IClasspathAttribute[] { attribute}, entry.isExported());
-			}
-		}
-		this.project.setRawClasspath(entries, null);
-	}
-
-	private void assertNoMarkers(IMarker[] markers) throws CoreException {
-		for (int i = 0; i < markers.length; i++)
-			System.err.println("Unexpected marker: "+markers[i].getAttributes().entrySet());
-		assertEquals("Number of markers", 0, markers.length);
-	}
-	
-	private void assertNoProblems(IProblem[] problems) throws CoreException {
-		for (int i = 0; i < problems.length; i++)
-			System.err.println("Unexpected marker: "+problems[i]);
-		assertEquals("Number of markers", 0, problems.length);
-	}
-
-	/** Perform full build. */
-	public void test1FullBuild() throws Exception {
-		setupJavaProject("Test1");
-		this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
-		IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
-		assertNoMarkers(markers);
-	}
-
-	/** Reconcile an individual CU. */
-	public void test1Reconcile() throws Exception {
-		setupJavaProject("Test1");
-		IPackageFragment fragment = this.root.getPackageFragment("test1");
-		ICompilationUnit unit = fragment.getCompilationUnit("Test1.java").getWorkingCopy(new NullProgressMonitor());
-		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
-		IProblem[] problems = reconciled.getProblems();
-		assertNoProblems(problems);
-	}
-
-	/** Project with real JRE8. */
-	public void test2() throws Exception {
-		Hashtable options = JavaCore.getOptions();
-		try {
-			setupJavaProject("Test2");
-			this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
-			IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
-			assertNoMarkers(markers);
-		} finally {
-			// project using a full JRE container initializes global options to 1.8 -- must reset now:
-			JavaCore.setOptions(options);
-		}
-	}
-
-	/** Project with real JRE8.
-	 * More interesting work with generics
-	 */
-	public void test3() throws Exception {
-		Hashtable options = JavaCore.getOptions();
-		try {
-			setupJavaProject("Test3");
-			this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
-			IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
-			assertNoMarkers(markers);
-		} finally {
-			// project using a full JRE container initializes global options to 1.8 -- must reset now:
-			JavaCore.setOptions(options);
-		}
-	}
-}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath
deleted file mode 100644
index 8c0b66a..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="var" path="JCL18_LIB" annotationpath="annots"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project
deleted file mode 100644
index bd0683a..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>Test1</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea
deleted file mode 100644
index 85e172b..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/java/util/Map.eea
+++ /dev/null
@@ -1,11 +0,0 @@
-class <K:V:>java/util/Map
-
-get
- (Ljava/lang/Object;)TV;
- (Ljava/lang/Object;)T0V;
-put
- (TK;TV;)TV;
- (TK;TV;)T0V;
-remove
- (Ljava/lang/Object;)TV;
- (Ljava/lang/Object;)T0V;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java
deleted file mode 100644
index e483874..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package test1;
-
-import java.util.Map;
-import org.eclipse.jdt.annotation.*;
-
-@NonNullByDefault
-public class Test1 {
-	void test(Map<String,Test1> map, String key) {
-		Test1 v = map.get(key);
-		if (v == null)
-			throw new RuntimeException(); // should not be reported as dead code, although V is a '@NonNull Test1'
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath
deleted file mode 100644
index 51499da..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" 
-			path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8" 
-			annotationpath="annots"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project
deleted file mode 100644
index 1b369ff..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>Test2</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
deleted file mode 100644
index 85e172b..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
+++ /dev/null
@@ -1,11 +0,0 @@
-class <K:V:>java/util/Map
-
-get
- (Ljava/lang/Object;)TV;
- (Ljava/lang/Object;)T0V;
-put
- (TK;TV;)TV;
- (TK;TV;)T0V;
-remove
- (Ljava/lang/Object;)TV;
- (Ljava/lang/Object;)T0V;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java
deleted file mode 100644
index e483874..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package test1;
-
-import java.util.Map;
-import org.eclipse.jdt.annotation.*;
-
-@NonNullByDefault
-public class Test1 {
-	void test(Map<String,Test1> map, String key) {
-		Test1 v = map.get(key);
-		if (v == null)
-			throw new RuntimeException(); // should not be reported as dead code, although V is a '@NonNull Test1'
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath
deleted file mode 100644
index 51499da..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" 
-			path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8" 
-			annotationpath="annots"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project
deleted file mode 100644
index ea7fde1..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>Test3</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
deleted file mode 100644
index 40e900b..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
+++ /dev/null
@@ -1,5 +0,0 @@
-class <T:R:>java/util/function/Function
-
-compose
- <V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+TT;>;)Ljava/util/function/Function<TV;TR;>;
- <V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+T0T;>;)Ljava/util/function/Function<TV;TR;>;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java
deleted file mode 100644
index 4e025c6..0000000
--- a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package test1;
-
-import org.eclipse.jdt.annotation.*;
-import java.util.function.*;
-
-
-class A {}
-class B {}
-class C {}
-
-@NonNullByDefault
-public class Test3 {
-	C test(Function<A,@Nullable B> f1, Function<B,C> f2, A a) {
-		return f2.compose(f1).apply(a); // actually incompatible, but we tweak compose to pretend it's compatible
-	}
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
index 02b7d13..6a02d3b 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2014 IBM Corporation and others.
+ * Copyright (c) 2008, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,7 +9,6 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								Bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.codeassist;
 
@@ -39,7 +38,7 @@ import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
+import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
@@ -339,7 +338,7 @@ public class InternalExtendedCompletionContext {
 
 			SignatureWrapper wrapper = new SignatureWrapper(replacePackagesDot(typeSignature.toCharArray()));
 			// FIXME(stephan): do we interpret type annotations here?
-			assignableTypeBinding = this.lookupEnvironment.getTypeFromTypeSignature(wrapper, typeVariables, this.assistScope.enclosingClassScope().referenceContext.binding, null, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+			assignableTypeBinding = this.lookupEnvironment.getTypeFromTypeSignature(wrapper, typeVariables, this.assistScope.enclosingClassScope().referenceContext.binding, null, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 			assignableTypeBinding = BinaryTypeBinding.resolveType(assignableTypeBinding, this.lookupEnvironment, true);
 		} catch (AbortCompilation e) {
 			assignableTypeBinding = null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index f950b82..a643a36 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,28 +7,22 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for
- *								Bug 365992 - [builder] [null] Change of nullness for a parameter doesn't trigger a build for the files that call the method
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
+ *     Stephan Herrmann - Contribution for bug 365992 - [builder] [null] Change of nullness for a parameter doesn't trigger a build for the files that call the method
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
- *         						bug 407191 - [1.8] Binary access support for type annotations
+ *         bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Arrays;
 
-import org.eclipse.core.runtime.IPath;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants;
 import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
-import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
-import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
@@ -62,7 +56,6 @@ public class ClassFileReader extends ClassFileStruct implements IBinaryType {
 	private char[][][] missingTypeNames;
 	private int enclosingNameAndTypeIndex;
 	private char[] enclosingMethod;
-	private ExternalAnnotationProvider annotationProvider;
 
 private static String printTypeModifiers(int modifiers) {
 	java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream();
@@ -404,47 +397,6 @@ public ClassFileReader(byte[] classFileBytes, char[] fileName, boolean fullyInit
 }
 
 /**
- * @param classFileBytes byte[]
- * 		Actual bytes of a .class file
- *
- * @param fileName char[]
- * 		Actual name of the file that contains the bytes, can be null
- *
- * @param fullyInitialize boolean
- * 		Flag to fully initialize the new object
- * 
- * @param externalAnnotationPath
- * 		Path to external annotations as used for null analysis
- * 
- * @exception ClassFormatException
- */
-public ClassFileReader(byte[] classFileBytes, char[] fileName, boolean fullyInitialize, IPath externalAnnotationPath) throws ClassFormatException {
-	this(classFileBytes, fileName, fullyInitialize);
-	if (externalAnnotationPath != null)
-		setExternalAnnotationProvider(externalAnnotationPath.toString());
-}
-
-/** Create and remember a provider for external annotations using the given text file. */
-public void setExternalAnnotationProvider(String externalAnnotationDir) {
-	try {
-		this.annotationProvider = new ExternalAnnotationProvider(externalAnnotationDir, String.valueOf(getName()));
-	} catch (FileNotFoundException e) {
-		// silent
-	} catch (IOException e) {
-		// TODO Auto-generated catch block
-		e.printStackTrace();
-	}
-}
-
-/** If a provider for external annotations has been registered try to retrieve an annotation walker for the given method. */
-public ITypeAnnotationWalker getAnnotationsForMethod(IBinaryMethod method, char[] methodSignature, LookupEnvironment environment) {
-	if (this.annotationProvider != null) {
-		return this.annotationProvider.forMethod(method.isConstructor() ? TypeConstants.INIT : method.getSelector(), methodSignature, environment);
-	}
-	return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
-}
-
-/**
  * Answer the receiver's access flags.  The value of the access_flags
  *	item is a mask of modifiers used with class and interface declarations.
  *  @return int
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
deleted file mode 100644
index ae62af0..0000000
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
+++ /dev/null
@@ -1,267 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2014 GK Software AG.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     Stephan Herrmann - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.compiler.classfmt;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.LineNumberReader;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Map.Entry;
-
-import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
-import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
-import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
-import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
-import org.eclipse.jdt.internal.compiler.lookup.SignatureWrapper;
-
-public class ExternalAnnotationProvider {
-
-	public static final String ANNOTATION_FILE_SUFFIX = ".eea"; //$NON-NLS-1$ // FIXME(SH): define file extension
-
-	private File annotationSource;
-	private Map<String,String> methodAnnotationSources;
-	
-	public ExternalAnnotationProvider(String baseDir, String typeName) throws IOException {
-		this.annotationSource = new File(baseDir+File.separatorChar+typeName+ANNOTATION_FILE_SUFFIX);
-		if (!this.annotationSource.exists()) throw new FileNotFoundException(this.annotationSource.getAbsolutePath());
-		this.methodAnnotationSources = new HashMap<String, String>();
-		initialize(typeName);
-	}
-	
-	private void initialize(String typeName) throws IOException {
-		LineNumberReader reader = new LineNumberReader(new InputStreamReader(new FileInputStream(this.annotationSource)));
-		try {
-			String line = reader.readLine();
-			if (!line.startsWith("class ")) // TODO properly evaluate class header //$NON-NLS-1$
-				throw new IOException("missing class header in annotation file"); //$NON-NLS-1$
-			if (!line.endsWith(typeName))
-				throw new IOException("mismatching class name in annotation file, expected "+typeName+", but header said "+line); //$NON-NLS-1$ //$NON-NLS-2$
-			while ((line = reader.readLine()) != null) {
-				if (line.isEmpty()) continue;
-				String rawSig = null, annotSig = null;
-				// selector:
-				String selector = line;
-				int errLine = -1;
-				try {
-					// raw signature:
-					line = reader.readLine();
-					if (line.charAt(0) == ' ')
-						rawSig = line.substring(1);
-					else
-						errLine = reader.getLineNumber();
-					// annotated signature:
-					line = reader.readLine();
-					if (line.charAt(0) == ' ')
-						annotSig = line.substring(1);
-				} catch (Exception ex) {
-					// continue to escalate below
-				}
-				if (rawSig == null || annotSig == null) {
-					if (errLine == -1) errLine = reader.getLineNumber();
-					throw new IOException("Illegal format for annotation file at line "+errLine); //$NON-NLS-1$
-				}
-				this.methodAnnotationSources.put(selector+rawSig, annotSig);
-			}
-		} finally {
-			reader.close();
-		}
-	}
-
-	public ITypeAnnotationWalker forMethod(char[] selector, char[] signature, LookupEnvironment environment) {
-		String source = this.methodAnnotationSources.get(String.valueOf(CharOperation.concat(selector, signature)));
-		if (source != null)
-			return new MethodAnnotationWalker(source.toCharArray(), 0, environment);
-		return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
-	}
-	
-	public String toString() {
-		StringBuilder sb = new StringBuilder();
-		sb.append("External Annotations from "+this.annotationSource.getAbsolutePath()).append('\n'); //$NON-NLS-1$
-		sb.append("Methods:\n"); //$NON-NLS-1$
-		for (Entry<String,String> e : this.methodAnnotationSources.entrySet())
-			sb.append('\t').append(e.getKey()).append('\n');
-		return sb.toString();
-	}
-
-	abstract class SingleMarkerAnnotation implements IBinaryAnnotation {
-		@Override
-		public IBinaryElementValuePair[] getElementValuePairs() {
-			return ElementValuePairInfo.NoMembers;
-		}
-		protected char[] getBinaryTypeName(char[][] name) {
-			return CharOperation.concat('L', CharOperation.concatWith(name, '/'), ';');
-		}
-	}
-
-	class MethodAnnotationWalker implements ITypeAnnotationWalker {
-
-		private SingleMarkerAnnotation NULLABLE = new SingleMarkerAnnotation() {
-			@Override public char[] getTypeName() { return getBinaryTypeName(MethodAnnotationWalker.this.environment.getNullableAnnotationName()); }
-		};
-		private SingleMarkerAnnotation NONNULL = new SingleMarkerAnnotation() {
-			@Override public char[] getTypeName() { return getBinaryTypeName(MethodAnnotationWalker.this.environment.getNonNullAnnotationName()); }
-		};
-
-		char[] source;
-		SignatureWrapper wrapper;
-		int pos;
-		int prevParamStart;
-		int prevTypeArgStart;
-		LookupEnvironment environment;
-
-		MethodAnnotationWalker(char[] source, int pos, LookupEnvironment environment) {
-			super();
-			this.source = source;
-			this.pos = pos;
-			this.environment = environment;
-		}
-		
-		SignatureWrapper wrapperWithStart(int start) {
-			if (this.wrapper == null)
-				this.wrapper = new SignatureWrapper(this.source);
-			this.wrapper.start = start;
-			return this.wrapper;
-		}
-
-		int typeEnd(int start) {
-			while (this.source[start] == '[') {
-				start++;
-				char an = this.source[start];
-				if (an == '0' || an == '1')
-					start++;
-			}
-			int end = wrapperWithStart(start).computeEnd();
-			return end;
-		}
-
-		@Override
-		public ITypeAnnotationWalker toMethodReturn() {
-			int close = CharOperation.indexOf(')', this.source);
-			if (close != -1)
-				return new MethodAnnotationWalker(this.source, close+1, this.environment);
-			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
-		}
-
-		@Override
-		public ITypeAnnotationWalker toReceiver() {
-			return this;
-		}
-
-		@Override
-		public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
-			return this;
-		}
-
-		@Override
-		public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
-			return this;
-		}
-
-		@Override
-		public ITypeAnnotationWalker toTypeBound(short boundIndex) {
-			return this;
-		}
-
-		@Override
-		public ITypeAnnotationWalker toSupertype(short index) {
-			return this;
-		}
-
-		@Override
-		public ITypeAnnotationWalker toMethodParameter(short index) {
-			if (index == 0) {
-				int start = CharOperation.indexOf('(', this.source) + 1;
-				this.prevParamStart = start;
-				return new MethodAnnotationWalker(this.source, start, this.environment);
-			}
-			int end = typeEnd(this.prevParamStart);
-			end++;
-		    this.prevParamStart = end;
-		    return new MethodAnnotationWalker(this.source, end, this.environment);
-		}
-
-		@Override
-		public ITypeAnnotationWalker toThrows(int index) {
-			return this;
-		}
-
-		@Override
-		public ITypeAnnotationWalker toTypeArgument(int rank) {
-			if (rank == 0) {
-				int start = CharOperation.indexOf('<', this.source, this.pos) + 1;
-				this.prevTypeArgStart = start;
-				return new MethodAnnotationWalker(this.source, start, this.environment);
-			}
-			int next = this.prevTypeArgStart;
-			switch (this.source[next]) {
-				case '*': 
-					break;
-				case '-': 
-				case '+':
-					next++;
-					//$FALL-THROUGH$
-				default:
-					next = wrapperWithStart(next).computeEnd();
-			}
-			next++;
-		    this.prevTypeArgStart = next;
-		    return new MethodAnnotationWalker(this.source, next,	this.environment);
-		}
-
-		@Override
-		public ITypeAnnotationWalker toWildcardBound() {
-			switch (this.source[this.pos]) {
-				case '-': 
-				case '+':
-					return new MethodAnnotationWalker(this.source, this.pos+1, this.environment);
-				default: // includes unbounded '*'
-					return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
-			}			
-		}
-
-		@Override
-		public ITypeAnnotationWalker toNextArrayDimension() {
-			return this;
-		}
-
-		@Override
-		public ITypeAnnotationWalker toNextNestedType() {
-			return this;
-		}
-
-		@Override
-		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
-			if (this.pos != -1 && this.pos < this.source.length-2) {
-				switch (this.source[this.pos]) {
-					case 'T':
-					case 'L':
-						switch (this.source[this.pos+1]) {
-							case '0':
-								return new IBinaryAnnotation[]{ this.NULLABLE };
-							case '1':
-								return new IBinaryAnnotation[]{ this.NONNULL };
-						}
-				}				
-			}
-			return null;
-		}
-
-		@Override
-		public ITypeAnnotationWalker toField() {
-			throw new UnsupportedOperationException("Methods have no fields"); //$NON-NLS-1$
-		}		
-	}
-}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
index 95d996e..cac02c8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
@@ -14,7 +14,6 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
-import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
@@ -102,21 +101,21 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 	
 	@Override
-	public ITypeAnnotationWalker toMethodParameter(short index) {
+	public TypeAnnotationWalker toMethodParameter(short index) {
 		// don't set nextIsDefaultLocation, because signature-level nullness is handled by ImplicitNullAnnotationVerifier
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toMethodParameter(index);
 	}
 
 	@Override
-	public ITypeAnnotationWalker toMethodReturn() {
+	public TypeAnnotationWalker toMethodReturn() {
 		// don't set nextIsDefaultLocation, because signature-level nullness is handled by ImplicitNullAnnotationVerifier
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toMethodReturn();
 	}
 
 	@Override
-	public ITypeAnnotationWalker toTypeBound(short boundIndex) {
+	public TypeAnnotationWalker toTypeBound(short boundIndex) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
 		this.nextIsTypeBound = true;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
@@ -124,7 +123,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 
 	@Override
-	public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+	public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
 		this.nextIsTypeBound = true;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
@@ -132,7 +131,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 
 	@Override
-	public ITypeAnnotationWalker toTypeArgument(int rank) {
+	public TypeAnnotationWalker toTypeArgument(int rank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeArgument) != 0;
 		this.nextIsTypeBound = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
@@ -140,7 +139,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 
 	@Override
-	public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+	public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeParameter) != 0;
 		this.nextIsTypeBound = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
index 7f4e388..3e525b7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
@@ -13,11 +13,37 @@ package org.eclipse.jdt.internal.compiler.classfmt;
 import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
-import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 
-/** Type annotation walker implementation based an actual annotations decoded from a .class file. */
-public class TypeAnnotationWalker implements ITypeAnnotationWalker {
+/**
+ * A TypeAnnotationWalker is initialized with all type annotations found at a given element.
+ * It can be used to walk into the types at the given element and finally answer the
+ * actual annotations at any node of the walk.
+ * 
+ * The walker is implemented as immutable objects. During the walk either new instances
+ * are created, or the current instance is shared if no difference is encountered.
+ */
+public class TypeAnnotationWalker {
 
+	public static final IBinaryAnnotation[] NO_ANNOTATIONS = new IBinaryAnnotation[0];
+
+	/**
+	 * A no-effect annotation walker, all walking methods are implemented as identity-functions.
+	 * At the end of any walk an empty array of annotations is returned.
+	 */
+	public static final TypeAnnotationWalker EMPTY_ANNOTATION_WALKER = new TypeAnnotationWalker(new IBinaryTypeAnnotation[0], 0L) {
+		public TypeAnnotationWalker toField() { return this; }
+		public TypeAnnotationWalker toTarget(int targetType) { return this; }
+		public TypeAnnotationWalker toThrows(int rank) { return this; }
+		public TypeAnnotationWalker toTypeArgument(int rank) { return this; }
+		public TypeAnnotationWalker toMethodParameter(short index) { return this; }
+		public TypeAnnotationWalker toSupertype(short index) { return this; }
+		public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) { return this; }
+		public TypeAnnotationWalker toTypeBound(short boundIndex) { return this; }
+		public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) { return this; }
+		public TypeAnnotationWalker toNextDetail(int detailKind) { return this; }
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) { return NO_ANNOTATIONS; }
+	};
+	
 	final protected IBinaryTypeAnnotation[] typeAnnotations;	// the actual material we're managing here
 	final protected long matches;								// bit mask of indices into typeAnnotations, 1 means active, 0 is filtered during the walk
 	final protected int pathPtr;								// pointer into the typePath
@@ -35,7 +61,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 		this.pathPtr = pathPtr;
 	}
 
-	protected ITypeAnnotationWalker restrict(long newMatches, int newPathPtr) {
+	protected TypeAnnotationWalker restrict(long newMatches, int newPathPtr) {
 		if (this.matches == newMatches && this.pathPtr == newPathPtr) return this;
 		if (newMatches == 0 || this.typeAnnotations == null || this.typeAnnotations.length == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -45,13 +71,12 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	// ==== filter by top-level targetType: ====
 	
 	/** Walk to a field. */
-	public ITypeAnnotationWalker toField() {
+	public TypeAnnotationWalker toField() {
 		return toTarget(AnnotationTargetTypeConstants.FIELD);
 	}
 
 	/** Walk to the return type of a method. */
-	@Override
-	public ITypeAnnotationWalker toMethodReturn() {
+	public TypeAnnotationWalker toMethodReturn() {
 		return toTarget(AnnotationTargetTypeConstants.METHOD_RETURN);
 	}
 
@@ -59,15 +84,14 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	 * Walk to the receiver type of a method.
 	 * Note: Type annotations on receiver are not currently used by the compiler.
 	 */
-	@Override
-	public ITypeAnnotationWalker toReceiver() {
+	public TypeAnnotationWalker toReceiver() {
 		return toTarget(AnnotationTargetTypeConstants.METHOD_RECEIVER);
 	}
 
 	/*
 	 * Implementation for walking to methodReturn, receiver type or field.
 	 */
-	protected ITypeAnnotationWalker toTarget(int targetType) {
+	protected TypeAnnotationWalker toTarget(int targetType) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -85,8 +109,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	 * @param isClassTypeParameter whether we are looking for a class type parameter (else: method type type parameter)
 	 * @param rank rank of the type parameter
 	 */
-	@Override
-	public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+	public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -108,8 +131,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	 * @param isClassTypeParameter whether we are looking at a class type parameter (else: method type type parameter)
 	 * @param parameterRank rank of the type parameter.
 	 */
-	@Override
-	public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+	public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -130,8 +152,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	 * of the previously selected type parameter. 
 	 * @param boundIndex
 	 */
-	@Override
-	public ITypeAnnotationWalker toTypeBound(short boundIndex) {
+	public TypeAnnotationWalker toTypeBound(short boundIndex) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -148,8 +169,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	
 	
 	/** Walk to the specified supertype: -1 is superclass, else the superinterface at the given index. */
-	@Override
-	public ITypeAnnotationWalker toSupertype(short index) {
+	public TypeAnnotationWalker toSupertype(short index) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -165,8 +185,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	}
 
 	/** Walk to the index'th visible formal method parameter (i.e., not counting synthetic args). */
-	@Override
-	public ITypeAnnotationWalker toMethodParameter(short index) {
+	public TypeAnnotationWalker toMethodParameter(short index) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -184,8 +203,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	/**
 	 * Walk to the throws type at the given index.
 	 */
-	@Override
-	public ITypeAnnotationWalker toThrows(int index) {
+	public TypeAnnotationWalker toThrows(int index) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -203,8 +221,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	// ==== descending into details: ====
 
 	/** Walk to the type argument of the given rank. */
-	@Override
-	public ITypeAnnotationWalker toTypeArgument(int rank) {
+	public TypeAnnotationWalker toTypeArgument(int rank) {
 		// like toNextDetail() but also checking byte 2 against rank
 		long newMatches = this.matches;
 		if (newMatches == 0)
@@ -224,8 +241,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	}
 
 	/** Walk to the bound of a wildcard. */
-	@Override
-	public ITypeAnnotationWalker toWildcardBound() {
+	public TypeAnnotationWalker toWildcardBound() {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -245,16 +261,14 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	/**
 	 * Descend down one level of array dimensions.
 	 */
-	@Override
-	public ITypeAnnotationWalker toNextArrayDimension() {
+	public TypeAnnotationWalker toNextArrayDimension() {
 		return toNextDetail(AnnotationTargetTypeConstants.NEXT_ARRAY_DIMENSION);
 	}
 	
 	/**
 	 * Descend down one level of type nesting.
 	 */
-	@Override
-	public ITypeAnnotationWalker toNextNestedType() {
+	public TypeAnnotationWalker toNextNestedType() {
 		return toNextDetail(AnnotationTargetTypeConstants.NEXT_NESTED_TYPE);
 	}
 
@@ -262,7 +276,7 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	 * Implementation for walking along the type_path for array dimensions & nested types.
 	 * FIXME(stephan): support wildcard bounds.
 	 */
-	protected ITypeAnnotationWalker toNextDetail(int detailKind) {
+	protected TypeAnnotationWalker toNextDetail(int detailKind) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -284,7 +298,6 @@ public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 	 * Retrieve the type annotations at the current position
 	 * reached by invocations of toXYZ() methods.
 	 */
-	@Override
 	public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
 		int length = this.typeAnnotations.length;
 		IBinaryAnnotation[] filtered = new IBinaryAnnotation[length];
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
deleted file mode 100644
index 26e95b7..0000000
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2014 GK Software AG.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     Stephan Herrmann - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.compiler.env;
-
-
-/**
- * A TypeAnnotationWalker is initialized with all type annotations found at a given element.
- * It can be used to walk into the types at the given element and finally answer the
- * actual annotations at any node of the walk.
- * 
- * The walker is implemented as immutable objects. During the walk either new instances
- * are created, or the current instance is shared if no difference is encountered.
- */
-public interface ITypeAnnotationWalker {
-
-	public static final IBinaryAnnotation[] NO_ANNOTATIONS = new IBinaryAnnotation[0];
-	/**
-	 * A no-effect annotation walker, all walking methods are implemented as identity-functions.
-	 * At the end of any walk an empty array of annotations is returned.
-	 */
-	public static final ITypeAnnotationWalker EMPTY_ANNOTATION_WALKER = new ITypeAnnotationWalker() {
-		public ITypeAnnotationWalker toField() { return this; }
-		public ITypeAnnotationWalker toThrows(int rank) { return this; }
-		public ITypeAnnotationWalker toTypeArgument(int rank) { return this; }
-		public ITypeAnnotationWalker toMethodParameter(short index) { return this; }
-		public ITypeAnnotationWalker toSupertype(short index) { return this; }
-		public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) { return this; }
-		public ITypeAnnotationWalker toTypeBound(short boundIndex) { return this; }
-		public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) { return this; }
-		public ITypeAnnotationWalker toMethodReturn() { return this; }
-		public ITypeAnnotationWalker toReceiver() { return this; }
-		public ITypeAnnotationWalker toWildcardBound() { return this; }
-		public ITypeAnnotationWalker toNextArrayDimension() { return this; }
-		public ITypeAnnotationWalker toNextNestedType() { return this; }
-		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) { return NO_ANNOTATIONS; }
-	};
-
-	/** Walk to a field. */
-	public abstract ITypeAnnotationWalker toField();
-
-
-	/** Walk to the return type of a method. */
-	public abstract ITypeAnnotationWalker toMethodReturn();
-
-	/**
-	 * Walk to the receiver type of a method.
-	 * Note: Type annotations on receiver are not currently used by the compiler.
-	 */
-	public abstract ITypeAnnotationWalker toReceiver();
-
-	/**
-	 * Walk to the type parameter of the given rank.
-	 * @param isClassTypeParameter whether we are looking for a class type parameter (else: method type type parameter)
-	 * @param rank rank of the type parameter
-	 */
-	public abstract ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank);
-
-	/**
-	 * Walk to the bounds of a type parameter of either a class or a method (signaled by isClassTypeParameter).
-	 * Clients must then call {@link #toTypeBound(short)} on the resulting walker.
-	 * @param isClassTypeParameter whether we are looking at a class type parameter (else: method type type parameter)
-	 * @param parameterRank rank of the type parameter.
-	 */
-	public abstract ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank);
-
-	/**
-	 * Detail of {@link #toTypeParameterBounds(boolean, int)}: walk to the bounds
-	 * of the previously selected type parameter. 
-	 * @param boundIndex
-	 */
-	public abstract ITypeAnnotationWalker toTypeBound(short boundIndex);
-
-	/** Walk to the specified supertype: -1 is superclass, else the superinterface at the given index. */
-	public abstract ITypeAnnotationWalker toSupertype(short index);
-
-	/** Walk to the index'th visible formal method parameter (i.e., not counting synthetic args). */
-	public abstract ITypeAnnotationWalker toMethodParameter(short index);
-
-	/**
-	 * Walk to the throws type at the given index.
-	 */
-	public abstract ITypeAnnotationWalker toThrows(int index);
-
-	/** Walk to the type argument of the given rank. */
-	public abstract ITypeAnnotationWalker toTypeArgument(int rank);
-
-	/** Walk to the bound of a wildcard. */
-	public abstract ITypeAnnotationWalker toWildcardBound();
-
-	/**
-	 * Descend down one level of array dimensions.
-	 */
-	public abstract ITypeAnnotationWalker toNextArrayDimension();
-
-	/**
-	 * Descend down one level of type nesting.
-	 */
-	public abstract ITypeAnnotationWalker toNextNestedType();
-
-	/**
-	 * Retrieve the type annotations at the current position
-	 * reached by invocations of toXYZ() methods.
-	 */
-	public abstract IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId);
-
-}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index a3a82ff..baf0271 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -29,7 +29,6 @@
  *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *								Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
  *								Bug 434602 - Possible error with inferred null annotations leading to contradictory null annotations
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *    Jesper Steen Moller - Contributions for
  *								Bug 412150 [1.8] [compiler] Enable reflected parameter names during annotation processing
  *								Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
@@ -41,7 +40,6 @@ import java.util.ArrayList;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.NonNullDefaultAwareTypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
@@ -92,12 +90,12 @@ static Object convertMemberValue(Object binaryValue, LookupEnvironment env, char
 	if (binaryValue instanceof Constant)
 		return binaryValue;
 	if (binaryValue instanceof ClassSignature)
-		return env.getTypeFromSignature(((ClassSignature) binaryValue).getTypeName(), 0, -1, false, null, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+		return env.getTypeFromSignature(((ClassSignature) binaryValue).getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 	if (binaryValue instanceof IBinaryAnnotation)
 		return createAnnotation((IBinaryAnnotation) binaryValue, env, missingTypeNames);
 	if (binaryValue instanceof EnumConstantSignature) {
 		EnumConstantSignature ref = (EnumConstantSignature) binaryValue;
-		ReferenceBinding enumType = (ReferenceBinding) env.getTypeFromSignature(ref.getTypeName(), 0, -1, false, null, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+		ReferenceBinding enumType = (ReferenceBinding) env.getTypeFromSignature(ref.getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 		if (enumType.isUnresolvedType() && !resolveEnumConstants)
 			return new ElementValuePair.UnresolvedEnumConstant(enumType, env, ref.getEnumConstantName());
 		enumType = (ReferenceBinding) resolveType(enumType, env, false /* no raw conversion */);
@@ -405,7 +403,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 			// need annotations on the type before processing null annotations on members respecting any @NonNullByDefault:
 			scanTypeForNullDefaultAnnotation(binaryType, this.fPackage, this);
 		}
-		ITypeAnnotationWalker walker = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
+		TypeAnnotationWalker walker = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
 		char[] typeSignature = binaryType.getGenericSignature(); // use generic signature even in 1.4
 		this.tagBits |= binaryType.getTagBits();
 		
@@ -475,7 +473,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 		if (needFieldsAndMethods) {
 			IBinaryField[] iFields = binaryType.getFields();
 			createFields(iFields, sourceLevel, missingTypeNames);
-			IBinaryMethod[] iMethods = createMethods(binaryType.getMethods(), binaryType, sourceLevel, missingTypeNames);
+			IBinaryMethod[] iMethods = createMethods(binaryType.getMethods(), sourceLevel, missingTypeNames);
 			boolean isViewedAsDeprecated = isViewedAsDeprecated();
 			if (isViewedAsDeprecated) {
 				for (int i = 0, max = this.fields.length; i < max; i++) {
@@ -515,7 +513,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 	}
 }
 
-private ITypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] annotations) {
+private TypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] annotations) {
 	if (!isPrototype()) throw new IllegalStateException();
 	if (annotations == null || annotations.length == 0 || !this.environment.usesAnnotatedTypeSystem()) {
 		if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
@@ -523,7 +521,7 @@ private ITypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] an
 			if (nullness > Binding.NULL_UNSPECIFIED_BY_DEFAULT)
 				return new NonNullDefaultAwareTypeAnnotationWalker(nullness, this.environment);
 		}
-		return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		return TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
 	}
 	if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
 		int nullness = getNullDefault();
@@ -546,7 +544,7 @@ private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] m
 			for (int i = 0; i < size; i++) {
 				IBinaryField binaryField = iFields[i];
 				char[] fieldSignature = use15specifics ? binaryField.getGenericSignature() : null;
-				ITypeAnnotationWalker walker = getTypeAnnotationWalker(binaryField.getTypeAnnotations()).toField();
+				TypeAnnotationWalker walker = getTypeAnnotationWalker(binaryField.getTypeAnnotations()).toField();
 				TypeBinding type = fieldSignature == null
 					? this.environment.getTypeFromSignature(binaryField.getTypeName(), 0, -1, false, this, missingTypeNames, walker)
 					: this.environment.getTypeFromTypeSignature(new SignatureWrapper(fieldSignature), Binding.NO_TYPE_VARIABLES, this, missingTypeNames, walker);
@@ -582,7 +580,7 @@ private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] m
 	}
 }
 
-private MethodBinding createMethod(IBinaryMethod method, IBinaryType binaryType, long sourceLevel, char[][][] missingTypeNames) {
+private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[][][] missingTypeNames) {
 	if (!isPrototype()) throw new IllegalStateException();
 	int methodModifiers = method.getModifiers() | ExtraCompilerModifiers.AccUnresolved;
 	if (sourceLevel < ClassFileConstants.JDK1_5)
@@ -608,13 +606,10 @@ private MethodBinding createMethod(IBinaryMethod method, IBinaryType binaryType,
 	   variables properly in order to be able to apply substitutions and thus be able to detect
 	   overriding in the presence of generics. Seeing the erased form is not good enough.
 	 */
-	ITypeAnnotationWalker walker = getTypeAnnotationWalker(method.getTypeAnnotations());
+	TypeAnnotationWalker walker = getTypeAnnotationWalker(method.getTypeAnnotations());
 	char[] methodSignature = method.getGenericSignature(); // always use generic signature, even in 1.4
 	if (methodSignature == null) { // no generics
 		char[] methodDescriptor = method.getMethodDescriptor();   // of the form (I[Ljava/jang/String;)V
-		if (walker == ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER && binaryType instanceof ClassFileReader) {// TODO: avoid cast? add method to IBinaryType?
-			walker = ((ClassFileReader)binaryType).getAnnotationsForMethod(method, methodDescriptor, this.environment);
-		}
 		int numOfParams = 0;
 		char nextChar;
 		int index = 0; // first character is always '(' so skip it
@@ -688,9 +683,6 @@ private MethodBinding createMethod(IBinaryMethod method, IBinaryType binaryType,
 		}
 
 	} else {
-		if (walker == ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER && binaryType instanceof ClassFileReader) {// TODO: avoid cast? add method to IBinaryType?
-			walker = ((ClassFileReader)binaryType).getAnnotationsForMethod(method, methodSignature, this.environment);
-		}
 		methodModifiers |= ExtraCompilerModifiers.AccGenericSignature;
 		// MethodTypeSignature = ParameterPart(optional) '(' TypeSignatures ')' return_typeSignature ['^' TypeSignature (optional)]
 		SignatureWrapper wrapper = new SignatureWrapper(methodSignature, use15specifics);
@@ -788,7 +780,7 @@ private MethodBinding createMethod(IBinaryMethod method, IBinaryType binaryType,
  * As some iMethods may be ignored in this process we return the matching array of those
  * iMethods for which MethodBindings have been created; indices match those in this.methods.
  */
-private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, IBinaryType binaryType, long sourceLevel, char[][][] missingTypeNames) {
+private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, long sourceLevel, char[][][] missingTypeNames) {
 	if (!isPrototype()) throw new IllegalStateException();
 	int total = 0, initialTotal = 0, iClinit = -1;
 	int[] toSkip = null;
@@ -823,7 +815,7 @@ private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, IBinaryType bina
 	this.methods = new MethodBinding[total];
 	if (total == initialTotal) {
 		for (int i = 0; i < initialTotal; i++) {
-			MethodBinding method = createMethod(iMethods[i], binaryType, sourceLevel, missingTypeNames);
+			MethodBinding method = createMethod(iMethods[i], sourceLevel, missingTypeNames);
 			if (hasRestrictedAccess)
 				method.modifiers |= ExtraCompilerModifiers.AccRestrictedAccess;
 			this.methods[i] = method;
@@ -833,7 +825,7 @@ private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, IBinaryType bina
 		IBinaryMethod[] mappedBinaryMethods = new IBinaryMethod[total];
 		for (int i = 0, index = 0; i < initialTotal; i++) {
 			if (iClinit != i && (toSkip == null || toSkip[i] != -1)) {
-				MethodBinding method = createMethod(iMethods[i], binaryType, sourceLevel, missingTypeNames);
+				MethodBinding method = createMethod(iMethods[i], sourceLevel, missingTypeNames);
 				if (hasRestrictedAccess)
 					method.modifiers |= ExtraCompilerModifiers.AccRestrictedAccess;
 				mappedBinaryMethods[index] = iMethods[i];
@@ -845,7 +837,7 @@ private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, IBinaryType bina
 }
 
 private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, boolean assignVariables, char[][][] missingTypeNames,
-													ITypeAnnotationWalker walker, boolean isClassTypeParameter)
+													TypeAnnotationWalker walker, boolean isClassTypeParameter)
 {
 	if (!isPrototype()) throw new IllegalStateException();
 	// detect all type variables first
@@ -962,7 +954,7 @@ private MethodBinding findMethod(char[] methodDescriptor, char[][][] missingType
 				while ((nextChar = methodDescriptor[++end]) != Util.C_NAME_END){/*empty*/}
 
 			// not interested in type annotations, type will be used for comparison only, and erasure() is used if needed
-			TypeBinding param = this.environment.getTypeFromSignature(methodDescriptor, index, end, false, this, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+			TypeBinding param = this.environment.getTypeFromSignature(methodDescriptor, index, end, false, this, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 			if (param instanceof UnresolvedReferenceBinding) {
 				param = resolveType(param, this.environment, true /* raw conversion */);
 			}
@@ -1233,7 +1225,7 @@ public boolean hasTypeBit(int bit) {
 	}
 	return (this.typeBits & bit) != 0;
 }
-private void initializeTypeVariable(TypeVariableBinding variable, TypeVariableBinding[] existingVariables, SignatureWrapper wrapper, char[][][] missingTypeNames, ITypeAnnotationWalker walker) {
+private void initializeTypeVariable(TypeVariableBinding variable, TypeVariableBinding[] existingVariables, SignatureWrapper wrapper, char[][][] missingTypeNames, TypeAnnotationWalker walker) {
 	if (!isPrototype()) throw new IllegalStateException();
 	// ParameterSignature = Identifier ':' TypeSignature
 	//   or Identifier ':' TypeSignature(optional) InterfaceBound(s)
@@ -1750,7 +1742,7 @@ private void scanTypeForContainerAnnotation(IBinaryType binaryType, char[][][] m
 				if (elementValuePairs != null && elementValuePairs.length == 1) {
 					Object value = elementValuePairs[0].getValue();
 					if (value instanceof ClassSignature) {
-						this.containerAnnotationType = (ReferenceBinding) this.environment.getTypeFromSignature(((ClassSignature)value).getTypeName(), 0, -1, false, null, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+						this.containerAnnotationType = (ReferenceBinding) this.environment.getTypeFromSignature(((ClassSignature)value).getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 					}
 				}
 				break;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 53da641..8144e21 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -27,7 +27,6 @@
  *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *								Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
  *								Bug 434602 - Possible error with inferred null annotations leading to contradictory null annotations
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -42,6 +41,7 @@ import org.eclipse.jdt.internal.compiler.ClassFilePool;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.ITypeRequestor;
@@ -1164,7 +1164,7 @@ public ReferenceBinding getType(char[][] compoundName) {
 }
 
 private TypeBinding[] getTypeArgumentsFromSignature(SignatureWrapper wrapper, TypeVariableBinding[] staticVariables, ReferenceBinding enclosingType, ReferenceBinding genericType,
-		char[][][] missingTypeNames, ITypeAnnotationWalker walker)
+		char[][][] missingTypeNames, TypeAnnotationWalker walker)
 {
 	java.util.ArrayList args = new java.util.ArrayList(2);
 	int rank = 0;
@@ -1217,7 +1217,7 @@ private ReferenceBinding getTypeFromCompoundName(char[][] compoundName, boolean
 *
 * NOTE: Does NOT answer base types nor array types!
 */
-ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int end, boolean isParameterized, char[][][] missingTypeNames, ITypeAnnotationWalker walker) {
+ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int end, boolean isParameterized, char[][][] missingTypeNames, TypeAnnotationWalker walker) {
 	if (end == -1)
 		end = signature.length;
 	char[][] compoundName = CharOperation.splitOn('/', signature, start, end);
@@ -1231,14 +1231,14 @@ ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int en
 		}
 	}
 	ReferenceBinding binding = getTypeFromCompoundName(compoundName, isParameterized, wasMissingType);
-	if (walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		binding = (ReferenceBinding) annotateType(binding, walker, missingTypeNames);
 	}
 	return binding;
 }
 
 ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int end, boolean isParameterized, char[][][] missingTypeNames) {
-	return getTypeFromConstantPoolName(signature, start, end, isParameterized, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+	return getTypeFromConstantPoolName(signature, start, end, isParameterized, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 }
 
 /* Answer the type corresponding to the signature from the binary file.
@@ -1248,7 +1248,7 @@ ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int en
 * NOTE: Does answer base types & array types.
 */
 TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean isParameterized, TypeBinding enclosingType, 
-		char[][][] missingTypeNames, ITypeAnnotationWalker walker)
+		char[][][] missingTypeNames, TypeAnnotationWalker walker)
 {
 	int dimension = 0;
 	while (signature[start] == '[') {
@@ -1257,7 +1257,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 	}
 	// annotations on dimensions?
 	AnnotationBinding [][] annotationsOnDimensions = null;
-	if (dimension > 0 && walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (dimension > 0 && walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		for (int i = 0; i < dimension; i++) {
 			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0), this, missingTypeNames);
 			if (annotations != Binding.NO_ANNOTATIONS) { 
@@ -1317,7 +1317,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 		return binding;
 	}
 	
-	if (walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		binding = annotateType(binding, walker, missingTypeNames);
 	}
 	
@@ -1327,7 +1327,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 	return binding;
 }
 
-private TypeBinding annotateType(TypeBinding binding, ITypeAnnotationWalker walker, char[][][] missingTypeNames) {
+private TypeBinding annotateType(TypeBinding binding, TypeAnnotationWalker walker, char[][][] missingTypeNames) {
 	int depth = binding.depth() + 1;
 	if (depth > 1) {
 		// need to count non-static nesting levels, resolved binding required for precision
@@ -1373,7 +1373,7 @@ boolean qualifiedNameMatchesSignature(char[][] name, char[] signature) {
 }
 
 public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariableBinding[] staticVariables, ReferenceBinding enclosingType, 
-		char[][][] missingTypeNames, ITypeAnnotationWalker walker) 
+		char[][][] missingTypeNames, TypeAnnotationWalker walker) 
 {
 	// TypeVariableSignature = 'T' Identifier ';'
 	// ArrayTypeSignature = '[' TypeSignature
@@ -1387,7 +1387,7 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 	}
 	// annotations on dimensions?
 	AnnotationBinding [][] annotationsOnDimensions = null;
-	if (dimension > 0 && walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (dimension > 0 && walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		for (int i = 0; i < dimension; i++) {
 			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0), this, missingTypeNames);
 			if (annotations != Binding.NO_ANNOTATIONS) { 
@@ -1461,7 +1461,7 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 	return dimension == 0 ? (TypeBinding) parameterizedType : createArrayType(parameterizedType, dimension, AnnotatableTypeSystem.flattenedAnnotations(annotationsOnDimensions));
 }
 
-private TypeBinding getTypeFromTypeVariable(TypeVariableBinding typeVariableBinding, int dimension, AnnotationBinding [][] annotationsOnDimensions, ITypeAnnotationWalker walker, char [][][] missingTypeNames) {
+private TypeBinding getTypeFromTypeVariable(TypeVariableBinding typeVariableBinding, int dimension, AnnotationBinding [][] annotationsOnDimensions, TypeAnnotationWalker walker, char [][][] missingTypeNames) {
 	AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0), this, missingTypeNames);
 	if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
 		typeVariableBinding = (TypeVariableBinding) createAnnotatedType(typeVariableBinding, new AnnotationBinding [][] { annotations });
@@ -1479,7 +1479,7 @@ TypeBinding getTypeFromVariantTypeSignature(
 		ReferenceBinding genericType,
 		int rank,
 		char[][][] missingTypeNames,
-		ITypeAnnotationWalker walker) {
+		TypeAnnotationWalker walker) {
 	// VariantTypeSignature = '-' TypeSignature
 	//   or '+' TypeSignature
 	//   or TypeSignature
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathEntry.java
index 0aa30ad..8c882fd 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathEntry.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,8 +7,6 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.core;
 
@@ -474,11 +472,4 @@ public interface IClasspathEntry {
 	 * @deprecated Use {@link JavaCore#getResolvedClasspathEntry(IClasspathEntry)} instead
 	 */
 	IClasspathEntry getResolvedEntry();
-
-	/**
-	 * Returns the location where external annotation files can be found to assist
-	 * annotation based null analysis of 3rd party libraries.
-	 * @since 3.11
-	 */
-	IPath getExternalAnnotationPath();
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
index 320dafa..c1ed588 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IPackageFragmentRoot.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,8 +15,6 @@
  *     IBM Corporation - added NO_RESOURCE_MODIFICATION
  *     IBM Corporation - added REPLACE
  *     IBM Corporation - added ORIGINATING_PROJECT_CLASSPATH
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.core;
 
@@ -352,19 +350,6 @@ public interface IPackageFragmentRoot
 	IPath getSourceAttachmentRootPath() throws JavaModelException;
 
 	/**
-	 * Returns the absolute path to the location where external annotations can be
-	 * found to support annotation based null analysis involving 3rd party libraries.
-	 * 
-	 * @return the absolute path to the corresponding external annotations,
-	 *   or <code>null</code> if this package fragment root's binary archive
-	 *   has no corresponding external annotations, or if this package fragment root
-	 *   is not a binary archive
-	 * @exception JavaModelException if this operation fails
-	 * @since 3.11
-	 */
-	IPath getExternalAnnotationPath() throws JavaModelException;
-	
-	/**
 	 * Returns whether this package fragment root's underlying
 	 * resource is a binary archive (a JAR or zip file).
 	 * <p>
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 9d7f43a..f34eba2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -98,8 +98,6 @@
  *									COMPILER_INHERIT_NULL_ANNOTATIONS
  *									COMPILER_PB_NONNULL_PARAMETER_ANNOTATION_DROPPED
  *									COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *     Jesper S Moller   - Contributions for bug 381345 : [1.8] Take care of the Java 8 major version
  *                       - added the following constants:
  *									COMPILER_CODEGEN_METHOD_PARAMETERS_ATTR
@@ -4452,92 +4450,6 @@ public final class JavaCore extends Plugin {
 			IAccessRule[] accessRules,
 			IClasspathAttribute[] extraAttributes,
 			boolean isExported) {
-		return newContainerEntry(containerPath, accessRules, null, extraAttributes, isExported);
-	}
-
-	/**
-	 * Creates and returns a new classpath entry of kind <code>CPE_CONTAINER</code>
-	 * for the given path. The path of the container will be used during resolution so as to map this
-	 * container entry to a set of other classpath entries the container is acting for.
-	 * <p>
-	 * A container entry allows to express indirect references to a set of libraries, projects and variable entries,
-	 * which can be interpreted differently for each Java project where it is used.
-	 * A classpath container entry can be resolved using <code>JavaCore.getResolvedClasspathContainer</code>,
-	 * and updated with <code>JavaCore.classpathContainerChanged</code>
-	 * </p>
-	 * <p>
-	 * A container is exclusively resolved by a <code>ClasspathContainerInitializer</code> registered onto the
-	 * extension point "org.eclipse.jdt.core.classpathContainerInitializer".
-	 * </p>
-	 * <p>
-	 * A container path must be formed of at least one segment, where:
-	 * </p>
-	 * <ul>
-	 * <li> the first segment is a unique ID identifying the target container, there must be a container initializer registered
-	 * 	onto this ID through the extension point  "org.eclipse.jdt.core.classpathContainerInitializer". </li>
-	 * <li> the remaining segments will be passed onto the initializer, and can be used as additional
-	 * 	hints during the initialization phase. </li>
-	 * </ul>
-	 * <p>
-	 * Example of an ClasspathContainerInitializer for a classpath container denoting a default JDK container:
-	 * </p>
-	 * <pre>
-	 * containerEntry = JavaCore.newContainerEntry(new Path("MyProvidedJDK/default"));
-	 *
-	 * &lt;extension
-	 *    point="org.eclipse.jdt.core.classpathContainerInitializer"&gt;
-	 *    &lt;containerInitializer
-	 *       id="MyProvidedJDK"
-	 *       class="com.example.MyInitializer"/&gt;
-	 * </pre>
-	 * <p>
-	 * The access rules determine the set of accessible source and class files
-	 * in the container. If the list of access rules is empty, then all files
-	 * in this container are accessible.
-	 * See {@link IAccessRule} for a detailed description of access
-	 * rules. Note that if an entry defined by the container defines access rules,
-	 * then these access rules are combined with the given access rules.
-	 * The given access rules are considered first, then the entry's access rules are
-	 * considered.
-	 * </p>
-	 * <p>
-	 * The <code>extraAttributes</code> list contains name/value pairs that must be persisted with
-	 * this entry. If no extra attributes are provided, an empty array must be passed in.<br>
-	 * Note that this list should not contain any duplicate name.
-	 * </p>
-	 * <p>
-	 * The <code>isExported</code> flag indicates whether this entry is contributed to dependent
-	 * projects. If not exported, dependent projects will not see any of the classes from this entry.
-	 * If exported, dependent projects will concatenate the accessible files patterns of this entry with the
-	 * accessible files patterns of the projects, and they will concatenate the non accessible files patterns of this entry
-	 * with the non accessible files patterns of the project.
-	 * </p>
-	 * <p>
-	 * Note that this operation does not attempt to validate classpath containers
-	 * or access the resources at the given paths.
-	 * </p>
-	 *
-	 * @param containerPath the path identifying the container, it must be formed of at least
-	 * 	one segment (ID+hints)
-	 * @param accessRules the possibly empty list of access rules for this entry
-	 * @param externalAnnotationPath the location where external annotations are found for annotation based null analysis
-	 * @param extraAttributes the possibly empty list of extra attributes to persist with this entry
-	 * @param isExported a boolean indicating whether this entry is contributed to dependent
-	 *    projects in addition to the output location
-	 * @return a new container classpath entry
-	 *
-	 * @see JavaCore#getClasspathContainer(IPath, IJavaProject)
-	 * @see JavaCore#setClasspathContainer(IPath, IJavaProject[], IClasspathContainer[], IProgressMonitor)
-	 * @see JavaCore#newContainerEntry(IPath, boolean)
-	 * @see JavaCore#newAccessRule(IPath, int)
-	 * @since 3.11
-	 */
-	public static IClasspathEntry newContainerEntry(
-			IPath containerPath,
-			IAccessRule[] accessRules,
-			IPath externalAnnotationPath,
-			IClasspathAttribute[] extraAttributes,
-			boolean isExported) {
 
 		if (containerPath == null) {
 			throw new ClasspathEntry.AssertionFailedException("Container path cannot be null"); //$NON-NLS-1$
@@ -4558,7 +4470,6 @@ public final class JavaCore extends Plugin {
 			ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 			null, // source attachment
 			null, // source attachment root
-			externalAnnotationPath,
 			null, // specific output folder
 			isExported,
 			accessRules,
@@ -4742,86 +4653,6 @@ public final class JavaCore extends Plugin {
 			IAccessRule[] accessRules,
 			IClasspathAttribute[] extraAttributes,
 			boolean isExported) {
-		return newLibraryEntry(path, sourceAttachmentPath, sourceAttachmentRootPath, null, accessRules, extraAttributes, isExported);
-	}
-
-	/**
-	 * Creates and returns a new classpath entry of kind <code>CPE_LIBRARY</code> for the JAR or folder
-	 * identified by the given absolute path. This specifies that all package fragments within the root
-	 * will have children of type <code>IClassFile</code>.
-	 * <p>
-	 * A library entry is used to denote a prerequisite JAR or root folder containing binaries.
-	 * The target JAR can either be defined internally to the workspace (absolute path relative
-	 * to the workspace root), or externally to the workspace (absolute path in the file system).
-	 * The target root folder can also be defined internally to the workspace (absolute path relative
-	 * to the workspace root), or - since 3.4 - externally to the workspace (absolute path in the file system).
-	 * Since 3.5, the path to the library can also be relative to the project using ".." as the first segment. 
-	 * </p>
-	 * <p>
-	 * e.g. Here are some examples of binary path usage
-	 * </p>
-	 *	<ul>
-	 *	<li><code> "c:\jdk1.2.2\jre\lib\rt.jar" </code> - reference to an external JAR on Windows</li>
-	 *	<li><code> "/Project/someLib.jar" </code> - reference to an internal JAR on Windows or Linux</li>
-	 *	<li><code> "/Project/classes/" </code> - reference to an internal binary folder on Windows or Linux</li>
-	 *	<li><code> "/home/usr/classes" </code> - reference to an external binary folder on Linux</li>
-	 *	<li><code> "../../lib/someLib.jar" </code> - reference to an external JAR that is a sibling of the workspace on either platform</li>
-	 * </ul>
-	 * Note that on non-Windows platform, a path <code>"/some/lib.jar"</code> is ambiguous.
-	 * It can be a path to an external JAR (its file system path being <code>"/some/lib.jar"</code>)
-	 * or it can be a path to an internal JAR (<code>"some"</code> being a project in the workspace).
-	 * Such an ambiguity is solved when the classpath entry is used (e.g. in {@link IJavaProject#getPackageFragmentRoots()}).
-	 * If the resource <code>"lib.jar"</code> exists in project <code>"some"</code>, then it is considered an
-	 * internal JAR. Otherwise it is an external JAR.
-	 * <p>Also note that this operation does not attempt to validate or access the
-	 * resources at the given paths.
-	 * </p><p>
-	 * The access rules determine the set of accessible class files
-	 * in the library. If the list of access rules is empty then all files
-	 * in this library are accessible.
-	 * See {@link IAccessRule} for a detailed description of access
-	 * rules.
-	 * </p>
-	 * <p>
-	 * The <code>extraAttributes</code> list contains name/value pairs that must be persisted with
-	 * this entry. If no extra attributes are provided, an empty array must be passed in.<br>
-	 * Note that this list should not contain any duplicate name.
-	 * </p>
-	 * <p>
-	 * The <code>isExported</code> flag indicates whether this entry is contributed to dependent
-	 * projects. If not exported, dependent projects will not see any of the classes from this entry.
-	 * If exported, dependent projects will concatenate the accessible files patterns of this entry with the
-	 * accessible files patterns of the projects, and they will concatenate the non accessible files patterns of this entry
-	 * with the non accessible files patterns of the project.
-	 * </p>
-	 * <p>
-	 * Since 3.5, if the library is a ZIP archive, the "Class-Path" clause (if any) in the "META-INF/MANIFEST.MF" is read
-	 * and referenced ZIP archives are added to the {@link IJavaProject#getResolvedClasspath(boolean) resolved classpath}.
-	 * </p>
-	 *
-	 * @param path the path to the library
-	 * @param sourceAttachmentPath the absolute path of the corresponding source archive or folder,
-	 *    or <code>null</code> if none. Note, since 3.0, an empty path is allowed to denote no source attachment.
-	 *   and will be automatically converted to <code>null</code>. Since 3.4, this path can also denote a path external
-	 *   to the workspace.
-	 * @param sourceAttachmentRootPath the location of the root of the source files within the source archive or folder
-	 *    or <code>null</code> if this location should be automatically detected.
-	 * @param externalAnnotationPath the location where external annotations are found for annotation based null analysis
-	 * @param accessRules the possibly empty list of access rules for this entry
-	 * @param extraAttributes the possibly empty list of extra attributes to persist with this entry
-	 * @param isExported indicates whether this entry is contributed to dependent
-	 * 	  projects in addition to the output location
-	 * @return a new library classpath entry
-	 * @since 3.11
-	 */
-	public static IClasspathEntry newLibraryEntry(
-			IPath path,
-			IPath sourceAttachmentPath,
-			IPath sourceAttachmentRootPath,
-			IPath externalAnnotationPath,
-			IAccessRule[] accessRules,
-			IClasspathAttribute[] extraAttributes,
-			boolean isExported) {
 
 		if (path == null) throw new ClasspathEntry.AssertionFailedException("Library path cannot be null"); //$NON-NLS-1$
 		if (accessRules == null) {
@@ -4849,7 +4680,6 @@ public final class JavaCore extends Plugin {
 			ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 			sourceAttachmentPath,
 			sourceAttachmentRootPath,
-			externalAnnotationPath,
 			null, // specific output folder
 			isExported,
 			accessRules,
@@ -4970,7 +4800,6 @@ public final class JavaCore extends Plugin {
 			ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 			null, // source attachment
 			null, // source attachment root
-			null, // external annotation path
 			null, // specific output folder
 			isExported,
 			accessRules,
@@ -5182,7 +5011,6 @@ public final class JavaCore extends Plugin {
 			exclusionPatterns,
 			null, // source attachment
 			null, // source attachment root
-			null, // external annotation path
 			specificOutputLocation, // custom output location
 			false,
 			null,
@@ -5317,80 +5145,6 @@ public final class JavaCore extends Plugin {
 			IAccessRule[] accessRules,
 			IClasspathAttribute[] extraAttributes,
 			boolean isExported) {
-		return newVariableEntry(variablePath, variableSourceAttachmentPath, variableSourceAttachmentRootPath, null, accessRules, extraAttributes, isExported);
-	}
-
-	/**
-	 * Creates and returns a new classpath entry of kind <code>CPE_VARIABLE</code>
-	 * for the given path. The first segment of the path is the name of a classpath variable.
-	 * The trailing segments of the path will be appended to resolved variable path.
-	 * <p>
-	 * A variable entry allows to express indirect references on a classpath to other projects or libraries,
-	 * depending on what the classpath variable is referring.
-	 * </p>
-	 * <p>
-	 * It is possible to register an automatic initializer (<code>ClasspathVariableInitializer</code>),
-	 * which will be invoked through the extension point "org.eclipse.jdt.core.classpathVariableInitializer".
-	 * After resolution, a classpath variable entry may either correspond to a project or a library entry.
-	 * </p>
-	 * <p>
-	 * e.g. Here are some examples of variable path usage
-	 * </p>
-	 * <ul>
-	 * <li> "JDTCORE" where variable <code>JDTCORE</code> is
-	 *		bound to "c:/jars/jdtcore.jar". The resolved classpath entry is denoting the library "c:\jars\jdtcore.jar"</li>
-	 * <li> "JDTCORE" where variable <code>JDTCORE</code> is
-	 *		bound to "/Project_JDTCORE". The resolved classpath entry is denoting the project "/Project_JDTCORE"</li>
-	 * <li> "PLUGINS/com.example/example.jar" where variable <code>PLUGINS</code>
-	 *      is bound to "c:/eclipse/plugins". The resolved classpath entry is denoting the library "c:\eclipse\plugins\com.example\example.jar"</li>
-	 * </ul>
-	 * <p>
-	 * The access rules determine the set of accessible class files
-	 * in the project or library. If the list of access rules is empty then all files
-	 * in this project or library are accessible.
-	 * See {@link IAccessRule} for a detailed description of access rules.
-	 * </p>
-	 * <p>
-	 * The <code>extraAttributes</code> list contains name/value pairs that must be persisted with
-	 * this entry. If no extra attributes are provided, an empty array must be passed in.<br>
-	 * Note that this list should not contain any duplicate name.
-	 * </p>
-	 * <p>
-	 * The <code>isExported</code> flag indicates whether this entry is contributed to dependent
-	 * projects. If not exported, dependent projects will not see any of the classes from this entry.
-	 * If exported, dependent projects will concatenate the accessible files patterns of this entry with the
-	 * accessible files patterns of the projects, and they will concatenate the non accessible files patterns of this entry
-	 * with the non accessible files patterns of the project.
-	 * </p>
-	 * <p>
-	 * Note that this operation does not attempt to validate classpath variables
-	 * or access the resources at the given paths.
-	 * </p>
-	 *
-	 * @param variablePath the path of the binary archive; first segment is the
-	 *   name of a classpath variable
-	 * @param variableSourceAttachmentPath the path of the corresponding source archive,
-	 *    or <code>null</code> if none; if present, the first segment is the
-	 *    name of a classpath variable (not necessarily the same variable
-	 *    as the one that begins <code>variablePath</code>)
-	 * @param variableSourceAttachmentRootPath the location of the root of the source files within the source archive
-	 *    or <code>null</code> if <code>variableSourceAttachmentPath</code> is also <code>null</code>
-	 * @param externalAnnotationPath the location where external annotations are found for annotation based null analysis
-	 * @param accessRules the possibly empty list of access rules for this entry
-	 * @param extraAttributes the possibly empty list of extra attributes to persist with this entry
-	 * @param isExported indicates whether this entry is contributed to dependent
-	 * 	  projects in addition to the output location
-	 * @return a new variable classpath entry
-	 * @since 3.11
-	 */
-	public static IClasspathEntry newVariableEntry(
-			IPath variablePath,
-			IPath variableSourceAttachmentPath,
-			IPath variableSourceAttachmentRootPath,
-			IPath externalAnnotationPath, 
-			IAccessRule[] accessRules, 
-			IClasspathAttribute[] extraAttributes,
-			boolean isExported) {
 
 		if (variablePath == null) throw new ClasspathEntry.AssertionFailedException("Variable path cannot be null"); //$NON-NLS-1$
 		if (variablePath.segmentCount() < 1) {
@@ -5411,14 +5165,13 @@ public final class JavaCore extends Plugin {
 			ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 			variableSourceAttachmentPath, // source attachment
 			variableSourceAttachmentRootPath, // source attachment root
-			externalAnnotationPath,
 			null, // specific output folder
 			isExported,
 			accessRules,
 			false, // no access rules to combine
 			extraAttributes);
 	}
-
+	
 	/**
 	 * Returns an array of classpath entries that are referenced directly or indirectly 
 	 * by a given classpath entry. For the entry kind {@link IClasspathEntry#CPE_LIBRARY}, 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index b94678e..fde3a86 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,8 +7,6 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
@@ -349,7 +347,7 @@ private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyIniti
 		if (ze != null) {
 			byte contents[] = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
 			String fileName = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
-			return new ClassFileReader(contents, fileName.toCharArray(), fullyInitialize, root.getExternalAnnotationPath());
+			return new ClassFileReader(contents, fileName.toCharArray(), fullyInitialize);
 		}
 	} finally {
 		JavaModelManager.getJavaModelManager().closeZipFile(zip);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
index 837d37c..af3a661 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,8 +9,6 @@
  *     IBM Corporation - initial API and implementation
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425
  *     Thirumala Reddy Mutchukota <thirumala@google.com> - Avoid optional library classpath entries validation - https://bugs.eclipse.org/bugs/show_bug.cgi?id=412882
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
@@ -88,7 +86,6 @@ public class ClasspathEntry implements IClasspathEntry {
 	public static final String TAG_OUTPUT = "output"; //$NON-NLS-1$
 	public static final String TAG_KIND = "kind"; //$NON-NLS-1$
 	public static final String TAG_PATH = "path"; //$NON-NLS-1$
-	public static final String TAG_ANNOTATION_PATH = "annotationpath"; //$NON-NLS-1$
 	public static final String TAG_SOURCEPATH = "sourcepath"; //$NON-NLS-1$
 	public static final String TAG_ROOTPATH = "rootpath"; //$NON-NLS-1$
 	public static final String TAG_EXPORTED = "exported"; //$NON-NLS-1$
@@ -142,8 +139,6 @@ public class ClasspathEntry implements IClasspathEntry {
 	 */
 	public IPath path;
 
-	private IPath externalAnnotationPath;
-
 	/**
 	 * Patterns allowing to include/exclude portions of the resource tree denoted by this entry path.
 	 */
@@ -244,7 +239,6 @@ public class ClasspathEntry implements IClasspathEntry {
 			IPath[] exclusionPatterns,
 			IPath sourceAttachmentPath,
 			IPath sourceAttachmentRootPath,
-			IPath externalAnnotationPath,
 			IPath specificOutputLocation,
 			boolean isExported,
 			IAccessRule[] accessRules,
@@ -258,7 +252,6 @@ public class ClasspathEntry implements IClasspathEntry {
 				exclusionPatterns, 
 				sourceAttachmentPath, 
 				sourceAttachmentRootPath, 
-				externalAnnotationPath,
 				specificOutputLocation,
 				null,
 				isExported,
@@ -278,7 +271,6 @@ public class ClasspathEntry implements IClasspathEntry {
 		IPath[] exclusionPatterns,
 		IPath sourceAttachmentPath,
 		IPath sourceAttachmentRootPath,
-		IPath externalAnnotationPath,
 		IPath specificOutputLocation,
 		IClasspathEntry referencingEntry,
 		boolean isExported,
@@ -329,7 +321,6 @@ public class ClasspathEntry implements IClasspathEntry {
 	    }
 		this.sourceAttachmentPath = sourceAttachmentPath;
 		this.sourceAttachmentRootPath = sourceAttachmentRootPath;
-		this.externalAnnotationPath = externalAnnotationPath;
 		this.specificOutputLocation = specificOutputLocation;
 		this.isExported = isExported;
 	}
@@ -343,11 +334,8 @@ public class ClasspathEntry implements IClasspathEntry {
 	 */
 	public ClasspathEntry combineWith(ClasspathEntry referringEntry) {
 		if (referringEntry == null) return this;
-		if (referringEntry.isExported() || referringEntry.getAccessRuleSet() != null || referringEntry.getExternalAnnotationPath() != null) {
+		if (referringEntry.isExported() || referringEntry.getAccessRuleSet() != null ) {
 			boolean combine = this.entryKind == CPE_SOURCE || referringEntry.combineAccessRules();
-			IPath externalAnnotations = referringEntry.getExternalAnnotationPath(); // give precedence to this one
-			if (externalAnnotations == null)
-				externalAnnotations = getExternalAnnotationPath();
 			return new ClasspathEntry(
 								getContentKind(),
 								getEntryKind(),
@@ -356,7 +344,6 @@ public class ClasspathEntry implements IClasspathEntry {
 								this.exclusionPatterns,
 								getSourceAttachmentPath(),
 								getSourceAttachmentRootPath(),
-								externalAnnotations,
 								getOutputLocation(),
 								referringEntry.isExported() || this.isExported, // duplicate container entry for tagging it as exported
 								combine(referringEntry.getAccessRules(), getAccessRules(), combine),
@@ -579,9 +566,6 @@ public class ClasspathEntry implements IClasspathEntry {
 		if (this.sourceAttachmentRootPath != null) {
 			parameters.put(TAG_ROOTPATH, String.valueOf(this.sourceAttachmentRootPath));
 		}
-		if (this.externalAnnotationPath != null) {
-			parameters.put(TAG_ANNOTATION_PATH, String.valueOf(this.externalAnnotationPath));
-		}
 		if (this.isExported) {
 			parameters.put(TAG_EXPORTED, "true");//$NON-NLS-1$
 		}
@@ -694,7 +678,6 @@ public class ClasspathEntry implements IClasspathEntry {
 		boolean[] foundChildren = new boolean[children.getLength()];
 		String kindAttr = removeAttribute(TAG_KIND, attributes);
 		String pathAttr = removeAttribute(TAG_PATH, attributes);
-		String annotationPathAttr = removeAttribute(TAG_ANNOTATION_PATH, attributes);
 
 		// ensure path is absolute
 		IPath path = new Path(pathAttr);
@@ -704,12 +687,6 @@ public class ClasspathEntry implements IClasspathEntry {
 				path = projectPath.append(path);
 			}
 		}
-		IPath annotationPath = annotationPathAttr.isEmpty() ? null : new Path(annotationPathAttr);
-		if (annotationPath != null && !annotationPath.isAbsolute()) {
-			if (!(annotationPath.segmentCount() > 0 && annotationPath.segment(0).equals(ClasspathEntry.DOT_DOT))) {
-				annotationPath = project.getProject().getLocation().append(annotationPath);
-			}
-		}
 		// source attachment info (optional)
 		IPath sourceAttachmentPath =
 			element.hasAttribute(TAG_SOURCEPATH)
@@ -795,7 +772,6 @@ public class ClasspathEntry implements IClasspathEntry {
 												ClasspathEntry.EXCLUDE_NONE, // exclusion patterns
 												null, // source attachment
 												null, // source attachment root
-												null, // external annotation path
 												null, // specific output folder
 												isExported,
 												accessRules,
@@ -867,7 +843,6 @@ public class ClasspathEntry implements IClasspathEntry {
 												EXCLUDE_NONE,
 												null, // source attachment
 												null, // source attachment root
-												null, // external annotation path
 												null, // custom output location
 												false,
 												null, // no access rules
@@ -885,8 +860,6 @@ public class ClasspathEntry implements IClasspathEntry {
 			unknownElements.put(path, unknownXmlElements);
 		}
 
-		if (entry instanceof ClasspathEntry && kind != ClasspathEntry.K_OUTPUT && annotationPath != null)
-			((ClasspathEntry)entry).externalAnnotationPath = annotationPath;
 		return entry;
 	}
 	
@@ -1272,13 +1245,6 @@ public class ClasspathEntry implements IClasspathEntry {
 		return this.sourceAttachmentRootPath;
 	}
 
-	/**
-	 * @see IClasspathEntry
-	 */
-	public IPath getExternalAnnotationPath() {
-		return this.externalAnnotationPath;
-	}
-
 
 	public IClasspathEntry getReferencingEntry() {
 		return this.referencingEntry;
@@ -1428,11 +1394,6 @@ public class ClasspathEntry implements IClasspathEntry {
 			buffer.append(getSourceAttachmentRootPath());
 			buffer.append(']');
 		}
-		if (getExternalAnnotationPath() != null) {
-			buffer.append("[annotationPath:"); //$NON-NLS-1$
-			buffer.append(getExternalAnnotationPath());
-			buffer.append(']');
-		}
 		buffer.append("[isExported:"); //$NON-NLS-1$
 		buffer.append(this.isExported);
 		buffer.append(']');
@@ -1499,7 +1460,6 @@ public class ClasspathEntry implements IClasspathEntry {
 							this.exclusionPatterns,
 							getSourceAttachmentPath(),
 							getSourceAttachmentRootPath(),
-							getExternalAnnotationPath(),
 							getOutputLocation(),
 							this.getReferencingEntry(),
 							this.isExported,
@@ -1528,7 +1488,6 @@ public class ClasspathEntry implements IClasspathEntry {
 					this.exclusionPatterns,
 					null,
 					null,
-					null,
 					getOutputLocation(),
 					this,
 					this.isExported,
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index d3525dd..30bc98a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -10,9 +10,7 @@
  *     Theodora Yeung (tyeung@bea.com) - ensure that JarPackageFragmentRoot make it into cache
  *                                                           before its contents
  *                                                           (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=102422)
- *     Stephan Herrmann - Contribution for
- *								Bug 346010 - [model] strange initialization dependency in OptionTests
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
+ *     Stephan Herrmann - Contribution for Bug 346010 - [model] strange initialization dependency in OptionTests
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425
  *     Thirumala Reddy Mutchukota <thirumala@google.com> - Contribution to bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=411423
  *     Terry Parker <tparker@google.com> - [performance] Low hit rates in JavaModel caches - https://bugs.eclipse.org/421165
@@ -2558,8 +2556,6 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 						resolvedPath,
 						getResolvedVariablePath(entry.getSourceAttachmentPath(), usePreviousSession),
 						getResolvedVariablePath(entry.getSourceAttachmentRootPath(), usePreviousSession),
-						entry.getExternalAnnotationPath(),
-//TODO:var resolving?	getResolvedVariablePath(entry.getAnnotationPath(), usePreviousSession),
 						entry.getAccessRules(),
 						entry.getExtraAttributes(),
 						entry.isExported());
@@ -2570,8 +2566,6 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 							resolvedPath,
 							getResolvedVariablePath(entry.getSourceAttachmentPath(), usePreviousSession),
 							getResolvedVariablePath(entry.getSourceAttachmentRootPath(), usePreviousSession),
-							entry.getExternalAnnotationPath(),
-//TODO:var resolving?		getResolvedVariablePath(entry.getAnnotationPath(), usePreviousSession),
 							entry.getAccessRules(),
 							entry.getExtraAttributes(),
 							entry.isExported());
@@ -3562,7 +3556,7 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 
 			IClasspathEntry entry = new ClasspathEntry(contentKind, entryKind,
 					path, inclusionPatterns, exclusionPatterns,
-					sourceAttachmentPath, sourceAttachmentRootPath, null, // FIXME(SH): persistent external annotation location
+					sourceAttachmentPath, sourceAttachmentRootPath,
 					specificOutputLocation, isExported, accessRules,
 					combineAccessRules, extraAttributes);
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index 4412328..beba74d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -7,8 +7,6 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
@@ -631,44 +629,6 @@ public IPath getSourceAttachmentPath() throws JavaModelException {
 }
 
 /**
- * @see IPackageFragmentRoot
- */
-public IPath getExternalAnnotationPath() throws JavaModelException {
-	if (getKind() != K_BINARY) return null;
-
-	// partially modeled after getSourceAttachmentPath()
-/*
-	// 1) look source attachment property (set iff attachSource(...) was called
-	IPath path = getPath();
-	String serverPathString= Util.getSourceAttachmentProperty(path);
-	if (serverPathString != null) {
-		int index= serverPathString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER);
-		if (index < 0) {
-			// no root path specified
-			return new Path(serverPathString);
-		} else {
-			String serverSourcePathString= serverPathString.substring(0, index);
-			return new Path(serverSourcePathString);
-		}
-	}
-*/
-	
-	// 2) look at classpath entry
-	IClasspathEntry entry = ((JavaProject) getParent()).getClasspathEntryFor(getPath());
-	IPath externalAnnotationPath;
-	if (entry != null && (externalAnnotationPath = entry.getExternalAnnotationPath()) != null)
-		return externalAnnotationPath;
-/*
-	// 3) look for a recommendation
-	entry = findSourceAttachmentRecommendation();
-	if (entry != null && (externalAnnotationPath = entry.getSourceAttachmentPath()) != null) {
-		return externalAnnotationPath;
-	}
-*/
-	return null;
-}
-
-/**
  * For use by <code>AttachSourceOperation</code> only.
  * Sets the source mapper associated with this root.
  */
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 7cb730a..47e3e8f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,21 +8,12 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Tal Lev-Ami - added package cache for zip files
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
-import java.io.File;
-import java.io.IOException;
-import java.util.Date;
-import java.util.Enumeration;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-
 import org.eclipse.core.resources.IFile;
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.*;
+
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
@@ -32,6 +23,10 @@ import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.util.Util;
 
+import java.io.*;
+import java.util.*;
+import java.util.zip.*;
+
 @SuppressWarnings("rawtypes")
 public class ClasspathJar extends ClasspathLocation {
 
@@ -90,9 +85,8 @@ long lastModified;
 boolean closeZipFileAtEnd;
 SimpleSet knownPackageNames;
 AccessRuleSet accessRuleSet;
-String externalAnnotationDir;
 
-ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
+ClasspathJar(IFile resource, AccessRuleSet accessRuleSet) {
 	this.resource = resource;
 	try {
 		java.net.URI location = resource.getLocationURI();
@@ -108,28 +102,22 @@ ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotati
 	this.zipFile = null;
 	this.knownPackageNames = null;
 	this.accessRuleSet = accessRuleSet;
-	if (externalAnnotationPath != null)
-		this.externalAnnotationDir = externalAnnotationPath.toString();
 }
 
-ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
+ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet) {
 	this.zipFilename = zipFilename;
 	this.lastModified = lastModified;
 	this.zipFile = null;
 	this.knownPackageNames = null;
 	this.accessRuleSet = accessRuleSet;
-	if (externalAnnotationPath != null)
-		this.externalAnnotationDir = externalAnnotationPath.toString();
 }
 
-public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
+public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet) {
 	this.zipFilename = zipFile.getName();
 	this.zipFile = zipFile;
 	this.closeZipFileAtEnd = false;
 	this.knownPackageNames = null;
 	this.accessRuleSet = accessRuleSet;
-	if (externalAnnotationPath != null)
-		this.externalAnnotationDir = externalAnnotationPath.toString();
 }
 
 public void cleanup() {
@@ -160,8 +148,6 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 	try {
 		ClassFileReader reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
 		if (reader != null) {
-			if (this.externalAnnotationDir != null)
-				reader.setExternalAnnotationProvider(this.externalAnnotationDir);
 			if (this.accessRuleSet == null)
 				return new NameEnvironmentAnswer(reader, null);
 			String fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
index d20f0a8..aef33e1 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,8 +7,6 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
@@ -28,16 +26,16 @@ public static ClasspathLocation forBinaryFolder(IContainer binaryFolder, boolean
 	return new ClasspathDirectory(binaryFolder, isOutputFolder, accessRuleSet);
 }
 
-static ClasspathLocation forLibrary(String libraryPathname, long lastModified, AccessRuleSet accessRuleSet, IPath annotationsPath) {
-	return new ClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath);
+static ClasspathLocation forLibrary(String libraryPathname, long lastModified, AccessRuleSet accessRuleSet) {
+	return new ClasspathJar(libraryPathname, lastModified, accessRuleSet);
 }
 
-static ClasspathLocation forLibrary(String libraryPathname, AccessRuleSet accessRuleSet, IPath annotationsPath) {
-	return forLibrary(libraryPathname, 0, accessRuleSet, annotationsPath);
+static ClasspathLocation forLibrary(String libraryPathname, AccessRuleSet accessRuleSet) {
+	return forLibrary(libraryPathname, 0, accessRuleSet);
 }
 
-static ClasspathLocation forLibrary(IFile library, AccessRuleSet accessRuleSet, IPath annotationsPath) {
-	return new ClasspathJar(library, accessRuleSet, annotationsPath);
+static ClasspathLocation forLibrary(IFile library, AccessRuleSet accessRuleSet) {
+	return new ClasspathJar(library, accessRuleSet);
 }
 
 public abstract NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String qualifiedBinaryFileName);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index 6ad6ba2..a3dc10a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,7 +12,6 @@
  *           -  Another problem with inner classes referenced from jars or class folders: "The type ... cannot be resolved"
  *     Stephan Herrmann - Contribution for
  *								Bug 392727 - Cannot compile project when a java file contains $ in its file name
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
@@ -104,7 +103,6 @@ private void computeClasspathLocations(
 		ClasspathEntry entry = (ClasspathEntry) classpathEntries[i];
 		IPath path = entry.getPath();
 		Object target = JavaModel.getTarget(path, true);
-		IPath externalAnnotationPath = entry.getExternalAnnotationPath();
 		if (target == null) continue nextEntry;
 
 		switch(entry.getEntryKind()) {
@@ -174,7 +172,7 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-						bLocation = ClasspathLocation.forLibrary((IFile) resource, accessRuleSet, externalAnnotationPath);
+						bLocation = ClasspathLocation.forLibrary((IFile) resource, accessRuleSet);
 					} else if (resource instanceof IContainer) {
 						AccessRuleSet accessRuleSet =
 							(JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE, true))
@@ -202,7 +200,7 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-					bLocations.add(ClasspathLocation.forLibrary(path.toString(), accessRuleSet, externalAnnotationPath));
+					bLocations.add(ClasspathLocation.forLibrary(path.toString(), accessRuleSet));
 				}
 				continue nextEntry;
 		}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
index 90e9741..30cb7db 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
@@ -7,8 +7,6 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
@@ -47,7 +45,7 @@ private long previousStructuralBuildTime;
 private StringSet structurallyChangedTypes;
 public static int MaxStructurallyChangedTypes = 100; // keep track of ? structurally changed types, otherwise consider all to be changed
 
-public static final byte VERSION = 0x001C;
+public static final byte VERSION = 0x001B;
 
 static final byte SOURCE_FOLDER = 1;
 static final byte BINARY_FOLDER = 2;
@@ -271,10 +269,10 @@ static State read(IProject project, DataInputStream in) throws IOException {
 				newState.binaryLocations[i] = ClasspathLocation.forBinaryFolder(outputFolder, in.readBoolean(), readRestriction(in));
 				break;
 			case EXTERNAL_JAR :
-				newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(), readRestriction(in), new Path(in.readUTF()));
+				newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(), readRestriction(in));
 				break;
 			case INTERNAL_JAR :
-				newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())), readRestriction(in), new Path(in.readUTF()));
+				newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())), readRestriction(in));
 		}
 	}
 
@@ -465,7 +463,6 @@ void write(DataOutputStream out) throws IOException {
 				out.writeUTF(jar.resource.getFullPath().toString());
 			}
 			writeRestriction(jar.accessRuleSet, out);
-			out.writeUTF(jar.externalAnnotationDir != null ? jar.externalAnnotationDir : ""); //$NON-NLS-1$
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index 56c24d6..b0ba183 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -7,8 +7,6 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for
- *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.search.matching;
 
@@ -97,10 +95,9 @@ private void computeClasspathLocations(IWorkspaceRoot workspaceRoot, JavaProject
 		PackageFragmentRoot root = (PackageFragmentRoot) roots[i];
 		IPath path = root.getPath();
 		try {
-			ClasspathEntry classpathEntry = (ClasspathEntry) root.getRawClasspathEntry();
 			if (root.isArchive()) {
 				ZipFile zipFile = manager.getZipFile(path);
-				cpLocations[index++] = new ClasspathJar(zipFile, classpathEntry.getAccessRuleSet(), classpathEntry.getExternalAnnotationPath());
+				cpLocations[index++] = new ClasspathJar(zipFile, ((ClasspathEntry) root.getRawClasspathEntry()).getAccessRuleSet());
 			} else {
 				Object target = JavaModel.getTarget(path, true);
 				if (target == null) {
@@ -110,7 +107,7 @@ private void computeClasspathLocations(IWorkspaceRoot workspaceRoot, JavaProject
 				} else if (root.getKind() == IPackageFragmentRoot.K_SOURCE) {
 					cpLocations[index++] = new ClasspathSourceDirectory((IContainer)target, root.fullExclusionPatternChars(), root.fullInclusionPatternChars());
 				} else {
-					cpLocations[index++] = ClasspathLocation.forBinaryFolder((IContainer) target, false, classpathEntry.getAccessRuleSet());
+					cpLocations[index++] = ClasspathLocation.forBinaryFolder((IContainer) target, false, ((ClasspathEntry) root.getRawClasspathEntry()).getAccessRuleSet());
 				}
 			}
 		} catch (CoreException e1) {
commit 0b6f06d77f121375ae3494c8c329aad2cfc0a1a4
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Feb 12 19:22:08 2015 +0100

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    Bug 440474 - [null] textual encoding of external null annotations
    
    Change-Id: Ia7ffd6bac1484d0f021beebf653d239d0ddd36a5
    Signed-off-by: Stephan Herrmann <stephan.herrmann@berlin.de>

113	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
5	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
5	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
166	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations17Test.java
785	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
6	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/.classpath
17	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/.project
12	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/annots/libs/MyMap.eea
11	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/src/test1/Test1.java
6	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath
17	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project
12	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/libs/MyMap.eea
13	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java
10	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath
17	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project
12	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
13	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java
10	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath
17	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project
6	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
16	0	org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java
32	8	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
21	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
3	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
4	3	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
81	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
636	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
7	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
39	88	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
119	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
68	33	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
13	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
39	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
9	2	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
14	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathAttribute.java
535	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
65	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
15	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
82	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
230	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ExternalAnnotationTracker.java
6	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelCache.java
13	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
36	10	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
9	7	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
5	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
7	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
8	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
6	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 2ae64da..72c3430 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -24,6 +24,7 @@
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
  *								bug 383368 - [compiler][null] syntactic null analysis for field references
  *								Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis 
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *     Jesper Steen Moller - Contributions for
  *								bug 404146 - [1.7][compiler] nested try-catch-finally-blocks leads to unrunnable Java byte code
  *								bug 407297 - [1.8][compiler] Control generation of parameter names by option
@@ -88,8 +89,53 @@ public class BatchCompilerTest extends AbstractRegressionTest {
 			"public @interface NonNull{\n" +
 			"}\n";
 
+	private static final String ELEMENT_TYPE_18_CONTENT = "package java.lang.annotation;\n" + 
+			"public enum ElementType {\n" + 
+			"    TYPE,\n" + 
+			"    FIELD,\n" + 
+			"    METHOD,\n" + 
+			"    PARAMETER,\n" + 
+			"    CONSTRUCTOR,\n" + 
+			"    LOCAL_VARIABLE,\n" + 
+			"    ANNOTATION_TYPE,\n" + 
+			"    PACKAGE,\n" + 
+			"    TYPE_PARAMETER,\n" + 
+			"    TYPE_USE\n" + 
+			"}\n" + 
+			"";
+	private static final String NONNULL_ANNOTATION_18_CONTENT = "package org.eclipse.jdt.annotation;\n" +
+			"import java.lang.annotation.ElementType;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Documented\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target({ ElementType.TYPE_USE })\n" +
+			"public @interface NonNull{\n" +
+			"}\n";
+	private static final String NONNULL_BY_DEFAULT_ANNOTATION_18_CONTENT = "package org.eclipse.jdt.annotation;\n" +
+			"import java.lang.annotation.ElementType;\n" + 
+			"import static org.eclipse.jdt.annotation.DefaultLocation.*;\n" + 
+			"\n" + 
+			"import java.lang.annotation.Retention;\n" + 
+			"import java.lang.annotation.RetentionPolicy;\n" + 
+			"import java.lang.annotation.Target;\n" + 
+			"@Retention(RetentionPolicy.CLASS)\n" + 
+			"@Target({ ElementType.PACKAGE, ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE })\n" + 
+			"public @interface NonNullByDefault {\n" + 
+			"	DefaultLocation[] value() default { PARAMETER, RETURN_TYPE, FIELD, TYPE_BOUND, TYPE_ARGUMENT };\n" + 
+			"}\n";
+	private static final String DEFAULT_LOCATION_CONTENT = "package org.eclipse.jdt.annotation;\n" +
+			"public enum DefaultLocation {\n" + 
+			"	PARAMETER,\n" + 
+			"	RETURN_TYPE,\n" + 
+			"	FIELD,\n" + 
+			"	TYPE_PARAMETER,\n" + 
+			"	TYPE_BOUND,\n" + 
+			"	TYPE_ARGUMENT,\n" + 
+			"	ARRAY_CONTENTS\n" + 
+			"}\n";
+
 	static {
-//		TESTS_NAMES = new String[] { "test320_warn_options" };
+//		TESTS_NAMES = new String[] { "test440477" };
 //		TESTS_NUMBERS = new int[] { 306 };
 //		TESTS_RANGE = new int[] { 298, -1 };
 	}
@@ -1657,7 +1703,10 @@ public void test012(){
         "    -genericsignature  generate generic signature for lambda expressions\n" +
         "    -Xemacs            used to enable emacs-style output in the console.\n" +
         "                       It does not affect the xml log output\n" +
-        "    -missingNullDefault  report missing default nullness annotation\n" + 
+        "    -missingNullDefault  report missing default nullness annotation\n" +
+        "    -annotationpath <path>\n" + 
+        "                       Path to a base directory or zip file holding external\n" + 
+        "                       annotations to support annotation-based null analysis\n" + 
         " \n" + 
         "    -? -help           print this help message\n" +
         "    -v -version        print compiler version\n" +
@@ -14048,6 +14097,68 @@ public void testBug419351() {
 		new File(lib1Path).delete();
 	}
 }
+// Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
+// - single external annotation directory
+public void test440477() throws IOException {
+	String annots_dir = Util.getOutputDirectory() + File.separator + "annots";
+	String annots_java_util = annots_dir + File.separator + "java/util";
+	new File(annots_java_util).mkdirs();
+	Util.createFile(
+			annots_java_util + File.separator + "Map.eea", 
+			"class java/util/Map\n" +
+			" <K:V:>\n" + 
+			"\n" + 
+			"get\n" + 
+			" (Ljava/lang/Object;)TV;\n" + 
+			" (Ljava/lang/Object;)T0V;\n" + 
+			"put\n" + 
+			" (TK;TV;)TV;\n" + 
+			" (TK;TV;)T0V;\n" + 
+			"remove\n" + 
+			" (Ljava/lang/Object;)TV;\n" + 
+			" (Ljava/lang/Object;)T0V;\n");
+
+	String o_e_j_annotation_dir = OUTPUT_DIR + File.separator +
+			"org" + File.separator + "eclipse" + File.separator + "jdt" + File.separator + "annotation";
+	String j_l_annotation_dir = OUTPUT_DIR +  File.separator +
+			"java" + File.separator + "lang" + File.separator + "annotation";
+	this.runConformTest(
+		new String[] {
+			"java/lang/annotation/ElementType.java",
+			ELEMENT_TYPE_18_CONTENT,
+			"org/eclipse/jdt/annotation/NonNull.java",
+			NONNULL_ANNOTATION_18_CONTENT,
+			"org/eclipse/jdt/annotation/DefaultLocation.java",				
+			DEFAULT_LOCATION_CONTENT,
+			"org/eclipse/jdt/annotation/NonNullByDefault.java",				
+			NONNULL_BY_DEFAULT_ANNOTATION_18_CONTENT,
+			"test1/Test1.java",
+			"package test1;\n" + 
+			"\n" + 
+			"import java.util.Map;\n" + 
+			"import org.eclipse.jdt.annotation.*;\n" + 
+			"\n" + 
+			"@NonNullByDefault\n" + 
+			"public class Test1 {\n" + 
+			"	void test(Map<String,Test1> map, String key) {\n" + 
+			"		Test1 v = map.get(key);\n" + 
+			"		if (v == null)\n" + 
+			"			throw new RuntimeException(); // should not be reported as dead code, although V is a '@NonNull Test1'\n" + 
+			"	}\n" + 
+			"}\n"
+			},
+			" -1.8 -proc:none -d none -warn:+nullAnnot -annotationpath " + annots_dir +
+			" -sourcepath \"" + OUTPUT_DIR + "\" " +
+			// explicitly mention all files to ensure a good order, cannot pull in source of NNBD on demand
+			"\"" + j_l_annotation_dir   +  File.separator + "ElementType.java\" " +
+			"\"" + o_e_j_annotation_dir +  File.separator + "NonNull.java\" " +
+			"\"" + o_e_j_annotation_dir +  File.separator + "DefaultLocation.java\" " +
+			"\"" + o_e_j_annotation_dir +  File.separator + "NonNullByDefault.java\" " +
+			"\"" + OUTPUT_DIR +  File.separator + "test1" + File.separator + "Test1.java\"",
+			"",
+			"",
+			true);
+}
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=439750
 public void test439750() {
 	this.runConformTest(
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
index 2048e88..96df8ea 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
@@ -193,6 +195,9 @@ private static Class[] getAllTestClasses() {
 		
 		// Tests regarding null-annotations:
 		NullAnnotationModelTests.class,
+		ExternalAnnotations17Test.class,
+		ExternalAnnotations18Test.class,
+
 		// Java model changes related to Java 8
 		JavaElement8Tests.class,
 	};
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
index 47c14fc..5e55e9e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java
@@ -9,7 +9,10 @@
  *     IBM Corporation - initial API and implementation
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425,
  *     									   Fup of 357425: ensure all reported regressions are witnessed by tests, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=361922
- *     Thirumala Reddy Mutchukota <thirumala@google.com> - Contribution to bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=411423
+ *     Thirumala Reddy Mutchukota <thirumala@google.com> - Contribution for
+ *     							Bug 411423 - JavaProject.resolveClasspath is spending more than 90% time on ExternalFoldersManager.isExternalFolderPath
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
@@ -5843,6 +5846,7 @@ public void testBug55992a() throws CoreException {
 			ClasspathEntry.EXCLUDE_NONE,
 			new Path("TEST_SRC"),
 			null,
+			null,
 			null, // specific output folder
 			false,
 			(IAccessRule[]) null,
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations17Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations17Test.java
new file mode 100644
index 0000000..674f204
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations17Test.java
@@ -0,0 +1,166 @@
+/*******************************************************************************
+ * Copyright (c) 2015 GK Software AG, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.model;
+
+import junit.framework.Test;
+
+import org.eclipse.core.resources.IMarker;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IncrementalProjectBuilder;
+import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaModelMarker;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.osgi.framework.Bundle;
+
+public class ExternalAnnotations17Test extends ExternalAnnotations18Test {
+
+
+	public ExternalAnnotations17Test(String name) {
+		super(name, "1.7", "JCL17_LIB");
+	}
+	
+// Use this static initializer to specify subset for tests
+// All specified tests which do not belong to the class are skipped...
+	static {
+		// Names of tests to run: can be "testBugXXXX" or "BugXXXX")
+//		TESTS_PREFIX = "testLibsWithTypeParameters";
+//		TESTS_NAMES = new String[] {"testLibsWithFields"};
+//		TESTS_NUMBERS = new int[] { 23, 28, 38 };
+//		TESTS_RANGE = new int[] { 21, 38 };
+	}
+	public static Test suite() {
+		return buildModelTestSuite(ExternalAnnotations17Test.class, BYTECODE_DECLARATION_ORDER);
+	}
+
+	/**
+	 * @deprecated indirectly uses deprecated class PackageAdmin
+	 */
+	protected Bundle[] getAnnotationBundles() {
+		return org.eclipse.jdt.core.tests.Activator.getPackageAdmin().getBundles("org.eclipse.jdt.annotation", "[1.1.0,2.0.0)");
+	}
+	
+	public String getSourceWorkspacePath() {
+		// we read individual projects from within this folder:
+		return super.getSourceWorkspacePathBase()+"/ExternalAnnotations17";
+	}
+
+	public void test1FullBuild() throws Exception {
+		setupJavaProject("Test1");
+		this.project.setOption(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/MyMap.java",
+				MY_MAP_CONTENT
+			}, null);
+		this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+		IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
+		sortMarkers(markers);
+		assertMarkers("Unexpected markers", 
+				"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+				"Null type mismatch: required \'@NonNull Test1\' but the provided value is null\n" +
+				"Potential null pointer access: The variable v may be null at this location",
+				markers);
+	}
+
+	/** Perform full build, annotations are found relative to a variable. */
+	public void test1FullBuildWithVariable() throws Exception {
+		setupJavaProject("Test1");
+		this.project.setOption(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+		JavaCore.setClasspathVariable("MY_PRJ_ROOT", this.project.getProject().getLocation(), null);
+		try {
+			addLibraryWithExternalAnnotations(this.project, "lib1.jar", "MY_PRJ_ROOT/annots", new String[] {
+					"/UnannotatedLib/libs/MyMap.java",
+					MY_MAP_CONTENT
+				}, null);
+			this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
+			sortMarkers(markers);
+			assertMarkers("Unexpected markers", 
+					"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+					"Null type mismatch: required \'@NonNull Test1\' but the provided value is null\n" +
+					"Potential null pointer access: The variable v may be null at this location",
+					markers);
+		} finally {
+			JavaCore.removeClasspathVariable("MY_PRJ_ROOT", null);
+		}
+	}
+
+	/** Reconcile an individual CU. */
+	public void test1Reconcile() throws Exception {
+		setupJavaProject("Test1");
+		this.project.setOption(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/MyMap.java",
+				MY_MAP_CONTENT
+			}, null);
+		IPackageFragment fragment = this.root.getPackageFragment("test1");
+		ICompilationUnit unit = fragment.getCompilationUnit("Test1.java").getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertProblems(problems,
+					new String[] {
+						"Pb(910) Null type mismatch: required \'@NonNull Test1\' but the provided value is null",
+						"Pb(910) Null type mismatch: required \'@NonNull Object\' but the provided value is null",
+						"Pb(452) Potential null pointer access: The variable v may be null at this location"
+					},	
+					new int[]{ 7, 8, 9});
+	}
+
+	public void testLibsWithFields() throws Exception {
+		myCreateJavaProject("TestLibs");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" +
+				"public interface Lib1 {\n" + 
+				"	String one = \"1\";\n" + 
+				"	String none = null;\n" + 
+				"}\n"
+			}, null);
+		createFileInProject("annots/libs", "Lib1.eea", 
+				"class libs/Lib1\n" +
+				"\n" + 
+				"one\n" + 
+				" Ljava/lang/String;\n" + 
+				" L1java/lang/String;\n" + 
+				"\n" + 
+				"none\n" + 
+				" Ljava/lang/String;\n" +
+				" L0java/lang/String;\n" +
+				"\n");
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	@NonNull String test0() {\n" + 
+				"		return Lib1.none;\n" + 
+				"	}\n" +
+				"	@NonNull String test1() {\n" + 
+				"		return Lib1.one;\n" + 
+				"	}\n" +
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertProblems(problems, new String[] {
+			"Pb(933) Null type mismatch: required '@NonNull String' but the provided value is specified as @Nullable",
+		}, new int[] { 8 });
+	}
+
+}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
new file mode 100644
index 0000000..d63124b
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ExternalAnnotations18Test.java
@@ -0,0 +1,785 @@
+/*******************************************************************************
+ * Copyright (c) 2014, 2015 GK Software AG, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.model;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Hashtable;
+import java.util.Map;
+
+import junit.framework.Test;
+
+import org.eclipse.core.resources.IMarker;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IncrementalProjectBuilder;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.FileLocator;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.IClasspathAttribute;
+import org.eclipse.jdt.core.IClasspathContainer;
+import org.eclipse.jdt.core.IClasspathEntry;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaModelMarker;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.tests.util.Util;
+import org.eclipse.jdt.internal.core.ClasspathAttribute;
+import org.osgi.framework.Bundle;
+
+public class ExternalAnnotations18Test extends ModifyingResourceTests {
+
+	/** Bridge to hook the host JRE into the registered ContainerInitializer. */
+	static class TestContainerInitializer implements ContainerInitializer.ITestInitializer {
+
+		/** Use this container name in test projects. */
+		private static final String TEST_CONTAINER_NAME = "org.eclipse.jdt.core.tests.model.TEST_CONTAINER";
+		
+		static class TestContainer implements IClasspathContainer {
+			IPath path;
+			IClasspathEntry[] entries;
+			TestContainer(IPath path, IClasspathEntry[] entries){
+				this.path = path;
+				this.entries = entries;
+			}
+			public IPath getPath() { return this.path; }
+			public IClasspathEntry[] getClasspathEntries() { return this.entries;	}
+			public String getDescription() { return this.path.toString(); 	}
+			public int getKind() { return 0; }
+		}
+
+		public void initialize(IPath containerPath, IJavaProject project) throws CoreException {
+			String[] jars = Util.getJavaClassLibs();
+			IClasspathEntry[] entries = new IClasspathEntry[jars.length];
+			for (int i = 0; i < jars.length; i++)
+				entries[i] = JavaCore.newLibraryEntry(new Path(jars[i]), null, null);
+			JavaCore.setClasspathContainer(
+					new Path(TEST_CONTAINER_NAME),
+					new IJavaProject[]{ project },
+					new IClasspathContainer[] { new TestContainer(new Path(TEST_CONTAINER_NAME), entries) },
+					null);
+		}
+		public boolean allowFailureContainer() {
+			return false;
+		}
+	}
+
+	protected IJavaProject project;
+	protected IPackageFragmentRoot root;
+	protected String ANNOTATION_LIB;
+	protected final String compliance;
+	protected final String jclLib;
+
+	protected static final String MY_MAP_CONTENT = 
+			"package libs;\n" + 
+			"\n" + 
+			"public interface MyMap<K,V> {\n" + 
+			"	V get(Object key);\n" + 
+			"	V put(K key, V val);\n" + 
+			"	V remove(Object key);\n" + 
+			"}\n";
+
+	public ExternalAnnotations18Test(String name) {
+		this(name, "1.8", "JCL18_LIB");
+	}
+	
+	protected ExternalAnnotations18Test(String name, String compliance, String jclLib) {
+		super(name);
+		this.compliance = compliance;
+		this.jclLib = jclLib;
+	}
+
+	// Use this static initializer to specify subset for tests
+// All specified tests which do not belong to the class are skipped...
+	static {
+		// Names of tests to run: can be "testBugXXXX" or "BugXXXX")
+//		TESTS_PREFIX = "testLibsWithTypeParameters";
+//		TESTS_NAMES = new String[] {"test3"};
+//		TESTS_NUMBERS = new int[] { 23, 28, 38 };
+//		TESTS_RANGE = new int[] { 21, 38 };
+	}
+	public static Test suite() {
+		return buildModelTestSuite(ExternalAnnotations18Test.class, BYTECODE_DECLARATION_ORDER);
+	}
+
+	public void setUpSuite() throws Exception {
+		super.setUpSuite();
+		
+		Bundle[] bundles = getAnnotationBundles();
+		File bundleFile = FileLocator.getBundleFile(bundles[0]);
+		this.ANNOTATION_LIB = bundleFile.isDirectory() ? bundleFile.getPath()+"/bin" : bundleFile.getPath();
+
+		// set up class path container bridging to the host JRE:
+		ContainerInitializer.setInitializer(new TestContainerInitializer());
+	}
+
+	/**
+	 * @deprecated indirectly uses deprecated class PackageAdmin
+	 */
+	protected Bundle[] getAnnotationBundles() {
+		return org.eclipse.jdt.core.tests.Activator.getPackageAdmin().getBundles("org.eclipse.jdt.annotation", "[2.0.0,3.0.0)");
+	}
+
+	public void tearDownSuite() throws Exception {
+		super.tearDownSuite();
+		ContainerInitializer.setInitializer(null);
+	}
+	
+	public String getSourceWorkspacePath() {
+		// we read individual projects from within this folder:
+		return super.getSourceWorkspacePath()+"/ExternalAnnotations18";
+	}
+
+	protected String getSourceWorkspacePathBase() {
+		return super.getSourceWorkspacePath();
+	}
+
+	void setupJavaProject(String name) throws CoreException, IOException {
+		this.project = setUpJavaProject(name, this.compliance); //$NON-NLS-1$
+		addLibraryEntry(this.project, this.ANNOTATION_LIB, false);
+		Map options = this.project.getOptions(true);
+		options.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+		this.project.setOptions(options);
+
+		IPackageFragmentRoot[] roots = this.project.getAllPackageFragmentRoots();
+		int count = 0;
+		for (int i = 0, max = roots.length; i < max; i++) {
+			final IPackageFragmentRoot packageFragmentRoot = roots[i];
+			switch(packageFragmentRoot.getKind()) {
+				case IPackageFragmentRoot.K_SOURCE :
+					count++;
+					if (this.root == null) {
+						this.root = packageFragmentRoot;
+					}
+			}
+		}
+		assertEquals("Wrong value", 1, count); //$NON-NLS-1$
+		assertNotNull("Should not be null", this.root); //$NON-NLS-1$
+	}
+	
+	void myCreateJavaProject(String name) throws CoreException {
+		this.project = createJavaProject(name, new String[]{"src"}, new String[]{this.jclLib}, null, null, "bin", null, null, null, this.compliance);
+		addLibraryEntry(this.project, this.ANNOTATION_LIB, false);
+		Map options = this.project.getOptions(true);
+		options.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+		this.project.setOptions(options);
+
+		IPackageFragmentRoot[] roots = this.project.getAllPackageFragmentRoots();
+		int count = 0;
+		for (int i = 0, max = roots.length; i < max; i++) {
+			final IPackageFragmentRoot packageFragmentRoot = roots[i];
+			switch(packageFragmentRoot.getKind()) {
+				case IPackageFragmentRoot.K_SOURCE :
+					count++;
+					if (this.root == null) {
+						this.root = packageFragmentRoot;
+					}
+			}
+		}
+		assertEquals("Wrong value", 1, count); //$NON-NLS-1$
+		assertNotNull("Should not be null", this.root); //$NON-NLS-1$
+	}
+	
+	protected void tearDown() throws Exception {
+		this.project.getProject().delete(true, true, null);
+		this.project = null;
+		this.root = null;
+		super.tearDown();
+	}
+
+	protected void addLibraryWithExternalAnnotations(
+			IJavaProject javaProject,
+			String jarName,
+			String externalAnnotationPath,
+			String[] pathAndContents,
+			Map options) throws CoreException, IOException
+	{
+		createLibrary(javaProject, jarName, "src.zip", pathAndContents, null, this.compliance, options);
+		String jarPath = '/' + javaProject.getProject().getName() + '/' + jarName;
+		IClasspathAttribute[] extraAttributes = new IClasspathAttribute[] { new ClasspathAttribute(IClasspathAttribute.EXTERNAL_ANNOTATION_PATH, externalAnnotationPath) };
+		IClasspathEntry entry = JavaCore.newLibraryEntry(
+				new Path(jarPath),
+				null/*src attach*/,
+				null/*src attach root*/,
+				null/*access rules*/,
+				extraAttributes,
+				false/*exported*/);
+		addClasspathEntry(this.project, entry);
+	}
+
+	protected void createFileInProject(String projectRelativeFolder, String fileName, String content) throws CoreException {
+		String folderPath = this.project.getProject().getName()+'/'+projectRelativeFolder;
+		createFolder(folderPath);
+		createFile(folderPath+'/'+fileName, content);
+	}
+
+	protected void assertNoMarkers(IMarker[] markers) throws CoreException {
+		for (int i = 0; i < markers.length; i++)
+			System.err.println("Unexpected marker: "+markers[i].getAttributes().entrySet());
+		assertEquals("Number of markers", 0, markers.length);
+	}
+	
+	protected void assertNoProblems(IProblem[] problems) throws CoreException {
+		for (int i = 0; i < problems.length; i++)
+			System.err.println("Unexpected marker: "+problems[i]);
+		assertEquals("Number of markers", 0, problems.length);
+	}
+
+	protected void assertProblems(IProblem[] problems, String[] messages, int[] lines) throws CoreException {
+		int nMatch = 0;
+		for (int i = 0; i < problems.length; i++) {
+			for (int j = 0; j < messages.length; j++) {
+				if (messages[j] == null) continue;
+				if (problems[i].toString().equals(messages[j])
+						&& problems[i].getSourceLineNumber() == lines[j]) {
+					messages[j] = null;
+					problems[i] = null;
+					nMatch++;
+					break;
+				}
+			}
+		}
+		for (int i = 0; i < problems.length; i++) {
+			if (problems[i] != null)
+				fail("Unexpected problem "+problems[i]+" at "+problems[i].getSourceLineNumber());
+		}
+		for (int i = 0; i < messages.length; i++) {
+			if (messages[i] != null)
+				System.err.println("Unmatched problem "+messages[i]);
+		}
+		assertEquals("Number of problems", messages.length, nMatch);
+	}
+
+	/** Perform full build. */
+	public void test1FullBuild() throws Exception {
+		setupJavaProject("Test1");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/MyMap.java",
+				MY_MAP_CONTENT
+			}, null);
+		this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+		IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
+		assertNoMarkers(markers);
+	}
+
+	/** Perform full build, annotations are found relative to a variable. */
+	public void test1FullBuildWithVariable() throws Exception {
+		setupJavaProject("Test1");
+		JavaCore.setClasspathVariable("MY_PRJ_ROOT", this.project.getProject().getLocation(), null);
+		try {
+			addLibraryWithExternalAnnotations(this.project, "lib1.jar", "MY_PRJ_ROOT/annots", new String[] {
+					"/UnannotatedLib/libs/MyMap.java",
+					MY_MAP_CONTENT
+				}, null);
+			this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
+			assertNoMarkers(markers);
+		} finally {
+			JavaCore.removeClasspathVariable("MY_PRJ_ROOT", null);
+		}
+	}
+
+	/** Reconcile an individual CU. */
+	public void test1Reconcile() throws Exception {
+		setupJavaProject("Test1");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/MyMap.java",
+				MY_MAP_CONTENT
+			}, null);
+		IPackageFragment fragment = this.root.getPackageFragment("test1");
+		ICompilationUnit unit = fragment.getCompilationUnit("Test1.java").getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertNoProblems(problems);
+	}
+	
+	public void testLibs1() throws Exception {
+		myCreateJavaProject("TestLibs");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" + 
+				"import java.util.Collection;\n" + 
+				"import java.util.Iterator;\n" + 
+				"\n" + 
+				"public interface Lib1 {\n" + 
+				"	<T> Iterator<T> unconstrainedTypeArguments1(Collection<T> in);\n" + 
+				"	Iterator<String> unconstrainedTypeArguments2(Collection<String> in);\n" + 
+				"	<T> Iterator<? extends T> constrainedWildcards(Collection<? extends T> in);\n" + 
+				"	<T extends Collection<?>> T constrainedTypeParameter(T in);\n" + 
+				"}\n"
+			}, null);
+		// annotations on type variables & class type in various positions:
+		createFileInProject("annots/libs", "Lib1.eea",
+				"class libs/Lib1\n" + 
+				"\n" + 
+				"unconstrainedTypeArguments1\n" + 
+				" <T:Ljava/lang/Object;>(Ljava/util/Collection<TT;>;)Ljava/util/Iterator<TT;>;\n" + 
+				" <T:Ljava/lang/Object;>(Ljava/util/Collection<T0T;>;)Ljava/util/Iterator<TT;>;\n" +  // position: type argument
+				"\n" + 
+				"unconstrainedTypeArguments2\n" + 
+				" (Ljava/util/Collection<Ljava/lang/String;>;)Ljava/util/Iterator<Ljava/lang/String;>;\n" + 
+				" (Ljava/util/Collection<Ljava/lang/String;>;)Ljava/util/Iterator<L1java/lang/String;>;\n" + // position: type argument bound (class type)
+				"constrainedWildcards\n" +
+				" <T:Ljava/lang/Object;>(Ljava/util/Collection<+TT;>;)Ljava/util/Iterator<+TT;>;\n" +
+				" <T:Ljava/lang/Object;>(Ljava/util/Collection<+T0T;>;)Ljava/util/Iterator<+T1T;>;\n" + // positions: wildcard bound
+				"constrainedTypeParameter\n" +
+				" <T::Ljava/util/Collection<*>;>(TT;)TT;\n" +
+				" <T::Ljava/util/Collection<*>;>(T0T;)T1T;\n"); // position: top-level type
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import java.util.Collection;\n" + 
+				"import java.util.Iterator;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	Iterator<@NonNull String> test1(Lib1 lib, Collection<@Nullable String> coll) {\n" + 
+				"		return lib.unconstrainedTypeArguments1(coll);\n" + 
+				"	}\n" + 
+				"	Iterator<@NonNull String> test2(Lib1 lib, Collection<@Nullable String> coll) {\n" + 
+				"		return lib.unconstrainedTypeArguments2(coll);\n" + 
+				"	}\n" +
+				"	Iterator<? extends @NonNull String> test3(Lib1 lib, Collection<String> coll) {\n" +
+				"		return lib.constrainedWildcards(coll);\n" +
+				"	}\n" +
+				"	@NonNull Collection<String> test4(Lib1 lib, @Nullable Collection<String> in) {\n" +
+				"		return lib.constrainedTypeParameter(in);\n" +
+				"	}\n" + 
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertNoProblems(problems);
+	}
+
+	public void testLibsWithWildcards() throws Exception {
+		myCreateJavaProject("TestLibs");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" + 
+				"import java.util.Collection;\n" + 
+				"import java.util.Iterator;\n" + 
+				"\n" + 
+				"public interface Lib1 {\n" + 
+				"	Iterator<?> unconstrainedWildcard1(Collection<?> in);\n" + 
+				"	Iterator<?> unconstrainedWildcard2(Collection<?> in);\n" + 
+				"	Iterator<? extends CharSequence> constrainedWildcard1(Collection<? extends CharSequence> in);\n" + 
+				"	Iterator<? super CharSequence> constrainedWildcard2(Collection<? super CharSequence> in);\n" + 
+				"}\n"
+			}, null);
+		// annotations directly on a wildcard (*, +, -)
+		createFileInProject("annots/libs", "Lib1.eea",
+				"class libs/Lib1\n" + 
+				"\n" + 
+				"unconstrainedWildcard1\n" + 
+				" (Ljava/util/Collection<*>;)Ljava/util/Iterator<*>;\n" + 
+				" (Ljava/util/Collection<*>;)Ljava/util/Iterator<*1>;\n" +
+				"\n" + 
+				"unconstrainedWildcard2\n" + 
+				" (Ljava/util/Collection<*>;)Ljava/util/Iterator<*>;\n" + 
+				" (Ljava/util/Collection<*>;)Ljava/util/Iterator<*0>;\n" + 
+				"\n" + 
+				"constrainedWildcard1\n" + 
+				" (Ljava/util/Collection<+Ljava/lang/CharSequence;>;)Ljava/util/Iterator<+Ljava/lang/CharSequence;>;\n" + 
+				" (Ljava/util/Collection<+Ljava/lang/CharSequence;>;)Ljava/util/Iterator<+0Ljava/lang/CharSequence;>;\n" + 
+				"\n" + 
+				"constrainedWildcard2\n" + 
+				" (Ljava/util/Collection<-Ljava/lang/CharSequence;>;)Ljava/util/Iterator<-Ljava/lang/CharSequence;>;\n" + 
+				" (Ljava/util/Collection<-Ljava/lang/CharSequence;>;)Ljava/util/Iterator<-0Ljava/lang/CharSequence;>;\n" + 
+				"\n" + 
+				"\n");
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import java.util.Collection;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	@NonNull Object test1(Lib1 lib, Collection<@Nullable String> coll) {\n" + 
+				"		 return lib.unconstrainedWildcard1(coll).next();\n" + // OK
+				"	}\n" + 
+				"	@NonNull Object test2(Lib1 lib, Collection<@Nullable String> coll) {\n" + 
+				"		 return lib.unconstrainedWildcard2(coll).next();\n" + // return is nullable -> error
+				"	}\n" + 
+				"	@NonNull CharSequence test3(Lib1 lib, Collection<@Nullable String> coll) {\n" + 
+				"		 return lib.constrainedWildcard1(coll).next();\n" + // '@Nullable ? extends CharSequence' -> error
+				"	}\n" + 
+				"	@NonNull Object test4(Lib1 lib, Collection<@Nullable CharSequence> coll) {\n" + 
+				"		 return lib.constrainedWildcard2(coll).next();\n" + // return is '@Nullable ? super CharSequence' -> error
+				"	}\n" + 
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertProblems(problems, new String[] {
+				"Pb(953) Null type mismatch (type annotations): required '@NonNull Object' but this expression has type '@Nullable capture#of ?'",
+				"Pb(953) Null type mismatch (type annotations): required '@NonNull CharSequence' but this expression has type '@Nullable capture#of ? extends CharSequence'",
+				"Pb(953) Null type mismatch (type annotations): required '@NonNull Object' but this expression has type '@Nullable capture#of ? super CharSequence'"
+			}, new int[] { 13, 16, 19 });
+	}
+	
+	public void testLibsWithArrays() throws Exception {
+		myCreateJavaProject("TestLibs");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" + 
+				"import java.util.Collection;\n" + 
+				"import java.util.Iterator;\n" + 
+				"\n" + 
+				"public interface Lib1 {\n" + 
+				"	String[] constraintArrayTop(String[] in);\n" + 
+				"	String[] constraintArrayFull(String[] in);\n" + 
+				"	String[][] constraintDeep(String[][] in);\n" + 
+				"}\n"
+			}, null);
+		createFileInProject("annots/libs", "Lib1.eea", 
+				"class libs/Lib1\n" + 
+				"\n" + 
+				"constraintArrayTop\n" + 
+				" ([Ljava/lang/String;)[Ljava/lang/String;\n" + 
+				" ([0Ljava/lang/String;)[1Ljava/lang/String;\n" + 
+				"\n" + 
+				"constraintArrayFull\n" + 
+				" ([Ljava/lang/String;)[Ljava/lang/String;\n" +
+				" ([0L0java/lang/String;)[1L1java/lang/String;\n" +
+				"\n" +
+				"constraintDeep\n" +
+				" ([[Ljava/lang/String;)[[Ljava/lang/String;\n" +
+				" ([0[1L0java/lang/String;)[1[0L1java/lang/String;\n");
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	String @NonNull[] test1(Lib1 lib, String @Nullable[] ok, String[] nok) {\n" + 
+				"		lib.constraintArrayTop(nok);\n" + 
+				"		return lib.constraintArrayTop(ok);\n" + 
+				"	}\n" +
+				"	@NonNull String @NonNull[] test2(Lib1 lib, @Nullable String @Nullable[] ok, String[] nok) {\n" + 
+				"		lib.constraintArrayFull(nok);\n" + 
+				"		return lib.constraintArrayFull(ok);\n" + 
+				"	}\n" + 
+				"	@NonNull String @NonNull[] @Nullable[] test3(Lib1 lib, @Nullable String @Nullable[] @NonNull[] ok, String[][] nok) {\n" + 
+				"		lib.constraintDeep(nok);\n" + 
+				"		return lib.constraintDeep(ok);\n" + 
+				"	}\n" + 
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertProblems(problems, new String[] {
+			"Pb(955) Null type safety (type annotations): The expression of type 'String[]' needs unchecked conversion to conform to '@Nullable String @Nullable[]'",
+			"Pb(955) Null type safety (type annotations): The expression of type 'String[][]' needs unchecked conversion to conform to '@Nullable String @Nullable[] @NonNull[]'",
+		}, new int[] { 12, 16 });
+	}
+
+	public void testLibsWithFields() throws Exception {
+		myCreateJavaProject("TestLibs");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" +
+				"public interface Lib1 {\n" + 
+				"	String one = \"1\";\n" + 
+				"	String none = null;\n" + 
+				"}\n"
+			}, null);
+		createFileInProject("annots/libs", "Lib1.eea", 
+				"class libs/Lib1\n" +
+				"\n" + 
+				"one\n" + 
+				" Ljava/lang/String;\n" + 
+				" L1java/lang/String;\n" + 
+				"\n" + 
+				"none\n" + 
+				" Ljava/lang/String;\n" +
+				" L0java/lang/String;\n" +
+				"\n");
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	@NonNull String test0() {\n" + 
+				"		return Lib1.none;\n" + 
+				"	}\n" +
+				"	@NonNull String test1() {\n" + 
+				"		return Lib1.one;\n" + 
+				"	}\n" +
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertProblems(problems, new String[] {
+			"Pb(953) Null type mismatch (type annotations): required '@NonNull String' but this expression has type '@Nullable String'",
+		}, new int[] { 8 });
+	}
+
+	public void testLibsWithFieldsZipped() throws Exception {
+		myCreateJavaProject("TestLibs");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots.zip", new String[] {
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" +
+				"public interface Lib1 {\n" + 
+				"	String one = \"1\";\n" + 
+				"	String none = null;\n" + 
+				"}\n"
+			}, null);
+		Util.createSourceZip(
+			new String[] {
+				"libs/Lib1.eea", 
+				"class libs/Lib1\n" +
+				"\n" + 
+				"one\n" + 
+				" Ljava/lang/String;\n" + 
+				" L1java/lang/String;\n" + 
+				"\n" + 
+				"none\n" + 
+				" Ljava/lang/String;\n" +
+				" L0java/lang/String;\n" +
+				"\n"
+			},
+			this.project.getProject().getLocation().toString()+"/annots.zip");
+	    this.project.getProject().refreshLocal(IResource.DEPTH_INFINITE, null);
+
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	@NonNull String test0() {\n" + 
+				"		return Lib1.none;\n" + 
+				"	}\n" +
+				"	@NonNull String test1() {\n" + 
+				"		return Lib1.one;\n" + 
+				"	}\n" +
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertProblems(problems, new String[] {
+			"Pb(953) Null type mismatch (type annotations): required '@NonNull String' but this expression has type '@Nullable String'",
+		}, new int[] { 8 });
+	}
+
+	public void testLibsWithFieldsExternalZipped() throws Exception {
+		myCreateJavaProject("TestLibs");
+		String zipPath = Util.getOutputDirectory() + '/' + "annots.zip";
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", zipPath, new String[] {
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" +
+				"public interface Lib1 {\n" + 
+				"	String one = \"1\";\n" + 
+				"	String none = null;\n" + 
+				"}\n"
+			}, null);
+		Util.createSourceZip(
+			new String[] {
+				"libs/Lib1.eea", 
+				"class libs/Lib1\n" +
+				"\n" + 
+				"one\n" + 
+				" Ljava/lang/String;\n" + 
+				" L1java/lang/String;\n" + 
+				"\n" + 
+				"none\n" + 
+				" Ljava/lang/String;\n" +
+				" L0java/lang/String;\n" +
+				"\n"
+			},
+			zipPath);
+
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	@NonNull String test0() {\n" + 
+				"		return Lib1.none;\n" + 
+				"	}\n" +
+				"	@NonNull String test1() {\n" + 
+				"		return Lib1.one;\n" + 
+				"	}\n" +
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertProblems(problems, new String[] {
+			"Pb(953) Null type mismatch (type annotations): required '@NonNull String' but this expression has type '@Nullable String'",
+		}, new int[] { 8 });
+	}
+
+	public void testLibsWithTypeParameters() throws Exception {
+		myCreateJavaProject("TestLibs");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" +
+				"public interface Lib1<U,V,W extends U> {\n" + 
+				"	U getU();\n" + 
+				"	V getV();\n" +
+				"	W getW();\n" +
+				"	<X,Y extends CharSequence> Y fun(X x);\n" + 
+				"}\n"
+			}, null);
+		createFileInProject("annots/libs", "Lib1.eea", 
+				"class libs/Lib1\n" +
+				" <U:Ljava/lang/Object;V:Ljava/lang/Object;W:TU;>\n" +
+				" <0U:Ljava/lang/Object;1V:Ljava/lang/Object;W:T1U;>\n" +
+				"\n" +
+				"fun\n" +
+				" <X:Ljava/lang/Object;Y::Ljava/lang/CharSequence;>(TX;)TY;\n" +
+				" <1X:Ljava/lang/Object;Y::L1java/lang/CharSequence;>(TX;)TY;\n" +
+				"\n");
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	@NonNull String test0(Lib1<@Nullable String,@NonNull String,@NonNull String> l) {\n" + 
+				"		return l.getU();\n" + // mismatch: U is nullable 
+				"	}\n" +
+				"	@NonNull String test1(Lib1<@Nullable String,@NonNull String,@NonNull String> l) {\n" + 
+				"		return l.getV();\n" + // OK: V is nonnull
+				"	}\n" +
+				"	@NonNull String test2(Lib1<@Nullable String,@NonNull String,@NonNull String> l) {\n" + 
+				"		return l.getW();\n" + // OK: V is nonnull
+				"	}\n" +
+				"	Lib1<@NonNull String, @NonNull String, @NonNull String> f1;\n" + // mismatch at U
+				"	Lib1<@Nullable String, String, @NonNull String> f2;\n" + // mismatch at V
+				"	Lib1<@Nullable String, @NonNull String, @Nullable String> f3;\n" + // mismatch at W
+				"	@Nullable String test3(Lib1<@Nullable String,@NonNull String,@NonNull String> l) {\n" +
+				"		return l.<@Nullable String,@Nullable String>fun(\"\");\n" + // mismatches at X and Y
+				"	}\n" +
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertProblems(problems, new String[] {
+			"Pb(953) Null type mismatch (type annotations): required '@NonNull String' but this expression has type '@Nullable String'",
+			"Pb(964) Null constraint mismatch: The type '@NonNull String' is not a valid substitute for the type parameter '@Nullable U extends Object'",
+			"Pb(964) Null constraint mismatch: The type 'String' is not a valid substitute for the type parameter '@NonNull V extends Object'",
+			"Pb(964) Null constraint mismatch: The type '@Nullable String' is not a valid substitute for the type parameter '@NonNull W extends @NonNull U extends Object'", // FIXME(stephan): @NonNull before W is bogus, see https://bugs.eclipse.org/456532
+			"Pb(964) Null constraint mismatch: The type '@Nullable String' is not a valid substitute for the type parameter '@NonNull X extends Object'",
+			"Pb(964) Null constraint mismatch: The type '@Nullable String' is not a valid substitute for the type parameter '@NonNull Y extends @NonNull CharSequence'", // FIXME(see above)
+		}, new int[] { 8, 16, 17, 18, 20, 20 });
+	}
+
+	public void testLibsWithTypeArgOfSuper() throws Exception {
+		myCreateJavaProject("TestLibs");
+		addLibraryWithExternalAnnotations(this.project, "lib1.jar", "annots", new String[] {
+				"/UnannotatedLib/libs/LibSuper.java",
+				"package libs;\n" + 
+				"\n" +
+				"public interface LibSuper<T,U> {\n" + 
+				"	U apply(T t);\n" + 
+				"}\n",
+				"/UnannotatedLib/libs/Lib1.java",
+				"package libs;\n" + 
+				"\n" +
+				"public interface Lib1 extends LibSuper<String,Exception> {\n" + 
+				"}\n"
+			}, null);
+		createFileInProject("annots/libs", "Lib1.eea", 
+				"class libs/Lib1\n" +
+				"super libs/LibSuper\n" +
+				" <Ljava/lang/String;Ljava/lang/Exception;>\n" +
+				" <L1java/lang/String;L0java/lang/Exception;>\n" +
+				"\n");
+		IPackageFragment fragment = this.project.getPackageFragmentRoots()[0].createPackageFragment("tests", true, null);
+		ICompilationUnit unit = fragment.createCompilationUnit("Test1.java", 
+				"package tests;\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"import libs.Lib1;\n" + 
+				"\n" + 
+				"public class Test1 {\n" + 
+				"	@NonNull Exception test0(Lib1 lib, @Nullable String str) {\n" + 
+				"		return lib\n" +
+				"				.apply(str);\n" + 
+				"	}\n" +
+				"}\n",
+				true, new NullProgressMonitor()).getWorkingCopy(new NullProgressMonitor());
+		CompilationUnit reconciled = unit.reconcile(AST.JLS8, true, null, new NullProgressMonitor());
+		IProblem[] problems = reconciled.getProblems();
+		assertProblems(problems, new String[] {
+			"Pb(953) Null type mismatch (type annotations): required '@NonNull Exception' but this expression has type '@Nullable Exception'",
+			"Pb(953) Null type mismatch (type annotations): required '@NonNull String' but this expression has type '@Nullable String'",
+		}, new int[] { 8, 9 });
+	}
+
+	/** Project with real JRE8. */
+	public void test2() throws Exception {
+		Hashtable options = JavaCore.getOptions();
+		try {
+			setupJavaProject("Test2");
+			this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
+			assertNoMarkers(markers);
+		} finally {
+			// project using a full JRE container initializes global options to 1.8 -- must reset now:
+			JavaCore.setOptions(options);
+		}
+	}
+
+	/** Project with real JRE8.
+	 * More interesting work with generics
+	 * .classpath uses var TESTWORK for path to external annotations.
+	 */
+	public void test3() throws Exception {
+		final String TESTWORK_VAR_NAME = "TESTWORK";
+		JavaCore.setClasspathVariable(TESTWORK_VAR_NAME, new Path(getSourceWorkspacePath()), null);
+		Hashtable options = JavaCore.getOptions();
+		try {
+			setupJavaProject("Test3");
+			this.project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = this.project.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, false, IResource.DEPTH_INFINITE);
+			assertNoMarkers(markers);
+		} finally {
+			// project using a full JRE container initializes global options to 1.8 -- must reset now:
+			JavaCore.setOptions(options);
+			JavaCore.removeClasspathVariable(TESTWORK_VAR_NAME, null);
+		}
+	}
+
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/.classpath
new file mode 100644
index 0000000..964d9d0
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/.classpath
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="var" path="JCL17_LIB"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/.project
new file mode 100644
index 0000000..bd0683a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Test1</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/annots/libs/MyMap.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/annots/libs/MyMap.eea
new file mode 100644
index 0000000..a9090bd
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/annots/libs/MyMap.eea
@@ -0,0 +1,12 @@
+class libs/MyMap
+ <K:V:>
+
+get
+ (Ljava/lang/Object;)TV;
+ (L1java/lang/Object;)T0V;
+put
+ (TK;TV;)TV;
+ (T0K;T1V;)T0V;
+remove
+ (Ljava/lang/Object;)TV;
+ (Ljava/lang/Object;)T0V;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/src/test1/Test1.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/src/test1/Test1.java
new file mode 100644
index 0000000..959df55
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations17/Test1/src/test1/Test1.java
@@ -0,0 +1,11 @@
+package test1;
+
+import libs.MyMap;
+
+public class Test1 {
+	String test1(MyMap<String,Test1> map) {
+		map.put(null, null); // key is OK (@Nullable), val is err (@NonNull)
+		Test1 v = map.get(null); // err: key is @NonNull via eea
+		return v.toString(); // err: v is @Nullable via eea
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath
new file mode 100644
index 0000000..f8a6de7
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.classpath
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="var" path="JCL18_LIB"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project
new file mode 100644
index 0000000..bd0683a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Test1</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/libs/MyMap.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/libs/MyMap.eea
new file mode 100644
index 0000000..7b80da8
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/annots/libs/MyMap.eea
@@ -0,0 +1,12 @@
+class libs/MyMap
+ <K:V:>
+
+get
+ (Ljava/lang/Object;)TV;
+ (Ljava/lang/Object;)T0V;
+put
+ (TK;TV;)TV;
+ (TK;TV;)T0V;
+remove
+ (Ljava/lang/Object;)TV;
+ (Ljava/lang/Object;)T0V;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java
new file mode 100644
index 0000000..05b7d3a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test1/src/test1/Test1.java
@@ -0,0 +1,13 @@
+package test1;
+
+import libs.MyMap;
+import org.eclipse.jdt.annotation.*;
+
+@NonNullByDefault
+public class Test1 {
+	void test(MyMap<String,Test1> map, String key) {
+		Test1 v = map.get(key);
+		if (v == null)
+			throw new RuntimeException(); // should not be reported as dead code, although V is a '@NonNull Test1'
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath
new file mode 100644
index 0000000..611bff8
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.core.tests.model.TEST_CONTAINER">
+		<attributes>
+			<attribute name="annotationpath" value="annots"/>
+		</attributes>
+	</classpathentry> 
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project
new file mode 100644
index 0000000..1b369ff
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Test2</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
new file mode 100644
index 0000000..48eadcc
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/annots/java/util/Map.eea
@@ -0,0 +1,12 @@
+class java/util/Map Version=1.8
+ <K:V:>
+
+get
+ (Ljava/lang/Object;)TV;
+ (Ljava/lang/Object;)T0V; Source=manual Author=Au@th.or
+put
+ (TK;TV;)TV;
+ (TK;TV;)T0V;
+remove
+ (Ljava/lang/Object;)TV;
+ (Ljava/lang/Object;)T0V;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java
new file mode 100644
index 0000000..e483874
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test2/src/test1/Test1.java
@@ -0,0 +1,13 @@
+package test1;
+
+import java.util.Map;
+import org.eclipse.jdt.annotation.*;
+
+@NonNullByDefault
+public class Test1 {
+	void test(Map<String,Test1> map, String key) {
+		Test1 v = map.get(key);
+		if (v == null)
+			throw new RuntimeException(); // should not be reported as dead code, although V is a '@NonNull Test1'
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath
new file mode 100644
index 0000000..398dc89
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.core.tests.model.TEST_CONTAINER">
+		<attributes>
+			<attribute name="annotationpath" value="TESTWORK/Test3/annots"/>
+		</attributes>
+	</classpathentry> 
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project
new file mode 100644
index 0000000..ea7fde1
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Test3</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
new file mode 100644
index 0000000..4b2412e
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/annots/java/util/function/Function.eea
@@ -0,0 +1,6 @@
+class java/util/function/Function
+ <T:R:>
+
+compose
+ <V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+TT;>;)Ljava/util/function/Function<TV;TR;>;
+ <V:Ljava/lang/Object;>(Ljava/util/function/Function<-TV;+T0T;>;)Ljava/util/function/Function<TV;TR;>;
diff --git a/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java
new file mode 100644
index 0000000..4e025c6
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/workspace/ExternalAnnotations18/Test3/src/test1/Test3.java
@@ -0,0 +1,16 @@
+package test1;
+
+import org.eclipse.jdt.annotation.*;
+import java.util.function.*;
+
+
+class A {}
+class B {}
+class C {}
+
+@NonNullByDefault
+public class Test3 {
+	C test(Function<A,@Nullable B> f1, Function<B,C> f2, A a) {
+		return f2.compose(f1).apply(a); // actually incompatible, but we tweak compose to pretend it's compatible
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index d12ef90..181ad0e 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.batch;
 
@@ -27,6 +29,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.util.ManifestAnalyzer;
+import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
 @SuppressWarnings({"rawtypes", "unchecked"})
@@ -34,8 +37,10 @@ public class ClasspathJar extends ClasspathLocation {
 
 protected File file;
 protected ZipFile zipFile;
+protected ZipFile annotationZipFile;
 protected boolean closeZipFileAtEnd;
 protected Hashtable packageCache;
+protected String annotationPath;
 
 public ClasspathJar(File file, boolean closeZipFileAtEnd,
 		AccessRuleSet accessRuleSet, String destinationPath) {
@@ -96,8 +101,17 @@ public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageN
 
 	try {
 		ClassFileReader reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
-		if (reader != null)
+		if (reader != null) {
+			if (this.annotationPath != null) {
+				String qualifiedClassName = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length()-SuffixConstants.EXTENSION_CLASS.length()-1);
+				try {
+					this.annotationZipFile = reader.setExternalAnnotationProvider(this.annotationPath, qualifiedClassName, this.annotationZipFile, null);
+				} catch (IOException e) {
+					// don't let error on annotations fail class reading
+				}
+			}
 			return new NameEnvironmentAnswer(reader, fetchAccessRestriction(qualifiedBinaryFileName));
+		}
 	} catch(ClassFormatException e) {
 		// treat as if class file is missing
 	} catch (IOException e) {
@@ -168,13 +182,23 @@ public boolean isPackage(String qualifiedPackageName) {
 	return this.packageCache.containsKey(qualifiedPackageName);
 }
 public void reset() {
-	if (this.zipFile != null && this.closeZipFileAtEnd) {
-		try {
-			this.zipFile.close();
-		} catch(IOException e) {
-			// ignore
+	if (this.closeZipFileAtEnd) {
+		if (this.zipFile != null) {
+			try {
+				this.zipFile.close();
+			} catch(IOException e) {
+				// ignore
+			}
+			this.zipFile = null;
+		}
+		if (this.annotationZipFile != null) {
+			try {
+				this.annotationZipFile.close();
+			} catch(IOException e) {
+				// ignore
+			}
+			this.annotationZipFile = null;
 		}
-		this.zipFile = null;
 	}
 	this.packageCache = null;
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index e8f4893..93554e9 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -19,6 +19,7 @@
  *								bug 375366 - ECJ ignores unusedParameterIncludeDocCommentReference unless enableJavadoc option is set
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *     Jesper S Moller   - Contributions for
  *								bug 407297 - [1.8][compiler] Control generation of parameter names by option
  *    Mat Booth - Contribution for bug 405176 
@@ -1296,6 +1297,8 @@ public class Main implements ProblemSeverities, SuffixConstants {
 	/* Bundle containing messages */
 	public ResourceBundle bundle;
 	protected FileSystem.Classpath[] checkedClasspaths;
+	// path to external annotations:
+	protected String annotationPath;
 
 	public Locale compilerLocale;
 	public CompilerOptions compilerOptions; // read-only
@@ -1757,6 +1760,7 @@ public void configure(String[] argv) {
 	final int INSIDE_S_start = 19;
 	final int INSIDE_CLASS_NAMES = 20;
 	final int INSIDE_WARNINGS_PROPERTIES = 21;
+	final int INSIDE_ANNOTATIONPATH_start = 22;
 
 	final int DEFAULT = 0;
 	ArrayList bootclasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
@@ -1765,6 +1769,7 @@ public void configure(String[] argv) {
 	ArrayList classpaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
 	ArrayList extdirsClasspaths = null;
 	ArrayList endorsedDirClasspaths = null;
+	this.annotationPath = null;
 
 	int index = -1;
 	int filesCount = 0;
@@ -2450,6 +2455,10 @@ public void configure(String[] argv) {
 					this.options.put(CompilerOptions.OPTION_ReportMissingNonNullByDefaultAnnotation, CompilerOptions.WARNING);
 					continue;
 				}
+				if (currentArg.equals("-annotationpath")) { //$NON-NLS-1$
+					mode = INSIDE_ANNOTATIONPATH_start;
+					continue;
+				}
 				break;
 			case INSIDE_TARGET :
 				if (this.didSpecifyTarget) {
@@ -2649,6 +2658,10 @@ public void configure(String[] argv) {
 				initializeWarnings(currentArg);
 				mode = DEFAULT;
 				continue;
+			case INSIDE_ANNOTATIONPATH_start:
+				mode = DEFAULT;
+				this.annotationPath = currentArg;
+				continue;
 		}
 
 		// default is input directory, if no custom destination path exists
@@ -4558,6 +4571,13 @@ protected void setPaths(ArrayList bootclasspaths,
 	this.checkedClasspaths = new FileSystem.Classpath[classpaths.size()];
 	classpaths.toArray(this.checkedClasspaths);
 	this.logger.logClasspath(this.checkedClasspaths);
+
+	if (this.annotationPath != null) {
+		for (FileSystem.Classpath cp : this.checkedClasspaths) {
+			if (cp instanceof ClasspathJar)
+				((ClasspathJar) cp).annotationPath = this.annotationPath;
+		}
+	}
 }
 private static boolean shouldIgnoreOptionalProblems(char[][] folderNames, char[] fileName) {
 	if (folderNames == null || fileName == null) {
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index f9d635a..905f39f 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -263,6 +263,9 @@ misc.usage = {1} {2}\n\
 \    -Xemacs            used to enable emacs-style output in the console.\n\
 \                       It does not affect the xml log output\n\
 \    -missingNullDefault  report missing default nullness annotation\n\
+\    -annotationpath <path>\n\
+\                       Path to a base directory or zip file holding external\n\
+\                       annotations to support annotation-based null analysis\n\
 \ \n\
 \    -? -help           print this help message\n\
 \    -v -version        print compiler version\n\
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
index 05d9399..3d56dc8 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2008, 2013 IBM Corporation and others.
+ * Copyright (c) 2008, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								Bug 392384 - [1.8][compiler][null] Restore nullness info from type annotations in class files
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.codeassist;
 
@@ -39,7 +40,7 @@ import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
@@ -339,7 +340,7 @@ public class InternalExtendedCompletionContext {
 
 			SignatureWrapper wrapper = new SignatureWrapper(replacePackagesDot(typeSignature.toCharArray()));
 			// FIXME(stephan): do we interpret type annotations here?
-			assignableTypeBinding = this.lookupEnvironment.getTypeFromTypeSignature(wrapper, typeVariables, this.assistScope.enclosingClassScope().referenceContext.binding, null, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+			assignableTypeBinding = this.lookupEnvironment.getTypeFromTypeSignature(wrapper, typeVariables, this.assistScope.enclosingClassScope().referenceContext.binding, null, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 			assignableTypeBinding = BinaryTypeBinding.resolveType(assignableTypeBinding, this.lookupEnvironment, true);
 		} catch (AbortCompilation e) {
 			assignableTypeBinding = null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index a643a36..9fbcb34 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,22 +7,30 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 365992 - [builder] [null] Change of nullness for a parameter doesn't trigger a build for the files that call the method
+ *     Stephan Herrmann - Contribution for
+ *								Bug 365992 - [builder] [null] Change of nullness for a parameter doesn't trigger a build for the files that call the method
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
- *         bug 407191 - [1.8] Binary access support for type annotations
+ *         						bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Arrays;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants;
 import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
@@ -56,6 +64,7 @@ public class ClassFileReader extends ClassFileStruct implements IBinaryType {
 	private char[][][] missingTypeNames;
 	private int enclosingNameAndTypeIndex;
 	private char[] enclosingMethod;
+	private ExternalAnnotationProvider annotationProvider;
 
 private static String printTypeModifiers(int modifiers) {
 	java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream();
@@ -396,6 +405,75 @@ public ClassFileReader(byte[] classFileBytes, char[] fileName, boolean fullyInit
 	}
 }
 
+/** Auxiliary interface for {@link #setExternalAnnotationProvider(String,String,ZipFile,ZipFileProducer)}. */
+public interface ZipFileProducer { ZipFile produce() throws IOException; }
+
+/**
+ * Create and remember a provider for external annotations using the given basePath,
+ * which is either a directory holding .eea text files, or a zip file of entries of the same format.
+ * @param basePath resolved filesystem path of either directory or zip file
+ * @param qualifiedBinaryTypeName slash-separated type name
+ * @param zipFile an existing zip file for the same basePath, or null. 
+ * 		Output: wl be filled with 
+ * @param producer an optional helper to produce the zipFile when needed.
+ * @return the client provided zip file; 
+ * 		or else a fresh new zip file, to let clients cache it, if desired; 
+ * 		or null to signal that basePath is not a zip file, but a directory.
+ * @throws IOException any unexpected errors during file access. File not found while
+ *		accessing an individual file if basePath is a directory <em>is</em> expected,
+ *		and simply answered with null. If basePath is neither a directory nor a zip file,
+ *		this is unexpected.
+ */
+public ZipFile setExternalAnnotationProvider(String basePath, String qualifiedBinaryTypeName, ZipFile zipFile, ZipFileProducer producer) throws IOException {
+	String qualifiedBinaryFileName = qualifiedBinaryTypeName + ExternalAnnotationProvider.ANNOTATION_FILE_SUFFIX;
+	if (zipFile == null) {
+		File annotationBase = new File(basePath);
+		if (annotationBase.isDirectory()) {
+			try {
+				String filePath = annotationBase.getAbsolutePath()+'/'+qualifiedBinaryFileName;
+				this.annotationProvider = new ExternalAnnotationProvider(new FileInputStream(filePath), String.valueOf(getName()));
+			} catch (FileNotFoundException e) {
+				// expected, no need to report an error here
+			}
+			return null; // no zipFile
+		}
+		if (!annotationBase.exists())
+			return null; // no zipFile, treat as not-yet-created directory
+		zipFile = (producer != null ? producer.produce() : new ZipFile(annotationBase));
+	}
+	ZipEntry entry = zipFile.getEntry(qualifiedBinaryFileName);
+	if (entry != null)
+		this.annotationProvider = new ExternalAnnotationProvider(zipFile.getInputStream(entry), String.valueOf(getName()));
+	return zipFile;
+}
+
+/**
+ * Conditionally add external annotations to the mix.
+ * If 'member' is given it must be either of IBinaryField or IBinaryMethod, in which case we're seeking annotations for that member.
+ * Otherwise we're seeking annotations for top-level elements of a type (type parameters & super types).
+ */
+@Override
+public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWalker walker, Object member, LookupEnvironment environment) {
+	if (walker == ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER && this.annotationProvider != null) {
+		if (member == null) {
+			return this.annotationProvider.forTypeHeader(environment);
+		} else if (member instanceof IBinaryField) {
+			IBinaryField field = (IBinaryField) member;
+			char[] fieldSignature = field.getGenericSignature();
+			if (fieldSignature == null)
+				fieldSignature = field.getTypeName();
+			return this.annotationProvider.forField(field.getName(), fieldSignature, environment);
+		} else if (member instanceof IBinaryMethod) {
+			IBinaryMethod method = (IBinaryMethod) member;
+			char[] methodSignature = method.getGenericSignature();
+			if (methodSignature == null)
+				methodSignature = method.getMethodDescriptor();
+			return this.annotationProvider.forMethod(method.isConstructor() ? TypeConstants.INIT : method.getSelector(), methodSignature, environment);
+		}
+	}
+	return walker;
+}
+
 /**
  * Answer the receiver's access flags.  The value of the access_flags
  *	item is a mask of modifiers used with class and interface declarations.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
new file mode 100644
index 0000000..bc64451
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -0,0 +1,636 @@
+/*******************************************************************************
+ * Copyright (c) 2014, 2015 GK Software AG.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.classfmt;
+
+import static org.eclipse.jdt.core.util.ExternalAnnotationUtil.NONNULL;
+import static org.eclipse.jdt.core.util.ExternalAnnotationUtil.NULLABLE;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.LineNumberReader;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+import org.eclipse.jdt.internal.compiler.lookup.SignatureWrapper;
+import org.eclipse.jdt.internal.compiler.util.Util;
+
+public class ExternalAnnotationProvider {
+
+	public static final String ANNOTION_FILE_EXTENSION= "eea"; //$NON-NLS-1$
+	public static final String CLASS_PREFIX = "class "; //$NON-NLS-1$
+	public static final String SUPER_PREFIX = "super "; //$NON-NLS-1$
+
+	static final String ANNOTATION_FILE_SUFFIX = ".eea"; //$NON-NLS-1$
+
+	private static final String TYPE_PARAMETER_PREFIX = " <"; //$NON-NLS-1$
+
+
+	private String typeName;
+	String typeParametersAnnotationSource;
+	Map<String,String> supertypeAnnotationSources;
+	private Map<String,String> methodAnnotationSources;
+	private Map<String,String> fieldAnnotationSources;
+	
+	/**
+	 * Create and initialize.
+	 * @param input open input stream to read the annotations from, will be closed by the constructor.
+	 * @param typeName slash-separated qualified name of a type
+	 * @throws IOException various issues when accessing the annotation file
+	 */
+	public ExternalAnnotationProvider(InputStream input, String typeName) throws IOException {
+		this.typeName = typeName;
+		initialize(input);
+	}
+
+	private void initialize(InputStream input) throws IOException {
+		LineNumberReader reader = new LineNumberReader(new InputStreamReader(input));
+		try {
+			String line = reader.readLine().trim();
+			if (line.startsWith(CLASS_PREFIX)) {
+				line = line.substring(CLASS_PREFIX.length());
+			} else {
+				throw new IOException("missing class header in annotation file"); //$NON-NLS-1$
+			}
+			if (!trimTail(line).equals(this.typeName)) {
+				throw new IOException("mismatching class name in annotation file, expected "+this.typeName+", but header said "+line); //$NON-NLS-1$ //$NON-NLS-2$
+			}
+			if ((line = reader.readLine()) == null) {
+				return;
+			}
+			if (line.startsWith(TYPE_PARAMETER_PREFIX)) {
+				if ((line = reader.readLine()) == null) // skip first line, second line may contain type parameter annotations
+					return;
+				if (line.startsWith(TYPE_PARAMETER_PREFIX)) {
+					this.typeParametersAnnotationSource = line.substring(TYPE_PARAMETER_PREFIX.length());
+					if ((line = reader.readLine()) == null)
+						return;
+				} 
+			}
+			do {
+				line = line.trim();
+				if (line.isEmpty()) continue;
+				String rawSig = null, annotSig = null;
+				// selector:
+				String selector = line;
+				boolean isSuper = selector.startsWith(SUPER_PREFIX);
+				if (isSuper)
+					selector = selector.substring(SUPER_PREFIX.length());
+				int errLine = -1;
+				try {
+					// raw signature:
+					line = reader.readLine();
+					if (line != null && !line.isEmpty() && line.charAt(0) == ' ') // first signature line is mandatory
+						rawSig = line.substring(1);
+					else
+						errLine = reader.getLineNumber();
+					// annotated signature:
+					line = reader.readLine();
+					if (line == null || line.isEmpty())
+						continue; // skip since optional line with annotations is missing
+					if (line.charAt(0) == ' ')
+						annotSig = line.substring(1);
+				} catch (Exception ex) {
+					// continue to escalate below
+				}
+				if (rawSig == null || annotSig == null) {
+					if (errLine == -1) errLine = reader.getLineNumber();
+					throw new IOException("Illegal format for annotation file at line "+errLine); //$NON-NLS-1$
+				}
+				// discard optional meta data (separated by whitespace):
+				annotSig = trimTail(annotSig);
+				if (isSuper) {
+					if (this.supertypeAnnotationSources == null)
+						this.supertypeAnnotationSources = new HashMap<String, String>();
+					this.supertypeAnnotationSources.put('L'+selector+rawSig+';', annotSig);
+				} else if (rawSig.contains("(")) { //$NON-NLS-1$
+					if (this.methodAnnotationSources == null)
+						this.methodAnnotationSources = new HashMap<String, String>();
+					this.methodAnnotationSources.put(selector+rawSig, annotSig);
+				} else {
+					if (this.fieldAnnotationSources == null)
+						this.fieldAnnotationSources = new HashMap<String, String>();
+					this.fieldAnnotationSources.put(selector+':'+rawSig, annotSig);
+				}
+			} while ((line = reader.readLine()) != null);
+		} finally {
+			reader.close();
+		}
+	}
+
+	/** Lines may contain arbitrary trailing data, separated by white space. */
+	protected String trimTail(String line) {
+		int tail = line.indexOf(' ');
+		if (tail == -1)
+			tail = line.indexOf('\t');
+		if (tail != -1) 
+			return line.substring(0, tail);
+		return line;
+	}
+
+	public ITypeAnnotationWalker forTypeHeader(LookupEnvironment environment) {
+		if (this.typeParametersAnnotationSource != null || this.supertypeAnnotationSources != null)
+			return new DispatchingAnnotationWalker(environment);
+		return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+	}
+
+	public ITypeAnnotationWalker forMethod(char[] selector, char[] signature, LookupEnvironment environment) {
+		Map<String, String> sources = this.methodAnnotationSources;
+		if (sources != null) {
+			String source = sources.get(String.valueOf(CharOperation.concat(selector, signature)));
+			if (source != null)
+				return new MethodAnnotationWalker(source.toCharArray(), 0, environment);
+		}
+		return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+	}
+
+	public ITypeAnnotationWalker forField(char[] selector, char[] signature, LookupEnvironment environment) {
+		if (this.fieldAnnotationSources != null) {
+			String source = this.fieldAnnotationSources.get(String.valueOf(CharOperation.concat(selector, signature, ':')));
+			if (source != null)
+				return new FieldAnnotationWalker(source.toCharArray(), 0, environment);
+		}
+		return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+	}
+
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		sb.append("External Annotations for ").append(this.typeName).append('\n'); //$NON-NLS-1$
+		sb.append("Methods:\n"); //$NON-NLS-1$
+		if (this.methodAnnotationSources != null)
+			for (Entry<String,String> e : this.methodAnnotationSources.entrySet())
+				sb.append('\t').append(e.getKey()).append('\n');
+		return sb.toString();
+	}
+
+	abstract class SingleMarkerAnnotation implements IBinaryAnnotation {
+		@Override
+		public IBinaryElementValuePair[] getElementValuePairs() {
+			return ElementValuePairInfo.NoMembers;
+		}
+		protected char[] getBinaryTypeName(char[][] name) {
+			return CharOperation.concat('L', CharOperation.concatWith(name, '/'), ';');
+		}
+	}
+
+	SingleMarkerAnnotation NULLABLE_ANNOTATION, NONNULL_ANNOTATION;
+
+	void initAnnotations(final LookupEnvironment environment) {
+		if (this.NULLABLE_ANNOTATION == null) {
+			this.NULLABLE_ANNOTATION = new SingleMarkerAnnotation() {
+				@Override public char[] getTypeName() { return getBinaryTypeName(environment.getNullableAnnotationName()); }
+			};
+		}
+		if (this.NONNULL_ANNOTATION == null) {
+			this.NONNULL_ANNOTATION = new SingleMarkerAnnotation() {
+				@Override public char[] getTypeName() { return getBinaryTypeName(environment.getNonNullAnnotationName()); }
+			};
+		}
+	}
+
+	/**
+	 * Walker for top-level elements of a type (type parameters & super types),
+	 * which dispatches to specialized walkers for those details.
+	 */
+	class DispatchingAnnotationWalker implements ITypeAnnotationWalker {
+
+		private LookupEnvironment environment;
+		private TypeParametersAnnotationWalker typeParametersWalker;
+
+		public DispatchingAnnotationWalker(LookupEnvironment environment) {
+			this.environment = environment;
+		}
+		public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+			String source = ExternalAnnotationProvider.this.typeParametersAnnotationSource;
+			if (source != null) {
+				if (this.typeParametersWalker == null) 
+					this.typeParametersWalker = new TypeParametersAnnotationWalker(source.toCharArray(), 0, 0, null, this.environment);
+				return this.typeParametersWalker.toTypeParameter(isClassTypeParameter, rank);
+			}
+			return this;
+		}
+		public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+			if (this.typeParametersWalker != null)
+				return this.typeParametersWalker.toTypeParameterBounds(isClassTypeParameter, parameterRank);
+			return this;
+		}
+		public ITypeAnnotationWalker toSupertype(short index, char[] superTypeSignature) {
+			Map<String, String> sources = ExternalAnnotationProvider.this.supertypeAnnotationSources;
+			if (sources != null) {
+				String source = sources.get(String.valueOf(superTypeSignature));
+				if (source != null)
+					return new SuperTypesAnnotationWalker(source.toCharArray(), this.environment);
+			}
+			return this;
+		}
+		// the rest is borrowed from EMPTY_ANNOTATION_WALKER:
+		public ITypeAnnotationWalker toField() { return this; }
+		public ITypeAnnotationWalker toThrows(int rank) { return this; }
+		public ITypeAnnotationWalker toTypeArgument(int rank) { return this; }
+		public ITypeAnnotationWalker toMethodParameter(short index) { return this; }
+		public ITypeAnnotationWalker toTypeBound(short boundIndex) { return this; }
+		public ITypeAnnotationWalker toMethodReturn() { return this; }
+		public ITypeAnnotationWalker toReceiver() { return this; }
+		public ITypeAnnotationWalker toWildcardBound() { return this; }
+		public ITypeAnnotationWalker toNextArrayDimension() { return this; }
+		public ITypeAnnotationWalker toNextNestedType() { return this; }
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) { return NO_ANNOTATIONS; }
+	}
+
+	abstract class BasicAnnotationWalker implements ITypeAnnotationWalker {
+		
+		char[] source;
+		SignatureWrapper wrapper;
+		int pos;
+		int prevTypeArgStart;
+		int currentTypeBound;
+		LookupEnvironment environment;
+
+		BasicAnnotationWalker(char[] source, int pos, LookupEnvironment environment) {
+			this.source = source;
+			this.pos = pos;
+			this.environment = environment;
+			initAnnotations(environment);
+		}
+		
+		SignatureWrapper wrapperWithStart(int start) {
+			if (this.wrapper == null)
+				this.wrapper = new SignatureWrapper(this.source);
+			this.wrapper.start = start;
+			return this.wrapper;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toReceiver() {
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeBound(short boundIndex) {
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toSupertype(short index, char[] superTypeSignature) {
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeArgument(int rank) {
+			if (rank == 0) {
+				int start = CharOperation.indexOf('<', this.source, this.pos) + 1;
+				this.prevTypeArgStart = start;
+				return new MethodAnnotationWalker(this.source, start, this.environment);
+			}
+			int next = this.prevTypeArgStart;
+			switch (this.source[next]) {
+				case '*': 
+					break;
+				case '-': 
+				case '+':
+					next++;
+					//$FALL-THROUGH$
+				default:
+					next = wrapperWithStart(next).computeEnd();
+			}
+			next++;
+		    this.prevTypeArgStart = next;
+		    return new MethodAnnotationWalker(this.source, next,	this.environment);
+		}
+
+		@Override
+		public ITypeAnnotationWalker toWildcardBound() {
+			switch (this.source[this.pos]) {
+				case '-': 
+				case '+':
+					return new MethodAnnotationWalker(this.source, this.pos+1, this.environment);
+				default: // includes unbounded '*'
+					return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+			}			
+		}
+
+		@Override
+		public ITypeAnnotationWalker toNextArrayDimension() {
+			if (this.source[this.pos] == '[') {
+				int newPos = this.pos+1;
+				switch (this.source[newPos]) {
+					case NULLABLE: case NONNULL: newPos++; break;
+				}
+				return new MethodAnnotationWalker(this.source, newPos, this.environment);
+			}
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toNextNestedType() {
+			return this; // FIXME(stephan)
+		}
+
+		@Override
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
+			if (this.pos != -1 && this.pos < this.source.length-2) {
+				switch (this.source[this.pos]) {
+					case 'T':
+					case 'L':
+					case '[':
+					case '*':
+					case '+':
+					case '-':
+						switch (this.source[this.pos+1]) {
+							case NULLABLE:
+								return new IBinaryAnnotation[]{ ExternalAnnotationProvider.this.NULLABLE_ANNOTATION };
+							case NONNULL:
+								return new IBinaryAnnotation[]{ ExternalAnnotationProvider.this.NONNULL_ANNOTATION };
+						}
+				}				
+			}
+			return null;
+		}
+	}
+
+	/**
+	 * Walker that may serve the annotations on type parameters of the current class or method.
+	 */
+	public class TypeParametersAnnotationWalker extends BasicAnnotationWalker {
+
+		int[] rankStarts; // indices of start positions for type parameters per rank
+		int currentRank;
+
+		TypeParametersAnnotationWalker(char[] source, int pos, int rank, int[] rankStarts, LookupEnvironment environment) {
+			super(source, pos, environment);
+			this.currentRank = rank;
+			if (rankStarts != null) {
+				this.rankStarts = rankStarts;
+			} else {
+				// eagerly scan all type parameters:
+				int length = source.length;
+				rankStarts = new int[length];
+				int curRank = 0;
+				// next block cf. BinaryTypeBinding.createTypeVariables():
+				int depth = 0;
+				boolean pendingVariable = true;
+				scanVariables: {
+					for (int i = pos; i < length; i++) {
+						switch(this.source[i]) {
+							case Util.C_GENERIC_START :
+								depth++;
+								break;
+							case Util.C_GENERIC_END :
+								if (--depth < 0)
+									break scanVariables;
+								break;
+							case Util.C_NAME_END :
+								if ((depth == 0) && (i +1 < length) && (this.source[i+1] != Util.C_COLON))
+									pendingVariable = true;
+								break;
+							default:
+								if (pendingVariable) {
+									pendingVariable = false;
+									rankStarts[curRank++] = i;
+								}
+						}
+					}
+				}
+				System.arraycopy(rankStarts, 0, this.rankStarts = new int[curRank], 0, curRank);
+			}
+		}
+		
+		@Override
+		public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+			if (rank == this.currentRank)
+				return this;
+			if (rank < this.rankStarts.length)
+				return new TypeParametersAnnotationWalker(this.source, this.rankStarts[rank], rank, this.rankStarts, this.environment);
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+			return new TypeParametersAnnotationWalker(this.source, this.rankStarts[parameterRank], parameterRank, this.rankStarts, this.environment);
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeBound(short boundIndex) {
+			// assume we are positioned either at the start of the bounded type parameter
+			// or at the start of a previous type bound
+			int p = this.pos;
+			int i = this.currentTypeBound;
+			while(true) {
+				// each bound is prefixed with ':'
+				int colon = CharOperation.indexOf(Util.C_COLON, this.source, p);
+				if (colon != -1)
+					p = colon + 1;
+				if (++i > boundIndex) break;
+				// skip next type:
+				p = wrapperWithStart(p).computeEnd()+1;
+			}
+			this.pos = p;
+			this.currentTypeBound = boundIndex;
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toField() {
+			throw new UnsupportedOperationException("Cannot navigate to fields"); //$NON-NLS-1$
+		}
+
+		@Override
+		public ITypeAnnotationWalker toMethodReturn() {
+			throw new UnsupportedOperationException("Cannot navigate to method return"); //$NON-NLS-1$
+		}
+
+		@Override
+		public ITypeAnnotationWalker toMethodParameter(short index) {
+			throw new UnsupportedOperationException("Cannot navigate to method parameter"); //$NON-NLS-1$
+		}
+
+		@Override
+		public ITypeAnnotationWalker toThrows(int index) {
+			throw new UnsupportedOperationException("Cannot navigate to throws"); //$NON-NLS-1$
+		}
+
+		@Override
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
+			if (this.pos != -1 && this.pos < this.source.length-1) {
+				switch (this.source[this.pos]) {
+					case NULLABLE:
+						return new IBinaryAnnotation[]{ ExternalAnnotationProvider.this.NULLABLE_ANNOTATION };
+					case NONNULL:
+						return new IBinaryAnnotation[]{ ExternalAnnotationProvider.this.NONNULL_ANNOTATION };
+				}				
+			}
+			return super.getAnnotationsAtCursor(currentTypeId);
+		}
+	}
+
+	/** Walker serving type annotations on a type's supertypes. */
+	class SuperTypesAnnotationWalker extends BasicAnnotationWalker {
+
+		SuperTypesAnnotationWalker(char[] source, LookupEnvironment environment) {
+			super(source, 0, environment);
+		}
+
+		// actual implementation is inherited, main entries: toTypeArgument & getAnnotationsAtCursor
+
+		@Override
+		public ITypeAnnotationWalker toField() {
+			throw new UnsupportedOperationException("Supertype has no field annotations"); //$NON-NLS-1$
+		}
+
+		@Override
+		public ITypeAnnotationWalker toMethodReturn() {
+			throw new UnsupportedOperationException("Supertype has no method return"); //$NON-NLS-1$
+		}
+
+		@Override
+		public ITypeAnnotationWalker toMethodParameter(short index) {
+			throw new UnsupportedOperationException("Supertype has no method parameter"); //$NON-NLS-1$
+		}
+
+		@Override
+		public ITypeAnnotationWalker toThrows(int index) {
+			throw new UnsupportedOperationException("Supertype has no throws"); //$NON-NLS-1$
+		}
+	}
+
+	public interface IMethodAnnotationWalker extends ITypeAnnotationWalker {
+		int getParameterCount();
+	}
+	class MethodAnnotationWalker extends BasicAnnotationWalker implements IMethodAnnotationWalker {
+
+		int prevParamStart;
+		TypeParametersAnnotationWalker typeParametersWalker;
+
+		MethodAnnotationWalker(char[] source, int pos, LookupEnvironment environment) {
+			super(source, pos, environment);
+		}
+	
+		int typeEnd(int start) {
+			while (this.source[start] == '[') {
+				start++;
+				char an = this.source[start];
+				if (an == NULLABLE || an == NONNULL)
+					start++;
+			}
+			int end = wrapperWithStart(start).computeEnd();
+			return end;
+		}
+		
+		@Override
+		public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+			if (this.source[0] == '<') {
+				if (this.typeParametersWalker == null)
+					return this.typeParametersWalker = new TypeParametersAnnotationWalker(this.source, this.pos+1, rank, null, this.environment);
+				return this.typeParametersWalker.toTypeParameter(isClassTypeParameter, rank);
+			}
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+			if (this.typeParametersWalker != null)
+				return this.typeParametersWalker.toTypeParameterBounds(isClassTypeParameter, parameterRank);
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toMethodReturn() {
+			int close = CharOperation.indexOf(')', this.source);
+			if (close != -1) {
+				// optimization, see toMethodParameter.
+				this.pos = close+1;
+				return this;
+			}
+			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toMethodParameter(short index) {
+			if (index == 0) {
+				int start = CharOperation.indexOf('(', this.source) + 1;
+				this.prevParamStart = start;
+				// optimization: normally we should create a new walker with pos=start,
+				// but since we know the order how BTB/LE call us, we can safely use one walker for all parameters:
+				this.pos = start;
+				return this;
+			}
+			int end = typeEnd(this.prevParamStart); // leverage the fact that all parameters are evaluated in order
+			end++;
+		    this.prevParamStart = end;
+		    // optimization, see above.
+		    this.pos = end;
+		    return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toThrows(int index) {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toField() {
+			throw new UnsupportedOperationException("Methods have no fields"); //$NON-NLS-1$
+		}
+
+		@Override
+		public int getParameterCount() {
+			int count = 0;
+			int start = CharOperation.indexOf('(', this.source) + 1;
+			while (start < this.source.length && this.source[start] != ')') {
+				start = typeEnd(start) + 1;
+				count++;
+			}
+			return count;
+		}
+	}
+	
+	class FieldAnnotationWalker extends BasicAnnotationWalker {
+		public FieldAnnotationWalker(char[] source, int pos, LookupEnvironment environment) {
+			super(source, pos, environment);
+		}
+
+		@Override
+		public ITypeAnnotationWalker toField() {
+			return this;
+		}
+
+		@Override
+		public ITypeAnnotationWalker toMethodReturn() {
+			throw new UnsupportedOperationException("Field has no method return"); //$NON-NLS-1$
+		}
+
+		@Override
+		public ITypeAnnotationWalker toMethodParameter(short index) {
+			throw new UnsupportedOperationException("Field has no method parameter"); //$NON-NLS-1$
+		}
+
+		@Override
+		public ITypeAnnotationWalker toThrows(int index) {
+			throw new UnsupportedOperationException("Field has no throws"); //$NON-NLS-1$
+		}
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
index 911cd6f..ed80d9b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/NonNullDefaultAwareTypeAnnotationWalker.java
@@ -14,6 +14,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
@@ -108,21 +109,21 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 	
 	@Override
-	public TypeAnnotationWalker toMethodParameter(short index) {
+	public ITypeAnnotationWalker toMethodParameter(short index) {
 		// don't set nextIsDefaultLocation, because signature-level nullness is handled by ImplicitNullAnnotationVerifier
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toMethodParameter(index);
 	}
 
 	@Override
-	public TypeAnnotationWalker toMethodReturn() {
+	public ITypeAnnotationWalker toMethodReturn() {
 		// don't set nextIsDefaultLocation, because signature-level nullness is handled by ImplicitNullAnnotationVerifier
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
 		return super.toMethodReturn();
 	}
 
 	@Override
-	public TypeAnnotationWalker toTypeBound(short boundIndex) {
+	public ITypeAnnotationWalker toTypeBound(short boundIndex) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
 		this.nextIsTypeBound = true;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
@@ -130,7 +131,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 
 	@Override
-	public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+	public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeBound) != 0;
 		this.nextIsTypeBound = true;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
@@ -138,7 +139,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 
 	@Override
-	public TypeAnnotationWalker toTypeArgument(int rank) {
+	public ITypeAnnotationWalker toTypeArgument(int rank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeArgument) != 0;
 		this.nextIsTypeBound = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
@@ -146,7 +147,7 @@ public class NonNullDefaultAwareTypeAnnotationWalker extends TypeAnnotationWalke
 	}
 
 	@Override
-	public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+	public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
 		this.nextIsDefaultLocation = (this.defaultNullness & Binding.DefaultLocationTypeParameter) != 0;
 		this.nextIsTypeBound = false;
 		if (this.isEmpty) return restrict(this.matches, this.pathPtr);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
index d36d52a..eba1da2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/TypeAnnotationWalker.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013, 2014 GK Software AG.
+ * Copyright (c) 2013, 2015 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -13,37 +13,11 @@ package org.eclipse.jdt.internal.compiler.classfmt;
 import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 
-/**
- * A TypeAnnotationWalker is initialized with all type annotations found at a given element.
- * It can be used to walk into the types at the given element and finally answer the
- * actual annotations at any node of the walk.
- * 
- * The walker is implemented as immutable objects. During the walk either new instances
- * are created, or the current instance is shared if no difference is encountered.
- */
-public class TypeAnnotationWalker {
+/** Type annotation walker implementation based an actual annotations decoded from a .class file. */
+public class TypeAnnotationWalker implements ITypeAnnotationWalker {
 
-	public static final IBinaryAnnotation[] NO_ANNOTATIONS = new IBinaryAnnotation[0];
-
-	/**
-	 * A no-effect annotation walker, all walking methods are implemented as identity-functions.
-	 * At the end of any walk an empty array of annotations is returned.
-	 */
-	public static final TypeAnnotationWalker EMPTY_ANNOTATION_WALKER = new TypeAnnotationWalker(new IBinaryTypeAnnotation[0], 0L) {
-		public TypeAnnotationWalker toField() { return this; }
-		public TypeAnnotationWalker toTarget(int targetType) { return this; }
-		public TypeAnnotationWalker toThrows(int rank) { return this; }
-		public TypeAnnotationWalker toTypeArgument(int rank) { return this; }
-		public TypeAnnotationWalker toMethodParameter(short index) { return this; }
-		public TypeAnnotationWalker toSupertype(short index) { return this; }
-		public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) { return this; }
-		public TypeAnnotationWalker toTypeBound(short boundIndex) { return this; }
-		public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) { return this; }
-		public TypeAnnotationWalker toNextDetail(int detailKind) { return this; }
-		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) { return NO_ANNOTATIONS; }
-	};
-	
 	final protected IBinaryTypeAnnotation[] typeAnnotations;	// the actual material we're managing here
 	final protected long matches;								// bit mask of indices into typeAnnotations, 1 means active, 0 is filtered during the walk
 	final protected int pathPtr;								// pointer into the typePath
@@ -61,7 +35,7 @@ public class TypeAnnotationWalker {
 		this.pathPtr = pathPtr;
 	}
 
-	protected TypeAnnotationWalker restrict(long newMatches, int newPathPtr) {
+	protected ITypeAnnotationWalker restrict(long newMatches, int newPathPtr) {
 		if (this.matches == newMatches && this.pathPtr == newPathPtr) return this;
 		if (newMatches == 0 || this.typeAnnotations == null || this.typeAnnotations.length == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -70,28 +44,25 @@ public class TypeAnnotationWalker {
 
 	// ==== filter by top-level targetType: ====
 	
-	/** Walk to a field. */
-	public TypeAnnotationWalker toField() {
+	@Override
+	public ITypeAnnotationWalker toField() {
 		return toTarget(AnnotationTargetTypeConstants.FIELD);
 	}
 
-	/** Walk to the return type of a method. */
-	public TypeAnnotationWalker toMethodReturn() {
+	@Override
+	public ITypeAnnotationWalker toMethodReturn() {
 		return toTarget(AnnotationTargetTypeConstants.METHOD_RETURN);
 	}
 
-	/**
-	 * Walk to the receiver type of a method.
-	 * Note: Type annotations on receiver are not currently used by the compiler.
-	 */
-	public TypeAnnotationWalker toReceiver() {
+	@Override
+	public ITypeAnnotationWalker toReceiver() {
 		return toTarget(AnnotationTargetTypeConstants.METHOD_RECEIVER);
 	}
 
 	/*
 	 * Implementation for walking to methodReturn, receiver type or field.
 	 */
-	protected TypeAnnotationWalker toTarget(int targetType) {
+	protected ITypeAnnotationWalker toTarget(int targetType) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -104,12 +75,8 @@ public class TypeAnnotationWalker {
 		return restrict(newMatches, 0);
 	}
 
-	/**
-	 * Walk to the type parameter of the given rank.
-	 * @param isClassTypeParameter whether we are looking for a class type parameter (else: method type type parameter)
-	 * @param rank rank of the type parameter
-	 */
-	public TypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
+	@Override
+	public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -125,13 +92,8 @@ public class TypeAnnotationWalker {
 		return restrict(newMatches, 0);		
 	}
 
-	/**
-	 * Walk to the bounds of a type parameter of either a class or a method (signaled by isClassTypeParameter).
-	 * Clients must then call {@link #toTypeBound(short)} on the resulting walker.
-	 * @param isClassTypeParameter whether we are looking at a class type parameter (else: method type type parameter)
-	 * @param parameterRank rank of the type parameter.
-	 */
-	public TypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
+	@Override
+	public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -147,12 +109,9 @@ public class TypeAnnotationWalker {
 		}
 		return restrict(newMatches, 0);	
 	}
-	/**
-	 * Detail of {@link #toTypeParameterBounds(boolean, int)}: walk to the bounds
-	 * of the previously selected type parameter. 
-	 * @param boundIndex
-	 */
-	public TypeAnnotationWalker toTypeBound(short boundIndex) {
+
+	@Override
+	public ITypeAnnotationWalker toTypeBound(short boundIndex) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -168,8 +127,12 @@ public class TypeAnnotationWalker {
 	}
 	
 	
-	/** Walk to the specified supertype: -1 is superclass, else the superinterface at the given index. */
-	public TypeAnnotationWalker toSupertype(short index) {
+	/**
+	 * {@inheritDoc}
+	 * <p>(superTypesSignature is ignored in this implementation).</p>
+	 */
+	@Override
+	public ITypeAnnotationWalker toSupertype(short index, char[] superTypeSignature) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -184,8 +147,8 @@ public class TypeAnnotationWalker {
 		return restrict(newMatches, 0);		
 	}
 
-	/** Walk to the index'th visible formal method parameter (i.e., not counting synthetic args). */
-	public TypeAnnotationWalker toMethodParameter(short index) {
+	@Override
+	public ITypeAnnotationWalker toMethodParameter(short index) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -200,10 +163,8 @@ public class TypeAnnotationWalker {
 		return restrict(newMatches, 0);		
 	}
 
-	/**
-	 * Walk to the throws type at the given index.
-	 */
-	public TypeAnnotationWalker toThrows(int index) {
+	@Override
+	public ITypeAnnotationWalker toThrows(int index) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -220,8 +181,8 @@ public class TypeAnnotationWalker {
 
 	// ==== descending into details: ====
 
-	/** Walk to the type argument of the given rank. */
-	public TypeAnnotationWalker toTypeArgument(int rank) {
+	@Override
+	public ITypeAnnotationWalker toTypeArgument(int rank) {
 		// like toNextDetail() but also checking byte 2 against rank
 		long newMatches = this.matches;
 		if (newMatches == 0)
@@ -240,8 +201,8 @@ public class TypeAnnotationWalker {
 		return restrict(newMatches, this.pathPtr+2);		
 	}
 
-	/** Walk to the bound of a wildcard. */
-	public TypeAnnotationWalker toWildcardBound() {
+	@Override
+	public ITypeAnnotationWalker toWildcardBound() {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -258,25 +219,20 @@ public class TypeAnnotationWalker {
 		return restrict(newMatches, this.pathPtr+2);		
 	}
 
-	/**
-	 * Descend down one level of array dimensions.
-	 */
-	public TypeAnnotationWalker toNextArrayDimension() {
+	@Override
+	public ITypeAnnotationWalker toNextArrayDimension() {
 		return toNextDetail(AnnotationTargetTypeConstants.NEXT_ARRAY_DIMENSION);
 	}
 	
-	/**
-	 * Descend down one level of type nesting.
-	 */
-	public TypeAnnotationWalker toNextNestedType() {
+	@Override
+	public ITypeAnnotationWalker toNextNestedType() {
 		return toNextDetail(AnnotationTargetTypeConstants.NEXT_NESTED_TYPE);
 	}
 
 	/*
 	 * Implementation for walking along the type_path for array dimensions & nested types.
-	 * FIXME(stephan): support wildcard bounds.
 	 */
-	protected TypeAnnotationWalker toNextDetail(int detailKind) {
+	protected ITypeAnnotationWalker toNextDetail(int detailKind) {
 		long newMatches = this.matches;
 		if (newMatches == 0)
 			return EMPTY_ANNOTATION_WALKER;
@@ -294,12 +250,7 @@ public class TypeAnnotationWalker {
 	
 	// ==== leaves: the actual annotations: ====
 	
-	/**
-	 * Retrieve the type annotations at the current position
-	 * reached by invocations of toXYZ() methods.
-	 * @param currentTypeId the id of the type being annotated; 0 signals don't care / unknown;
-	 * 		 -1 signals if annotating a wildcard or a use of a type variable.
-	 */
+	@Override
 	public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) {
 		int length = this.typeAnnotations.length;
 		IBinaryAnnotation[] filtered = new IBinaryAnnotation[length];
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
index 2cf3efa..4d58e4f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,10 +9,13 @@
  *     IBM Corporation - initial API and implementation
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *         bug 407191 - [1.8] Binary access support for type annotations
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440474 - [null] textual encoding of external null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.env;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 
 public interface IBinaryType extends IGenericType {
 
@@ -148,4 +151,13 @@ boolean isMember();
 
 char[] sourceFileName();
 
+/**
+ * Answer a type annotation walker that takes into consideration also external annotations.
+ * @param walker previous walker, may be empty, otherwise it will be returned unchanged
+ * @param member if either a IBinaryField or a IBinaryMethod is provided, answer a walker specifically for that member
+ * @param environment for use by the walker
+ * @return either a matching walker with data from external annotations or the walker provided via argument 'walker'.
+ */
+ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWalker walker, Object member, LookupEnvironment environment);
+
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
new file mode 100644
index 0000000..1f595ae
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ITypeAnnotationWalker.java
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * Copyright (c) 2015 GK Software AG.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.env;
+
+
+/**
+ * A TypeAnnotationWalker is initialized with all type annotations found at a given element.
+ * It can be used to walk into the types at the given element and finally answer the
+ * actual annotations at any node of the walk.
+ * 
+ * The walker is implemented as immutable objects. During the walk either new instances
+ * are created, or the current instance is shared if no difference is encountered.
+ */
+public interface ITypeAnnotationWalker {
+
+	public static final IBinaryAnnotation[] NO_ANNOTATIONS = new IBinaryAnnotation[0];
+	/**
+	 * A no-effect annotation walker, all walking methods are implemented as identity-functions.
+	 * At the end of any walk an empty array of annotations is returned.
+	 */
+	public static final ITypeAnnotationWalker EMPTY_ANNOTATION_WALKER = new ITypeAnnotationWalker() {
+		public ITypeAnnotationWalker toField() { return this; }
+		public ITypeAnnotationWalker toThrows(int rank) { return this; }
+		public ITypeAnnotationWalker toTypeArgument(int rank) { return this; }
+		public ITypeAnnotationWalker toMethodParameter(short index) { return this; }
+		public ITypeAnnotationWalker toSupertype(short index, char[] superTypeSignature) { return this; }
+		public ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank) { return this; }
+		public ITypeAnnotationWalker toTypeBound(short boundIndex) { return this; }
+		public ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank) { return this; }
+		public ITypeAnnotationWalker toMethodReturn() { return this; }
+		public ITypeAnnotationWalker toReceiver() { return this; }
+		public ITypeAnnotationWalker toWildcardBound() { return this; }
+		public ITypeAnnotationWalker toNextArrayDimension() { return this; }
+		public ITypeAnnotationWalker toNextNestedType() { return this; }
+		public IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId) { return NO_ANNOTATIONS; }
+	};
+
+	/** Walk to a field. */
+	public abstract ITypeAnnotationWalker toField();
+
+
+	/** Walk to the return type of a method. */
+	public abstract ITypeAnnotationWalker toMethodReturn();
+
+	/**
+	 * Walk to the receiver type of a method.
+	 * Note: Type annotations on receiver are not currently used by the compiler.
+	 */
+	public abstract ITypeAnnotationWalker toReceiver();
+
+	/**
+	 * Walk to the type parameter of the given rank.
+	 * @param isClassTypeParameter whether we are looking for a class type parameter (else: method type parameter)
+	 * @param rank rank of the type parameter
+	 */
+	public abstract ITypeAnnotationWalker toTypeParameter(boolean isClassTypeParameter, int rank);
+
+	/**
+	 * Walk to the bounds of a type parameter of either a class or a method (signaled by isClassTypeParameter).
+	 * Clients must then call {@link #toTypeBound(short)} on the resulting walker.
+	 * @param isClassTypeParameter whether we are looking at a class type parameter (else: method type parameter)
+	 * @param parameterRank rank of the type parameter.
+	 */
+	public abstract ITypeAnnotationWalker toTypeParameterBounds(boolean isClassTypeParameter, int parameterRank);
+
+	/**
+	 * Detail of {@link #toTypeParameterBounds(boolean, int)}: walk to the bounds
+	 * of the previously selected type parameter. 
+	 * @param boundIndex
+	 */
+	public abstract ITypeAnnotationWalker toTypeBound(short boundIndex);
+
+	/** Walk to the specified supertype either index based or name based:
+	 * @param index -1 is superclass, else index into the list of superinterfaces 
+	 * @param superTypeSignature name and type arguments of the super type to visit
+	 */
+	public abstract ITypeAnnotationWalker toSupertype(short index, char[] superTypeSignature);
+
+	/** Walk to the index'th visible formal method parameter (i.e., not counting synthetic args). */
+	public abstract ITypeAnnotationWalker toMethodParameter(short index);
+
+	/**
+	 * Walk to the throws type at the given index.
+	 */
+	public abstract ITypeAnnotationWalker toThrows(int index);
+
+	/** Walk to the type argument of the given rank. */
+	public abstract ITypeAnnotationWalker toTypeArgument(int rank);
+
+	/** Walk to the bound of a wildcard. */
+	public abstract ITypeAnnotationWalker toWildcardBound();
+
+	/**
+	 * Descend down one level of array dimensions.
+	 */
+	public abstract ITypeAnnotationWalker toNextArrayDimension();
+
+	/**
+	 * Descend down one level of type nesting.
+	 */
+	public abstract ITypeAnnotationWalker toNextNestedType();
+
+	/**
+	 * Retrieve the type annotations at the current position
+	 * reached by invocations of toXYZ() methods.
+	 * @param currentTypeId the id of the type being annotated; 0 signals don't care / unknown;
+	 * 		 -1 signals if annotating a wildcard or a use of a type variable.
+	 */
+	public abstract IBinaryAnnotation[] getAnnotationsAtCursor(int currentTypeId);
+
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index d2662d5..3ea657a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -29,6 +29,7 @@
  *								Bug 438458 - [1.8][null] clean up handling of null type annotations wrt type variables
  *								Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
  *								Bug 434602 - Possible error with inferred null annotations leading to contradictory null annotations
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *								Bug 441693 - [1.8][null] Bogus warning for type argument annotated with @NonNull
  *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *								Bug 453475 - [1.8][null] Contradictory null annotations (4.5 M3 edition)
@@ -44,6 +45,7 @@ import java.util.ArrayList;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationProvider.IMethodAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.classfmt.NonNullDefaultAwareTypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
@@ -93,12 +95,12 @@ static Object convertMemberValue(Object binaryValue, LookupEnvironment env, char
 	if (binaryValue instanceof Constant)
 		return binaryValue;
 	if (binaryValue instanceof ClassSignature)
-		return env.getTypeFromSignature(((ClassSignature) binaryValue).getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+		return env.getTypeFromSignature(((ClassSignature) binaryValue).getTypeName(), 0, -1, false, null, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 	if (binaryValue instanceof IBinaryAnnotation)
 		return createAnnotation((IBinaryAnnotation) binaryValue, env, missingTypeNames);
 	if (binaryValue instanceof EnumConstantSignature) {
 		EnumConstantSignature ref = (EnumConstantSignature) binaryValue;
-		ReferenceBinding enumType = (ReferenceBinding) env.getTypeFromSignature(ref.getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+		ReferenceBinding enumType = (ReferenceBinding) env.getTypeFromSignature(ref.getTypeName(), 0, -1, false, null, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 		if (enumType.isUnresolvedType() && !resolveEnumConstants)
 			return new ElementValuePair.UnresolvedEnumConstant(enumType, env, ref.getEnumConstantName());
 		enumType = (ReferenceBinding) resolveType(enumType, env, false /* no raw conversion */);
@@ -406,7 +408,8 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 			// need annotations on the type before processing null annotations on members respecting any @NonNullByDefault:
 			scanTypeForNullDefaultAnnotation(binaryType, this.fPackage);
 		}
-		TypeAnnotationWalker walker = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
+		ITypeAnnotationWalker walker = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
+		ITypeAnnotationWalker toplevelWalker = binaryType.enrichWithExternalAnnotationsFor(walker, null, this.environment);
 		char[] typeSignature = binaryType.getGenericSignature(); // use generic signature even in 1.4
 		this.tagBits |= binaryType.getTagBits();
 		
@@ -418,7 +421,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 			if (wrapper.signature[wrapper.start] == Util.C_GENERIC_START) {
 				// ParameterPart = '<' ParameterSignature(s) '>'
 				wrapper.start++; // skip '<'
-				this.typeVariables = createTypeVariables(wrapper, true, missingTypeNames, walker, true/*class*/);
+				this.typeVariables = createTypeVariables(wrapper, true, missingTypeNames, toplevelWalker, true/*class*/);
 				wrapper.start++; // skip '>'
 				this.tagBits |=  TagBits.HasUnresolvedTypeVariables;
 				this.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
@@ -437,7 +440,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 			char[] superclassName = binaryType.getSuperclassName();
 			if (superclassName != null) {
 				// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)
-				this.superclass = this.environment.getTypeFromConstantPoolName(superclassName, 0, -1, false, missingTypeNames, walker.toSupertype((short) -1));
+				this.superclass = this.environment.getTypeFromConstantPoolName(superclassName, 0, -1, false, missingTypeNames, toplevelWalker.toSupertype((short) -1, superclassName));
 				this.tagBits |= TagBits.HasUnresolvedSuperclass;
 			}
 
@@ -449,14 +452,14 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 					this.superInterfaces = new ReferenceBinding[size];
 					for (short i = 0; i < size; i++)
 						// attempt to find each superinterface if it exists in the cache (otherwise - resolve it when requested)
-						this.superInterfaces[i] = this.environment.getTypeFromConstantPoolName(interfaceNames[i], 0, -1, false, missingTypeNames, walker.toSupertype(i));
+						this.superInterfaces[i] = this.environment.getTypeFromConstantPoolName(interfaceNames[i], 0, -1, false, missingTypeNames, toplevelWalker.toSupertype(i, superclassName));
 					this.tagBits |= TagBits.HasUnresolvedSuperinterfaces;
 				}
 			}
 		} else {
 			// attempt to find the superclass if it exists in the cache (otherwise - resolve it when requested)
 			this.superclass = (ReferenceBinding) this.environment.getTypeFromTypeSignature(wrapper, typeVars, this, missingTypeNames, 
-																		walker.toSupertype((short) -1));
+																		toplevelWalker.toSupertype((short) -1, wrapper.peekFullType()));
 			this.tagBits |= TagBits.HasUnresolvedSuperclass;
 
 			this.superInterfaces = Binding.NO_SUPERINTERFACES;
@@ -465,7 +468,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 				java.util.ArrayList types = new java.util.ArrayList(2);
 				short rank = 0;
 				do {
-					types.add(this.environment.getTypeFromTypeSignature(wrapper, typeVars, this, missingTypeNames, walker.toSupertype(rank++)));
+					types.add(this.environment.getTypeFromTypeSignature(wrapper, typeVars, this, missingTypeNames, toplevelWalker.toSupertype(rank++, wrapper.peekFullType())));
 				} while (!wrapper.atEnd());
 				this.superInterfaces = new ReferenceBinding[types.size()];
 				types.toArray(this.superInterfaces);
@@ -475,8 +478,8 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 
 		if (needFieldsAndMethods) {
 			IBinaryField[] iFields = binaryType.getFields();
-			createFields(iFields, sourceLevel, missingTypeNames);
-			IBinaryMethod[] iMethods = createMethods(binaryType.getMethods(), sourceLevel, missingTypeNames);
+			createFields(iFields, binaryType, sourceLevel, missingTypeNames);
+			IBinaryMethod[] iMethods = createMethods(binaryType.getMethods(), binaryType, sourceLevel, missingTypeNames);
 			boolean isViewedAsDeprecated = isViewedAsDeprecated();
 			if (isViewedAsDeprecated) {
 				for (int i = 0, max = this.fields.length; i < max; i++) {
@@ -494,12 +497,22 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 			}
 			if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
 				if (iFields != null) {
-					for (int i = 0; i < iFields.length; i++)
-						scanFieldForNullAnnotation(iFields[i], this.fields[i], this.isEnum());
+					for (int i = 0; i < iFields.length; i++) {
+						// below 1.8 we still might use an annotation walker to discover external annotations:
+						ITypeAnnotationWalker fieldWalker = ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+						if (sourceLevel < ClassFileConstants.JDK1_8)
+							fieldWalker = binaryType.enrichWithExternalAnnotationsFor(walker, iFields[i], this.environment);
+						scanFieldForNullAnnotation(iFields[i], this.fields[i], this.isEnum(), fieldWalker);
+					}
 				}
 				if (iMethods != null) {
-					for (int i = 0; i < iMethods.length; i++)
-						scanMethodForNullAnnotation(iMethods[i], this.methods[i]);
+					for (int i = 0; i < iMethods.length; i++) {
+						// below 1.8 we still might use an annotation walker to discover external annotations:
+						ITypeAnnotationWalker methodWalker = ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+						if (sourceLevel < ClassFileConstants.JDK1_8)
+							methodWalker = binaryType.enrichWithExternalAnnotationsFor(methodWalker, iMethods[i], this.environment);
+						scanMethodForNullAnnotation(iMethods[i], this.methods[i], methodWalker);
+					}
 				}
 			}
 		}
@@ -516,7 +529,7 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 	}
 }
 
-private TypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] annotations) {
+private ITypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] annotations) {
 	if (!isPrototype()) throw new IllegalStateException();
 	if (annotations == null || annotations.length == 0 || !this.environment.usesAnnotatedTypeSystem()) {
 		if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
@@ -524,7 +537,7 @@ private TypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] ann
 			if (nullness > Binding.NULL_UNSPECIFIED_BY_DEFAULT)
 				return new NonNullDefaultAwareTypeAnnotationWalker(nullness, this.environment);
 		}
-		return TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
+		return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
 	}
 	if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
 		int nullness = getNullDefault();
@@ -534,7 +547,8 @@ private TypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] ann
 	return new TypeAnnotationWalker(annotations);
 }
 
-private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] missingTypeNames) {
+
+private void createFields(IBinaryField[] iFields, IBinaryType binaryType, long sourceLevel, char[][][] missingTypeNames) {
 	if (!isPrototype()) throw new IllegalStateException();
 	this.fields = Binding.NO_FIELDS;
 	if (iFields != null) {
@@ -547,7 +561,11 @@ private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] m
 			for (int i = 0; i < size; i++) {
 				IBinaryField binaryField = iFields[i];
 				char[] fieldSignature = use15specifics ? binaryField.getGenericSignature() : null;
-				TypeAnnotationWalker walker = getTypeAnnotationWalker(binaryField.getTypeAnnotations()).toField();
+				ITypeAnnotationWalker walker = getTypeAnnotationWalker(binaryField.getTypeAnnotations());
+				if (sourceLevel >= ClassFileConstants.JDK1_8) { // below 1.8, external annotations will be attached later
+					walker = binaryType.enrichWithExternalAnnotationsFor(walker, iFields[i], this.environment);
+				}
+				walker = walker.toField();
 				TypeBinding type = fieldSignature == null
 					? this.environment.getTypeFromSignature(binaryField.getTypeName(), 0, -1, false, this, missingTypeNames, walker)
 					: this.environment.getTypeFromTypeSignature(new SignatureWrapper(fieldSignature), Binding.NO_TYPE_VARIABLES, this, missingTypeNames, walker);
@@ -583,7 +601,7 @@ private void createFields(IBinaryField[] iFields, long sourceLevel, char[][][] m
 	}
 }
 
-private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[][][] missingTypeNames) {
+private MethodBinding createMethod(IBinaryMethod method, IBinaryType binaryType, long sourceLevel, char[][][] missingTypeNames) {
 	if (!isPrototype()) throw new IllegalStateException();
 	int methodModifiers = method.getModifiers() | ExtraCompilerModifiers.AccUnresolved;
 	if (sourceLevel < ClassFileConstants.JDK1_5)
@@ -609,10 +627,13 @@ private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[
 	   variables properly in order to be able to apply substitutions and thus be able to detect
 	   overriding in the presence of generics. Seeing the erased form is not good enough.
 	 */
-	TypeAnnotationWalker walker = getTypeAnnotationWalker(method.getTypeAnnotations());
+	ITypeAnnotationWalker walker = getTypeAnnotationWalker(method.getTypeAnnotations());
 	char[] methodSignature = method.getGenericSignature(); // always use generic signature, even in 1.4
 	if (methodSignature == null) { // no generics
 		char[] methodDescriptor = method.getMethodDescriptor();   // of the form (I[Ljava/jang/String;)V
+		if (sourceLevel >= ClassFileConstants.JDK1_8) { // below 1.8, external annotations will be attached later
+			walker = binaryType.enrichWithExternalAnnotationsFor(walker, method, this.environment);
+		}
 		int numOfParams = 0;
 		char nextChar;
 		int index = 0; // first character is always '(' so skip it
@@ -686,6 +707,9 @@ private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[
 		}
 
 	} else {
+		if (sourceLevel >= ClassFileConstants.JDK1_8) { // below 1.8, external annotations will be attached later
+			walker = binaryType.enrichWithExternalAnnotationsFor(walker, method, this.environment);
+		}
 		methodModifiers |= ExtraCompilerModifiers.AccGenericSignature;
 		// MethodTypeSignature = ParameterPart(optional) '(' TypeSignatures ')' return_typeSignature ['^' TypeSignature (optional)]
 		SignatureWrapper wrapper = new SignatureWrapper(methodSignature, use15specifics);
@@ -783,7 +807,7 @@ private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[
  * As some iMethods may be ignored in this process we return the matching array of those
  * iMethods for which MethodBindings have been created; indices match those in this.methods.
  */
-private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, long sourceLevel, char[][][] missingTypeNames) {
+private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, IBinaryType binaryType, long sourceLevel, char[][][] missingTypeNames) {
 	if (!isPrototype()) throw new IllegalStateException();
 	int total = 0, initialTotal = 0, iClinit = -1;
 	int[] toSkip = null;
@@ -818,7 +842,7 @@ private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, long sourceLevel
 	this.methods = new MethodBinding[total];
 	if (total == initialTotal) {
 		for (int i = 0; i < initialTotal; i++) {
-			MethodBinding method = createMethod(iMethods[i], sourceLevel, missingTypeNames);
+			MethodBinding method = createMethod(iMethods[i], binaryType, sourceLevel, missingTypeNames);
 			if (hasRestrictedAccess)
 				method.modifiers |= ExtraCompilerModifiers.AccRestrictedAccess;
 			this.methods[i] = method;
@@ -828,7 +852,7 @@ private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, long sourceLevel
 		IBinaryMethod[] mappedBinaryMethods = new IBinaryMethod[total];
 		for (int i = 0, index = 0; i < initialTotal; i++) {
 			if (iClinit != i && (toSkip == null || toSkip[i] != -1)) {
-				MethodBinding method = createMethod(iMethods[i], sourceLevel, missingTypeNames);
+				MethodBinding method = createMethod(iMethods[i], binaryType, sourceLevel, missingTypeNames);
 				if (hasRestrictedAccess)
 					method.modifiers |= ExtraCompilerModifiers.AccRestrictedAccess;
 				mappedBinaryMethods[index] = iMethods[i];
@@ -840,7 +864,7 @@ private IBinaryMethod[] createMethods(IBinaryMethod[] iMethods, long sourceLevel
 }
 
 private TypeVariableBinding[] createTypeVariables(SignatureWrapper wrapper, boolean assignVariables, char[][][] missingTypeNames,
-													TypeAnnotationWalker walker, boolean isClassTypeParameter)
+													ITypeAnnotationWalker walker, boolean isClassTypeParameter)
 {
 	if (!isPrototype()) throw new IllegalStateException();
 	// detect all type variables first
@@ -957,7 +981,7 @@ private MethodBinding findMethod(char[] methodDescriptor, char[][][] missingType
 				while ((nextChar = methodDescriptor[++end]) != Util.C_NAME_END){/*empty*/}
 
 			// not interested in type annotations, type will be used for comparison only, and erasure() is used if needed
-			TypeBinding param = this.environment.getTypeFromSignature(methodDescriptor, index, end, false, this, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+			TypeBinding param = this.environment.getTypeFromSignature(methodDescriptor, index, end, false, this, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 			if (param instanceof UnresolvedReferenceBinding) {
 				param = resolveType(param, this.environment, true /* raw conversion */);
 			}
@@ -1228,7 +1252,7 @@ public boolean hasTypeBit(int bit) {
 	}
 	return (this.typeBits & bit) != 0;
 }
-private void initializeTypeVariable(TypeVariableBinding variable, TypeVariableBinding[] existingVariables, SignatureWrapper wrapper, char[][][] missingTypeNames, TypeAnnotationWalker walker) {
+private void initializeTypeVariable(TypeVariableBinding variable, TypeVariableBinding[] existingVariables, SignatureWrapper wrapper, char[][][] missingTypeNames, ITypeAnnotationWalker walker) {
 	if (!isPrototype()) throw new IllegalStateException();
 	// ParameterSignature = Identifier ':' TypeSignature
 	//   or Identifier ':' TypeSignature(optional) InterfaceBound(s)
@@ -1239,6 +1263,7 @@ private void initializeTypeVariable(TypeVariableBinding variable, TypeVariableBi
 	short rank = 0;
 	if (wrapper.signature[wrapper.start] == Util.C_COLON) {
 		type = this.environment.getResolvedType(TypeConstants.JAVA_LANG_OBJECT, null);
+		rank++;
 	} else {
 		TypeBinding typeFromTypeSignature = this.environment.getTypeFromTypeSignature(wrapper, existingVariables, this, missingTypeNames, walker.toTypeBound(rank++));
 		if (typeFromTypeSignature instanceof ReferenceBinding) {
@@ -1470,7 +1495,7 @@ SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 }
 
 //pre: null annotation analysis is enabled
-private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBinding, boolean isEnum) {
+private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBinding, boolean isEnum, ITypeAnnotationWalker externalAnnotationWalker) {
 	if (!isPrototype()) throw new IllegalStateException();
 
 	if (isEnum && (field.getModifiers() & ClassFileConstants.AccEnum) != 0) {
@@ -1499,7 +1524,9 @@ private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBi
 		return; // null annotations are only applied to reference types
 
 	boolean explicitNullness = false;
-	IBinaryAnnotation[] annotations = field.getAnnotations();
+	IBinaryAnnotation[] annotations = externalAnnotationWalker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER
+											? externalAnnotationWalker.getAnnotationsAtCursor(fieldBinding.type.id) 
+											: field.getAnnotations();
 	if (annotations != null) {
 		for (int i = 0; i < annotations.length; i++) {
 			char[] annotationTypeName = annotations[i].getTypeName();
@@ -1523,7 +1550,7 @@ private void scanFieldForNullAnnotation(IBinaryField field, FieldBinding fieldBi
 	}
 }
 
-private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding) {
+private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding, ITypeAnnotationWalker externalAnnotationWalker) {
 	if (!isPrototype()) throw new IllegalStateException();
 	char[][] nullableAnnotationName = this.environment.getNullableAnnotationName();
 	char[][] nonNullAnnotationName = this.environment.getNonNullAnnotationName();
@@ -1532,7 +1559,10 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 		return; // not well-configured to use null annotations
 
 	// return:
-	IBinaryAnnotation[] annotations = method.getAnnotations();
+	ITypeAnnotationWalker returnWalker = externalAnnotationWalker.toMethodReturn();
+	IBinaryAnnotation[] annotations = returnWalker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER
+								? returnWalker.getAnnotationsAtCursor(methodBinding.returnType.id)
+								: method.getAnnotations();
 	if (annotations != null) {
 		for (int i = 0; i < annotations.length; i++) {
 			char[] annotationTypeName = annotations[i].getTypeName();
@@ -1556,12 +1586,17 @@ private void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding met
 	// parameters:
 	TypeBinding[] parameters = methodBinding.parameters;
 	int numVisibleParams = parameters.length;
-	int numParamAnnotations = method.getAnnotatedParametersCount();
+	int numParamAnnotations = externalAnnotationWalker instanceof IMethodAnnotationWalker
+							? ((IMethodAnnotationWalker) externalAnnotationWalker).getParameterCount()
+							: method.getAnnotatedParametersCount();
 	if (numParamAnnotations > 0) {
 		for (int j = 0; j < numVisibleParams; j++) {
 			if (numParamAnnotations > 0) {
 				int startIndex = numParamAnnotations - numVisibleParams;
-				IBinaryAnnotation[] paramAnnotations = method.getParameterAnnotations(j+startIndex);
+				ITypeAnnotationWalker parameterWalker = externalAnnotationWalker.toMethodParameter((short) (j+startIndex));
+				IBinaryAnnotation[] paramAnnotations = parameterWalker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER
+															? parameterWalker.getAnnotationsAtCursor(parameters[j].id)
+															: method.getParameterAnnotations(j+startIndex);
 				if (paramAnnotations != null) {
 					for (int i = 0; i < paramAnnotations.length; i++) {
 						char[] annotationTypeName = paramAnnotations[i].getTypeName();
@@ -1714,7 +1749,7 @@ private void scanTypeForContainerAnnotation(IBinaryType binaryType, char[][][] m
 				if (elementValuePairs != null && elementValuePairs.length == 1) {
 					Object value = elementValuePairs[0].getValue();
 					if (value instanceof ClassSignature) {
-						this.containerAnnotationType = (ReferenceBinding) this.environment.getTypeFromSignature(((ClassSignature)value).getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+						this.containerAnnotationType = (ReferenceBinding) this.environment.getTypeFromSignature(((ClassSignature)value).getTypeName(), 0, -1, false, null, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 					}
 				}
 				break;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index e8ba49e..91706e6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -30,6 +30,7 @@
  *								Bug 435805 - [1.8][compiler][null] Java 8 compiler does not recognize declaration style null annotations
  *								Bug 453475 - [1.8][null] Contradictory null annotations (4.5 M3 edition)
  *								Bug 457079 - Regression: type inference
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -45,7 +46,6 @@ import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.ITypeRequestor;
@@ -1197,7 +1197,7 @@ public ReferenceBinding getType(char[][] compoundName) {
 }
 
 private TypeBinding[] getTypeArgumentsFromSignature(SignatureWrapper wrapper, TypeVariableBinding[] staticVariables, ReferenceBinding enclosingType, ReferenceBinding genericType,
-		char[][][] missingTypeNames, TypeAnnotationWalker walker)
+		char[][][] missingTypeNames, ITypeAnnotationWalker walker)
 {
 	java.util.ArrayList args = new java.util.ArrayList(2);
 	int rank = 0;
@@ -1250,7 +1250,7 @@ private ReferenceBinding getTypeFromCompoundName(char[][] compoundName, boolean
 *
 * NOTE: Does NOT answer base types nor array types!
 */
-ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int end, boolean isParameterized, char[][][] missingTypeNames, TypeAnnotationWalker walker) {
+ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int end, boolean isParameterized, char[][][] missingTypeNames, ITypeAnnotationWalker walker) {
 	if (end == -1)
 		end = signature.length;
 	char[][] compoundName = CharOperation.splitOn('/', signature, start, end);
@@ -1264,14 +1264,14 @@ ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int en
 		}
 	}
 	ReferenceBinding binding = getTypeFromCompoundName(compoundName, isParameterized, wasMissingType);
-	if (walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		binding = (ReferenceBinding) annotateType(binding, walker, missingTypeNames);
 	}
 	return binding;
 }
 
 ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int end, boolean isParameterized, char[][][] missingTypeNames) {
-	return getTypeFromConstantPoolName(signature, start, end, isParameterized, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+	return getTypeFromConstantPoolName(signature, start, end, isParameterized, missingTypeNames, ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 }
 
 /* Answer the type corresponding to the signature from the binary file.
@@ -1281,7 +1281,7 @@ ReferenceBinding getTypeFromConstantPoolName(char[] signature, int start, int en
 * NOTE: Does answer base types & array types.
 */
 TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean isParameterized, TypeBinding enclosingType, 
-		char[][][] missingTypeNames, TypeAnnotationWalker walker)
+		char[][][] missingTypeNames, ITypeAnnotationWalker walker)
 {
 	int dimension = 0;
 	while (signature[start] == '[') {
@@ -1290,7 +1290,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 	}
 	// annotations on dimensions?
 	AnnotationBinding [][] annotationsOnDimensions = null;
-	if (dimension > 0 && walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (dimension > 0 && walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		for (int i = 0; i < dimension; i++) {
 			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0), this, missingTypeNames);
 			if (annotations != Binding.NO_ANNOTATIONS) { 
@@ -1350,7 +1350,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 		return binding;
 	}
 	
-	if (walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		binding = annotateType(binding, walker, missingTypeNames);
 	}
 	
@@ -1360,7 +1360,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 	return binding;
 }
 
-private TypeBinding annotateType(TypeBinding binding, TypeAnnotationWalker walker, char[][][] missingTypeNames) {
+private TypeBinding annotateType(TypeBinding binding, ITypeAnnotationWalker walker, char[][][] missingTypeNames) {
 	int depth = binding.depth() + 1;
 	if (depth > 1) {
 		// need to count non-static nesting levels, resolved binding required for precision
@@ -1406,7 +1406,7 @@ boolean qualifiedNameMatchesSignature(char[][] name, char[] signature) {
 }
 
 public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariableBinding[] staticVariables, ReferenceBinding enclosingType, 
-		char[][][] missingTypeNames, TypeAnnotationWalker walker) 
+		char[][][] missingTypeNames, ITypeAnnotationWalker walker) 
 {
 	// TypeVariableSignature = 'T' Identifier ';'
 	// ArrayTypeSignature = '[' TypeSignature
@@ -1420,7 +1420,7 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 	}
 	// annotations on dimensions?
 	AnnotationBinding [][] annotationsOnDimensions = null;
-	if (dimension > 0 && walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
+	if (dimension > 0 && walker != ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
 		for (int i = 0; i < dimension; i++) {
 			AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(0), this, missingTypeNames);
 			if (annotations != Binding.NO_ANNOTATIONS) { 
@@ -1494,7 +1494,7 @@ public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariab
 	return dimension == 0 ? (TypeBinding) parameterizedType : createArrayType(parameterizedType, dimension, AnnotatableTypeSystem.flattenedAnnotations(annotationsOnDimensions));
 }
 
-private TypeBinding getTypeFromTypeVariable(TypeVariableBinding typeVariableBinding, int dimension, AnnotationBinding [][] annotationsOnDimensions, TypeAnnotationWalker walker, char [][][] missingTypeNames) {
+private TypeBinding getTypeFromTypeVariable(TypeVariableBinding typeVariableBinding, int dimension, AnnotationBinding [][] annotationsOnDimensions, ITypeAnnotationWalker walker, char [][][] missingTypeNames) {
 	AnnotationBinding [] annotations = BinaryTypeBinding.createAnnotations(walker.getAnnotationsAtCursor(-1), this, missingTypeNames);
 	if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
 		typeVariableBinding = (TypeVariableBinding) createAnnotatedType(typeVariableBinding, new AnnotationBinding [][] { annotations });
@@ -1512,7 +1512,7 @@ TypeBinding getTypeFromVariantTypeSignature(
 		ReferenceBinding genericType,
 		int rank,
 		char[][][] missingTypeNames,
-		TypeAnnotationWalker walker) {
+		ITypeAnnotationWalker walker) {
 	// VariantTypeSignature = '-' TypeSignature
 	//   or '+' TypeSignature
 	//   or TypeSignature
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
index 5df44ca..19514c0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440474 - [null] textual encoding of external null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -91,6 +93,42 @@ public class SignatureWrapper {
 
 		return CharOperation.subarray(this.signature, this.start, this.start = this.end); // skip word
 	}
+	/**  similar to nextWord() but don't stop at '.' */
+	public char[] nextName() {
+		this.end = CharOperation.indexOf(';', this.signature, this.start);
+		if (this.bracket <= this.start) // already know it if its > start
+			this.bracket = CharOperation.indexOf('<', this.signature, this.start);
+
+		if (this.bracket > this.start && this.bracket < this.end)
+			this.end = this.bracket;
+
+		return CharOperation.subarray(this.signature, this.start, this.start = this.end); // skip name
+	}
+
+	/**  answer the next type (incl. type arguments), but don't advance any cursors */
+	public char[] peekFullType() {
+		int s = this.start, b = this.bracket, e = this.end;
+		int peekEnd = skipAngleContents(computeEnd());
+		this.start = s;
+		this.bracket = b;
+		this.end = e;
+		return CharOperation.subarray(this.signature, s, peekEnd+1);
+	}
+
+	/**
+	 * assuming a previously stored start of 's' followed by a call to computeEnd()
+	 * now retrieve the content between these bounds including trailing angle content
+	 */
+	public char[] getFrom(int s) {
+		if (this.end == this.bracket) {
+			this.end = skipAngleContents(this.bracket);
+			this.start = this.end + 1;
+		}
+		return CharOperation.subarray(this.signature, s, this.end+1);
+	}
+	public char[] tail() {
+		return CharOperation.subarray(this.signature, this.start, this.signature.length);
+	}
 	public String toString() {
 		return new String(this.signature) + " @ " + this.start; //$NON-NLS-1$
 	}
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
index 952cd68..2967162 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Stephan Herrmann - Contribution for
+ *								Bug 186342 - [compiler][null] Using annotations for null checking
+ *								Bug 440474 - [null] textual encoding of external null annotations
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *         Bug 407191 - [1.8] Binary access support for type annotations
  *******************************************************************************/
@@ -23,6 +25,8 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.core.util.Util;
 
 /**
@@ -190,4 +194,7 @@ public boolean isMember() {
 public char[] sourceFileName() {
 	return null;
 }
+public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWalker walker, Object member, LookupEnvironment environment) {
+	return walker;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathAttribute.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathAttribute.java
index dc2c826..9bab66c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathAttribute.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IClasspathAttribute.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2012 IBM Corporation and others.
+ * Copyright (c) 2005, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.core;
 
@@ -113,6 +115,17 @@ public interface IClasspathAttribute {
 	String OPTIONAL = "optional"; //$NON-NLS-1$
 
 	/**
+	 * Constant for the name of the external annotation path attribute. 
+	 * 
+	 * <p>The value for this attribute has to be the string representation of a path.
+	 * It should point to an existing directory where external annotations can be
+	 * found to support annotation based null analysis involving 3rd party libraries.</p>
+	 * 
+	 * @since 3.11
+	 */
+	String EXTERNAL_ANNOTATION_PATH = "annotationpath"; //$NON-NLS-1$
+
+	/**
 	 * Returns the name of this classpath attribute.
 	 *
 	 * @return the name of this classpath attribute.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
new file mode 100644
index 0000000..2e3eea4
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
@@ -0,0 +1,535 @@
+/*******************************************************************************
+ * Copyright (c) 2015 GK Software AG.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.util;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.UnsupportedEncodingException;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspaceRoot;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.jdt.core.IClasspathEntry;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.dom.IMethodBinding;
+import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationProvider;
+import org.eclipse.jdt.internal.compiler.lookup.SignatureWrapper;
+import org.eclipse.jdt.internal.core.ClasspathEntry;
+
+/**
+ * Utilities for accessing and manipulating text files that externally define annotations for a given Java type.
+ * Files are assumed to be in ".eea format", a textual representation of annotated signatures of members of a given type.
+ * 
+ * @since 3.11
+ * @noinstantiate This class is not intended to be instantiated by clients.
+ */
+public final class ExternalAnnotationUtil {
+
+	/** Representation of a 'nullable' annotation, independent of the concrete annotation name used in Java sources. */
+	public static final char NULLABLE = '0';
+
+	/** Representation of a 'nonnull' annotation, independent of the concrete annotation name used in Java sources. */
+	public static final char NONNULL = '1';
+
+	/**
+	 * Represents absence of a null annotation. Useful for removing an existing null annotation.
+	 * This character is used only internally, it is not part of the Eclipse External Annotation file format.
+	 */
+	public static final char NO_ANNOTATION = '@';
+
+	/** Strategy for merging a new signature with an existing (possibly annotated) signature. */
+	public static enum MergeStrategy {
+		/** Unconditionally replace the signature. */
+		REPLACE_SIGNATURE,
+		/** Override existing annotations, keeping old annotations in locations that are not annotated in the new signature. */
+		OVERWRITE_ANNOTATIONS,
+		/** Only add new annotations, never remove or overwrite existing annotations. */
+		ADD_ANNOTATIONS
+	}
+
+	private static final int POSITION_RETURN_TYPE = -1;
+	private static final int POSITION_FULL_SIGNATURE = -2;
+
+	/**
+	 * Answer the give method's signature in class file format.
+	 * @param methodBinding binding representing a method
+	 * @return a signature in class file format
+	 */
+	public static String extractGenericSignature(IMethodBinding methodBinding) {
+		// Note that IMethodBinding.binding is not accessible, hence we need to reverse engineer from the key:
+		
+		// method key contains the signature between '(' and '|': "class.selector(params)return|throws"
+		int open= methodBinding.getKey().indexOf('(');
+		int throwStart= methodBinding.getKey().indexOf('|');
+		return throwStart == -1 ? methodBinding.getKey().substring(open) : methodBinding.getKey().substring(open, throwStart);
+	}
+
+	/**
+	 * Insert an encoded annotation into the given methodSignature affecting its return type.
+	 * <p>
+	 * This method is suitable for declaration annotations.
+	 * </p>
+	 * @param methodSignature a method signature in class file format
+	 * @param annotation one of {@link #NULLABLE} and {@link #NONNULL}.
+	 * @param mergeStrategy when passing {@link MergeStrategy#ADD_ANNOTATIONS} this method will
+	 * 	refuse to overwrite any existing annotation in the specified location
+	 * @return the modified method signature, or the original signature if modification would
+	 *	conflict with the given merge strategy.
+	 * @throws IllegalArgumentException if the method signature is malformed or its return type is not a reference type.
+	 */
+	public static String insertReturnAnnotation(String methodSignature, char annotation, MergeStrategy mergeStrategy) {
+		int close = methodSignature.indexOf(')');
+		if (close == -1 || close > methodSignature.length()-4)
+			throw new IllegalArgumentException("Malformed method signature"); //$NON-NLS-1$
+		switch (methodSignature.charAt(close+1)) {
+			case 'L': case 'T': case '[':
+				return insertAt(methodSignature, close+2, annotation, mergeStrategy);
+		}
+		throw new IllegalArgumentException("Return type is not a reference type"); //$NON-NLS-1$
+	}
+
+	/**
+	 * Insert an encoded annotation into the given methodSignature affecting one of its parameters.
+	 * <p>
+	 * This method is suitable for declaration annotations.
+	 * </p>
+	 * @param methodSignature a method signature in class file format
+	 * @param paramIdx 0-based index of the parameter to which the annotation should be attached
+	 * @param annotation one of {@link #NULLABLE} and {@link #NONNULL}.
+	 * @param mergeStrategy when passing {@link MergeStrategy#ADD_ANNOTATIONS} this method will
+	 * 	refuse to overwrite any existing annotation in the specified location
+	 * @return the modified method signature, or the original signature if modification would
+	 *	conflict with the given merge strategy.
+	 * @throws IllegalArgumentException if the method signature is malformed or its specified parameter type is not a reference type.
+	 */
+	public static String insertParameterAnnotation(String methodSignature, int paramIdx, char annotation, MergeStrategy mergeStrategy)
+	{
+		SignatureWrapper wrapper = new SignatureWrapper(methodSignature.toCharArray());
+		wrapper.start = 1;
+		for (int i = 0; i < paramIdx; i++)
+			wrapper.start = wrapper.computeEnd() + 1;
+		int start = wrapper.start;
+		switch (methodSignature.charAt(start)) {
+			case 'L': case 'T': case '[':
+				return insertAt(methodSignature, start+1, annotation, mergeStrategy);
+		}
+		throw new IllegalArgumentException("Paramter type is not a reference type"); //$NON-NLS-1$
+	}
+
+	/**
+	 * Answer the external annotation file corresponding to the given type as seen from the given project.
+	 * Note that manipulation of external annotations is only supported for annotation files in the workspace,
+	 * and only in directory layout, not from zip files.
+	 * @param project current project that references the given type from a jar file.
+	 * @param type the type for which external annotations are sought
+	 * @param monitor progress monitor to be passed through into file operations
+	 * @return a file assumed (but not checked) to be in .eea format. The file may not "exist".
+	 * 	Can be null if the given type is not contained in a jar file for which an external annotation path
+	 *  has been defined in the context of the given project.
+	 * @throws CoreException Signals a problem in accessing any of the relevant elements: the project, the type,
+	 * the containing jar file and finally the sought annotation file.
+	 */
+	public static IFile getAnnotationFile(IJavaProject project, ITypeBinding type, IProgressMonitor monitor) throws CoreException {
+	
+		IType targetType = project.findType(type.getErasure().getQualifiedName());
+		if (!targetType.exists())
+			return null;
+
+		String binaryTypeName = targetType.getFullyQualifiedName('.').replace('.', '/');
+		
+		IPackageFragmentRoot packageRoot = (IPackageFragmentRoot) targetType.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
+		IClasspathEntry entry = packageRoot.getResolvedClasspathEntry();
+		IPath annotationPath = ClasspathEntry.getExternalAnnotationPath(entry, project.getProject(), false);
+	
+		if (annotationPath == null) 
+			return null;
+		IWorkspaceRoot workspaceRoot = project.getProject().getWorkspace().getRoot();
+		IFile annotationZip = workspaceRoot.getFile(annotationPath);
+		if (annotationZip.exists())
+			return null;
+	
+		annotationPath = annotationPath.append(binaryTypeName).addFileExtension(ExternalAnnotationProvider.ANNOTION_FILE_EXTENSION);
+		return workspaceRoot.getFile(annotationPath);
+	}
+
+	/**
+	 * Update the given external annotation file with details regarding annotations of one specific method or field.
+	 * If the specified member already has external annotations, old and new annotations will be merged,
+	 * with priorities controlled by the parameter 'mergeStrategy'.
+	 * <p>
+	 * This method is suitable for declaration annotations and type use annotations.
+	 * </p>
+	 * @param typeName binary name (slash separated) of the type being annotated
+	 * @param file a file assumed to be in .eea format, will be created if it doesn't exist.
+	 * @param selector selector of the method or field
+	 * @param originalSignature unannotated signature of the member, used for identification
+	 * @param annotatedSignature new signatures whose annotations should be superimposed on the member
+	 * @param mergeStrategy controls how old and new signatures should be merged
+	 * @param monitor progress monitor to be passed through into file operations, or null if no reporting is desired
+	 * @throws CoreException if access to the file fails
+	 * @throws IOException if reading file content fails
+	 */
+	public static void annotateMember(String typeName, IFile file, String selector, String originalSignature, String annotatedSignature,
+										MergeStrategy mergeStrategy, IProgressMonitor monitor)
+			throws CoreException, IOException
+	{
+		annotateMember(typeName, file, selector, originalSignature, annotatedSignature, POSITION_FULL_SIGNATURE, mergeStrategy, monitor);
+	}
+
+	/**
+	 * Update the given external annotation file with details regarding annotations of the return type of a given method.
+	 * If the specified method already has external annotations, old and new annotations will be merged,
+	 * with priorities controlled by the parameter 'mergeStrategy'.
+	 * <p>
+	 * This method is suitable for declaration annotations and type use annotations.
+	 * </p>
+	 * @param typeName binary name (slash separated) of the type being annotated
+	 * @param file a file assumed to be in .eea format, will be created if it doesn't exist.
+	 * @param selector selector of the method
+	 * @param originalSignature unannotated signature of the member, used for identification
+	 * @param annotatedReturnType signature of the new return type whose annotations should be superimposed on the method
+	 * @param mergeStrategy controls how old and new signatures should be merged
+	 * @param monitor progress monitor to be passed through into file operations, or null if no reporting is desired
+	 * @throws CoreException if access to the file fails
+	 * @throws IOException if reading file content fails
+	 */
+	public static void annotateMethodReturnType(String typeName, IFile file, String selector, String originalSignature,
+										String annotatedReturnType, MergeStrategy mergeStrategy, IProgressMonitor monitor)
+			throws CoreException, IOException
+	{
+		annotateMember(typeName, file, selector, originalSignature, annotatedReturnType, POSITION_RETURN_TYPE, mergeStrategy, monitor);
+	}
+
+	static void annotateMember(String typeName, IFile file, String selector, String originalSignature, String annotatedSignature,
+										int updatePosition, MergeStrategy mergeStrategy, IProgressMonitor monitor)
+			throws CoreException, IOException
+	{
+
+		if (!file.exists()) {
+			StringBuffer newContent= new StringBuffer();
+			// header:
+			newContent.append(ExternalAnnotationProvider.CLASS_PREFIX);
+			newContent.append(typeName).append('\n');
+			// new entry:
+			newContent.append(selector).append('\n');
+			newContent.append(' ').append(originalSignature).append('\n');
+			newContent.append(' ').append(annotatedSignature).append('\n');
+
+			createNewFile(file, newContent.toString(), monitor);
+		} else {
+			BufferedReader reader = new BufferedReader(new InputStreamReader(file.getContents()));
+			StringBuffer newContent = new StringBuffer();
+			try {
+				newContent.append(reader.readLine()).append('\n'); // skip class name
+				String line;
+				while ((line = reader.readLine()) != null) {
+					if (line.isEmpty()) {
+						newContent.append('\n');
+						continue;
+					}
+					if (!Character.isJavaIdentifierStart(line.charAt(0))) {
+						newContent.append(line).append('\n');
+						continue;
+					}
+					// compare selectors:
+					int relation = line.compareTo(selector);
+					if (relation > 0) { // past the insertion point
+						break;
+					}
+					if (relation < 0) {
+						newContent.append(line).append('\n');
+						continue;
+					}
+					if (relation == 0) {
+						StringBuffer pending = new StringBuffer(line).append('\n');
+						pending.append(line = reader.readLine());
+						// compare original signatures:
+						relation = line.trim().compareTo(originalSignature);
+						if (relation > 0) { // past the insertion point
+							// add new entry (below)
+							line = pending.toString(); // push back
+							break;
+						}
+						newContent.append(pending).append('\n');
+						if (relation < 0)
+							continue;
+						if (relation == 0) {
+							// update existing entry:
+							String nextLine = reader.readLine();
+							if (nextLine == null)
+								nextLine = line; // no annotated line yet, use unannotated line instead
+							if (nextLine.startsWith(" ")) { //$NON-NLS-1$
+								switch (mergeStrategy) {
+									case REPLACE_SIGNATURE:
+										break; // unconditionally use annotatedSignature
+									case OVERWRITE_ANNOTATIONS:
+									case ADD_ANNOTATIONS:
+										if (updatePosition == POSITION_FULL_SIGNATURE) {
+											annotatedSignature = addAnnotationsTo(annotatedSignature, nextLine.trim(), mergeStrategy);
+										} else if (updatePosition == POSITION_RETURN_TYPE) {
+											annotatedSignature = updateMethodReturnType(annotatedSignature, nextLine.trim(), mergeStrategy);
+										} else {
+											// parameter i
+										}
+										break;
+									default:
+										JavaCore.getJavaCore().getLog().log(new Status(IStatus.ERROR, JavaCore.PLUGIN_ID,
+																				"Unexpected value for enum MergeStrategy")); //$NON-NLS-1$
+								}
+								nextLine = null; // discard old annotated signature (may have been merged above)
+							}
+							writeFile(file, newContent, annotatedSignature, nextLine, reader, monitor);
+							return;
+						}
+					}
+				}
+				// add new entry:
+				newContent.append(selector).append('\n');
+				newContent.append(' ').append(originalSignature).append('\n');
+				if (updatePosition == POSITION_FULL_SIGNATURE) {
+					// annotatedSignature is already complete
+				} else if (updatePosition == POSITION_RETURN_TYPE) {
+					annotatedSignature = updateMethodReturnType(annotatedSignature, originalSignature, mergeStrategy);
+				} else {
+					// parameter i
+				}
+				writeFile(file, newContent, annotatedSignature, line, reader, monitor);
+			} finally {
+				reader.close();
+			}
+		}
+	}
+
+	/**
+	 * Insert that given annotation at the given position into the given signature. 
+	 * @param mergeStrategy if set to {@link MergeStrategy#ADD_ANNOTATIONS}, refuse to
+	 *   overwrite any existing annotation in the specified location.
+	 */
+	private static String insertAt(String signature, int position, char annotation, MergeStrategy mergeStrategy) {
+		StringBuffer result = new StringBuffer();
+		result.append(signature, 0, position);
+		result.append(annotation);
+		char next = signature.charAt(position);
+		switch (next) {
+			case NULLABLE: case NONNULL:
+				if (mergeStrategy == MergeStrategy.ADD_ANNOTATIONS)
+					return signature; // refuse any change
+				position++; // skip old annotation
+		}
+		result.append(signature, position, signature.length());
+		return result.toString();
+	}
+
+	private static String addAnnotationsTo(String newSignature, String oldSignature, MergeStrategy mergeStategy) {
+		// TODO: consider rewrite using updateType() below
+		StringBuffer buf = new StringBuffer();
+		assert newSignature.charAt(0) == '(' : "signature must start with '('"; //$NON-NLS-1$
+		assert oldSignature.charAt(0) == '(' : "signature must start with '('"; //$NON-NLS-1$
+		buf.append('(');
+		SignatureWrapper wrapperNew = new SignatureWrapper(newSignature.toCharArray(), true); // when using annotations we must be at 1.5+
+		wrapperNew.start = 1;
+		SignatureWrapper wrapperOld = new SignatureWrapper(oldSignature.toCharArray(), true);
+		wrapperOld.start = 1;
+		while (!wrapperNew.atEnd() && !wrapperOld.atEnd()) {
+			int startNew = wrapperNew.start;
+			int startOld = wrapperOld.start;
+			if (wrapperNew.signature[startNew] == ')') {
+				if (wrapperOld.signature[startOld] != ')')
+					throw new IllegalArgumentException("Structural difference between signatures "+newSignature+" and "+oldSignature);  //$NON-NLS-1$//$NON-NLS-2$
+				startNew = ++wrapperNew.start;
+				startOld = ++wrapperOld.start;
+				buf.append(')');
+			}			
+			int endNew = wrapperNew.computeEnd();
+			int endOld = wrapperOld.computeEnd();
+			int lenNew = endNew-startNew+1;
+			int lenOld = endOld-startOld+1;
+			 // TODO detailed comparison / merging:
+			if (lenNew == lenOld) {
+				switch (mergeStategy) {
+					case OVERWRITE_ANNOTATIONS:
+						buf.append(wrapperNew.signature, startNew, lenNew);
+						break;
+					case ADD_ANNOTATIONS:
+						buf.append(wrapperOld.signature, startOld, lenOld);
+						break;
+					//$CASES-OMITTED$ should only be called with the two strategies handled above
+					default:
+						JavaCore.getJavaCore().getLog().log(new Status(IStatus.ERROR, JavaCore.PLUGIN_ID,
+																"Unexpected value for enum MergeStrategy")); //$NON-NLS-1$
+				}
+			} else if (lenNew > lenOld) {
+				buf.append(wrapperNew.signature, startNew, lenNew);
+			} else {				
+				buf.append(wrapperOld.signature, startOld, lenOld);
+			}
+		}
+		return buf.toString();
+	}
+
+	private static String updateMethodReturnType(String newReturnType, String oldSignature, MergeStrategy mergeStrategy) {
+		StringBuffer buf = new StringBuffer();
+		assert oldSignature.charAt(0) == '(' : "signature must start with '('"; //$NON-NLS-1$
+		int close = oldSignature.indexOf(')');
+		buf.append(oldSignature, 0, close+1);
+		updateType(buf, oldSignature.substring(close+1).toCharArray(), newReturnType.toCharArray(), mergeStrategy);
+		return buf.toString();
+	}
+
+	/**
+	 * Update 'oldType' with annotations from 'newType' guided by 'mergeStrategy'.
+	 * The result is written into 'buf' as we go.
+	 */
+	private static boolean updateType(StringBuffer buf, char[] oldType, char[] newType, MergeStrategy mergeStrategy) {
+		SignatureWrapper oWrap = new SignatureWrapper(oldType, true);
+		SignatureWrapper nWrap = new SignatureWrapper(newType, true);
+		if (match(buf, oWrap, nWrap, 'L', false)
+			|| match(buf, oWrap, nWrap, 'T', false))
+		{
+			mergeAnnotation(buf, oWrap, nWrap, mergeStrategy);
+			buf.append(oWrap.nextName());
+			nWrap.nextName(); // skip
+			if (match(buf, oWrap, nWrap, '<', false)) {
+				do {
+					int oStart = oWrap.start;
+					int nStart = nWrap.start;
+					oWrap.computeEnd();
+					nWrap.computeEnd();
+					if (updateType(buf, oWrap.getFrom(oStart), nWrap.getFrom(nStart), mergeStrategy))
+						mergeAnnotation(buf, oWrap, nWrap, mergeStrategy);
+				} while (!match(buf, oWrap, nWrap, '>', false));
+			}
+			match(buf, oWrap, nWrap, ';', true);
+		} else if (match(buf, oWrap, nWrap, '[', false)) {
+			mergeAnnotation(buf, oWrap, nWrap, mergeStrategy);
+			updateType(buf, oWrap.tail(), nWrap.tail(), mergeStrategy);
+		} else if (match(buf, oWrap, nWrap, '*', false)
+				|| match(buf, oWrap, nWrap, '+', false)
+				|| match(buf, oWrap, nWrap, '-', false))
+		{
+			return true; // annotation allowed after this (not included in oldType / newType)
+		} else {			
+			buf.append(oldType);
+		}
+		return false;
+	}
+	/**
+	 * Does the current char at both given signatures match the 'expected' char?
+	 * If yes, print it into 'buf' and answer true.
+	 * If no, if 'force' raise an exception, else quietly answer false without updating 'buf'.
+	 */
+	private static boolean match(StringBuffer buf, SignatureWrapper sig1, SignatureWrapper sig2, char expected, boolean force) {
+		boolean match1 = sig1.signature[sig1.start] == expected;
+		boolean match2 = sig2.signature[sig2.start] == expected;
+		if (match1 != match2) {
+			throw new IllegalArgumentException("Mismatching type structures" //$NON-NLS-1$
+					+ new String(sig1.signature)+" vs "+new String(sig2.signature)); //$NON-NLS-1$ 
+		}
+		if (match1) {
+			buf.append(expected);
+			sig1.start++;
+			sig2.start++;
+			return true;
+		} else if (force) {
+			throw new IllegalArgumentException("Expected char "+expected+" not found in "+new String(sig1.signature)); //$NON-NLS-1$ //$NON-NLS-2$
+		} else {
+			return false;
+		}
+	}
+
+	/**
+	 * If a current char of 'oldS' and/or 'newS' represents a null annotation, insert it into 'buf' guided by 'mergeStrategy'.
+	 * If the new char is NO_ANNOTATION and strategy is OVERWRITE_ANNOTATIONS, silently skip over any null annotations in 'oldS'. 
+	 */
+	private static void mergeAnnotation(StringBuffer buf, SignatureWrapper oldS, SignatureWrapper newS, MergeStrategy mergeStrategy) {
+		 // if atEnd use a char that's different from NULLABLE, NONNULL and NO_ANNOTATION:
+		char oldAnn = !oldS.atEnd() ? oldS.signature[oldS.start] : '\0';
+		char newAnn = !newS.atEnd() ? newS.signature[newS.start] : '\0';
+		switch (mergeStrategy) {
+			case ADD_ANNOTATIONS:
+				switch (oldAnn) {
+					case NULLABLE: case NONNULL:
+						oldS.start++;
+						buf.append(oldAnn); // old exists, so it remains
+						switch (newAnn) { case NULLABLE: case NONNULL: newS.start++; } // just skip
+						return;
+				}
+				//$FALL-THROUGH$
+			case OVERWRITE_ANNOTATIONS:
+				switch (newAnn) {
+					case NULLABLE: case NONNULL:
+						newS.start++;
+						buf.append(newAnn); // new exists and is not suppressed by "ADD & old exists"
+						switch (oldAnn) { case NULLABLE: case NONNULL: oldS.start++; } // just skip
+						break;
+					case NO_ANNOTATION:
+						newS.start++; // don't insert
+						switch (oldAnn) { case NULLABLE: case NONNULL: oldS.start++; } // just skip // skip
+						break;
+				}
+		}
+	}
+
+	/**
+	 * Write back the given annotationFile, with the following content:
+	 * - head (assumed to include a member and its original signature
+	 * - annotatedSignature
+	 * - nextLines (optionally, may be null)
+	 * - the still unconsumed content of tailReader
+	 */
+	private static void writeFile(IFile annotationFile, StringBuffer head, String annotatedSignature,
+									String nextLines, BufferedReader tailReader, IProgressMonitor monitor)
+			throws CoreException, IOException
+	{
+		head.append(' ').append(annotatedSignature).append('\n'); 
+		if (nextLines != null)
+			head.append(nextLines).append('\n');
+		String line;
+		while ((line = tailReader.readLine()) != null)
+			head.append(line).append('\n');
+		ByteArrayInputStream newContent = new ByteArrayInputStream(head.toString().getBytes("UTF-8")); //$NON-NLS-1$
+		annotationFile.setContents(newContent, IResource.KEEP_HISTORY, monitor);
+	}
+
+	private static void createNewFile(IFile file, String newContent, IProgressMonitor monitor) throws CoreException {
+		ensureExists(file.getParent(), monitor);
+		
+		try {
+			file.create(new ByteArrayInputStream(newContent.getBytes("UTF-8")), false, monitor); //$NON-NLS-1$
+		} catch (UnsupportedEncodingException e) {
+			throw new CoreException(new Status(IStatus.ERROR, JavaCore.PLUGIN_ID, e.getMessage(), e));
+		}
+	}
+
+	private static void ensureExists(IContainer container, IProgressMonitor monitor) throws CoreException {
+		if (container.exists()) return;
+		if (!(container instanceof IFolder)) throw new CoreException(new Status(IStatus.ERROR, JavaCore.PLUGIN_ID, "not a folder: "+container)); //$NON-NLS-1$
+		IContainer parent= container.getParent();
+		if (parent instanceof IFolder) {
+			ensureExists(parent, monitor);
+		}
+		((IFolder) container).create(false, true, monitor);
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index 7f9b93e..f2d1208 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -9,6 +9,7 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								Bug 458577 - IClassFile.getWorkingCopy() may lead to NPE in BecomeWorkingCopyOperation
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
@@ -21,7 +22,9 @@ import java.util.zip.ZipFile;
 import org.eclipse.core.resources.IContainer;
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.resources.IProject;
 import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspaceRoot;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
@@ -47,6 +50,8 @@ public class ClassFile extends Openable implements IClassFile, SuffixConstants {
 	protected String name;
 	protected BinaryType binaryType = null;
 
+	private IPath externalAnnotationBase;
+
 /*
  * Creates a handle to a class file.
  */
@@ -343,6 +348,7 @@ public byte[] getBytes() throws JavaModelException {
 private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyInitialize) throws CoreException, IOException, ClassFormatException {
 	JarPackageFragmentRoot root = (JarPackageFragmentRoot) pkg.getParent();
 	ZipFile zip = null;
+	ZipFile annotationZip = null;
 	try {
 		zip = root.getJar();
 		String entryName = Util.concatWith(pkg.names, getElementName(), '/');
@@ -350,13 +356,71 @@ private IBinaryType getJarBinaryTypeInfo(PackageFragment pkg, boolean fullyIniti
 		if (ze != null) {
 			byte contents[] = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
 			String fileName = root.getHandleIdentifier() + IDependent.JAR_FILE_ENTRY_SEPARATOR + entryName;
-			return new ClassFileReader(contents, fileName.toCharArray(), fullyInitialize);
+			ClassFileReader reader = new ClassFileReader(contents, fileName.toCharArray(), fullyInitialize);
+			if (root.getKind() == IPackageFragmentRoot.K_BINARY) {
+				JavaProject javaProject = (JavaProject) getAncestor(IJavaElement.JAVA_PROJECT);
+				IClasspathEntry entry = javaProject.getClasspathEntryFor(getPath());
+				if (entry != null) {
+					IProject project = javaProject.getProject();
+					IPath externalAnnotationPath = ClasspathEntry.getExternalAnnotationPath(entry, project, false);
+					if (externalAnnotationPath != null)
+						setupExternalAnnotationProvider(project, externalAnnotationPath, annotationZip, reader, 
+								entryName.substring(0, entryName.length() - SuffixConstants.SUFFIX_CLASS.length));
+				}
+			} 
+			return reader;
 		}
 	} finally {
 		JavaModelManager.getJavaModelManager().closeZipFile(zip);
+		JavaModelManager.getJavaModelManager().closeZipFile(annotationZip);
 	}
 	return null;
 }
+
+private void setupExternalAnnotationProvider(IProject project, final IPath externalAnnotationPath,
+		ZipFile annotationZip, ClassFileReader reader, final String typeName)
+{
+	// try resolve path within the workspace:
+	IWorkspaceRoot root = project.getWorkspace().getRoot();
+	IResource resource = root.getFolder(externalAnnotationPath);
+	if (!resource.exists())
+		resource = root.getFile(externalAnnotationPath);
+	String resolvedPath = resource.exists()
+							? resource.getLocation().toString() // workspace lookup succeeded -> resolve it
+							: externalAnnotationPath.toString(); // not in workspace, use as is
+	try {
+		annotationZip = reader.setExternalAnnotationProvider(resolvedPath, typeName, annotationZip, new ClassFileReader.ZipFileProducer() {
+			@Override public ZipFile produce() throws IOException {
+				try {
+					return JavaModelManager.getJavaModelManager().getZipFile(externalAnnotationPath); // use (absolute, but) unresolved path here
+				} catch (CoreException e) {
+					throw new IOException("Failed to read annotation file for "+typeName+" from "+externalAnnotationPath.toString(), e); //$NON-NLS-1$ //$NON-NLS-2$
+				}
+			}});
+	} catch (IOException e) {
+		Util.log(e);
+		return;
+	}
+	if (annotationZip == null) {
+		// Additional change listening for individual types only when annotations are in individual files.
+		// Note that we also listen for classes that don't yet have an annotation file, to detect its creation
+		this.externalAnnotationBase = externalAnnotationPath; // remember so we can unregister later
+		ExternalAnnotationTracker.registerClassFile(externalAnnotationPath, new Path(typeName), this);
+	}
+}
+void closeAndRemoveFromJarTypeCache() throws JavaModelException {
+	super.close();
+	// triggered when external annotations have changed we need to recreate this class file
+	JavaModelManager.getJavaModelManager().removeFromJarTypeCache(this.binaryType);
+}
+@Override
+public void close() throws JavaModelException {
+	if (this.externalAnnotationBase != null) {
+		String entryName = Util.concatWith(((PackageFragment) getParent()).names, this.name, '/');
+		ExternalAnnotationTracker.unregisterClassFile(this.externalAnnotationBase, new Path(entryName));
+	}
+	super.close();
+}
 public IBuffer getBuffer() throws JavaModelException {
 	IStatus status = validateClassFile();
 	if (status.isOK()) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
index 247a132..7d1df25 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathChange.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
@@ -27,6 +29,7 @@ import org.eclipse.jdt.core.IClasspathEntry;
 import org.eclipse.jdt.core.IJavaElementDelta;
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.internal.compiler.util.ObjectVector;
 import org.eclipse.jdt.internal.core.DeltaProcessor.RootInfo;
@@ -122,6 +125,17 @@ public class ClasspathChange {
 								continue nextEntry;
 						}
 					}
+					if (JavaCore.ENABLED.equals(this.project.getOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, true))) {
+						// if null annotations are enabled, also check for changes in external annotation attachment
+						String annotationPath = ClasspathEntry.getRawExternalAnnotationPath(entry);
+						String otherAnnotationPath = ClasspathEntry.getRawExternalAnnotationPath(other);
+						if (annotationPath != null && otherAnnotationPath != null) {
+							if (!annotationPath.equals(otherAnnotationPath))
+								continue;
+						} else if (annotationPath != otherAnnotationPath) {
+							continue; // null and not-null
+						}						
+					}
 					return i;
 			}
 		}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
index af3a661..b5acca9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,6 +9,8 @@
  *     IBM Corporation - initial API and implementation
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425
  *     Thirumala Reddy Mutchukota <thirumala@google.com> - Avoid optional library classpath entries validation - https://bugs.eclipse.org/bugs/show_bug.cgi?id=412882
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
@@ -330,12 +332,21 @@ public class ClasspathEntry implements IClasspathEntry {
 	}
 
 	/**
-	 * Used to perform export/restriction propagation across referring projects/containers
+	 * Used to perform export/restriction propagation across referring projects/containers.
+	 * Also: propagating extraAttributes.
 	 */
 	public ClasspathEntry combineWith(ClasspathEntry referringEntry) {
 		if (referringEntry == null) return this;
-		if (referringEntry.isExported() || referringEntry.getAccessRuleSet() != null ) {
+		IClasspathAttribute[] referringExtraAttributes = referringEntry.getExtraAttributes();
+		if (referringEntry.isExported() || referringEntry.getAccessRuleSet() != null || referringExtraAttributes.length > 0) {
 			boolean combine = this.entryKind == CPE_SOURCE || referringEntry.combineAccessRules();
+			IClasspathAttribute[] combinedAttributes = this.extraAttributes;
+			int lenRefer = referringExtraAttributes.length;
+			if (lenRefer > 0) {
+				int lenCombined = combinedAttributes.length;
+				System.arraycopy(combinedAttributes, 0, combinedAttributes=new IClasspathAttribute[lenCombined+lenRefer], 0, lenCombined);
+				System.arraycopy(referringExtraAttributes, 0, combinedAttributes, lenCombined, lenRefer);
+			}
 			return new ClasspathEntry(
 								getContentKind(),
 								getEntryKind(),
@@ -348,7 +359,7 @@ public class ClasspathEntry implements IClasspathEntry {
 								referringEntry.isExported() || this.isExported, // duplicate container entry for tagging it as exported
 								combine(referringEntry.getAccessRules(), getAccessRules(), combine),
 								this.combineAccessRules,
-								this.extraAttributes);
+								combinedAttributes);
 		}
 		// no need to clone
 		return this;
@@ -1245,7 +1256,74 @@ public class ClasspathEntry implements IClasspathEntry {
 		return this.sourceAttachmentRootPath;
 	}
 
+	/**
+	 * Internal API: answer the path for external annotations (for null analysis) associated with
+	 * the given classpath entry.
+	 * Four shapes of paths are supported:
+	 * <ol>
+	 * <li>relative, variable (VAR/relpath): resolve classpath variable VAR and append relpath</li>
+	 * <li>relative, project (relpath): interpret relpath as a relative path within the given project</li>
+	 * <li>absolute, workspace (/Proj/relpath): an absolute path in the workspace</li>
+	 * <li>absolute, filesystem (/abspath): an absolute path in the filesystem</li>
+	 * </ol>
+	 * In case of ambiguity, workspace lookup has higher priority than filesystem lookup
+	 * (in fact filesystem paths are never validated).
+	 * 
+	 * @param entry classpath entry to work on
+	 * @param project project whose classpath we are analysing
+	 * @param resolve if true, any workspace-relative paths will be resolved to filesystem paths.
+	 * @return a path (in the workspace or filesystem-absolute) or null
+	 */
+	public static IPath getExternalAnnotationPath(IClasspathEntry entry, IProject project, boolean resolve) {
+		String rawAnnotationPath = getRawExternalAnnotationPath(entry);
+		if (rawAnnotationPath != null) {
+			IPath annotationPath = new Path(rawAnnotationPath);
+			if (annotationPath.isAbsolute()) {
+				if (!resolve)
+					return annotationPath;
+
+				if (annotationPath.segmentCount() > 1) {
+					// try Workspace-absolute:
+					IProject targetProject = project.getWorkspace().getRoot().getProject(annotationPath.segment(0));
+					if (targetProject.exists())
+						return targetProject.getLocation().append(annotationPath.removeFirstSegments(1));
+				}
+				// absolute, not in workspace, must be Filesystem-absolute:
+				return annotationPath;
+			} else {
+				// try Variable (always resolved):
+				IPath resolved = JavaCore.getResolvedVariablePath(annotationPath);
+				if (resolved != null)
+					return resolved;
+
+				// Project-relative:
+				if (project != null) {
+					if (resolve)
+						return project.getLocation().append(annotationPath);
+					else
+						return new Path(project.getName()).append(annotationPath).makeAbsolute();
+				}
+			}
+		}
+		return null;
+	}
 
+	/**
+	 * Answer the raw external annotation path as specified in .classpath, or null.
+	 * @param entry where to look
+	 * @return the attached external annotation path, or null.
+	 */
+	static String getRawExternalAnnotationPath(IClasspathEntry entry) {
+		IClasspathAttribute[] extraAttributes = entry.getExtraAttributes();
+		for (int i = 0, length = extraAttributes.length; i < length; i++) {
+			IClasspathAttribute attribute = extraAttributes[i];
+			if (IClasspathAttribute.EXTERNAL_ANNOTATION_PATH.equals(attribute.getName())) {
+				return attribute.getValue();
+			}
+		}
+		return null;
+	}
+	
 	public IClasspathEntry getReferencingEntry() {
 		return this.referencingEntry;
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ExternalAnnotationTracker.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ExternalAnnotationTracker.java
new file mode 100644
index 0000000..972bfcf
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ExternalAnnotationTracker.java
@@ -0,0 +1,230 @@
+/*******************************************************************************
+ * Copyright (c) 2015 GK Software AG.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.eclipse.core.resources.IResourceChangeEvent;
+import org.eclipse.core.resources.IResourceChangeListener;
+import org.eclipse.core.resources.IResourceDelta;
+import org.eclipse.core.resources.IWorkspace;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationProvider;
+import org.eclipse.jdt.internal.core.util.Util;
+
+/**
+ * Track changes of external annotation files and trigger closing / reloading of affected ClassFiles.
+ */
+public class ExternalAnnotationTracker implements IResourceChangeListener {
+
+	/**
+	 * Nodes in a tree that represents external annotation attachments.
+	 * Each node is either an intermediate node, or an annotation base.
+	 * <p>
+	 * <b>Intermediate nodes</b> represent the workspace structure holding the
+	 * external annotations. They may have children.<br/>
+	 * <em>Note: we don't flatten these intermediate nodes as to facilitate
+	 * matching against the exact structure of resource deltas.</em>
+	 * </p><p>
+	 * An <b>annotation base</b> is a leaf in the represented directory structure
+	 * and may have a map of known class files.
+	 * </p>
+	 */
+	static class DirectoryNode {
+
+		DirectoryNode parent;		
+		
+		/** Key is a full workspace path. */
+		Map<IPath,DirectoryNode> children;
+		/**
+		 * Key is the path of an external annotation file (.eea), relative to this annotation base.
+		 * The annotation file need not exist, in which case we are waiting for its creation.
+		 */
+		Map<IPath, ClassFile> classFiles;
+		IPackageFragmentRoot modelRoot; // TODO: for handling zipped annotations
+		
+		public DirectoryNode(DirectoryNode parent) {
+			this.parent = parent;
+		}
+
+		Map<IPath, DirectoryNode> getChildren() {
+			if (this.children == null)
+				this.children = new HashMap<IPath, DirectoryNode>();
+			return this.children;
+		}
+
+		void registerClassFile(IPath relativeAnnotationPath, ClassFile classFile) {
+			if (this.classFiles == null)
+				this.classFiles = new HashMap<IPath, ClassFile>();
+			this.classFiles.put(relativeAnnotationPath, classFile);
+			if (this.modelRoot == null)
+				this.modelRoot = classFile.getPackageFragmentRoot();
+		}
+
+		void unregisterClassFile(IPath relativeAnnotationPath) {
+			if (this.classFiles != null) {
+				this.classFiles.remove(relativeAnnotationPath);
+				if (this.classFiles.isEmpty() && this.parent != null)
+					this.parent.unregisterDirectory(this);
+			}
+		}
+		void unregisterDirectory(DirectoryNode child) {
+			if (this.children == null) return;
+			this.children.remove(child);
+			if (this.children.isEmpty() && this.parent != null)
+				this.parent.unregisterDirectory(this);
+		}
+
+		@Override
+		public String toString() {
+			StringBuffer buf = new StringBuffer();
+			if (this.classFiles != null)
+				buf.append("annotation base "); //$NON-NLS-1$
+			buf.append("directory\n"); //$NON-NLS-1$
+			if (this.children != null)
+				buf.append("\twith ").append(this.children.size()).append(" children\n"); //$NON-NLS-1$ //$NON-NLS-2$
+			buf.append("\t#classFiles: ").append(numClassFiles()); //$NON-NLS-1$
+			return buf.toString();
+		}
+		int numClassFiles() {
+			if (this.classFiles != null)
+				return this.classFiles.size();
+			int count = 0;
+			if (this.children != null)
+				for (DirectoryNode child : this.children.values())
+					count += child.numClassFiles();
+			return count;
+		}
+	}
+
+	/** The tree of tracked annotation bases and class files. */
+	DirectoryNode tree = new DirectoryNode(null);
+
+	private static ExternalAnnotationTracker singleton;
+	private ExternalAnnotationTracker() { }
+	
+	/** Start listening. */
+	static void start(IWorkspace workspace) {
+		singleton = new ExternalAnnotationTracker();
+		workspace.addResourceChangeListener(singleton);
+	}
+	
+	/** Stop listening & clean up. */
+	static void shutdown(IWorkspace workspace) {
+		workspace.removeResourceChangeListener(singleton);
+		singleton.tree.children = null;
+	}
+
+	/**
+	 * Register a ClassFile, to which the annotation attachment 'annotationBase' applies.
+	 * This is done for the purpose to listen to changes in the corresponding external annotations
+	 * and to force reloading the class file when necessary.
+	 * @param annotationBase the path of the annotation attachment (workspace absolute)
+	 * @param relativeAnnotationPath path corresponding to the qualified name of the main type of the class file.
+	 *  The path is relative to 'annotationBase'.
+	 *  When appending the file extension for annotation files it points to the annotation file
+	 *  that would correspond to the given class file. The annotation file may or may not yet exist. 
+	 * @param classFile the ClassFile to register.
+	 */
+	public static void registerClassFile(IPath annotationBase, IPath relativeAnnotationPath, ClassFile classFile) {
+		int baseDepth = annotationBase.segmentCount();
+		if (baseDepth == 0) {
+			Util.log(new IllegalArgumentException("annotationBase cannot be empty")); //$NON-NLS-1$
+		} else {
+			relativeAnnotationPath = relativeAnnotationPath.addFileExtension(ExternalAnnotationProvider.ANNOTION_FILE_EXTENSION);
+			DirectoryNode base = singleton.getAnnotationBase(singleton.tree, annotationBase, baseDepth, 1);
+			base.registerClassFile(relativeAnnotationPath, classFile);
+		}
+	}
+
+	/**
+	 * Unregister a class file that is being closed.
+	 * Only to be invoked for class files that potentially are affected by external annotations.
+	 * @param annotationBase path of the corresponding annotation attachment (workspace absolute)
+	 * @param relativeAnnotationPath path of the annotation file that would correspond to the given class file.
+	 */
+	public static void unregisterClassFile(IPath annotationBase, IPath relativeAnnotationPath) {
+		int baseDepth = annotationBase.segmentCount();
+		if (baseDepth == 0) {
+			Util.log(new IllegalArgumentException("annotationBase cannot be empty")); //$NON-NLS-1$
+		} else {
+			relativeAnnotationPath = relativeAnnotationPath.addFileExtension(ExternalAnnotationProvider.ANNOTION_FILE_EXTENSION);
+			DirectoryNode base = singleton.getAnnotationBase(singleton.tree, annotationBase, baseDepth, 1);
+			base.unregisterClassFile(relativeAnnotationPath);
+		}
+	}
+
+	private DirectoryNode getAnnotationBase(DirectoryNode current, IPath annotationBase, int baseDepth, int nextDepth) {
+		IPath nextHead = annotationBase.uptoSegment(nextDepth);
+		Map<IPath, DirectoryNode> children = current.getChildren(); // create if necessary
+		DirectoryNode nextHeadNode = children.get(nextHead);
+		if (nextHeadNode == null)
+			children.put(nextHead, nextHeadNode = new DirectoryNode(current));
+		if (baseDepth == nextDepth)
+			return nextHeadNode;
+		return getAnnotationBase(nextHeadNode, annotationBase, baseDepth, nextDepth+1);
+	}
+
+	/**
+	 * Listen to resource change events concerning external annotations, that potentially affect a cached ClassFile.
+	 */
+	@Override
+	public void resourceChanged(IResourceChangeEvent event) {
+		IResourceDelta delta = event.getDelta();
+		if (delta != null && delta.getFullPath().isRoot() && this.tree.children != null) {
+			for (IResourceDelta child : delta.getAffectedChildren()) {
+				DirectoryNode directoryNode = this.tree.children.get(child.getFullPath());
+				if (directoryNode != null)
+					traverseForDirectories(directoryNode, child);
+			}
+		}
+	}
+
+	// co-traversal of directory nodes & delta nodes:
+	private void traverseForDirectories(DirectoryNode directoryNode, IResourceDelta matchedDelta) {
+		if (directoryNode.classFiles != null) {
+			// annotation base reached, switch strategy:
+			traverseForClassFiles(directoryNode.classFiles, matchedDelta, matchedDelta.getFullPath().segmentCount());
+			// ignore further children, if we already have classFiles (i.e., nested annotation bases are tolerated but ignored).
+		} else if (directoryNode.children != null) {
+			for (IResourceDelta child : matchedDelta.getAffectedChildren()) {
+				DirectoryNode childDir = directoryNode.children.get(child.getFullPath());
+				if (childDir != null) {
+					if (child.getKind() == IResourceDelta.REMOVED)
+						directoryNode.children.remove(child.getFullPath());
+					else
+						traverseForDirectories(childDir, child);
+				}
+			}
+		}			
+	}
+
+	// traversal of delta nodes to be matched against map of class files:
+	private void traverseForClassFiles(Map<IPath, ClassFile> classFiles, IResourceDelta matchedDelta, int baseDepth) {
+		for (IResourceDelta delta : matchedDelta.getAffectedChildren()) {
+			IPath deltaRelativePath = delta.getFullPath().removeFirstSegments(baseDepth);
+			ClassFile classFile = classFiles.get(deltaRelativePath);
+			if (classFile != null) {
+				try {
+					// the payload: unload the class file corresponding to a changed external annotation file:
+					classFile.closeAndRemoveFromJarTypeCache();
+				} catch (JavaModelException e) {
+					Util.log(e, "Failed to close ClassFile "+classFile.name); //$NON-NLS-1$
+				}
+			} else {
+				traverseForClassFiles(classFiles, delta, baseDepth);
+			}
+		}		
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelCache.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelCache.java
index efec9ca..c805d92 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelCache.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelCache.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,6 +8,8 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Terry Parker <tparker@google.com> (Google Inc.)  https://bugs.eclipse.org/365499
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 import java.util.HashMap;
@@ -262,6 +264,9 @@ protected void removeInfo(JavaElement element) {
 protected void resetJarTypeCache() {
 	this.jarTypeCache = new LRUCache((int) (DEFAULT_OPENABLE_SIZE * getMemoryRatio() * getJarTypeRatio()));
 }
+protected void removeFromJarTypeCache(BinaryType type) {
+	this.jarTypeCache.flush(type);
+}
 public String toString() {
 	return toStringFillingRation(""); //$NON-NLS-1$
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index cadc79e..d7306e7 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,7 +10,9 @@
  *     Theodora Yeung (tyeung@bea.com) - ensure that JarPackageFragmentRoot make it into cache
  *                                                           before its contents
  *                                                           (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=102422)
- *     Stephan Herrmann - Contribution for Bug 346010 - [model] strange initialization dependency in OptionTests
+ *     Stephan Herrmann - Contributions for
+ *								Bug 346010 - [model] strange initialization dependency in OptionTests
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *     Terry Parker <tparker@google.com> - DeltaProcessor misses state changes in archive files, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=357425
  *     Thirumala Reddy Mutchukota <thirumala@google.com> - Contribution to bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=411423
  *     Terry Parker <tparker@google.com> - [performance] Low hit rates in JavaModel caches - https://bugs.eclipse.org/421165
@@ -3896,6 +3898,10 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 		return null;
 	}
 
+	void removeFromJarTypeCache(BinaryType type) {
+		this.cache.removeFromJarTypeCache(type);
+	}
+
 	public void removePerProjectInfo(JavaProject javaProject, boolean removeExtJarInfo) {
 		synchronized(this.perProjectInfos) { // use the perProjectInfo collection as its own lock
 			IProject project = javaProject.getProject();
@@ -5005,6 +5011,9 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 					| IResourceChangeEvent.PRE_CLOSE
 					| IResourceChangeEvent.PRE_REFRESH);
 
+			// listen to resource changes affecting external annotations
+			ExternalAnnotationTracker.start(workspace);
+
 			startIndexing();
 
 			// process deltas since last activated in indexer thread so that indexes are up-to-date.
@@ -5061,6 +5070,8 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 		workspace.removeResourceChangeListener(this.deltaState);
 		workspace.removeSaveParticipant(JavaCore.PLUGIN_ID);
 
+		ExternalAnnotationTracker.shutdown(workspace);
+
 		// Stop listening to content-type changes
 		Platform.getContentTypeManager().removeContentTypeChangeListener(this);
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 47e3e8f..1bda5fb 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,6 +8,8 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Tal Lev-Ami - added package cache for zip files
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
@@ -81,12 +83,14 @@ static SimpleSet findPackageSet(ClasspathJar jar) {
 String zipFilename; // keep for equals
 IFile resource;
 ZipFile zipFile;
+ZipFile annotationZipFile;
 long lastModified;
 boolean closeZipFileAtEnd;
 SimpleSet knownPackageNames;
 AccessRuleSet accessRuleSet;
+String externalAnnotationPath;
 
-ClasspathJar(IFile resource, AccessRuleSet accessRuleSet) {
+ClasspathJar(IFile resource, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
 	this.resource = resource;
 	try {
 		java.net.URI location = resource.getLocationURI();
@@ -102,31 +106,46 @@ ClasspathJar(IFile resource, AccessRuleSet accessRuleSet) {
 	this.zipFile = null;
 	this.knownPackageNames = null;
 	this.accessRuleSet = accessRuleSet;
+	if (externalAnnotationPath != null)
+		this.externalAnnotationPath = externalAnnotationPath.toString();
 }
 
-ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet) {
+ClasspathJar(String zipFilename, long lastModified, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
 	this.zipFilename = zipFilename;
 	this.lastModified = lastModified;
 	this.zipFile = null;
 	this.knownPackageNames = null;
 	this.accessRuleSet = accessRuleSet;
+	if (externalAnnotationPath != null)
+		this.externalAnnotationPath = externalAnnotationPath.toString();
 }
 
-public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet) {
+public ClasspathJar(ZipFile zipFile, AccessRuleSet accessRuleSet, IPath externalAnnotationPath) {
 	this.zipFilename = zipFile.getName();
 	this.zipFile = zipFile;
 	this.closeZipFileAtEnd = false;
 	this.knownPackageNames = null;
 	this.accessRuleSet = accessRuleSet;
+	if (externalAnnotationPath != null)
+		this.externalAnnotationPath = externalAnnotationPath.toString();
 }
 
 public void cleanup() {
-	if (this.zipFile != null && this.closeZipFileAtEnd) {
-		try {
-			this.zipFile.close();
-		} catch(IOException e) { // ignore it
+	if (this.closeZipFileAtEnd) {
+		if (this.zipFile != null) {
+			try {
+				this.zipFile.close();
+			} catch(IOException e) { // ignore it
+			}
+			this.zipFile = null;
+		}
+		if (this.annotationZipFile != null) {
+			try {
+				this.annotationZipFile.close();
+			} catch(IOException e) { // ignore it
+			}
+			this.annotationZipFile = null;
 		}
-		this.zipFile = null;
 	}
 	this.knownPackageNames = null;
 }
@@ -148,9 +167,16 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 	try {
 		ClassFileReader reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
 		if (reader != null) {
+			String fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);
+			if (this.externalAnnotationPath != null) {
+				try {
+					this.annotationZipFile = reader.setExternalAnnotationProvider(this.externalAnnotationPath, fileNameWithoutExtension, this.annotationZipFile, null);
+				} catch (IOException e) {
+					// don't let error on annotations fail class reading
+				}
+			}
 			if (this.accessRuleSet == null)
 				return new NameEnvironmentAnswer(reader, null);
-			String fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);
 			return new NameEnvironmentAnswer(reader, this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()));
 		}
 	} catch (IOException e) { // treat as if class file is missing
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
index aef33e1..343abc0 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathLocation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
@@ -26,16 +28,16 @@ public static ClasspathLocation forBinaryFolder(IContainer binaryFolder, boolean
 	return new ClasspathDirectory(binaryFolder, isOutputFolder, accessRuleSet);
 }
 
-static ClasspathLocation forLibrary(String libraryPathname, long lastModified, AccessRuleSet accessRuleSet) {
-	return new ClasspathJar(libraryPathname, lastModified, accessRuleSet);
+static ClasspathLocation forLibrary(String libraryPathname, long lastModified, AccessRuleSet accessRuleSet, IPath annotationsPath) {
+	return new ClasspathJar(libraryPathname, lastModified, accessRuleSet, annotationsPath);
 }
 
-static ClasspathLocation forLibrary(String libraryPathname, AccessRuleSet accessRuleSet) {
-	return forLibrary(libraryPathname, 0, accessRuleSet);
+static ClasspathLocation forLibrary(String libraryPathname, AccessRuleSet accessRuleSet, IPath annotationsPath) {
+	return forLibrary(libraryPathname, 0, accessRuleSet, annotationsPath);
 }
 
-static ClasspathLocation forLibrary(IFile library, AccessRuleSet accessRuleSet) {
-	return new ClasspathJar(library, accessRuleSet);
+static ClasspathLocation forLibrary(IFile library, AccessRuleSet accessRuleSet, IPath annotationsPath) {
+	return new ClasspathJar(library, accessRuleSet, annotationsPath);
 }
 
 public abstract NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String qualifiedBinaryFileName);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index a3dc10a..060bb20 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,6 +12,7 @@
  *           -  Another problem with inner classes referenced from jars or class folders: "The type ... cannot be resolved"
  *     Stephan Herrmann - Contribution for
  *								Bug 392727 - Cannot compile project when a java file contains $ in its file name
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
@@ -103,6 +104,7 @@ private void computeClasspathLocations(
 		ClasspathEntry entry = (ClasspathEntry) classpathEntries[i];
 		IPath path = entry.getPath();
 		Object target = JavaModel.getTarget(path, true);
+		IPath externalAnnotationPath = ClasspathEntry.getExternalAnnotationPath(entry, javaProject.getProject(), true);
 		if (target == null) continue nextEntry;
 
 		switch(entry.getEntryKind()) {
@@ -172,7 +174,7 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-						bLocation = ClasspathLocation.forLibrary((IFile) resource, accessRuleSet);
+						bLocation = ClasspathLocation.forLibrary((IFile) resource, accessRuleSet, externalAnnotationPath);
 					} else if (resource instanceof IContainer) {
 						AccessRuleSet accessRuleSet =
 							(JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE, true))
@@ -200,7 +202,7 @@ private void computeClasspathLocations(
 							&& JavaCore.IGNORE.equals(javaProject.getOption(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE, true)))
 								? null
 								: entry.getAccessRuleSet();
-					bLocations.add(ClasspathLocation.forLibrary(path.toString(), accessRuleSet));
+					bLocations.add(ClasspathLocation.forLibrary(path.toString(), accessRuleSet, externalAnnotationPath));
 				}
 				continue nextEntry;
 		}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
index 30cb7db..72f0d23 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/State.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
@@ -45,7 +47,7 @@ private long previousStructuralBuildTime;
 private StringSet structurallyChangedTypes;
 public static int MaxStructurallyChangedTypes = 100; // keep track of ? structurally changed types, otherwise consider all to be changed
 
-public static final byte VERSION = 0x001B;
+public static final byte VERSION = 0x001C;
 
 static final byte SOURCE_FOLDER = 1;
 static final byte BINARY_FOLDER = 2;
@@ -269,10 +271,10 @@ static State read(IProject project, DataInputStream in) throws IOException {
 				newState.binaryLocations[i] = ClasspathLocation.forBinaryFolder(outputFolder, in.readBoolean(), readRestriction(in));
 				break;
 			case EXTERNAL_JAR :
-				newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(), readRestriction(in));
+				newState.binaryLocations[i] = ClasspathLocation.forLibrary(in.readUTF(), in.readLong(), readRestriction(in), new Path(in.readUTF()));
 				break;
 			case INTERNAL_JAR :
-				newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())), readRestriction(in));
+				newState.binaryLocations[i] = ClasspathLocation.forLibrary(root.getFile(new Path(in.readUTF())), readRestriction(in), new Path(in.readUTF()));
 		}
 	}
 
@@ -463,6 +465,7 @@ void write(DataOutputStream out) throws IOException {
 				out.writeUTF(jar.resource.getFullPath().toString());
 			}
 			writeRestriction(jar.accessRuleSet, out);
+			out.writeUTF(jar.externalAnnotationPath != null ? jar.externalAnnotationPath : ""); //$NON-NLS-1$
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
index a0ea864..881b964 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -9,6 +9,8 @@
  *     IBM Corporation - initial API and implementation
  *     Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *         bug 407191 - [1.8] Binary access support for type annotations
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440474 - [null] textual encoding of external null annotations
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.hierarchy;
 
@@ -22,6 +24,8 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.core.search.indexing.IIndexConstants;
 
 public class HierarchyBinaryType implements IBinaryType {
@@ -265,4 +269,7 @@ public String toString() {
 	}
 	return buffer.toString();
 }
+public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWalker walker, Object member, LookupEnvironment environment) {
+	return walker;
+}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index 3de5d5c..2126a1c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for
+ *								Bug 440477 - [null] Infrastructure for feeding external annotations into compilation
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.search.matching;
 
@@ -98,7 +100,8 @@ private ClasspathLocation mapToClassPathLocation( JavaModelManager manager, Pack
 	IPath path = root.getPath();
 	try {
 		if (root.isArchive()) {
-			cp = new ClasspathJar(manager.getZipFile(path), ((ClasspathEntry) root.getRawClasspathEntry()).getAccessRuleSet());
+			ClasspathEntry rawClasspathEntry = (ClasspathEntry) root.getRawClasspathEntry();
+			cp = new ClasspathJar(manager.getZipFile(path), rawClasspathEntry.getAccessRuleSet(), ClasspathEntry.getExternalAnnotationPath(rawClasspathEntry, ((IJavaProject)root.getParent()).getProject(), true));
 		} else {
 			Object target = JavaModel.getTarget(path, true);
 			if (target != null) 
@@ -203,4 +206,4 @@ public boolean isPackage(String qualifiedPackageName) {
 	return false;
 }
 
-}
\ No newline at end of file
+}
commit db786a60645f0738c3e4c93c03142c921978dbe9
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Feb 26 13:48:11 2015 +0100

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - fix assembly of annotatedSignature

11	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
index 2e3eea4..c64c2c2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
@@ -228,6 +228,17 @@ public final class ExternalAnnotationUtil {
 	{
 
 		if (!file.exists()) {
+			// assemble full annotatedSignature:
+			switch (updatePosition) {
+				case POSITION_FULL_SIGNATURE:
+					break;
+				case POSITION_RETURN_TYPE:
+					annotatedSignature = updateMethodReturnType(annotatedSignature, originalSignature, mergeStrategy);
+					break;
+				default:
+					// parameter at updatePosition
+			}
+
 			StringBuffer newContent= new StringBuffer();
 			// header:
 			newContent.append(ExternalAnnotationProvider.CLASS_PREFIX);
commit 80e31481d0d6262559c156b1e1d04936f3ab697a
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Mar 3 18:49:10 2015 +0100

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - support parameter rewriting for Bug 458200
    - bug fix for keeping existing annotation

51	4	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
index c64c2c2..eab7ad8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
@@ -222,6 +222,31 @@ public final class ExternalAnnotationUtil {
 		annotateMember(typeName, file, selector, originalSignature, annotatedReturnType, POSITION_RETURN_TYPE, mergeStrategy, monitor);
 	}
 
+	/**
+	 * Update the given external annotation file with details regarding annotations of a parameter type of a given method.
+	 * If the specified method already has external annotations, old and new annotations will be merged,
+	 * with priorities controlled by the parameter 'mergeStrategy'.
+	 * <p>
+	 * This method is suitable for declaration annotations and type use annotations.
+	 * </p>
+	 * @param typeName binary name (slash separated) of the type being annotated
+	 * @param file a file assumed to be in .eea format, will be created if it doesn't exist.
+	 * @param selector selector of the method
+	 * @param originalSignature unannotated signature of the member, used for identification
+	 * @param annotatedParameterType signature of the new parameter type whose annotations should be superimposed on the method
+	 * @param paramIdx 0-based index of the parameter to which the annotation should be attached
+	 * @param mergeStrategy controls how old and new signatures should be merged
+	 * @param monitor progress monitor to be passed through into file operations, or null if no reporting is desired
+	 * @throws CoreException if access to the file fails
+	 * @throws IOException if reading file content fails
+	 */
+	public static void annotateMethodParameterType(String typeName, IFile file, String selector, String originalSignature,
+										String annotatedParameterType, int paramIdx, MergeStrategy mergeStrategy, IProgressMonitor monitor)
+			throws CoreException, IOException
+	{
+		annotateMember(typeName, file, selector, originalSignature, annotatedParameterType, paramIdx, mergeStrategy, monitor);
+	}
+
 	static void annotateMember(String typeName, IFile file, String selector, String originalSignature, String annotatedSignature,
 										int updatePosition, MergeStrategy mergeStrategy, IProgressMonitor monitor)
 			throws CoreException, IOException
@@ -236,7 +261,7 @@ public final class ExternalAnnotationUtil {
 					annotatedSignature = updateMethodReturnType(annotatedSignature, originalSignature, mergeStrategy);
 					break;
 				default:
-					// parameter at updatePosition
+					annotatedSignature = updateParameterType(annotatedSignature, updatePosition, originalSignature, mergeStrategy);
 			}
 
 			StringBuffer newContent= new StringBuffer();
@@ -302,7 +327,7 @@ public final class ExternalAnnotationUtil {
 										} else if (updatePosition == POSITION_RETURN_TYPE) {
 											annotatedSignature = updateMethodReturnType(annotatedSignature, nextLine.trim(), mergeStrategy);
 										} else {
-											// parameter i
+											annotatedSignature = updateParameterType(annotatedSignature, updatePosition, nextLine.trim(), mergeStrategy);
 										}
 										break;
 									default:
@@ -324,7 +349,7 @@ public final class ExternalAnnotationUtil {
 				} else if (updatePosition == POSITION_RETURN_TYPE) {
 					annotatedSignature = updateMethodReturnType(annotatedSignature, originalSignature, mergeStrategy);
 				} else {
-					// parameter i
+					annotatedSignature = updateParameterType(annotatedSignature, updatePosition, originalSignature, mergeStrategy);
 				}
 				writeFile(file, newContent, annotatedSignature, line, reader, monitor);
 			} finally {
@@ -409,6 +434,22 @@ public final class ExternalAnnotationUtil {
 		return buf.toString();
 	}
 
+	private static String updateParameterType(String newParameterType, int paramIdx, String oldSignature, MergeStrategy mergeStrategy) {
+		StringBuffer buf = new StringBuffer();
+
+		SignatureWrapper wrapper = new SignatureWrapper(oldSignature.toCharArray());
+		wrapper.start = 1;
+		for (int i = 0; i < paramIdx; i++)
+			wrapper.start = wrapper.computeEnd() + 1;
+		int start = wrapper.start;
+		int end = wrapper.computeEnd();
+		end = wrapper.skipAngleContents(end);
+		buf.append(oldSignature, 0, start);
+		updateType(buf, oldSignature.substring(start, end+1).toCharArray(), newParameterType.toCharArray(), mergeStrategy);
+		buf.append(oldSignature, end+1, oldSignature.length());
+		return buf.toString();
+	}
+
 	/**
 	 * Update 'oldType' with annotations from 'newType' guided by 'mergeStrategy'.
 	 * The result is written into 'buf' as we go.
@@ -497,8 +538,14 @@ public final class ExternalAnnotationUtil {
 						break;
 					case NO_ANNOTATION:
 						newS.start++; // don't insert
-						switch (oldAnn) { case NULLABLE: case NONNULL: oldS.start++; } // just skip // skip
+						switch (oldAnn) { case NULLABLE: case NONNULL: oldS.start++; } // just skip
 						break;
+					default:
+						switch (oldAnn) { 
+							case NULLABLE: case NONNULL: 
+								oldS.start++;
+								buf.append(oldAnn); // keep
+						}
 				}
 		}
 	}
commit a071cbdaf211a260b8aa9c61822ac5501cee9c5c
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Mar 3 22:07:32 2015 +0100

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - fix reading of signatures already containing external annotations
    - avoid dependency from ecj to model (EAUtil)
    - provide more API for reading and applying external annotations

34	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
16	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
103	5	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
index bc64451..5d925d2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -10,9 +10,6 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
-import static org.eclipse.jdt.core.util.ExternalAnnotationUtil.NONNULL;
-import static org.eclipse.jdt.core.util.ExternalAnnotationUtil.NULLABLE;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -35,6 +32,12 @@ public class ExternalAnnotationProvider {
 	public static final String CLASS_PREFIX = "class "; //$NON-NLS-1$
 	public static final String SUPER_PREFIX = "super "; //$NON-NLS-1$
 
+	/** Representation of a 'nullable' annotation, independent of the concrete annotation name used in Java sources. */
+	public static final char NULLABLE = '0';
+
+	/** Representation of a 'nonnull' annotation, independent of the concrete annotation name used in Java sources. */
+	public static final char NONNULL = '1';
+
 	static final String ANNOTATION_FILE_SUFFIX = ".eea"; //$NON-NLS-1$
 
 	private static final String TYPE_PARAMETER_PREFIX = " <"; //$NON-NLS-1$
@@ -60,15 +63,9 @@ public class ExternalAnnotationProvider {
 	private void initialize(InputStream input) throws IOException {
 		LineNumberReader reader = new LineNumberReader(new InputStreamReader(input));
 		try {
-			String line = reader.readLine().trim();
-			if (line.startsWith(CLASS_PREFIX)) {
-				line = line.substring(CLASS_PREFIX.length());
-			} else {
-				throw new IOException("missing class header in annotation file"); //$NON-NLS-1$
-			}
-			if (!trimTail(line).equals(this.typeName)) {
-				throw new IOException("mismatching class name in annotation file, expected "+this.typeName+", but header said "+line); //$NON-NLS-1$ //$NON-NLS-2$
-			}
+			assertClassHeader(reader.readLine(), this.typeName);
+
+			String line;
 			if ((line = reader.readLine()) == null) {
 				return;
 			}
@@ -132,8 +129,32 @@ public class ExternalAnnotationProvider {
 		}
 	}
 
+	/**
+	 * Assert that the given line is a class header for 'typeName' (slash-separated qualified name).
+	 */
+	public static void assertClassHeader(String line, String typeName) throws IOException {
+		if (line.startsWith(CLASS_PREFIX)) {
+			line = line.substring(CLASS_PREFIX.length());
+		} else {
+			throw new IOException("missing class header in annotation file"); //$NON-NLS-1$
+		}
+		if (!trimTail(line).equals(typeName)) {
+			throw new IOException("mismatching class name in annotation file, expected "+typeName+", but header said "+line); //$NON-NLS-1$ //$NON-NLS-2$
+		}
+	}
+
+	/**
+	 * Extract the signature from a line of an external annotation file.
+	 * Answers null if line is not in the expected format.
+	 */
+	public static String extractSignature(String line) {
+		if (line == null || line.isEmpty() || line.charAt(0) != ' ')
+			return null;
+		return trimTail(line.substring(1));
+	}
+
 	/** Lines may contain arbitrary trailing data, separated by white space. */
-	protected String trimTail(String line) {
+	protected static String trimTail(String line) {
 		int tail = line.indexOf(' ');
 		if (tail == -1)
 			tail = line.indexOf('\t');
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
index 19514c0..e60d0c1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
@@ -13,6 +13,7 @@
 package org.eclipse.jdt.internal.compiler.lookup;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationProvider;
 
 public class SignatureWrapper {
 	public char[] signature;
@@ -20,6 +21,7 @@ public class SignatureWrapper {
 	public int end;
 	public int bracket;
 	private boolean use15specifics;
+	private boolean useExternalAnnotations;
 
 	public SignatureWrapper(char[] signature, boolean use15specifics) {
 		this.signature = signature;
@@ -27,6 +29,13 @@ public class SignatureWrapper {
 		this.end = this.bracket = -1;
 		this.use15specifics = use15specifics;
 	}
+	public SignatureWrapper(char[] signature, boolean use15specifics, boolean useExternalAnnotations) {
+		this.signature = signature;
+		this.start = 0;
+		this.end = this.bracket = -1;
+		this.use15specifics = use15specifics;
+		this.useExternalAnnotations = useExternalAnnotations;
+	}
 	public SignatureWrapper(char [] signature) {
 		this(signature, true);
 	}
@@ -37,6 +46,13 @@ public class SignatureWrapper {
 		int index = this.start;
 		while (this.signature[index] == '[')
 			index++;
+		if (this.useExternalAnnotations && index > 0) {
+			switch (this.signature[index]) {
+				case ExternalAnnotationProvider.NONNULL :
+				case ExternalAnnotationProvider.NULLABLE :
+					index++; // skip null annotation token after '['
+			}
+		}
 		switch (this.signature[index]) {
 			case 'L' :
 			case 'T' :
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
index eab7ad8..4e40f15 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
@@ -48,10 +48,10 @@ import org.eclipse.jdt.internal.core.ClasspathEntry;
 public final class ExternalAnnotationUtil {
 
 	/** Representation of a 'nullable' annotation, independent of the concrete annotation name used in Java sources. */
-	public static final char NULLABLE = '0';
+	public static final char NULLABLE = ExternalAnnotationProvider.NULLABLE;
 
 	/** Representation of a 'nonnull' annotation, independent of the concrete annotation name used in Java sources. */
-	public static final char NONNULL = '1';
+	public static final char NONNULL = ExternalAnnotationProvider.NONNULL;
 
 	/**
 	 * Represents absence of a null annotation. Useful for removing an existing null annotation.
@@ -437,7 +437,7 @@ public final class ExternalAnnotationUtil {
 	private static String updateParameterType(String newParameterType, int paramIdx, String oldSignature, MergeStrategy mergeStrategy) {
 		StringBuffer buf = new StringBuffer();
 
-		SignatureWrapper wrapper = new SignatureWrapper(oldSignature.toCharArray());
+		SignatureWrapper wrapper = new SignatureWrapper(oldSignature.toCharArray(), true, true); // may already contain annotations
 		wrapper.start = 1;
 		for (int i = 0; i < paramIdx; i++)
 			wrapper.start = wrapper.computeEnd() + 1;
@@ -455,8 +455,8 @@ public final class ExternalAnnotationUtil {
 	 * The result is written into 'buf' as we go.
 	 */
 	private static boolean updateType(StringBuffer buf, char[] oldType, char[] newType, MergeStrategy mergeStrategy) {
-		SignatureWrapper oWrap = new SignatureWrapper(oldType, true);
-		SignatureWrapper nWrap = new SignatureWrapper(newType, true);
+		SignatureWrapper oWrap = new SignatureWrapper(oldType, true, true); // may already contain annotations
+		SignatureWrapper nWrap = new SignatureWrapper(newType, true, true); // may already contain annotations
 		if (match(buf, oWrap, nWrap, 'L', false)
 			|| match(buf, oWrap, nWrap, 'T', false))
 		{
@@ -590,4 +590,102 @@ public final class ExternalAnnotationUtil {
 		}
 		((IFolder) container).create(false, true, monitor);
 	}
+
+	/**
+	 * Retrieve the annotated signature of a specified member as found in the given external annotation file, if any.
+	 * @param typeName fully qualified slash-separated name of the type for which the file defines external annotations
+	 * @param file a file assumed to be in .eea format, must not be null, but may not exist
+	 * @param selector name of the member whose annotation we are looking for
+	 * @param originalSignature the unannotated signature by which the member is identified
+	 * @return the annotated signature as found in the file, or null.
+	 */
+	public static String getAnnotatedSignature(String typeName, IFile file, String selector, String originalSignature) {
+		if (file.exists()) {
+			try (BufferedReader reader = new BufferedReader(new InputStreamReader(file.getContents()))) {
+				ExternalAnnotationProvider.assertClassHeader(reader.readLine(), typeName);
+				while (true) {
+					String line = reader.readLine();
+					// selector:
+					if (selector.equals(line)) {
+						// original signature:
+						line = reader.readLine();
+						if (originalSignature.equals(ExternalAnnotationProvider.extractSignature(line))) {
+							// annotated signature:
+							return ExternalAnnotationProvider.extractSignature(reader.readLine());
+						}
+					}
+					if (line == null)
+						break;
+				}
+			} catch (IOException | CoreException e) {
+				return null;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Apply the specified changes on the return type of the given signature.
+	 * This method can be used as a dry run without modifying an annotation file.
+	 * 
+	 * @param originalSignature the original full signature, may be annotated already
+	 * @param annotatedType a type signature with additional annotations (incl. {@link #NO_ANNOTATION}).
+	 * @param mergeStrategy controls how old and new signatures should be merged
+	 * @return an array of length four: <ul>
+	 * <li>prefix up-to the changed type</li>
+	 * <li>original type</li>
+	 * <li>changed type</li>
+	 * <li>postfix after the changed type <em>(here: empty string)</li>
+	 * </ul>
+	 */
+	public static String[] annotateReturnType(String originalSignature, String annotatedType, MergeStrategy mergeStrategy)
+	{
+		String[] result = new String[4]; // prefix, orig, replacement, postfix
+		StringBuffer buf;
+		assert originalSignature.charAt(0) == '(' : "signature must start with '('"; //$NON-NLS-1$
+		int close = originalSignature.indexOf(')');
+		result[0] = originalSignature.substring(0, close+1);
+		buf = new StringBuffer();
+		result[1] = originalSignature.substring(close+1);
+		updateType(buf, result[1].toCharArray(), annotatedType.toCharArray(), mergeStrategy);
+		result[2] = buf.toString();
+		result[3] = ""; //$NON-NLS-1$
+		return result;
+	}
+	
+
+	/**
+	 * Apply the specified changes on a parameter within the given signature.
+	 * This method can be used as a dry run without modifying an annotation file.
+	 * 
+	 * @param originalSignature the original full signature, may be annotated already
+	 * @param annotatedType a type signature with additional annotations (incl. {@link #NO_ANNOTATION}).
+	 * @param paramIdx the index of a parameter to annotated
+	 * @param mergeStrategy controls how old and new signatures should be merged
+	 * @return an array of length four: <ul>
+	 * <li>prefix up-to the changed type</li>
+	 * <li>original type</li>
+	 * <li>changed type</li>
+	 * <li>postfix after the changed type</li>
+	 * </ul>
+	 */
+	public static String[] annotateParameterType(String originalSignature, String annotatedType, int paramIdx, MergeStrategy mergeStrategy)
+	{
+		String[] result = new String[4]; // prefix, orig, replacement, postfix
+		StringBuffer buf;
+		SignatureWrapper wrapper = new SignatureWrapper(originalSignature.toCharArray(), true, true); // may already contain annotations
+		wrapper.start = 1;
+		for (int i = 0; i < paramIdx; i++)
+			wrapper.start = wrapper.computeEnd() + 1;
+		int start = wrapper.start;
+		int end = wrapper.computeEnd();
+		end = wrapper.skipAngleContents(end);
+		result[0] = originalSignature.substring(0, start);				
+		buf = new StringBuffer();
+		result[1] = originalSignature.substring(start, end+1);
+		updateType(buf, result[1].toCharArray(), annotatedType.toCharArray(), mergeStrategy);
+		result[2] = buf.toString();
+		result[3] = originalSignature.substring(end+1, originalSignature.length());
+		return result;
+	}
 }
commit 6aa15157c4a89778b30fbac85a8e1c76029da034
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Mar 3 23:15:15 2015 +0100

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - fix handling of two-line entry (lacking an annotated signature) (r/w)
    - fix scanning of types like "[I"
    - systematically throw IAE on structural mismatch & document this
    - handle case of lonely selector at EOF

8	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
19	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
54	41	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
index 5d925d2..86e614a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -78,7 +78,9 @@ public class ExternalAnnotationProvider {
 						return;
 				} 
 			}
+			String pendingLine;
 			do {
+				pendingLine = null;
 				line = line.trim();
 				if (line.isEmpty()) continue;
 				String rawSig = null, annotSig = null;
@@ -99,8 +101,11 @@ public class ExternalAnnotationProvider {
 					line = reader.readLine();
 					if (line == null || line.isEmpty())
 						continue; // skip since optional line with annotations is missing
-					if (line.charAt(0) == ' ')
-						annotSig = line.substring(1);
+					if (line.charAt(0) != ' ') {
+						pendingLine = line; // push back what appears to be the next selector, not a signature
+						continue;
+					}
+					annotSig = line.substring(1);
 				} catch (Exception ex) {
 					// continue to escalate below
 				}
@@ -123,7 +128,7 @@ public class ExternalAnnotationProvider {
 						this.fieldAnnotationSources = new HashMap<String, String>();
 					this.fieldAnnotationSources.put(selector+':'+rawSig, annotSig);
 				}
-			} while ((line = reader.readLine()) != null);
+			} while (((line = pendingLine) != null) || (line = reader.readLine()) != null);
 		} finally {
 			reader.close();
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
index e60d0c1..92e2f50 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
@@ -44,14 +44,25 @@ public class SignatureWrapper {
 	}
 	public int computeEnd() {
 		int index = this.start;
-		while (this.signature[index] == '[')
-			index++;
-		if (this.useExternalAnnotations && index > 0) {
-			switch (this.signature[index]) {
-				case ExternalAnnotationProvider.NONNULL :
-				case ExternalAnnotationProvider.NULLABLE :
-					index++; // skip null annotation token after '['
+		if (this.useExternalAnnotations) {
+			// in addition to '[' tokens accept null annotations after the first '['
+			skipDimensions: while(true) {
+				switch (this.signature[index]) {
+					case ExternalAnnotationProvider.NONNULL :
+					case ExternalAnnotationProvider.NULLABLE :
+						if (index == this.start)
+							break skipDimensions;
+						//$FALL-THROUGH$
+					case '[':
+						index++;
+						break;
+					default:
+						break skipDimensions;
+				}
 			}
+		} else {
+			while (this.signature[index] == '[')
+				index++;
 		}
 		switch (this.signature[index]) {
 			case 'L' :
@@ -66,7 +77,7 @@ public class SignatureWrapper {
 					this.end = this.signature.length + 1;
 				break;
 			default :
-				this.end = this.start;
+				this.end = index;
 		}
 
 		if (this.use15specifics || this.end != this.bracket) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
index 4e40f15..c60fdb5 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
@@ -214,10 +214,11 @@ public final class ExternalAnnotationUtil {
 	 * @param monitor progress monitor to be passed through into file operations, or null if no reporting is desired
 	 * @throws CoreException if access to the file fails
 	 * @throws IOException if reading file content fails
+	 * @throws IllegalArgumentException if the annotatedReturnType does not structurally match to originalSignature
 	 */
 	public static void annotateMethodReturnType(String typeName, IFile file, String selector, String originalSignature,
 										String annotatedReturnType, MergeStrategy mergeStrategy, IProgressMonitor monitor)
-			throws CoreException, IOException
+			throws CoreException, IOException, IllegalArgumentException
 	{
 		annotateMember(typeName, file, selector, originalSignature, annotatedReturnType, POSITION_RETURN_TYPE, mergeStrategy, monitor);
 	}
@@ -239,17 +240,18 @@ public final class ExternalAnnotationUtil {
 	 * @param monitor progress monitor to be passed through into file operations, or null if no reporting is desired
 	 * @throws CoreException if access to the file fails
 	 * @throws IOException if reading file content fails
+	 * @throws IllegalArgumentException if the annotatedParameterType does not structurally match to originalSignature
 	 */
 	public static void annotateMethodParameterType(String typeName, IFile file, String selector, String originalSignature,
 										String annotatedParameterType, int paramIdx, MergeStrategy mergeStrategy, IProgressMonitor monitor)
-			throws CoreException, IOException
+			throws CoreException, IOException, IllegalArgumentException
 	{
 		annotateMember(typeName, file, selector, originalSignature, annotatedParameterType, paramIdx, mergeStrategy, monitor);
 	}
 
 	static void annotateMember(String typeName, IFile file, String selector, String originalSignature, String annotatedSignature,
 										int updatePosition, MergeStrategy mergeStrategy, IProgressMonitor monitor)
-			throws CoreException, IOException
+			throws CoreException, IOException, IllegalArgumentException
 	{
 
 		if (!file.exists()) {
@@ -301,6 +303,9 @@ public final class ExternalAnnotationUtil {
 					if (relation == 0) {
 						StringBuffer pending = new StringBuffer(line).append('\n');
 						pending.append(line = reader.readLine());
+						if (line == null) {
+							break; // found only the selector at EOF, append right here, ignoring 'pending'
+						}
 						// compare original signatures:
 						relation = line.trim().compareTo(originalSignature);
 						if (relation > 0) { // past the insertion point
@@ -313,28 +318,30 @@ public final class ExternalAnnotationUtil {
 							continue;
 						if (relation == 0) {
 							// update existing entry:
-							String nextLine = reader.readLine();
-							if (nextLine == null)
-								nextLine = line; // no annotated line yet, use unannotated line instead
-							if (nextLine.startsWith(" ")) { //$NON-NLS-1$
+							String annotationLine = reader.readLine();
+							String nextLine = null;
+							if (annotationLine == null || annotationLine.isEmpty() || !annotationLine.startsWith(" ")) { //$NON-NLS-1$
+								nextLine = annotationLine; // push back, since not a signature line
+								annotationLine = line; // no annotated line yet, use unannotated line instead
+							}
+							if (annotationLine.startsWith(" ")) { //$NON-NLS-1$
 								switch (mergeStrategy) {
 									case REPLACE_SIGNATURE:
 										break; // unconditionally use annotatedSignature
 									case OVERWRITE_ANNOTATIONS:
 									case ADD_ANNOTATIONS:
 										if (updatePosition == POSITION_FULL_SIGNATURE) {
-											annotatedSignature = addAnnotationsTo(annotatedSignature, nextLine.trim(), mergeStrategy);
+											annotatedSignature = addAnnotationsTo(annotatedSignature, annotationLine.trim(), mergeStrategy);
 										} else if (updatePosition == POSITION_RETURN_TYPE) {
-											annotatedSignature = updateMethodReturnType(annotatedSignature, nextLine.trim(), mergeStrategy);
+											annotatedSignature = updateMethodReturnType(annotatedSignature, annotationLine.trim(), mergeStrategy);
 										} else {
-											annotatedSignature = updateParameterType(annotatedSignature, updatePosition, nextLine.trim(), mergeStrategy);
+											annotatedSignature = updateParameterType(annotatedSignature, updatePosition, annotationLine.trim(), mergeStrategy);
 										}
 										break;
 									default:
 										JavaCore.getJavaCore().getLog().log(new Status(IStatus.ERROR, JavaCore.PLUGIN_ID,
 																				"Unexpected value for enum MergeStrategy")); //$NON-NLS-1$
 								}
-								nextLine = null; // discard old annotated signature (may have been merged above)
 							}
 							writeFile(file, newContent, annotatedSignature, nextLine, reader, monitor);
 							return;
@@ -455,35 +462,40 @@ public final class ExternalAnnotationUtil {
 	 * The result is written into 'buf' as we go.
 	 */
 	private static boolean updateType(StringBuffer buf, char[] oldType, char[] newType, MergeStrategy mergeStrategy) {
-		SignatureWrapper oWrap = new SignatureWrapper(oldType, true, true); // may already contain annotations
-		SignatureWrapper nWrap = new SignatureWrapper(newType, true, true); // may already contain annotations
-		if (match(buf, oWrap, nWrap, 'L', false)
-			|| match(buf, oWrap, nWrap, 'T', false))
-		{
-			mergeAnnotation(buf, oWrap, nWrap, mergeStrategy);
-			buf.append(oWrap.nextName());
-			nWrap.nextName(); // skip
-			if (match(buf, oWrap, nWrap, '<', false)) {
-				do {
-					int oStart = oWrap.start;
-					int nStart = nWrap.start;
-					oWrap.computeEnd();
-					nWrap.computeEnd();
-					if (updateType(buf, oWrap.getFrom(oStart), nWrap.getFrom(nStart), mergeStrategy))
-						mergeAnnotation(buf, oWrap, nWrap, mergeStrategy);
-				} while (!match(buf, oWrap, nWrap, '>', false));
+		try {
+			SignatureWrapper oWrap = new SignatureWrapper(oldType, true, true); // may already contain annotations
+			SignatureWrapper nWrap = new SignatureWrapper(newType, true, true); // may already contain annotations
+			if (match(buf, oWrap, nWrap, 'L', false)
+				|| match(buf, oWrap, nWrap, 'T', false))
+			{
+				mergeAnnotation(buf, oWrap, nWrap, mergeStrategy);
+				buf.append(oWrap.nextName());
+				nWrap.nextName(); // skip
+				if (match(buf, oWrap, nWrap, '<', false)) {
+					do {
+						int oStart = oWrap.start;
+						int nStart = nWrap.start;
+						oWrap.computeEnd();
+						nWrap.computeEnd();
+						if (updateType(buf, oWrap.getFrom(oStart), nWrap.getFrom(nStart), mergeStrategy))
+							mergeAnnotation(buf, oWrap, nWrap, mergeStrategy);
+					} while (!match(buf, oWrap, nWrap, '>', false));
+				}
+				match(buf, oWrap, nWrap, ';', true);
+			} else if (match(buf, oWrap, nWrap, '[', false)) {
+				mergeAnnotation(buf, oWrap, nWrap, mergeStrategy);
+				updateType(buf, oWrap.tail(), nWrap.tail(), mergeStrategy);
+			} else if (match(buf, oWrap, nWrap, '*', false)
+					|| match(buf, oWrap, nWrap, '+', false)
+					|| match(buf, oWrap, nWrap, '-', false))
+			{
+				return true; // annotation allowed after this (not included in oldType / newType)
+			} else {			
+				buf.append(oldType);
 			}
-			match(buf, oWrap, nWrap, ';', true);
-		} else if (match(buf, oWrap, nWrap, '[', false)) {
-			mergeAnnotation(buf, oWrap, nWrap, mergeStrategy);
-			updateType(buf, oWrap.tail(), nWrap.tail(), mergeStrategy);
-		} else if (match(buf, oWrap, nWrap, '*', false)
-				|| match(buf, oWrap, nWrap, '+', false)
-				|| match(buf, oWrap, nWrap, '-', false))
-		{
-			return true; // annotation allowed after this (not included in oldType / newType)
-		} else {			
-			buf.append(oldType);
+		} catch (ArrayIndexOutOfBoundsException aioobe) { // from several locations inside match() or mergeAnnotation().
+			StringBuilder msg = new StringBuilder("Structural mismatch between ").append(oldType).append(" and ").append(newType); //$NON-NLS-1$ //$NON-NLS-2$
+			throw new IllegalArgumentException(msg.toString(), aioobe);
 		}
 		return false;
 	}
@@ -496,8 +508,9 @@ public final class ExternalAnnotationUtil {
 		boolean match1 = sig1.signature[sig1.start] == expected;
 		boolean match2 = sig2.signature[sig2.start] == expected;
 		if (match1 != match2) {
-			throw new IllegalArgumentException("Mismatching type structures" //$NON-NLS-1$
-					+ new String(sig1.signature)+" vs "+new String(sig2.signature)); //$NON-NLS-1$ 
+			StringBuilder msg = new StringBuilder("Mismatching type structures ") //$NON-NLS-1$
+									.append(sig1.signature).append(" vs ").append(sig2.signature); //$NON-NLS-1$
+			throw new IllegalArgumentException(msg.toString()); 
 		}
 		if (match1) {
 			buf.append(expected);
commit 9b49fc6edec0d13e82a14df97219e6ae294f74cc
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Mar 10 12:22:52 2015 +0100

    Bug 440477 - [null] Infrastructure for feeding external annotations into
    compilation
    - support manipulation of field types
    - fix annotation removal in one particular case

6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
84	98	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
index 86e614a..6b61bcf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -38,6 +38,12 @@ public class ExternalAnnotationProvider {
 	/** Representation of a 'nonnull' annotation, independent of the concrete annotation name used in Java sources. */
 	public static final char NONNULL = '1';
 
+	/**
+	 * Represents absence of a null annotation. Useful for removing an existing null annotation.
+	 * This character is used only internally, it is not part of the Eclipse External Annotation file format.
+	 */
+	public static final char NO_ANNOTATION = '@';
+
 	static final String ANNOTATION_FILE_SUFFIX = ".eea"; //$NON-NLS-1$
 
 	private static final String TYPE_PARAMETER_PREFIX = " <"; //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
index 92e2f50..7e61a2d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SignatureWrapper.java
@@ -50,6 +50,7 @@ public class SignatureWrapper {
 				switch (this.signature[index]) {
 					case ExternalAnnotationProvider.NONNULL :
 					case ExternalAnnotationProvider.NULLABLE :
+					case ExternalAnnotationProvider.NO_ANNOTATION :
 						if (index == this.start)
 							break skipDimensions;
 						//$FALL-THROUGH$
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
index c60fdb5..cd3a50b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/ExternalAnnotationUtil.java
@@ -57,7 +57,7 @@ public final class ExternalAnnotationUtil {
 	 * Represents absence of a null annotation. Useful for removing an existing null annotation.
 	 * This character is used only internally, it is not part of the Eclipse External Annotation file format.
 	 */
-	public static final char NO_ANNOTATION = '@';
+	public static final char NO_ANNOTATION = ExternalAnnotationProvider.NO_ANNOTATION;
 
 	/** Strategy for merging a new signature with an existing (possibly annotated) signature. */
 	public static enum MergeStrategy {
@@ -87,6 +87,21 @@ public final class ExternalAnnotationUtil {
 	}
 
 	/**
+	 * Answer the given types's signature in class file format.
+	 * @param type binding representing a type
+	 * @return a signature in class file format
+	 */
+	public static String extractGenericTypeSignature(ITypeBinding type) {
+		String key = type.getKey();
+		if (type.isTypeVariable()) {
+			int colon= key.indexOf(':');
+			if (colon > -1)
+				return key.substring(colon+1); // cut of unwanted declaring type prefix
+		}
+		return key;
+	}
+
+	/**
 	 * Insert an encoded annotation into the given methodSignature affecting its return type.
 	 * <p>
 	 * This method is suitable for declaration annotations.
@@ -249,22 +264,14 @@ public final class ExternalAnnotationUtil {
 		annotateMember(typeName, file, selector, originalSignature, annotatedParameterType, paramIdx, mergeStrategy, monitor);
 	}
 
-	static void annotateMember(String typeName, IFile file, String selector, String originalSignature, String annotatedSignature,
+	private static void annotateMember(String typeName, IFile file, String selector, String originalSignature, String annotatedSignature,
 										int updatePosition, MergeStrategy mergeStrategy, IProgressMonitor monitor)
 			throws CoreException, IOException, IllegalArgumentException
 	{
 
 		if (!file.exists()) {
-			// assemble full annotatedSignature:
-			switch (updatePosition) {
-				case POSITION_FULL_SIGNATURE:
-					break;
-				case POSITION_RETURN_TYPE:
-					annotatedSignature = updateMethodReturnType(annotatedSignature, originalSignature, mergeStrategy);
-					break;
-				default:
-					annotatedSignature = updateParameterType(annotatedSignature, updatePosition, originalSignature, mergeStrategy);
-			}
+			// assemble full annotatedSignature (don't bother merging since no previous signature exists):
+			annotatedSignature = updateSignature(originalSignature, annotatedSignature, updatePosition, MergeStrategy.REPLACE_SIGNATURE);
 
 			StringBuffer newContent= new StringBuffer();
 			// header:
@@ -330,13 +337,7 @@ public final class ExternalAnnotationUtil {
 										break; // unconditionally use annotatedSignature
 									case OVERWRITE_ANNOTATIONS:
 									case ADD_ANNOTATIONS:
-										if (updatePosition == POSITION_FULL_SIGNATURE) {
-											annotatedSignature = addAnnotationsTo(annotatedSignature, annotationLine.trim(), mergeStrategy);
-										} else if (updatePosition == POSITION_RETURN_TYPE) {
-											annotatedSignature = updateMethodReturnType(annotatedSignature, annotationLine.trim(), mergeStrategy);
-										} else {
-											annotatedSignature = updateParameterType(annotatedSignature, updatePosition, annotationLine.trim(), mergeStrategy);
-										}
+										annotatedSignature = updateSignature(annotationLine.trim(), annotatedSignature, updatePosition, mergeStrategy);
 										break;
 									default:
 										JavaCore.getJavaCore().getLog().log(new Status(IStatus.ERROR, JavaCore.PLUGIN_ID,
@@ -351,13 +352,7 @@ public final class ExternalAnnotationUtil {
 				// add new entry:
 				newContent.append(selector).append('\n');
 				newContent.append(' ').append(originalSignature).append('\n');
-				if (updatePosition == POSITION_FULL_SIGNATURE) {
-					// annotatedSignature is already complete
-				} else if (updatePosition == POSITION_RETURN_TYPE) {
-					annotatedSignature = updateMethodReturnType(annotatedSignature, originalSignature, mergeStrategy);
-				} else {
-					annotatedSignature = updateParameterType(annotatedSignature, updatePosition, originalSignature, mergeStrategy);
-				}
+				annotatedSignature = updateSignature(originalSignature, annotatedSignature, updatePosition, mergeStrategy);
 				writeFile(file, newContent, annotatedSignature, line, reader, monitor);
 			} finally {
 				reader.close();
@@ -365,6 +360,38 @@ public final class ExternalAnnotationUtil {
 		}
 	}
 
+	private static String updateSignature(String originalSignature, String annotatedSignature, int updatePosition, MergeStrategy mergeStrategy) {
+		StringBuffer buf = new StringBuffer();
+		String signatureToReplace;
+		String postfix = null;
+		switch (updatePosition) {
+			case POSITION_FULL_SIGNATURE:
+				signatureToReplace = originalSignature;
+				break;
+			case POSITION_RETURN_TYPE:
+				assert originalSignature.charAt(0) == '(' : "signature must start with '('"; //$NON-NLS-1$
+				int close = originalSignature.indexOf(')');
+				buf.append(originalSignature, 0, close+1);
+				signatureToReplace = originalSignature.substring(close+1);
+				break;
+			default: // parameter
+				SignatureWrapper wrapper = new SignatureWrapper(originalSignature.toCharArray(), true, true); // may already contain annotations
+				wrapper.start = 1;
+				for (int i = 0; i < updatePosition; i++)
+					wrapper.start = wrapper.computeEnd() + 1;
+				int start = wrapper.start;
+				int end = wrapper.computeEnd();
+				end = wrapper.skipAngleContents(end);
+				buf.append(originalSignature, 0, start);
+				signatureToReplace = originalSignature.substring(start, end+1);
+				postfix = originalSignature.substring(end+1, originalSignature.length());
+		}
+		updateType(buf, signatureToReplace.toCharArray(), annotatedSignature.toCharArray(), mergeStrategy);
+		if (postfix != null)
+			buf.append(postfix);
+		return buf.toString();
+	}
+
 	/**
 	 * Insert that given annotation at the given position into the given signature. 
 	 * @param mergeStrategy if set to {@link MergeStrategy#ADD_ANNOTATIONS}, refuse to
@@ -385,83 +412,15 @@ public final class ExternalAnnotationUtil {
 		return result.toString();
 	}
 
-	private static String addAnnotationsTo(String newSignature, String oldSignature, MergeStrategy mergeStategy) {
-		// TODO: consider rewrite using updateType() below
-		StringBuffer buf = new StringBuffer();
-		assert newSignature.charAt(0) == '(' : "signature must start with '('"; //$NON-NLS-1$
-		assert oldSignature.charAt(0) == '(' : "signature must start with '('"; //$NON-NLS-1$
-		buf.append('(');
-		SignatureWrapper wrapperNew = new SignatureWrapper(newSignature.toCharArray(), true); // when using annotations we must be at 1.5+
-		wrapperNew.start = 1;
-		SignatureWrapper wrapperOld = new SignatureWrapper(oldSignature.toCharArray(), true);
-		wrapperOld.start = 1;
-		while (!wrapperNew.atEnd() && !wrapperOld.atEnd()) {
-			int startNew = wrapperNew.start;
-			int startOld = wrapperOld.start;
-			if (wrapperNew.signature[startNew] == ')') {
-				if (wrapperOld.signature[startOld] != ')')
-					throw new IllegalArgumentException("Structural difference between signatures "+newSignature+" and "+oldSignature);  //$NON-NLS-1$//$NON-NLS-2$
-				startNew = ++wrapperNew.start;
-				startOld = ++wrapperOld.start;
-				buf.append(')');
-			}			
-			int endNew = wrapperNew.computeEnd();
-			int endOld = wrapperOld.computeEnd();
-			int lenNew = endNew-startNew+1;
-			int lenOld = endOld-startOld+1;
-			 // TODO detailed comparison / merging:
-			if (lenNew == lenOld) {
-				switch (mergeStategy) {
-					case OVERWRITE_ANNOTATIONS:
-						buf.append(wrapperNew.signature, startNew, lenNew);
-						break;
-					case ADD_ANNOTATIONS:
-						buf.append(wrapperOld.signature, startOld, lenOld);
-						break;
-					//$CASES-OMITTED$ should only be called with the two strategies handled above
-					default:
-						JavaCore.getJavaCore().getLog().log(new Status(IStatus.ERROR, JavaCore.PLUGIN_ID,
-																"Unexpected value for enum MergeStrategy")); //$NON-NLS-1$
-				}
-			} else if (lenNew > lenOld) {
-				buf.append(wrapperNew.signature, startNew, lenNew);
-			} else {				
-				buf.append(wrapperOld.signature, startOld, lenOld);
-			}
-		}
-		return buf.toString();
-	}
-
-	private static String updateMethodReturnType(String newReturnType, String oldSignature, MergeStrategy mergeStrategy) {
-		StringBuffer buf = new StringBuffer();
-		assert oldSignature.charAt(0) == '(' : "signature must start with '('"; //$NON-NLS-1$
-		int close = oldSignature.indexOf(')');
-		buf.append(oldSignature, 0, close+1);
-		updateType(buf, oldSignature.substring(close+1).toCharArray(), newReturnType.toCharArray(), mergeStrategy);
-		return buf.toString();
-	}
-
-	private static String updateParameterType(String newParameterType, int paramIdx, String oldSignature, MergeStrategy mergeStrategy) {
-		StringBuffer buf = new StringBuffer();
-
-		SignatureWrapper wrapper = new SignatureWrapper(oldSignature.toCharArray(), true, true); // may already contain annotations
-		wrapper.start = 1;
-		for (int i = 0; i < paramIdx; i++)
-			wrapper.start = wrapper.computeEnd() + 1;
-		int start = wrapper.start;
-		int end = wrapper.computeEnd();
-		end = wrapper.skipAngleContents(end);
-		buf.append(oldSignature, 0, start);
-		updateType(buf, oldSignature.substring(start, end+1).toCharArray(), newParameterType.toCharArray(), mergeStrategy);
-		buf.append(oldSignature, end+1, oldSignature.length());
-		return buf.toString();
-	}
-
 	/**
 	 * Update 'oldType' with annotations from 'newType' guided by 'mergeStrategy'.
 	 * The result is written into 'buf' as we go.
 	 */
 	private static boolean updateType(StringBuffer buf, char[] oldType, char[] newType, MergeStrategy mergeStrategy) {
+		if (mergeStrategy == MergeStrategy.REPLACE_SIGNATURE) {
+			buf.append(newType);
+			return false;
+		}			
 		try {
 			SignatureWrapper oWrap = new SignatureWrapper(oldType, true, true); // may already contain annotations
 			SignatureWrapper nWrap = new SignatureWrapper(newType, true, true); // may already contain annotations
@@ -638,6 +597,33 @@ public final class ExternalAnnotationUtil {
 	}
 
 	/**
+	 * Apply the specified changes on the given type.
+	 * This method can be used as a dry run without modifying an annotation file.
+	 * 
+	 * @param originalSignature the original type signature, may be annotated already
+	 * @param annotatedType a type signature with additional annotations (incl. {@link #NO_ANNOTATION}).
+	 * @param mergeStrategy controls how old and new signatures should be merged
+	 * @return an array of length four: <ul>
+	 * <li>prefix up-to the changed type</li>
+	 * <li>original type</li>
+	 * <li>changed type</li>
+	 * <li>postfix after the changed type <em>(here: empty string)</li>
+	 * </ul>
+	 */
+	public static String[] annotateType(String originalSignature, String annotatedType, MergeStrategy mergeStrategy)
+	{
+		String[] result = new String[4]; // prefix, orig, replacement, postfix
+		StringBuffer buf;
+		result[0] = ""; //$NON-NLS-1$
+		buf = new StringBuffer();
+		result[1] = originalSignature;
+		updateType(buf, originalSignature.toCharArray(), annotatedType.toCharArray(), mergeStrategy);
+		result[2] = buf.toString();
+		result[3] = ""; //$NON-NLS-1$
+		return result;
+	}
+
+	/**
 	 * Apply the specified changes on the return type of the given signature.
 	 * This method can be used as a dry run without modifying an annotation file.
 	 * 
