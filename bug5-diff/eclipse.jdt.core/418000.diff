commit 340440fc2f9b9eb03b89c385f562976def2c6c0e
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Thu Oct 10 20:25:09 2013 +0530

    Fixed Bug 418000 - [1.8][compiler] Support language model API for
    repeated annotations

-	-	org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
8	0	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Foo.java
5	0	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/FooContainer.java
5	0	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/FooNonContainer.java
5	0	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Goo.java
5	0	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/GooNonContainer.java
8	0	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/TFoo.java
8	0	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/TFooContainer.java
225	51	org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
7	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120.java
8	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_1.java
8	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_2.java
8	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_3.java
8	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_4.java
8	0	org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_5.java
90	39	org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
11	12	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
40	7	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
94	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
38	6	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotationBinding.java
0	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
diff --git a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar
index 51952d6..c64d65c 100644
Binary files a/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar and b/org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors.jar differ
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Foo.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Foo.java
new file mode 100644
index 0000000..78d4821
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Foo.java
@@ -0,0 +1,8 @@
+package org.eclipse.jdt.compiler.apt.tests.annotations;
+import java.lang.annotation.Repeatable;
+
+@Repeatable(FooContainer.class)
+public @interface Foo {
+	// ...
+}
+
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/FooContainer.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/FooContainer.java
new file mode 100644
index 0000000..3b62d3a
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/FooContainer.java
@@ -0,0 +1,5 @@
+package org.eclipse.jdt.compiler.apt.tests.annotations;
+
+public @interface FooContainer {
+	Foo [] value();
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/FooNonContainer.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/FooNonContainer.java
new file mode 100644
index 0000000..5d49196
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/FooNonContainer.java
@@ -0,0 +1,5 @@
+package org.eclipse.jdt.compiler.apt.tests.annotations;
+
+public @interface FooNonContainer {
+	Foo [] value();
+}
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Goo.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Goo.java
new file mode 100644
index 0000000..d96937b
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/Goo.java
@@ -0,0 +1,5 @@
+package org.eclipse.jdt.compiler.apt.tests.annotations;
+
+public @interface Goo {
+
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/GooNonContainer.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/GooNonContainer.java
new file mode 100644
index 0000000..0ef1e95
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/GooNonContainer.java
@@ -0,0 +1,5 @@
+package org.eclipse.jdt.compiler.apt.tests.annotations;
+
+public @interface GooNonContainer {
+	Goo [] value();
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/TFoo.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/TFoo.java
new file mode 100644
index 0000000..2e1eb10
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/TFoo.java
@@ -0,0 +1,8 @@
+package org.eclipse.jdt.compiler.apt.tests.annotations;
+import java.lang.annotation.*;
+
+@Repeatable(TFooContainer.class)
+@Target(ElementType.TYPE_USE)
+public @interface TFoo {
+
+}
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/TFooContainer.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/TFooContainer.java
new file mode 100644
index 0000000..00d8b59
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/annotations/TFooContainer.java
@@ -0,0 +1,8 @@
+package org.eclipse.jdt.compiler.apt.tests.annotations;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+@Target(ElementType.TYPE_USE)
+public @interface TFooContainer {
+	TFoo [] value();
+}
diff --git a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
index 8fad083..2d5ac61 100644
--- a/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
+++ b/org.eclipse.jdt.compiler.apt.tests/processors/org/eclipse/jdt/compiler/apt/tests/processors/elements/Java8ElementProcessor.java
@@ -42,6 +42,13 @@ import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 
+import org.eclipse.jdt.compiler.apt.tests.annotations.Foo;
+import org.eclipse.jdt.compiler.apt.tests.annotations.FooContainer;
+import org.eclipse.jdt.compiler.apt.tests.annotations.FooNonContainer;
+import org.eclipse.jdt.compiler.apt.tests.annotations.Goo;
+import org.eclipse.jdt.compiler.apt.tests.annotations.GooNonContainer;
+import org.eclipse.jdt.compiler.apt.tests.annotations.TFoo;
+import org.eclipse.jdt.compiler.apt.tests.annotations.TFooContainer;
 import org.eclipse.jdt.compiler.apt.tests.annotations.Type;
 import org.eclipse.jdt.compiler.apt.tests.annotations.Type$1;
 import org.eclipse.jdt.compiler.apt.tests.processors.base.BaseProcessor;
@@ -52,7 +59,11 @@ import org.eclipse.jdt.compiler.apt.tests.processors.base.BaseProcessor;
  * -Aorg.eclipse.jdt.compiler.apt.tests.processors.elements.Java8ElementProcessor to the command line.
  * @since 3.9 BETA_JAVA8
  */
-@SupportedAnnotationTypes({"org.eclipse.jdt.compiler.apt.tests.annotations.Type", "org.eclipse.jdt.compiler.apt.tests.annotations.Type$1"})
+@SupportedAnnotationTypes({"org.eclipse.jdt.compiler.apt.tests.annotations.Type", "org.eclipse.jdt.compiler.apt.tests.annotations.Type$1", 
+	                       "org.eclipse.jdt.compiler.apt.tests.annotations.Foo", "org.eclipse.jdt.compiler.apt.tests.annotations.FooContainer",
+	                       "org.eclipse.jdt.compiler.apt.tests.annotations.Goo", "org.eclipse.jdt.compiler.apt.tests.annotations.GooNonContainer",
+	                       "org.eclipse.jdt.compiler.apt.tests.annotations.FooNonContainer"})
+
 @SupportedSourceVersion(SourceVersion.RELEASE_8)
 public class Java8ElementProcessor extends BaseProcessor {
 	
@@ -132,6 +143,12 @@ public class Java8ElementProcessor extends BaseProcessor {
 		testTypeAnnotations14();
 		testTypeAnnotations15();
 		testTypeAnnotations16();
+		testRepeatedAnnotations17();
+		testRepeatedAnnotations18();
+		testRepeatedAnnotations19();
+		testRepeatedAnnotations20();
+		testRepeatedAnnotations21();
+		testRepeatedAnnotations22();
 	}
 	
 	public void testLambdaSpecifics() {
@@ -225,7 +242,7 @@ public class Java8ElementProcessor extends BaseProcessor {
 		TypeMirror similar = typeMirror;
 		typeMirror = field1.asType();
 		assertFalse("Should be of same type", _typeUtils.isSameType(typeMirror, similar));
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f1)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=f1)"});
 		similar = field11.asType();
 		assertTrue("Should be of same type", _typeUtils.isSameType(typeMirror, similar));
 		
@@ -241,15 +258,15 @@ public class Java8ElementProcessor extends BaseProcessor {
 		TypeElement annotatedType = _elementUtils.getTypeElement("targets.model8.X");
 		TypeMirror superType = annotatedType.getSuperclass();
 		assertNotNull("Java8ElementProcessor#examineSE8Specifics: super type not be null", superType);
-		verifyTypeAnnotations(superType, new String[]{"@Type(value=s)"});
+		verifyAnnotations(superType, new String[]{"@Type(value=s)"});
 
 		List<? extends TypeMirror> interfaces  = annotatedType.getInterfaces();
 		assertNotNull("Java8ElementProcessor#examineSE8Specifics: super interfaces list should not be null", interfaces);
 		assertEquals("Java8ElementProcessor#examineSE8Specifics: incorrect no of super interfaces", 2, interfaces.size());
 		superType = interfaces.get(0);
-		verifyTypeAnnotations(superType, new String[]{"@Type(value=i1)"});
+		verifyAnnotations(superType, new String[]{"@Type(value=i1)"});
 		superType = interfaces.get(1);
-		verifyTypeAnnotations(superType, new String[]{"@Type(value=i2)"});
+		verifyAnnotations(superType, new String[]{"@Type(value=i2)"});
 	}
 	
 	public void testTypeAnnotations1() {
@@ -265,10 +282,10 @@ public class Java8ElementProcessor extends BaseProcessor {
 		assertEquals("Incorrect no of params for method bar()", 2, params.size());
 		VariableElement param = (VariableElement) params.get(0);
 		TypeMirror typeMirror = param.asType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p1)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=p1)"});
 		param = (VariableElement) params.get(1);
 		typeMirror = param.asType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p2)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=p2)"});
 	}
 	
 	public void testTypeAnnotations2() {
@@ -288,27 +305,27 @@ public class Java8ElementProcessor extends BaseProcessor {
 		assertNotNull("Java8ElementProcessor#examineSE8Specifics: Element for field _field2 should not be null", field2);
 		TypeMirror typeMirror = field2.asType();
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f3)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=f3)"});
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f1)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=f1)"});
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f2)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=f2)"});
 
 		assertNotNull("Java8ElementProcessor#examineSE8Specifics: Element for field _field3 should not be null", field3);
 		typeMirror = field3.asType();
 		// The second field binding doesn't seem to have the annotations. To be investigated
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f4)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=f4)"});
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
-		verifyTypeAnnotations(typeMirror, new String[]{});
+		verifyAnnotations(typeMirror, new String[]{});
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f1)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=f1)"});
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=f2)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=f2)"});
 	}
 	
 	public void testTypeAnnotations3() {
@@ -323,16 +340,16 @@ public class Java8ElementProcessor extends BaseProcessor {
 		// @Type("m") String @Type("m1") [] foo() @Type("m2") [] @Type("m3") [] {}
 		assertNotNull("Method should not be null", method);
 		TypeMirror typeMirror = method.getReturnType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=m2)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=m2)"});
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=m3)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=m3)"});
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=m1)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=m1)"});
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=m)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=m)"});
 	}
 
 	public void testTypeAnnotations4() {
@@ -350,28 +367,28 @@ public class Java8ElementProcessor extends BaseProcessor {
 		assertEquals("Incorrect no of params for method bar()", 2, params.size());
 		VariableElement param = (VariableElement) params.get(0);
 		TypeMirror typeMirror = param.asType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p2)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=p2)"});
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
 		
-		verifyTypeAnnotations(typeMirror, new String[]{});
+		verifyAnnotations(typeMirror, new String[]{});
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p1)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=p1)"});
 
 		param = (VariableElement) params.get(1);
 		typeMirror = param.asType();
-		verifyTypeAnnotations(typeMirror, new String[]{});
+		verifyAnnotations(typeMirror, new String[]{});
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
 		
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p5)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=p5)"});
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p4)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=p4)"});
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p3)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=p3)"});
 		
 	}
 	
@@ -388,9 +405,9 @@ public class Java8ElementProcessor extends BaseProcessor {
 		List<?extends TypeMirror> exceptions = method.getThrownTypes();
 		assertEquals("Incorrect no of thrown exceptions", 2, exceptions.size());
 		TypeMirror typeMirror = exceptions.get(0);
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=e1)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=e1)"});
 		typeMirror = exceptions.get(1);
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=e2)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=e2)"});
 	}
 
 	public void testTypeAnnotations6() {
@@ -406,13 +423,13 @@ public class Java8ElementProcessor extends BaseProcessor {
 		List<? extends VariableElement> params = method.getParameters();
 		assertEquals("Incorrect no of parameters", 1, params.size());
 		TypeMirror typeMirror = params.get(0).asType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p2)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=p2)"});
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p3)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=p3)"});
 		assertEquals("Should be an array type", TypeKind.ARRAY, typeMirror.getKind());
 		typeMirror = ((ArrayType) typeMirror).getComponentType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=p1)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=p1)"});
 
 	}
 
@@ -423,13 +440,13 @@ public class Java8ElementProcessor extends BaseProcessor {
 		List<? extends TypeParameterElement> typeParams = typeZ.getTypeParameters();
 		assertEquals("Incorrect no of type params", 2, typeParams.size());
 		TypeParameterElement typeParam = typeParams.get(0);
-		verifyTypeAnnotations(typeParam, new String[]{"@Type(value=tp1)"});
+		verifyAnnotations(typeParam, new String[]{"@Type(value=tp1)"});
 		typeMirror = typeParam.asType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=tp1)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=tp1)"});
 		typeParam = typeParams.get(1);
 		typeMirror = typeParam.asType();
-		verifyTypeAnnotations(typeParam, new String[]{"@Type(value=tp2)"});
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=tp2)"});
+		verifyAnnotations(typeParam, new String[]{"@Type(value=tp2)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=tp2)"});
 	}
 	
 	public void testTypeAnnotations8() {
@@ -449,15 +466,15 @@ public class Java8ElementProcessor extends BaseProcessor {
 		List<? extends TypeParameterElement> typeParams = method.getTypeParameters();
 		assertEquals("Incorrect no of type params", 2, typeParams.size());
 		TypeParameterElement typeParam = typeParams.get(0);
-		verifyTypeAnnotations(typeParam, new String[]{"@Type(value=mp1)"});
-		verifyTypeAnnotations(typeParam.asType(), new String[]{"@Type(value=mp1)"});
+		verifyAnnotations(typeParam, new String[]{"@Type(value=mp1)"});
+		verifyAnnotations(typeParam.asType(), new String[]{"@Type(value=mp1)"});
 		typeParam = typeParams.get(1);
-		verifyTypeAnnotations(typeParam, new String[]{"@Type(value=mp2)"});
-		verifyTypeAnnotations(typeParam.asType(), new String[]{"@Type(value=mp2)"});
+		verifyAnnotations(typeParam, new String[]{"@Type(value=mp2)"});
+		verifyAnnotations(typeParam.asType(), new String[]{"@Type(value=mp2)"});
 		//Z<@Type("ta1") String, @Type("ta2") Object> z1 = null;
 		// APIs don't expose the type arguments on a TypeMirror
 		TypeMirror typeMirror = field.asType();
-		verifyTypeAnnotations(typeMirror, new String[]{});
+		verifyAnnotations(typeMirror, new String[]{});
 	}
 
 	public void testTypeAnnotations9() {
@@ -487,10 +504,10 @@ public class Java8ElementProcessor extends BaseProcessor {
 				field3 = (VariableElement) member;
 			}
 		}
-		verifyTypeAnnotations(annotatedType, new String[]{"@Type(value=c)"});
-		verifyTypeAnnotations(annotatedType.asType(), new String[]{});
-		verifyTypeAnnotations(field3, new String[]{});
-		verifyTypeAnnotations(field3.asType(), new String[]{});
+		verifyAnnotations(annotatedType, new String[]{"@Type(value=c)"});
+		verifyAnnotations(annotatedType.asType(), new String[]{});
+		verifyAnnotations(field3, new String[]{});
+		verifyAnnotations(field3.asType(), new String[]{});
 	}
 
 	public void testTypeAnnotations11() {
@@ -502,8 +519,8 @@ public class Java8ElementProcessor extends BaseProcessor {
 				xy = (VariableElement) member;
 			}
 		}
-		verifyTypeAnnotations(xy, new String[]{});
-		verifyTypeAnnotations(xy.asType(), new String[]{"@Type(value=xy)"});
+		verifyAnnotations(xy, new String[]{});
+		verifyAnnotations(xy.asType(), new String[]{"@Type(value=xy)"});
 		
 		Set<String> expectedElementNames = new HashSet<String>(ELEMENT_NAMES.length);
 		for (String name : ELEMENT_NAMES) {
@@ -538,9 +555,9 @@ public class Java8ElementProcessor extends BaseProcessor {
 			}
 		}
 		TypeMirror typeMirror = bar2.getReceiverType();
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=receiver)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=receiver)"});
 		ExecutableType type = (ExecutableType) bar2.asType();
-		verifyTypeAnnotations(type.getReceiverType(), new String[]{"@Type(value=receiver)"});
+		verifyAnnotations(type.getReceiverType(), new String[]{"@Type(value=receiver)"});
 	}
 	
 	public void testTypeAnnotations13() {
@@ -555,7 +572,7 @@ public class Java8ElementProcessor extends BaseProcessor {
 			}
 		}
 		TypeMirror typeMirror = field.asType();
-		verifyTypeAnnotations(typeMirror, new String[]{});
+		verifyAnnotations(typeMirror, new String[]{});
 	}
 
 	public void testTypeAnnotations14() {
@@ -597,11 +614,11 @@ public class Java8ElementProcessor extends BaseProcessor {
 		typeMirror = constr.getReceiverType();
 		assertNotNull("TypeMirror should not be null", typeMirror);
 		assertNotSame("Should not be no type", TypeKind.NONE, typeMirror.getKind());
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=receiver)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=receiver)"});
 		type = (ExecutableType) constr.asType();
 		typeMirror = type.getReceiverType();
 		assertNotNull("TypeMirror should not be null", typeMirror);
-		verifyTypeAnnotations(typeMirror, new String[]{"@Type(value=receiver)"});
+		verifyAnnotations(typeMirror, new String[]{"@Type(value=receiver)"});
 		assertNotSame("Should not be no type", TypeKind.NONE, typeMirror.getKind());
 	}
 
@@ -643,6 +660,146 @@ public class Java8ElementProcessor extends BaseProcessor {
 		assertTrue("Found unexpected extra elements", expectedElementNames.isEmpty());
 	}
 
+	public void testRepeatedAnnotations17() {
+		Set<? extends Element> actualElments = roundEnv.getElementsAnnotatedWith(Foo.class); // discovery is always in terms of container
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 0);
+		
+		actualElments = roundEnv.getElementsAnnotatedWith(FooContainer.class);
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 1);
+		
+		for (Element e : actualElments) {
+			verifyAnnotations(e, new String[]{"@FooContainer(value=@org.eclipse.jdt.compiler.apt.tests.annotations.Foo,@org.eclipse.jdt.compiler.apt.tests.annotations.Foo)"},
+					new String [] {"@FooContainer(value=[@org.eclipse.jdt.compiler.apt.tests.annotations.Foo, @org.eclipse.jdt.compiler.apt.tests.annotations.Foo])"});
+			Annotation annot = e.getAnnotation(Foo.class);
+			assertNull("Repeating annotation should not be seen through old API", annot);
+			annot = e.getAnnotation(FooContainer.class);
+			assertNotNull("Container missing", annot);
+			Annotation [] annots = e.getAnnotationsByType(FooContainer.class);
+			assertTrue("Should not be empty", annots.length == 1);
+			annots = e.getAnnotationsByType(Foo.class);
+			assertTrue("Should be 2", annots.length == 2);
+			assertEquals("@Foo missing", "@org.eclipse.jdt.compiler.apt.tests.annotations.Foo()", "@org.eclipse.jdt.compiler.apt.tests.annotations.Foo",  annots[0].toString());
+			assertEquals("@Foo missing", "@org.eclipse.jdt.compiler.apt.tests.annotations.Foo()", "@org.eclipse.jdt.compiler.apt.tests.annotations.Foo", annots[1].toString());
+		}
+	}
+	
+	public void testRepeatedAnnotations18() {
+		Set<? extends Element> actualElments = roundEnv.getElementsAnnotatedWith(Foo.class); // discovery is always in terms of container
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 0);
+		
+		actualElments = roundEnv.getElementsAnnotatedWith(FooContainer.class);
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 1);
+		
+		for (Element e : actualElments) {
+			verifyAnnotations(e, new String[]{"@FooContainer(value=@org.eclipse.jdt.compiler.apt.tests.annotations.Foo,@org.eclipse.jdt.compiler.apt.tests.annotations.Foo)"},
+					new String [] {"@FooContainer(value=[@org.eclipse.jdt.compiler.apt.tests.annotations.Foo, @org.eclipse.jdt.compiler.apt.tests.annotations.Foo])"});
+			Annotation annot = e.getAnnotation(Foo.class);
+			assertNull("Repeating annotation should not be seen through old API", annot);
+			annot = e.getAnnotation(FooContainer.class);
+			assertNotNull("Container missing", annot);
+			Annotation [] annots = e.getAnnotationsByType(FooContainer.class);
+			assertTrue("Should not be empty", annots.length == 1);
+			annots = e.getAnnotationsByType(Foo.class);
+			assertTrue("Should be 2", annots.length == 2);
+			assertEquals("@Foo missing", "@org.eclipse.jdt.compiler.apt.tests.annotations.Foo()", "@org.eclipse.jdt.compiler.apt.tests.annotations.Foo",  annots[0].toString());
+			assertEquals("@Foo missing", "@org.eclipse.jdt.compiler.apt.tests.annotations.Foo()", "@org.eclipse.jdt.compiler.apt.tests.annotations.Foo", annots[1].toString());
+		}
+	}
+	public void testRepeatedAnnotations19() { // Goo is wrapped by GooNonContainer, but Goo is not repeatable.
+		Set<? extends Element> actualElments = roundEnv.getElementsAnnotatedWith(Goo.class); // discovery is always in terms of container
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 0);
+		
+		actualElments = roundEnv.getElementsAnnotatedWith(GooNonContainer.class);
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 1);
+		
+		for (Element e : actualElments) {
+			verifyAnnotations(e, new String[]{"@GooNonContainer(value=@org.eclipse.jdt.compiler.apt.tests.annotations.Goo,@org.eclipse.jdt.compiler.apt.tests.annotations.Goo)"},
+					new String [] {"@GooNonContainer(value=[@org.eclipse.jdt.compiler.apt.tests.annotations.Goo, @org.eclipse.jdt.compiler.apt.tests.annotations.Goo])"});
+			Annotation annot = e.getAnnotation(Goo.class);
+			assertNull("Repeating annotation should not be seen through old API", annot);
+			annot = e.getAnnotation(GooNonContainer.class);
+			assertNotNull("Container missing", annot);
+			Annotation [] annots = e.getAnnotationsByType(GooNonContainer.class);
+			assertTrue("Should not be empty", annots.length == 1);
+			annots = e.getAnnotationsByType(Goo.class); // Goo should not be unwrapped from the container as Goo is not a repeatable annotation.
+			assertTrue("Should be 0", annots.length == 0);
+		}
+	}
+	public void testRepeatedAnnotations20() { // Both Foo and FooContainer occur.
+		Set<? extends Element> actualElments = roundEnv.getElementsAnnotatedWith(Foo.class); // discovery is always in terms of container
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 1);
+		
+		actualElments = roundEnv.getElementsAnnotatedWith(FooContainer.class);
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 1);
+		
+		for (Element e : actualElments) {
+			verifyAnnotations(e, new String[]{"@FooContainer(value=@org.eclipse.jdt.compiler.apt.tests.annotations.Foo)", "@Foo()"},
+					new String [] {"@FooContainer(value=[@org.eclipse.jdt.compiler.apt.tests.annotations.Foo])","@org.eclipse.jdt.compiler.apt.tests.annotations.Foo"});
+			Annotation annot = e.getAnnotation(Foo.class);
+			assertNotNull("Foo is not wrapped, so should be seen with old API", annot);
+			annot = e.getAnnotation(FooContainer.class);
+			assertNotNull("Container missing", annot);
+			Annotation [] annots = e.getAnnotationsByType(FooContainer.class);
+			assertTrue("Should not be empty", annots.length == 1);
+			annots = e.getAnnotationsByType(Foo.class);
+			assertTrue("Should be 2", annots.length == 2);
+		}
+	}
+	
+	public void testRepeatedAnnotations21() { // Foo is wrapped by a non-declared container
+		Set<? extends Element> actualElments = roundEnv.getElementsAnnotatedWith(Foo.class); // discovery is always in terms of container
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 0);
+		
+		actualElments = roundEnv.getElementsAnnotatedWith(FooNonContainer.class);
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 1);
+		
+		for (Element e : actualElments) {
+			verifyAnnotations(e, new String[]{"@FooNonContainer(value=@org.eclipse.jdt.compiler.apt.tests.annotations.Foo,@org.eclipse.jdt.compiler.apt.tests.annotations.Foo)"},
+					new String [] {"@FooNonContainer(value=[@org.eclipse.jdt.compiler.apt.tests.annotations.Foo, @org.eclipse.jdt.compiler.apt.tests.annotations.Foo])"});
+			Annotation annot = e.getAnnotation(Foo.class);
+			assertNull("Foo should not be seen with old API", annot);
+			annot = e.getAnnotation(FooNonContainer.class);
+			assertNotNull("Container missing", annot);
+			Annotation [] annots = e.getAnnotationsByType(FooNonContainer.class);
+			assertTrue("Should not be empty", annots.length == 1);
+			annots = e.getAnnotationsByType(Foo.class);
+			assertTrue("Should be 0", annots.length == 0);
+		}
+	}
+	
+	public void testRepeatedAnnotations22() { // Repeating type annotations
+		Set<? extends Element> actualElments = roundEnv.getElementsAnnotatedWith(Foo.class); // discovery is always in terms of container
+		assertNotNull("RoundEnvironment#getElementsAnnotatedWith returned null", actualElments);
+		assertTrue("Found unexpected elements", actualElments.size() == 2);
+		
+		for (Element e : actualElments) {
+			if (e instanceof VariableElement) {
+				VariableElement field = (VariableElement) e;
+				TypeMirror mirror = field.asType();
+				verifyAnnotations(mirror, new String[]{"@TFooContainer(value=@org.eclipse.jdt.compiler.apt.tests.annotations.TFoo,@org.eclipse.jdt.compiler.apt.tests.annotations.TFoo)"},
+					new String [] {"@TFooContainer(value=[@org.eclipse.jdt.compiler.apt.tests.annotations.TFoo, @org.eclipse.jdt.compiler.apt.tests.annotations.TFoo])"});
+				Annotation annot = mirror.getAnnotation(TFoo.class);
+				assertNull("TFoo should not be seen with old API", annot);
+				annot = mirror.getAnnotation(TFooContainer.class);
+				assertNotNull("Container missing", annot);
+				Annotation [] annots = mirror.getAnnotationsByType(TFooContainer.class);
+				assertTrue("Should not be empty", annots.length == 1);
+				annots = mirror.getAnnotationsByType(TFoo.class);
+				assertTrue("Should be 2", annots.length == 2);
+			}
+		}
+	}
+	
 	private String getExceptionStackTrace(Throwable t) {
 		StringBuffer buf = new StringBuffer(t.getMessage());
 		StackTraceElement[] traces = t.getStackTrace();
@@ -655,7 +812,7 @@ public class Java8ElementProcessor extends BaseProcessor {
 		return buf.toString();
 	}
 
-	private void verifyTypeAnnotations(AnnotatedConstruct construct, String[] annots) {
+	private void verifyAnnotations(AnnotatedConstruct construct, String[] annots) {
 		List<? extends AnnotationMirror> annotations = construct.getAnnotationMirrors();
 		assertEquals("Incorrect no of annotations", annots.length, annotations.size());
 		for(int i = 0, length = annots.length; i < length; i++) {
@@ -663,6 +820,15 @@ public class Java8ElementProcessor extends BaseProcessor {
 			assertEquals("Invalid annotation value", annots[i], getAnnotationString(mirror));
 		}
 	}
+	
+	private void verifyAnnotations(AnnotatedConstruct construct, String[] annots, String [] alternateAnnots) {
+		List<? extends AnnotationMirror> annotations = construct.getAnnotationMirrors();
+		assertEquals("Incorrect no of annotations", annots.length, annotations.size());
+		for(int i = 0, length = annots.length; i < length; i++) {
+			AnnotationMirror mirror = annotations.get(i);
+			assertEquals("Invalid annotation value", annots[i], alternateAnnots[i], getAnnotationString(mirror));
+		}
+	}
 
 	private String getAnnotationString(AnnotationMirror annot) {
 		DeclaredType annotType = annot.getAnnotationType();
@@ -732,6 +898,14 @@ public class Java8ElementProcessor extends BaseProcessor {
         }
     }
 
+    public void assertEquals(String message, Object expected, Object alternateExpected, Object actual) {
+        if (equalsRegardingNull(expected, actual) || equalsRegardingNull(alternateExpected, actual)) {
+            return;
+        } else {
+        	reportError(message + ", expected " + expected.toString() + " but was " + actual.toString());
+        }
+    }
+    
     static boolean equalsRegardingNull(Object expected, Object actual) {
         if (expected == null) {
             return actual == null;
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120.java
new file mode 100644
index 0000000..aad8d40
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120.java
@@ -0,0 +1,7 @@
+package org.eclipse.jdt.compiler.apt.tests;
+import org.eclipse.jdt.compiler.apt.tests.annotations.Foo;
+
+@Foo @Foo
+public class JEP120 {
+	// ...
+}
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_1.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_1.java
new file mode 100644
index 0000000..8204b2a
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_1.java
@@ -0,0 +1,8 @@
+package org.eclipse.jdt.compiler.apt.tests;
+import org.eclipse.jdt.compiler.apt.tests.annotations.Foo;
+import org.eclipse.jdt.compiler.apt.tests.annotations.FooContainer;
+
+@FooContainer({@Foo, @Foo})
+public class JEP120_1 {
+	// ...
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_2.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_2.java
new file mode 100644
index 0000000..69ba813
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_2.java
@@ -0,0 +1,8 @@
+package org.eclipse.jdt.compiler.apt.tests;
+import org.eclipse.jdt.compiler.apt.tests.annotations.Goo;
+import org.eclipse.jdt.compiler.apt.tests.annotations.GooNonContainer;
+
+@GooNonContainer({@Goo, @Goo})
+public class JEP120_2 {
+	// ...
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_3.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_3.java
new file mode 100644
index 0000000..88ff376
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_3.java
@@ -0,0 +1,8 @@
+package org.eclipse.jdt.compiler.apt.tests;
+import org.eclipse.jdt.compiler.apt.tests.annotations.Foo;
+import org.eclipse.jdt.compiler.apt.tests.annotations.FooContainer;
+
+@FooContainer({@Foo}) @Foo
+public class JEP120_3 {
+	// ...
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_4.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_4.java
new file mode 100644
index 0000000..9da0b08
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_4.java
@@ -0,0 +1,8 @@
+package org.eclipse.jdt.compiler.apt.tests;
+import org.eclipse.jdt.compiler.apt.tests.annotations.Foo;
+import org.eclipse.jdt.compiler.apt.tests.annotations.FooNonContainer;
+
+@FooNonContainer({@Foo, @Foo})
+public class JEP120_4 {
+	// ...
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_5.java b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_5.java
new file mode 100644
index 0000000..4d19372
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/resources/targets/model8/JEP120_5.java
@@ -0,0 +1,8 @@
+package org.eclipse.jdt.compiler.apt.tests;
+import org.eclipse.jdt.compiler.apt.tests.annotations.Foo;
+import org.eclipse.jdt.compiler.apt.tests.annotations.TFoo;
+
+@Foo
+public class JEP120_5 {
+	@TFoo @TFoo @Foo String field;
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
index bba13d5..6436f35 100644
--- a/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
+++ b/org.eclipse.jdt.compiler.apt.tests/src/org/eclipse/jdt/compiler/apt/tests/Java8ElementsTests.java
@@ -30,7 +30,7 @@ import junit.framework.TestCase;
 
 public class Java8ElementsTests extends TestCase {
 	
-	private static final String TYPE_ANNOTATION_PROC = "org.eclipse.jdt.compiler.apt.tests.processors.elements.Java8ElementProcessor";
+	private static final String JAVA8_ANNOTATION_PROC = "org.eclipse.jdt.compiler.apt.tests.processors.elements.Java8ElementProcessor";
 
 	@Override
 	protected void setUp() throws Exception {
@@ -40,155 +40,206 @@ public class Java8ElementsTests extends TestCase {
 
 	public void testSE8Specifics() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testSE8Specifics");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testSE8Specifics");
 	}
 	public void testSE8SpecificsWithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testSE8Specifics");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testSE8Specifics");
 	}
 	public void testLambdaSpecifics() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testLambdaSpecifics");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testLambdaSpecifics");
 	}
 	public void testLambdaSpecificsWithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testLambdaSpecifics");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testLambdaSpecifics");
 	}
 	public void testTypeAnnotations() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations");
 	}
 	public void testTypeAnnotationsWithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations");
 	}
 	public void testTypeAnnotations1() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations1");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations1");
 	}
 	public void testTypeAnnotations1WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations1");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations1");
 	}
 	public void testTypeAnnotations2() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations2");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations2");
 	}
 	public void testTypeAnnotations2WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations2");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations2");
 	}
 	public void testTypeAnnotations3() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations3");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations3");
 	}
 	public void testTypeAnnotations3WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations3");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations3");
 	}
 	public void testTypeAnnotations4() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations4");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations4");
 	}
 	public void testTypeAnnotations4WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations4");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations4");
 	}
 	public void testTypeAnnotations5() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations5");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations5");
 	}
 	public void testTypeAnnotations5WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations5");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations5");
 	}
 	public void testTypeAnnotations6() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations6");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations6");
 	}
 	public void _testTypeAnnotations6WithJavac() throws Exception {   // Disabled for now. Javac 8b108 drops annotations arrays preceding varargs.
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations6");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations6");
 	}
 	public void testTypeAnnotations7() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations7");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations7");
 	}
 	public void _testTypeAnnotations7WithJavac() throws Exception {  // Disabled for now. Javac 8b108 misattributes annotations on type parameters 
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations7");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations7");
 	}
 	public void testTypeAnnotations8() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations8");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations8");
 	}
 	public void _testTypeAnnotations8WithJavac() throws Exception {     // Disabled for now. Javac 8b108 misattributes annotations on type parameters
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations8");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations8");
 	}
 	public void testTypeAnnotations9() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations9");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations9");
 	}
 	public void testTypeAnnotations9WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations9");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations9");
 	}
 	public void testTypeAnnotations10() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations10");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations10");
 	}
 	public void testTypeAnnotations10WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations10");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations10");
 	}
 	public void testTypeAnnotations11() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations11");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations11");
 	}
 	public void testTypeAnnotations11WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations11");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations11");
 	}
 	public void testTypeAnnotations12() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations12");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations12");
 	}
 	public void testTypeAnnotations12WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations12");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations12");
 	}
 	public void testTypeAnnotations13() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations13");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations13");
 	}
 	public void testTypeAnnotations13WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations13");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations13");
 	}
 	public void testTypeAnnotations14() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations14");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations14");
 	}
 	public void _testTypeAnnotations14WithJavac() throws Exception { // Disabled for now. Javac returns null as receiver type where it should be type 'None'
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations14");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations14");
 	}
 	public void testTypeAnnotations15() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations15", "Z1.java");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations15", "Z1.java");
 	}
 	public void testTypeAnnotations15WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations15", "Z1.java");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations15", "Z1.java");
 	}
 	public void testTypeAnnotations16() throws Exception {
 		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations16", "Z2.java");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations16", "Z2.java");
 	}
 	public void testTypeAnnotations16WithJavac() throws Exception {
 		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-		internalTest(compiler, TYPE_ANNOTATION_PROC, "testTypeAnnotations16", "Z2.java");
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testTypeAnnotations16", "Z2.java");
+	}
+	public void testRepeatedAnnotations17() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations17", "JEP120.java");
+	}
+	public void testRepeatedAnnotations17WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations17", "JEP120.java");
+	}
+	public void testRepeatedAnnotations18() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations18", "JEP120_1.java");
+	}
+	public void testRepeatedAnnotations18WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations18", "JEP120_1.java");
+	}
+	public void testRepeatedAnnotations19() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations19", "JEP120_2.java");
+	}
+	public void testRepeatedAnnotations19WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations19", "JEP120_2.java");
+	}
+	public void testRepeatedAnnotations20() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations20", "JEP120_3.java");
+	}
+	public void testRepeatedAnnotations20WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations20", "JEP120_3.java");
+	}
+	
+	public void testRepeatedAnnotations21() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations21", "JEP120_4.java");
+	}
+	public void testRepeatedAnnotations21WithJavac() throws Exception {
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations21", "JEP120_4.java");
+	}
+	
+	public void testRepeatedAnnotations22() throws Exception {
+		JavaCompiler compiler = BatchTestUtils.getEclipseCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations22", "JEP120_5.java");
+	}
+	
+	public void _testRepeatedAnnotations22WithJavac() throws Exception { // Disabled for now, javac 8b108 does not seem to expose any annotations on a type mirror when there are repeated annotations.
+		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+		internalTest(compiler, JAVA8_ANNOTATION_PROC, "testRepeatedAnnotations22", "JEP120_5.java");
 	}
 
 	private void internalTest(JavaCompiler compiler, String processor, String testMethod) throws IOException {
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
index 8bb119f..3eb2495 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
@@ -14,6 +14,7 @@ import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.apt.model.ElementImpl;
 import org.eclipse.jdt.internal.compiler.apt.model.Factory;
 import org.eclipse.jdt.internal.compiler.apt.util.ManyToMany;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
@@ -221,20 +222,18 @@ public class AnnotationDiscoveryVisitor extends ASTVisitor {
 		return true;
 	}
 
-	private void resolveAnnotations(
-			BlockScope scope,
-			Annotation[] annotations,
-			Binding currentBinding) {
-		ASTNode.resolveAnnotations(scope, annotations, currentBinding, true);
-		Element element = null;
+	private void resolveAnnotations(BlockScope scope, Annotation[] annotations, Binding currentBinding) {
+		
+		int length = annotations == null ? 0 : annotations.length;
+		if (length == 0)
+			return;
 		
-		for (Annotation annotation : annotations) {
-			AnnotationBinding binding = annotation.getCompilerAnnotation();
-			if (binding != null) { // binding should be resolved, but in case it's not, ignore it
+		ASTNode.resolveAnnotations(scope, annotations, currentBinding, true);
+		ElementImpl element = (ElementImpl) _factory.newElement(currentBinding);
+		AnnotationBinding [] annotationBindings = element.getPackedAnnotationBindings(); // discovery is never in terms of repeating annotation.
+		for (AnnotationBinding binding : annotationBindings) {
+			if (binding != null) { // binding should be resolved, but in case it's not, ignore it: it could have been wrapped into a container.
 				TypeElement anno = (TypeElement)_factory.newElement(binding.getAnnotationType());
-				if (element == null) {
-					element = _factory.newElement(currentBinding);
-				}
 				_annoToElement.put(anno, element);
 			}
 		}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
index d09f2fe..4580b99 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
@@ -15,6 +15,7 @@
 package org.eclipse.jdt.internal.compiler.apt.model;
 
 import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
@@ -51,23 +52,55 @@ public abstract class ElementImpl
 		return _env.getFactory().newTypeMirror(_binding);
 	}
 
-	@Override
-	public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {
-		return _env.getFactory().getAnnotation(getAnnotationBindings(), annotationClass);
-	}
-	
 	/**
 	 * @return the set of compiler annotation bindings on this element
 	 */
 	protected abstract AnnotationBinding[] getAnnotationBindings();
 
+	/* Package any repeating annotations into containers, return others as is.
+	   In the compiler bindings repeating annotations are left in as is, hence
+	   this step. The return value would match what one would expect to see in
+	   a class file.
+	*/
+	public final AnnotationBinding [] getPackedAnnotationBindings() {
+		return Factory.getPackedAnnotationBindings(getAnnotationBindings());
+	}
+	
+	/* Return only the contained annotations. Anything not inside a container is not 
+	   part of result. Since the compiler bindings encode repeating annotations as is,
+	   we need the packaging step first.
+	*/
+	public final AnnotationBinding [] getOnlyUnpackedAnnotationBindings() {
+		return Factory.getOnlyUnpackedAnnotationBindings(getPackedAnnotationBindings());
+	}
+	
+	@Override
+	public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {
+		return _env.getFactory().getAnnotation(getPackedAnnotationBindings(), annotationClass);
+	}
+	
 	@Override
 	public List<? extends AnnotationMirror> getAnnotationMirrors() {
-		return _env.getFactory().getAnnotationMirrors(getAnnotationBindings());
+		return _env.getFactory().getAnnotationMirrors(getPackedAnnotationBindings());
 	}
 
 	public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
-		return _env.getFactory().getAnnotationsByType(getAnnotationBindings(), annotationType);	
+		
+		A [] result1 = _env.getFactory().getAnnotationsByType(getPackedAnnotationBindings(), annotationType);
+		A [] result2 = _env.getFactory().getAnnotationsByType(getOnlyUnpackedAnnotationBindings(), annotationType);
+		
+		if (result1.length == 0)
+			return result2;
+		if (result2.length == 0)
+			return result1;
+		
+		@SuppressWarnings("unchecked")
+		A [] result = (A[]) Array.newInstance(result1[0].getClass(), result1.length + result2.length);
+		
+		System.arraycopy(result1, 0, result, 0, result1.length);
+		System.arraycopy(result2, 0, result, result1.length, result2.length);
+		
+		return result;
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
index 63d74f9..72110e5 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
@@ -45,11 +45,13 @@ import org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
 import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.compiler.lookup.ElementValuePair;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
@@ -757,5 +759,96 @@ public class Factory {
 			Array.set(array, i, null);
 		}
 	}
-    
+
+	/* Wrap repeating annotations into their container, return an array of bindings.
+	   Second and subsequent repeating annotations are replaced with nulls. Caller
+	   must be prepared to handle with nulls. Incoming array is not modified.
+	*/
+	public static AnnotationBinding [] getPackedAnnotationBindings(AnnotationBinding [] annotations) {
+		
+		int length = annotations == null ? 0 : annotations.length;
+		if (length == 0)
+			return annotations;
+		
+		AnnotationBinding[] repackagedBindings = annotations; // only replicate if repackaging.
+		for (int i = 0; i < length; i++) {
+			AnnotationBinding annotation = repackagedBindings[i];
+			if (annotation == null) continue;
+			ReferenceBinding annotationType = annotation.getAnnotationType();
+			if (!annotationType.isRepeatableAnnotation())
+				continue;
+			ReferenceBinding containerType = annotationType.resolveContainerAnnotation();
+			if (containerType == null)
+				continue; // FUBAR.
+			MethodBinding [] values = containerType.getMethods(TypeConstants.VALUE);
+			if (values == null || values.length != 1)
+				continue; // FUBAR.
+			MethodBinding value = values[0];
+			if (value.returnType == null || value.returnType.leafComponentType() != annotationType)
+				continue; // FUBAR
+			
+			// We have a kosher repeatable annotation with a kosher containing type. See if actually repeats.
+			List<AnnotationBinding> containees = null;
+			for (int j = i + 1; j < length; j++) {
+				AnnotationBinding otherAnnotation = repackagedBindings[j];
+				if (otherAnnotation == null) continue;
+				if (otherAnnotation.getAnnotationType() == annotationType) {
+					if (repackagedBindings == annotations)
+						System.arraycopy(repackagedBindings, 0, repackagedBindings = new AnnotationBinding[length], 0, length);
+					repackagedBindings[j] = null; // so it is not double packed.
+					if (containees == null) {
+						containees = new ArrayList<AnnotationBinding>();
+						containees.add(annotation);
+					}
+					containees.add(otherAnnotation);
+				}
+			}
+			if (containees != null) {
+				ElementValuePair [] elementValuePairs = new ElementValuePair [] { new ElementValuePair(TypeConstants.VALUE, containees.toArray(), value) };
+				repackagedBindings[i] = new AnnotationBinding(containerType, elementValuePairs);
+			}
+		}
+		return repackagedBindings;
+	}
+	
+	/* Unwrap container annotations into the repeated annotations, return an array of bindings. non-contained annotations are not returned.
+	*/
+	public static AnnotationBinding [] getOnlyUnpackedAnnotationBindings(AnnotationBinding [] annotations) {
+		
+		int length = annotations == null ? 0 : annotations.length;
+		if (length == 0)
+			return annotations;
+		
+		List<AnnotationBinding> unpackedAnnotations = new ArrayList<AnnotationBinding>();
+		for (int i = 0; i < length; i++) {
+			AnnotationBinding annotation = annotations[i];
+			if (annotation == null) continue;
+			ReferenceBinding annotationType = annotation.getAnnotationType();
+			
+			MethodBinding [] values = annotationType.getMethods(TypeConstants.VALUE);
+			if (values == null || values.length != 1)
+				continue;
+			MethodBinding value = values[0];
+			
+			TypeBinding containeeType = value.returnType.leafComponentType();
+			if (containeeType == null || !containeeType.isAnnotationType() || !containeeType.isRepeatableAnnotation())
+				continue;
+			
+			if (containeeType.resolveContainerAnnotation() != annotationType)
+				continue;
+			
+			// We have a kosher container: unwrap the contained annotations.
+			ElementValuePair [] elementValuePairs = annotation.getElementValuePairs();
+			for (ElementValuePair elementValuePair : elementValuePairs) {
+				if (CharOperation.equals(elementValuePair.getName(), TypeConstants.VALUE)) {
+					Object [] containees = (Object []) elementValuePair.getValue();
+					for (Object object : containees) {
+						unpackedAnnotations.add((AnnotationBinding) object);
+					}
+					break;
+				}
+			}
+		}
+		return (AnnotationBinding[]) unpackedAnnotations.toArray(new AnnotationBinding [unpackedAnnotations.size()]);
+	}	
 }
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
index c715726..6857451 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
@@ -17,6 +17,7 @@
 package org.eclipse.jdt.internal.compiler.apt.model;
 
 import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
 import java.util.List;
 
 import javax.lang.model.element.AnnotationMirror;
@@ -116,24 +117,55 @@ public class TypeMirrorImpl implements TypeMirror {
 		return _binding == other._binding;
 	}
 
+	/* Package any repeating annotations into containers, return others as is.
+	   In the compiler bindings repeating annotations are left in as is, hence
+	   this step. The return value would match what one would expect to see in
+	   a class file.
+	*/
+	public final AnnotationBinding [] getPackedAnnotationBindings() {
+		return Factory.getPackedAnnotationBindings(getAnnotationBindings());
+	}
+	
+	/* Return only the contained annotations. Anything not inside a container is not 
+	   part of result. Since the compiler bindings encode repeating annotations as is,
+	   we need the packaging step first.
+	*/
+	public final AnnotationBinding [] getOnlyUnpackedAnnotationBindings() {
+		return Factory.getOnlyUnpackedAnnotationBindings(getPackedAnnotationBindings());
+	}
+
 	protected AnnotationBinding[] getAnnotationBindings() {
 		return ((TypeBinding)_binding).getTypeAnnotations();
 	}
 
 	public List<? extends AnnotationMirror> getAnnotationMirrors() {
 		return _env == null ? Factory.EMPTY_ANNOTATION_MIRRORS : 
-								_env.getFactory().getAnnotationMirrors(getAnnotationBindings());
+								_env.getFactory().getAnnotationMirrors(getPackedAnnotationBindings());
 	}
 
 	public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
-		return _env == null ? null : _env.getFactory().getAnnotation(getAnnotationBindings(), annotationType);
+		return _env == null ? null : _env.getFactory().getAnnotation(getPackedAnnotationBindings(), annotationType);
 	}
 
 	@SuppressWarnings("unchecked")
 	public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
-		return _env == null ? (A[]) Factory.EMPTY_ANNOTATIONS : 
-								_env.getFactory().getAnnotationsByType(getAnnotationBindings(), annotationType);
+		
+		if (_env == null)
+			return (A[]) Factory.EMPTY_ANNOTATIONS;
+		
+		A [] result1 = _env.getFactory().getAnnotationsByType(getPackedAnnotationBindings(), annotationType);
+		A [] result2 = _env.getFactory().getAnnotationsByType(getOnlyUnpackedAnnotationBindings(), annotationType);
+		
+		if (result1.length == 0)
+			return result2;
+		if (result2.length == 0)
+			return result1;
+		
+		A [] result = (A[]) Array.newInstance(result1[0].getClass(), result1.length + result2.length);
+		
+		System.arraycopy(result1, 0, result, 0, result1.length);
+		System.arraycopy(result2, 0, result, result1.length, result2.length);
+		
+		return result;
 	}
-
-	
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotationBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotationBinding.java
index e9f1d86..b2c9001 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotationBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/AnnotationBinding.java
@@ -171,7 +171,7 @@ private static AnnotationBinding buildTargetAnnotation(long bits, LookupEnvironm
 			});
 }
 
-AnnotationBinding(ReferenceBinding type, ElementValuePair[] pairs) {
+public AnnotationBinding(ReferenceBinding type, ElementValuePair[] pairs) {
 	this.type = type;
 	this.pairs = pairs;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 5a5b0da..9ec687c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -1379,13 +1379,6 @@ public final boolean isPublic() {
 }
 
 /**
- * Answer true if the receiver is an annotation which may be repeatable. Overridden as appropriate.
- */
-public boolean isRepeatableAnnotation() {
-	return false;
-}
-
-/**
  * Answer true if the receiver is a static member type (or toplevel)
  */
 public final boolean isStatic() {
@@ -1529,10 +1522,6 @@ public char[] readableName() /*java.lang.Object,  p.X<T> */ {
 	return readableName;
 }
 
-public ReferenceBinding resolveContainerAnnotation() {
-	return null;
-}
-
 protected void appendNullAnnotation(StringBuffer nameBuffer, CompilerOptions options) {
 	if (options.isAnnotationBasedNullAnalysisEnabled) {
 		// restore applied null annotation from tagBits:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 1ea2688..62f1f92 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -161,6 +161,10 @@ int rank() {
 	return -1; // overridden in WildcardBinding
 }
 
+public ReferenceBinding resolveContainerAnnotation() {
+	return null;
+}
+
 /* Answer true if the receiver can be instantiated
  */
 public boolean canBeInstantiated() {
@@ -986,6 +990,13 @@ private boolean isProvablyDistinctTypeArgument(TypeBinding otherArgument, final
 	}
 }
 
+/**
+ * Answer true if the receiver is an annotation which may be repeatable. Overridden as appropriate.
+ */
+public boolean isRepeatableAnnotation() {
+	return false;
+}
+
 public final boolean isRawType() {
 	return kind() == Binding.RAW_TYPE;
 }
commit ed66e6486327bb8ea562a3ea71402763c0b480fb
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Thu Oct 10 22:14:44 2013 +0530

    Follow up to fix for Bug 418000 - [1.8][compiler] Support language model
    API for repeated annotations (to eliminate needless repacking of
    annotations)

4	10	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
3	10	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
index 4580b99..986c2e3 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
@@ -66,14 +66,6 @@ public abstract class ElementImpl
 		return Factory.getPackedAnnotationBindings(getAnnotationBindings());
 	}
 	
-	/* Return only the contained annotations. Anything not inside a container is not 
-	   part of result. Since the compiler bindings encode repeating annotations as is,
-	   we need the packaging step first.
-	*/
-	public final AnnotationBinding [] getOnlyUnpackedAnnotationBindings() {
-		return Factory.getOnlyUnpackedAnnotationBindings(getPackedAnnotationBindings());
-	}
-	
 	@Override
 	public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {
 		return _env.getFactory().getAnnotation(getPackedAnnotationBindings(), annotationClass);
@@ -86,8 +78,10 @@ public abstract class ElementImpl
 
 	public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
 		
-		A [] result1 = _env.getFactory().getAnnotationsByType(getPackedAnnotationBindings(), annotationType);
-		A [] result2 = _env.getFactory().getAnnotationsByType(getOnlyUnpackedAnnotationBindings(), annotationType);
+		AnnotationBinding [] packedAnnotations = getPackedAnnotationBindings();
+		
+		A [] result1 = _env.getFactory().getAnnotationsByType(packedAnnotations, annotationType);
+		A [] result2 = _env.getFactory().getAnnotationsByType(Factory.getOnlyUnpackedAnnotationBindings(packedAnnotations), annotationType);
 		
 		if (result1.length == 0)
 			return result2;
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
index 6857451..d9eda0b 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
@@ -126,14 +126,6 @@ public class TypeMirrorImpl implements TypeMirror {
 		return Factory.getPackedAnnotationBindings(getAnnotationBindings());
 	}
 	
-	/* Return only the contained annotations. Anything not inside a container is not 
-	   part of result. Since the compiler bindings encode repeating annotations as is,
-	   we need the packaging step first.
-	*/
-	public final AnnotationBinding [] getOnlyUnpackedAnnotationBindings() {
-		return Factory.getOnlyUnpackedAnnotationBindings(getPackedAnnotationBindings());
-	}
-
 	protected AnnotationBinding[] getAnnotationBindings() {
 		return ((TypeBinding)_binding).getTypeAnnotations();
 	}
@@ -153,8 +145,9 @@ public class TypeMirrorImpl implements TypeMirror {
 		if (_env == null)
 			return (A[]) Factory.EMPTY_ANNOTATIONS;
 		
-		A [] result1 = _env.getFactory().getAnnotationsByType(getPackedAnnotationBindings(), annotationType);
-		A [] result2 = _env.getFactory().getAnnotationsByType(getOnlyUnpackedAnnotationBindings(), annotationType);
+		AnnotationBinding [] packedAnnotations = getPackedAnnotationBindings();
+		A [] result1 = _env.getFactory().getAnnotationsByType(packedAnnotations, annotationType);
+		A [] result2 = _env.getFactory().getAnnotationsByType(Factory.getOnlyUnpackedAnnotationBindings(packedAnnotations), annotationType);
 		
 		if (result1.length == 0)
 			return result2;
