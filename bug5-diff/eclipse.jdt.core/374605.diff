commit 44ff943ce2a18d1de59c739946fda0722d1ad727
Author: Stephan Herrmann <sherrmann>
Date:   Thu Apr 19 17:31:12 2012 +0200

    Tests & fix for bug 374605: Unreasonable warning for enum-based switch
    statements

105	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
12	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
233	40	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
2	12	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StaticImportTest.java
33	7	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
0	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
0	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
3	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CodeCorrectionTests.java
22	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
4	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
15	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
33	22	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
29	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
17	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
27	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
36	4	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index eae3cad..d44b1a1 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -18,6 +18,7 @@
  *								bug 365208 - [compiler][batch] command line options for annotation based null analysis
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
+ *								bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -1717,6 +1718,8 @@ public void test012b(){
         "      emptyBlock           undocumented empty block\n" + 
         "      enumIdentifier       ''enum'' used as identifier\n" + 
         "      enumSwitch           incomplete enum switch\n" + 
+        "      enumSwitchPedantic + report missing enum switch cases even\n" + 
+        "                           in the presence of a default case\n" + 
         "      fallthrough          possible fall-through case\n" + 
         "      fieldHiding          field hiding another variable\n" + 
         "      finalBound           type parameter with final bound\n" + 
@@ -1755,7 +1758,8 @@ public void test012b(){
         "      super                overriding a method without making a super invocation\n" + 
         "      suppress           + enable @SuppressWarnings\n" + 
         "                           When used with -err:, it can also silent optional\n" + 
-        "                           errors and warnings\n" + 
+        "                           errors and warnings\n" +
+        "      switchDefault      + switch statement lacking a default case\n" + 
         "      syncOverride         missing synchronized in synchr. method override\n" + 
         "      syntheticAccess      synthetic access for innerclass\n" + 
         "      tasks(<tags separated by |>) tasks identified by tags inside comments\n" + 
@@ -1884,7 +1888,9 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility\" value=\"public\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.localVariableHiding\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.methodWithConstructorName\" value=\"warning\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation\" value=\"ignore\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.missingDefaultCase\" value=\"ignore\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation\" value=\"ignore\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.missingEnumCaseDespiteDefault\" value=\"disabled\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.missingJavadocComments\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding\" value=\"disabled\"/>\n" + 
@@ -12731,6 +12737,103 @@ public void test316_warn_options() {
 		true);
 }
 
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=374605
+// -warn/-error option : enumSwitchPedantic 
+public void test317_warn_options() {
+	this.runConformTest(
+		new String[] {
+				"p/X.java",
+				"package p;\n" +
+				"enum Color { RED, GREEN };\n" +
+				"public class X {\n" +
+				"     int getVal(Color c) {\n" +
+				"         switch (c) {\n" +
+				"             case RED: return 1;\n" +
+				"             default : return 0;\n" +
+				"         }\n" +
+				"     }\n" +
+				"}\n"
+		},
+		"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
+		+ " -sourcepath \"" + OUTPUT_DIR + "\""
+		+ " -1.5"
+		+ " -warn:+enumSwitchPedantic -proc:none -d \"" + OUTPUT_DIR + "\"",
+		"",
+		"----------\n" +
+		"1. WARNING in " + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java (at line 5)\n" +
+		"	switch (c) {\n" +
+		"	        ^\n" +
+		"The enum constant GREEN should have a corresponding case label in this enum switch on Color. To suppress this problem, add a comment //$CASES-OMITTED$ on the line above the 'default:'\n" +
+		"----------\n" +
+		"1 problem (1 warning)",
+		true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=374605
+// -warn/-error option : enumSwitchPedantic: increase severity to ERROR
+public void test318_warn_options() {
+	this.runNegativeTest(
+			new String[] {
+					"p/X.java",
+					"package p;\n" +
+					"enum Color { RED, GREEN };\n" +
+					"public class X {\n" +
+					"     int getVal(Color c) {\n" +
+					"         switch (c) {\n" +
+					"             case RED: return 1;\n" +
+					"             default : return 0;\n" +
+					"         }\n" +
+					"     }\n" +
+					"}\n"
+			},
+			"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
+			+ " -sourcepath \"" + OUTPUT_DIR + "\""
+			+ " -1.5"
+			+ " -err:+enumSwitchPedantic -proc:none -d \"" + OUTPUT_DIR + "\"",
+			"",
+			"----------\n" +
+			"1. ERROR in " + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java (at line 5)\n" +
+			"	switch (c) {\n" +
+			"	        ^\n" +
+			"The enum constant GREEN should have a corresponding case label in this enum switch on Color. To suppress this problem, add a comment //$CASES-OMITTED$ on the line above the 'default:'\n" +
+			"----------\n" +
+			"1 problem (1 error)",
+			true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=374605
+// -warn/-error option : switchDefault
+public void test319_warn_options() {
+	this.runConformTest(
+		new String[] {
+				"p/X.java",
+				"package p;\n" +
+				"enum Color { RED, GREEN };\n" +
+				"public class X {\n" +
+				"     int getVal(Color c) {\n" +
+				"         switch (c) {\n" +
+				"             case RED: return 1;\n" +
+				"             case GREEN : return 2;\n" +
+				"         }\n" +
+				"         return 0;\n" +
+				"     }\n" +
+				"}\n"
+		},
+		"\"" + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java\""
+		+ " -sourcepath \"" + OUTPUT_DIR + "\""
+		+ " -1.5"
+		+ " -warn:+switchDefault -proc:none -d \"" + OUTPUT_DIR + "\"",
+		"",
+		"----------\n" +
+		"1. WARNING in " + OUTPUT_DIR +  File.separator + "p" + File.separator + "X.java (at line 5)\n" +
+		"	switch (c) {\n" +
+		"	        ^\n" +
+		"The switch over the enum type Color should have a default case\n" +
+		"----------\n" +
+		"1 problem (1 warning)",
+		true);
+}
+
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=220928
 //-nowarn option - regression tests
 //default
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 7455d46..cf5f3b6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -14,6 +14,7 @@
  *     							bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
+ *								bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -695,9 +696,11 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("MethodReturnsVoid", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("MethodVarargsArgumentNeedCast", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("MissingArgumentsForParameterizedMemberType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("MissingDefaultCase", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("MissingEnclosingInstance", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("MissingEnclosingInstanceForConstructorCall", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("MissingEnumConstantCase", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("MissingEnumConstantCaseDespiteDefault", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("MissingEnumDefaultCase", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("MissingNonNullByDefaultAnnotationOnPackage", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("MissingNonNullByDefaultAnnotationOnType", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -821,6 +824,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("SafeVarargsOnNonFinalInstanceMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("ShouldImplementHashcode", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ShouldReturnValue", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("ShouldReturnValueHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("SpecdNonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("StaticInheritedMethodConflicts", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("StaticMemberOfParameterizedType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
@@ -883,7 +887,9 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("UnhandledExceptionOnAutoClose", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("UnhandledWarningToken", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("UninitializedBlankFinalField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("UninitializedBlankFinalFieldHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("UninitializedLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
+		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("UnmatchedBracket", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", DEPRECATED);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
@@ -1395,10 +1401,12 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("MethodReturnsVoid", SKIP);
 		expectedProblemAttributes.put("MethodVarargsArgumentNeedCast", new ProblemAttributes(JavaCore.COMPILER_PB_VARARGS_ARGUMENT_NEED_CAST));
 		expectedProblemAttributes.put("MissingArgumentsForParameterizedMemberType", SKIP);
+		expectedProblemAttributes.put("MissingDefaultCase", new ProblemAttributes(JavaCore.COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE));
 		expectedProblemAttributes.put("MissingEnclosingInstance", SKIP);
 		expectedProblemAttributes.put("MissingEnclosingInstanceForConstructorCall", SKIP);
 		expectedProblemAttributes.put("MissingEnumConstantCase", new ProblemAttributes(JavaCore.COMPILER_PB_INCOMPLETE_ENUM_SWITCH));
-		expectedProblemAttributes.put("MissingEnumDefaultCase", new ProblemAttributes(JavaCore.COMPILER_PB_INCOMPLETE_ENUM_SWITCH));
+		expectedProblemAttributes.put("MissingEnumConstantCaseDespiteDefault", new ProblemAttributes(JavaCore.COMPILER_PB_INCOMPLETE_ENUM_SWITCH));
+		expectedProblemAttributes.put("MissingEnumDefaultCase", new ProblemAttributes(JavaCore.COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE));
 		expectedProblemAttributes.put("MissingNonNullByDefaultAnnotationOnPackage", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION));
 		expectedProblemAttributes.put("MissingNonNullByDefaultAnnotationOnType", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_NONNULL_BY_DEFAULT_ANNOTATION));
 		expectedProblemAttributes.put("MissingOverrideAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_OVERRIDE_ANNOTATION));
@@ -1521,6 +1529,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("SafeVarargsOnNonFinalInstanceMethod", SKIP);
 		expectedProblemAttributes.put("ShouldImplementHashcode", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_HASHCODE_METHOD));
 		expectedProblemAttributes.put("ShouldReturnValue", SKIP);
+		expectedProblemAttributes.put("ShouldReturnValueHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("SpecdNonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("StaticInheritedMethodConflicts", SKIP);
 		expectedProblemAttributes.put("StaticMemberOfParameterizedType", SKIP);
@@ -1583,7 +1592,9 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UnhandledExceptionOnAutoClose", SKIP);
 		expectedProblemAttributes.put("UnhandledWarningToken", new ProblemAttributes(JavaCore.COMPILER_PB_UNHANDLED_WARNING_TOKEN));
 		expectedProblemAttributes.put("UninitializedBlankFinalField", SKIP);
+		expectedProblemAttributes.put("UninitializedBlankFinalFieldHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UninitializedLocalVariable", SKIP);
+		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UnmatchedBracket", SKIP);
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", SKIP);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(JavaCore.COMPILER_PB_UNNECESSARY_TYPE_CHECK));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
index f3fbf69..b6cb60c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/EnumTest.java
@@ -10,6 +10,7 @@
  *		Stephan Herrmann - Contributions for
  *								Bug 365519 - editorial cleanup after bug 186342 and bug 365387
  *								Bug 265744 - Enum switch should warn about missing default
+ *								Bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -36,7 +37,7 @@ public class EnumTest extends AbstractComparableTest {
 	// Static initializer to specify tests subset using TESTS_* static variables
 	// All specified tests which does not belong to the class are skipped...
 	static {
-//		TESTS_NAMES = new String[] { "test146" };
+//		TESTS_NAMES = new String[] { "test187" };
 //		TESTS_NUMBERS = new int[] { 185 };
 //		TESTS_RANGE = new int[] { 21, 50 };
 	}
@@ -735,22 +736,17 @@ public void test022() {
 			"}\n",
 		},
 		"----------\n" + 
-		"1. WARNING in X.java (at line 6)\n" + 
-		"	switch(e) {\n" + 
-		"	       ^\n" + 
-		"The switch on the enum type X.MX should have a default case\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 7)\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
 		"	case MX.BLEU : break;\n" + 
 		"	     ^^^^^^^\n" + 
 		"The qualified case label X.MX.BLEU must be replaced with the unqualified enum constant BLEU\n" + 
 		"----------\n" + 
-		"3. ERROR in X.java (at line 8)\n" + 
+		"2. ERROR in X.java (at line 8)\n" + 
 		"	case MX.BLANC : break;\n" + 
 		"	     ^^^^^^^^\n" + 
 		"The qualified case label X.MX.BLANC must be replaced with the unqualified enum constant BLANC\n" + 
 		"----------\n" + 
-		"4. ERROR in X.java (at line 9)\n" + 
+		"3. ERROR in X.java (at line 9)\n" + 
 		"	case MX.ROUGE : break;\n" + 
 		"	     ^^^^^^^^\n" + 
 		"The qualified case label X.MX.ROUGE must be replaced with the unqualified enum constant ROUGE\n" + 
@@ -1818,24 +1814,19 @@ public void test061() {
 		"1. WARNING in X.java (at line 8)\n" +
 		"	switch (x) {\n" +
 		"	        ^\n" +
-		"The switch on the enum type X should have a default case\n" +
-		"----------\n" +
-		"2. WARNING in X.java (at line 8)\n" +
-		"	switch (x) {\n" +
-		"	        ^\n" +
 		"The enum constant A needs a corresponding case label in this enum switch on X\n" +
 		"----------\n" +
-		"3. WARNING in X.java (at line 8)\n" +
+		"2. WARNING in X.java (at line 8)\n" +
 		"	switch (x) {\n" +
 		"	        ^\n" +
 		"The enum constant B needs a corresponding case label in this enum switch on X\n" +
 		"----------\n" +
-		"4. WARNING in X.java (at line 8)\n" +
+		"3. WARNING in X.java (at line 8)\n" +
 		"	switch (x) {\n" +
 		"	        ^\n" +
 		"The enum constant C needs a corresponding case label in this enum switch on X\n" +
 		"----------\n" +
-		"5. ERROR in X.java (at line 9)\n" +
+		"4. ERROR in X.java (at line 9)\n" +
 		"	case D:\n" +
 		"	     ^\n" +
 		"The field X.D cannot be referenced from an enum case label; only enum constants can be used in enum switch\n" +
@@ -1846,6 +1837,8 @@ public void test061() {
  * https://bugs.eclipse.org/bugs/show_bug.cgi?id=82217 - variation with qualified name
  */
 public void test062() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE, JavaCore.WARNING);
 	this.runNegativeTest(
 		new String[] {
 			"X.java",
@@ -1866,7 +1859,7 @@ public void test062() {
 		"1. WARNING in X.java (at line 8)\n" +
 		"	switch (x) {\n" +
 		"	        ^\n" +
-		"The switch on the enum type X should have a default case\n" +
+		"The switch over the enum type X should have a default case\n" + 
 		"----------\n" +
 		"2. WARNING in X.java (at line 8)\n" +
 		"	switch (x) {\n" +
@@ -1887,7 +1880,10 @@ public void test062() {
 		"	case X.D:\n" +
 		"	       ^\n" +
 		"The field X.D cannot be referenced from an enum case label; only enum constants can be used in enum switch\n" +
-		"----------\n");
+		"----------\n",
+		null, // classlibs
+		true, // flush
+		options);
 }
 
 /**
@@ -3141,24 +3137,19 @@ public void test098() {
 		"1. WARNING in E.java (at line 5)\n" +
 		"	switch (color) {\n" +
 		"	        ^^^^^\n" +
-		"The switch on the enum type Colors should have a default case\n" +
-		"----------\n" +
-		"2. WARNING in E.java (at line 5)\n" +
-		"	switch (color) {\n" +
-		"	        ^^^^^\n" +
 		"The enum constant BLACK needs a corresponding case label in this enum switch on Colors\n" +
 		"----------\n" +
-		"3. WARNING in E.java (at line 5)\n" +
+		"2. WARNING in E.java (at line 5)\n" +
 		"	switch (color) {\n" +
 		"	        ^^^^^\n" +
 		"The enum constant RED needs a corresponding case label in this enum switch on Colors\n" +
 		"----------\n" +
-		"4. WARNING in E.java (at line 5)\n" +
+		"3. WARNING in E.java (at line 5)\n" +
 		"	switch (color) {\n" +
 		"	        ^^^^^\n" +
 		"The enum constant WHITE needs a corresponding case label in this enum switch on Colors\n" +
 		"----------\n" +
-		"5. ERROR in E.java (at line 16)\n" +
+		"4. ERROR in E.java (at line 16)\n" +
 		"	Zork z;\n" +
 		"	^^^^\n" +
 		"Zork cannot be resolved to a type\n" +
@@ -4759,15 +4750,10 @@ public void test135() {
 			"}",
         },
         "----------\n" + 
-		"1. WARNING in X.java (at line 4)\n" + 
-		"	switch (e) {\n" + 
-		"	        ^\n" + 
-		"The switch on the enum type E should have a default case\n" + 
-		"----------\n" +
-		"2. ERROR in X.java (at line 12)\n" +
+		"1. ERROR in X.java (at line 12)\n" +
 		"	return b;\n" +
 		"	       ^\n" +
-		"The local variable b may not have been initialized\n" +
+		"The local variable b may not have been initialized. Note that a problem regarding missing 'default:' on 'switch' has been suppressed, which is perhaps related to this problem\n" +
 		"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=151368
@@ -5179,14 +5165,49 @@ public void test146() {
 		"1. ERROR in X.java (at line 6)\n" +
 		"	public X(MyEnum e) { // error\n" +
 		"	       ^^^^^^^^^^^\n" +
-		"The blank final field test may not have been initialized\n" +
-		"----------\n" + 
-		"2. WARNING in X.java (at line 7)\n" + 
-		"	switch (e) {\n" + 
-		"	        ^\n" + 
-		"The switch on the enum type X.MyEnum should have a default case\n" + 
+		"The blank final field test may not have been initialized. Note that a problem regarding missing 'default:' on 'switch' has been suppressed, which is perhaps related to this problem\n" +
 		"----------\n");
 }
+// normal error when other warning is enabled
+public void test146b() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE, JavaCore.WARNING);
+	this.runNegativeTest(
+		new String[] {
+				"X.java",
+				"public class X {\n" +
+				"	enum MyEnum {\n" +
+				"		A, B\n" +
+				"	}\n" +
+				"	final String test;\n" +
+				"	public X(MyEnum e) { // error\n" +
+				"		switch (e) {\n" +
+				"			case A:\n" +
+				"				test = \"a\";\n" +
+				"				break;\n" +
+				"			case B:\n" +
+				"				test = \"a\";\n" +
+				"				break;\n" +
+				"			// default: test = \"unknown\"; // enabling this line fixes above error\n" +
+				"		}\n" +
+				"	}\n" +
+				"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 6)\n" +
+		"	public X(MyEnum e) { // error\n" +
+		"	       ^^^^^^^^^^^\n" +
+		"The blank final field test may not have been initialized\n" +
+		"----------\n" +
+		"2. WARNING in X.java (at line 7)\n" +
+		"	switch (e) {\n" +
+		"	        ^\n" +
+		"The switch over the enum type X.MyEnum should have a default case\n" +
+		"----------\n",
+		null,
+		true,
+		options);
+}
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=227502
 public void test147() {
 	this.runNegativeTest(
@@ -6839,4 +6860,176 @@ public void test185() {
 		"Unhandled exception type Exception\n" + 
 		"----------\n");
 }
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=374605
+public void test186() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_MISSING_ENUM_CASE_DESPITE_DEFAULT, JavaCore.ENABLED);
+	this.runNegativeTest(
+		new String[] {
+			"Y.java",
+			"enum X {\n" + 
+			"  A, B;\n" + 
+			"}\n" +
+			"public class Y {\n" +
+			"    void test(X x) {\n" +
+			"        switch (x) {\n" +
+			"			case A: System.out.println(\"A\"); break;\n" +
+			" 			default : System.out.println(\"unknown\"); break;\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+		},
+		"----------\n" + 
+		"1. WARNING in Y.java (at line 6)\n" + 
+		"	switch (x) {\n" + 
+		"	        ^\n" + 
+		"The enum constant B should have a corresponding case label in this enum switch on X. To suppress this problem, add a comment //$CASES-OMITTED$ on the line above the 'default:'\n" + 
+		"----------\n",
+		null, // classlibs
+		true, // flush
+		options);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=374605
+public void test187() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_MISSING_ENUM_CASE_DESPITE_DEFAULT, JavaCore.ENABLED);
+	options.put(JavaCore.COMPILER_PB_INCOMPLETE_ENUM_SWITCH, JavaCore.ERROR);
+	this.runConformTest(
+		new String[] {
+			"Y.java",
+			"enum X {\n" + 
+			"  A, B;\n" + 
+			"}\n" +
+			"public class Y {\n" +
+			"    void test(X x) {\n" +
+			"        switch (x) {\n" +
+			"			case A: System.out.println(\"A\");\n" +
+			"           //$FALL-THROUGH$\n" +
+			"           //$CASES-OMITTED$\n" +
+			" 			default : System.out.println(\"unknown\"); break;\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+		},
+		"",
+		null, // classlibs
+		true, // flush
+		null, // vmArgs
+		options,
+		null /*requestor*/);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=374605
+public void test187a() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_MISSING_ENUM_CASE_DESPITE_DEFAULT, JavaCore.ENABLED);
+	this.runNegativeTest(
+		new String[] {
+			"Y.java",
+			"enum X {\n" + 
+			"  A, B;\n" + 
+			"}\n" +
+			"public class Y {\n" +
+			"    void test(X x) {\n" +
+			"        switch (x) {\n" +
+			"			case A: System.out.println(\"A\"); break;\n" +
+			"           //$CASES-OMITTED$\n" + // not strong enough to suppress the warning if default: is missing
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+		},
+		"----------\n" + 
+		"1. WARNING in Y.java (at line 6)\n" + 
+		"	switch (x) {\n" + 
+		"	        ^\n" + 
+		"The enum constant B needs a corresponding case label in this enum switch on X\n" + 
+		"----------\n",
+		null, // classlibs
+		true, // flush
+		options);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=374605
+public void test187b() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE, JavaCore.ERROR);
+	options.put(JavaCore.COMPILER_PB_SUPPRESS_OPTIONAL_ERRORS, JavaCore.ENABLED);
+	this.runConformTest(
+		new String[] {
+			"Y.java",
+			"enum X {\n" + 
+			"  A, B;\n" + 
+			"}\n" +
+			"public class Y {\n" +
+			"    @SuppressWarnings(\"incomplete-switch\")\n" +
+			"    void test(X x) {\n" +
+			"        switch (x) {\n" +
+			"			case A: System.out.println(\"A\"); break;\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+		},
+		"",
+		null, // classlibs
+		true, // flush
+		null, // vmArgs
+		options,
+		null /*requestor*/);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=374605
+public void test188() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE, JavaCore.WARNING);
+	this.runNegativeTest(
+		new String[] {
+			"Y.java",
+			"enum X {\n" + 
+			"  A, B;\n" + 
+			"}\n" +
+			"public class Y {\n" +
+			"    void test(X x) {\n" +
+			"        switch (x) {\n" +
+			"			case A: System.out.println(\"A\"); break;\n" +
+			"			case B: System.out.println(\"B\"); break;\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+		},
+		"----------\n" + 
+		"1. WARNING in Y.java (at line 6)\n" + 
+		"	switch (x) {\n" + 
+		"	        ^\n" + 
+		"The switch over the enum type X should have a default case\n" + 
+		"----------\n",
+		null, // classlibs
+		true, // flush
+		options);
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=374605
+public void test189() {
+	Map options = getCompilerOptions();
+	//options.put(JavaCore.COMPILER_PB_MISSING_DEFAULT_CASE, JavaCore.WARNING);
+	this.runNegativeTest(
+		new String[] {
+			"Y.java",
+			"enum X {\n" + 
+			"  A, B;\n" + 
+			"}\n" +
+			"public class Y {\n" +
+			"    int test(X x) {\n" +
+			"        switch (x) {\n" +
+			"			case A: return 1;\n" +
+			"			case B: return 2;\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+		},
+		"----------\n" + 
+		"1. ERROR in Y.java (at line 5)\n" + 
+		"	int test(X x) {\n" + 
+		"	    ^^^^^^^^^\n" + 
+		"This method must return a result of type int. Note that a problem regarding missing 'default:' on 'switch' has been suppressed, which is perhaps related to this problem\n" + 
+		"----------\n",
+		null, // classlibs
+		true, // flush
+		options);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StaticImportTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StaticImportTest.java
index 1200657..a2d81a4 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StaticImportTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/StaticImportTest.java
@@ -1802,12 +1802,7 @@ public class StaticImportTest extends AbstractComparableTest {
 			"	              ^^^^^^^^^^^^^^^^^^^^\n" +
 			"The import sample.X.TestEnum.V2 is never used\n" +
 			"----------\n" +
-			"3. WARNING in sample\\X.java (at line 12)\n" +
-			"	switch (value) {\n" +
-			"	        ^^^^^\n" +
-			"The switch on the enum type X.TestEnum should have a default case\n" +
-			"----------\n" +
-			"4. ERROR in sample\\X.java (at line 22)\n" +
+			"3. ERROR in sample\\X.java (at line 22)\n" +
 			"	i++;\n" +
 			"	^\n" +
 			"The local variable i may not have been initialized\n" +
@@ -1848,13 +1843,8 @@ public class StaticImportTest extends AbstractComparableTest {
 			"	import static sample.X.TestEnum.*;\n" +
 			"	              ^^^^^^^^^^^^^^^^^\n" +
 			"The import sample.X.TestEnum is never used\n" +
-			"----------\n" + 
-			"2. WARNING in sample\\X.java (at line 11)\n" + 
-			"	switch (value) {\n" + 
-			"	        ^^^^^\n" + 
-			"The switch on the enum type X.TestEnum should have a default case\n" + 
 			"----------\n" +
-			"3. ERROR in sample\\X.java (at line 21)\n" +
+			"2. ERROR in sample\\X.java (at line 21)\n" +
 			"	i++;\n" +
 			"	^\n" +
 			"The local variable i may not have been initialized\n" +
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
index f45096e..212d3d3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/SwitchTest.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -15,6 +16,7 @@ import java.util.Map;
 
 import junit.framework.Test;
 
+import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.ToolFactory;
 import org.eclipse.jdt.core.tests.util.Util;
 import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
@@ -1028,17 +1030,12 @@ public void testCaseTypeMismatch3() {
 		"	     ^^^\n" + 
 		"Type mismatch: cannot convert from String to int\n" + 
 		"----------\n" + 
-		"2. WARNING in X.java (at line 9)\n" + 
-		"	switch(Days.Sunday) {\n" + 
-		"	       ^^^^^^^^^^^\n" + 
-		"The switch on the enum type Days should have a default case\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 10)\n" + 
+		"2. ERROR in X.java (at line 10)\n" + 
 		"	case \"Sunday\": break;\n" + 
 		"	     ^^^^^^^^\n" + 
 		"Type mismatch: cannot convert from String to Days\n" + 
 		"----------\n" + 
-		"4. ERROR in X.java (at line 13)\n" + 
+		"3. ERROR in X.java (at line 13)\n" + 
 		"	case \"0\": break;\n" + 
 		"	     ^^^\n" + 
 		"Type mismatch: cannot convert from String to Integer\n" + 
@@ -2138,6 +2135,35 @@ public void testFor356002_3() {
 		this.runConformTest(sourceFiles, "DONE");
 	}
 }
+public void testBug374605() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE, JavaCore.WARNING);
+	this.runNegativeTest(
+			new String[] {
+				"p/X.java",
+				"package p;\n" +
+				"class X {\n" +
+				"  void v(int i) {\n" +
+				"    switch (i) {\n" +
+				"      case 1 :\n" +
+				"        break;\n" +
+				"      case 2 :\n" +
+				"        break;\n" +
+				"    }\n" +
+				"  }\n" +
+				"}",
+			},
+			"----------\n" +
+			"1. WARNING in p\\X.java (at line 4)\n" +
+			"	switch (i) {\n" +
+			"	        ^\n" +
+			"The switch over the type int should have a default case\n" +
+			"----------\n",
+			null,
+			true,
+			options
+		);	
+}
 public static Class testClass() {
 	return SwitchTest.class;
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
index 9b73eb2..48b71d8 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
@@ -4767,7 +4767,6 @@ public class ASTConverter15JLS4Test extends ConverterTestSetup {
     		"	RED, GREEN(), BLUE(17);\n" +
     		"	X() {}\n" +
     		"	X(int i) {}\n" +
-    		"   @SuppressWarnings(\"incomplete-switch\")\n" +
     		"	public static void main(String[] args) {\n" +
     		"		for (X x : X.values()) {\n" +
     		"			switch(x) {\n" +
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
index dac0e8d..e67367d 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
@@ -4770,7 +4770,6 @@ public class ASTConverter15Test extends ConverterTestSetup {
     		"	RED, GREEN(), BLUE(17);\n" +
     		"	X() {}\n" +
     		"	X(int i) {}\n" +
-    		"   @SuppressWarnings(\"incomplete-switch\")\n" +
     		"	public static void main(String[] args) {\n" +
     		"		for (X x : X.values()) {\n" +
     		"			switch(x) {\n" +
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CodeCorrectionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CodeCorrectionTests.java
index 62da35b..972f591 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CodeCorrectionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CodeCorrectionTests.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
@@ -804,7 +805,9 @@ public void testWarningTokens() {
 	assertEquals("wrong token", "hiding", CorrectionEngine.getWarningToken(IProblem.TypeParameterHidingType));
 	assertEquals("wrong token", "nls", CorrectionEngine.getWarningToken(IProblem.NonExternalizedStringLiteral));
 	assertEquals("wrong token", "incomplete-switch", CorrectionEngine.getWarningToken(IProblem.MissingEnumConstantCase));
+	assertEquals("wrong token", "incomplete-switch", CorrectionEngine.getWarningToken(IProblem.MissingEnumConstantCaseDespiteDefault));
 	assertEquals("wrong token", "incomplete-switch", CorrectionEngine.getWarningToken(IProblem.MissingEnumDefaultCase));
+	assertEquals("wrong token", "incomplete-switch", CorrectionEngine.getWarningToken(IProblem.MissingDefaultCase));
 	assertEquals("wrong token", "unused", CorrectionEngine.getWarningToken(IProblem.UnusedImport));
 	assertEquals("wrong token", "unused", CorrectionEngine.getWarningToken(IProblem.LocalVariableIsNeverUsed));
 	assertEquals("wrong token", "unused", CorrectionEngine.getWarningToken(IProblem.ArgumentIsNeverUsed));
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index 7562d38..8fb5ce1 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -15,6 +15,7 @@
  *     							bug 295551 - Add option to automatically promote all warnings to errors
  *     							bug 359721 - [options] add command line option for new warning token "resource"
  *								bug 365208 - [compiler][batch] command line options for annotation based null analysis
+ *								bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.batch;
 
@@ -3369,10 +3370,26 @@ private void handleErrorOrWarningToken(String token, boolean isEnabling, int sev
 			}
 			break;
 		case 'e' :
-			if (token.equals("enumSwitch") //$NON-NLS-1$
-					|| token.equals("incomplete-switch")) { //$NON-NLS-1$
+			if (token.equals("enumSwitch")) { //$NON-NLS-1$
 				setSeverity(CompilerOptions.OPTION_ReportIncompleteEnumSwitch, severity, isEnabling);
 				return;
+			} else if (token.equals("enumSwitchPedantic")) { //$NON-NLS-1$
+				if (isEnabling) {
+					switch (severity) {
+						case ProblemSeverities.Error:
+							setSeverity(CompilerOptions.OPTION_ReportIncompleteEnumSwitch, severity, isEnabling);
+							break;
+						case ProblemSeverities.Warning:
+							if (CompilerOptions.IGNORE.equals(this.options.get(CompilerOptions.OPTION_ReportIncompleteEnumSwitch))) {
+								setSeverity(CompilerOptions.OPTION_ReportIncompleteEnumSwitch, severity, isEnabling);
+							}
+							break;
+						default: // no severity update
+					}
+				}
+				this.options.put(CompilerOptions.OPTION_ReportMissingEnumCaseDespiteDefault, 
+								 isEnabling ? CompilerOptions.ENABLED : CompilerOptions.DISABLED);
+				return;
 			} else if (token.equals("emptyBlock")) {//$NON-NLS-1$
 				setSeverity(CompilerOptions.OPTION_ReportUndocumentedEmptyBlock, severity, isEnabling);
 				return;
@@ -3590,6 +3607,9 @@ private void handleErrorOrWarningToken(String token, boolean isEnabling, int sev
 			} else if (token.equals("static-method")) { //$NON-NLS-1$
 				setSeverity(CompilerOptions.OPTION_ReportMethodCanBeStatic, severity, isEnabling);
 				return;
+			} else if (token.equals("switchDefault")) { //$NON-NLS-1$
+				setSeverity(CompilerOptions.OPTION_ReportMissingDefaultCase, severity, isEnabling);
+				return;
 			}
 			break;
 		case 't' :
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index 11fc1ed..b55260b 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -13,6 +13,7 @@
 #								bug 295551 - Add option to automatically promote all warnings to errors
 #								bug 359721 - [options] add command line option for new warning token "resource"
 #								bug 365208 - [compiler][batch] command line options for annotation based null analysis
+#								bug 374605 - Unreasonable warning for enum-based switch statements
 ###############################################################################
 ### JavaBatchCompiler messages.
 
@@ -298,6 +299,8 @@ misc.usage.warn = {1} {2}\n\
 \      emptyBlock           undocumented empty block\n\
 \      enumIdentifier       ''enum'' used as identifier\n\
 \      enumSwitch           incomplete enum switch\n\
+\      enumSwitchPedantic + report missing enum switch cases even\n\
+\                           in the presence of a default case\n\
 \      fallthrough          possible fall-through case\n\
 \      fieldHiding          field hiding another variable\n\
 \      finalBound           type parameter with final bound\n\
@@ -337,6 +340,7 @@ misc.usage.warn = {1} {2}\n\
 \      suppress           + enable @SuppressWarnings\n\
 \                           When used with -err:, it can also silent optional\n\
 \                           errors and warnings\n\
+\      switchDefault      + switch statement lacking a default case\n\
 \      syncOverride         missing synchronized in synchr. method override\n\
 \      syntheticAccess      synthetic access for innerclass\n\
 \      tasks(<tags separated by |>) tasks identified by tags inside comments\n\
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index b59b281..ea7e82f 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -52,7 +52,9 @@ Eclipse SDK 3.8.0 - %date% - April 10, 2012
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=372694">372694</a>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=374605">374605</a>
+Unreasonable warning for enum-based switch statements
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=372694">372694</a>
 Adjust parser generator tools
 
 <a name="v_C45"></a>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 7a29115..46093f9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -144,6 +144,11 @@
  *									RedundantNullCheckOnSpecdNonNullLocalVariable
  *									SpecdNonNullLocalVariableComparisonYieldsFalse
  *									RequiredNonNullButProvidedSpecdNullable
+ *									MissingDefaultCase
+ *									MissingEnumConstantCaseDespiteDefault
+ *									UninitializedLocalVariableHintMissingDefault
+ *									UninitializedBlankFinalFieldHintMissingDefault
+ *									ShouldReturnValueHintMissingDefault
  *******************************************************************************/
 package org.eclipse.jdt.core.compiler;
 
@@ -1348,6 +1353,16 @@ void setSourceStart(int sourceStart);
 	int AbstractMethodInEnum = MethodRelated + 765;
 	/** @since 3.8 */
 	int MissingEnumDefaultCase = Internal + 766;
+	/** @since 3.8 */
+	int MissingDefaultCase = Internal + 767;
+	/** @since 3.8 */
+	int MissingEnumConstantCaseDespiteDefault = FieldRelated + 768;
+	/** @since 3.8 */
+	int UninitializedLocalVariableHintMissingDefault = Internal + 769;
+	/** @since 3.8 */
+	int UninitializedBlankFinalFieldHintMissingDefault = FieldRelated + 770;
+	/** @since 3.8 */
+	int ShouldReturnValueHintMissingDefault = MethodRelated + 771;
 
 	/**
 	 * Var args
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index 5aae1c7..bd74fc7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -13,6 +13,7 @@
  *     							bug 185682 - Increment/decrement operators mark local variables as read
  *     							bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 365519 - editorial cleanup after bug 186342 and bug 365387
+ *								bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -133,6 +134,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	public static final int IsReachable = Bit32;
 	public static final int LabelUsed = Bit7;
 	public static final int DocumentedFallthrough = Bit30; // switch statement
+	public static final int DocumentedCasesOmitted = Bit31; // switch statement
 
 	// local decls
 	public static final int IsLocalDeclarationReachable = Bit31;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
index 576e200..0a2f27e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
@@ -11,6 +11,7 @@
  *     							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *								bug 265744 - Enum switch should warn about missing default
+ *								bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -451,6 +452,7 @@ public class SwitchStatement extends Statement {
 			boolean isEnumSwitch = false;
 			boolean isStringSwitch = false;
 			TypeBinding expressionType = this.expression.resolveType(upperScope);
+			CompilerOptions compilerOptions = upperScope.compilerOptions();
 			if (expressionType != null) {
 				this.expression.computeConversion(upperScope, expressionType, expressionType);
 				checkType: {
@@ -464,14 +466,14 @@ public class SwitchStatement extends Statement {
 							break checkType;
 					} else if (expressionType.isEnum()) {
 						isEnumSwitch = true;
-						if (upperScope.compilerOptions().complianceLevel < ClassFileConstants.JDK1_5) {
+						if (compilerOptions.complianceLevel < ClassFileConstants.JDK1_5) {
 							upperScope.problemReporter().incorrectSwitchType(this.expression, expressionType); // https://bugs.eclipse.org/bugs/show_bug.cgi?id=360317
 						}
 						break checkType;
 					} else if (upperScope.isBoxingCompatibleWith(expressionType, TypeBinding.INT)) {
 						this.expression.computeConversion(upperScope, TypeBinding.INT, expressionType);
 						break checkType;
-					} else if (upperScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_7 && expressionType.id == TypeIds.T_JavaLangString) {
+					} else if (compilerOptions.complianceLevel >= ClassFileConstants.JDK1_7 && expressionType.id == TypeIds.T_JavaLangString) {
 						isStringSwitch = true;
 						break checkType;
 					}
@@ -536,28 +538,37 @@ public class SwitchStatement extends Statement {
 					upperScope.problemReporter().undocumentedEmptyBlock(this.blockStart, this.sourceEnd);
 				}
 			}
-			// for enum switch, check if all constants are accounted for (if no default)
-			if (isEnumSwitch && this.defaultCase == null
-					&& upperScope.compilerOptions().getSeverity(CompilerOptions.IncompleteEnumSwitch) != ProblemSeverities.Ignore) {
-				// JLS recommends a default case for every enum switch
-				if (upperScope.compilerOptions().complianceLevel >= ClassFileConstants.JDK1_5) { // report only if enum is legal in the first place
-					upperScope.problemReporter().missingEnumDefaultCase(this, expressionType);
+			// check default case for all kinds of switch:
+			if (this.defaultCase == null) {
+				if (compilerOptions.getSeverity(CompilerOptions.MissingDefaultCase) == ProblemSeverities.Ignore) {
+					if (isEnumSwitch) {
+						upperScope.methodScope().hasMissingSwitchDefault = true;
+					}
+				} else {
+					upperScope.problemReporter().missingDefaultCase(this, isEnumSwitch, expressionType);
 				}
-
-				int constantCount = this.constants == null ? 0 : this.constants.length; // could be null if no case statement
-				if (constantCount == this.caseCount
-						&& this.caseCount != ((ReferenceBinding)expressionType).enumConstantCount()) {
-					FieldBinding[] enumFields = ((ReferenceBinding)expressionType.erasure()).fields();
-					for (int i = 0, max = enumFields.length; i <max; i++) {
-						FieldBinding enumConstant = enumFields[i];
-						if ((enumConstant.modifiers & ClassFileConstants.AccEnum) == 0) continue;
-						findConstant : {
-							for (int j = 0; j < this.caseCount; j++) {
-								if ((enumConstant.id + 1) == this.constants[j]) // zero should not be returned see bug 141810
-									break findConstant;
+			}
+			// for enum switch, check if all constants are accounted for (perhaps depending on existence of a default case)
+			if (isEnumSwitch && compilerOptions.complianceLevel >= ClassFileConstants.JDK1_5) {
+				if (this.defaultCase == null || compilerOptions.reportMissingEnumCaseDespiteDefault) {
+					int constantCount = this.constants == null ? 0 : this.constants.length; // could be null if no case statement
+					if (constantCount == this.caseCount
+							&& this.caseCount != ((ReferenceBinding)expressionType).enumConstantCount()) {
+						FieldBinding[] enumFields = ((ReferenceBinding)expressionType.erasure()).fields();
+						for (int i = 0, max = enumFields.length; i <max; i++) {
+							FieldBinding enumConstant = enumFields[i];
+							if ((enumConstant.modifiers & ClassFileConstants.AccEnum) == 0) continue;
+							findConstant : {
+								for (int j = 0; j < this.caseCount; j++) {
+									if ((enumConstant.id + 1) == this.constants[j]) // zero should not be returned see bug 141810
+										break findConstant;
+								}
+								// enum constant did not get referenced from switch
+								boolean suppress = (this.defaultCase != null && (this.defaultCase.bits & DocumentedCasesOmitted) != 0);
+								if (!suppress) {
+									upperScope.problemReporter().missingEnumConstantCase(this, enumConstant);
+								}
 							}
-							// enum constant did not get referenced from switch
-							upperScope.problemReporter().missingEnumConstantCase(this, enumConstant);
 						}
 					}
 				}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 4ab00b7..1a2b75f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -15,6 +15,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *								bug 366063 - Compiler should not add synthetic @NonNull annotations
+ *								bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.impl;
 
@@ -117,6 +118,8 @@ public class CompilerOptions {
 	public static final String OPTION_ReportMissingOverrideAnnotationForInterfaceMethodImplementation = "org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation"; //$NON-NLS-1$
 	public static final String OPTION_ReportMissingDeprecatedAnnotation = "org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation"; //$NON-NLS-1$
 	public static final String OPTION_ReportIncompleteEnumSwitch = "org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch"; //$NON-NLS-1$
+	public static final String OPTION_ReportMissingEnumCaseDespiteDefault = "org.eclipse.jdt.core.compiler.problem.missingEnumCaseDespiteDefault"; //$NON-NLS-1$
+	public static final String OPTION_ReportMissingDefaultCase = "org.eclipse.jdt.core.compiler.problem.missingDefaultCase"; //$NON-NLS-1$
 	public static final String OPTION_ReportForbiddenReference =  "org.eclipse.jdt.core.compiler.problem.forbiddenReference"; //$NON-NLS-1$
 	public static final String OPTION_ReportDiscouragedReference =  "org.eclipse.jdt.core.compiler.problem.discouragedReference"; //$NON-NLS-1$
 	public static final String OPTION_SuppressWarnings =  "org.eclipse.jdt.core.compiler.problem.suppressWarnings"; //$NON-NLS-1$
@@ -235,7 +238,7 @@ public class CompilerOptions {
 	public static final int AnnotationSuperInterface = IrritantSet.GROUP1 | ASTNode.Bit10;
 	public static final int TypeHiding = IrritantSet.GROUP1 | ASTNode.Bit11;
 	public static final int MissingOverrideAnnotation = IrritantSet.GROUP1 | ASTNode.Bit12;
-	public static final int IncompleteEnumSwitch = IrritantSet.GROUP1 | ASTNode.Bit13;
+	public static final int MissingEnumConstantCase = IrritantSet.GROUP1 | ASTNode.Bit13;
 	public static final int MissingDeprecatedAnnotation = IrritantSet.GROUP1 | ASTNode.Bit14;
 	public static final int DiscouragedReference = IrritantSet.GROUP1 | ASTNode.Bit15;
 	public static final int UnhandledWarningToken = IrritantSet.GROUP1 | ASTNode.Bit16;
@@ -269,6 +272,7 @@ public class CompilerOptions {
 	public static final int NullUncheckedConversion = IrritantSet.GROUP2 | ASTNode.Bit13;
 	public static final int RedundantNullAnnotation = IrritantSet.GROUP2 | ASTNode.Bit14;
 	public static final int MissingNonNullByDefaultAnnotation = IrritantSet.GROUP2 | ASTNode.Bit15;
+	public static final int MissingDefaultCase = IrritantSet.GROUP2 | ASTNode.Bit16;
 
 	// Severity level for handlers
 	/** 
@@ -408,6 +412,8 @@ public class CompilerOptions {
 	public long intendedDefaultNonNullness; // 0 or TagBits#AnnotationNonNull
 	/** Should resources (objects of type Closeable) be analysed for matching calls to close()? */
 	public boolean analyseResourceLeaks;
+	/** Should missing enum cases be reported even if a default case exists in the same switch? */
+	public boolean reportMissingEnumCaseDespiteDefault;
 
 	// keep in sync with warningTokenToIrritant and warningTokenFromIrritant
 	public final static String[] warningTokens = {
@@ -558,8 +564,10 @@ public class CompilerOptions {
 				return OPTION_ReportTypeParameterHiding;
 			case MissingOverrideAnnotation :
 				return OPTION_ReportMissingOverrideAnnotation;
-			case IncompleteEnumSwitch :
+			case MissingEnumConstantCase :
 				return OPTION_ReportIncompleteEnumSwitch;
+			case MissingDefaultCase :
+				return OPTION_ReportMissingDefaultCase;
 			case MissingDeprecatedAnnotation :
 				return OPTION_ReportMissingDeprecatedAnnotation;
 			case DiscouragedReference :
@@ -713,7 +721,9 @@ public class CompilerOptions {
 			OPTION_ReportForbiddenReference,
 			OPTION_ReportHiddenCatchBlock,
 			OPTION_ReportIncompatibleNonInheritedInterfaceMethod,
+			OPTION_ReportMissingDefaultCase,
 			OPTION_ReportIncompleteEnumSwitch,
+			OPTION_ReportMissingEnumCaseDespiteDefault,
 			OPTION_ReportIndirectStaticAccess,
 			OPTION_ReportInvalidJavadoc,
 			OPTION_ReportInvalidJavadocTags,
@@ -829,7 +839,8 @@ public class CompilerOptions {
 				return "boxing"; //$NON-NLS-1$
 			case TypeHiding :
 				return "hiding"; //$NON-NLS-1$
-			case IncompleteEnumSwitch :
+			case MissingEnumConstantCase :
+			case MissingDefaultCase :
 				return "incomplete-switch"; //$NON-NLS-1$
 			case MissingDeprecatedAnnotation :
 				return "dep-ann"; //$NON-NLS-1$
@@ -998,7 +1009,9 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportUnnecessaryElse, getSeverityString(UnnecessaryElse));
 		optionsMap.put(OPTION_ReportAutoboxing, getSeverityString(AutoBoxing));
 		optionsMap.put(OPTION_ReportAnnotationSuperInterface, getSeverityString(AnnotationSuperInterface));
-		optionsMap.put(OPTION_ReportIncompleteEnumSwitch, getSeverityString(IncompleteEnumSwitch));
+		optionsMap.put(OPTION_ReportIncompleteEnumSwitch, getSeverityString(MissingEnumConstantCase));
+		optionsMap.put(OPTION_ReportMissingEnumCaseDespiteDefault, this.reportMissingEnumCaseDespiteDefault ? ENABLED : DISABLED);
+		optionsMap.put(OPTION_ReportMissingDefaultCase, getSeverityString(MissingDefaultCase));
 		optionsMap.put(OPTION_ReportInvalidJavadoc, getSeverityString(InvalidJavadoc));
 		optionsMap.put(OPTION_ReportInvalidJavadocTagsVisibility, getVisibilityString(this.reportInvalidJavadocTagsVisibility));
 		optionsMap.put(OPTION_ReportInvalidJavadocTags, this.reportInvalidJavadocTags ? ENABLED : DISABLED);
@@ -1029,7 +1042,6 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportMissingOverrideAnnotation, getSeverityString(MissingOverrideAnnotation));
 		optionsMap.put(OPTION_ReportMissingOverrideAnnotationForInterfaceMethodImplementation, this.reportMissingOverrideAnnotationForInterfaceMethodImplementation ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportMissingDeprecatedAnnotation, getSeverityString(MissingDeprecatedAnnotation));
-		optionsMap.put(OPTION_ReportIncompleteEnumSwitch, getSeverityString(IncompleteEnumSwitch));
 		optionsMap.put(OPTION_ReportUnusedLabel, getSeverityString(UnusedLabel));
 		optionsMap.put(OPTION_ReportUnusedTypeArgumentsForMethodInvocation, getSeverityString(UnusedTypeArguments));
 		optionsMap.put(OPTION_Compliance, versionFromJdkLevel(this.complianceLevel));
@@ -1244,6 +1256,8 @@ public class CompilerOptions {
 		this.intendedDefaultNonNullness = 0;
 		
 		this.analyseResourceLeaks = true;
+
+		this.reportMissingEnumCaseDespiteDefault = false;
 	}
 
 	public void set(Map optionsMap) {
@@ -1506,7 +1520,15 @@ public class CompilerOptions {
 		if ((optionValue = optionsMap.get(OPTION_ReportAnnotationSuperInterface)) != null) updateSeverity(AnnotationSuperInterface, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportMissingOverrideAnnotation)) != null) updateSeverity(MissingOverrideAnnotation, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportMissingDeprecatedAnnotation)) != null) updateSeverity(MissingDeprecatedAnnotation, optionValue);
-		if ((optionValue = optionsMap.get(OPTION_ReportIncompleteEnumSwitch)) != null) updateSeverity(IncompleteEnumSwitch, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportIncompleteEnumSwitch)) != null) updateSeverity(MissingEnumConstantCase, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportMissingEnumCaseDespiteDefault)) != null) {
+			if (ENABLED.equals(optionValue)) {
+				this.reportMissingEnumCaseDespiteDefault = true;
+			} else if (DISABLED.equals(optionValue)) {
+				this.reportMissingEnumCaseDespiteDefault = false;
+			}
+		}
+		if ((optionValue = optionsMap.get(OPTION_ReportMissingDefaultCase)) != null) updateSeverity(MissingDefaultCase, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportUnhandledWarningToken)) != null) updateSeverity(UnhandledWarningToken, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportUnusedWarningToken)) != null) updateSeverity(UnusedWarningToken, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportUnusedLabel)) != null) updateSeverity(UnusedLabel, optionValue);
@@ -1754,7 +1776,7 @@ public class CompilerOptions {
 		buf.append("\n\t- missing @Override annotation: ").append(getSeverityString(MissingOverrideAnnotation)); //$NON-NLS-1$
 		buf.append("\n\t- missing @Override annotation for interface method implementation: ").append(this.reportMissingOverrideAnnotationForInterfaceMethodImplementation ? ENABLED : DISABLED); //$NON-NLS-1$
 		buf.append("\n\t- missing @Deprecated annotation: ").append(getSeverityString(MissingDeprecatedAnnotation)); //$NON-NLS-1$
-		buf.append("\n\t- incomplete enum switch: ").append(getSeverityString(IncompleteEnumSwitch)); //$NON-NLS-1$
+		buf.append("\n\t- incomplete enum switch: ").append(getSeverityString(MissingEnumConstantCase)); //$NON-NLS-1$
 		buf.append("\n\t- raise null related warnings for variables tainted in assert statements: ").append(this.includeNullInfoFromAsserts ? ENABLED : DISABLED); //$NON-NLS-1$
 		buf.append("\n\t- suppress warnings: ").append(this.suppressWarnings ? ENABLED : DISABLED); //$NON-NLS-1$
 		buf.append("\n\t- suppress optional errors: ").append(this.suppressOptionalErrors ? ENABLED : DISABLED); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index 6a1aa76..38f3cc0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -12,6 +12,7 @@
  *								bug 186342 - [compiler][null] Using annotations for null checking
  *								bug 370639 - [compiler][resource] restore the default for resource leak warnings
  *								bug 265744 - Enum switch should warn about missing default
+ *								bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.impl;
@@ -49,7 +50,7 @@ public class IrritantSet {
 	public static final IrritantSet FALLTHROUGH = new IrritantSet(CompilerOptions.FallthroughCase);
 	public static final IrritantSet FINALLY = new IrritantSet(CompilerOptions.FinallyBlockNotCompleting);
 	public static final IrritantSet HIDING = new IrritantSet(CompilerOptions.MaskedCatchBlock);
-	public static final IrritantSet INCOMPLETE_SWITCH = new IrritantSet(CompilerOptions.IncompleteEnumSwitch);
+	public static final IrritantSet INCOMPLETE_SWITCH = new IrritantSet(CompilerOptions.MissingEnumConstantCase);
 	public static final IrritantSet NLS = new IrritantSet(CompilerOptions.NonExternalizedString);
 	public static final IrritantSet NULL = new IrritantSet(CompilerOptions.NullReference);
 	public static final IrritantSet RAW = new IrritantSet(CompilerOptions.RawTypeReference);
@@ -103,7 +104,7 @@ public class IrritantSet {
 				| CompilerOptions.UnusedTypeArguments
 				| CompilerOptions.UnusedWarningToken
 				| CompilerOptions.ComparingIdentical
-				| CompilerOptions.IncompleteEnumSwitch)
+				| CompilerOptions.MissingEnumConstantCase)
 			// group-2 warnings enabled by default
 			.set(
 				CompilerOptions.DeadCode
@@ -147,6 +148,7 @@ public class IrritantSet {
 		RESOURCE
 			.set(CompilerOptions.PotentiallyUnclosedCloseable)
 			.set(CompilerOptions.ExplicitlyClosedAutoCloseable);
+		INCOMPLETE_SWITCH.set(CompilerOptions.MissingDefaultCase);
 		String suppressRawWhenUnchecked = System.getProperty("suppressRawWhenUnchecked"); //$NON-NLS-1$
 		if (suppressRawWhenUnchecked != null && "true".equalsIgnoreCase(suppressRawWhenUnchecked)) { //$NON-NLS-1$
 			UNCHECKED.set(CompilerOptions.RawTypeReference);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
index bfb4f2b..22b5da1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 349326 - [1.7] new warning for missing try-with-resources
+ *     Stephan Herrmann - Contributions for
+ *								bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -50,6 +52,9 @@ public class MethodScope extends BlockScope {
 	// inner-emulation
 	public SyntheticArgumentBinding[] extraSyntheticArguments;
 
+	// remember suppressed warning re missing 'default:' to give hints on possibly related flow problems
+	public boolean hasMissingSwitchDefault; // TODO(stephan): combine flags to a bitset?
+
 public MethodScope(ClassScope parent, ReferenceContext context, boolean isStatic) {
 	super(METHOD_SCOPE, parent);
 	this.locals = new LocalVariableBinding[5];
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index 732a6fd..a39c850 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -8,7 +8,9 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Tom Tromey - patch for readTable(String) as described in http://bugs.eclipse.org/bugs/show_bug.cgi?id=32196
- *     Stephan Herrmann - Contribution for Bug 366003 - CCE in ASTNode.resolveAnnotations(ASTNode.java:639)
+ *     Stephan Herrmann - Contributions for 
+ *								bug 366003 - CCE in ASTNode.resolveAnnotations(ASTNode.java:639)
+ *								bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.parser;
 
@@ -47,6 +49,7 @@ public class Parser implements  ParserBasicInformation, TerminalTokens, Operator
 	protected static final int THIS_CALL = ExplicitConstructorCall.This;
 	protected static final int SUPER_CALL = ExplicitConstructorCall.Super;
 	public static final char[] FALL_THROUGH_TAG = "$FALL-THROUGH$".toCharArray(); //$NON-NLS-1$
+	public static final char[] CASES_OMITTED_TAG = "$CASES-OMITTED$".toCharArray(); //$NON-NLS-1$
 	
 	public static char asb[] = null;
 	public static char asr[] = null;
@@ -2846,10 +2849,13 @@ protected void consumeCreateInitializer() {
 protected void consumeDefaultLabel() {
 	// SwitchLabel ::= 'default' ':'
 	CaseStatement defaultStatement = new CaseStatement(null, this.intStack[this.intPtr--], this.intStack[this.intPtr--]);
-	// Look for $fall-through$ tag in leading comment for case statement
+	// Look for $fall-through$ and $CASES-OMITTED$ tags in leading comment for case statement
 	if (hasLeadingTagComment(FALL_THROUGH_TAG, defaultStatement.sourceStart)) {
 		defaultStatement.bits |= ASTNode.DocumentedFallthrough;
-	}	
+	}
+	if (hasLeadingTagComment(CASES_OMITTED_TAG, defaultStatement.sourceStart)) {
+		defaultStatement.bits |= ASTNode.DocumentedCasesOmitted;
+	}
 	pushOnAstStack(defaultStatement);
 }
 protected void consumeDefaultModifiers() {
@@ -9189,8 +9195,14 @@ public boolean hasLeadingTagComment(char[] commentPrefixTag, int rangeEnd) {
 			}
 		}
 		for (int iTag = 0, length = commentPrefixTag.length; iTag < length; iTag++, charPos++) {
-			if (charPos >= rangeEnd) return false; // comment is too small to host tag
-			if (source[charPos] != commentPrefixTag[iTag]) return false;
+			if (charPos >= rangeEnd // comment is too small to host tag
+					|| source[charPos] != commentPrefixTag[iTag]) {
+				if (iTag == 0) {
+					return false; // didn't even match leading '$' -> not a tag comment
+				} else {
+					continue previousComment; // accept as tag comment -> skip it and keep searching backwards
+				}
+			}
 		}
 		return true;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 6a2e7f7..334658b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -17,6 +17,7 @@
  *								bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
  *								bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
  *								bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
+ *								bug 374605 - Unreasonable warning for enum-based switch statements
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
@@ -99,6 +100,7 @@ import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
@@ -334,8 +336,12 @@ public static int getIrritant(int problemID) {
 			return CompilerOptions.AutoBoxing;
 
 		case IProblem.MissingEnumConstantCase :
+		case IProblem.MissingEnumConstantCaseDespiteDefault :	// this one is further protected by CompilerOptions.reportMissingEnumCaseDespiteDefault
+			return CompilerOptions.MissingEnumConstantCase;
+
+		case IProblem.MissingDefaultCase :
 		case IProblem.MissingEnumDefaultCase :
-			return CompilerOptions.IncompleteEnumSwitch;
+			return CompilerOptions.MissingDefaultCase;
 
 		case IProblem.AnnotationTypeUsedAsSuperInterface :
 			return CompilerOptions.AnnotationSuperInterface;
@@ -523,7 +529,8 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.NullReference :
 			case CompilerOptions.PotentialNullReference :
 			case CompilerOptions.RedundantNullCheck :
-			case CompilerOptions.IncompleteEnumSwitch :
+			case CompilerOptions.MissingEnumConstantCase :
+			case CompilerOptions.MissingDefaultCase :
 			case CompilerOptions.FallthroughCase :
 			case CompilerOptions.OverridingMethodWithoutSuperInvocation :
 			case CompilerOptions.ComparingIdentical :
@@ -5379,19 +5386,20 @@ public void missingDeprecatedAnnotationForType(TypeDeclaration type) {
 }
 public void missingEnumConstantCase(SwitchStatement switchStatement, FieldBinding enumConstant) {
 	this.handle(
-		IProblem.MissingEnumConstantCase,
+		switchStatement.defaultCase == null ? IProblem.MissingEnumConstantCase : IProblem.MissingEnumConstantCaseDespiteDefault,
 		new String[] {new String(enumConstant.declaringClass.readableName()), new String(enumConstant.name) },
 		new String[] {new String(enumConstant.declaringClass.shortReadableName()), new String(enumConstant.name) },
 		switchStatement.expression.sourceStart,
 		switchStatement.expression.sourceEnd);
 }
-public void missingEnumDefaultCase(SwitchStatement switchStatement, TypeBinding enumType) {
+public void missingDefaultCase(SwitchStatement switchStatement, boolean isEnumSwitch, TypeBinding expressionType) {
 	this.handle(
-		IProblem.MissingEnumDefaultCase,
-		new String[] {new String(enumType.readableName())},
-		new String[] {new String(enumType.shortReadableName())},
+		isEnumSwitch ? IProblem.MissingEnumDefaultCase : IProblem.MissingDefaultCase,
+		new String[] {new String(expressionType.readableName())},
+		new String[] {new String(expressionType.shortReadableName())},
 		switchStatement.expression.sourceStart,
 		switchStatement.expression.sourceEnd);
+
 }
 public void missingOverrideAnnotation(AbstractMethodDeclaration method) {
 	int severity = computeSeverity(IProblem.MissingOverrideAnnotation);
@@ -6655,7 +6663,7 @@ public void shouldImplementHashcode(SourceTypeBinding type) {
 }
 public void shouldReturn(TypeBinding returnType, ASTNode location) {
 	this.handle(
-		IProblem.ShouldReturnValue,
+		methodHasMissingSwitchDefault() ? IProblem.ShouldReturnValueHintMissingDefault : IProblem.ShouldReturnValue,
 		new String[] { new String (returnType.readableName())},
 		new String[] { new String (returnType.shortReadableName())},
 		location.sourceStart,
@@ -7182,7 +7190,7 @@ public void unhandledWarningToken(Expression token) {
 public void uninitializedBlankFinalField(FieldBinding field, ASTNode location) {
 	String[] arguments = new String[] {new String(field.readableName())};
 	this.handle(
-		IProblem.UninitializedBlankFinalField,
+		methodHasMissingSwitchDefault() ? IProblem.UninitializedBlankFinalFieldHintMissingDefault : IProblem.UninitializedBlankFinalField,
 		arguments,
 		arguments,
 		nodeSourceStart(field, location),
@@ -7192,12 +7200,21 @@ public void uninitializedLocalVariable(LocalVariableBinding binding, ASTNode loc
 	binding.tagBits |= TagBits.NotInitialized;
 	String[] arguments = new String[] {new String(binding.readableName())};
 	this.handle(
-		IProblem.UninitializedLocalVariable,
+		methodHasMissingSwitchDefault() ? IProblem.UninitializedLocalVariableHintMissingDefault : IProblem.UninitializedLocalVariable,
 		arguments,
 		arguments,
 		nodeSourceStart(binding, location),
 		nodeSourceEnd(binding, location));
 }
+private boolean methodHasMissingSwitchDefault() {
+	MethodScope methodScope = null;
+	if (this.referenceContext instanceof Block) {
+		methodScope = ((Block)this.referenceContext).scope.methodScope();
+	} else if (this.referenceContext instanceof AbstractMethodDeclaration) {
+		methodScope = ((AbstractMethodDeclaration)this.referenceContext).scope;
+	}
+	return methodScope != null && methodScope.hasMissingSwitchDefault;	
+}
 public void unmatchedBracket(int position, ReferenceContext context, CompilationResult compilationResult) {
 	this.handle(
 		IProblem.UnmatchedBracket,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index fd9a4ef..9e1f264 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -15,6 +15,7 @@
 #							bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
 #							bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
 #							bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
+#							bug 374605 - Unreasonable warning for enum-based switch statements
 ###############################################################################
 0 = {0}
 1 = super cannot be used in java.lang.Object
@@ -612,7 +613,12 @@
 763 = The enum constant {2} must implement the abstract method {0}({1})
 764 = The enum constant {0} cannot define abstract methods
 765 = The method {1} cannot be abstract in the enum constant {0}
-766 = The switch on the enum type {0} should have a default case
+766 = The switch over the enum type {0} should have a default case
+767 = The switch over the type {0} should have a default case
+768 = The enum constant {1} should have a corresponding case label in this enum switch on {0}. To suppress this problem, add a comment //$CASES-OMITTED$ on the line above the 'default:'
+769 = The local variable {0} may not have been initialized. Note that a problem regarding missing 'default:' on 'switch' has been suppressed, which is perhaps related to this problem
+770 = The blank final field {0} may not have been initialized. Note that a problem regarding missing 'default:' on 'switch' has been suppressed, which is perhaps related to this problem
+771 = This method must return a result of type {0}. Note that a problem regarding missing 'default:' on 'switch' has been suppressed, which is perhaps related to this problem
 
 ### VARARGS
 800 = Extended dimensions are illegal for a variable argument
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index dc65013..1af5510 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -93,6 +93,8 @@
  *     								COMPILER_PB_NULL_SPECIFICATION_VIOLATION
  *     								COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION
  *     								COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO
+ *									COMPILER_PB_MISSING_ENUM_CASE_DESPITE_DEFAULT
+ *									COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE
  *******************************************************************************/
 
 package org.eclipse.jdt.core;
@@ -1074,10 +1076,9 @@ public final class JavaCore extends Plugin {
 	public static final String COMPILER_PB_DEAD_CODE_IN_TRIVIAL_IF_STATEMENT = PLUGIN_ID + ".compiler.problem.deadCodeInTrivialIfStatement"; //$NON-NLS-1$
 	/**
 	 * Compiler option ID: Reporting Incomplete Enum Switch.
-	 * <p>When enabled, the compiler will issue an error or a warning whenever
-	 *    an enum switch statement lacks a default case.
-	 *    If no default case is given, additionally one error or warning is issued
-	 *    regarding each enum constant for which a corresponding case label is lacking.
+	 * <p>When enabled, the compiler will issue an error or a warning
+	 * 		regarding each enum constant for which a corresponding case label is lacking.
+	 * 		Reporting is further controlled by the option {@link #COMPILER_PB_MISSING_ENUM_CASE_DESPITE_DEFAULT}.
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
@@ -1088,6 +1089,37 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_PB_INCOMPLETE_ENUM_SWITCH = PLUGIN_ID + ".compiler.problem.incompleteEnumSwitch"; //$NON-NLS-1$
 	/**
+	 * Compiler option ID: Reporting Missing Enum Case In Switch Despite An Existing Default Case.
+	 * <p>This option further controls the option {@link #COMPILER_PB_INCOMPLETE_ENUM_SWITCH}:
+	 * 	<ul>
+	 * 	<li>If enabled the compiler will report problems about missing enum constants even if a default case exists
+	 * 		in the same switch statement.</li>
+	 *  <li>If disabled existence of a default case is considered as sufficient to make a switch statement complete.</li>
+	 *  </ul>
+	 *  This option has no effect if {@link #COMPILER_PB_INCOMPLETE_ENUM_SWITCH} is set to <code>"ignore"</code>.
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.missingEnumCaseDespiteDefault"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "enabled", "disabled" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * </dl>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_MISSING_ENUM_CASE_DESPITE_DEFAULT = PLUGIN_ID + ".compiler.problem.missingEnumCaseDespiteDefault"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Reporting Missing Default Case In Switch.
+	 * <p>When enabled, the compiler will issue an error or a warning 
+	 * 		against each switch statement that lacks a default case.
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.missingDefaultCase"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"ignore"</code></dd>
+	 * </dl>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_SWITCH_MISSING_DEFAULT_CASE = PLUGIN_ID + ".compiler.problem.missingDefaultCase"; //$NON-NLS-1$
+	/**
 	 * @since 3.1
 	 * @deprecated Use {@link #COMPILER_PB_NULL_REFERENCE} instead.
 	 * @category DeprecatedOptionID
