commit e638bcfa6ede2617a8de404af4af8024502bc348
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Oct 6 22:29:32 2013 +0200

    Bug 418235 - [compiler][null] Unreported nullness error when using
    generic
    - preparatory refactoring

2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
148	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
2	48	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
2	120	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 96db07e..b229b7b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -18,6 +18,7 @@
  *							bug 345305 - [compiler][null] Compiler misidentifies a case of "variable can only be null"
  *							bug 388996 - [compiler][resource] Incorrect 'potential resource leak'
  *							bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
+ *							Bug 418235 - [compiler][null] Unreported nullness error when using generic
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *							bug 378674 - "The method can be declared as static" is wrong
  *     Till Brychcy - Contributions for
@@ -440,7 +441,7 @@ public TypeBinding resolveType(BlockScope scope) {
  	}
 	final CompilerOptions compilerOptions = scope.compilerOptions();
 	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
-		new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations)
+		new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
 				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
 	}
 	return allocationType;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 7665234..1cbcd7d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -27,6 +27,7 @@
  *								bug 403086 - [compiler][null] include the effect of 'assert' in syntactic null analysis for fields
  *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *								Bug 405569 - Resource leak check false positive when using DbUtils.closeQuietly
+ *								Bug 418235 - [compiler][null] Unreported nullness error when using generic
  *     Jesper S Moller - Contributions for
  *								Bug 378674 - "The method can be declared as static" is wrong
  *******************************************************************************/
@@ -701,7 +702,7 @@ public TypeBinding resolveType(BlockScope scope) {
 
 	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
 		// not interested in reporting problems against this.binding:
-		new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations)
+		new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
 				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
 	}
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 1d2b012..e2fd358 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -18,6 +18,7 @@
  *								bug 395977 - [compiler][resource] Resource leak warning behavior possibly incorrect for anonymous inner class
  *								bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
  *								Bug 416267 - NPE in QualifiedAllocationExpression.resolveType
+ *								Bug 418235 - [compiler][null] Unreported nullness error when using generic
  *     Jesper S Moller <jesper@selskabet.org> - Contributions for
  *								bug 378674 - "The method can be declared as static" is wrong
  *     Till Brychcy - Contributions for
@@ -273,7 +274,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 		if(result != null && this.binding != null) {
 			final CompilerOptions compilerOptions = scope.compilerOptions();
 			if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
-				new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations)
+				new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
 						.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 5cee7f9..0937b88 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -43,16 +43,21 @@ public class ImplicitNullAnnotationVerifier {
 	// can be 'this', but is never a MethodVerifier (to avoid infinite recursion).
 	ImplicitNullAnnotationVerifier buddyImplicitNullAnnotationsVerifier;
 	private boolean inheritNullAnnotations;
+	protected LookupEnvironment environment;
 
-	public ImplicitNullAnnotationVerifier(boolean inheritNullAnnotations) {
+
+	public ImplicitNullAnnotationVerifier(LookupEnvironment environment, boolean inheritNullAnnotations) {
 		this.buddyImplicitNullAnnotationsVerifier = this;
 		this.inheritNullAnnotations = inheritNullAnnotations;
+		this.environment = environment;
 	}
 
 	// for sub-classes:
-	ImplicitNullAnnotationVerifier(CompilerOptions options) {
-		this.buddyImplicitNullAnnotationsVerifier = new ImplicitNullAnnotationVerifier(options.inheritNullAnnotations);
+	ImplicitNullAnnotationVerifier(LookupEnvironment environment) {
+		CompilerOptions options = environment.globalOptions;
+		this.buddyImplicitNullAnnotationsVerifier = new ImplicitNullAnnotationVerifier(environment, options.inheritNullAnnotations);
 		this.inheritNullAnnotations = options.inheritNullAnnotations;
+		this.environment = environment;
 	}
 
 	/**
@@ -202,7 +207,6 @@ public class ImplicitNullAnnotationVerifier {
 		long currentBits = currentMethod.tagBits;
 		long currentNullnessBits = currentBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable);
 		
-		LookupEnvironment environment = scope.environment();
 		boolean shouldInherit = this.inheritNullAnnotations;
 
 		// return type:
@@ -239,7 +243,7 @@ public class ImplicitNullAnnotationVerifier {
 				{
 					if (srcMethod != null) {
 						scope.problemReporter().illegalReturnRedefinition(srcMethod, inheritedMethod,
-																	environment.getNonNullAnnotationName());
+																	this.environment.getNonNullAnnotationName());
 					} else {
 						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
 						return;
@@ -301,9 +305,9 @@ public class ImplicitNullAnnotationVerifier {
 			if (shouldComplain) {
 				char[][] annotationName;
 				if (inheritedNonNullNess == Boolean.TRUE) {
-					annotationName = environment.getNonNullAnnotationName();
+					annotationName = this.environment.getNonNullAnnotationName();
 				} else {
-					annotationName = environment.getNullableAnnotationName();
+					annotationName = this.environment.getNullableAnnotationName();
 				}
 				if (inheritedNonNullNess != Boolean.TRUE		// super parameter is not restricted to @NonNull
 						&& currentNonNullNess == Boolean.TRUE)	// current parameter is restricted to @NonNull 
@@ -313,7 +317,7 @@ public class ImplicitNullAnnotationVerifier {
 						scope.problemReporter().illegalRedefinitionToNonNullParameter(
 								currentArgument,
 								inheritedMethod.declaringClass,
-								(inheritedNonNullNess == null) ? null : environment.getNullableAnnotationName());
+								(inheritedNonNullNess == null) ? null : this.environment.getNullableAnnotationName());
 					} else {
 						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
 					}
@@ -447,4 +451,140 @@ public class ImplicitNullAnnotationVerifier {
 		//		return ((UnresolvedReferenceBinding) two).resolvedType == one;
 		return false; // all other type bindings are identical
 	}
+
+	public boolean doesMethodOverride(MethodBinding method, MethodBinding inheritedMethod) {
+		return couldMethodOverride(method, inheritedMethod) && areMethodsCompatible(method, inheritedMethod);
+	}
+
+	protected boolean couldMethodOverride(MethodBinding method, MethodBinding inheritedMethod) {
+		if (!org.eclipse.jdt.core.compiler.CharOperation.equals(method.selector, inheritedMethod.selector))
+			return false;
+		if (method == inheritedMethod || method.isStatic() || inheritedMethod.isStatic())
+			return false;
+		if (inheritedMethod.isPrivate())
+			return false;
+		if (inheritedMethod.isDefault() && method.declaringClass.getPackage() != inheritedMethod.declaringClass.getPackage())
+			return false;
+		if (!method.isPublic()) { // inheritedMethod is either public or protected & method is less than public
+			if (inheritedMethod.isPublic())
+				return false;
+			if (inheritedMethod.isProtected() && !method.isProtected())
+				return false;
+		}
+		return true;
+	}
+
+	protected boolean areMethodsCompatible(MethodBinding one, MethodBinding two) {
+		// use the original methods to test compatibility, but do not check visibility, etc
+		one = one.original();
+		two = one.findOriginalInheritedMethod(two);
+	
+		if (two == null)
+			return false; // method's declaringClass does not inherit from inheritedMethod's
+	
+		return isParameterSubsignature(one, two);
+	}
+
+	protected boolean isParameterSubsignature(MethodBinding method, MethodBinding inheritedMethod) {
+		MethodBinding substitute = computeSubstituteMethod(inheritedMethod, method);
+		return substitute != null && isSubstituteParameterSubsignature(method, substitute);
+	}
+
+	protected MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod) {
+		if (inheritedMethod == null) return null;
+		if (currentMethod.parameters.length != inheritedMethod.parameters.length) return null; // no match
+	
+		// due to hierarchy & compatibility checks, we need to ensure these 2 methods are resolved
+		if (currentMethod.declaringClass instanceof BinaryTypeBinding)
+			((BinaryTypeBinding) currentMethod.declaringClass).resolveTypesFor(currentMethod);
+		if (inheritedMethod.declaringClass instanceof BinaryTypeBinding)
+			((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);
+	
+		TypeVariableBinding[] inheritedTypeVariables = inheritedMethod.typeVariables;
+		int inheritedLength = inheritedTypeVariables.length;
+		if (inheritedLength == 0) return inheritedMethod; // no substitution needed
+		TypeVariableBinding[] typeVariables = currentMethod.typeVariables;
+		int length = typeVariables.length;
+		if (length == 0)
+			return inheritedMethod.asRawMethod(this.environment);
+		if (length != inheritedLength)
+			return inheritedMethod; // no match JLS 8.4.2
+	
+		// interface I { <T> void foo(T t); }
+		// class X implements I { public <T extends I> void foo(T t) {} }
+		// for the above case, we do not want to answer the substitute method since its not a match
+		TypeVariableBinding[] arguments = new TypeVariableBinding[length];
+		System.arraycopy(typeVariables, 0, arguments, 0, length);
+		ParameterizedGenericMethodBinding substitute =
+			this.environment.createParameterizedGenericMethod(inheritedMethod, arguments);
+		for (int i = 0; i < inheritedLength; i++) {
+			TypeVariableBinding inheritedTypeVariable = inheritedTypeVariables[i];
+			TypeVariableBinding typeVariable = arguments[i];
+			if (typeVariable.firstBound == inheritedTypeVariable.firstBound) {
+				if (typeVariable.firstBound == null)
+					continue; // both are null
+			} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {
+				if (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())
+					return inheritedMethod; // not a match
+			}
+			if (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)
+				return inheritedMethod; // not a match
+			int interfaceLength = inheritedTypeVariable.superInterfaces.length;
+			ReferenceBinding[] interfaces = typeVariable.superInterfaces;
+			if (interfaceLength != interfaces.length)
+				return inheritedMethod; // not a match
+			next : for (int j = 0; j < interfaceLength; j++) {
+				TypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);
+				for (int k = 0; k < interfaceLength; k++)
+					if (superType == interfaces[k])
+						continue next;
+				return inheritedMethod; // not a match
+			}
+		}
+	   return substitute;
+	}
+
+	protected boolean isSubstituteParameterSubsignature(MethodBinding method, MethodBinding substituteMethod) {
+		if (!areParametersEqual(method, substituteMethod)) {
+			// method can still override substituteMethod in cases like :
+			// <U extends Number> void c(U u) {}
+			// @Override void c(Number n) {}
+			// but method cannot have a "generic-enabled" parameter type
+			if (substituteMethod.hasSubstitutedParameters() && method.areParameterErasuresEqual(substituteMethod))
+				return method.typeVariables == Binding.NO_TYPE_VARIABLES && !hasGenericParameter(method);
+	
+			// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=279836
+			if (method.declaringClass.isRawType() && substituteMethod.declaringClass.isRawType())
+				if (method.hasSubstitutedParameters() && substituteMethod.hasSubstitutedParameters())
+					return areMethodsCompatible(method, substituteMethod);
+	
+			return false;
+		}
+	
+		if (substituteMethod instanceof ParameterizedGenericMethodBinding) {
+			if (method.typeVariables != Binding.NO_TYPE_VARIABLES)
+				return !((ParameterizedGenericMethodBinding) substituteMethod).isRaw;
+			// since substituteMethod has substituted type variables, method cannot have a generic signature AND no variables -> its a name clash if it does
+			return !hasGenericParameter(method);
+		}
+	
+		// if method has its own variables, then substituteMethod failed bounds check in computeSubstituteMethod()
+		return method.typeVariables == Binding.NO_TYPE_VARIABLES;
+	}
+
+	boolean hasGenericParameter(MethodBinding method) {
+		if (method.genericSignature() == null) return false;
+	
+		// may be only the return type that is generic, need to check parameters
+		TypeBinding[] params = method.parameters;
+		for (int i = 0, l = params.length; i < l; i++) {
+			TypeBinding param = params[i].leafComponentType();
+			if (param instanceof ReferenceBinding) {
+				int modifiers = ((ReferenceBinding) param).modifiers;
+				if ((modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)
+					return true;
+			}
+		}
+		return false;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
index 51280ee..ce36425 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
@@ -13,6 +13,7 @@
  *								bug 395681 - [compiler] Improve simulation of javac6 behavior from bug 317719 after fixing bug 388795
  *								bug 406928 - computation of inherited methods seems damaged (affecting @Overrides)
  *								bug 409473 - [compiler] JDT cannot compile against JRE 1.8
+ *								Bug 418235 - [compiler][null] Unreported nullness error when using generic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -33,7 +34,6 @@ public abstract class MethodVerifier extends ImplicitNullAnnotationVerifier {
 	SourceTypeBinding type;
 	HashtableOfObject inheritedMethods;
 	HashtableOfObject currentMethods;
-	LookupEnvironment environment;
 	private boolean allowCompatibleReturnTypes;
 /*
 Binding creation is responsible for reporting all problems with types:
@@ -53,7 +53,7 @@ Binding creation is responsible for reporting all problems with types:
 		- defining an interface as a local type (local types can only be classes)
 */
 MethodVerifier(LookupEnvironment environment) {
-	super(environment.globalOptions);
+	super(environment);
 	this.type = null;  // Initialized with the public method verify(SourceTypeBinding)
 	this.inheritedMethods = null;
 	this.currentMethods = null;
@@ -62,9 +62,6 @@ MethodVerifier(LookupEnvironment environment) {
 		environment.globalOptions.complianceLevel >= ClassFileConstants.JDK1_5
 			&& environment.globalOptions.sourceLevel < ClassFileConstants.JDK1_5;
 }
-boolean areMethodsCompatible(MethodBinding one, MethodBinding two) {
-	return isParameterSubsignature(one, two) && areReturnTypesCompatible(one, two);
-}
 boolean areReturnTypesCompatible(MethodBinding one, MethodBinding two) {
 	if (one.returnType == two.returnType) return true;
 
@@ -639,45 +636,6 @@ void computeMethods() {
 	}
 }
 
-MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod) {
-	if (inheritedMethod == null) return null;
-	if (currentMethod.parameters.length != inheritedMethod.parameters.length) return null; // no match
-	return inheritedMethod;
-}
-
-boolean couldMethodOverride(MethodBinding method, MethodBinding inheritedMethod) {
-	if (!org.eclipse.jdt.core.compiler.CharOperation.equals(method.selector, inheritedMethod.selector))
-		return false;
-	if (method == inheritedMethod || method.isStatic() || inheritedMethod.isStatic())
-		return false;
-	if (inheritedMethod.isPrivate())
-		return false;
-	if (inheritedMethod.isDefault() && method.declaringClass.getPackage() != inheritedMethod.declaringClass.getPackage())
-		return false;
-	if (!method.isPublic()) { // inheritedMethod is either public or protected & method is less than public
-		if (inheritedMethod.isPublic())
-			return false;
-		if (inheritedMethod.isProtected() && !method.isProtected())
-			return false;
-	}
-	return true;
-}
-
-// Answer whether the method overrides the inheritedMethod
-// Check the necessary visibility rules & inheritance from the inheritedMethod's declaringClass
-// See isMethodSubsignature() for parameter comparisons
-public boolean doesMethodOverride(MethodBinding method, MethodBinding inheritedMethod) {
-	if (!couldMethodOverride(method, inheritedMethod))
-		return false;
-
-	inheritedMethod = inheritedMethod.original();
-	TypeBinding match = method.declaringClass.findSuperTypeOriginatingFrom(inheritedMethod.declaringClass);
-	if (!(match instanceof ReferenceBinding))
-		return false; // method's declaringClass does not inherit from inheritedMethod's
-
-	return isParameterSubsignature(method, inheritedMethod);
-}
-
 SimpleSet findSuperinterfaceCollisions(ReferenceBinding superclass, ReferenceBinding[] superInterfaces) {
 	return null; // noop in 1.4
 }
@@ -774,10 +732,6 @@ public boolean isMethodSubsignature(MethodBinding method, MethodBinding inherite
 		&& isParameterSubsignature(method, inheritedMethod);
 }
 
-boolean isParameterSubsignature(MethodBinding method, MethodBinding inheritedMethod) {
-	return areParametersEqual(method, inheritedMethod);
-}
-
 boolean isSameClassOrSubclassOf(ReferenceBinding testClass, ReferenceBinding superclass) {
 	do {
 		if (testClass == superclass) return true;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
index 1b7b1f2..b4532ae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
@@ -16,6 +16,7 @@
  *								bug 395681 - [compiler] Improve simulation of javac6 behavior from bug 317719 after fixing bug 388795
  *								bug 409473 - [compiler] JDT cannot compile against JRE 1.8
  *								Bug 410325 - [1.7][compiler] Generified method override different between javac and eclipse compiler
+ *								Bug 418235 - [compiler][null] Unreported nullness error when using generic
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -37,16 +38,6 @@ class MethodVerifier15 extends MethodVerifier {
 MethodVerifier15(LookupEnvironment environment) {
 	super(environment);
 }
-boolean areMethodsCompatible(MethodBinding one, MethodBinding two) {
-	// use the original methods to test compatibility, but do not check visibility, etc
-	one = one.original();
-	two = one.findOriginalInheritedMethod(two);
-
-	if (two == null)
-		return false; // method's declaringClass does not inherit from inheritedMethod's
-
-	return isParameterSubsignature(one, two);
-}
 boolean areReturnTypesCompatible(MethodBinding one, MethodBinding two) {
 	if (one.returnType == two.returnType) return true;
 	if (this.type.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {
@@ -352,7 +343,7 @@ void checkNullSpecInheritance(MethodBinding currentMethod, AbstractMethodDeclara
 	if (currentMethod.declaringClass != this.type 
 			&& (currentMethod.tagBits & TagBits.IsNullnessKnown) == 0) 
 	{
-		this.buddyImplicitNullAnnotationsVerifier.checkImplicitNullAnnotations(currentMethod, srcMethod, complain, this.type.scope);
+		this.buddyImplicitNullAnnotationsVerifier.checkImplicitNullAnnotations(currentMethod, srcMethod, complain, scope);
 	}
 	super.checkNullSpecInheritance(currentMethod, srcMethod, hasNonNullDefault, complain, inheritedMethod, scope, inheritedNonNullnessInfos);
 }
@@ -696,64 +687,6 @@ void checkTypeVariableMethods(TypeParameter typeParameter) {
 		}
 	}
 }
-MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, MethodBinding currentMethod) {
-	if (inheritedMethod == null) return null;
-	if (currentMethod.parameters.length != inheritedMethod.parameters.length) return null; // no match
-
-	// due to hierarchy & compatibility checks, we need to ensure these 2 methods are resolved
-	if (currentMethod.declaringClass instanceof BinaryTypeBinding)
-		((BinaryTypeBinding) currentMethod.declaringClass).resolveTypesFor(currentMethod);
-	if (inheritedMethod.declaringClass instanceof BinaryTypeBinding)
-		((BinaryTypeBinding) inheritedMethod.declaringClass).resolveTypesFor(inheritedMethod);
-
-	TypeVariableBinding[] inheritedTypeVariables = inheritedMethod.typeVariables;
-	int inheritedLength = inheritedTypeVariables.length;
-	if (inheritedLength == 0) return inheritedMethod; // no substitution needed
-	TypeVariableBinding[] typeVariables = currentMethod.typeVariables;
-	int length = typeVariables.length;
-	if (length == 0)
-		return inheritedMethod.asRawMethod(this.environment);
-	if (length != inheritedLength)
-		return inheritedMethod; // no match JLS 8.4.2
-
-	// interface I { <T> void foo(T t); }
-	// class X implements I { public <T extends I> void foo(T t) {} }
-	// for the above case, we do not want to answer the substitute method since its not a match
-	TypeBinding[] arguments = new TypeBinding[length];
-	System.arraycopy(typeVariables, 0, arguments, 0, length);
-	ParameterizedGenericMethodBinding substitute =
-		this.environment.createParameterizedGenericMethod(inheritedMethod, arguments);
-	for (int i = 0; i < inheritedLength; i++) {
-		TypeVariableBinding inheritedTypeVariable = inheritedTypeVariables[i];
-		TypeBinding argument = arguments[i];
-		if (argument instanceof TypeVariableBinding) {
-			TypeVariableBinding typeVariable = (TypeVariableBinding) argument;
-			if (typeVariable.firstBound == inheritedTypeVariable.firstBound) {
-				if (typeVariable.firstBound == null)
-					continue; // both are null
-			} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {
-				if (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())
-					return inheritedMethod; // not a match
-			}
-			if (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)
-				return inheritedMethod; // not a match
-			int interfaceLength = inheritedTypeVariable.superInterfaces.length;
-			ReferenceBinding[] interfaces = typeVariable.superInterfaces;
-			if (interfaceLength != interfaces.length)
-				return inheritedMethod; // not a match
-			next : for (int j = 0; j < interfaceLength; j++) {
-				TypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);
-				for (int k = 0; k < interfaceLength; k++)
-					if (superType == interfaces[k])
-						continue next;
-				return inheritedMethod; // not a match
-			}
-		} else if (inheritedTypeVariable.boundCheck(substitute, argument, this.type.scope) != TypeConstants.OK) {
-	    	return inheritedMethod;
-		}
-	}
-   return substitute;
-}
 boolean detectInheritedNameClash(MethodBinding inherited, MethodBinding otherInherited) {
 	if (!inherited.areParameterErasuresEqual(otherInherited))
 		return false;
@@ -814,9 +747,6 @@ boolean detectNameClash(MethodBinding current, MethodBinding inherited, boolean
 	if (severity == ProblemSeverities.Warning) return false;
 	return true;
 }
-public boolean doesMethodOverride(MethodBinding method, MethodBinding inheritedMethod) {
-	return couldMethodOverride(method, inheritedMethod) && areMethodsCompatible(method, inheritedMethod);
-}
 boolean doTypeVariablesClash(MethodBinding one, MethodBinding substituteTwo) {
 	// one has type variables and substituteTwo did not pass bounds check in computeSubstituteMethod()
 	return one.typeVariables != Binding.NO_TYPE_VARIABLES && !(substituteTwo instanceof ParameterizedGenericMethodBinding);
@@ -890,21 +820,6 @@ SimpleSet findSuperinterfaceCollisions(ReferenceBinding superclass, ReferenceBin
 	}
 	return copy;
 }
-boolean hasGenericParameter(MethodBinding method) {
-	if (method.genericSignature() == null) return false;
-
-	// may be only the return type that is generic, need to check parameters
-	TypeBinding[] params = method.parameters;
-	for (int i = 0, l = params.length; i < l; i++) {
-		TypeBinding param = params[i].leafComponentType();
-		if (param instanceof ReferenceBinding) {
-			int modifiers = ((ReferenceBinding) param).modifiers;
-			if ((modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)
-				return true;
-		}
-	}
-	return false;
-}
 boolean isAcceptableReturnTypeOverride(MethodBinding currentMethod, MethodBinding inheritedMethod) {
 	// called when currentMethod's return type is compatible with inheritedMethod's return type
 
@@ -950,39 +865,6 @@ public boolean isMethodSubsignature(MethodBinding method, MethodBinding inherite
 	MethodBinding inheritedOriginal = method.findOriginalInheritedMethod(inheritedMethod);
 	return isParameterSubsignature(method, inheritedOriginal == null ? inheritedMethod : inheritedOriginal);
 }
-boolean isParameterSubsignature(MethodBinding method, MethodBinding inheritedMethod) {
-	MethodBinding substitute = computeSubstituteMethod(inheritedMethod, method);
-	return substitute != null && isSubstituteParameterSubsignature(method, substitute);
-}
-// if method "overrides" substituteMethod then we can skip over substituteMethod while resolving a message send
-// if it does not then a name clash error is likely
-boolean isSubstituteParameterSubsignature(MethodBinding method, MethodBinding substituteMethod) {
-	if (!areParametersEqual(method, substituteMethod)) {
-		// method can still override substituteMethod in cases like :
-		// <U extends Number> void c(U u) {}
-		// @Override void c(Number n) {}
-		// but method cannot have a "generic-enabled" parameter type
-		if (substituteMethod.hasSubstitutedParameters() && method.areParameterErasuresEqual(substituteMethod))
-			return method.typeVariables == Binding.NO_TYPE_VARIABLES && !hasGenericParameter(method);
-
-		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=279836
-		if (method.declaringClass.isRawType() && substituteMethod.declaringClass.isRawType())
-			if (method.hasSubstitutedParameters() && substituteMethod.hasSubstitutedParameters())
-				return areMethodsCompatible(method, substituteMethod);
-
-		return false;
-	}
-
-	if (substituteMethod instanceof ParameterizedGenericMethodBinding) {
-		if (method.typeVariables != Binding.NO_TYPE_VARIABLES)
-			return !((ParameterizedGenericMethodBinding) substituteMethod).isRaw;
-		// since substituteMethod has substituted type variables, method cannot have a generic signature AND no variables -> its a name clash if it does
-		return !hasGenericParameter(method);
-	}
-
-	// if method has its own variables, then substituteMethod failed bounds check in computeSubstituteMethod()
-	return method.typeVariables == Binding.NO_TYPE_VARIABLES;
-}
 boolean isUnsafeReturnTypeOverride(MethodBinding currentMethod, MethodBinding inheritedMethod) {
 	// called when currentMethod's return type is NOT compatible with inheritedMethod's return type
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 13f1227..a434061 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -21,6 +21,7 @@
  *								bug 388281 - [compiler][null] inheritance of null annotations as an option
  *								bug 331649 - [compiler][null] consider null annotations for fields
  *								bug 380896 - [compiler][null] Enum constants not recognised as being NonNull.
+ *								Bug 418235 - [compiler][null] Unreported nullness error when using generic
  *     Till Brychcy - Contributions for
  *     							bug 415269 - NonNullByDefault is not always inherited to nested classes
  *******************************************************************************/
@@ -1666,7 +1667,8 @@ private void createArgumentBindings(MethodBinding method, CompilerOptions compil
 			methodDecl.createArgumentBindings();
 		// add implicit annotations (inherited(?) & default):
 		if (compilerOptions.isAnnotationBasedNullAnalysisEnabled) {
-			new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations).checkImplicitNullAnnotations(method, methodDecl, true, this.scope);
+			new ImplicitNullAnnotationVerifier(this.scope.environment(), compilerOptions.inheritNullAnnotations)
+					.checkImplicitNullAnnotations(method, methodDecl, true, this.scope);
 		}
 	}
 }
commit 998718a6f3c4fdf42208417429777816ff07d23a
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Tue Oct 8 14:52:54 2013 +0200

    Bug 418235 - [compiler][null] Unreported nullness error when using
    generic
    - test & fix

25	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index dc07fa5..5eec9a6 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -6471,4 +6471,29 @@ public void testBug416267() {
 		"Missing cannot be resolved to a type\n" + 
 		"----------\n");
 }
+public void testBug418235() {
+    runNegativeTestWithLibs(
+            new String[] {
+                    "GenericInterface.java",
+                    "public interface GenericInterface<T> {\n" + 
+                    "       T doSomethingGeneric(T o);\n" + 
+                    "}",
+                    "Implementation.java",
+                    "import org.eclipse.jdt.annotation.NonNullByDefault;\n" + 
+                    "@NonNullByDefault\n" + 
+                    "public class Implementation implements GenericInterface<Object> {\n" + 
+                    "\n" + 
+                    (this.complianceLevel < ClassFileConstants.JDK1_6 ? "\n" : "      @Override\n" ) +
+                    "       public Object doSomethingGeneric(Object o) {\n" + 
+                    "               return o;\n" + 
+                    "       }\n" + 
+                    "}\n"
+            },
+            "----------\n" + 
+            "1. ERROR in Implementation.java (at line 6)\n" + 
+    		"	public Object doSomethingGeneric(Object o) {\n" + 
+    		"	                                 ^^^^^^\n" + 
+            "Illegal redefinition of parameter o, inherited method from GenericInterface<Object> does not constrain this parameter\n" + 
+            "----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 0937b88..269d5b3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -163,7 +163,7 @@ public class ImplicitNullAnnotationVerifier {
 			MethodBinding currentMethod = ifcMethods[i];
 			if (currentMethod.isStatic())
 				continue;
-			if (areParametersEqual(original, currentMethod.original())) {
+			if (doesMethodOverride(original, currentMethod)) {
 				result.add(currentMethod);
 				return; // at most one method is overridden from any supertype
 			}
commit 6f2d59d80da8490e52a278944b98c97220ac4149
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Oct 10 12:51:33 2013 +0200

    Bug 418235 - [compiler][null] Unreported nullness error when using
    generic
    - modified version of refactoring in
    e638bcfa6ede2617a8de404af4af8024502bc348

1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
16	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
20	27	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 6db9d96..6c7206e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -461,7 +461,7 @@ public TypeBinding resolveType(BlockScope scope) {
  	}
 	final CompilerOptions compilerOptions = scope.compilerOptions();
 	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
-		new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations)
+		new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
 				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
 	}
 	return allocationType;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index d3a41ff..842c6c3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -729,7 +729,7 @@ public TypeBinding resolveType(BlockScope scope) {
 	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled) {
 		if ((this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
 			// not interested in reporting problems against this.binding:
-			new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations)
+			new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
 					.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
 		}
 		if (compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 12020ae..aae925d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -283,7 +283,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 		if(result != null && this.binding != null) {
 			final CompilerOptions compilerOptions = scope.compilerOptions();
 			if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
-				new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations)
+				new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
 						.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 36bc73c..5b84b30 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -49,16 +49,20 @@ public class ImplicitNullAnnotationVerifier {
 	// can be 'this', but is never a MethodVerifier (to avoid infinite recursion).
 	ImplicitNullAnnotationVerifier buddyImplicitNullAnnotationsVerifier;
 	private boolean inheritNullAnnotations;
+	protected LookupEnvironment environment;
 
-	public ImplicitNullAnnotationVerifier(boolean inheritNullAnnotations) {
+	public ImplicitNullAnnotationVerifier(LookupEnvironment environment, boolean inheritNullAnnotations) {
 		this.buddyImplicitNullAnnotationsVerifier = this;
 		this.inheritNullAnnotations = inheritNullAnnotations;
+		this.environment = environment;
 	}
 
 	// for sub-classes:
-	ImplicitNullAnnotationVerifier(CompilerOptions options) {
-		this.buddyImplicitNullAnnotationsVerifier = new ImplicitNullAnnotationVerifier(options.inheritNullAnnotations);
+	ImplicitNullAnnotationVerifier(LookupEnvironment environment) {
+		CompilerOptions options = environment.globalOptions;
+		this.buddyImplicitNullAnnotationsVerifier = new ImplicitNullAnnotationVerifier(environment, options.inheritNullAnnotations);
 		this.inheritNullAnnotations = options.inheritNullAnnotations;
+		this.environment = environment;
 	}
 
 	/**
@@ -226,8 +230,7 @@ public class ImplicitNullAnnotationVerifier {
 			// TODO (stephan): even here we may need to report problems? How to discriminate?
 			this.buddyImplicitNullAnnotationsVerifier.checkImplicitNullAnnotations(inheritedMethod, null, false, scope);
 		}
-		LookupEnvironment environment = scope.environment();
-		boolean useTypeAnnotations = environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;
+		boolean useTypeAnnotations = this.environment.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8;
 		long inheritedNullnessBits = getReturnTypeNullnessTagBits(inheritedMethod, useTypeAnnotations);
 		long currentNullnessBits = getReturnTypeNullnessTagBits(currentMethod, useTypeAnnotations);
 		
@@ -252,14 +255,14 @@ public class ImplicitNullAnnotationVerifier {
 									inheritedMethod, Boolean.valueOf(inheritedNullnessBits == TagBits.AnnotationNonNull), inheritedNonNullnessInfos[0]);
 						} else {
 							// no need to defer, record this info now:
-							applyReturnNullBits(currentMethod, inheritedNullnessBits, environment);
+							applyReturnNullBits(currentMethod, inheritedNullnessBits, this.environment);
 						}	
 						break returnType; // compatible by construction, skip complain phase below
 					}
 				}
 				if (hasNonNullDefault) { // conflict with inheritance already checked
 					currentNullnessBits = TagBits.AnnotationNonNull;
-					applyReturnNullBits(currentMethod, currentNullnessBits, environment);
+					applyReturnNullBits(currentMethod, currentNullnessBits, this.environment);
 				}
 			}
 			if (shouldComplain) {
@@ -268,7 +271,7 @@ public class ImplicitNullAnnotationVerifier {
 				{
 					if (srcMethod != null) {
 						scope.problemReporter().illegalReturnRedefinition(srcMethod, inheritedMethod,
-																	environment.getNonNullAnnotationName());
+																	this.environment.getNonNullAnnotationName());
 					} else {
 						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
 						return;
@@ -320,7 +323,7 @@ public class ImplicitNullAnnotationVerifier {
 							if (!useTypeAnnotations)
 								recordArgNonNullness(currentMethod, length, i, currentArgument, inheritedNonNullNess);
 							else
-								recordArgNonNullness18(currentMethod, i, currentArgument, inheritedNonNullNess, environment);
+								recordArgNonNullness18(currentMethod, i, currentArgument, inheritedNonNullNess, this.environment);
 						}
 						continue; // compatible by construction, skip complain phase below
 					}
@@ -330,15 +333,15 @@ public class ImplicitNullAnnotationVerifier {
 					if (!useTypeAnnotations)
 						recordArgNonNullness(currentMethod, length, i, currentArgument, Boolean.TRUE);
 					else
-						recordArgNonNullness18(currentMethod, i, currentArgument, Boolean.TRUE, environment);
+						recordArgNonNullness18(currentMethod, i, currentArgument, Boolean.TRUE, this.environment);
 				}
 			}
 			if (shouldComplain) {
 				char[][] annotationName;
 				if (inheritedNonNullNess == Boolean.TRUE) {
-					annotationName = environment.getNonNullAnnotationName();
+					annotationName = this.environment.getNonNullAnnotationName();
 				} else {
-					annotationName = environment.getNullableAnnotationName();
+					annotationName = this.environment.getNullableAnnotationName();
 				}
 				if (inheritedNonNullNess != Boolean.TRUE		// super parameter is not restricted to @NonNull
 						&& currentNonNullNess == Boolean.TRUE)	// current parameter is restricted to @NonNull 
@@ -348,7 +351,7 @@ public class ImplicitNullAnnotationVerifier {
 						scope.problemReporter().illegalRedefinitionToNonNullParameter(
 								currentArgument,
 								inheritedMethod.declaringClass,
-								(inheritedNonNullNess == null) ? null : environment.getNullableAnnotationName());
+								(inheritedNonNullNess == null) ? null : this.environment.getNullableAnnotationName());
 					} else {
 						scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
 					}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
index de5264e..2ab27dd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
@@ -49,7 +49,6 @@ public abstract class MethodVerifier extends ImplicitNullAnnotationVerifier {
 	SourceTypeBinding type;
 	HashtableOfObject inheritedMethods;
 	HashtableOfObject currentMethods;
-	LookupEnvironment environment;
 	/*
 Binding creation is responsible for reporting all problems with types:
 	- all modifier problems (duplicates & multiple visibility modifiers + incompatible combinations - abstract/final)
@@ -68,11 +67,10 @@ Binding creation is responsible for reporting all problems with types:
 		- defining an interface as a local type (local types can only be classes)
 */
 MethodVerifier(LookupEnvironment environment) {
-	super(environment.globalOptions);
+	super(environment);
 	this.type = null;  // Initialized with the public method verify(SourceTypeBinding)
 	this.inheritedMethods = null;
 	this.currentMethods = null;
-	this.environment = environment;
 }
 boolean areMethodsCompatible(MethodBinding one, MethodBinding two) {
 	return areMethodsCompatible(one, two, this.environment);
@@ -703,31 +701,26 @@ static MethodBinding computeSubstituteMethod(MethodBinding inheritedMethod, Meth
 		environment.createParameterizedGenericMethod(inheritedMethod, arguments);
 	for (int i = 0; i < inheritedLength; i++) {
 		TypeVariableBinding inheritedTypeVariable = inheritedTypeVariables[i];
-		TypeBinding argument = arguments[i];
-		if (argument instanceof TypeVariableBinding) {
-			TypeVariableBinding typeVariable = (TypeVariableBinding) argument;
-			if (typeVariable.firstBound == inheritedTypeVariable.firstBound) {
-				if (typeVariable.firstBound == null)
-					continue; // both are null
-			} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {
-				if (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())
-					return inheritedMethod; // not a match
-			}
-			if (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)
-				return inheritedMethod; // not a match
-			int interfaceLength = inheritedTypeVariable.superInterfaces.length;
-			ReferenceBinding[] interfaces = typeVariable.superInterfaces;
-			if (interfaceLength != interfaces.length)
-				return inheritedMethod; // not a match
-			next : for (int j = 0; j < interfaceLength; j++) {
-				TypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);
-				for (int k = 0; k < interfaceLength; k++)
-					if (superType == interfaces[k])
-						continue next;
+		TypeVariableBinding typeVariable = (TypeVariableBinding) arguments[i]; // cast is safe by construction: arguments is copied from TypeVariableBinding[]
+		if (typeVariable.firstBound == inheritedTypeVariable.firstBound) {
+			if (typeVariable.firstBound == null)
+				continue; // both are null
+		} else if (typeVariable.firstBound != null && inheritedTypeVariable.firstBound != null) {
+			if (typeVariable.firstBound.isClass() != inheritedTypeVariable.firstBound.isClass())
 				return inheritedMethod; // not a match
-			}
-		} else if (inheritedTypeVariable.boundCheck(substitute, argument, null) != TypeConstants.OK) {
-	    	return inheritedMethod;
+		}
+		if (Scope.substitute(substitute, inheritedTypeVariable.superclass) != typeVariable.superclass)
+			return inheritedMethod; // not a match
+		int interfaceLength = inheritedTypeVariable.superInterfaces.length;
+		ReferenceBinding[] interfaces = typeVariable.superInterfaces;
+		if (interfaceLength != interfaces.length)
+			return inheritedMethod; // not a match
+		next : for (int j = 0; j < interfaceLength; j++) {
+			TypeBinding superType = Scope.substitute(substitute, inheritedTypeVariable.superInterfaces[j]);
+			for (int k = 0; k < interfaceLength; k++)
+				if (superType == interfaces[k])
+					continue next;
+			return inheritedMethod; // not a match
 		}
 	}
    return substitute;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
index 5b5026e..f8153dc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
@@ -391,7 +391,7 @@ void checkNullSpecInheritance(MethodBinding currentMethod, AbstractMethodDeclara
 	if (currentMethod.declaringClass != this.type 
 			&& (currentMethod.tagBits & TagBits.IsNullnessKnown) == 0) 
 	{
-		this.buddyImplicitNullAnnotationsVerifier.checkImplicitNullAnnotations(currentMethod, srcMethod, complain, this.type.scope);
+		this.buddyImplicitNullAnnotationsVerifier.checkImplicitNullAnnotations(currentMethod, srcMethod, complain, scope);
 	}
 	super.checkNullSpecInheritance(currentMethod, srcMethod, hasNonNullDefault, complain, inheritedMethod, scope, inheritedNonNullnessInfos);
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index e1110e4..f460cbb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -1966,7 +1966,7 @@ private void createArgumentBindings(MethodBinding method, CompilerOptions compil
 			methodDecl.createArgumentBindings();
 		// add implicit annotations (inherited(?) & default):
 		if (compilerOptions.isAnnotationBasedNullAnalysisEnabled) {
-			new ImplicitNullAnnotationVerifier(compilerOptions.inheritNullAnnotations).checkImplicitNullAnnotations(method, methodDecl, true, this.scope);
+			new ImplicitNullAnnotationVerifier(this.scope.environment()).checkImplicitNullAnnotations(method, methodDecl, true, this.scope);
 		}
 	}
 }
commit 06b5701a9032533ad97c85c114cda06219dc0a99
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Oct 10 13:05:25 2013 +0200

    Bug 418235 - [compiler][null] Unreported nullness error when using
    generic
    - test & fix

25	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 974002b..9284c7d 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -6628,4 +6628,29 @@ public void testBug416267() {
 		"Missing cannot be resolved to a type\n" + 
 		"----------\n");
 }
+public void testBug418235() {
+    runNegativeTestWithLibs(
+            new String[] {
+                    "GenericInterface.java",
+                    "public interface GenericInterface<T> {\n" + 
+                    "       T doSomethingGeneric(T o);\n" + 
+                    "}",
+                    "Implementation.java",
+                    "import org.eclipse.jdt.annotation.NonNullByDefault;\n" + 
+                    "@NonNullByDefault\n" + 
+                    "public class Implementation implements GenericInterface<Object> {\n" + 
+                    "\n" + 
+                    (this.complianceLevel < ClassFileConstants.JDK1_6 ? "\n" : "      @Override\n" ) +
+                    "       public Object doSomethingGeneric(Object o) {\n" + 
+                    "               return o;\n" + 
+                    "       }\n" + 
+                    "}\n"
+            },
+            "----------\n" + 
+            "1. ERROR in Implementation.java (at line 6)\n" + 
+    		"	public Object doSomethingGeneric(Object o) {\n" + 
+    		"	                                 ^^^^^^\n" + 
+            "Illegal redefinition of parameter o, inherited method from GenericInterface<Object> does not constrain this parameter\n" + 
+            "----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 5b84b30..16347b3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -51,6 +51,7 @@ public class ImplicitNullAnnotationVerifier {
 	private boolean inheritNullAnnotations;
 	protected LookupEnvironment environment;
 
+
 	public ImplicitNullAnnotationVerifier(LookupEnvironment environment, boolean inheritNullAnnotations) {
 		this.buddyImplicitNullAnnotationsVerifier = this;
 		this.inheritNullAnnotations = inheritNullAnnotations;
@@ -191,7 +192,7 @@ public class ImplicitNullAnnotationVerifier {
 			MethodBinding currentMethod = ifcMethods[i];
 			if (currentMethod.isStatic())
 				continue;
-			if (areParametersEqual(original, currentMethod)) {
+			if (MethodVerifier.doesMethodOverride(original, currentMethod, this.environment)) {
 				result.add(currentMethod);
 				return; // at most one method is overridden from any supertype
 			}
