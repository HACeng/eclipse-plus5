commit 271be052e104f1beefee4cd78039eca6ee6adb4f
Author: David Audel <daudel>
Date:   Thu Mar 6 15:31:32 2008 +0000

    HEAD - bug 202470

1	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
156	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
216	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionElementNotifier.java
36	9	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
208	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionUnitStructureRequestor.java
45	14	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalCompletionContext.java
793	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
2	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
81	3	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
30	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistAnnotation.java
55	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistCompilationUnit.java
35	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistImportContainer.java
30	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistImportDeclaration.java
39	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistInitializer.java
35	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistPackageDeclaration.java
69	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceField.java
74	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceMethod.java
100	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceType.java
30	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistTypeParameter.java
2	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
10	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
6	70	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java
7	187	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
10	7	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
7	3	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java
6	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
758	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
19	685	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
7	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
52	21	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
3	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ImportContainer.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Initializer.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementInfo.java
8	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Openable.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageDeclaration.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceField.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceMethod.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceType.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
253	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
1	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index 1fe1a1e..3e45bf9 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -14,7 +14,7 @@
 #Format: compiler.name = word1 word2 word3
 compiler.name = Eclipse Java Compiler
 #Format: compiler.version = 0.XXX[, other words (don't forget the comma if adding other words)]
-compiler.version = 0.843, pre-3.4.0 milestone-6
+compiler.version = 0.844, pre-3.4.0 milestone-6
 compiler.copyright = Copyright IBM Corp 2000, 2008. All rights reserved.
 
 ### progress
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index b4e20bf..01a5cc0 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -38,11 +38,166 @@
 	</td>
   </tr>
 </table>
+<a name="v_844"></a>
+<hr><h1>
+Eclipse Platform Build Notes<br>
+Java Development Tooling Core</h1>
+Eclipse SDK 3.4M6 - %date% - 3.4 MILESTONE 6
+<br>Project org.eclipse.jdt.core v_844
+(<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_844">cvs</a>).
+<h2>What's new in this drop</h2>
+<ul>
+<li>CodeAssist: Added new API to give more information about completion context:<br>
+<ul>
+<li>CompletionContext#getEnclosingElement() - This method returns the elements visible from the completion location.
+<pre>
+public class X {
+	void foo() {
+		zzz| // ctrl+space at | location
+	}
+}
+</pre>
+<code>getEnclosingElement()</code> returns the IMethod named foo.
+</li>
+<li>CompletionContext#getVisibleElements(String) - This method returns the innermost enclosing Java element which contains the completion location.
+<pre>
+public class X {
+	p.Y f1;
+	p.Z f2;
+	void foo() {
+		p.Y l1;
+		p.Z l2;
+		zzz| // ctrl+space at | location
+	}
+}
+</pre>
+<code>getVisibleElements("Lp/Z;")</code> returns the IField named f2 and the ILocalVariable name l2.
+</li>
+</ul>
+
+<pre>
+public class CompletionRequestor {
+	...
+	
+	/**
+	 * Returns whether this requestor requires an extended context.
+	 * 
+	 * By default this method return <code>false</code>.
+	 * 
+	 * @return <code>true</code> if this requestor requires an extended context.
+	 * 
+	 * @see CompletionContext#isExtended()
+	 * 
+	 * @since 3.4
+	 */
+	public boolean isExtendedContextRequired() {...}
+	
+	/**
+	 * Sets whether this requestor requires an extended context.
+	 * 
+	 * @param require <code>true</code> if this requestor requires an extended context.
+	 * 
+	 * @see CompletionContext#isExtended()
+	 * 
+	 * @since 3.4
+	 */
+	public void setRequireExtendedContext(boolean require) {...}
+	
+	...
+}
+ </pre>
+ <pre>
+public class CompletionContext {
+	...
+	
+	/**
+	 * Returns whether this completion context is an extended context.
+	 * Some methods of this context can be used only if this context is an extended context but an extended context consumes more memory.
+	 * 
+	 * @return <code>true</code> if this completion context is an extended context.
+	 * 
+	 * @since 3.4
+	 */
+	public boolean isExtended() {...}
+	
+	/**
+	 * Returns the innermost enclosing Java element which contains the completion location or <code>null</code> if this element cannot be computed.
+	 * The returned Java element and all Java elements in the same compilation unit which can be navigated to from the returned Java element are special Java elements:
+	 * <ul>
+	 * <li>they are based on the current content of the compilation unit's buffer, they are not the result of a reconcile operation</li>
+	 * <li>they are not updated if the buffer changes.</li>
+	 * <li>they do not contain local types which are not visible from the completion location.</li>
+	 * <li>they do not give information about categories. {@link IMember#getCategories()} will return an empty array</li>
+	 * </ul>
+	 * 
+	 * Reasons for returning <code>null</code> include:
+	 * <ul>
+	 * <li>the compilation unit no longer exists</li>
+	 * <li>the completion occurred in a binary type. However this restriction might be relaxed in the future.</li>
+	 * </ul>
+	 * 
+	 * @return the innermost enclosing Java element which contains the completion location or <code>null</code> if this element cannot be computed.
+	 * 
+	 * @exception UnsupportedOperationException if the context is not an extended context
+	 * 
+	 * @since 3.4
+	 */
+	public IJavaElement getEnclosingElement() {...}
+	
+	/**
+	 * Return the elements which are visible from the completion location and which can be assigned to the given type.
+	 * An element is assignable if its type can be assigned to a variable
+	 * of the given type, as specified in section 5.2 of <em>The Java Language
+	 * Specification, Third Edition</em> (JLS3).
+	 * A visible element is either:
+	 * <ul>
+	 * <li>a {@link ILocalVariable} - the element type is {@link ILocalVariable#getTypeSignature()}</li>
+	 * <li>a {@link IField} - the element type is {@link IField#getTypeSignature()}</li>
+	 * <li>a {@link IMethod} - the element type is {@link IMethod#getReturnType()}</li>
+	 * </ul>
+	 * 
+	 * Returned elements defined in the completed compilation unit are special Java elements:
+	 * <ul>
+	 * <li>they are based on the current content of the compilation unit's buffer, they are not the result of a reconcile operation</li>
+	 * <li>they are not updated if the buffer changes.</li>
+	 * <li>they do not contain local types which are not visible from the completion location.</li>
+	 * <li>they do not give information about categories. {@link IMember#getCategories()} will return an empty array</li>
+	 * </ul>
+	 * 
+	 * Note the array can be empty if:
+	 * <ul>
+	 * <li>the compilation unit no longer exists</li>
+	 * <li>the completion occurred in a binary type. However this restriction might be relaxed in the future.</li>
+	 * </ul>
+	 * 
+	 * @param typeSignature elements which can be assigned to this type are returned.
+	 * 		If <code>null</code> there is no constraint on the type of the returned elements.
+	 * 
+	 * @return elements which are visible from the completion location and which can be assigned to the given type.
+	 * 
+	 * @exception UnsupportedOperationException if the context is not an extended context
+	 * 
+	 * @see #isExtended()
+	 * 
+	 * @since 3.4
+	 */
+	public IJavaElement[] getVisibleElements(String typeSignature) {...}
+	
+	...
+}
+ </pre>
+</li>
+</ul>
+
+<h3>Problem Reports Fixed</h3>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=202470">202470</a>
+[assist] provide all elements that are visible
+
 <a name="v_843"></a>
 <hr><h1>
 Eclipse Platform Build Notes<br>
 Java Development Tooling Core</h1>
-Eclipse SDK 3.4M6 - March 5, 2008 - 3.4 MILESTONE 6
+Eclipse SDK 3.4M6 - March 5, 2008
 <br>Project org.eclipse.jdt.core v_843
 (<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_843">cvs</a>).
 <h2>What's new in this drop</h2>
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionElementNotifier.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionElementNotifier.java
new file mode 100644
index 0000000..353acce
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionElementNotifier.java
@@ -0,0 +1,216 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist;
+
+import java.util.Map;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnAnnotationOfType;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnArgumentName;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnFieldName;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnFieldType;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnImportReference;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnKeyword;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnKeyword2;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnMethodName;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnMethodReturnType;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnMethodTypeParameter;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnPackageReference;
+import org.eclipse.jdt.internal.compiler.SourceElementNotifier;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ImportReference;
+import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt;
+
+public class CompletionElementNotifier extends SourceElementNotifier {
+	
+	private ASTNode assistNode;
+	
+	public CompletionElementNotifier(
+			CompletionUnitStructureRequestor requestor,
+			boolean reportLocalDeclarations,
+			ASTNode assistNode) {
+		super(requestor, reportLocalDeclarations);
+		this.assistNode = assistNode;
+	}
+	
+	protected char[][][] getArguments(Argument[] arguments) {
+		int argumentLength = arguments.length;
+		char[][] argumentTypes = new char[argumentLength][];
+		char[][] argumentNames = new char[argumentLength][];
+		int argumentCount = 0;
+		next : for (int i = 0; i < argumentLength; i++) {
+			Argument argument = arguments[i];
+			
+			if (argument instanceof CompletionOnArgumentName && argument.name.length == 0) continue next;
+			
+			argumentTypes[argumentCount] = CharOperation.concatWith(argument.type.getParameterizedTypeName(), '.');
+			argumentNames[argumentCount++] = argument.name;
+		}
+		
+		if (argumentCount < argumentLength) {
+			System.arraycopy(argumentTypes, 0, argumentTypes = new char[argumentCount][], 0, argumentCount);
+			System.arraycopy(argumentNames, 0, argumentNames = new char[argumentCount][], 0, argumentCount);
+		}
+		
+		return new char[][][] {argumentTypes, argumentNames};
+	}
+	
+	protected char[][] getInterfaceNames(TypeDeclaration typeDeclaration) {
+		char[][] interfaceNames = null;
+		int superInterfacesLength = 0;
+		TypeReference[] superInterfaces = typeDeclaration.superInterfaces;
+		if (superInterfaces != null) {
+			superInterfacesLength = superInterfaces.length;
+			interfaceNames = new char[superInterfacesLength][];
+		} else {
+			if ((typeDeclaration.bits & ASTNode.IsAnonymousType) != 0) {
+				// see PR 3442
+				QualifiedAllocationExpression alloc = typeDeclaration.allocation;
+				if (alloc != null && alloc.type != null) {
+					superInterfaces = new TypeReference[] { alloc.type};
+					superInterfacesLength = 1;
+					interfaceNames = new char[1][];
+				}
+			}
+		}
+		if (superInterfaces != null) {
+			int superInterfaceCount = 0;
+			next: for (int i = 0; i < superInterfacesLength; i++) {
+				TypeReference superInterface = superInterfaces[i];
+				
+				if (superInterface instanceof CompletionOnKeyword) continue next;
+				if (CompletionUnitStructureRequestor.hasEmptyName(superInterface, this.assistNode)) continue next;
+				
+				interfaceNames[superInterfaceCount++] = CharOperation.concatWith(superInterface.getParameterizedTypeName(), '.'); 
+			}
+			
+			if (superInterfaceCount == 0) return null;
+			if (superInterfaceCount < superInterfacesLength) {
+				System.arraycopy(interfaceNames, 0, interfaceNames = new char[superInterfaceCount][], 0, superInterfaceCount);
+			}
+		}
+		return interfaceNames;
+	}
+	
+	protected char[] getSuperclassName(TypeDeclaration typeDeclaration) {
+		TypeReference superclass = typeDeclaration.superclass;
+		
+		if (superclass instanceof CompletionOnKeyword) return null;
+		if (CompletionUnitStructureRequestor.hasEmptyName(superclass, this.assistNode)) return null;
+				
+		return superclass != null ? CharOperation.concatWith(superclass.getParameterizedTypeName(), '.') : null;
+	}
+	
+	protected char[][] getThrownExceptions(AbstractMethodDeclaration methodDeclaration) {
+		char[][] thrownExceptionTypes = null;
+		TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;
+		if (thrownExceptions != null) {
+			int thrownExceptionLength = thrownExceptions.length;
+			int thrownExceptionCount = 0;
+			thrownExceptionTypes = new char[thrownExceptionLength][];
+			next : for (int i = 0; i < thrownExceptionLength; i++) {
+				TypeReference thrownException = thrownExceptions[i];
+				
+				if (thrownException instanceof CompletionOnKeyword) continue next;
+				if (CompletionUnitStructureRequestor.hasEmptyName(thrownException, this.assistNode)) continue next;
+				
+				thrownExceptionTypes[thrownExceptionCount++] = 
+					CharOperation.concatWith(thrownException.getParameterizedTypeName(), '.'); 
+			}
+			
+			if (thrownExceptionCount == 0) return null;
+			if (thrownExceptionCount < thrownExceptionLength) {
+				System.arraycopy(thrownExceptionTypes, 0, thrownExceptionTypes = new char[thrownExceptionCount][], 0, thrownExceptionCount);
+			}
+		}
+		return thrownExceptionTypes;
+	}
+	
+	protected char[][] getTypeParameterBounds(TypeParameter typeParameter) {
+		TypeReference firstBound = typeParameter.type;
+		TypeReference[] otherBounds = typeParameter.bounds;
+		char[][] typeParameterBounds = null;
+		if (firstBound != null) {
+			if (otherBounds != null) {
+				int otherBoundsLength = otherBounds.length;
+				char[][] boundNames = new char[otherBoundsLength+1][];
+				int boundCount = 0;
+				if (!CompletionUnitStructureRequestor.hasEmptyName(firstBound, this.assistNode)) {
+					boundNames[boundCount++] = CharOperation.concatWith(firstBound.getParameterizedTypeName(), '.');
+				}
+				for (int j = 0; j < otherBoundsLength; j++) {
+					TypeReference otherBound = otherBounds[j];
+					if (!CompletionUnitStructureRequestor.hasEmptyName(otherBound, this.assistNode)) {
+						boundNames[boundCount++] = 
+							CharOperation.concatWith(otherBound.getParameterizedTypeName(), '.');
+					}
+				}
+				
+				if (boundCount == 0) {
+					boundNames = CharOperation.NO_CHAR_CHAR;
+				} else if (boundCount < otherBoundsLength + 1){
+					System.arraycopy(boundNames, 0, boundNames = new char[boundCount][], 0, boundCount);
+				}
+				typeParameterBounds = boundNames;
+			} else {
+				if (!CompletionUnitStructureRequestor.hasEmptyName(firstBound, this.assistNode)) {
+					typeParameterBounds = new char[][] { CharOperation.concatWith(firstBound.getParameterizedTypeName(), '.')};
+				} else {
+					typeParameterBounds = CharOperation.NO_CHAR_CHAR;
+				}
+			}
+		} else {
+			typeParameterBounds = CharOperation.NO_CHAR_CHAR;
+		}
+		
+		return typeParameterBounds;
+	}
+	
+	protected void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration) {
+		if (methodDeclaration instanceof CompletionOnMethodReturnType) return;
+		if (methodDeclaration instanceof CompletionOnMethodTypeParameter) return;
+		if (methodDeclaration instanceof CompletionOnMethodName) return;
+		super.notifySourceElementRequestor(methodDeclaration);
+	}
+	
+	public void notifySourceElementRequestor(CompilationUnitDeclaration parsedUnit, int sourceStart, int sourceEnd, boolean reportReference, HashtableOfObjectToInt sourceEndsMap, Map nodesToCategoriesMap) {
+		super.notifySourceElementRequestor(parsedUnit, sourceStart, sourceEnd, reportReference, sourceEndsMap, nodesToCategoriesMap);
+	}
+	
+	protected void notifySourceElementRequestor(FieldDeclaration fieldDeclaration, TypeDeclaration declaringType) {
+		if (fieldDeclaration instanceof CompletionOnFieldType) return;
+		if (fieldDeclaration instanceof CompletionOnFieldName) return;
+		super.notifySourceElementRequestor(fieldDeclaration, declaringType);
+	}
+	
+	protected void notifySourceElementRequestor(ImportReference importReference, boolean isPackage) {
+		if (importReference instanceof CompletionOnKeyword2) return;
+		if (importReference instanceof CompletionOnImportReference ||
+				importReference instanceof CompletionOnPackageReference) {
+			if (importReference.tokens[importReference.tokens.length - 1].length == 0) return;
+		}
+		
+		super.notifySourceElementRequestor(importReference, isPackage);
+	}
+	
+	protected void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence, TypeDeclaration declaringType) {
+		if (typeDeclaration instanceof CompletionOnAnnotationOfType) return;
+		super.notifySourceElementRequestor(typeDeclaration, notifyTypePresence, declaringType);
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index aad1dee..c762395 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -23,8 +23,10 @@ import org.eclipse.jdt.core.IAccessRule;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IMethod;
 import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeRoot;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.Signature;
+import org.eclipse.jdt.core.WorkingCopyOwner;
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.compiler.IProblem;
@@ -288,7 +290,9 @@ public final class CompletionEngine
 	
 	long targetedElement;
 	
+	WorkingCopyOwner owner;
 	IJavaProject javaProject;
+	ITypeRoot typeRoot; 
 	CompletionParser parser;
 	CompletionRequestor requestor;
 	CompletionProblemFactory problemFactory;
@@ -398,7 +402,8 @@ public final class CompletionEngine
 			SearchableEnvironment nameEnvironment,
 			CompletionRequestor requestor,
 			Map settings,
-			IJavaProject javaProject) {
+			IJavaProject javaProject,
+			WorkingCopyOwner owner) {
 		super(settings);
 		this.javaProject = javaProject;
 		this.requestor = requestor;
@@ -413,7 +418,7 @@ public final class CompletionEngine
 		this.lookupEnvironment =
 			new LookupEnvironment(this, this.compilerOptions, this.problemReporter, nameEnvironment);
 		this.parser =
-			new CompletionParser(this.problemReporter);
+			new CompletionParser(this.problemReporter, this.requestor.isExtendedContextRequired());
 		this.nameScanner =
 			new Scanner(
 				false /*comment*/, 
@@ -423,6 +428,7 @@ public final class CompletionEngine
 				null /*taskTags*/, 
 				null/*taskPriorities*/,
 				true/*taskCaseSensitive*/);
+		this.owner = owner;
 	}
 
 	/**
@@ -859,9 +865,20 @@ public final class CompletionEngine
 	private void buildContext(
 			ASTNode astNode,
 			ASTNode astNodeParent,
+			CompilationUnitDeclaration compilationUnitDeclaration,
 			Binding qualifiedBinding,
 			Scope scope) {
 		CompletionContext context = new CompletionContext();
+		if (this.requestor.isExtendedContextRequired()) {
+			context.setExtendedData(
+					this.typeRoot,
+					compilationUnitDeclaration,
+					this.lookupEnvironment,
+					scope,
+					astNode,
+					this.owner,
+					this.parser);
+		}
 		
 		// build expected types context
 		if (this.expectedTypesPtr > -1) {
@@ -974,7 +991,14 @@ public final class CompletionEngine
 		}
 	}
 
-	private boolean complete(ASTNode astNode, ASTNode astNodeParent, ASTNode enclosingNode, Binding qualifiedBinding, Scope scope, boolean insideTypeAnnotation) {
+	private boolean complete(
+			ASTNode astNode,
+			ASTNode astNodeParent,
+			ASTNode enclosingNode,
+			CompilationUnitDeclaration compilationUnitDeclaration,
+			Binding qualifiedBinding,
+			Scope scope,
+			boolean insideTypeAnnotation) {
 
 		setSourceAndTokenRange(astNode.sourceStart, astNode.sourceEnd);
 
@@ -985,7 +1009,7 @@ public final class CompletionEngine
 			computeExpectedTypes(astNodeParent, astNode, scope);
 		}
 		
-		buildContext(astNode, astNodeParent, qualifiedBinding, scope);
+		buildContext(astNode, astNodeParent, compilationUnitDeclaration, qualifiedBinding, scope);
 		
 		if (astNode instanceof CompletionOnFieldType) {
 
@@ -2191,6 +2215,7 @@ public final class CompletionEngine
 									e.astNode,
 									this.parser.assistNodeParent,
 									this.parser.enclosingNode,
+									compilationUnit,
 									e.qualifiedBinding,
 									e.scope,
 									e.insideTypeAnnotation);
@@ -2290,7 +2315,7 @@ public final class CompletionEngine
 	 *      a position in the source where the completion is taking place. 
 	 *      This position is relative to the source provided.
 	 */
-	public void complete(ICompilationUnit sourceUnit, int completionPosition, int pos) {
+	public void complete(ICompilationUnit sourceUnit, int completionPosition, int pos, ITypeRoot root) {
 
 		if(DEBUG) {
 			System.out.print("COMPLETION IN "); //$NON-NLS-1$
@@ -2306,6 +2331,7 @@ public final class CompletionEngine
 			this.fileName = sourceUnit.getFileName();
 			this.actualCompletionPosition = completionPosition - 1;
 			this.offset = pos;
+			this.typeRoot = root;
 			// for now until we can change the UI.
 			CompilationResult result = new CompilationResult(sourceUnit, 1, 1, this.compilerOptions.maxProblemsPerUnit);
 			CompilationUnitDeclaration parsedUnit = this.parser.dietParse(sourceUnit, result, this.actualCompletionPosition);
@@ -2320,7 +2346,7 @@ public final class CompletionEngine
 				// scan the package & import statements first
 				if (parsedUnit.currentPackage instanceof CompletionOnPackageReference) {
 					contextAccepted = true;
-					this.buildContext(parsedUnit.currentPackage, null, null, null);
+					this.buildContext(parsedUnit.currentPackage, null, parsedUnit, null, null);
 					if(!this.requestor.isIgnored(CompletionProposal.PACKAGE_REF)) {
 						findPackages((CompletionOnPackageReference) parsedUnit.currentPackage);
 					}
@@ -2341,7 +2367,7 @@ public final class CompletionEngine
 							this.lookupEnvironment.buildTypeBindings(parsedUnit, null /*no access restriction*/);
 							if ((this.unitScope = parsedUnit.scope) != null) {
 								contextAccepted = true;
-								this.buildContext(importReference, null, null, null);
+								this.buildContext(importReference, null, parsedUnit, null, null);
 								
 								long positions = importReference.sourcePositions[importReference.sourcePositions.length - 1];
 								setSourceAndTokenRange((int) (positions >>> 32), (int) positions);
@@ -2389,7 +2415,7 @@ public final class CompletionEngine
 							return;
 						} else if(importReference instanceof CompletionOnKeyword) {
 							contextAccepted = true;
-							this.buildContext(importReference, null, null, null);
+							this.buildContext(importReference, null, parsedUnit, null, null);
 							if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
 								setSourceAndTokenRange(importReference.sourceStart, importReference.sourceEnd);
 								CompletionOnKeyword keyword = (CompletionOnKeyword)importReference;
@@ -2438,6 +2464,7 @@ public final class CompletionEngine
 									e.astNode,
 									this.parser.assistNodeParent,
 									this.parser.enclosingNode,
+									parsedUnit,
 									e.qualifiedBinding,
 									e.scope,
 									e.insideTypeAnnotation);
@@ -8710,7 +8737,7 @@ public final class CompletionEngine
 
 	protected void reset() {
 
-		super.reset();
+		super.reset(false);
 		this.knownPkgs = new HashtableOfObject(10);
 		this.knownTypes = new HashtableOfObject(10);
 	}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionUnitStructureRequestor.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionUnitStructureRequestor.java
new file mode 100644
index 0000000..839abfa
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionUnitStructureRequestor.java
@@ -0,0 +1,208 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist;
+
+import java.util.Map;
+
+import org.eclipse.jdt.core.IAnnotation;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IMemberValuePair;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnMarkerAnnotationName;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnMemberValueName;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnParameterizedQualifiedTypeReference;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnQualifiedNameReference;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnQualifiedTypeReference;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnSingleNameReference;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionOnSingleTypeReference;
+import org.eclipse.jdt.internal.codeassist.impl.AssistAnnotation;
+import org.eclipse.jdt.internal.codeassist.impl.AssistImportContainer;
+import org.eclipse.jdt.internal.codeassist.impl.AssistImportDeclaration;
+import org.eclipse.jdt.internal.codeassist.impl.AssistInitializer;
+import org.eclipse.jdt.internal.codeassist.impl.AssistPackageDeclaration;
+import org.eclipse.jdt.internal.codeassist.impl.AssistSourceField;
+import org.eclipse.jdt.internal.codeassist.impl.AssistSourceMethod;
+import org.eclipse.jdt.internal.codeassist.impl.AssistSourceType;
+import org.eclipse.jdt.internal.codeassist.impl.AssistTypeParameter;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
+import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.parser.Parser;
+import org.eclipse.jdt.internal.core.AnnotatableInfo;
+import org.eclipse.jdt.internal.core.Annotation;
+import org.eclipse.jdt.internal.core.CompilationUnit;
+import org.eclipse.jdt.internal.core.CompilationUnitElementInfo;
+import org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor;
+import org.eclipse.jdt.internal.core.ImportContainer;
+import org.eclipse.jdt.internal.core.ImportDeclaration;
+import org.eclipse.jdt.internal.core.Initializer;
+import org.eclipse.jdt.internal.core.JavaElement;
+import org.eclipse.jdt.internal.core.JavaModelManager;
+import org.eclipse.jdt.internal.core.PackageDeclaration;
+import org.eclipse.jdt.internal.core.SourceField;
+import org.eclipse.jdt.internal.core.SourceMethod;
+import org.eclipse.jdt.internal.core.SourceType;
+import org.eclipse.jdt.internal.core.TypeParameter;
+
+public class CompletionUnitStructureRequestor extends CompilationUnitStructureRequestor {
+	private ASTNode assistNode;
+	
+	private Map bindingCache;
+	private Map elementCache;
+	
+	public CompletionUnitStructureRequestor(
+			ICompilationUnit unit,
+			CompilationUnitElementInfo unitInfo,
+			Parser parser,
+			ASTNode assistNode,
+			Map bindingCache,
+			Map elementCache,
+			Map newElements) {
+		super(unit, unitInfo, newElements);
+		this.parser = parser;
+		this.assistNode = assistNode;
+		this.bindingCache = bindingCache;
+		this.elementCache = elementCache;
+	}
+	
+	protected Annotation createAnnotation(JavaElement parent, String name) {
+		return new AssistAnnotation(parent, name, this.newElements);
+	}
+
+	protected SourceField createField(JavaElement parent, FieldInfo fieldInfo) {
+		String fieldName = JavaModelManager.getJavaModelManager().intern(new String(fieldInfo.name));
+		AssistSourceField field = new AssistSourceField(parent, fieldName, this.bindingCache, this.newElements);
+		if (fieldInfo.node.binding != null) {
+			this.bindingCache.put(field, fieldInfo.node.binding);
+			this.elementCache.put(fieldInfo.node.binding, field);
+		}
+		return field;
+	}
+
+	protected ImportContainer createImportContainer(ICompilationUnit parent) {
+		return new AssistImportContainer((CompilationUnit)parent, this.newElements);
+	}
+
+	protected ImportDeclaration createImportDeclaration(ImportContainer parent, String name, boolean onDemand) {
+		return new AssistImportDeclaration(parent, name, onDemand, this.newElements);
+	}
+
+	protected Initializer createInitializer(JavaElement parent) {
+		return new AssistInitializer(parent, 1, this.bindingCache, this.newElements);
+	}
+
+	protected SourceMethod createMethod(JavaElement parent, MethodInfo methodInfo) {
+		String selector = JavaModelManager.getJavaModelManager().intern(new String(methodInfo.name));
+		String[] parameterTypeSigs = convertTypeNamesToSigs(methodInfo.parameterTypes);
+		AssistSourceMethod method = new AssistSourceMethod(parent, selector, parameterTypeSigs, this.bindingCache, this.newElements);
+		if (methodInfo.node.binding != null) {
+			this.bindingCache.put(method, methodInfo.node.binding);
+			this.elementCache.put(methodInfo.node.binding, method);
+		}
+		return method;
+	}
+
+	protected PackageDeclaration createPackageDeclaration(JavaElement parent, String name) {
+		return new AssistPackageDeclaration((CompilationUnit) parent, name, this.newElements);
+	}
+	
+	protected SourceType createType(JavaElement parent, TypeInfo typeInfo) {
+		String nameString= new String(typeInfo.name);
+		AssistSourceType type = new AssistSourceType(parent, nameString, this.bindingCache, this.newElements);
+		if (typeInfo.node.binding != null) {
+			this.bindingCache.put(type, typeInfo.node.binding);
+			this.elementCache.put(typeInfo.node.binding, type);
+		}
+		return type;
+	}
+	
+	protected TypeParameter createTypeParameter(JavaElement parent, String name) {
+		return new AssistTypeParameter(parent, name, this.newElements);
+	}
+	
+	protected IAnnotation enterAnnotation(
+			org.eclipse.jdt.internal.compiler.ast.Annotation annotation,
+			AnnotatableInfo parentInfo,
+			JavaElement parentHandle) {
+		if (annotation instanceof CompletionOnMarkerAnnotationName) {
+			if (hasEmptyName(annotation.type, assistNode)) {
+				super.enterAnnotation(annotation, null, parentHandle);
+				return null;
+			}
+		}
+		return super.enterAnnotation(annotation, parentInfo, parentHandle);
+	}
+	
+	protected Object getMemberValue(
+			org.eclipse.jdt.internal.core.MemberValuePair memberValuePair,
+			Expression expression) {
+		if (expression instanceof CompletionOnSingleNameReference) {
+			CompletionOnSingleNameReference reference = (CompletionOnSingleNameReference) expression;
+			if (reference.token.length == 0) return null;
+		} else if (expression instanceof CompletionOnQualifiedNameReference) {
+			CompletionOnQualifiedNameReference reference = (CompletionOnQualifiedNameReference) expression;
+			if (reference.tokens[reference.tokens.length - 1].length == 0) return null;
+		}
+		return super.getMemberValue(memberValuePair, expression);
+	}
+	protected IMemberValuePair[] getMemberValuePairs(MemberValuePair[] memberValuePairs) {
+		int membersLength = memberValuePairs.length;
+		int membersCount = 0;
+		IMemberValuePair[] members = new IMemberValuePair[membersLength];
+		next : for (int j = 0; j < membersLength; j++) {
+			if (memberValuePairs[j] instanceof CompletionOnMemberValueName) continue next;
+			
+			members[membersCount++] = getMemberValuePair(memberValuePairs[j]);
+		}
+		
+		if (membersCount > membersLength) {
+			System.arraycopy(members, 0, members, 0, membersCount);
+		}
+		return members;
+	}
+
+	protected static boolean hasEmptyName(TypeReference reference, ASTNode assistNode) {
+		if (reference == null) return false;
+		
+		if (reference.sourceStart <= assistNode.sourceStart && assistNode.sourceEnd <= reference.sourceEnd) return false;
+		
+		if (reference instanceof CompletionOnSingleTypeReference ||
+				reference instanceof CompletionOnQualifiedTypeReference ||
+				reference instanceof CompletionOnParameterizedQualifiedTypeReference) {
+			char[][] typeName = reference.getTypeName();
+			if (typeName[typeName.length - 1].length == 0) return true;
+		}
+		if (reference instanceof ParameterizedSingleTypeReference) {
+			ParameterizedSingleTypeReference parameterizedReference = (ParameterizedSingleTypeReference) reference;
+			TypeReference[] typeArguments = parameterizedReference.typeArguments;
+			if (typeArguments != null) {
+				for (int i = 0; i < typeArguments.length; i++) {
+					if (hasEmptyName(typeArguments[i], assistNode)) return true;
+				}
+			}
+		} else if (reference instanceof ParameterizedQualifiedTypeReference) {
+			ParameterizedQualifiedTypeReference parameterizedReference = (ParameterizedQualifiedTypeReference) reference;
+			TypeReference[][] typeArguments = parameterizedReference.typeArguments;
+			if (typeArguments != null) {
+				for (int i = 0; i < typeArguments.length; i++) {
+					if (typeArguments[i] != null) {
+						for (int j = 0; j < typeArguments[i].length; j++) {
+							if (hasEmptyName(typeArguments[i][j], assistNode)) return true;
+						}
+					}
+				}
+			}
+		}
+		return false;
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalCompletionContext.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalCompletionContext.java
index c3249ef..918d932 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalCompletionContext.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalCompletionContext.java
@@ -10,6 +10,14 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.codeassist;
 
+import org.eclipse.jdt.core.ITypeRoot;
+import org.eclipse.jdt.core.WorkingCopyOwner;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionParser;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+import org.eclipse.jdt.internal.compiler.lookup.Scope;
+
 
 /**
  * Internal completion context
@@ -27,12 +35,34 @@ public class InternalCompletionContext {
 	protected int tokenKind;
 	protected int tokenLocation;
 	
+	protected InternalExtendedCompletionContext extendedContext;
+	
+	protected void setExpectedTypesKeys(char[][] expectedTypesKeys) {
+		this.expectedTypesKeys = expectedTypesKeys;
+	}
+	
 	protected void setExpectedTypesSignatures(char[][] expectedTypesSignatures) {
 		this.expectedTypesSignatures = expectedTypesSignatures;
 	}
 	
-	protected void setExpectedTypesKeys(char[][] expectedTypesKeys) {
-		this.expectedTypesKeys = expectedTypesKeys;
+	protected void setExtendedData(
+			ITypeRoot typeRoot,
+			CompilationUnitDeclaration compilationUnitDeclaration,
+			LookupEnvironment lookupEnvironment,
+			Scope scope,
+			ASTNode astNode,
+			WorkingCopyOwner owner,
+			CompletionParser parser) {
+		this.extendedContext =
+			new InternalExtendedCompletionContext(
+					this,
+					typeRoot,
+					compilationUnitDeclaration,
+					lookupEnvironment,
+					scope,
+					astNode,
+					owner,
+					parser);
 	}
 
 	protected void setJavadoc(int javadoc) {
@@ -42,10 +72,23 @@ public class InternalCompletionContext {
 	protected void setOffset(int offset) {
 		this.offset = offset;
 	}
+
+	protected void setToken(char[] token) {
+		this.token = token;
+	}
+
+	protected void setTokenKind(int tokenKind) {
+		this.tokenKind = tokenKind;
+	}
 	
+	protected void setTokenLocation(int tokenLocation) {
+		this.tokenLocation = tokenLocation;
+	}
+
 	protected void setTokenRange(int start, int end) {
 		this.setTokenRange(start, end, -1);
 	}
+
 	protected void setTokenRange(int start, int end, int endOfEmptyToken) {
 		this.tokenStart = start;
 		this.tokenEnd = endOfEmptyToken > end ? endOfEmptyToken : end;
@@ -57,16 +100,4 @@ public class InternalCompletionContext {
 			this.tokenEnd = 0;
 		}
 	}
-	
-	protected void setToken(char[] token) {
-		this.token = token;
-	}
-	
-	protected void setTokenKind(int tokenKind) {
-		this.tokenKind = tokenKind;
-	}
-	
-	protected void setTokenLocation(int tokenLocation) {
-		this.tokenLocation = tokenLocation;
-	}
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
new file mode 100644
index 0000000..aa5d242
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/InternalExtendedCompletionContext.java
@@ -0,0 +1,793 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IInitializer;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.ISourceRange;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeRoot;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.WorkingCopyOwner;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.codeassist.complete.CompletionParser;
+import org.eclipse.jdt.internal.codeassist.impl.AssistCompilationUnit;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Initializer;
+import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
+import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
+import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ImportBinding;
+import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
+import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
+import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.SignatureWrapper;
+import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
+import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
+import org.eclipse.jdt.internal.compiler.util.ObjectVector;
+import org.eclipse.jdt.internal.core.CompilationUnitElementInfo;
+import org.eclipse.jdt.internal.core.JavaElement;
+import org.eclipse.jdt.internal.core.LocalVariable;
+import org.eclipse.jdt.internal.core.util.Util;
+
+public class InternalExtendedCompletionContext {
+	private static Util.BindingsToNodesMap EmptyNodeMap = new Util.BindingsToNodesMap() {
+		public ASTNode get(Binding binding) {
+			return null;
+		}
+	};
+	
+	private InternalCompletionContext completionContext;
+	
+	// static data
+	private ITypeRoot typeRoot;
+	private CompilationUnitDeclaration compilationUnitDeclaration;
+	private LookupEnvironment lookupEnvironment;
+	private Scope assistScope;
+	private ASTNode assistNode;
+	private WorkingCopyOwner owner;
+	
+	private CompletionParser parser;
+	
+	// computed data
+	private boolean hasComputedVisibleElementBindings;
+	private ObjectVector visibleLocalVariables;
+	private ObjectVector visibleFields;
+	private ObjectVector visibleMethods;
+	
+	private boolean hasComputedEnclosingJavaElements;
+	Map bindingsToNodes;
+	private Map bindingsToHandles;
+	private ICompilationUnit compilationUnit;
+	
+	public InternalExtendedCompletionContext(
+			InternalCompletionContext completionContext,
+			ITypeRoot typeRoot,
+			CompilationUnitDeclaration compilationUnitDeclaration,
+			LookupEnvironment lookupEnvironment,
+			Scope assistScope,
+			ASTNode assistNode,
+			WorkingCopyOwner owner,
+			CompletionParser parser) {
+		this.completionContext = completionContext;
+		this.typeRoot = typeRoot;
+		this.compilationUnitDeclaration = compilationUnitDeclaration;
+		this.lookupEnvironment = lookupEnvironment;
+		this.assistScope = assistScope;
+		this.assistNode = assistNode;
+		this.owner = owner;
+		this.parser = parser;
+	}
+	
+	private void computeEnclosingJavaElements() {
+		this.hasComputedEnclosingJavaElements = true;
+		
+		if (this.typeRoot == null) return;
+		
+		if (this.typeRoot.getElementType() == IJavaElement.COMPILATION_UNIT) {
+	 		ICompilationUnit original = (org.eclipse.jdt.core.ICompilationUnit)this.typeRoot;
+			
+			HashMap handleToBinding = new HashMap();
+			HashMap bindingToHandle = new HashMap();
+			HashMap handleToInfo = new HashMap();
+			
+			org.eclipse.jdt.core.ICompilationUnit handle = new AssistCompilationUnit(original, this.owner, handleToBinding, handleToInfo);
+			CompilationUnitElementInfo info = new CompilationUnitElementInfo();
+			
+			handleToInfo.put(handle, info);
+			
+			CompletionUnitStructureRequestor structureRequestor = 
+				new CompletionUnitStructureRequestor(
+						handle,
+						info,
+						this.parser,
+						this.assistNode,
+						handleToBinding,
+						bindingToHandle,
+						handleToInfo);
+			
+			CompletionElementNotifier notifier =
+				new CompletionElementNotifier(
+						structureRequestor,
+						true,
+						this.assistNode);
+			
+			notifier.notifySourceElementRequestor(
+					this.compilationUnitDeclaration,
+					this.compilationUnitDeclaration.sourceStart,
+					this.compilationUnitDeclaration.sourceEnd,
+					false,
+					this.parser.sourceEnds,
+					new HashMap());
+			
+			this.bindingsToHandles = bindingToHandle;
+			this.compilationUnit = handle;
+		}
+	}
+	
+	private void computeVisibleElementBindings() {
+		this.hasComputedVisibleElementBindings = true;
+		
+		Scope scope = this.assistScope;
+		ASTNode astNode = this.assistNode;
+		boolean notInJavadoc = this.completionContext.javadoc == 0;
+		
+		this.visibleLocalVariables = new ObjectVector();
+		this.visibleFields = new ObjectVector();
+		this.visibleMethods = new ObjectVector();
+		this.bindingsToNodes = new HashMap();
+		
+		ReferenceContext referenceContext = scope.referenceContext();
+		if (referenceContext instanceof AbstractMethodDeclaration) {
+			// completion is inside a method body
+			searchVisibleVariablesAndMethods(scope, visibleLocalVariables, visibleFields, visibleMethods, notInJavadoc);
+		} else if (referenceContext instanceof TypeDeclaration) {
+			TypeDeclaration typeDeclaration = (TypeDeclaration) referenceContext;
+			FieldDeclaration[] fields = typeDeclaration.fields;
+			if (fields != null) {
+				done : for (int i = 0; i < fields.length; i++) {
+					if (fields[i] instanceof Initializer) {
+						Initializer initializer = (Initializer) fields[i];
+						if (initializer.block.sourceStart <= astNode.sourceStart &&
+								astNode.sourceStart < initializer.bodyEnd) {
+							// completion is inside an initializer
+							searchVisibleVariablesAndMethods(scope, visibleLocalVariables, visibleFields, visibleMethods, notInJavadoc);
+							break done;
+						}
+					} else {
+						FieldDeclaration fieldDeclaration = fields[i];
+						if (fieldDeclaration.initialization != null && 
+								fieldDeclaration.initialization.sourceStart <= astNode.sourceStart &&
+								astNode.sourceEnd <= fieldDeclaration.initialization.sourceEnd) {
+							// completion is inside a field initializer
+							searchVisibleVariablesAndMethods(scope, visibleLocalVariables, visibleFields, visibleMethods, notInJavadoc);
+							break done;
+						}  
+					}
+				}
+			}
+		}
+	}
+	
+	public IJavaElement getEnclosingElement() {
+		try {
+			if (!this.hasComputedEnclosingJavaElements) {
+				this.computeEnclosingJavaElements();
+			}
+			if (this.compilationUnit == null) return null;
+			IJavaElement enclosingElement = compilationUnit.getElementAt(this.completionContext.offset);
+			return enclosingElement == null ? this.compilationUnit : enclosingElement;
+		} catch (JavaModelException e) {
+			Util.log(e, "Cannot compute enclosing element"); //$NON-NLS-1$
+			return null;
+		}
+	}
+	
+	private JavaElement getJavaElement(LocalVariableBinding binding) {
+		LocalDeclaration local = binding.declaration;
+		
+		JavaElement parent = null;
+		ReferenceContext referenceContext = binding.declaringScope.referenceContext();
+		if (referenceContext instanceof AbstractMethodDeclaration) {
+			AbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) referenceContext;
+			parent = this.getJavaElementOfCompilationUnit(methodDeclaration.binding);
+		} else if (referenceContext instanceof TypeDeclaration){
+			// Local variable is declared inside an initializer
+			TypeDeclaration typeDeclaration = (TypeDeclaration) referenceContext;
+			
+			IType type = (IType)this.getJavaElementOfCompilationUnit(typeDeclaration.binding);
+			if (type != null) {
+				try {
+					IInitializer[] initializers = type.getInitializers();
+					if (initializers != null) {
+						done : for (int i = 0; i < initializers.length; i++) {
+							IInitializer initializer = initializers[i];
+							ISourceRange sourceRange = initializer.getSourceRange();
+							if (sourceRange != null) {
+								int initializerStart = sourceRange.getOffset();
+								int initializerEnd = initializerStart + sourceRange.getLength();
+								if (initializerStart <= local.sourceStart &&
+										local.sourceEnd <= initializerEnd) {
+									parent = (JavaElement)initializer;
+									break done;
+								}
+							}
+						}
+					}
+				} catch (JavaModelException e) {
+					return null;
+				}
+			}
+		}
+		if (parent == null) return null;
+		
+		return new LocalVariable(
+				parent,
+				new String(local.name),
+				local.declarationSourceStart,
+				local.declarationSourceEnd,
+				local.sourceStart,
+				local.sourceEnd,
+				Util.typeSignature(local.type),
+				binding.declaration.annotations);
+	}
+	
+	private JavaElement getJavaElementOfCompilationUnit(Binding binding) {
+		if (!this.hasComputedEnclosingJavaElements) {
+			computeEnclosingJavaElements();
+		}
+		if (this.bindingsToHandles == null) return null;
+		return (JavaElement)this.bindingsToHandles.get(binding);
+	}
+	
+	private TypeBinding getTypeFromSignature(String typeSignature, Scope scope) {
+		TypeBinding assignableTypeBinding = null;
+		
+		TypeVariableBinding[] typeVariables = Binding.NO_TYPE_VARIABLES;
+		ReferenceContext referenceContext = scope.referenceContext();
+		if (referenceContext instanceof AbstractMethodDeclaration) {
+			AbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) referenceContext;
+			typeVariables = methodDeclaration.binding.typeVariables;
+		}
+		
+		CompilationUnitDeclaration previousUnitBeingCompleted = lookupEnvironment.unitBeingCompleted;
+		lookupEnvironment.unitBeingCompleted = this.compilationUnitDeclaration;
+		try {
+			
+			SignatureWrapper wrapper = new SignatureWrapper(typeSignature.toCharArray());
+			assignableTypeBinding = lookupEnvironment.getTypeFromTypeSignature(wrapper, typeVariables, this.assistScope.enclosingClassScope().referenceContext.binding, null);
+			if (assignableTypeBinding instanceof ReferenceBinding) {
+				assignableTypeBinding = BinaryTypeBinding.resolveType((ReferenceBinding)assignableTypeBinding, lookupEnvironment, true);
+			}
+		} catch (AbortCompilation e) {
+			assignableTypeBinding = null;
+		} finally {
+			lookupEnvironment.unitBeingCompleted = previousUnitBeingCompleted;
+		}
+		return assignableTypeBinding;
+	}
+	
+	public IJavaElement[] getVisibleElements(String typeSignature) {
+		if (this.assistScope == null) return new IJavaElement[0];
+		
+		if (!this.hasComputedVisibleElementBindings) {
+			this.computeVisibleElementBindings();
+		}
+		
+		TypeBinding assignableTypeBinding = null;
+		if (typeSignature != null) {
+			assignableTypeBinding = this.getTypeFromSignature(typeSignature, this.assistScope);
+			if (assignableTypeBinding == null) return new IJavaElement[0];
+		}
+		 
+		int length = visibleLocalVariables.size() + visibleFields.size() + visibleMethods.size();
+		if (length == 0) return new IJavaElement[0];
+		
+		IJavaElement[] result = new IJavaElement[length];
+		
+		int elementCount = 0;
+		
+		int size = visibleLocalVariables.size();
+		if (size > 0) {
+			next : for (int i = 0; i < size; i++) {
+				LocalVariableBinding binding = (LocalVariableBinding) visibleLocalVariables.elementAt(i);
+				if (assignableTypeBinding != null && !binding.type.isCompatibleWith(assignableTypeBinding)) continue next;
+				result[elementCount++] = getJavaElement(binding);
+			}
+		
+		}
+		size = visibleFields.size();
+		if (size > 0) {
+			next : for (int i = 0; i < size; i++) {
+				FieldBinding binding = (FieldBinding) visibleFields.elementAt(i);
+				if (assignableTypeBinding != null && !binding.type.isCompatibleWith(assignableTypeBinding)) continue next;
+				if (this.assistScope.isDefinedInSameUnit(binding.declaringClass)) {
+					JavaElement field = getJavaElementOfCompilationUnit(binding);
+					if (field != null) result[elementCount++] = field;
+				} else {
+					JavaElement field = Util.getUnresolvedJavaElement(binding, owner, EmptyNodeMap);
+					if (field != null) result[elementCount++] = field.resolved(binding);
+				}
+			}
+		
+		}
+		size = visibleMethods.size();
+		if (size > 0) {
+			next : for (int i = 0; i < size; i++) {
+				MethodBinding binding = (MethodBinding) visibleMethods.elementAt(i);
+				if (assignableTypeBinding != null && !binding.returnType.isCompatibleWith(assignableTypeBinding)) continue next;
+				if (this.assistScope.isDefinedInSameUnit(binding.declaringClass)) {
+					JavaElement method = getJavaElementOfCompilationUnit(binding);
+					if (method != null) result[elementCount++] = method;
+				} else {
+					JavaElement method = Util.getUnresolvedJavaElement(binding, owner, EmptyNodeMap);
+					if (method != null) result[elementCount++] = method.resolved(binding);
+				}
+				
+			}
+		}
+		
+		if (elementCount != result.length) {
+			System.arraycopy(result, 0, result = new IJavaElement[elementCount], 0, elementCount);
+		}
+
+		return result;
+	}
+	
+	private void searchVisibleFields(
+			FieldBinding[] fields,
+			ReferenceBinding receiverType,
+			Scope scope,
+			InvocationSite invocationSite,
+			Scope invocationScope,
+			boolean onlyStaticFields,
+			ObjectVector localsFound,
+			ObjectVector fieldsFound) {
+		ObjectVector newFieldsFound = new ObjectVector();
+		// Inherited fields which are hidden by subclasses are filtered out
+		// No visibility checks can be performed without the scope & invocationSite
+		
+		next : for (int f = fields.length; --f >= 0;) {			
+			FieldBinding field = fields[f];
+
+			if (field.isSynthetic()) continue next;
+			
+			if (onlyStaticFields && !field.isStatic()) continue next;
+			
+			if (!field.canBeSeenBy(receiverType, invocationSite, scope)) continue next;
+			
+			for (int i = fieldsFound.size; --i >= 0;) {
+				FieldBinding otherField = (FieldBinding) fieldsFound.elementAt(i);
+				if (CharOperation.equals(field.name, otherField.name, true)) {
+					continue next;
+				}
+			}
+
+			for (int l = localsFound.size; --l >= 0;) {
+				LocalVariableBinding local = (LocalVariableBinding) localsFound.elementAt(l);	
+
+				if (CharOperation.equals(field.name, local.name, true)) {
+					continue next;
+				}
+			}
+			
+			newFieldsFound.add(field);
+		}
+		
+		fieldsFound.addAll(newFieldsFound);
+	}
+	
+	private void searchVisibleFields(
+			ReferenceBinding receiverType,
+			Scope scope,
+			InvocationSite invocationSite,
+			Scope invocationScope,
+			boolean onlyStaticFields,
+			boolean notInJavadoc,
+			ObjectVector localsFound,
+			ObjectVector fieldsFound) {
+
+		ReferenceBinding currentType = receiverType;
+		ReferenceBinding[] interfacesToVisit = null;
+		int nextPosition = 0;
+		do {
+			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
+			if (notInJavadoc && itsInterfaces != Binding.NO_SUPERINTERFACES) {
+				if (interfacesToVisit == null) {
+					interfacesToVisit = itsInterfaces;
+					nextPosition = interfacesToVisit.length;
+				} else {
+					int itsLength = itsInterfaces.length;
+					if (nextPosition + itsLength >= interfacesToVisit.length)
+						System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);
+					nextInterface : for (int a = 0; a < itsLength; a++) {
+						ReferenceBinding next = itsInterfaces[a];
+						for (int b = 0; b < nextPosition; b++)
+							if (next == interfacesToVisit[b]) continue nextInterface;
+						interfacesToVisit[nextPosition++] = next;
+					}
+				}
+			}
+
+			FieldBinding[] fields = currentType.availableFields();
+			if(fields != null && fields.length > 0) {
+				
+				searchVisibleFields(
+						fields,
+						receiverType,
+						scope,
+						invocationSite,
+						invocationScope,
+						onlyStaticFields,
+						localsFound,
+						fieldsFound);
+			}
+			currentType = currentType.superclass();
+		} while (notInJavadoc && currentType != null);
+
+		if (notInJavadoc && interfacesToVisit != null) {
+			for (int i = 0; i < nextPosition; i++) {
+				ReferenceBinding anInterface = interfacesToVisit[i];
+				FieldBinding[] fields = anInterface.availableFields();
+				if(fields !=  null) {
+					searchVisibleFields(
+							fields,
+							receiverType,
+							scope,
+							invocationSite,
+							invocationScope,
+							onlyStaticFields,
+							localsFound,
+							fieldsFound);
+				}
+
+				ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
+				if (itsInterfaces != Binding.NO_SUPERINTERFACES) {
+					int itsLength = itsInterfaces.length;
+					if (nextPosition + itsLength >= interfacesToVisit.length)
+						System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);
+					nextInterface : for (int a = 0; a < itsLength; a++) {
+						ReferenceBinding next = itsInterfaces[a];
+						for (int b = 0; b < nextPosition; b++)
+							if (next == interfacesToVisit[b]) continue nextInterface;
+						interfacesToVisit[nextPosition++] = next;
+					}
+				}
+			}
+		}
+	}
+
+	private void searchVisibleInterfaceMethods(
+			ReferenceBinding[] itsInterfaces,
+			ReferenceBinding receiverType,
+			Scope scope,
+			InvocationSite invocationSite,
+			Scope invocationScope,
+			boolean onlyStaticMethods,
+			ObjectVector methodsFound) {
+		if (itsInterfaces != Binding.NO_SUPERINTERFACES) {
+			ReferenceBinding[] interfacesToVisit = itsInterfaces;
+			int nextPosition = interfacesToVisit.length;
+
+			for (int i = 0; i < nextPosition; i++) {
+				ReferenceBinding currentType = interfacesToVisit[i];
+				MethodBinding[] methods = currentType.availableMethods();
+				if(methods != null) {
+					searchVisibleLocalMethods(
+							methods,
+							receiverType,
+							scope,
+							invocationSite,
+							invocationScope,
+							onlyStaticMethods,
+							methodsFound);
+				}
+
+				itsInterfaces = currentType.superInterfaces();
+				if (itsInterfaces != null && itsInterfaces != Binding.NO_SUPERINTERFACES) {
+					int itsLength = itsInterfaces.length;
+					if (nextPosition + itsLength >= interfacesToVisit.length)
+						System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);
+					nextInterface : for (int a = 0; a < itsLength; a++) {
+						ReferenceBinding next = itsInterfaces[a];
+						for (int b = 0; b < nextPosition; b++)
+							if (next == interfacesToVisit[b]) continue nextInterface;
+						interfacesToVisit[nextPosition++] = next;
+					}
+				}
+			}
+		}
+	}
+	
+	private void searchVisibleLocalMethods(
+			MethodBinding[] methods,
+			ReferenceBinding receiverType,
+			Scope scope,
+			InvocationSite invocationSite,
+			Scope invocationScope,
+			boolean onlyStaticMethods,
+			ObjectVector methodsFound) {
+		ObjectVector newMethodsFound =  new ObjectVector();
+		// Inherited methods which are hidden by subclasses are filtered out
+		// No visibility checks can be performed without the scope & invocationSite
+
+		next : for (int f = methods.length; --f >= 0;) {
+			MethodBinding method = methods[f];
+
+			if (method.isSynthetic()) continue next;
+
+			if (method.isDefaultAbstract())	continue next;
+
+			if (method.isConstructor()) continue next;
+			
+			if (onlyStaticMethods && !method.isStatic()) continue next;
+
+			if (!method.canBeSeenBy(receiverType, invocationSite, scope)) continue next;
+			
+			for (int i = methodsFound.size; --i >= 0;) {
+				MethodBinding otherMethod = (MethodBinding) methodsFound.elementAt(i);
+				if (method == otherMethod)
+					continue next;
+				
+				if (CharOperation.equals(method.selector, otherMethod.selector, true)) {
+					if (this.lookupEnvironment.methodVerifier().isMethodSubsignature(otherMethod, method)) {
+						continue next;
+					}
+				}
+			}
+
+			newMethodsFound.add(method);
+		}
+		
+		methodsFound.addAll(newMethodsFound);
+	}
+	
+	private void searchVisibleMethods(
+			ReferenceBinding receiverType,
+			Scope scope,
+			InvocationSite invocationSite,
+			Scope invocationScope,
+			boolean onlyStaticMethods,
+			boolean notInJavadoc,
+			ObjectVector methodsFound) {
+		ReferenceBinding currentType = receiverType;
+		if (notInJavadoc) {
+			if (receiverType.isInterface()) {
+				searchVisibleInterfaceMethods(
+						new ReferenceBinding[]{currentType},
+						receiverType,
+						scope,
+						invocationSite,
+						invocationScope,
+						onlyStaticMethods,
+						methodsFound);
+				
+				currentType = scope.getJavaLangObject();
+			}
+		}
+		boolean hasPotentialDefaultAbstractMethods = true;
+		while (currentType != null) {
+			
+			MethodBinding[] methods = currentType.availableMethods();
+			if (methods != null) {
+				searchVisibleLocalMethods(
+						methods,
+						receiverType,
+						scope,
+						invocationSite,
+						invocationScope,
+						onlyStaticMethods,
+						methodsFound);
+			}
+			
+			if (notInJavadoc &&
+					hasPotentialDefaultAbstractMethods &&
+					(currentType.isAbstract() ||
+							currentType.isTypeVariable() ||
+							currentType.isIntersectionType() ||
+							currentType.isEnum())){
+				
+				ReferenceBinding[] superInterfaces = currentType.superInterfaces();
+				if (superInterfaces != null && currentType.isIntersectionType()) {
+					for (int i = 0; i < superInterfaces.length; i++) {
+						superInterfaces[i] = (ReferenceBinding)superInterfaces[i].capture(invocationScope, invocationSite.sourceEnd());
+					}
+				}
+				
+				searchVisibleInterfaceMethods(
+						superInterfaces,
+						receiverType,
+						scope,
+						invocationSite,
+						invocationScope,
+						onlyStaticMethods,
+						methodsFound);
+			} else {
+				hasPotentialDefaultAbstractMethods = false;
+			}
+			if(currentType.isParameterizedType()) {
+				currentType = ((ParameterizedTypeBinding)currentType).genericType().superclass();
+			} else {
+				currentType = currentType.superclass();
+			}
+		}
+	}
+	private void searchVisibleVariablesAndMethods(
+			Scope scope,
+			ObjectVector localsFound,
+			ObjectVector fieldsFound,
+			ObjectVector methodsFound,
+			boolean notInJavadoc) {
+		
+		InvocationSite invocationSite = CompletionEngine.FakeInvocationSite;
+		
+		boolean staticsOnly = false;
+		// need to know if we're in a static context (or inside a constructor)
+
+		Scope currentScope = scope;
+		
+		done1 : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
+
+			switch (currentScope.kind) {
+
+				case Scope.METHOD_SCOPE :
+					// handle the error case inside an explicit constructor call (see MethodScope>>findField)
+					MethodScope methodScope = (MethodScope) currentScope;
+					staticsOnly |= methodScope.isStatic | methodScope.isConstructorCall;
+
+				case Scope.BLOCK_SCOPE :
+					BlockScope blockScope = (BlockScope) currentScope;
+
+					next : for (int i = 0, length = blockScope.locals.length; i < length; i++) {
+						LocalVariableBinding local = blockScope.locals[i];
+
+						if (local == null)
+							break next;
+
+						if (local.isSecret())
+							continue next;
+
+						for (int f = 0; f < localsFound.size; f++) {
+							LocalVariableBinding otherLocal =
+								(LocalVariableBinding) localsFound.elementAt(f);
+							if (CharOperation.equals(otherLocal.name, local.name, true))
+								continue next;
+						}
+						
+						localsFound.add(local);
+					}
+					break;
+
+				case Scope.COMPILATION_UNIT_SCOPE :
+					break done1;
+			}
+			currentScope = currentScope.parent;
+		}
+		
+		staticsOnly = false;
+		currentScope = scope;
+		
+		done2 : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
+
+			switch (currentScope.kind) {
+				case Scope.METHOD_SCOPE :
+					// handle the error case inside an explicit constructor call (see MethodScope>>findField)
+					MethodScope methodScope = (MethodScope) currentScope;
+					staticsOnly |= methodScope.isStatic | methodScope.isConstructorCall;
+					break;
+				case Scope.CLASS_SCOPE :
+					ClassScope classScope = (ClassScope) currentScope;
+					SourceTypeBinding enclosingType = classScope.referenceContext.binding;
+					
+					searchVisibleFields(
+							enclosingType,
+							classScope,
+							invocationSite,
+							scope,
+							staticsOnly,
+							notInJavadoc,
+							localsFound,
+							fieldsFound);
+					
+					searchVisibleMethods(
+							enclosingType,
+							classScope,
+							invocationSite,
+							scope,
+							staticsOnly,
+							notInJavadoc,
+							methodsFound);
+					
+					staticsOnly |= enclosingType.isStatic();
+					break;
+
+				case Scope.COMPILATION_UNIT_SCOPE :
+					break done2;
+			}
+			currentScope = currentScope.parent;
+		}
+		
+		// search in static import
+		ImportBinding[] importBindings = scope.compilationUnitScope().imports;
+		for (int i = 0; i < importBindings.length; i++) {
+			ImportBinding importBinding = importBindings[i];
+			if(importBinding.isValidBinding() && importBinding.isStatic()) {
+				Binding binding = importBinding.resolvedImport;
+				if(binding != null && binding.isValidBinding()) {
+					if(importBinding.onDemand) {
+						if((binding.kind() & Binding.TYPE) != 0) {
+							searchVisibleFields(
+									(ReferenceBinding)binding,
+									scope,
+									invocationSite,
+									scope,
+									staticsOnly,
+									notInJavadoc,
+									localsFound,
+									fieldsFound);
+							
+							searchVisibleMethods(
+									(ReferenceBinding)binding,
+									scope,
+									invocationSite,
+									scope,
+									staticsOnly,
+									notInJavadoc,
+									methodsFound);
+						}
+					} else {
+						if ((binding.kind() & Binding.FIELD) != 0) {
+							searchVisibleFields(
+									new FieldBinding[]{(FieldBinding)binding},
+									((FieldBinding)binding).declaringClass,
+									scope,
+									invocationSite,
+									scope,
+									staticsOnly,
+									localsFound,
+									fieldsFound);
+						} else if ((binding.kind() & Binding.METHOD) != 0) {
+							MethodBinding methodBinding = (MethodBinding)binding;
+							
+							searchVisibleLocalMethods(
+									methodBinding.declaringClass.getMethods(methodBinding.selector),
+									methodBinding.declaringClass,
+									scope,
+									invocationSite,
+									scope,
+									true,
+									methodsFound);
+						}
+					}
+				}
+			}
+		}
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
index b0214e6..40af943 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/SelectionEngine.java
@@ -737,7 +737,7 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 				e.printStackTrace(System.out);
 			}
 		} finally {
-			reset();
+			reset(true);
 		}
 	}
 
@@ -1193,7 +1193,7 @@ public final class SelectionEngine extends Engine implements ISearchRequestor {
 			}
 		} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object
 		} finally {
-			reset();
+			reset(true);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
index 7f52947..feba3fb 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
@@ -26,6 +26,7 @@ import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.ast.*;
 import org.eclipse.jdt.internal.compiler.parser.*;
 import org.eclipse.jdt.internal.compiler.problem.*;
+import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt;
 import org.eclipse.jdt.internal.compiler.util.Util;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.codeassist.impl.*;
@@ -160,10 +161,17 @@ public class CompletionParser extends AssistParser {
 	
 	CompletionOnAnnotationOfType pendingAnnotation;
 	
-public CompletionParser(ProblemReporter problemReporter) {
+	private boolean storeSourceEnds;
+	public HashtableOfObjectToInt sourceEnds;
+	
+public CompletionParser(ProblemReporter problemReporter, boolean storeExtraSourceEnds) {
 	super(problemReporter);
 	this.reportSyntaxErrorIsRequired = false;
 	this.javadocParser.checkDocComment = true;
+	if (storeExtraSourceEnds) {
+		this.storeSourceEnds = true;
+		this.sourceEnds = new HashtableOfObjectToInt();
+	}
 }
 private void addPotentialName(char[] potentialVariableName, int start, int end) {
 	int length = this.potentialVariableNames.length;
@@ -2118,6 +2126,9 @@ protected void consumeConstructorHeaderName() {
 
 	/* no need to take action if not inside assist identifiers */
 	if (indexOfAssistIdentifier() < 0) {
+		long selectorSourcePositions = this.identifierPositionStack[this.identifierPtr];
+		int selectorSourceEnd = (int) selectorSourcePositions;
+		int currentAstPtr = this.astPtr;
 		/* recovering - might be an empty message send */
 		if (this.currentElement != null && this.lastIgnoredToken == TokenNamenew){ // was an allocation expression
 			super.consumeConstructorHeaderName();
@@ -2128,6 +2139,9 @@ protected void consumeConstructorHeaderName() {
 				this.pendingAnnotation = null;
 			}
 		}
+		if (this.sourceEnds != null && this.astPtr > currentAstPtr) { // if ast node was pushed on the ast stack
+			this.sourceEnds.put(this.astStack[this.astPtr], selectorSourceEnd);
+		}
 		return;
 	}
 
@@ -2140,6 +2154,9 @@ protected void consumeConstructorHeaderName() {
 	this.restartRecovery = true;
 }
 protected void consumeConstructorHeaderNameWithTypeParameters() {
+	long selectorSourcePositions = this.identifierPositionStack[this.identifierPtr];
+	int selectorSourceEnd = (int) selectorSourcePositions;
+	int currentAstPtr = this.astPtr;
 	if (this.currentElement != null && this.lastIgnoredToken == TokenNamenew){ // was an allocation expression
 		super.consumeConstructorHeaderNameWithTypeParameters();
 	} else {
@@ -2149,6 +2166,9 @@ protected void consumeConstructorHeaderNameWithTypeParameters() {
 			this.pendingAnnotation = null;
 		}
 	}
+	if (this.sourceEnds != null && this.astPtr > currentAstPtr) { // if ast node was pushed on the ast stack
+		this.sourceEnds.put(this.astStack[this.astPtr], selectorSourceEnd);
+	}
 }
 protected void consumeDefaultLabel() {
 	super.consumeDefaultLabel();
@@ -2269,6 +2289,24 @@ protected void consumeEnumConstantHeaderName() {
 		this.pendingAnnotation = null;
 	}
 }
+protected void consumeEnumConstantNoClassBody() {
+	super.consumeEnumConstantNoClassBody();
+	if ((currentToken == TokenNameCOMMA || currentToken == TokenNameSEMICOLON)
+			&& this.astStack[this.astPtr] instanceof FieldDeclaration) {
+		if (this.sourceEnds != null) {
+			this.sourceEnds.put(this.astStack[this.astPtr], this.scanner.currentPosition - 1);
+		}
+	}
+}
+protected void consumeEnumConstantWithClassBody() {
+	super.consumeEnumConstantWithClassBody();
+	if ((currentToken == TokenNameCOMMA || currentToken == TokenNameSEMICOLON)
+			&& astStack[astPtr] instanceof FieldDeclaration) {
+		if (this.sourceEnds != null) {
+			this.sourceEnds.put(this.astStack[this.astPtr], this.scanner.currentPosition - 1);
+		}
+	}
+}
 protected void consumeEnumHeaderName() {
 	super.consumeEnumHeaderName();
 	this.hasUnusedModifiers = false;
@@ -2304,7 +2342,13 @@ protected void consumeEqualityExpressionWithName(int op) {
 }
 protected void consumeExitVariableWithInitialization() {
 	super.consumeExitVariableWithInitialization();
-
+	if ((currentToken == TokenNameCOMMA || currentToken == TokenNameSEMICOLON)
+			&& this.astStack[this.astPtr] instanceof FieldDeclaration) {
+		if (this.sourceEnds != null) {
+			this.sourceEnds.put(this.astStack[this.astPtr], this.scanner.currentPosition - 1);
+		}
+	}
+	
 	// does not keep the initialization if completion is not inside
 	AbstractVariableDeclaration variable = (AbstractVariableDeclaration) astStack[astPtr];
 	if (cursorLocation + 1 < variable.initialization.sourceStart ||
@@ -2314,6 +2358,17 @@ protected void consumeExitVariableWithInitialization() {
 		assistNodeParent = variable;
 	}
 }
+protected void consumeExitVariableWithoutInitialization() {
+	// ExitVariableWithoutInitialization ::= $empty
+	// do nothing by default
+	super.consumeExitVariableWithoutInitialization();
+	if ((currentToken == TokenNameCOMMA || currentToken == TokenNameSEMICOLON)
+			&& astStack[astPtr] instanceof FieldDeclaration) {
+		if (this.sourceEnds != null) {
+			this.sourceEnds.put(this.astStack[this.astPtr], this.scanner.currentPosition - 1);
+		}
+	}
+}
 protected void consumeExplicitConstructorInvocation(int flag, int recFlag) {
 	popElement(K_SELECTOR_QUALIFIER);
 	popElement(K_SELECTOR_INVOCATION_TYPE);
@@ -2561,7 +2616,13 @@ protected void consumeMethodHeaderName(boolean isAnnotationMethod) {
 			this.identifierLengthStack[this.identifierLengthPtr] != this.genericsIdentifiersLengthStack[this.genericsIdentifiersLengthPtr]) {
 			identifierPtr++;
 			identifierLengthPtr++;
+			long selectorSourcePositions = this.identifierPositionStack[this.identifierPtr];
+			int selectorSourceEnd = (int) selectorSourcePositions;
+			int currentAstPtr = this.astPtr;
 			super.consumeMethodHeaderName(isAnnotationMethod);
+			if (this.sourceEnds != null && this.astPtr > currentAstPtr) { // if ast node was pushed on the ast stack
+				this.sourceEnds.put(this.astStack[this.astPtr], selectorSourceEnd);
+			}
 			if (this.pendingAnnotation != null) {
 				this.pendingAnnotation.potentialAnnotatedNode = this.astStack[this.astPtr];
 				this.pendingAnnotation = null;
@@ -2681,7 +2742,13 @@ protected void consumeMethodHeaderName(boolean isAnnotationMethod) {
 	}
 }
 protected void consumeMethodHeaderNameWithTypeParameters( boolean isAnnotationMethod) {
+	long selectorSourcePositions = this.identifierPositionStack[this.identifierPtr];
+	int selectorSourceEnd = (int) selectorSourcePositions;
+	int currentAstPtr = this.astPtr;
 	super.consumeMethodHeaderNameWithTypeParameters(isAnnotationMethod);
+	if (this.sourceEnds != null && this.astPtr > currentAstPtr) {// if ast node was pushed on the ast stack
+		this.sourceEnds.put(this.astStack[this.astPtr], selectorSourceEnd);
+	}
 	if (this.pendingAnnotation != null) {
 		this.pendingAnnotation.potentialAnnotatedNode = this.astStack[this.astPtr];
 		this.pendingAnnotation = null;
@@ -3730,7 +3797,15 @@ protected void consumeUnaryExpression(int op, boolean post) {
 		}
 	}
 }
-
+public MethodDeclaration convertToMethodDeclaration(ConstructorDeclaration c, CompilationResult compilationResult) {
+	MethodDeclaration methodDeclaration = super.convertToMethodDeclaration(c, compilationResult);
+	if (this.sourceEnds != null) {
+		int selectorSourceEnd = this.sourceEnds.removeKey(c);
+		if (selectorSourceEnd != -1)
+			this.sourceEnds.put(methodDeclaration, selectorSourceEnd);
+	}
+	return methodDeclaration;
+}
 public ImportReference createAssistImportReference(char[][] tokens, long[] positions, int mod){
 	return new CompletionOnImportReference(tokens, positions, mod);
 }
@@ -4420,6 +4495,9 @@ public void recoveryTokenCheck() {
 public void reset() {
 	super.reset();
 	this.cursorLocation = 0;
+	if (this.storeSourceEnds) {
+		this.sourceEnds = new HashtableOfObjectToInt();
+	}
 }
 /*
  * Reset internal state after completion is over
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistAnnotation.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistAnnotation.java
new file mode 100644
index 0000000..426beeb
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistAnnotation.java
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.impl;
+
+import java.util.Map;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.core.Annotation;
+import org.eclipse.jdt.internal.core.JavaElement;
+
+public class AssistAnnotation extends Annotation {
+	private Map infoCache;
+	public AssistAnnotation(JavaElement parent, String name, Map infoCache) {
+		super(parent, name);
+		this.infoCache = infoCache;
+	}
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return infoCache.get(this);
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistCompilationUnit.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistCompilationUnit.java
new file mode 100644
index 0000000..eb5921f
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistCompilationUnit.java
@@ -0,0 +1,55 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.impl;
+
+import java.util.Map;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IImportContainer;
+import org.eclipse.jdt.core.IPackageDeclaration;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.WorkingCopyOwner;
+import org.eclipse.jdt.internal.core.CompilationUnit;
+import org.eclipse.jdt.internal.core.JavaElementInfo;
+import org.eclipse.jdt.internal.core.PackageFragment;
+
+public class AssistCompilationUnit extends CompilationUnit {
+	private Map infoCache;
+	private Map bindingCache;
+	public AssistCompilationUnit(ICompilationUnit compilationUnit, WorkingCopyOwner owner, Map bindingCache, Map infoCache) {
+		super((PackageFragment)compilationUnit.getParent(), compilationUnit.getElementName(), owner);
+		this.bindingCache = bindingCache;
+		this.infoCache = infoCache;
+	}
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return infoCache.get(this);
+	}
+	
+	public IImportContainer getImportContainer() {
+		return new AssistImportContainer(this, this.infoCache);
+	}
+	
+	public IPackageDeclaration getPackageDeclaration(String pkg) {
+		return new AssistPackageDeclaration(this, pkg, this.infoCache);
+	}
+	
+	public IType getType(String typeName) {
+		return new AssistSourceType(this, typeName, this.bindingCache, this.infoCache);
+	}
+	
+	public boolean hasChildren() throws JavaModelException {
+		JavaElementInfo info = (JavaElementInfo)this.infoCache.get(this);
+		return info.getChildren().length > 0;
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistImportContainer.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistImportContainer.java
new file mode 100644
index 0000000..15fd05d
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistImportContainer.java
@@ -0,0 +1,35 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.impl;
+
+import java.util.Map;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.IImportDeclaration;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.core.CompilationUnit;
+import org.eclipse.jdt.internal.core.ImportContainer;
+
+public class AssistImportContainer extends ImportContainer {
+	private Map infoCache;
+	public AssistImportContainer(CompilationUnit parent, Map infoCache) {
+		super(parent);
+		this.infoCache = infoCache;
+	}
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return infoCache.get(this);
+	}
+	
+	protected IImportDeclaration getImport(String importName, boolean isOnDemand) {
+		return new AssistImportDeclaration(this, importName, isOnDemand, this.infoCache);
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistImportDeclaration.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistImportDeclaration.java
new file mode 100644
index 0000000..18868a1
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistImportDeclaration.java
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.impl;
+
+import java.util.Map;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.core.ImportContainer;
+import org.eclipse.jdt.internal.core.ImportDeclaration;
+
+public class AssistImportDeclaration extends ImportDeclaration {
+	private Map infoCache;
+	public AssistImportDeclaration(ImportContainer parent, String name, boolean isOnDemand, Map infoCache) {
+		super(parent, name, isOnDemand);
+		this.infoCache = infoCache;
+	}
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return infoCache.get(this);
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistInitializer.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistInitializer.java
new file mode 100644
index 0000000..622750a
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistInitializer.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.impl;
+
+import java.util.Map;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.core.Initializer;
+import org.eclipse.jdt.internal.core.JavaElement;
+
+public class AssistInitializer extends Initializer {
+	private Map bindingCache;
+	private Map infoCache;
+	public AssistInitializer(JavaElement parent, int count, Map bindingCache, Map infoCache) {
+		super(parent, count);
+		this.bindingCache = bindingCache;
+		this.infoCache = infoCache;
+	}
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return infoCache.get(this);
+	}
+	
+	public IType getType(String typeName, int count) {
+		AssistSourceType type = new AssistSourceType(this, typeName, this.bindingCache, this.infoCache);
+		type.occurrenceCount = count;
+		return type;
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistPackageDeclaration.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistPackageDeclaration.java
new file mode 100644
index 0000000..901897b
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistPackageDeclaration.java
@@ -0,0 +1,35 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.impl;
+
+import java.util.Map;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.IAnnotation;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.core.CompilationUnit;
+import org.eclipse.jdt.internal.core.PackageDeclaration;
+
+public class AssistPackageDeclaration extends PackageDeclaration {
+	private Map infoCache;
+	public AssistPackageDeclaration(CompilationUnit parent, String name, Map infoCache) {
+		super(parent, name);
+		this.infoCache = infoCache;
+	}
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return infoCache.get(this);
+	}
+	
+	public IAnnotation getAnnotation(String name) {
+		return new AssistAnnotation(this, name, this.infoCache);
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceField.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceField.java
new file mode 100644
index 0000000..31b23c7
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceField.java
@@ -0,0 +1,69 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.impl;
+
+import java.util.Map;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.IAnnotation;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.core.JavaElement;
+import org.eclipse.jdt.internal.core.ResolvedSourceField;
+
+public class AssistSourceField extends ResolvedSourceField {
+	private Map bindingCache;
+	private Map infoCache;
+	
+	private String uniqueKey;
+	
+	public AssistSourceField(JavaElement parent, String name, Map bindingCache, Map infoCache) {
+		super(parent, name, null);
+		this.bindingCache = bindingCache;
+		this.infoCache = infoCache;
+	}
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return infoCache.get(this);
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.internal.core.SourceField#getKey()
+	 */
+	public String getKey() {
+		if (this.uniqueKey == null) {
+			Binding binding = (Binding) this.bindingCache.get(this);
+			if (binding != null) {
+				this.uniqueKey = new String(binding.computeUniqueKey());
+			}
+		}
+		return this.uniqueKey;
+	}
+	
+	public boolean isResolved() {
+		return getKey() != null;
+	}
+	
+	protected void toStringInfo(int tab, StringBuffer buffer, Object info,boolean showResolvedInfo) {
+		super.toStringInfo(tab, buffer, info, showResolvedInfo && this.isResolved());
+	}
+	
+	public IAnnotation getAnnotation(String annotationName) {
+		return new AssistAnnotation(this, annotationName, this.infoCache);
+	}
+	
+	public IType getType(String typeName, int count) {
+		AssistSourceType type = new AssistSourceType(this, typeName, this.bindingCache, this.infoCache);
+		type.occurrenceCount = count;
+		return type;
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceMethod.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceMethod.java
new file mode 100644
index 0000000..1b6c810
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceMethod.java
@@ -0,0 +1,74 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.impl;
+
+import java.util.Map;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.IAnnotation;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeParameter;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.core.JavaElement;
+import org.eclipse.jdt.internal.core.ResolvedSourceMethod;
+
+public class AssistSourceMethod extends ResolvedSourceMethod {
+	private Map bindingCache;
+	private Map infoCache;
+	
+	private String uniqueKey;
+	
+	public AssistSourceMethod(JavaElement parent, String name, String[] parameterTypes, Map bindingCache, Map infoCache) {
+		super(parent, name, parameterTypes, null);
+		this.bindingCache = bindingCache;
+		this.infoCache = infoCache;
+	}
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return infoCache.get(this);
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.internal.core.SourceMethod#getKey()
+	 */
+	public String getKey() {
+		if (this.uniqueKey == null) {
+			Binding binding = (Binding) this.bindingCache.get(this);
+			if (binding != null) {
+				this.uniqueKey = new String(binding.computeUniqueKey());
+			}
+		}
+		return this.uniqueKey;
+	}
+	
+	public boolean isResolved() {
+		return getKey() != null;
+	}
+	
+	protected void toStringInfo(int tab, StringBuffer buffer, Object info,boolean showResolvedInfo) {
+		super.toStringInfo(tab, buffer, info, showResolvedInfo && this.isResolved());
+	}
+	
+	public IAnnotation getAnnotation(String annotationName) {
+		return new AssistAnnotation(this, annotationName, this.infoCache);
+	}
+	
+	public IType getType(String typeName, int count) {
+		AssistSourceType type = new AssistSourceType(this, typeName, this.bindingCache, this.infoCache);
+		type.occurrenceCount = count;
+		return type;
+	}
+	
+	public ITypeParameter getTypeParameter(String typeParameterName) {
+		return new AssistTypeParameter(this, typeParameterName, this.infoCache);
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceType.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceType.java
new file mode 100644
index 0000000..375dc53
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistSourceType.java
@@ -0,0 +1,100 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.impl;
+
+import java.util.Map;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.IAnnotation;
+import org.eclipse.jdt.core.IField;
+import org.eclipse.jdt.core.IInitializer;
+import org.eclipse.jdt.core.IMethod;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeParameter;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.core.JavaElement;
+import org.eclipse.jdt.internal.core.ResolvedSourceType;
+
+public class AssistSourceType extends ResolvedSourceType {
+	private Map bindingCache;
+	private Map infoCache;
+	
+	private String uniqueKey;
+	
+	public AssistSourceType(JavaElement parent, String name, Map bindingCache, Map infoCache) {
+		super(parent, name, null);
+		this.bindingCache = bindingCache;
+		this.infoCache = infoCache;
+	}
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return infoCache.get(this);
+	}
+	
+	public String getFullyQualifiedParameterizedName() throws JavaModelException {
+		if (this.isResolved()) {
+			return getFullyQualifiedParameterizedName(getFullyQualifiedName(), this.getKey());
+		}
+		return getFullyQualifiedName('.', true/*show parameters*/);
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.internal.core.SourceType#getKey()
+	 */
+	public String getKey() {
+		if (this.uniqueKey == null) {
+			Binding binding = (Binding) this.bindingCache.get(this);
+			if (binding != null) {
+				this.uniqueKey = new String(binding.computeUniqueKey());
+			}
+		}
+		return this.uniqueKey;
+	}
+	
+	public boolean isResolved() {
+		return getKey() != null;
+	}
+	
+	protected void toStringInfo(int tab, StringBuffer buffer, Object info,boolean showResolvedInfo) {
+		super.toStringInfo(tab, buffer, info, showResolvedInfo && this.isResolved());
+	}
+	
+	public IAnnotation getAnnotation(String annotationName) {
+		return new AssistAnnotation(this, annotationName, this.infoCache);
+	}
+	
+	public IField getField(String fieldName) {
+		return new AssistSourceField(this, fieldName, this.bindingCache, this.infoCache);
+	}
+	
+	public IInitializer getInitializer(int count) {
+		return new AssistInitializer(this, count, this.bindingCache, this.infoCache);
+	}
+	
+	public IMethod getMethod(String selector, String[] parameterTypeSignatures) {
+		return new AssistSourceMethod(this, selector, parameterTypeSignatures, this.bindingCache, this.infoCache);
+	}
+	
+	public IType getType(String typeName) {
+		return new AssistSourceType(this, typeName, this.bindingCache, this.infoCache);
+	}
+	
+	public IType getType(String typeName, int count) {
+		AssistSourceType type = new AssistSourceType(this, typeName, this.bindingCache, this.infoCache);
+		type.occurrenceCount = count;
+		return type;
+	}
+	
+	public ITypeParameter getTypeParameter(String typeParameterName) {
+		return new AssistTypeParameter(this, typeParameterName, this.infoCache);
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistTypeParameter.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistTypeParameter.java
new file mode 100644
index 0000000..e2efaf0
--- /dev/null
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistTypeParameter.java
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.codeassist.impl;
+
+import java.util.Map;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.internal.core.JavaElement;
+import org.eclipse.jdt.internal.core.TypeParameter;
+
+public class AssistTypeParameter extends TypeParameter {
+	private Map infoCache;
+	public AssistTypeParameter(JavaElement parent, String name, Map infoCache) {
+		super(parent, name);
+		this.infoCache = infoCache;
+	}
+	
+	public Object getElementInfo(IProgressMonitor monitor) throws JavaModelException {
+		return infoCache.get(this);
+	}
+}
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
index bb035a0..cf32487 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/Engine.java
@@ -309,8 +309,8 @@ public abstract class Engine implements ITypeRequestor {
 		return null;
 	}
 
-	protected void reset() {
-		lookupEnvironment.reset();
+	protected void reset(boolean resetLookupEnvironment) {
+		if (resetLookupEnvironment) lookupEnvironment.reset();
 	}
 
 	public static char[] getTypeSignature(TypeBinding typeBinding) {
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
index 6743b34..5ddc18b 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
@@ -61,6 +61,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
+import org.eclipse.jdt.internal.core.util.Util;
 
 /**
  * Internal class for resolving bindings using old ASTs.
@@ -208,6 +209,15 @@ class DefaultBindingResolver extends BindingResolver {
 		}
 		return null;
 	}
+	
+	Util.BindingsToNodesMap getBindingsToNodesMap() {
+		return new Util.BindingsToNodesMap() {
+			public org.eclipse.jdt.internal.compiler.ast.ASTNode get(Binding binding) {
+				return (org.eclipse.jdt.internal.compiler.ast.ASTNode)
+					DefaultBindingResolver.this.newAstToOldAst.get(DefaultBindingResolver.this.bindingsToAstNodes.get(binding));
+			}
+		};
+	}
 
 	synchronized org.eclipse.jdt.internal.compiler.ast.ASTNode getCorrespondingNode(ASTNode currentNode) {
 		return (org.eclipse.jdt.internal.compiler.ast.ASTNode) this.newAstToOldAst.get(currentNode);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java
index 65dcd45..65d6df9 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/MethodBinding.java
@@ -11,15 +11,7 @@
 
 package org.eclipse.jdt.core.dom;
 
-import java.util.ArrayList;
-import java.util.Iterator;
-
 import org.eclipse.jdt.core.IJavaElement;
-import org.eclipse.jdt.core.IMethod;
-import org.eclipse.jdt.core.IType;
-import org.eclipse.jdt.core.JavaModelException;
-import org.eclipse.jdt.core.Signature;
-import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
@@ -29,7 +21,6 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
 import org.eclipse.jdt.internal.core.JavaElement;
-import org.eclipse.jdt.internal.core.Member;
 import org.eclipse.jdt.internal.core.util.Util;
 
 /**
@@ -252,68 +243,13 @@ class MethodBinding implements IMethodBinding {
 	}
 
 	private JavaElement getUnresolvedJavaElement() {
-		IType declaringType = (IType) getDeclaringClass().getJavaElement();
-		if (declaringType == null) return null;
 		if (!(this.resolver instanceof DefaultBindingResolver)) return null;
-		ASTNode node = (ASTNode) ((DefaultBindingResolver) this.resolver).bindingsToAstNodes.get(this);
-		if (node != null && declaringType.getParent().getElementType() != IJavaElement.CLASS_FILE) {
-			if (node instanceof MethodDeclaration) {
-				MethodDeclaration methodDeclaration = (MethodDeclaration) node;
-				ArrayList parameterSignatures = new ArrayList();
-				Iterator iterator = methodDeclaration.parameters().iterator();
-				while (iterator.hasNext()) {
-					SingleVariableDeclaration parameter = (SingleVariableDeclaration) iterator.next();
-					Type type = parameter.getType();
-					String typeSig = Util.getSignature(type);
-					int arrayDim = parameter.getExtraDimensions();
-					if (parameter.getAST().apiLevel() >= AST.JLS3 && parameter.isVarargs()) {
-						arrayDim++;
-					}
-					if (arrayDim > 0) {
-						typeSig = Signature.createArraySignature(typeSig, arrayDim);
-					}
-					parameterSignatures.add(typeSig);
-				}
-				int parameterCount = parameterSignatures.size();
-				String[] parameters = new String[parameterCount];
-				parameterSignatures.toArray(parameters);
-				return (JavaElement) declaringType.getMethod(getName(), parameters);
-			} else {
-				// annotation type member declaration
-				AnnotationTypeMemberDeclaration typeMemberDeclaration = (AnnotationTypeMemberDeclaration) node;
-				return (JavaElement) declaringType.getMethod(typeMemberDeclaration.getName().getIdentifier(), CharOperation.NO_STRINGS); // annotation type members don't have parameters
-			}
-		} else {
-			// case of method not in the created AST, or a binary method
-			org.eclipse.jdt.internal.compiler.lookup.MethodBinding original = this.binding.original();
-			String selector = original.isConstructor() ? declaringType.getElementName() : new String(original.selector);
-			boolean isBinary = declaringType.isBinary();
-			ReferenceBinding enclosingType = original.declaringClass.enclosingType();
-			boolean isInnerBinaryTypeConstructor = isBinary && original.isConstructor() && enclosingType != null;
-			TypeBinding[] parameters = original.parameters;
-			int length = parameters == null ? 0 : parameters.length;
-			int declaringIndex = isInnerBinaryTypeConstructor ? 1 : 0;
-			String[] parameterSignatures = new String[declaringIndex + length];
-			if (isInnerBinaryTypeConstructor)
-				parameterSignatures[0] = new String(enclosingType.genericTypeSignature()).replace('/', '.');
-			for (int i = 0;  i < length; i++) {
-				parameterSignatures[declaringIndex + i] = new String(parameters[i].genericTypeSignature()).replace('/', '.');
-			}
-			IMethod result = declaringType.getMethod(selector, parameterSignatures);
-			if (isBinary)
-				return (JavaElement) result;
-			IMethod[] methods = null;
-			try {
-				methods = declaringType.getMethods();
-			} catch (JavaModelException e) {
-				// declaring type doesn't exist
-				return null;
-			}
-			IMethod[] candidates = Member.findMethods(result, methods);
-			if (candidates == null || candidates.length == 0)
-				return null;
-			return (JavaElement) candidates[0];
-		}
+		
+		DefaultBindingResolver defaultBindingResolver = (DefaultBindingResolver) this.resolver;
+		return Util.getUnresolvedJavaElement(
+				this.binding,
+				defaultBindingResolver.workingCopyOwner,
+				defaultBindingResolver.getBindingsToNodesMap());
 	}
 
 	/**
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
index e85395f..cdedc9a 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/TypeBinding.java
@@ -11,27 +11,12 @@
 
 package org.eclipse.jdt.core.dom;
 
-import java.io.File;
-
-import org.eclipse.core.resources.IContainer;
-import org.eclipse.core.resources.IWorkspaceRoot;
-import org.eclipse.core.resources.ResourcesPlugin;
-import org.eclipse.core.runtime.Path;
-import org.eclipse.jdt.core.IClassFile;
-import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
-import org.eclipse.jdt.core.IJavaProject;
-import org.eclipse.jdt.core.IMethod;
-import org.eclipse.jdt.core.IPackageFragment;
-import org.eclipse.jdt.core.IPackageFragmentRoot;
-import org.eclipse.jdt.core.IType;
-import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
-import org.eclipse.jdt.internal.compiler.env.IDependent;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
 import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Binding;
@@ -49,9 +34,6 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
-import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
-import org.eclipse.jdt.internal.compiler.util.Util;
-import org.eclipse.jdt.internal.core.ClassFile;
 import org.eclipse.jdt.internal.core.CompilationUnit;
 import org.eclipse.jdt.internal.core.JavaElement;
 import org.eclipse.jdt.internal.core.PackageFragment;
@@ -184,46 +166,6 @@ class TypeBinding implements ITypeBinding {
 	}
 
 	/*
-	 * Returns the class file for the given file name, or null if not found.
-	 * @see org.eclipse.jdt.internal.compiler.env.IDependent#getFileName()
-	 */
-	private IClassFile getClassFile(char[] fileName) {
-		int jarSeparator = CharOperation.indexOf(IDependent.JAR_FILE_ENTRY_SEPARATOR, fileName);
-		int pkgEnd = CharOperation.lastIndexOf('/', fileName); // pkgEnd is exclusive
-		if (pkgEnd == -1)
-			pkgEnd = CharOperation.lastIndexOf(File.separatorChar, fileName);
-		if (jarSeparator != -1 && pkgEnd < jarSeparator) // if in a jar and no slash, it is a default package -> pkgEnd should be equal to jarSeparator
-			pkgEnd = jarSeparator;
-		if (pkgEnd == -1)
-			return null;
-		IPackageFragment pkg = getPackageFragment(fileName, pkgEnd, jarSeparator);
-		if (pkg == null) return null;
-		int start;
-		return pkg.getClassFile(new String(fileName, start = pkgEnd + 1, fileName.length - start));
-	}
-
-	/*
-	 * Returns the compilation unit for the given file name, or null if not found.
-	 * @see org.eclipse.jdt.internal.compiler.env.IDependent#getFileName()
-	 */
-	private ICompilationUnit getCompilationUnit(char[] fileName) {
-		char[] slashSeparatedFileName = CharOperation.replaceOnCopy(fileName, File.separatorChar, '/');
-		int pkgEnd = CharOperation.lastIndexOf('/', slashSeparatedFileName); // pkgEnd is exclusive
-		if (pkgEnd == -1)
-			return null;
-		IPackageFragment pkg = getPackageFragment(slashSeparatedFileName, pkgEnd, -1/*no jar separator for .java files*/);
-		if (pkg == null) return null;
-		int start;
-		ICompilationUnit cu = pkg.getCompilationUnit(new String(slashSeparatedFileName, start =  pkgEnd+1, slashSeparatedFileName.length - start));
-		if (this.resolver instanceof DefaultBindingResolver) {
-			ICompilationUnit workingCopy = cu.findWorkingCopy(((DefaultBindingResolver) this.resolver).workingCopyOwner);
-			if (workingCopy != null)
-				return workingCopy;
-		}
-		return cu;
-	}
-
-	/*
 	 * @see ITypeBinding#getComponentType()
 	 */
 	public ITypeBinding getComponentType() {
@@ -545,99 +487,14 @@ class TypeBinding implements ITypeBinding {
 		return getUnresolvedJavaElement(this.binding);
 	}
 	private JavaElement getUnresolvedJavaElement(org.eclipse.jdt.internal.compiler.lookup.TypeBinding typeBinding ) {
-		if (typeBinding == null)
-			return null;
-		switch (typeBinding.kind()) {
-			case Binding.ARRAY_TYPE :
-				typeBinding = ((ArrayBinding) typeBinding).leafComponentType();
-				return getUnresolvedJavaElement(typeBinding);
-			case Binding.BASE_TYPE :
-			case Binding.WILDCARD_TYPE :
-			case Binding.INTERSECTION_TYPE:
-				return null;
-			default :
-				if (typeBinding.isCapture())
-					return null;
-		}
-		ReferenceBinding referenceBinding;
-		if (typeBinding.isParameterizedType() || typeBinding.isRawType())
-			referenceBinding = (ReferenceBinding) typeBinding.erasure();
-		else
-			referenceBinding = (ReferenceBinding) typeBinding;
-		char[] fileName = referenceBinding.getFileName();
-		if (referenceBinding.isLocalType() || referenceBinding.isAnonymousType()) {
-			// local or anonymous type
-			if (Util.isClassFileName(fileName)) {
-				int jarSeparator = CharOperation.indexOf(IDependent.JAR_FILE_ENTRY_SEPARATOR, fileName);
-				int pkgEnd = CharOperation.lastIndexOf('/', fileName); // pkgEnd is exclusive
-				if (pkgEnd == -1)
-					pkgEnd = CharOperation.lastIndexOf(File.separatorChar, fileName);
-				if (jarSeparator != -1 && pkgEnd < jarSeparator) // if in a jar and no slash, it is a default package -> pkgEnd should be equal to jarSeparator
-					pkgEnd = jarSeparator;
-				if (pkgEnd == -1)
-					return null;
-				IPackageFragment pkg = getPackageFragment(fileName, pkgEnd, jarSeparator);
-				char[] constantPoolName = referenceBinding.constantPoolName();
-				if (constantPoolName == null) {
-					ClassFile classFile = (ClassFile) getClassFile(fileName);
-					return classFile == null ? null : (JavaElement) classFile.getType();
-				}
-				pkgEnd = CharOperation.lastIndexOf('/', constantPoolName);
-				char[] classFileName = CharOperation.subarray(constantPoolName, pkgEnd+1, constantPoolName.length);
-				ClassFile classFile = (ClassFile) pkg.getClassFile(new String(classFileName) + SuffixConstants.SUFFIX_STRING_class);
-				return (JavaElement) classFile.getType();
-			}
-			ICompilationUnit cu = getCompilationUnit(fileName);
-			if (cu == null) return null;
-			// must use getElementAt(...) as there is no back pointer to the defining method (scope is null after resolution has ended)
-			try {
-				int sourceStart = ((LocalTypeBinding) referenceBinding).sourceStart;
-				return (JavaElement) cu.getElementAt(sourceStart);
-			} catch (JavaModelException e) {
-				// does not exist
-				return null;
-			}
-		} else if (referenceBinding.isTypeVariable()) {
-			// type parameter
-			final String typeVariableName = new String(referenceBinding.sourceName());
-			Binding declaringElement = ((TypeVariableBinding) referenceBinding).declaringElement;
-			IBinding declaringTypeBinding = null;
-			if (declaringElement instanceof MethodBinding) {
-				declaringTypeBinding = this.resolver.getMethodBinding((MethodBinding) declaringElement);
-				IMethod declaringMethod = (IMethod) declaringTypeBinding.getJavaElement();
-				return (JavaElement) declaringMethod.getTypeParameter(typeVariableName);
-			} else {
-				ITypeBinding typeBinding2 = this.resolver.getTypeBinding((org.eclipse.jdt.internal.compiler.lookup.TypeBinding) declaringElement);
-				if (typeBinding2 == null) return null;
-				declaringTypeBinding = typeBinding2;
-				IType declaringType = (IType) declaringTypeBinding.getJavaElement();
-				return (JavaElement) declaringType.getTypeParameter(typeVariableName);
-			}
+		if (this.resolver instanceof DefaultBindingResolver) {
+			DefaultBindingResolver defaultBindingResolver = (DefaultBindingResolver) this.resolver;
+			return org.eclipse.jdt.internal.core.util.Util.getUnresolvedJavaElement(
+					typeBinding,
+					defaultBindingResolver.workingCopyOwner,
+					defaultBindingResolver.getBindingsToNodesMap());
 		} else {
-			if (fileName == null) return null; // case of a WilCardBinding that doesn't have a corresponding Java element
-			// member or top level type
-			ITypeBinding declaringTypeBinding = null;
-			if (this.isArray()) {
-				declaringTypeBinding = this.getElementType().getDeclaringClass();
-			} else {
-				declaringTypeBinding = this.getDeclaringClass();
-			}
-			if (declaringTypeBinding == null) {
-				// top level type
-				if (Util.isClassFileName(fileName)) {
-					ClassFile classFile = (ClassFile) getClassFile(fileName);
-					if (classFile == null) return null;
-					return (JavaElement) classFile.getType();
-				}
-				ICompilationUnit cu = getCompilationUnit(fileName);
-				if (cu == null) return null;
-				return (JavaElement) cu.getType(new String(referenceBinding.sourceName()));
-			} else {
-				// member type
-				IType declaringType = (IType) declaringTypeBinding.getJavaElement();
-				if (declaringType == null) return null;
-				return (JavaElement) declaringType.getType(new String(referenceBinding.sourceName()));
-			}
+			return org.eclipse.jdt.internal.core.util.Util.getUnresolvedJavaElement(typeBinding, null, null);
 		}
 	}
 
@@ -781,43 +638,6 @@ class TypeBinding implements ITypeBinding {
 		return this.resolver.getPackageBinding(referenceBinding.getPackage());
 	}
 
-	/*
-	 * Returns the package that includes the given file name, or null if not found.
-	 * pkgEnd == jarSeparator if default package in a jar
-	 * pkgEnd > jarSeparator if non default package in a jar
-	 * pkgEnd > 0 if package not in a jar
-	 *
-	 * @see org.eclipse.jdt.internal.compiler.env.IDependent#getFileName()
-	 */
-	private IPackageFragment getPackageFragment(char[] fileName, int pkgEnd, int jarSeparator) {
-		if (jarSeparator != -1) {
-			String jarMemento = new String(fileName, 0, jarSeparator);
-			IPackageFragmentRoot root = (IPackageFragmentRoot) JavaCore.create(jarMemento);
-			if (pkgEnd == jarSeparator)
-				return root.getPackageFragment(IPackageFragment.DEFAULT_PACKAGE_NAME);
-			char[] pkgName = CharOperation.subarray(fileName, jarSeparator+1, pkgEnd);
-			CharOperation.replace(pkgName, '/', '.');
-			return root.getPackageFragment(new String(pkgName));
-		} else {
-			Path path = new Path(new String(fileName, 0, pkgEnd));
-			IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
-			IContainer folder = path.segmentCount() == 1 ? workspaceRoot.getProject(path.lastSegment()) : (IContainer) workspaceRoot.getFolder(path);
-			IJavaElement element = JavaCore.create(folder);
-			if (element == null) return null;
-			switch (element.getElementType()) {
-				case IJavaElement.PACKAGE_FRAGMENT:
-					return (IPackageFragment) element;
-				case IJavaElement.PACKAGE_FRAGMENT_ROOT:
-					return ((IPackageFragmentRoot) element).getPackageFragment(IPackageFragment.DEFAULT_PACKAGE_NAME);
-				case IJavaElement.JAVA_PROJECT:
-					IPackageFragmentRoot root = ((IJavaProject) element).getPackageFragmentRoot(folder);
-					if (root == null) return null;
-					return root.getPackageFragment(IPackageFragment.DEFAULT_PACKAGE_NAME);
-			}
-			return null;
-		}
-	}
-
 	/**
 	 * @see org.eclipse.jdt.core.dom.ITypeBinding#getQualifiedName()
 	 */
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
index a76c2a2..c16e700 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/VariableBinding.java
@@ -12,7 +12,6 @@
 package org.eclipse.jdt.core.dom;
 
 import org.eclipse.jdt.core.IJavaElement;
-import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.util.IModifierConstants;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
@@ -22,6 +21,7 @@ import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.core.JavaElement;
 import org.eclipse.jdt.internal.core.LocalVariable;
+import org.eclipse.jdt.internal.core.util.Util;
 
 /**
  * Internal implementation of variable bindings.
@@ -201,12 +201,15 @@ class VariableBinding implements IVariableBinding {
 
 	private JavaElement getUnresolvedJavaElement() {
 		if (isField()) {
-			// field
-			FieldBinding fieldBinding = (FieldBinding) this.binding;
-			if (fieldBinding.declaringClass == null) return null; // arraylength
-			IType declaringType = (IType) getDeclaringClass().getJavaElement();
-			if (declaringType == null) return null;
-			return (JavaElement) declaringType.getField(getName());
+			if (this.resolver instanceof DefaultBindingResolver) {
+				DefaultBindingResolver defaultBindingResolver = (DefaultBindingResolver) this.resolver;
+				return Util.getUnresolvedJavaElement(
+						(FieldBinding) this.binding,
+						defaultBindingResolver.workingCopyOwner,
+						defaultBindingResolver.getBindingsToNodesMap());
+			} else {
+				return Util.getUnresolvedJavaElement((FieldBinding) this.binding, null, null);
+			}
 		}
 		// local variable
 		IMethodBinding declaringMethod = getDeclaringMethod();
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java
index 2b58ba7..1a9e8db 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/EvaluationContext.java
@@ -15,6 +15,7 @@ import java.util.Map;
 
 import org.eclipse.jdt.core.CompletionRequestor;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.WorkingCopyOwner;
 import org.eclipse.jdt.core.compiler.*;
 import org.eclipse.jdt.internal.codeassist.CompletionEngine;
 import org.eclipse.jdt.internal.codeassist.ISelectionRequestor;
@@ -100,8 +101,11 @@ public GlobalVariable[] allVariables() {
  *
  *  @param options
  *		set of options used to configure the code assist engine.
+ *
+ *  @param owner
+ *  	the owner of working copies that take precedence over their original compilation units
  */
-public void complete(char[] codeSnippet, int completionPosition, SearchableEnvironment environment, CompletionRequestor requestor, Map options, IJavaProject project) {
+public void complete(char[] codeSnippet, int completionPosition, SearchableEnvironment environment, CompletionRequestor requestor, Map options, final IJavaProject project, WorkingCopyOwner owner) {
 	try {
 		IRequestor variableRequestor = new IRequestor() {
 			public boolean acceptClassFiles(ClassFile[] classFiles, char[] codeSnippetClassName) {
@@ -144,7 +148,7 @@ public void complete(char[] codeSnippet, int completionPosition, SearchableEnvir
 		}
 	};
 	
-	CompletionEngine engine = new CompletionEngine(environment, mapper.getCompletionRequestor(requestor), options, project);
+	CompletionEngine engine = new CompletionEngine(environment, mapper.getCompletionRequestor(requestor), options, project, owner);
 	
 	if (this.installedVars != null) {
 		IBinaryType binaryType = this.getRootCodeSnippetBinary();
@@ -165,7 +169,7 @@ public void complete(char[] codeSnippet, int completionPosition, SearchableEnvir
 		}
 	}
 	
-	engine.complete(sourceUnit, mapper.startPosOffset + completionPosition, mapper.startPosOffset);
+	engine.complete(sourceUnit, mapper.startPosOffset + completionPosition, mapper.startPosOffset, null/*extended context isn't computed*/);
 }
 /**
  * Deletes the given variable from this evaluation context. This will take effect in the target VM only
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
index 2b1dba8..23a3dd3 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
@@ -11,9 +11,12 @@
 package org.eclipse.jdt.internal.compiler;
 
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;
+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 
 /*
  * Part of the source element parser responsible for building the output. It
@@ -54,6 +57,7 @@ public interface ISourceElementRequestor {
 		public boolean secondary;
 		public boolean anonymousMember;
 		public Annotation[] annotations;
+		public TypeDeclaration node;
 	}
 	
 	public static class TypeParameterInfo {
@@ -80,6 +84,7 @@ public interface ISourceElementRequestor {
 		public TypeParameterInfo[] typeParameters;
 		public char[][] categories;
 		public Annotation[] annotations;
+		public AbstractMethodDeclaration node;
 	}
 	
 	public static class FieldInfo {
@@ -91,6 +96,7 @@ public interface ISourceElementRequestor {
 		public int nameSourceEnd;
 		public char[][] categories;
 		public Annotation[] annotations;
+		public FieldDeclaration node;
 	}
 
 	void acceptAnnotationTypeReference(char[][] annotation, int sourceStart, int sourceEnd);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
new file mode 100644
index 0000000..3271cf0
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
@@ -0,0 +1,758 @@
+/*******************************************************************************
+ * Copyright (c) 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler;
+
+import java.util.ArrayList;
+import java.util.Map;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
+import org.eclipse.jdt.internal.compiler.ast.ArrayReference;
+import org.eclipse.jdt.internal.compiler.ast.Assignment;
+import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
+import org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ImportReference;
+import org.eclipse.jdt.internal.compiler.ast.Initializer;
+import org.eclipse.jdt.internal.compiler.ast.MessageSend;
+import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.ThisReference;
+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
+import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
+import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
+import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt;
+
+public class SourceElementNotifier {
+	/**
+	 * An ast visitor that visits local type declarations.
+	 */
+	public class LocalDeclarationVisitor extends ASTVisitor {
+		ArrayList declaringTypes;
+		public void pushDeclaringType(TypeDeclaration declaringType) {
+			if (this.declaringTypes == null) {
+				this.declaringTypes = new ArrayList();
+			}
+			this.declaringTypes.add(declaringType);
+		}
+		public void popDeclaringType() {
+			this.declaringTypes.remove(this.declaringTypes.size()-1);
+		}
+		public TypeDeclaration peekDeclaringType() {
+			if (this.declaringTypes == null) return null;
+			int size = this.declaringTypes.size();
+			if (size == 0) return null;
+			return (TypeDeclaration) this.declaringTypes.get(size-1);
+		}
+		public boolean visit(TypeDeclaration typeDeclaration, BlockScope scope) {
+			notifySourceElementRequestor(typeDeclaration, true, peekDeclaringType());
+			return false; // don't visit members as this was done during notifySourceElementRequestor(...)
+		}
+		public boolean visit(TypeDeclaration typeDeclaration, ClassScope scope) {
+			notifySourceElementRequestor(typeDeclaration, true, peekDeclaringType());
+			return false; // don't visit members as this was done during notifySourceElementRequestor(...)
+		}	
+	}
+	
+	ISourceElementRequestor requestor;
+	boolean reportReferenceInfo;
+	char[][] typeNames;
+	char[][] superTypeNames;
+	int nestedTypeIndex;
+	LocalDeclarationVisitor localDeclarationVisitor = null;
+	
+	HashtableOfObjectToInt sourceEnds;
+	Map nodesToCategories;
+	
+	int initialPosition;
+	int eofPosition;
+	
+public SourceElementNotifier(ISourceElementRequestor requestor, boolean reportLocalDeclarations) {
+	this.requestor = requestor;
+	if (reportLocalDeclarations) {
+		this.localDeclarationVisitor = new LocalDeclarationVisitor();
+	}
+	typeNames = new char[4][];
+	superTypeNames = new char[4][];
+	nestedTypeIndex = 0;
+}
+protected char[][][] getArguments(Argument[] arguments) {
+	int argumentLength = arguments.length;
+	char[][] argumentTypes = new char[argumentLength][];
+	char[][] argumentNames = new char[argumentLength][];
+	for (int i = 0; i < argumentLength; i++) {
+		argumentTypes[i] = CharOperation.concatWith(arguments[i].type.getParameterizedTypeName(), '.');
+		argumentNames[i] = arguments[i].name;
+	}
+	
+	return new char[][][] {argumentTypes, argumentNames};
+}
+protected char[][] getInterfaceNames(TypeDeclaration typeDeclaration) {
+	char[][] interfaceNames = null;
+	int superInterfacesLength = 0;
+	TypeReference[] superInterfaces = typeDeclaration.superInterfaces;
+	if (superInterfaces != null) {
+		superInterfacesLength = superInterfaces.length;
+		interfaceNames = new char[superInterfacesLength][];
+	} else {
+		if ((typeDeclaration.bits & ASTNode.IsAnonymousType) != 0) {
+			// see PR 3442
+			QualifiedAllocationExpression alloc = typeDeclaration.allocation;
+			if (alloc != null && alloc.type != null) {
+				superInterfaces = new TypeReference[] { alloc.type};
+				superInterfacesLength = 1;
+				interfaceNames = new char[1][];
+			}
+		}
+	}
+	if (superInterfaces != null) {
+		for (int i = 0; i < superInterfacesLength; i++) {
+			interfaceNames[i] = 
+				CharOperation.concatWith(superInterfaces[i].getParameterizedTypeName(), '.'); 
+		}
+	}
+	return interfaceNames;
+}
+protected char[] getSuperclassName(TypeDeclaration typeDeclaration) {
+	TypeReference superclass = typeDeclaration.superclass;
+	return superclass != null ? CharOperation.concatWith(superclass.getParameterizedTypeName(), '.') : null;
+}
+protected char[][] getThrownExceptions(AbstractMethodDeclaration methodDeclaration) {
+	char[][] thrownExceptionTypes = null;
+	TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;
+	if (thrownExceptions != null) {
+		int thrownExceptionLength = thrownExceptions.length;
+		thrownExceptionTypes = new char[thrownExceptionLength][];
+		for (int i = 0; i < thrownExceptionLength; i++) {
+			thrownExceptionTypes[i] = 
+				CharOperation.concatWith(thrownExceptions[i].getParameterizedTypeName(), '.'); 
+		}
+	}
+	return thrownExceptionTypes;
+}
+protected char[][] getTypeParameterBounds(TypeParameter typeParameter) {
+	TypeReference firstBound = typeParameter.type;
+	TypeReference[] otherBounds = typeParameter.bounds;
+	char[][] typeParameterBounds = null;
+	if (firstBound != null) {
+		if (otherBounds != null) {
+			int otherBoundsLength = otherBounds.length;
+			char[][] boundNames = new char[otherBoundsLength+1][];
+			boundNames[0] = CharOperation.concatWith(firstBound.getParameterizedTypeName(), '.');
+			for (int j = 0; j < otherBoundsLength; j++) {
+				boundNames[j+1] = 
+					CharOperation.concatWith(otherBounds[j].getParameterizedTypeName(), '.'); 
+			}
+			typeParameterBounds = boundNames;
+		} else {
+			typeParameterBounds = new char[][] { CharOperation.concatWith(firstBound.getParameterizedTypeName(), '.')};
+		}
+	} else {
+		typeParameterBounds = CharOperation.NO_CHAR_CHAR;
+	}
+	
+	return typeParameterBounds;
+}
+private ISourceElementRequestor.TypeParameterInfo[] getTypeParameterInfos(TypeParameter[] typeParameters) {
+	if (typeParameters == null) return null;
+	int typeParametersLength = typeParameters.length;
+	ISourceElementRequestor.TypeParameterInfo[] result = new ISourceElementRequestor.TypeParameterInfo[typeParametersLength];
+	for (int i = 0; i < typeParametersLength; i++) {
+		TypeParameter typeParameter = typeParameters[i];
+		char[][] typeParameterBounds = this.getTypeParameterBounds(typeParameter);
+		ISourceElementRequestor.TypeParameterInfo typeParameterInfo = new ISourceElementRequestor.TypeParameterInfo();
+		typeParameterInfo.declarationStart = typeParameter.declarationSourceStart;
+		typeParameterInfo.declarationEnd = typeParameter.declarationSourceEnd;
+		typeParameterInfo.name = typeParameter.name;
+		typeParameterInfo.nameSourceStart = typeParameter.sourceStart;
+		typeParameterInfo.nameSourceEnd = typeParameter.sourceEnd;
+		typeParameterInfo.bounds = typeParameterBounds;
+		result[i] = typeParameterInfo;
+	}
+	return result;
+}
+/*
+ * Checks whether one of the annotations is the @Deprecated annotation
+ * (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=89807)
+ */
+private boolean hasDeprecatedAnnotation(Annotation[] annotations) {
+	if (annotations != null) {
+		for (int i = 0, length = annotations.length; i < length; i++) {
+			Annotation annotation = annotations[i];
+			if (CharOperation.equals(annotation.type.getLastToken(), TypeConstants.JAVA_LANG_DEPRECATED[2])) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+/*
+ * Update the bodyStart of the corresponding parse node
+ */
+protected void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration) {
+
+	// range check
+	boolean isInRange = 
+				initialPosition <= methodDeclaration.declarationSourceStart
+				&& eofPosition >= methodDeclaration.declarationSourceEnd;
+
+	if (methodDeclaration.isClinit()) {
+		this.visitIfNeeded(methodDeclaration);
+		return;
+	}
+
+	if (methodDeclaration.isDefaultConstructor()) {
+		if (reportReferenceInfo) {
+			ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) methodDeclaration;
+			ExplicitConstructorCall constructorCall = constructorDeclaration.constructorCall;
+			if (constructorCall != null) {
+				switch(constructorCall.accessMode) {
+					case ExplicitConstructorCall.This :
+						requestor.acceptConstructorReference(
+							typeNames[nestedTypeIndex-1],
+							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
+							constructorCall.sourceStart);
+						break;
+					case ExplicitConstructorCall.Super :
+					case ExplicitConstructorCall.ImplicitSuper :					
+						requestor.acceptConstructorReference(
+							superTypeNames[nestedTypeIndex-1],
+							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
+							constructorCall.sourceStart);
+						break;
+				}
+			}
+		}	
+		return;	
+	}	
+	char[][] argumentTypes = null;
+	char[][] argumentNames = null;
+	boolean isVarArgs = false;
+	Argument[] arguments = methodDeclaration.arguments;
+	if (arguments != null) {
+		char[][][] argumentTypesAndNames = this.getArguments(arguments);
+		argumentTypes = argumentTypesAndNames[0];
+		argumentNames = argumentTypesAndNames[1];
+		
+		isVarArgs = arguments[arguments.length-1].isVarArgs();
+	}
+	char[][] thrownExceptionTypes = getThrownExceptions(methodDeclaration);
+	// by default no selector end position
+	int selectorSourceEnd = -1;
+	if (methodDeclaration.isConstructor()) {
+		selectorSourceEnd = this.sourceEnds.get(methodDeclaration);
+		if (isInRange){
+			int currentModifiers = methodDeclaration.modifiers;
+			if (isVarArgs)
+				currentModifiers |= ClassFileConstants.AccVarargs;
+			
+			// remember deprecation so as to not lose it below
+			boolean deprecated = (currentModifiers & ClassFileConstants.AccDeprecated) != 0 || hasDeprecatedAnnotation(methodDeclaration.annotations);
+			
+			ISourceElementRequestor.MethodInfo methodInfo = new ISourceElementRequestor.MethodInfo();
+			methodInfo.isConstructor = true;
+			methodInfo.declarationStart = methodDeclaration.declarationSourceStart;
+			methodInfo.modifiers = deprecated ? (currentModifiers & ExtraCompilerModifiers.AccJustFlag) | ClassFileConstants.AccDeprecated : currentModifiers & ExtraCompilerModifiers.AccJustFlag;
+			methodInfo.name = methodDeclaration.selector;
+			methodInfo.nameSourceStart = methodDeclaration.sourceStart;
+			methodInfo.nameSourceEnd = selectorSourceEnd;
+			methodInfo.parameterTypes = argumentTypes;
+			methodInfo.parameterNames = argumentNames;
+			methodInfo.exceptionTypes = thrownExceptionTypes;
+			methodInfo.typeParameters = getTypeParameterInfos(methodDeclaration.typeParameters());
+			methodInfo.categories = (char[][]) this.nodesToCategories.get(methodDeclaration);
+			methodInfo.annotations = methodDeclaration.annotations;
+			methodInfo.node = methodDeclaration;
+			requestor.enterConstructor(methodInfo);
+		}
+		if (reportReferenceInfo) {
+			ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) methodDeclaration;
+			ExplicitConstructorCall constructorCall = constructorDeclaration.constructorCall;
+			if (constructorCall != null) {
+				switch(constructorCall.accessMode) {
+					case ExplicitConstructorCall.This :
+						requestor.acceptConstructorReference(
+							typeNames[nestedTypeIndex-1],
+							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
+							constructorCall.sourceStart);
+						break;
+					case ExplicitConstructorCall.Super :
+					case ExplicitConstructorCall.ImplicitSuper :
+						requestor.acceptConstructorReference(
+							superTypeNames[nestedTypeIndex-1],
+							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
+							constructorCall.sourceStart);
+						break;
+				}
+			}
+		}
+		this.visitIfNeeded(methodDeclaration);
+		if (isInRange){
+			requestor.exitConstructor(methodDeclaration.declarationSourceEnd);
+		}
+		return;
+	}
+	selectorSourceEnd = this.sourceEnds.get(methodDeclaration);
+	if (isInRange) {
+		int currentModifiers = methodDeclaration.modifiers;
+		if (isVarArgs)
+			currentModifiers |= ClassFileConstants.AccVarargs;
+		
+		// remember deprecation so as to not lose it below
+		boolean deprecated = (currentModifiers & ClassFileConstants.AccDeprecated) != 0 || hasDeprecatedAnnotation(methodDeclaration.annotations);	
+			
+		TypeReference returnType = methodDeclaration instanceof MethodDeclaration
+			? ((MethodDeclaration) methodDeclaration).returnType
+			: null;
+		ISourceElementRequestor.MethodInfo methodInfo = new ISourceElementRequestor.MethodInfo();
+		methodInfo.isAnnotation = methodDeclaration instanceof AnnotationMethodDeclaration;
+		methodInfo.declarationStart = methodDeclaration.declarationSourceStart;
+		methodInfo.modifiers = deprecated ? (currentModifiers & ExtraCompilerModifiers.AccJustFlag) | ClassFileConstants.AccDeprecated : currentModifiers & ExtraCompilerModifiers.AccJustFlag;
+		methodInfo.returnType = returnType == null ? null : CharOperation.concatWith(returnType.getParameterizedTypeName(), '.');
+		methodInfo.name = methodDeclaration.selector;
+		methodInfo.nameSourceStart = methodDeclaration.sourceStart;
+		methodInfo.nameSourceEnd = selectorSourceEnd;
+		methodInfo.parameterTypes = argumentTypes;
+		methodInfo.parameterNames = argumentNames;
+		methodInfo.exceptionTypes = thrownExceptionTypes;
+		methodInfo.typeParameters = getTypeParameterInfos(methodDeclaration.typeParameters());
+		methodInfo.categories = (char[][]) this.nodesToCategories.get(methodDeclaration);
+		methodInfo.annotations = methodDeclaration.annotations;
+		methodInfo.node = methodDeclaration;
+		requestor.enterMethod(methodInfo);
+	}		
+		
+	this.visitIfNeeded(methodDeclaration);
+
+	if (isInRange) {
+		if (methodDeclaration instanceof AnnotationMethodDeclaration) {
+			AnnotationMethodDeclaration annotationMethodDeclaration = (AnnotationMethodDeclaration) methodDeclaration;
+			Expression expression = annotationMethodDeclaration.defaultValue;
+			if (expression != null) {
+				requestor.exitMethod(methodDeclaration.declarationSourceEnd, expression);
+				return;
+			}
+		} 
+		requestor.exitMethod(methodDeclaration.declarationSourceEnd, null);
+	}
+}
+
+/*
+ * Update the bodyStart of the corresponding parse node
+ */
+public void notifySourceElementRequestor(
+		CompilationUnitDeclaration parsedUnit,
+		int sourceStart,
+		int sourceEnd,
+		boolean reportReference,
+		HashtableOfObjectToInt sourceEndsMap,
+		Map nodesToCategoriesMap) {
+	
+	this.initialPosition = sourceStart;
+	this.eofPosition = sourceEnd;
+	
+	this.reportReferenceInfo = reportReference;
+	this.sourceEnds = sourceEndsMap;
+	this.nodesToCategories = nodesToCategoriesMap;
+	
+	try {
+		// range check
+		boolean isInRange = 
+					initialPosition <= parsedUnit.sourceStart
+					&& eofPosition >= parsedUnit.sourceEnd;
+		
+		// collect the top level ast nodes
+		int length = 0;
+		ASTNode[] nodes = null;
+		if (isInRange) {
+			requestor.enterCompilationUnit();
+		}
+		ImportReference currentPackage = parsedUnit.currentPackage;
+		ImportReference[] imports = parsedUnit.imports;
+		TypeDeclaration[] types = parsedUnit.types;
+		length = 
+			(currentPackage == null ? 0 : 1) 
+			+ (imports == null ? 0 : imports.length)
+			+ (types == null ? 0 : types.length);
+		nodes = new ASTNode[length];
+		int index = 0;
+		if (currentPackage != null) {
+			nodes[index++] = currentPackage;
+		}
+		if (imports != null) {
+			for (int i = 0, max = imports.length; i < max; i++) {
+				nodes[index++] = imports[i];
+			}
+		}
+		if (types != null) {
+			for (int i = 0, max = types.length; i < max; i++) {
+				nodes[index++] = types[i];
+			}
+		}
+		
+		// notify the nodes in the syntactical order
+		if (length > 0) {
+			quickSort(nodes, 0, length-1);
+			for (int i=0;i<length;i++) {
+				ASTNode node = nodes[i];
+				if (node instanceof ImportReference) {
+					ImportReference importRef = (ImportReference)node;
+					if (node == parsedUnit.currentPackage) {
+						notifySourceElementRequestor(importRef, true);
+					} else {
+						notifySourceElementRequestor(importRef, false);
+					}
+				} else { // instanceof TypeDeclaration
+					notifySourceElementRequestor((TypeDeclaration)node, true, null);
+				}
+			}
+		}
+		
+		if (isInRange) {
+			requestor.exitCompilationUnit(parsedUnit.sourceEnd);
+		}
+	} finally {
+		this.reset();
+	}
+}
+
+/*
+* Update the bodyStart of the corresponding parse node
+*/
+protected void notifySourceElementRequestor(FieldDeclaration fieldDeclaration, TypeDeclaration declaringType) {
+	
+	// range check
+	boolean isInRange = 
+				initialPosition <= fieldDeclaration.declarationSourceStart
+				&& eofPosition >= fieldDeclaration.declarationSourceEnd;
+
+	switch(fieldDeclaration.getKind()) {
+		case AbstractVariableDeclaration.ENUM_CONSTANT:
+			if (this.reportReferenceInfo) {
+				// accept constructor reference for enum constant
+				if (fieldDeclaration.initialization instanceof AllocationExpression) {
+					AllocationExpression alloc = (AllocationExpression) fieldDeclaration.initialization;
+					requestor.acceptConstructorReference(
+						declaringType.name,
+						alloc.arguments == null ? 0 : alloc.arguments.length, 
+						alloc.sourceStart);
+				}
+			}
+			// fall through next case
+		case AbstractVariableDeclaration.FIELD:
+			int fieldEndPosition = this.sourceEnds.get(fieldDeclaration);
+			if (fieldEndPosition == -1) {
+				// use the declaration source end by default
+				fieldEndPosition = fieldDeclaration.declarationSourceEnd;
+			}
+			if (isInRange) {
+				int currentModifiers = fieldDeclaration.modifiers;
+				
+				// remember deprecation so as to not lose it below
+				boolean deprecated = (currentModifiers & ClassFileConstants.AccDeprecated) != 0 || hasDeprecatedAnnotation(fieldDeclaration.annotations);	
+			
+				char[] typeName = null;
+				if (fieldDeclaration.type == null) {
+					// enum constant
+					typeName = declaringType.name;
+					currentModifiers |= ClassFileConstants.AccEnum;
+				} else {
+					// regular field
+					typeName = CharOperation.concatWith(fieldDeclaration.type.getParameterizedTypeName(), '.');
+				}
+				ISourceElementRequestor.FieldInfo fieldInfo = new ISourceElementRequestor.FieldInfo();
+				fieldInfo.declarationStart = fieldDeclaration.declarationSourceStart;
+				fieldInfo.name = fieldDeclaration.name;
+				fieldInfo.modifiers = deprecated ? (currentModifiers & ExtraCompilerModifiers.AccJustFlag) | ClassFileConstants.AccDeprecated : currentModifiers & ExtraCompilerModifiers.AccJustFlag;
+				fieldInfo.type = typeName;
+				fieldInfo.nameSourceStart = fieldDeclaration.sourceStart;
+				fieldInfo.nameSourceEnd = fieldDeclaration.sourceEnd;
+				fieldInfo.categories = (char[][]) this.nodesToCategories.get(fieldDeclaration);
+				fieldInfo.annotations = fieldDeclaration.annotations;
+				fieldInfo.node = fieldDeclaration;
+				requestor.enterField(fieldInfo);
+			}
+			this.visitIfNeeded(fieldDeclaration, declaringType);
+			if (isInRange){
+				requestor.exitField(
+					// filter out initializations that are not a constant (simple check)
+					(fieldDeclaration.initialization == null 
+							|| fieldDeclaration.initialization instanceof ArrayInitializer
+							|| fieldDeclaration.initialization instanceof AllocationExpression
+							|| fieldDeclaration.initialization instanceof ArrayAllocationExpression
+							|| fieldDeclaration.initialization instanceof Assignment
+							|| fieldDeclaration.initialization instanceof ClassLiteralAccess
+							|| fieldDeclaration.initialization instanceof MessageSend
+							|| fieldDeclaration.initialization instanceof ArrayReference
+							|| fieldDeclaration.initialization instanceof ThisReference) ? 
+						-1 :  
+						fieldDeclaration.initialization.sourceStart, 
+					fieldEndPosition,
+					fieldDeclaration.declarationSourceEnd);
+			}
+			break;
+		case AbstractVariableDeclaration.INITIALIZER:
+			if (isInRange){
+				requestor.enterInitializer(
+					fieldDeclaration.declarationSourceStart,
+					fieldDeclaration.modifiers); 
+			}
+			this.visitIfNeeded((Initializer)fieldDeclaration);
+			if (isInRange){
+				requestor.exitInitializer(fieldDeclaration.declarationSourceEnd);
+			}
+			break;
+	}
+}
+protected void notifySourceElementRequestor(
+	ImportReference importReference, 
+	boolean isPackage) {
+	if (isPackage) {
+		requestor.acceptPackage(importReference); 
+	} else {
+		requestor.acceptImport(
+			importReference.declarationSourceStart, 
+			importReference.declarationSourceEnd, 
+			importReference.tokens, 
+			(importReference.bits & ASTNode.OnDemand) != 0,
+			importReference.modifiers); 
+	}
+}
+protected void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence, TypeDeclaration declaringType) {
+	
+	if (CharOperation.equals(TypeConstants.PACKAGE_INFO_NAME, typeDeclaration.name)) return;
+
+	// range check
+	boolean isInRange = 
+		initialPosition <= typeDeclaration.declarationSourceStart
+		&& eofPosition >= typeDeclaration.declarationSourceEnd;
+	
+	FieldDeclaration[] fields = typeDeclaration.fields;
+	AbstractMethodDeclaration[] methods = typeDeclaration.methods;
+	TypeDeclaration[] memberTypes = typeDeclaration.memberTypes;
+	int fieldCounter = fields == null ? 0 : fields.length;
+	int methodCounter = methods == null ? 0 : methods.length;
+	int memberTypeCounter = memberTypes == null ? 0 : memberTypes.length;
+	int fieldIndex = 0;
+	int methodIndex = 0;
+	int memberTypeIndex = 0;
+	
+	if (notifyTypePresence){
+		char[][] interfaceNames = getInterfaceNames(typeDeclaration);
+		int kind = TypeDeclaration.kind(typeDeclaration.modifiers);
+		char[] implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_OBJECT;
+		if (isInRange) {
+			int currentModifiers = typeDeclaration.modifiers;
+			
+			// remember deprecation so as to not lose it below
+			boolean deprecated = (currentModifiers & ClassFileConstants.AccDeprecated) != 0 || hasDeprecatedAnnotation(typeDeclaration.annotations);	
+			
+			boolean isEnumInit = typeDeclaration.allocation != null && typeDeclaration.allocation.enumConstant != null;
+			char[] superclassName;
+			if (isEnumInit) {
+				currentModifiers |= ClassFileConstants.AccEnum;
+				superclassName = declaringType.name;
+			} else {
+				superclassName = getSuperclassName(typeDeclaration);
+			}
+			ISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();
+			typeInfo.declarationStart = typeDeclaration.allocation == null ? typeDeclaration.declarationSourceStart : typeDeclaration.allocation.sourceStart;
+			typeInfo.modifiers = deprecated ? (currentModifiers & ExtraCompilerModifiers.AccJustFlag) | ClassFileConstants.AccDeprecated : currentModifiers & ExtraCompilerModifiers.AccJustFlag;
+			typeInfo.name = typeDeclaration.name;
+			typeInfo.nameSourceStart = typeDeclaration.sourceStart;
+			typeInfo.nameSourceEnd = sourceEnd(typeDeclaration);
+			typeInfo.superclass = superclassName;
+			typeInfo.superinterfaces = interfaceNames;
+			typeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);
+			typeInfo.categories = (char[][]) this.nodesToCategories.get(typeDeclaration);
+			typeInfo.secondary = typeDeclaration.isSecondary();
+			typeInfo.anonymousMember = typeDeclaration.allocation != null && typeDeclaration.allocation.enclosingInstance != null;
+			typeInfo.annotations = typeDeclaration.annotations;
+			typeInfo.node = typeDeclaration;
+			requestor.enterType(typeInfo);
+			switch (kind) {
+				case TypeDeclaration.CLASS_DECL :
+					if (superclassName != null)
+						implicitSuperclassName = superclassName;
+					break;
+				case TypeDeclaration.INTERFACE_DECL :
+					implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_OBJECT;
+					break;
+				case TypeDeclaration.ENUM_DECL :
+					implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_ENUM;
+					break;
+				case TypeDeclaration.ANNOTATION_TYPE_DECL :
+					implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_ANNOTATION_ANNOTATION;
+					break;
+			}
+		}
+		if (this.nestedTypeIndex == this.typeNames.length) {
+			// need a resize
+			System.arraycopy(this.typeNames, 0, (this.typeNames = new char[this.nestedTypeIndex * 2][]), 0, this.nestedTypeIndex);
+			System.arraycopy(this.superTypeNames, 0, (this.superTypeNames = new char[this.nestedTypeIndex * 2][]), 0, this.nestedTypeIndex);
+		}
+		this.typeNames[this.nestedTypeIndex] = typeDeclaration.name;
+		this.superTypeNames[this.nestedTypeIndex++] = implicitSuperclassName;
+	}
+	while ((fieldIndex < fieldCounter)
+			|| (memberTypeIndex < memberTypeCounter)
+			|| (methodIndex < methodCounter)) {
+		FieldDeclaration nextFieldDeclaration = null;
+		AbstractMethodDeclaration nextMethodDeclaration = null;
+		TypeDeclaration nextMemberDeclaration = null;
+		
+		int position = Integer.MAX_VALUE;
+		int nextDeclarationType = -1;
+		if (fieldIndex < fieldCounter) {
+			nextFieldDeclaration = fields[fieldIndex];
+			if (nextFieldDeclaration.declarationSourceStart < position) {
+				position = nextFieldDeclaration.declarationSourceStart;
+				nextDeclarationType = 0; // FIELD
+			}
+		}
+		if (methodIndex < methodCounter) {
+			nextMethodDeclaration = methods[methodIndex];
+			if (nextMethodDeclaration.declarationSourceStart < position) {
+				position = nextMethodDeclaration.declarationSourceStart;
+				nextDeclarationType = 1; // METHOD
+			}
+		}
+		if (memberTypeIndex < memberTypeCounter) {
+			nextMemberDeclaration = memberTypes[memberTypeIndex];
+			if (nextMemberDeclaration.declarationSourceStart < position) {
+				position = nextMemberDeclaration.declarationSourceStart;
+				nextDeclarationType = 2; // MEMBER
+			}
+		}
+		switch (nextDeclarationType) {
+			case 0 :
+				fieldIndex++;
+				notifySourceElementRequestor(nextFieldDeclaration, typeDeclaration);
+				break;
+			case 1 :
+				methodIndex++;
+				notifySourceElementRequestor(nextMethodDeclaration);
+				break;
+			case 2 :
+				memberTypeIndex++;
+				notifySourceElementRequestor(nextMemberDeclaration, true, null);
+		}
+	}
+	if (notifyTypePresence){
+		if (isInRange){
+			requestor.exitType(typeDeclaration.declarationSourceEnd);
+		}
+		nestedTypeIndex--;
+	}
+}
+/*
+ * Sort the given ast nodes by their positions.
+ */
+private static void quickSort(ASTNode[] sortedCollection, int left, int right) {
+	int original_left = left;
+	int original_right = right;
+	ASTNode mid = sortedCollection[left +  (right - left) / 2];
+	do {
+		while (sortedCollection[left].sourceStart < mid.sourceStart) {
+			left++;
+		}
+		while (mid.sourceStart < sortedCollection[right].sourceStart) {
+			right--;
+		}
+		if (left <= right) {
+			ASTNode tmp = sortedCollection[left];
+			sortedCollection[left] = sortedCollection[right];
+			sortedCollection[right] = tmp;
+			left++;
+			right--;
+		}
+	} while (left <= right);
+	if (original_left < right) {
+		quickSort(sortedCollection, original_left, right);
+	}
+	if (left < original_right) {
+		quickSort(sortedCollection, left, original_right);
+	}
+}
+private void reset() {
+	typeNames = new char[4][];
+	superTypeNames = new char[4][];
+	nestedTypeIndex = 0;
+	
+	this.sourceEnds = null;
+}
+private int sourceEnd(TypeDeclaration typeDeclaration) {
+	if ((typeDeclaration.bits & ASTNode.IsAnonymousType) != 0) {
+		QualifiedAllocationExpression allocation = typeDeclaration.allocation;
+		if (allocation.type == null) // case of enum constant body
+			return typeDeclaration.sourceEnd;
+		return allocation.type.sourceEnd;
+	} else {
+		return typeDeclaration.sourceEnd;
+	}
+}
+private void visitIfNeeded(AbstractMethodDeclaration method) {
+	if (this.localDeclarationVisitor != null 
+		&& (method.bits & ASTNode.HasLocalType) != 0) {
+			if (method instanceof ConstructorDeclaration) {
+				ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) method;
+				if (constructorDeclaration.constructorCall != null) {
+					constructorDeclaration.constructorCall.traverse(this.localDeclarationVisitor, method.scope);
+				}
+			}
+			if (method.statements != null) {
+				int statementsLength = method.statements.length;
+				for (int i = 0; i < statementsLength; i++)
+					method.statements[i].traverse(this.localDeclarationVisitor, method.scope);
+			}
+	}
+}
+
+private void visitIfNeeded(FieldDeclaration field, TypeDeclaration declaringType) {
+	if (this.localDeclarationVisitor != null 
+		&& (field.bits & ASTNode.HasLocalType) != 0) {
+			if (field.initialization != null) {
+				try {
+					this.localDeclarationVisitor.pushDeclaringType(declaringType);
+					field.initialization.traverse(this.localDeclarationVisitor, (MethodScope) null);
+				} finally {
+					this.localDeclarationVisitor.popDeclaringType();
+				}
+			}
+	}
+}
+
+private void visitIfNeeded(Initializer initializer) {
+	if (this.localDeclarationVisitor != null 
+		&& (initializer.bits & ASTNode.HasLocalType) != 0) {
+			if (initializer.block != null) {
+				initializer.block.traverse(this.localDeclarationVisitor, null);
+			}
+	}
+}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java
index ea05017..9c786b5 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementParser.java
@@ -10,7 +10,6 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler;
 
-import java.util.ArrayList;
 import java.util.HashMap;
 
 import org.eclipse.core.runtime.IProgressMonitor;
@@ -46,46 +45,14 @@ import org.eclipse.jdt.internal.core.util.Messages;
  */
 public class SourceElementParser extends CommentRecorderParser {
 	
-	public ISourceElementRequestor requestor;
-	ISourceType sourceType;
+	ISourceElementRequestor requestor;
 	boolean reportReferenceInfo;
-	char[][] typeNames;
-	char[][] superTypeNames;
-	int nestedTypeIndex;
-	LocalDeclarationVisitor localDeclarationVisitor = null;
+	boolean reportLocalDeclarations;
 	HashtableOfObjectToInt sourceEnds = new HashtableOfObjectToInt();
 	HashMap nodesToCategories = new HashMap(); // a map from ASTNode to char[][]
 	boolean useSourceJavadocParser = true;
 	
-/**
- * An ast visitor that visits local type declarations.
- */
-public class LocalDeclarationVisitor extends ASTVisitor {
-	ArrayList declaringTypes;
-	public void pushDeclaringType(TypeDeclaration declaringType) {
-		if (this.declaringTypes == null) {
-			this.declaringTypes = new ArrayList();
-		}
-		this.declaringTypes.add(declaringType);
-	}
-	public void popDeclaringType() {
-		this.declaringTypes.remove(this.declaringTypes.size()-1);
-	}
-	public TypeDeclaration peekDeclaringType() {
-		if (this.declaringTypes == null) return null;
-		int size = this.declaringTypes.size();
-		if (size == 0) return null;
-		return (TypeDeclaration) this.declaringTypes.get(size-1);
-	}
-	public boolean visit(TypeDeclaration typeDeclaration, BlockScope scope) {
-		notifySourceElementRequestor(typeDeclaration, sourceType == null, peekDeclaringType());
-		return false; // don't visit members as this was done during notifySourceElementRequestor(...)
-	}
-	public boolean visit(TypeDeclaration typeDeclaration, ClassScope scope) {
-		notifySourceElementRequestor(typeDeclaration, sourceType == null, peekDeclaringType());
-		return false; // don't visit members as this was done during notifySourceElementRequestor(...)
-	}	
-}
+	SourceElementNotifier notifier;
 
 public SourceElementParser(
 		final ISourceElementRequestor requestor, 
@@ -111,6 +78,8 @@ public SourceElementParser(
 			problemFactory),
 		optimizeStringLiterals);
 	
+	this.reportLocalDeclarations = reportLocalDeclarations;
+	
 	// we want to notify all syntax error with the acceptProblem API
 	// To do so, we define the record method of the ProblemReporter
 	this.problemReporter = new ProblemReporter(
@@ -123,13 +92,10 @@ public SourceElementParser(
 		}
 	};
 	this.requestor = requestor;
-	typeNames = new char[4][];
-	superTypeNames = new char[4][];
-	nestedTypeIndex = 0;
 	this.options = options;
-	if (reportLocalDeclarations) {
-		this.localDeclarationVisitor = new LocalDeclarationVisitor();
-	}
+	
+	this.notifier = new SourceElementNotifier(this.requestor, reportLocalDeclarations);
+	
 	// set specific javadoc parser
 	this.useSourceJavadocParser = useSourceJavadocParser;
 	if (useSourceJavadocParser) {
@@ -735,22 +701,6 @@ public MethodDeclaration convertToMethodDeclaration(ConstructorDeclaration c, Co
 	return methodDeclaration;
 }
 protected CompilationUnitDeclaration endParse(int act) {
-	if (sourceType != null) {
-		switch (TypeDeclaration.kind(sourceType.getModifiers())) {
-			case TypeDeclaration.CLASS_DECL :
-				consumeClassDeclaration();
-				break;
-			case TypeDeclaration.INTERFACE_DECL :
-				consumeInterfaceDeclaration();
-				break;
-			case TypeDeclaration.ENUM_DECL :
-				consumeEnumDeclaration();
-				break;
-			case TypeDeclaration.ANNOTATION_TYPE_DECL :
-				consumeAnnotationTypeDeclaration();
-				break;
-		}
-	}
 	if (compilationUnit != null) {
 		CompilationUnitDeclaration result = super.endParse(act);
 		return result;
@@ -758,42 +708,6 @@ protected CompilationUnitDeclaration endParse(int act) {
 		return null;
 	}		
 }
-private ISourceElementRequestor.TypeParameterInfo[] getTypeParameterInfos(TypeParameter[] typeParameters) {
-	if (typeParameters == null) return null;
-	int typeParametersLength = typeParameters.length;
-	ISourceElementRequestor.TypeParameterInfo[] result = new ISourceElementRequestor.TypeParameterInfo[typeParametersLength];
-	for (int i = 0; i < typeParametersLength; i++) {
-		TypeParameter typeParameter = typeParameters[i];
-		TypeReference firstBound = typeParameter.type;
-		TypeReference[] otherBounds = typeParameter.bounds;
-		char[][] typeParameterBounds = null;
-		if (firstBound != null) {
-			if (otherBounds != null) {
-				int otherBoundsLength = otherBounds.length;
-				char[][] boundNames = new char[otherBoundsLength+1][];
-				boundNames[0] = CharOperation.concatWith(firstBound.getParameterizedTypeName(), '.');
-				for (int j = 0; j < otherBoundsLength; j++) {
-					boundNames[j+1] = 
-						CharOperation.concatWith(otherBounds[j].getParameterizedTypeName(), '.'); 
-				}
-				typeParameterBounds = boundNames;
-			} else {
-				typeParameterBounds = new char[][] { CharOperation.concatWith(firstBound.getParameterizedTypeName(), '.')};
-			}
-		} else {
-			typeParameterBounds = CharOperation.NO_CHAR_CHAR;
-		}
-		ISourceElementRequestor.TypeParameterInfo typeParameterInfo = new ISourceElementRequestor.TypeParameterInfo();
-		typeParameterInfo.declarationStart = typeParameter.declarationSourceStart;
-		typeParameterInfo.declarationEnd = typeParameter.declarationSourceEnd;
-		typeParameterInfo.name = typeParameter.name;
-		typeParameterInfo.nameSourceStart = typeParameter.sourceStart;
-		typeParameterInfo.nameSourceEnd = typeParameter.sourceEnd;
-		typeParameterInfo.bounds = typeParameterBounds;
-		result[i] = typeParameterInfo;
-	}
-	return result;
-}
 public TypeReference getTypeReference(int dim) {
 	/* build a Reference on a variable that may be qualified or not
 	 * This variable is a type reference and dim will be its dimensions
@@ -962,23 +876,6 @@ public NameReference getUnspecifiedReferenceOptimized() {
 	}
 	return ref;
 }
-
-/*
- * Checks whether one of the annotations is the @Deprecated annotation
- * (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=89807)
- */
-private boolean hasDeprecatedAnnotation(Annotation[] annotations) {
-	if (annotations != null) {
-		for (int i = 0, length = annotations.length; i < length; i++) {
-			Annotation annotation = annotations[i];
-			if (CharOperation.equals(annotation.type.getLastToken(), TypeConstants.JAVA_LANG_DEPRECATED[2])) {
-				return true;
-			}
-		}
-	}
-	return false;
-}
-
 protected ImportReference newImportReference(char[][] tokens, long[] positions, boolean onDemand, int mod) {
 	return new ImportReference(tokens, positions, onDemand, mod);
 }
@@ -988,498 +885,6 @@ protected QualifiedNameReference newQualifiedNameReference(char[][] tokens, long
 protected SingleNameReference newSingleNameReference(char[] source, long positions) {
 	return new SingleNameReference(source, positions);
 }
-/*
- * Update the bodyStart of the corresponding parse node
- */
-public void notifySourceElementRequestor(CompilationUnitDeclaration parsedUnit) {
-	if (parsedUnit == null) {
-		// when we parse a single type member declaration the compilation unit is null, but we still
-		// want to be able to notify the requestor on the created ast node
-		if (astStack[0] instanceof AbstractMethodDeclaration) {
-			notifySourceElementRequestor((AbstractMethodDeclaration) astStack[0]);
-			return;
-		}
-		return;
-	}
-	// range check
-	boolean isInRange = 
-				scanner.initialPosition <= parsedUnit.sourceStart
-				&& scanner.eofPosition >= parsedUnit.sourceEnd;
-	
-	// collect the top level ast nodes
-	int length = 0;
-	ASTNode[] nodes = null;
-	if (sourceType == null){
-		if (isInRange) {
-			requestor.enterCompilationUnit();
-		}
-		ImportReference currentPackage = parsedUnit.currentPackage;
-		ImportReference[] imports = parsedUnit.imports;
-		TypeDeclaration[] types = parsedUnit.types;
-		length = 
-			(currentPackage == null ? 0 : 1) 
-			+ (imports == null ? 0 : imports.length)
-			+ (types == null ? 0 : types.length);
-		nodes = new ASTNode[length];
-		int index = 0;
-		if (currentPackage != null) {
-			nodes[index++] = currentPackage;
-		}
-		if (imports != null) {
-			for (int i = 0, max = imports.length; i < max; i++) {
-				nodes[index++] = imports[i];
-			}
-		}
-		if (types != null) {
-			for (int i = 0, max = types.length; i < max; i++) {
-				nodes[index++] = types[i];
-			}
-		}
-	} else {
-		TypeDeclaration[] types = parsedUnit.types;
-		if (types != null) {
-			length = types.length;
-			nodes = new ASTNode[length];
-			for (int i = 0, max = types.length; i < max; i++) {
-				nodes[i] = types[i];
-			}
-		}
-	}
-	
-	// notify the nodes in the syntactical order
-	if (nodes != null && length > 0) {
-		quickSort(nodes, 0, length-1);
-		for (int i=0;i<length;i++) {
-			ASTNode node = nodes[i];
-			if (node instanceof ImportReference) {
-				ImportReference importRef = (ImportReference)node;
-				if (node == parsedUnit.currentPackage) {
-					notifySourceElementRequestor(importRef, true);
-				} else {
-					notifySourceElementRequestor(importRef, false);
-				}
-			} else { // instanceof TypeDeclaration
-				notifySourceElementRequestor((TypeDeclaration)node, sourceType == null, null);
-			}
-		}
-	}
-	
-	if (sourceType == null){
-		if (isInRange) {
-			requestor.exitCompilationUnit(parsedUnit.sourceEnd);
-		}
-	}
-}
-
-/*
- * Update the bodyStart of the corresponding parse node
- */
-public void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration) {
-
-	// range check
-	boolean isInRange = 
-				scanner.initialPosition <= methodDeclaration.declarationSourceStart
-				&& scanner.eofPosition >= methodDeclaration.declarationSourceEnd;
-
-	if (methodDeclaration.isClinit()) {
-		this.visitIfNeeded(methodDeclaration);
-		return;
-	}
-
-	if (methodDeclaration.isDefaultConstructor()) {
-		if (reportReferenceInfo) {
-			ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) methodDeclaration;
-			ExplicitConstructorCall constructorCall = constructorDeclaration.constructorCall;
-			if (constructorCall != null) {
-				switch(constructorCall.accessMode) {
-					case ExplicitConstructorCall.This :
-						requestor.acceptConstructorReference(
-							typeNames[nestedTypeIndex-1],
-							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
-							constructorCall.sourceStart);
-						break;
-					case ExplicitConstructorCall.Super :
-					case ExplicitConstructorCall.ImplicitSuper :					
-						requestor.acceptConstructorReference(
-							superTypeNames[nestedTypeIndex-1],
-							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
-							constructorCall.sourceStart);
-						break;
-				}
-			}
-		}	
-		return;	
-	}	
-	char[][] argumentTypes = null;
-	char[][] argumentNames = null;
-	boolean isVarArgs = false;
-	Argument[] arguments = methodDeclaration.arguments;
-	if (arguments != null) {
-		int argumentLength = arguments.length;
-		argumentTypes = new char[argumentLength][];
-		argumentNames = new char[argumentLength][];
-		for (int i = 0; i < argumentLength; i++) {
-			argumentTypes[i] = CharOperation.concatWith(arguments[i].type.getParameterizedTypeName(), '.');
-			argumentNames[i] = arguments[i].name;
-		}
-		isVarArgs = arguments[argumentLength-1].isVarArgs();
-	}
-	char[][] thrownExceptionTypes = null;
-	TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;
-	if (thrownExceptions != null) {
-		int thrownExceptionLength = thrownExceptions.length;
-		thrownExceptionTypes = new char[thrownExceptionLength][];
-		for (int i = 0; i < thrownExceptionLength; i++) {
-			thrownExceptionTypes[i] = 
-				CharOperation.concatWith(thrownExceptions[i].getParameterizedTypeName(), '.'); 
-		}
-	}
-	// by default no selector end position
-	int selectorSourceEnd = -1;
-	if (methodDeclaration.isConstructor()) {
-		selectorSourceEnd = this.sourceEnds.get(methodDeclaration);
-		if (isInRange){
-			int currentModifiers = methodDeclaration.modifiers;
-			if (isVarArgs)
-				currentModifiers |= ClassFileConstants.AccVarargs;
-			
-			// remember deprecation so as to not lose it below
-			boolean deprecated = (currentModifiers & ClassFileConstants.AccDeprecated) != 0 || hasDeprecatedAnnotation(methodDeclaration.annotations);
-			
-			ISourceElementRequestor.MethodInfo methodInfo = new ISourceElementRequestor.MethodInfo();
-			methodInfo.isConstructor = true;
-			methodInfo.declarationStart = methodDeclaration.declarationSourceStart;
-			methodInfo.modifiers = deprecated ? (currentModifiers & ExtraCompilerModifiers.AccJustFlag) | ClassFileConstants.AccDeprecated : currentModifiers & ExtraCompilerModifiers.AccJustFlag;
-			methodInfo.name = methodDeclaration.selector;
-			methodInfo.nameSourceStart = methodDeclaration.sourceStart;
-			methodInfo.nameSourceEnd = selectorSourceEnd;
-			methodInfo.parameterTypes = argumentTypes;
-			methodInfo.parameterNames = argumentNames;
-			methodInfo.exceptionTypes = thrownExceptionTypes;
-			methodInfo.typeParameters = getTypeParameterInfos(methodDeclaration.typeParameters());
-			methodInfo.categories = (char[][]) this.nodesToCategories.get(methodDeclaration);
-			methodInfo.annotations = methodDeclaration.annotations;
-			requestor.enterConstructor(methodInfo);
-		}
-		if (reportReferenceInfo) {
-			ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) methodDeclaration;
-			ExplicitConstructorCall constructorCall = constructorDeclaration.constructorCall;
-			if (constructorCall != null) {
-				switch(constructorCall.accessMode) {
-					case ExplicitConstructorCall.This :
-						requestor.acceptConstructorReference(
-							typeNames[nestedTypeIndex-1],
-							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
-							constructorCall.sourceStart);
-						break;
-					case ExplicitConstructorCall.Super :
-					case ExplicitConstructorCall.ImplicitSuper :
-						requestor.acceptConstructorReference(
-							superTypeNames[nestedTypeIndex-1],
-							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
-							constructorCall.sourceStart);
-						break;
-				}
-			}
-		}
-		this.visitIfNeeded(methodDeclaration);
-		if (isInRange){
-			requestor.exitConstructor(methodDeclaration.declarationSourceEnd);
-		}
-		return;
-	}
-	selectorSourceEnd = this.sourceEnds.get(methodDeclaration);
-	if (isInRange) {
-		int currentModifiers = methodDeclaration.modifiers;
-		if (isVarArgs)
-			currentModifiers |= ClassFileConstants.AccVarargs;
-		
-		// remember deprecation so as to not lose it below
-		boolean deprecated = (currentModifiers & ClassFileConstants.AccDeprecated) != 0 || hasDeprecatedAnnotation(methodDeclaration.annotations);	
-			
-		TypeReference returnType = methodDeclaration instanceof MethodDeclaration
-			? ((MethodDeclaration) methodDeclaration).returnType
-			: null;
-		ISourceElementRequestor.MethodInfo methodInfo = new ISourceElementRequestor.MethodInfo();
-		methodInfo.isAnnotation = methodDeclaration instanceof AnnotationMethodDeclaration;
-		methodInfo.declarationStart = methodDeclaration.declarationSourceStart;
-		methodInfo.modifiers = deprecated ? (currentModifiers & ExtraCompilerModifiers.AccJustFlag) | ClassFileConstants.AccDeprecated : currentModifiers & ExtraCompilerModifiers.AccJustFlag;
-		methodInfo.returnType = returnType == null ? null : CharOperation.concatWith(returnType.getParameterizedTypeName(), '.');
-		methodInfo.name = methodDeclaration.selector;
-		methodInfo.nameSourceStart = methodDeclaration.sourceStart;
-		methodInfo.nameSourceEnd = selectorSourceEnd;
-		methodInfo.parameterTypes = argumentTypes;
-		methodInfo.parameterNames = argumentNames;
-		methodInfo.exceptionTypes = thrownExceptionTypes;
-		methodInfo.typeParameters = getTypeParameterInfos(methodDeclaration.typeParameters());
-		methodInfo.categories = (char[][]) this.nodesToCategories.get(methodDeclaration);
-		methodInfo.annotations = methodDeclaration.annotations;
-		requestor.enterMethod(methodInfo);
-	}		
-		
-	this.visitIfNeeded(methodDeclaration);
-
-	if (isInRange) {
-		if (methodDeclaration instanceof AnnotationMethodDeclaration) {
-			AnnotationMethodDeclaration annotationMethodDeclaration = (AnnotationMethodDeclaration) methodDeclaration;
-			Expression expression = annotationMethodDeclaration.defaultValue;
-			if (expression != null) {
-				requestor.exitMethod(methodDeclaration.declarationSourceEnd, expression);
-				return;
-			}
-		} 
-		requestor.exitMethod(methodDeclaration.declarationSourceEnd, null);
-	}
-}
-
-/*
-* Update the bodyStart of the corresponding parse node
-*/
-public void notifySourceElementRequestor(FieldDeclaration fieldDeclaration, TypeDeclaration declaringType) {
-	
-	// range check
-	boolean isInRange = 
-				scanner.initialPosition <= fieldDeclaration.declarationSourceStart
-				&& scanner.eofPosition >= fieldDeclaration.declarationSourceEnd;
-
-	switch(fieldDeclaration.getKind()) {
-		case AbstractVariableDeclaration.ENUM_CONSTANT:
-			// accept constructor reference for enum constant
-			if (fieldDeclaration.initialization instanceof AllocationExpression) {
-				AllocationExpression alloc = (AllocationExpression) fieldDeclaration.initialization;
-				requestor.acceptConstructorReference(
-					declaringType.name,
-					alloc.arguments == null ? 0 : alloc.arguments.length, 
-					alloc.sourceStart);
-			}
-			// fall through next case
-		case AbstractVariableDeclaration.FIELD:
-			int fieldEndPosition = this.sourceEnds.get(fieldDeclaration);
-			if (fieldEndPosition == -1) {
-				// use the declaration source end by default
-				fieldEndPosition = fieldDeclaration.declarationSourceEnd;
-			}
-			if (isInRange) {
-				int currentModifiers = fieldDeclaration.modifiers;
-				
-				// remember deprecation so as to not lose it below
-				boolean deprecated = (currentModifiers & ClassFileConstants.AccDeprecated) != 0 || hasDeprecatedAnnotation(fieldDeclaration.annotations);	
-			
-				char[] typeName = null;
-				if (fieldDeclaration.type == null) {
-					// enum constant
-					typeName = declaringType.name;
-					currentModifiers |= ClassFileConstants.AccEnum;
-				} else {
-					// regular field
-					typeName = CharOperation.concatWith(fieldDeclaration.type.getParameterizedTypeName(), '.');
-				}
-				ISourceElementRequestor.FieldInfo fieldInfo = new ISourceElementRequestor.FieldInfo();
-				fieldInfo.declarationStart = fieldDeclaration.declarationSourceStart;
-				fieldInfo.name = fieldDeclaration.name;
-				fieldInfo.modifiers = deprecated ? (currentModifiers & ExtraCompilerModifiers.AccJustFlag) | ClassFileConstants.AccDeprecated : currentModifiers & ExtraCompilerModifiers.AccJustFlag;
-				fieldInfo.type = typeName;
-				fieldInfo.nameSourceStart = fieldDeclaration.sourceStart;
-				fieldInfo.nameSourceEnd = fieldDeclaration.sourceEnd;
-				fieldInfo.categories = (char[][]) this.nodesToCategories.get(fieldDeclaration);
-				fieldInfo.annotations = fieldDeclaration.annotations;
-				requestor.enterField(fieldInfo);
-			}
-			this.visitIfNeeded(fieldDeclaration, declaringType);
-			if (isInRange){
-				requestor.exitField(
-					// filter out initializations that are not a constant (simple check)
-					(fieldDeclaration.initialization == null 
-							|| fieldDeclaration.initialization instanceof ArrayInitializer
-							|| fieldDeclaration.initialization instanceof AllocationExpression
-							|| fieldDeclaration.initialization instanceof ArrayAllocationExpression
-							|| fieldDeclaration.initialization instanceof Assignment
-							|| fieldDeclaration.initialization instanceof ClassLiteralAccess
-							|| fieldDeclaration.initialization instanceof MessageSend
-							|| fieldDeclaration.initialization instanceof ArrayReference
-							|| fieldDeclaration.initialization instanceof ThisReference) ? 
-						-1 :  
-						fieldDeclaration.initialization.sourceStart, 
-					fieldEndPosition,
-					fieldDeclaration.declarationSourceEnd);
-			}
-			break;
-		case AbstractVariableDeclaration.INITIALIZER:
-			if (isInRange){
-				requestor.enterInitializer(
-					fieldDeclaration.declarationSourceStart,
-					fieldDeclaration.modifiers); 
-			}
-			this.visitIfNeeded((Initializer)fieldDeclaration);
-			if (isInRange){
-				requestor.exitInitializer(fieldDeclaration.declarationSourceEnd);
-			}
-			break;
-	}
-}
-public void notifySourceElementRequestor(
-	ImportReference importReference, 
-	boolean isPackage) {
-	if (isPackage) {
-		requestor.acceptPackage(importReference); 
-	} else {
-		requestor.acceptImport(
-			importReference.declarationSourceStart, 
-			importReference.declarationSourceEnd, 
-			importReference.tokens, 
-			(importReference.bits & ASTNode.OnDemand) != 0,
-			importReference.modifiers); 
-	}
-}
-public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence, TypeDeclaration declaringType) {
-	
-	if (CharOperation.equals(TypeConstants.PACKAGE_INFO_NAME, typeDeclaration.name)) return;
-
-	// range check
-	boolean isInRange = 
-		scanner.initialPosition <= typeDeclaration.declarationSourceStart
-		&& scanner.eofPosition >= typeDeclaration.declarationSourceEnd;
-	
-	FieldDeclaration[] fields = typeDeclaration.fields;
-	AbstractMethodDeclaration[] methods = typeDeclaration.methods;
-	TypeDeclaration[] memberTypes = typeDeclaration.memberTypes;
-	int fieldCounter = fields == null ? 0 : fields.length;
-	int methodCounter = methods == null ? 0 : methods.length;
-	int memberTypeCounter = memberTypes == null ? 0 : memberTypes.length;
-	int fieldIndex = 0;
-	int methodIndex = 0;
-	int memberTypeIndex = 0;
-	
-	if (notifyTypePresence){
-		char[][] interfaceNames = null;
-		int superInterfacesLength = 0;
-		TypeReference[] superInterfaces = typeDeclaration.superInterfaces;
-		if (superInterfaces != null) {
-			superInterfacesLength = superInterfaces.length;
-			interfaceNames = new char[superInterfacesLength][];
-		} else {
-			if ((typeDeclaration.bits & ASTNode.IsAnonymousType) != 0) {
-				// see PR 3442
-				QualifiedAllocationExpression alloc = typeDeclaration.allocation;
-				if (alloc != null && alloc.type != null) {
-					superInterfaces = new TypeReference[] { alloc.type};
-					superInterfacesLength = 1;
-					interfaceNames = new char[1][];
-				}
-			}
-		}
-		if (superInterfaces != null) {
-			for (int i = 0; i < superInterfacesLength; i++) {
-				interfaceNames[i] = 
-					CharOperation.concatWith(superInterfaces[i].getParameterizedTypeName(), '.'); 
-			}
-		}
-		int kind = TypeDeclaration.kind(typeDeclaration.modifiers);
-		char[] implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_OBJECT;
-		if (isInRange) {
-			int currentModifiers = typeDeclaration.modifiers;
-			
-			// remember deprecation so as to not lose it below
-			boolean deprecated = (currentModifiers & ClassFileConstants.AccDeprecated) != 0 || hasDeprecatedAnnotation(typeDeclaration.annotations);	
-			
-			boolean isEnumInit = typeDeclaration.allocation != null && typeDeclaration.allocation.enumConstant != null;
-			char[] superclassName;
-			if (isEnumInit) {
-				currentModifiers |= ClassFileConstants.AccEnum;
-				superclassName = declaringType.name;
-			} else {
-				TypeReference superclass = typeDeclaration.superclass;
-				superclassName = superclass != null ? CharOperation.concatWith(superclass.getParameterizedTypeName(), '.') : null;
-			}
-			ISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();
-			typeInfo.declarationStart = typeDeclaration.allocation == null ? typeDeclaration.declarationSourceStart : typeDeclaration.allocation.sourceStart;
-			typeInfo.modifiers = deprecated ? (currentModifiers & ExtraCompilerModifiers.AccJustFlag) | ClassFileConstants.AccDeprecated : currentModifiers & ExtraCompilerModifiers.AccJustFlag;
-			typeInfo.name = typeDeclaration.name;
-			typeInfo.nameSourceStart = typeDeclaration.sourceStart;
-			typeInfo.nameSourceEnd = sourceEnd(typeDeclaration);
-			typeInfo.superclass = superclassName;
-			typeInfo.superinterfaces = interfaceNames;
-			typeInfo.typeParameters = getTypeParameterInfos(typeDeclaration.typeParameters);
-			typeInfo.categories = (char[][]) this.nodesToCategories.get(typeDeclaration);
-			typeInfo.secondary = typeDeclaration.isSecondary();
-			typeInfo.anonymousMember = typeDeclaration.allocation != null && typeDeclaration.allocation.enclosingInstance != null;
-			typeInfo.annotations = typeDeclaration.annotations;
-			requestor.enterType(typeInfo);
-			switch (kind) {
-				case TypeDeclaration.CLASS_DECL :
-					if (superclassName != null)
-						implicitSuperclassName = superclassName;
-					break;
-				case TypeDeclaration.INTERFACE_DECL :
-					implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_OBJECT;
-					break;
-				case TypeDeclaration.ENUM_DECL :
-					implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_ENUM;
-					break;
-				case TypeDeclaration.ANNOTATION_TYPE_DECL :
-					implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_ANNOTATION_ANNOTATION;
-					break;
-			}
-		}
-		if (this.nestedTypeIndex == this.typeNames.length) {
-			// need a resize
-			System.arraycopy(this.typeNames, 0, (this.typeNames = new char[this.nestedTypeIndex * 2][]), 0, this.nestedTypeIndex);
-			System.arraycopy(this.superTypeNames, 0, (this.superTypeNames = new char[this.nestedTypeIndex * 2][]), 0, this.nestedTypeIndex);
-		}
-		this.typeNames[this.nestedTypeIndex] = typeDeclaration.name;
-		this.superTypeNames[this.nestedTypeIndex++] = implicitSuperclassName;
-	}
-	while ((fieldIndex < fieldCounter)
-			|| (memberTypeIndex < memberTypeCounter)
-			|| (methodIndex < methodCounter)) {
-		FieldDeclaration nextFieldDeclaration = null;
-		AbstractMethodDeclaration nextMethodDeclaration = null;
-		TypeDeclaration nextMemberDeclaration = null;
-		
-		int position = Integer.MAX_VALUE;
-		int nextDeclarationType = -1;
-		if (fieldIndex < fieldCounter) {
-			nextFieldDeclaration = fields[fieldIndex];
-			if (nextFieldDeclaration.declarationSourceStart < position) {
-				position = nextFieldDeclaration.declarationSourceStart;
-				nextDeclarationType = 0; // FIELD
-			}
-		}
-		if (methodIndex < methodCounter) {
-			nextMethodDeclaration = methods[methodIndex];
-			if (nextMethodDeclaration.declarationSourceStart < position) {
-				position = nextMethodDeclaration.declarationSourceStart;
-				nextDeclarationType = 1; // METHOD
-			}
-		}
-		if (memberTypeIndex < memberTypeCounter) {
-			nextMemberDeclaration = memberTypes[memberTypeIndex];
-			if (nextMemberDeclaration.declarationSourceStart < position) {
-				position = nextMemberDeclaration.declarationSourceStart;
-				nextDeclarationType = 2; // MEMBER
-			}
-		}
-		switch (nextDeclarationType) {
-			case 0 :
-				fieldIndex++;
-				notifySourceElementRequestor(nextFieldDeclaration, typeDeclaration);
-				break;
-			case 1 :
-				methodIndex++;
-				notifySourceElementRequestor(nextMethodDeclaration);
-				break;
-			case 2 :
-				memberTypeIndex++;
-				notifySourceElementRequestor(nextMemberDeclaration, true, null);
-		}
-	}
-	if (notifyTypePresence){
-		if (isInRange){
-			requestor.exitType(typeDeclaration.declarationSourceEnd);
-		}
-		nestedTypeIndex--;
-	}
-}
 public CompilationUnitDeclaration parseCompilationUnit(
 	ICompilationUnit unit, 
 	boolean fullParse,
@@ -1499,12 +904,18 @@ public CompilationUnitDeclaration parseCompilationUnit(
 		}
 		int initialStart = this.scanner.initialPosition;
 		int initialEnd = this.scanner.eofPosition;
-		if (this.localDeclarationVisitor != null || fullParse){
+		if (this.reportLocalDeclarations || fullParse){
 			diet = false;
 			this.getMethodBodies(parsedUnit);
 		}
 		this.scanner.resetTo(initialStart, initialEnd);
-		notifySourceElementRequestor(parsedUnit);
+		this.notifier.notifySourceElementRequestor(
+				parsedUnit,
+				this.scanner.initialPosition,
+				this.scanner.eofPosition,
+				this.reportReferenceInfo,
+				this.sourceEnds,
+				this.nodesToCategories);
 		return parsedUnit;
 	} catch (AbortCompilation e) {
 		// ignore this exception
@@ -1514,35 +925,6 @@ public CompilationUnitDeclaration parseCompilationUnit(
 	}
 	return parsedUnit;
 }
-/*
- * Sort the given ast nodes by their positions.
- */
-private static void quickSort(ASTNode[] sortedCollection, int left, int right) {
-	int original_left = left;
-	int original_right = right;
-	ASTNode mid = sortedCollection[left +  (right - left) / 2];
-	do {
-		while (sortedCollection[left].sourceStart < mid.sourceStart) {
-			left++;
-		}
-		while (mid.sourceStart < sortedCollection[right].sourceStart) {
-			right--;
-		}
-		if (left <= right) {
-			ASTNode tmp = sortedCollection[left];
-			sortedCollection[left] = sortedCollection[right];
-			sortedCollection[right] = tmp;
-			left++;
-			right--;
-		}
-	} while (left <= right);
-	if (original_left < right) {
-		quickSort(sortedCollection, original_left, right);
-	}
-	if (left < original_right) {
-		quickSort(sortedCollection, left, original_right);
-	}
-}
 private void rememberCategories() {
 	if (this.useSourceJavadocParser) {
 		SourceJavadocParser sourceJavadocParser = (SourceJavadocParser) this.javadocParser;
@@ -1556,57 +938,9 @@ private void rememberCategories() {
 private void reset() {
 	this.sourceEnds = new HashtableOfObjectToInt();
 	this.nodesToCategories = new HashMap();
-	typeNames = new char[4][];
-	superTypeNames = new char[4][];
-	nestedTypeIndex = 0;
-}
-private int sourceEnd(TypeDeclaration typeDeclaration) {
-	if ((typeDeclaration.bits & ASTNode.IsAnonymousType) != 0) {
-		QualifiedAllocationExpression allocation = typeDeclaration.allocation;
-		if (allocation.type == null) // case of enum constant body
-			return typeDeclaration.sourceEnd;
-		return allocation.type.sourceEnd;
-	} else {
-		return typeDeclaration.sourceEnd;
-	}
-}
-private void visitIfNeeded(AbstractMethodDeclaration method) {
-	if (this.localDeclarationVisitor != null 
-		&& (method.bits & ASTNode.HasLocalType) != 0) {
-			if (method instanceof ConstructorDeclaration) {
-				ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) method;
-				if (constructorDeclaration.constructorCall != null) {
-					constructorDeclaration.constructorCall.traverse(this.localDeclarationVisitor, method.scope);
-				}
-			}
-			if (method.statements != null) {
-				int statementsLength = method.statements.length;
-				for (int i = 0; i < statementsLength; i++)
-					method.statements[i].traverse(this.localDeclarationVisitor, method.scope);
-			}
-	}
 }
-
-private void visitIfNeeded(FieldDeclaration field, TypeDeclaration declaringType) {
-	if (this.localDeclarationVisitor != null 
-		&& (field.bits & ASTNode.HasLocalType) != 0) {
-			if (field.initialization != null) {
-				try {
-					this.localDeclarationVisitor.pushDeclaringType(declaringType);
-					field.initialization.traverse(this.localDeclarationVisitor, (MethodScope) null);
-				} finally {
-					this.localDeclarationVisitor.popDeclaringType();
-				}
-			}
-	}
-}
-
-private void visitIfNeeded(Initializer initializer) {
-	if (this.localDeclarationVisitor != null 
-		&& (initializer.bits & ASTNode.HasLocalType) != 0) {
-			if (initializer.block != null) {
-				initializer.block.traverse(this.localDeclarationVisitor, null);
-			}
-	}
+public void setRequestor(ISourceElementRequestor requestor) {
+	this.requestor = requestor;
+	this.notifier.requestor = requestor;
 }
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
index 195beef..8795794 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java
@@ -92,7 +92,7 @@ public void codeComplete(char[] snippet,int insertion,int position,char[][] loca
 	}
 	JavaProject project = (JavaProject) getJavaProject();
 	SearchableEnvironment environment = project.newSearchableNameEnvironment(owner);
-	CompletionEngine engine = new CompletionEngine(environment, requestor, project.getOptions(true), project);
+	CompletionEngine engine = new CompletionEngine(environment, requestor, project.getOptions(true), project, owner);
 
 	String source = getClassFile().getSource();
 	if (source != null && insertion > -1 && insertion < source.length()) {
@@ -109,7 +109,7 @@ public void codeComplete(char[] snippet,int insertion,int position,char[][] loca
 				getElementName(),
 				project); // use project to retrieve corresponding .java IFile
 
-		engine.complete(cu, prefix.length + position, prefix.length);
+		engine.complete(cu, prefix.length + position, prefix.length, null/*extended context isn't computed*/);
 	} else {
 		engine.complete(this, snippet, position, localVariableTypeNames, localVariableNames, localVariableModifiers, isStatic);
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index 8256a7d..48c286b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -136,7 +136,7 @@ public void codeComplete(int offset, CompletionRequestor requestor, WorkingCopyO
 				null,
 				type.sourceFileName((IBinaryType) type.getElementInfo()),
 				getJavaProject()); // use project to retrieve corresponding .java IFile
-		codeComplete(cu, cu, offset, requestor, owner);
+		codeComplete(cu, cu, offset, requestor, owner, null/*extended context isn't computed*/);
 	}
 }
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
index 5e277fa..3e5dd15 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
@@ -338,7 +338,13 @@ public void codeComplete(int offset, CompletionRequestor requestor) throws JavaM
  * @see org.eclipse.jdt.core.ICodeAssist#codeComplete(int, org.eclipse.jdt.core.CompletionRequestor, org.eclipse.jdt.core.WorkingCopyOwner)
  */
 public void codeComplete(int offset, CompletionRequestor requestor, WorkingCopyOwner workingCopyOwner) throws JavaModelException {
-	codeComplete(this, isWorkingCopy() ? (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) getOriginalElement() : this, offset, requestor, workingCopyOwner);
+	codeComplete(
+			this,
+			isWorkingCopy() ? (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) getOriginalElement() : this,
+			offset,
+			requestor,
+			workingCopyOwner,
+			this);
 }
 
 /**
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
index e0b4d2a..c4a11eb 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
@@ -126,7 +126,7 @@ public void acceptImport(int declarationStart, int declarationEnd, char[][] toke
 
 	ICompilationUnit parentCU= (ICompilationUnit)parentHandle;
 	//create the import container and its info
-	ImportContainer importContainer= (ImportContainer)parentCU.getImportContainer();
+	ImportContainer importContainer= createImportContainer(parentCU);
 	if (this.importContainerInfo == null) {
 		this.importContainerInfo = new JavaElementInfo();
 		JavaElementInfo parentInfo = (JavaElementInfo) this.infoStack.peek();
@@ -135,7 +135,7 @@ public void acceptImport(int declarationStart, int declarationEnd, char[][] toke
 	}
 	
 	String elementName = JavaModelManager.getJavaModelManager().intern(new String(CharOperation.concatWith(tokens, '.')));
-	ImportDeclaration handle = new ImportDeclaration(importContainer, elementName, onDemand);
+	ImportDeclaration handle = createImportDeclaration(importContainer, elementName, onDemand);
 	resolveDuplicates(handle);
 	
 	ImportDeclarationElementInfo info = new ImportDeclarationElementInfo();
@@ -167,7 +167,7 @@ public void acceptPackage(ImportReference importReference) {
 		
 		if (parentHandle.getElementType() == IJavaElement.COMPILATION_UNIT) {
 			char[] name = CharOperation.concatWith(importReference.getImportName(), '.');
-			handle = new PackageDeclaration((CompilationUnit) parentHandle, new String(name));
+			handle = createPackageDeclaration(parentHandle, new String(name));
 		}
 		else {
 			Assert.isTrue(false); // Should not happen
@@ -200,11 +200,42 @@ private void addToChildren(JavaElementInfo parentInfo, JavaElement handle) {
 		this.children.put(parentInfo, childrenList = new ArrayList());
 	childrenList.add(handle);
 }
+protected Annotation createAnnotation(JavaElement parent, String name) {
+	return new Annotation(parent, name);
+}
+protected SourceField createField(JavaElement parent, FieldInfo fieldInfo) {
+	String fieldName = JavaModelManager.getJavaModelManager().intern(new String(fieldInfo.name));
+	return new SourceField(parent, fieldName);
+}
+protected ImportContainer createImportContainer(ICompilationUnit parent) {
+	return (ImportContainer)parent.getImportContainer();
+}
+protected ImportDeclaration createImportDeclaration(ImportContainer parent, String name, boolean onDemand) {
+	return new ImportDeclaration(parent, name, onDemand);
+}
+protected Initializer createInitializer(JavaElement parent) {
+	return new Initializer(parent, 1);
+}
+protected SourceMethod createMethod(JavaElement parent, MethodInfo methodInfo) {
+	String selector = JavaModelManager.getJavaModelManager().intern(new String(methodInfo.name));
+	String[] parameterTypeSigs = convertTypeNamesToSigs(methodInfo.parameterTypes);
+	return new SourceMethod(parent, selector, parameterTypeSigs);
+}
+protected PackageDeclaration createPackageDeclaration(JavaElement parent, String name) {
+	return new PackageDeclaration((CompilationUnit) parent, name);
+}
+protected SourceType createType(JavaElement parent, TypeInfo typeInfo) {
+	String nameString= new String(typeInfo.name);
+	return new SourceType(parent, nameString);
+}
+protected TypeParameter createTypeParameter(JavaElement parent, String name) {
+	return new TypeParameter(parent, name);
+}
 /**
  * Convert these type names to signatures.
  * @see Signature
  */
-/* default */ static String[] convertTypeNamesToSigs(char[][] typeNames) {
+protected static String[] convertTypeNamesToSigs(char[][] typeNames) {
 	if (typeNames == null)
 		return CharOperation.NO_STRINGS;
 	int n = typeNames.length;
@@ -219,7 +250,7 @@ private void addToChildren(JavaElementInfo parentInfo, JavaElement handle) {
 }
 protected IAnnotation enterAnnotation(org.eclipse.jdt.internal.compiler.ast.Annotation annotation, AnnotatableInfo parentInfo, JavaElement parentHandle) {
 	String nameString = new String(CharOperation.concatWith(annotation.type.getTypeName(), '.'));
-	Annotation handle = new Annotation(parentHandle, nameString); //NB: occurenceCount is computed in resolveDuplicates
+	Annotation handle = createAnnotation(parentHandle, nameString); //NB: occurenceCount is computed in resolveDuplicates
 	resolveDuplicates(handle);
 	
 	AnnotationInfo info = new AnnotationInfo();
@@ -237,11 +268,7 @@ protected IAnnotation enterAnnotation(org.eclipse.jdt.internal.compiler.ast.Anno
 	if (membersLength == 0) {
 		info.members = Annotation.NO_MEMBER_VALUE_PAIRS;
 	} else {
-		IMemberValuePair[] members = new IMemberValuePair[membersLength];
-		for (int j = 0; j < membersLength; j++) {
-			members[j] = getMemberValuePair(memberValuePairs[j]);
-		}
-		info.members = members;
+		info.members = getMemberValuePairs(memberValuePairs);
 	}
 	
 	if (parentInfo != null) {
@@ -278,8 +305,7 @@ public void enterField(FieldInfo fieldInfo) {
 	JavaElement parentHandle= (JavaElement) this.handleStack.peek();
 	SourceField handle = null;
 	if (parentHandle.getElementType() == IJavaElement.TYPE) {
-		String fieldName = JavaModelManager.getJavaModelManager().intern(new String(fieldInfo.name));
-		handle = new SourceField(parentHandle, fieldName);
+		handle = createField(parentHandle, fieldInfo);
 	}
 	else {
 		Assert.isTrue(false); // Should not happen
@@ -322,7 +348,7 @@ public void enterInitializer(
 		Initializer handle = null;
 		
 		if (parentHandle.getElementType() == IJavaElement.TYPE) {
-			handle = new Initializer(parentHandle, 1);
+			handle = createInitializer(parentHandle);
 		}
 		else {
 			Assert.isTrue(false); // Should not happen
@@ -359,10 +385,8 @@ public void enterMethod(MethodInfo methodInfo) {
 		methodInfo.exceptionTypes= CharOperation.NO_CHAR_CHAR;
 	}
 	
-	String[] parameterTypeSigs = convertTypeNamesToSigs(methodInfo.parameterTypes);
 	if (parentHandle.getElementType() == IJavaElement.TYPE) {
-		String selector = JavaModelManager.getJavaModelManager().intern(new String(methodInfo.name));
-		handle = new SourceMethod(parentHandle, selector, parameterTypeSigs);
+		handle = createMethod(parentHandle, methodInfo);
 	}
 	else {
 		Assert.isTrue(false); // Should not happen
@@ -422,8 +446,7 @@ public void enterType(TypeInfo typeInfo) {
 
 	JavaElementInfo parentInfo = (JavaElementInfo) this.infoStack.peek();
 	JavaElement parentHandle= (JavaElement) this.handleStack.peek();
-	String nameString= new String(typeInfo.name);
-	SourceType handle = new SourceType(parentHandle, nameString); //NB: occurenceCount is computed in resolveDuplicates
+	SourceType handle = this.createType(parentHandle, typeInfo); //NB: occurenceCount is computed in resolveDuplicates
 	resolveDuplicates(handle);
 	
 	SourceTypeElementInfo info = 
@@ -475,7 +498,7 @@ protected void enterTypeParameter(TypeParameterInfo typeParameterInfo) {
 	JavaElementInfo parentInfo = (JavaElementInfo) this.infoStack.peek();
 	JavaElement parentHandle = (JavaElement) this.handleStack.peek();
 	String nameString = new String(typeParameterInfo.name);
-	TypeParameter handle = new TypeParameter(parentHandle, nameString); //NB: occurenceCount is computed in resolveDuplicates
+	TypeParameter handle = createTypeParameter(parentHandle, nameString); //NB: occurenceCount is computed in resolveDuplicates
 	resolveDuplicates(handle);
 	
 	TypeParameterElementInfo info = new TypeParameterElementInfo();
@@ -601,16 +624,24 @@ protected void resolveDuplicates(SourceRefElement handle) {
 		handle.occurrenceCount++;
 	}
 }
-private IMemberValuePair getMemberValuePair(MemberValuePair memberValuePair) {
+protected IMemberValuePair getMemberValuePair(MemberValuePair memberValuePair) {
 	String memberName = new String(memberValuePair.name);
 	org.eclipse.jdt.internal.core.MemberValuePair result = new org.eclipse.jdt.internal.core.MemberValuePair(memberName);
 	result.value = getMemberValue(result, memberValuePair.value);
 	return result;
 }
+protected IMemberValuePair[] getMemberValuePairs(MemberValuePair[] memberValuePairs) {
+	int membersLength = memberValuePairs.length;
+	IMemberValuePair[] members = new IMemberValuePair[membersLength];
+	for (int j = 0; j < membersLength; j++) {
+		members[j] = getMemberValuePair(memberValuePairs[j]);
+	}
+	return members;
+}
 /*
  * Creates the value from the given expression, and sets the valueKind on the given memberValuePair
  */
-private Object getMemberValue(org.eclipse.jdt.internal.core.MemberValuePair memberValuePair, Expression expression) {
+protected Object getMemberValue(org.eclipse.jdt.internal.core.MemberValuePair memberValuePair, Expression expression) {
 	if (expression instanceof NullLiteral) {
 		return null;
 	} else if (expression instanceof Literal) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ImportContainer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ImportContainer.java
index 47a90aa..469049a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ImportContainer.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ImportContainer.java
@@ -69,6 +69,9 @@ public IImportDeclaration getImport(String importName) {
 	if (isOnDemand)
 		// make sure to copy the string (so that it doesn't hold on the underlying char[] that might be much bigger than necessary)
 		importName = new String(importName.substring(0, index));
+	return getImport(importName, isOnDemand);
+}
+protected IImportDeclaration getImport(String importName, boolean isOnDemand) {
 	return new ImportDeclaration(this, importName, isOnDemand);
 }
 /*
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Initializer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Initializer.java
index ee1953a..245da5a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Initializer.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Initializer.java
@@ -24,7 +24,7 @@ import org.eclipse.jdt.internal.core.util.Util;
  * @see IInitializer
  */
 
-/* package */ class Initializer extends Member implements IInitializer {
+public class Initializer extends Member implements IInitializer {
 
 protected Initializer(JavaElement parent, int count) {
 	super(parent);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementInfo.java
index ea1e690..4305572 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementInfo.java
@@ -16,7 +16,7 @@ import org.eclipse.jdt.core.IJavaElement;
  * Holds cached structure and properties for a Java element.
  * Subclassed to carry properties for specific kinds of elements.
  */
-/* package */ class JavaElementInfo {
+public class JavaElementInfo {
 
 	/**
 	 * Collection of handles of immediate children of this
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Openable.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Openable.java
index a360131..11d2605 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Openable.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Openable.java
@@ -96,7 +96,12 @@ protected void closeBuffer() {
 protected void closing(Object info) {
 	closeBuffer();
 }
-protected void codeComplete(org.eclipse.jdt.internal.compiler.env.ICompilationUnit cu, org.eclipse.jdt.internal.compiler.env.ICompilationUnit unitToSkip, int position, CompletionRequestor requestor, WorkingCopyOwner owner) throws JavaModelException {
+protected void codeComplete(
+		org.eclipse.jdt.internal.compiler.env.ICompilationUnit cu,
+		org.eclipse.jdt.internal.compiler.env.ICompilationUnit unitToSkip,
+		int position, CompletionRequestor requestor,
+		WorkingCopyOwner owner,
+		ITypeRoot typeRoot) throws JavaModelException {
 	if (requestor == null) {
 		throw new IllegalArgumentException("Completion requestor cannot be null"); //$NON-NLS-1$
 	}
@@ -120,8 +125,8 @@ protected void codeComplete(org.eclipse.jdt.internal.compiler.env.ICompilationUn
 	environment.unitToSkip = unitToSkip;
 
 	// code complete
-	CompletionEngine engine = new CompletionEngine(environment, requestor, project.getOptions(true), project);
-	engine.complete(cu, position, 0);
+	CompletionEngine engine = new CompletionEngine(environment, requestor, project.getOptions(true), project, owner);
+	engine.complete(cu, position, 0, typeRoot);
 	if(performanceStats != null) {
 		performanceStats.endRun();
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageDeclaration.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageDeclaration.java
index 4d31c65..7c49c6b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageDeclaration.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageDeclaration.java
@@ -17,7 +17,7 @@ import org.eclipse.jdt.core.IPackageDeclaration;
  * @see IPackageDeclaration
  */
 
-/* package */ class PackageDeclaration extends SourceRefElement implements IPackageDeclaration {
+public class PackageDeclaration extends SourceRefElement implements IPackageDeclaration {
 	
 	String name;
 	
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceField.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceField.java
index d710f04..7b9ec89 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceField.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceField.java
@@ -47,7 +47,7 @@ public class ResolvedSourceField extends SourceField {
 		super.toStringInfo(tab, buffer, info, showResolvedInfo);
 		if (showResolvedInfo) {
 			buffer.append(" {key="); //$NON-NLS-1$
-			buffer.append(this.uniqueKey);
+			buffer.append(this.getKey());
 			buffer.append("}"); //$NON-NLS-1$
 		}
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceMethod.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceMethod.java
index 1b67651..62d91d9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceMethod.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceMethod.java
@@ -46,7 +46,7 @@ public class ResolvedSourceMethod extends SourceMethod {
 		super.toStringInfo(tab, buffer, info, showResolvedInfo);
 		if (showResolvedInfo) {
 			buffer.append(" {key="); //$NON-NLS-1$
-			buffer.append(this.uniqueKey);
+			buffer.append(this.getKey());
 			buffer.append("}"); //$NON-NLS-1$
 		}
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceType.java
index 59c4e6d..ea60a4b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ResolvedSourceType.java
@@ -53,7 +53,7 @@ public class ResolvedSourceType extends SourceType {
 		super.toStringInfo(tab, buffer, info, showResolvedInfo);
 		if (showResolvedInfo) {
 			buffer.append(" {key="); //$NON-NLS-1$
-			buffer.append(this.uniqueKey);
+			buffer.append(this.getKey());
 			buffer.append("}"); //$NON-NLS-1$
 		}
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
index 751c480..da6ecab 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java
@@ -81,7 +81,7 @@ public void codeComplete(char[] snippet,int insertion,int position,char[][] loca
 	
 	JavaProject project = (JavaProject) getJavaProject();
 	SearchableEnvironment environment = project.newSearchableNameEnvironment(owner);
-	CompletionEngine engine = new CompletionEngine(environment, requestor, project.getOptions(true), project);
+	CompletionEngine engine = new CompletionEngine(environment, requestor, project.getOptions(true), project, owner);
 
 	String source = getCompilationUnit().getSource();
 	if (source != null && insertion > -1 && insertion < source.length()) {
@@ -97,7 +97,7 @@ public void codeComplete(char[] snippet,int insertion,int position,char[][] loca
 				getElementName(),
 				getParent());
 
-		engine.complete(cu, prefix.length + position, prefix.length);
+		engine.complete(cu, prefix.length + position, prefix.length, null/*extended context isn't computed*/);
 	} else {
 		engine.complete(this, snippet, position, localVariableTypeNames, localVariableNames, localVariableModifiers, isStatic);
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
index ba51d85..e60b8e7 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Util.java
@@ -39,16 +39,26 @@ import org.eclipse.jdt.core.util.ICodeAttribute;
 import org.eclipse.jdt.core.util.IFieldInfo;
 import org.eclipse.jdt.core.util.IMethodInfo;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
+import org.eclipse.jdt.internal.compiler.env.IDependent;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.lookup.Binding;
+import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
+import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.parser.ScannerHelper;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
+import org.eclipse.jdt.internal.core.ClassFile;
 import org.eclipse.jdt.internal.core.JavaElement;
 import org.eclipse.jdt.internal.core.JavaModelManager;
+import org.eclipse.jdt.internal.core.Member;
 import org.eclipse.jdt.internal.core.MemberValuePair;
 import org.eclipse.jdt.internal.core.PackageFragment;
 import org.eclipse.jdt.internal.core.PackageFragmentRoot;
@@ -76,6 +86,11 @@ public class Util {
 		 */
 		int compare(Object a, Object b);
 	}
+	
+	public static interface BindingsToNodesMap {
+		public org.eclipse.jdt.internal.compiler.ast.ASTNode get(Binding binding);
+	}
+	
 	private static final String ARGUMENTS_DELIMITER = "#"; //$NON-NLS-1$
 
 	private static final String EMPTY_ARGUMENT = "   "; //$NON-NLS-1$
@@ -747,6 +762,38 @@ public class Util {
 		return null;
 	}
 	
+	private static IClassFile getClassFile(char[] fileName) {
+		int jarSeparator = CharOperation.indexOf(IDependent.JAR_FILE_ENTRY_SEPARATOR, fileName);
+		int pkgEnd = CharOperation.lastIndexOf('/', fileName); // pkgEnd is exclusive
+		if (pkgEnd == -1)
+			pkgEnd = CharOperation.lastIndexOf(File.separatorChar, fileName);
+		if (jarSeparator != -1 && pkgEnd < jarSeparator) // if in a jar and no slash, it is a default package -> pkgEnd should be equal to jarSeparator
+			pkgEnd = jarSeparator;
+		if (pkgEnd == -1)
+			return null;
+		IPackageFragment pkg = getPackageFragment(fileName, pkgEnd, jarSeparator);
+		if (pkg == null) return null;
+		int start;
+		return pkg.getClassFile(new String(fileName, start = pkgEnd + 1, fileName.length - start));
+	}
+	
+	private static ICompilationUnit getCompilationUnit(char[] fileName, WorkingCopyOwner workingCopyOwner) {
+		char[] slashSeparatedFileName = CharOperation.replaceOnCopy(fileName, File.separatorChar, '/');
+		int pkgEnd = CharOperation.lastIndexOf('/', slashSeparatedFileName); // pkgEnd is exclusive
+		if (pkgEnd == -1)
+			return null;
+		IPackageFragment pkg = getPackageFragment(slashSeparatedFileName, pkgEnd, -1/*no jar separator for .java files*/);
+		if (pkg == null) return null;
+		int start;
+		ICompilationUnit cu = pkg.getCompilationUnit(new String(slashSeparatedFileName, start =  pkgEnd+1, slashSeparatedFileName.length - start));
+		if (workingCopyOwner != null) {
+			ICompilationUnit workingCopy = cu.findWorkingCopy(workingCopyOwner);
+			if (workingCopy != null)
+				return workingCopy;
+		}
+		return cu;
+	}
+	
 	/**
 	 * Returns the registered Java like extensions.
 	 */
@@ -910,7 +957,36 @@ public class Util {
 		}
 		return lineSeparator;
 	}
-		
+	
+	private static IPackageFragment getPackageFragment(char[] fileName, int pkgEnd, int jarSeparator) {
+		if (jarSeparator != -1) {
+			String jarMemento = new String(fileName, 0, jarSeparator);
+			IPackageFragmentRoot root = (IPackageFragmentRoot) JavaCore.create(jarMemento);
+			if (pkgEnd == jarSeparator)
+				return root.getPackageFragment(IPackageFragment.DEFAULT_PACKAGE_NAME);
+			char[] pkgName = CharOperation.subarray(fileName, jarSeparator+1, pkgEnd);
+			CharOperation.replace(pkgName, '/', '.');
+			return root.getPackageFragment(new String(pkgName));
+		} else {
+			Path path = new Path(new String(fileName, 0, pkgEnd));
+			IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
+			IContainer folder = path.segmentCount() == 1 ? workspaceRoot.getProject(path.lastSegment()) : (IContainer) workspaceRoot.getFolder(path);
+			IJavaElement element = JavaCore.create(folder);
+			if (element == null) return null;
+			switch (element.getElementType()) {
+				case IJavaElement.PACKAGE_FRAGMENT:
+					return (IPackageFragment) element;
+				case IJavaElement.PACKAGE_FRAGMENT_ROOT:
+					return ((IPackageFragmentRoot) element).getPackageFragment(IPackageFragment.DEFAULT_PACKAGE_NAME);
+				case IJavaElement.JAVA_PROJECT:
+					IPackageFragmentRoot root = ((IJavaProject) element).getPackageFragmentRoot(folder);
+					if (root == null) return null;
+					return root.getPackageFragment(IPackageFragment.DEFAULT_PACKAGE_NAME);
+			}
+			return null;
+		}
+	}
+	
 	/**
 	 * Returns the number of parameter types in a method signature.
 	 */
@@ -1204,7 +1280,182 @@ public class Util {
 		return result;
 	}
 	
-		/*
+	/**
+	 * Return the java element corresponding to the given compiler binding.
+	 */
+	public static JavaElement getUnresolvedJavaElement(FieldBinding binding, WorkingCopyOwner workingCopyOwner, BindingsToNodesMap bindingsToNodes) {
+		if (binding.declaringClass == null) return null; // arraylength
+		IType declaringType = (IType) getUnresolvedJavaElement(binding.declaringClass, workingCopyOwner, bindingsToNodes);
+		if (declaringType == null) return null;
+		return (JavaElement) declaringType.getField(String.valueOf(binding.name));
+	}
+	
+	/**
+	 * Return the java element corresponding to the given compiler binding.
+	 */
+	public static JavaElement getUnresolvedJavaElement(MethodBinding methodBinding, WorkingCopyOwner workingCopyOwner, BindingsToNodesMap bindingsToNodes) {
+		IType declaringType = (IType) getUnresolvedJavaElement(methodBinding.declaringClass, workingCopyOwner, bindingsToNodes);
+		
+		if (declaringType == null) return null;
+		
+		org.eclipse.jdt.internal.compiler.ast.ASTNode node = bindingsToNodes == null ? null : bindingsToNodes.get(methodBinding);
+		if (node != null && !declaringType.isBinary()) {
+			if (node instanceof AnnotationMethodDeclaration) {
+				// node is an AnnotationMethodDeclaration
+				AnnotationMethodDeclaration typeMemberDeclaration = (AnnotationMethodDeclaration) node;
+				return (JavaElement) declaringType.getMethod(String.valueOf(typeMemberDeclaration.selector), CharOperation.NO_STRINGS); // annotation type members don't have parameters
+			} else {
+				// node is an MethodDeclaration
+				MethodDeclaration methodDeclaration = (MethodDeclaration) node;
+				
+				Argument[] arguments = methodDeclaration.arguments;
+				String[] parameterSignatures;
+				if (arguments != null) {
+					parameterSignatures = new String[arguments.length];
+					for (int i = 0; i < arguments.length; i++) {
+						Argument argument = arguments[i];
+						TypeReference typeReference = argument.type;
+						int arrayDim = typeReference.dimensions();
+						
+						String typeSig = 
+							Signature.createTypeSignature(
+									CharOperation.concatWith(
+											typeReference.getTypeName(), '.'), false);
+						if (arrayDim > 0) {
+							typeSig = Signature.createArraySignature(typeSig, arrayDim);
+						}
+						parameterSignatures[i] = typeSig;
+						
+					}
+				} else {
+					parameterSignatures = new String[0];
+				}
+				return (JavaElement) declaringType.getMethod(String.valueOf(methodDeclaration.selector), parameterSignatures);
+			}
+		} else {
+			// case of method not in the created AST, or a binary method
+			org.eclipse.jdt.internal.compiler.lookup.MethodBinding original = methodBinding.original();
+			String selector = original.isConstructor() ? declaringType.getElementName() : new String(original.selector);
+			boolean isBinary = declaringType.isBinary();
+			ReferenceBinding enclosingType = original.declaringClass.enclosingType();
+			boolean isInnerBinaryTypeConstructor = isBinary && original.isConstructor() && enclosingType != null;
+			TypeBinding[] parameters = original.parameters;
+			int length = parameters == null ? 0 : parameters.length;
+			int declaringIndex = isInnerBinaryTypeConstructor ? 1 : 0;
+			String[] parameterSignatures = new String[declaringIndex + length];
+			if (isInnerBinaryTypeConstructor)
+				parameterSignatures[0] = new String(enclosingType.genericTypeSignature()).replace('/', '.');
+			for (int i = 0;  i < length; i++) {
+				parameterSignatures[declaringIndex + i] = new String(parameters[i].genericTypeSignature()).replace('/', '.');
+			}
+			IMethod result = declaringType.getMethod(selector, parameterSignatures);
+			if (isBinary)
+				return (JavaElement) result;
+			IMethod[] methods = null;
+			try {
+				methods = declaringType.getMethods();
+			} catch (JavaModelException e) {
+				// declaring type doesn't exist
+				return null;
+			}
+			IMethod[] candidates = Member.findMethods(result, methods);
+			if (candidates == null || candidates.length == 0)
+				return null;
+			return (JavaElement) candidates[0];
+		}
+	}
+	
+	/**
+	 * Return the java element corresponding to the given compiler binding.
+	 */
+	public static JavaElement getUnresolvedJavaElement(TypeBinding typeBinding, WorkingCopyOwner workingCopyOwner, BindingsToNodesMap bindingsToNodes) {
+		if (typeBinding == null)
+			return null;
+		switch (typeBinding.kind()) {
+			case Binding.ARRAY_TYPE :
+				typeBinding = ((org.eclipse.jdt.internal.compiler.lookup.ArrayBinding) typeBinding).leafComponentType();
+				return getUnresolvedJavaElement(typeBinding, workingCopyOwner, bindingsToNodes);
+			case Binding.BASE_TYPE :
+			case Binding.WILDCARD_TYPE :
+			case Binding.INTERSECTION_TYPE:
+				return null;
+			default :
+				if (typeBinding.isCapture())
+					return null;
+		}
+		ReferenceBinding referenceBinding;
+		if (typeBinding.isParameterizedType() || typeBinding.isRawType())
+			referenceBinding = (ReferenceBinding) typeBinding.erasure();
+		else
+			referenceBinding = (ReferenceBinding) typeBinding;
+		char[] fileName = referenceBinding.getFileName();
+		if (referenceBinding.isLocalType() || referenceBinding.isAnonymousType()) {
+			// local or anonymous type
+			if (org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(fileName)) {
+				int jarSeparator = CharOperation.indexOf(IDependent.JAR_FILE_ENTRY_SEPARATOR, fileName);
+				int pkgEnd = CharOperation.lastIndexOf('/', fileName); // pkgEnd is exclusive
+				if (pkgEnd == -1)
+					pkgEnd = CharOperation.lastIndexOf(File.separatorChar, fileName);
+				if (jarSeparator != -1 && pkgEnd < jarSeparator) // if in a jar and no slash, it is a default package -> pkgEnd should be equal to jarSeparator
+					pkgEnd = jarSeparator;
+				if (pkgEnd == -1)
+					return null;
+				IPackageFragment pkg = getPackageFragment(fileName, pkgEnd, jarSeparator);
+				char[] constantPoolName = referenceBinding.constantPoolName();
+				if (constantPoolName == null) {
+					ClassFile classFile = (ClassFile) getClassFile(fileName);
+					return classFile == null ? null : (JavaElement) classFile.getType();
+				}
+				pkgEnd = CharOperation.lastIndexOf('/', constantPoolName);
+				char[] classFileName = CharOperation.subarray(constantPoolName, pkgEnd+1, constantPoolName.length);
+				ClassFile classFile = (ClassFile) pkg.getClassFile(new String(classFileName) + SuffixConstants.SUFFIX_STRING_class);
+				return (JavaElement) classFile.getType();
+			}
+			ICompilationUnit cu = getCompilationUnit(fileName, workingCopyOwner);
+			if (cu == null) return null;
+			// must use getElementAt(...) as there is no back pointer to the defining method (scope is null after resolution has ended)
+			try {
+				int sourceStart = ((org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding) referenceBinding).sourceStart;
+				return (JavaElement) cu.getElementAt(sourceStart);
+			} catch (JavaModelException e) {
+				// does not exist
+				return null;
+			}
+		} else if (referenceBinding.isTypeVariable()) {
+			// type parameter
+			final String typeVariableName = new String(referenceBinding.sourceName());
+			org.eclipse.jdt.internal.compiler.lookup.Binding declaringElement = ((org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding) referenceBinding).declaringElement;
+			if (declaringElement instanceof MethodBinding) {
+				IMethod declaringMethod = (IMethod) getUnresolvedJavaElement((MethodBinding) declaringElement, workingCopyOwner, bindingsToNodes);
+				return (JavaElement) declaringMethod.getTypeParameter(typeVariableName);
+			} else {
+				IType declaringType = (IType) getUnresolvedJavaElement((TypeBinding) declaringElement, workingCopyOwner, bindingsToNodes);
+				return (JavaElement) declaringType.getTypeParameter(typeVariableName);
+			}
+		} else {
+			if (fileName == null) return null; // case of a WilCardBinding that doesn't have a corresponding Java element
+			// member or top level type
+			TypeBinding declaringTypeBinding = typeBinding.enclosingType();
+			if (declaringTypeBinding == null) {
+				// top level type
+				if (org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(fileName)) {
+					ClassFile classFile = (ClassFile) getClassFile(fileName);
+					if (classFile == null) return null;
+					return (JavaElement) classFile.getType();
+				}
+				ICompilationUnit cu = getCompilationUnit(fileName, workingCopyOwner);
+				if (cu == null) return null;
+				return (JavaElement) cu.getType(new String(referenceBinding.sourceName()));
+			} else {
+				// member type
+				IType declaringType = (IType) getUnresolvedJavaElement(declaringTypeBinding, workingCopyOwner, bindingsToNodes);
+				if (declaringType == null) return null;
+				return (JavaElement) declaringType.getType(new String(referenceBinding.sourceName()));
+			}
+		}
+	}
+	
+	/*
 	 * Returns the index of the most specific argument paths which is strictly enclosing the path to check
 	 */
 	public static int indexOfEnclosingPath(IPath checkedPath, IPath[] paths, int pathCount) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
index c1101b7..f8e297b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SuperTypeNamesCollector.java
@@ -19,6 +19,7 @@ import org.eclipse.jdt.core.search.*;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.ast.Initializer;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
commit f21888ae6d4ceca17a4c2f2fe7153b358e68695f
Author: David Audel <daudel>
Date:   Thu Mar 6 15:35:24 2008 +0000

    HEAD - bug 202470

4	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractCompletionTest.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationDietRecoveryTest.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/DietRecoveryTest.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/EnumDietRecoveryTest.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/GenericDietRecoveryTest.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/JavadocCompletionParserTest.java
29	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelCompletionTests.java
825	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionContextTests.java
352	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionContextTests_1_5.java
49	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
2	2	org.eclipse.jdt.core/buildnotes_jdt-core.html
10	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
110	24	org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionContext.java
31	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
1	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
2	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/eval/EvaluationContextWrapper.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractCompletionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractCompletionTest.java
index 3614e41..ed50194 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractCompletionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractCompletionTest.java
@@ -78,7 +78,8 @@ public void checkDietParse(
 			new ProblemReporter(
 				DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
 				options, 
-				new DefaultProblemFactory(Locale.getDefault())));
+				new DefaultProblemFactory(Locale.getDefault())),
+			false);
 
 	ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
 	CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
@@ -115,7 +116,8 @@ public void checkMethodParse(
 			new ProblemReporter(
 				DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
 				options, 
-				new DefaultProblemFactory(Locale.getDefault())));
+				new DefaultProblemFactory(Locale.getDefault())),
+			false);
 
 	ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
 	CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationDietRecoveryTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationDietRecoveryTest.java
index bfbc516..0831607 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationDietRecoveryTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AnnotationDietRecoveryTest.java
@@ -204,7 +204,8 @@ public void checkParse(
 				new ProblemReporter(
 					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
 					options, 
-					new DefaultProblemFactory(Locale.getDefault())));
+					new DefaultProblemFactory(Locale.getDefault())),
+				false);
 			
 		ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
 		CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/DietRecoveryTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/DietRecoveryTest.java
index 845d632..38ca34f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/DietRecoveryTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/DietRecoveryTest.java
@@ -230,7 +230,8 @@ public void checkParse(
 				new ProblemReporter(
 					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
 					options, 
-					new DefaultProblemFactory(Locale.getDefault())));
+					new DefaultProblemFactory(Locale.getDefault())),
+				false);
 			
 		ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
 		CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/EnumDietRecoveryTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/EnumDietRecoveryTest.java
index fb7af9b..6a497d0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/EnumDietRecoveryTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/EnumDietRecoveryTest.java
@@ -193,7 +193,8 @@ public void checkParse(
 				new ProblemReporter(
 					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
 					options, 
-					new DefaultProblemFactory(Locale.getDefault())));
+					new DefaultProblemFactory(Locale.getDefault())),
+				false);
 			
 		ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
 		CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/GenericDietRecoveryTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/GenericDietRecoveryTest.java
index 58400a2..ca75d45 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/GenericDietRecoveryTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/GenericDietRecoveryTest.java
@@ -236,7 +236,8 @@ public void checkParse(
 				new ProblemReporter(
 					DefaultErrorHandlingPolicies.proceedWithAllProblems(), 
 					options, 
-					new DefaultProblemFactory(Locale.getDefault())));
+					new DefaultProblemFactory(Locale.getDefault())),
+				false);
 			
 		ICompilationUnit sourceUnit = new CompilationUnit(source, testName, null);
 		CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);	
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/JavadocCompletionParserTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/JavadocCompletionParserTest.java
index 78bfcc3..33e2a82 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/JavadocCompletionParserTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/JavadocCompletionParserTest.java
@@ -98,7 +98,8 @@ protected void verifyCompletionInJavadoc(String source, String after) {
 	CompilerOptions options = new CompilerOptions(getCompilerOptions());
 	CompletionParser parser = new CompletionParser(new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),
 		options,
-		new DefaultProblemFactory(Locale.getDefault())));
+		new DefaultProblemFactory(Locale.getDefault())),
+		false);
 
 	ICompilationUnit sourceUnit = new CompilationUnit(source.toCharArray(), "Test.java", null);
 	CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, 0);
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelCompletionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelCompletionTests.java
index f9fd6ad..075c848 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelCompletionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelCompletionTests.java
@@ -101,7 +101,36 @@ protected CompletionResult complete(String path, String source, boolean showPosi
 	return result;
 }
 protected CompletionResult contextComplete(ICompilationUnit cu, int cursorLocation) throws JavaModelException {
+	return contextComplete0(cu, cursorLocation, false, false, false, null);
+}
+protected CompletionResult contextComplete(
+		ICompilationUnit cu,
+		int cursorLocation,
+		boolean computeEnclosingElement,
+		boolean computeVisibleElements) throws JavaModelException {
+	return contextComplete0(cu, cursorLocation, true, computeEnclosingElement, computeVisibleElements, null);
+}
+protected CompletionResult contextComplete(
+		ICompilationUnit cu,
+		int cursorLocation,
+		boolean computeEnclosingElement,
+		boolean computeVisibleElements,
+		String typeSignature) throws JavaModelException {
+	return contextComplete0(cu, cursorLocation, true, computeEnclosingElement, computeVisibleElements, typeSignature);
+}
+protected CompletionResult contextComplete0(
+		ICompilationUnit cu,
+		int cursorLocation,
+		boolean useExtendedContext,
+		boolean computeEnclosingElement,
+		boolean computeVisibleElements,
+		String typeSignature) throws JavaModelException {
 	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, false, false);
+	requestor.setRequireExtendedContext(useExtendedContext);
+	requestor.setComputeEnclosingElement(computeEnclosingElement);
+	requestor.setComputeVisibleElements(computeVisibleElements);
+	requestor.setAssignableType(typeSignature);
+	
 	cu.codeComplete(cursorLocation, requestor, this.wcOwner);
 	
 	CompletionResult result =  new CompletionResult();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionContextTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionContextTests.java
index 15fd509..3309277 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionContextTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionContextTests.java
@@ -10,6 +10,9 @@
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.model;
 
+import java.io.IOException;
+
+import org.eclipse.core.runtime.CoreException;
 import org.eclipse.jdt.core.*;
 
 import org.eclipse.jdt.internal.codeassist.RelevanceConstants;
@@ -3914,4 +3917,826 @@ public void test0142() throws JavaModelException {
 		"completion token location={STATEMENT_START}",
 		result.context);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0143() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"zzzz\n" + 
+		"public class X {\n" + 
+		"  public int field0;\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true);
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location=UNKNOWN\n" +
+		"visibleElements={}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0144() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  zzzz\n" + 
+		"  public int field0;\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true);
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={MEMBER_START}\n" +
+		"visibleElements={}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0145() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public int field0;\n" + 
+		"  public int field1 = zzzz;\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true);
+	
+	String jclPath = getExternalJCLPathString();
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures={I}\n" +
+		"expectedTypesKeys={I}\n" +
+		"completion token location=UNKNOWN\n" +
+		"visibleElements={\n" +
+		"	field1 {key=Ltest/X;.field1)I} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"	field0 {key=Ltest/X;.field0)I} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"	wait(long, int) {key=Ljava/lang/Object;.wait(JI)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait(long) {key=Ljava/lang/Object;.wait(J)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait() {key=Ljava/lang/Object;.wait()V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	toString() {key=Ljava/lang/Object;.toString()Ljava/lang/String;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notifyAll() {key=Ljava/lang/Object;.notifyAll()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notify() {key=Ljava/lang/Object;.notify()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	hashCode() {key=Ljava/lang/Object;.hashCode()I} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	getClass() {key=Ljava/lang/Object;.getClass()Ljava/lang/Class;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	finalize() {key=Ljava/lang/Object;.finalize()V|Ljava/lang/Throwable;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	equals(java.lang.Object) {key=Ljava/lang/Object;.equals(Ljava/lang/Object;)Z} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	clone() {key=Ljava/lang/Object;.clone()Ljava/lang/Object;|Ljava/lang/CloneNotSupportedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0146() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public int field0;\n" + 
+		"  { zzzz }\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true);
+	
+	String jclPath = getExternalJCLPathString();
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	field0 {key=Ltest/X;.field0)I} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"	wait(long, int) {key=Ljava/lang/Object;.wait(JI)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait(long) {key=Ljava/lang/Object;.wait(J)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait() {key=Ljava/lang/Object;.wait()V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	toString() {key=Ljava/lang/Object;.toString()Ljava/lang/String;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notifyAll() {key=Ljava/lang/Object;.notifyAll()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notify() {key=Ljava/lang/Object;.notify()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	hashCode() {key=Ljava/lang/Object;.hashCode()I} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	getClass() {key=Ljava/lang/Object;.getClass()Ljava/lang/Class;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	finalize() {key=Ljava/lang/Object;.finalize()V|Ljava/lang/Throwable;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	equals(java.lang.Object) {key=Ljava/lang/Object;.equals(Ljava/lang/Object;)Z} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	clone() {key=Ljava/lang/Object;.clone()Ljava/lang/Object;|Ljava/lang/CloneNotSupportedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0147() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public int field0;\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true);
+	
+	String jclPath = getExternalJCLPathString();
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	field0 {key=Ltest/X;.field0)I} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"	foo() {key=Ltest/X;.foo()V} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"	wait(long, int) {key=Ljava/lang/Object;.wait(JI)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait(long) {key=Ljava/lang/Object;.wait(J)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait() {key=Ljava/lang/Object;.wait()V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	toString() {key=Ljava/lang/Object;.toString()Ljava/lang/String;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notifyAll() {key=Ljava/lang/Object;.notifyAll()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notify() {key=Ljava/lang/Object;.notify()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	hashCode() {key=Ljava/lang/Object;.hashCode()I} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	getClass() {key=Ljava/lang/Object;.getClass()Ljava/lang/Class;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	finalize() {key=Ljava/lang/Object;.finalize()V|Ljava/lang/Throwable;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	equals(java.lang.Object) {key=Ljava/lang/Object;.equals(Ljava/lang/Object;)Z} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	clone() {key=Ljava/lang/Object;.clone()Ljava/lang/Object;|Ljava/lang/CloneNotSupportedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0148() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public int field0;\n" + 
+		"  public int fieldX0;\n" + 
+		"  public class Y {\n" +
+		"    public int field0;\n" + 
+		"    public int fieldY0;\n" + 
+		"    public void fooY() {\n" +
+		"      int local0;\n" +
+		"      int localfooY0;\n" +
+		"      if (true) {\n" +
+		"        int local0;\n" +
+		"        int localfooY1;\n" +
+		"        zzzz\n" +
+		"      }\n" +
+		"  }\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true);
+	
+	String jclPath = getExternalJCLPathString();
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	local0 [in fooY() [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]]],\n" +
+		"	localfooY0 [in fooY() [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]]],\n" +
+		"	localfooY1 [in fooY() [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]]],\n" +
+		"	fieldY0 {key=Ltest/X$Y;.fieldY0)I} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	field0 {key=Ltest/X$Y;.field0)I} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	fieldX0 {key=Ltest/X;.fieldX0)I} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"	fooY() {key=Ltest/X$Y;.fooY()V} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	wait(long, int) {key=Ljava/lang/Object;.wait(JI)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait(long) {key=Ljava/lang/Object;.wait(J)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait() {key=Ljava/lang/Object;.wait()V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	toString() {key=Ljava/lang/Object;.toString()Ljava/lang/String;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notifyAll() {key=Ljava/lang/Object;.notifyAll()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notify() {key=Ljava/lang/Object;.notify()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	hashCode() {key=Ljava/lang/Object;.hashCode()I} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	getClass() {key=Ljava/lang/Object;.getClass()Ljava/lang/Class;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	finalize() {key=Ljava/lang/Object;.finalize()V|Ljava/lang/Throwable;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	equals(java.lang.Object) {key=Ljava/lang/Object;.equals(Ljava/lang/Object;)Z} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	clone() {key=Ljava/lang/Object;.clone()Ljava/lang/Object;|Ljava/lang/CloneNotSupportedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0149() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public void method0() {}\n" + 
+		"  public void method0(int i) {}\n" + 
+		"  public class Y {\n" +
+		"    public void method1() {}\n" + 
+		"    public void method0(int i) {}\n" + 
+		"    public void foo() {\n" +
+		"      zzzz\n" +
+		"    }\n" +
+		"  }\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true);
+	
+	String jclPath = getExternalJCLPathString();
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	method1() {key=Ltest/X$Y;.method1()V} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	method0(int) {key=Ltest/X$Y;.method0(I)V} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	foo() {key=Ltest/X$Y;.foo()V} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	wait(long, int) {key=Ljava/lang/Object;.wait(JI)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait(long) {key=Ljava/lang/Object;.wait(J)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait() {key=Ljava/lang/Object;.wait()V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	toString() {key=Ljava/lang/Object;.toString()Ljava/lang/String;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notifyAll() {key=Ljava/lang/Object;.notifyAll()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notify() {key=Ljava/lang/Object;.notify()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	hashCode() {key=Ljava/lang/Object;.hashCode()I} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	getClass() {key=Ljava/lang/Object;.getClass()Ljava/lang/Class;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	finalize() {key=Ljava/lang/Object;.finalize()V|Ljava/lang/Throwable;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	equals(java.lang.Object) {key=Ljava/lang/Object;.equals(Ljava/lang/Object;)Z} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	clone() {key=Ljava/lang/Object;.clone()Ljava/lang/Object;|Ljava/lang/CloneNotSupportedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	method0() {key=Ltest/X;.method0()V} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0150() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X extends A {\n" + 
+		"  public void method0() {}\n" + 
+		"  public void method0(int i) {}\n" + 
+		"  public class Y extends B {\n" +
+		"    public void method1() {}\n" + 
+		"    public void method0(int i) {}\n" + 
+		"    public void foo() {\n" +
+		"      zzzz\n" +
+		"    }\n" +
+		"  }\n" + 
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/A.java",
+		"package test;\n" + 
+		"public class A {\n" + 
+		"  public void methodA() {}\n" + 
+		"  public void method0(int i) {}\n" + 
+		"}");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src3/test/B.java",
+		"package test;\n" + 
+		"public class B {\n" + 
+		"  public void methodB() {}\n" + 
+		"  public void method0(int i) {}\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true);
+	
+	String jclPath = getExternalJCLPathString();
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	method1() {key=Ltest/X$Y;.method1()V} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	method0(int) {key=Ltest/X$Y;.method0(I)V} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	foo() {key=Ltest/X$Y;.foo()V} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	methodB() {key=Ltest/B;.methodB()V} [in B [in [Working copy] B.java [in test [in src3 [in Completion]]]]],\n" +
+		"	wait(long, int) {key=Ljava/lang/Object;.wait(JI)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait(long) {key=Ljava/lang/Object;.wait(J)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait() {key=Ljava/lang/Object;.wait()V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	toString() {key=Ljava/lang/Object;.toString()Ljava/lang/String;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notifyAll() {key=Ljava/lang/Object;.notifyAll()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notify() {key=Ljava/lang/Object;.notify()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	hashCode() {key=Ljava/lang/Object;.hashCode()I} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	getClass() {key=Ljava/lang/Object;.getClass()Ljava/lang/Class;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	finalize() {key=Ljava/lang/Object;.finalize()V|Ljava/lang/Throwable;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	equals(java.lang.Object) {key=Ljava/lang/Object;.equals(Ljava/lang/Object;)Z} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	clone() {key=Ljava/lang/Object;.clone()Ljava/lang/Object;|Ljava/lang/CloneNotSupportedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	method0() {key=Ltest/X;.method0()V} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"	methodA() {key=Ltest/A;.methodA()V} [in A [in [Working copy] A.java [in test [in src3 [in Completion]]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0151() throws CoreException, IOException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X extends A {\n" + 
+		"  public void method0() {}\n" + 
+		"  public void method0(int i) {}\n" + 
+		"  public class Y extends B {\n" +
+		"    public void method1() {}\n" + 
+		"    public void method0(int i) {}\n" + 
+		"    public void foo() {\n" +
+		"      zzzz\n" +
+		"    }\n" +
+		"  }\n" + 
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/B.java",
+		"package test;\n" + 
+		"public class B extends D {\n" + 
+		"  public void methodB() {}\n" + 
+		"  public void method0(int i) {}\n" + 
+		"}");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src3/test/D.java",
+		"package test;\n" + 
+		"public class D {\n" + 
+		"  public void methodD() {}\n" + 
+		"  public void method0(int i) {}\n" + 
+		"}");
+	
+	this.addLibrary(
+		getJavaProject("Completion"),
+		"test.jar",
+		"testsrc.zip",
+		new String[] {
+			"/Completion/test/A.java",
+			"package test;\n" + 
+			"public class A extends C {\n" + 
+			"  public void methodA() {}\n" + 
+			"  public void method0(int i) {}\n" + 
+			"}",
+			"/Completion/test/C.java",
+			"package test;\n" + 
+			"public class C {\n" + 
+			"  public void methodC() {}\n" + 
+			"  public void method0(int i) {}\n" + 
+			"}"
+		},
+		"1.4");
+
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true);
+	
+	String jclPath = getExternalJCLPathString();
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	method1() {key=Ltest/X$Y;.method1()V} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	method0(int) {key=Ltest/X$Y;.method0(I)V} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	foo() {key=Ltest/X$Y;.foo()V} [in Y [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]],\n" +
+		"	methodB() {key=Ltest/B;.methodB()V} [in B [in [Working copy] B.java [in test [in src3 [in Completion]]]]],\n" +
+		"	methodD() {key=Ltest/D;.methodD()V} [in D [in [Working copy] D.java [in test [in src3 [in Completion]]]]],\n" +
+		"	wait(long, int) {key=Ljava/lang/Object;.wait(JI)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait(long) {key=Ljava/lang/Object;.wait(J)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait() {key=Ljava/lang/Object;.wait()V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	toString() {key=Ljava/lang/Object;.toString()Ljava/lang/String;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notifyAll() {key=Ljava/lang/Object;.notifyAll()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notify() {key=Ljava/lang/Object;.notify()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	hashCode() {key=Ljava/lang/Object;.hashCode()I} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	getClass() {key=Ljava/lang/Object;.getClass()Ljava/lang/Class;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	finalize() {key=Ljava/lang/Object;.finalize()V|Ljava/lang/Throwable;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	equals(java.lang.Object) {key=Ljava/lang/Object;.equals(Ljava/lang/Object;)Z} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	clone() {key=Ljava/lang/Object;.clone()Ljava/lang/Object;|Ljava/lang/CloneNotSupportedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	method0() {key=Ltest/X;.method0()V} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"	methodA() {key=Ltest/A;.methodA()V} [in A [in A.class [in test [in test.jar [in Completion]]]]],\n" +
+		"	methodC() {key=Ltest/C;.methodC()V} [in C [in C.class [in test [in test.jar [in Completion]]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0152() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public void method0() {}\n" + 
+		"  public void method0(int i) {}\n" + 
+		"  public class Y {\n" +
+		"    public void method1() {}\n" + 
+		"    public void method0(int i) {}\n" + 
+		"    public void foo() {\n" +
+		"      zzzz\n" +
+		"    }\n" +
+		"  }\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+	
+	boolean unsupported = false;
+	try {
+		contextComplete0(this.workingCopies[0], cursorLocation, false /*do not use extended context*/,true /*ask enclosing element*/, true /*ask visible elements*/, null);
+	} catch (UnsupportedOperationException e) {
+		// this is expected because visible elements computation require heavy context
+		unsupported = true;
+	}
+	assertTrue("getVisibleElements() shouldn't be supported", unsupported);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0153() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public A methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/A.java",
+		"package test;\n" + 
+		"public class A {\n" + 
+		"}");
+	
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "Ltest/A;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	methodX() {key=Ltest/X;.methodX()Ltest/A;} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0154() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public A methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/A.java",
+		"package test;\n" + 
+		"public class A {\n" + 
+		"}");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src3/test/B.java",
+		"package test;\n" + 
+		"public class B {\n" + 
+		"}");
+	
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "Ltest/B;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0155() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public A methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/A.java",
+		"package test;\n" + 
+		"public class A extends B {\n" + 
+		"}");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src3/test/B.java",
+		"package test;\n" + 
+		"public class B {\n" + 
+		"}");
+	
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "Ltest/B;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	methodX() {key=Ltest/X;.methodX()Ltest/A;} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0156() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public A methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "Ltest/Zork;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0157() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public test.Zork methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "Ltest/Zork;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	methodX() {key=Ltest/X;.methodX()Ltest/Zork;} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0158() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, true, false);
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"enclosingElement=foo() {key=Ltest/X;.foo()V} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0159() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public void foo() {}\n" +
+		"  zzzz\n" +
+		"  public void bar() {}\n" +
+		"}");
+	
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, true, false);
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={MEMBER_START}\n" +
+		"enclosingElement=X {key=Ltest/X;} [in [Working copy] X.java [in test [in src3 [in Completion]]]]",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0160() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"zzzz\n" +
+		"public class X {\n" + 
+		"}");
+	
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, true, false);
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location=UNKNOWN\n" +
+		"enclosingElement=[Working copy] X.java [in test [in src3 [in Completion]]]",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0161() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public void foo() {}\n" +
+		"  public class Y {\n" + 
+		"    public void fooY() {}\n" +
+		"      zzzz\n" +
+		"    public void barY() {}\n" +
+		"  }\n" +
+		"  public void bar() {}\n" +
+		"}");
+	
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, true, false);
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={MEMBER_START}\n" +
+		"enclosingElement=Y {key=Ltest/X$Y;} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]]",
+		result.context);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionContextTests_1_5.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionContextTests_1_5.java
index 32be1c1..5456d37 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionContextTests_1_5.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionContextTests_1_5.java
@@ -778,4 +778,356 @@ public void test0027() throws JavaModelException {
 		"completion token location=UNKNOWN",
 		result.context);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0028() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X<TX> extends A<String> {\n" + 
+		"  public void methodX(TX x) {}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/A.java",
+		"package test;\n" + 
+		"public class A<TA> {\n" + 
+		"  public void methodA(TA a) {}\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true);
+	
+	String jclPath = getExternalJCLPathString("1.5");
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	methodX(TX) {key=Ltest/X;.methodX(TTX;)V} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"	foo() {key=Ltest/X;.foo()V} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"	methodA(TA) {key=Ltest/A<Ljava/lang/String;>;.methodA(Ljava/lang/String;)V} [in A [in [Working copy] A.java [in test [in src3 [in Completion]]]]],\n" +
+		"	wait(long, int) {key=Ljava/lang/Object;.wait(JI)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait(long) {key=Ljava/lang/Object;.wait(J)V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	wait() {key=Ljava/lang/Object;.wait()V|Ljava/lang/IllegalMonitorStateException;|Ljava/lang/InterruptedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	toString() {key=Ljava/lang/Object;.toString()Ljava/lang/String;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notifyAll() {key=Ljava/lang/Object;.notifyAll()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	notify() {key=Ljava/lang/Object;.notify()V|Ljava/lang/IllegalMonitorStateException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	hashCode() {key=Ljava/lang/Object;.hashCode()I} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	getClass() {key=Ljava/lang/Object;.getClass()Ljava/lang/Class<+Ljava/lang/Object;>;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	finalize() {key=Ljava/lang/Object;.finalize()V|Ljava/lang/Throwable;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	equals(java.lang.Object) {key=Ljava/lang/Object;.equals(Ljava/lang/Object;)Z} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"	clone() {key=Ljava/lang/Object;.clone()Ljava/lang/Object;|Ljava/lang/CloneNotSupportedException;} [in Object [in Object.class [in java.lang [in "+jclPath+"]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0029() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public A<String> methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/A.java",
+		"package test;\n" + 
+		"public class A<TA> {\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "Ltest/A<Ljava/lang/String;>;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	methodX() {key=Ltest/X;.methodX()Ltest/A<Ljava/lang/String;>;} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0030() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public A<String> methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/A.java",
+		"package test;\n" + 
+		"public class A<TA> {\n" + 
+		"}");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src3/test/B.java",
+		"package test;\n" + 
+		"public class B<TB> {\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "Ltest/B<Ljava/lang/String;>;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0031() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public A<String> methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/A.java",
+		"package test;\n" + 
+		"public class A<TA> extends B<TA>{\n" + 
+		"}");
+	
+	this.workingCopies[2] = getWorkingCopy(
+		"/Completion/src3/test/B.java",
+		"package test;\n" + 
+		"public class B<TB> {\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "Ltest/B<Ljava/lang/String;>;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	methodX() {key=Ltest/X;.methodX()Ltest/A<Ljava/lang/String;>;} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0032() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public A<String> methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/A.java",
+		"package test;\n" + 
+		"public class A<TA> {\n" + 
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "Ltest/Zork<Ljava/lang/String;>;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0033() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public A<String> methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+		"/Completion/src3/test/A.java",
+		"package test;\n" + 
+		"public class A<TA> {\n" + 
+		"}");
+	
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "Ltest/A<LZork;>;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0034() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X<T> {\n" + 
+		"  public T methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "TT;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	methodX() {key=Ltest/X;.methodX()TT;} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0035() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public <T> T methodX() {return null;}\n" + 
+		"  public void foo() {\n" +
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "TT;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={}",
+		result.context);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202470
+public void test0036() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy(
+		"/Completion/src3/test/X.java",
+		"package test;\n" + 
+		"public class X {\n" + 
+		"  public <T> T methodX() {\n" + 
+		"    zzzz\n" +
+		"  }\n" +
+		"}");
+	
+	String str = this.workingCopies[0].getSource();
+	int tokenStart = str.lastIndexOf("zzzz");
+	int tokenEnd = tokenStart + "zzzz".length() - 1;
+	int cursorLocation = str.lastIndexOf("zzzz") + "zzzz".length();
+
+	CompletionResult result = contextComplete(this.workingCopies[0], cursorLocation, false, true, "TT;");
+	
+	assertResults(
+		"completion offset="+(cursorLocation)+"\n" +
+		"completion range=["+(tokenStart)+", "+(tokenEnd)+"]\n" +
+		"completion token=\"zzzz\"\n" +
+		"completion token kind=TOKEN_KIND_NAME\n" +
+		"expectedTypesSignatures=null\n" +
+		"expectedTypesKeys=null\n" +
+		"completion token location={STATEMENT_START}\n" +
+		"visibleElements={\n" +
+		"	methodX() {key=Ltest/X;.methodX<T:Ljava/lang/Object;>()TT;} [in X [in [Working copy] X.java [in test [in src3 [in Completion]]]]],\n" +
+		"}",
+		result.context);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
index bd2646e..9757894 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
@@ -16,8 +16,10 @@ import java.util.Comparator;
 import org.eclipse.jdt.core.CompletionContext;
 import org.eclipse.jdt.core.CompletionProposal;
 import org.eclipse.jdt.core.CompletionRequestor;
+import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.Signature;
 import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.internal.core.JavaElement;
 
 public class CompletionTestsRequestor2 extends CompletionRequestor {
 	private final char[] NULL_LITERAL = "null".toCharArray();//$NON-NLS-1$
@@ -35,6 +37,10 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 	private boolean shortContext;
 	private boolean showMissingTypes;
 	
+	private boolean computeVisibleElements;
+	private boolean computeEnclosingElement;
+	private String assignableType;
+	
 	public boolean fDebug = false;
 
 	public CompletionTestsRequestor2() {
@@ -181,6 +187,40 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 				buffer.append('}');
 			}
 		}
+		
+		if (this.computeEnclosingElement) {
+			buffer.append('\n');
+			buffer.append("enclosingElement="); //$NON-NLS-1$
+			JavaElement enclosingElement = (JavaElement)this.context.getEnclosingElement();
+			if (enclosingElement == null) {
+				buffer.append("null"); //$NON-NLS-1$
+			} else {
+				buffer.append(enclosingElement.toStringWithAncestors(true /*show resolved info*/));
+			}
+		}
+		
+		if (this.computeVisibleElements) {
+			buffer.append('\n');
+			
+			IJavaElement[] visibleElements = this.context.getVisibleElements(this.assignableType);
+			buffer.append("visibleElements="); //$NON-NLS-1$
+			if (visibleElements == null) {
+				buffer.append("null"); //$NON-NLS-1$
+			} else if (visibleElements.length == 0) {
+				buffer.append("{}"); //$NON-NLS-1$
+			} else {
+				buffer.append('{');
+				buffer.append('\n');
+				for (int i = 0; i < visibleElements.length; i++) {
+					JavaElement element = (JavaElement) visibleElements[i];
+					buffer.append('\t');
+					buffer.append(element.toStringWithAncestors(true /*show resolved info*/));
+					buffer.append(",\n"); //$NON-NLS-1$
+				}
+				buffer.append('}');
+			}
+		}
+		
 		//buffer.append('\n');
 		
 		
@@ -522,4 +562,13 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 	public String toString() {
 		return getResults();
 	}
+	public void setComputeVisibleElements(boolean computeVisibleElements) {
+		this.computeVisibleElements = computeVisibleElements;
+	}
+	public void setAssignableType(String typeSignature) {
+		this.assignableType = typeSignature;
+	}
+	public void setComputeEnclosingElement(boolean computeEnclosingElement) {
+		this.computeEnclosingElement = computeEnclosingElement;
+	}
 }
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 01a5cc0..dac09a5 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -49,7 +49,7 @@ Eclipse SDK 3.4M6 - %date% - 3.4 MILESTONE 6
 <ul>
 <li>CodeAssist: Added new API to give more information about completion context:<br>
 <ul>
-<li>CompletionContext#getEnclosingElement() - This method returns the elements visible from the completion location.
+<li>CompletionContext#getEnclosingElement() - This method returns the innermost enclosing Java element which contains the completion location.
 <pre>
 public class X {
 	void foo() {
@@ -59,7 +59,7 @@ public class X {
 </pre>
 <code>getEnclosingElement()</code> returns the IMethod named foo.
 </li>
-<li>CompletionContext#getVisibleElements(String) - This method returns the innermost enclosing Java element which contains the completion location.
+<li>CompletionContext#getVisibleElements(String) - This method returns the elements visible from the completion location.
 <pre>
 public class X {
 	p.Y f1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index a27f2b7..516b88b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -1220,7 +1220,7 @@ TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean i
 	return createArrayType(binding, dimension);
 }
 
-TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariableBinding[] staticVariables, ReferenceBinding enclosingType, char[][][] missingTypeNames) {
+public TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariableBinding[] staticVariables, ReferenceBinding enclosingType, char[][][] missingTypeNames) {
 	// TypeVariableSignature = 'T' Identifier ';'
 	// ArrayTypeSignature = '[' TypeSignature
 	// ClassTypeSignature = 'L' Identifier TypeArgs(optional) ';'
@@ -1239,12 +1239,15 @@ TypeBinding getTypeFromTypeSignature(SignatureWrapper wrapper, TypeVariableBindi
 				return dimension == 0 ? (TypeBinding) staticVariables[i] : createArrayType(staticVariables[i], dimension);
 	    ReferenceBinding initialType = enclosingType;
 		do {
-		    if (enclosingType instanceof BinaryTypeBinding) { // per construction can only be binary type binding
-				TypeVariableBinding[] enclosingVariables = ((BinaryTypeBinding)enclosingType).typeVariables; // do not trigger resolution of variables
-				for (int i = enclosingVariables.length; --i >= 0;)
-					if (CharOperation.equals(enclosingVariables[i].sourceName, wrapper.signature, varStart, varEnd))
-						return dimension == 0 ? (TypeBinding) enclosingVariables[i] : createArrayType(enclosingVariables[i], dimension);
-		    }
+			TypeVariableBinding[] enclosingTypeVariables;
+			if (enclosingType instanceof BinaryTypeBinding) { // compiler normal case, no eager resolution of binary variables
+				enclosingTypeVariables = ((BinaryTypeBinding)enclosingType).typeVariables; // do not trigger resolution of variables
+			} else { // codepath only use by codeassist for decoding signatures
+				enclosingTypeVariables = enclosingType.typeVariables();
+			}
+			for (int i = enclosingTypeVariables.length; --i >= 0;)
+				if (CharOperation.equals(enclosingTypeVariables[i].sourceName, wrapper.signature, varStart, varEnd))
+					return dimension == 0 ? (TypeBinding) enclosingTypeVariables[i] : createArrayType(enclosingTypeVariables[i], dimension);
 		} while ((enclosingType = enclosingType.enclosingType()) != null);
 		problemReporter.undefinedTypeVariableSignature(CharOperation.subarray(wrapper.signature, varStart, varEnd), initialType);
 		return null; // cannot reach this, since previous problem will abort compilation
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionContext.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionContext.java
index 2b89547..18e445a 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionContext.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionContext.java
@@ -27,6 +27,38 @@ import org.eclipse.jdt.internal.codeassist.complete.CompletionOnJavadoc;
 public final class CompletionContext extends InternalCompletionContext {
 
 	/**
+	 * The completed token is the first token of a member declaration.<br>
+	 * e.g.
+	 * <pre>
+	 * public class X {
+	 *   Foo| // completion occurs at |
+	 * }
+	 * </pre>
+	 * 
+	 * @see #getTokenLocation()
+	 * 
+	 * @since 3.4
+	 */
+	public static final int TL_MEMBER_START = 1;
+	
+	/**
+	 * The completed token is the first token of a statement.<br>
+	 * e.g.
+	 * <pre>
+	 * public class X {
+	 *   public void bar() {
+	 *     Foo| // completion occurs at |
+	 *   }
+	 * }
+	 * </pre>
+	 * 
+	 * @see #getTokenLocation()
+	 * 
+	 * @since 3.4
+	 */
+	public static final int TL_STATEMENT_START = 2;
+	
+	/**
 	 * The completion token is unknown.
 	 * @since 3.2
 	 */
@@ -83,6 +115,18 @@ public final class CompletionContext extends InternalCompletionContext {
 	public boolean isInJavadocFormalReference() {
 		return (this.javadoc & CompletionOnJavadoc.FORMAL_REFERENCE) != 0;
 	}
+	
+	/**
+	 * Returns whether this completion context is an extended context.
+	 * Some methods of this context can be used only if this context is an extended context but an extended context consumes more memory.
+	 * 
+	 * @return <code>true</code> if this completion context is an extended context.
+	 * 
+	 * @since 3.4
+	 */
+	public boolean isExtended() {
+		return this.extendedContext != null;
+	}
 
 	/**
 	 * Return signatures of expected types of a potential completion proposal at the completion position.
@@ -210,38 +254,80 @@ public final class CompletionContext extends InternalCompletionContext {
 		return this.offset;
 	}
 	
-	
 	/**
-	 * The completed token is the first token of a member declaration.<br>
-	 * e.g.
-	 * <pre>
-	 * public class X {
-	 *   Foo| // completion occurs at |
-	 * }
-	 * </pre>
+	 * Returns the innermost enclosing Java element which contains the completion location or <code>null</code> if this element cannot be computed.
+	 * The returned Java element and all Java elements in the same compilation unit which can be navigated to from the returned Java element are special Java elements:
+	 * <ul>
+	 * <li>they are based on the current content of the compilation unit's buffer, they are not the result of a reconcile operation</li>
+	 * <li>they are not updated if the buffer changes.</li>
+	 * <li>they do not contain local types which are not visible from the completion location.</li>
+	 * <li>they do not give information about categories. {@link IMember#getCategories()} will return an empty array</li>
+	 * </ul>
 	 * 
-	 * @see #getTokenLocation()
+	 * Reasons for returning <code>null</code> include:
+	 * <ul>
+	 * <li>the compilation unit no longer exists</li>
+	 * <li>the completion occurred in a binary type. However this restriction might be relaxed in the future.</li>
+	 * </ul>
+	 * 
+	 * @return the innermost enclosing Java element which contains the completion location or <code>null</code> if this element cannot be computed.
+	 * 
+	 * @exception UnsupportedOperationException if the context is not an extended context
 	 * 
 	 * @since 3.4
 	 */
-	public static final int TL_MEMBER_START = 1;
+	public IJavaElement getEnclosingElement() {
+		if (!this.isExtended()) throw new UnsupportedOperationException("Operation only supported in extended context"); //$NON-NLS-1$
+		
+		if (this.extendedContext == null) return null;
+		
+		return this.extendedContext.getEnclosingElement();
+	}
 	
 	/**
-	 * The completed token is the first token of a statement.<br>
-	 * e.g.
-	 * <pre>
-	 * public class X {
-	 *   public void bar() {
-	 *     Foo| // completion occurs at |
-	 *   }
-	 * }
-	 * </pre>
+	 * Return the elements which are visible from the completion location and which can be assigned to the given type.
+	 * An element is assignable if its type can be assigned to a variable
+	 * of the given type, as specified in section 5.2 of <em>The Java Language
+	 * Specification, Third Edition</em> (JLS3).
+	 * A visible element is either:
+	 * <ul>
+	 * <li>a {@link ILocalVariable} - the element type is {@link ILocalVariable#getTypeSignature()}</li>
+	 * <li>a {@link IField} - the element type is {@link IField#getTypeSignature()}</li>
+	 * <li>a {@link IMethod} - the element type is {@link IMethod#getReturnType()}</li>
+	 * </ul>
 	 * 
-	 * @see #getTokenLocation()
+	 * Returned elements defined in the completed compilation unit are special Java elements:
+	 * <ul>
+	 * <li>they are based on the current content of the compilation unit's buffer, they are not the result of a reconcile operation</li>
+	 * <li>they are not updated if the buffer changes.</li>
+	 * <li>they do not contain local types which are not visible from the completion location.</li>
+	 * <li>they do not give information about categories. {@link IMember#getCategories()} will return an empty array</li>
+	 * </ul>
+	 * 
+	 * Note the array can be empty if:
+	 * <ul>
+	 * <li>the compilation unit no longer exists</li>
+	 * <li>the completion occurred in a binary type. However this restriction might be relaxed in the future.</li>
+	 * </ul>
+	 * 
+	 * @param typeSignature elements which can be assigned to this type are returned.
+	 * 		If <code>null</code> there is no constraint on the type of the returned elements.
+	 * 
+	 * @return elements which are visible from the completion location and which can be assigned to the given type.
+	 * 
+	 * @exception UnsupportedOperationException if the context is not an extended context
+	 * 
+	 * @see #isExtended()
 	 * 
 	 * @since 3.4
 	 */
-	public static final int TL_STATEMENT_START = 2;
+	public IJavaElement[] getVisibleElements(String typeSignature) {
+		if (!this.isExtended()) throw new UnsupportedOperationException("Operation only supported in extended context"); //$NON-NLS-1$
+		
+		if (this.extendedContext == null) return new IJavaElement[0];
+		
+		return this.extendedContext.getVisibleElements(typeSignature);
+	}
 	
 	public String toString() {
 		StringBuffer buffer = new StringBuffer();
@@ -296,9 +382,9 @@ public final class CompletionContext extends InternalCompletionContext {
 		buffer.append('\n');
 		
 		if (tokenLocation == 0) {
-			buffer.append("locationType=UNKNOWN"); //$NON-NLS-1$
+			buffer.append("tokenLocation=UNKNOWN"); //$NON-NLS-1$
 		} else {
-			buffer.append("locationType={"); //$NON-NLS-1$
+			buffer.append("tokenLocation={"); //$NON-NLS-1$
 			boolean first = true;
 			if ((tokenLocation & CompletionContext.TL_MEMBER_START) != 0) {
 				if (!first) buffer.append(',');
@@ -313,7 +399,7 @@ public final class CompletionContext extends InternalCompletionContext {
 			buffer.append('}');
 		}
 		buffer.append('\n');
-			
+		
 		return buffer.toString();
 	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
index b76a0be..60c0836 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
@@ -68,6 +68,8 @@ public abstract class CompletionRequestor {
 	 * 1 << completionProposalKind
 	 */
 	private int requiredProposalAllowSet[] = null;
+			
+	private boolean requireExtendedContext = false;
 
 	/**
 	 * Creates a new completion requestor.
@@ -324,4 +326,33 @@ public abstract class CompletionRequestor {
 	public void acceptContext(CompletionContext context) {
 		// do nothing
 	}
+	
+	/**
+	 * Returns whether this requestor requires an extended context.
+	 * 
+	 * By default this method return <code>false</code>.
+	 * 
+	 * @return <code>true</code> if this requestor requires an extended context.
+	 * 
+	 * @see CompletionContext#isExtended()
+	 * 
+	 * @since 3.4
+	 */
+	public boolean isExtendedContextRequired() {
+		return this.requireExtendedContext;
+	}
+	
+	
+	/**
+	 * Sets whether this requestor requires an extended context.
+	 * 
+	 * @param require <code>true</code> if this requestor requires an extended context.
+	 * 
+	 * @see CompletionContext#isExtended()
+	 * 
+	 * @since 3.4
+	 */
+	public void setRequireExtendedContext(boolean require) {
+		this.requireExtendedContext = require;
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
index 06fb9b0..015e147 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
@@ -36,6 +36,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.ast.*;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.eclipse.jdt.internal.compiler.ast.Initializer;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.*;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/eval/EvaluationContextWrapper.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/eval/EvaluationContextWrapper.java
index f533a79..c06e50e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/eval/EvaluationContextWrapper.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/eval/EvaluationContextWrapper.java
@@ -110,7 +110,8 @@ public void codeComplete(String codeSnippet, int position, CompletionRequestor r
 		environment,
 		requestor,
 		this.project.getOptions(true),
-		this.project
+		this.project,
+		owner
 	);
 }
 /**
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
index fc21f4e..164f8a7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
@@ -50,7 +50,7 @@ public class SourceIndexer extends AbstractIndexer implements SuffixConstants {
 			IProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(path.segment(0));
 			parser = JavaModelManager.getJavaModelManager().indexManager.getSourceElementParser(JavaCore.create(project), requestor);
 		} else {
-			parser.requestor = requestor;
+			parser.setRequestor(requestor);
 		}
 		
 		// Launch the parser
