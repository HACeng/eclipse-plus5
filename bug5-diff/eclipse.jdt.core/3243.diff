commit d8e17e252326ade78baaea3eb05d18d16eaf07ae
Author: Jerome lanneluc <jlanneluc>
Date:   Wed Nov 20 17:01:48 2002 +0000

    Fix for bug 3243

158	160	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AttachSourceTests.java
1	1	org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/.classpath
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
4	6	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
7	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMember.java
3	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
8	8	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
4	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
1	13	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
49	20	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
13	7	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SetClasspathOperation.java
137	29	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AttachSourceTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AttachSourceTests.java
index bae9514..164154c 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AttachSourceTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AttachSourceTests.java
@@ -11,8 +11,6 @@
 package org.eclipse.jdt.core.tests.model;
 
 import junit.framework.Test;
-import junit.framework.TestSuite;
-
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
@@ -28,47 +26,20 @@ import org.eclipse.jdt.internal.core.JarPackageFragmentRoot;
 */
 public class AttachSourceTests extends ModifyingResourceTests {
 
-/**
- * Attaches a source zip to the given jar package fragment root.
- */
-protected void attachSource(IPackageFragmentRoot root, String sourcePath, String sourceRoot) throws JavaModelException {
-	IJavaProject javaProject = root.getJavaProject();
-	IClasspathEntry[] entries = (IClasspathEntry[])javaProject.getRawClasspath().clone();
-	for (int i = 0; i < entries.length; i++){
-		IClasspathEntry entry = entries[i];
-		if (entry.getPath().toOSString().toLowerCase().equals(root.getPath().toOSString().toLowerCase())) {
-			entries[i] = JavaCore.newLibraryEntry(
-				root.getPath(),
-				sourcePath == null ? null : new Path(sourcePath),
-				sourceRoot == null ? null : new Path(sourceRoot),
-				false);
-			break;
-		}
-	}
-	javaProject.setRawClasspath(entries, null);
+
+protected void setUp() throws Exception {
+	super.setUp();
+	this.attachSource(this.root, "/AttachSourceTests/attachsrc.zip", "");
 }
+
+
 	private IPackageFragmentRoot root;
 	
 public AttachSourceTests(String name) {
 	super(name);
 }
 public static Test suite() {
-	TestSuite suite = new Suite(AttachSourceTests.class.getName());
-	suite.addTest(new AttachSourceTests("testAttachSource"));
-	suite.addTest(new AttachSourceTests("testGetSourceAttachmentPath"));
-	suite.addTest(new AttachSourceTests("testAttachSourceRetrievalClass"));
-	suite.addTest(new AttachSourceTests("testAttachSourceRetrievalMethod"));
-	suite.addTest(new AttachSourceTests("testAttachSourceSourceRange"));
-	suite.addTest(new AttachSourceTests("testAttachSourceSourceRangeInnerClass"));
-	suite.addTest(new AttachSourceTests("testAttachSourceNameRange"));
-	suite.addTest(new AttachSourceTests("testClassFileGetElementAt"));
-	suite.addTest(new AttachSourceTests("testAttachSourcePersisted"));
-	suite.addTest(new AttachSourceTests("testChangeSourceAttachmentFile"));
-	suite.addTest(new AttachSourceTests("testDetachSource"));
-	suite.addTest(new AttachSourceTests("testAttachSourceWithRootPath"));
-	suite.addTest(new AttachSourceTests("testAttachSourceToLibFolder"));
-	return suite;
-
+	return new Suite(AttachSourceTests.class);
 }
 /**
  * Create project and set the jar placeholder.
@@ -77,31 +48,144 @@ public void setUpSuite() throws Exception {
 	super.setUpSuite();
 	
 	IJavaProject project = setUpJavaProject("AttachSourceTests");
-	this.root = project.getPackageFragmentRoot("/AttachSourceTests/attach.jar");
+	this.root = project.getPackageFragmentRoot(this.getFile("/AttachSourceTests/attach.jar"));
+}
+protected void tearDown() throws Exception {
+	IJavaProject project = this.getJavaProject("/AttachSourceTests");
+	IPackageFragmentRoot[] roots = project.getAllPackageFragmentRoots();
+	for (int i = 0; i < roots.length; i++) {
+		IPackageFragmentRoot root = roots[i];
+		if (root.getKind() == IPackageFragmentRoot.K_BINARY) {
+			this.attachSource(root, null, null); // detach source
+		}
+	}
+	super.tearDown();
 }
+
 /**
  * Reset the jar placeholder and delete project.
  */
 public void tearDownSuite() throws Exception {
-	this.root.close();
-	this.root = null;
 	this.deleteProject("AttachSourceTests");
-	
 	super.tearDown();
 }
 
+
 /**
- * Attaches a source zip to the classes.zip jar.
+ * Changing the source attachment file should update the java model.
+ * (regression test for bug 23292 Must restart Eclipse after debug of source in .zip is updated)
  */
-public void testAttachSource() throws CoreException {
-	this.attachSource(this.root, "/AttachSourceTests/attachsrc.zip", null);
+public void testChangeSourceAttachmentFile() throws CoreException {
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
+	IMethod method = cf.getType().getMethod("foo", new String[] {});
+	String lineSeparator = System.getProperty("line.separator");
+	
+	// check initial source
+	assertEquals(
+		"unexpected initial source for foo()",
+		"public void foo() {" + lineSeparator +
+		"	}",
+		method.getSource());
+
+	// replace source attachment file
+	this.swapFiles("AttachSourceTests/attachsrc.zip", "AttachSourceTests/attachsrc.new.zip");
+	assertEquals(
+		"unexpected source for foo() after replacement",
+		"public void foo() {" + lineSeparator +
+		"		System.out.println(\"foo\");" + lineSeparator +
+		"	}",
+		method.getSource());
+		
+	// delete source attachment file
+	this.deleteFile("AttachSourceTests/attachsrc.zip");
+	assertEquals(
+		"unexpected source for foo() after deletion",
+		null,
+		method.getSource());
+		
+	// add source attachment file back
+	this.moveFile("AttachSourceTests/attachsrc.new.zip", "AttachSourceTests/attachsrc.zip");
+	assertEquals(
+		"unexpected source for foo() after addition",
+		"public void foo() {" + lineSeparator +
+		"	}",
+		method.getSource());
 }
+/**
+ * Ensure that a class file with an attached source can retrieve its children given a source index.
+ */
+public void testClassFileGetElementAt() throws JavaModelException {
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
+	IJavaElement elt = null;
+	
+	elt = cf.getElementAt(15);
+	assertTrue("should have found \"A\"",
+		elt != null &&
+		elt.getElementType() == IJavaElement.TYPE &&
+		elt.getElementName().equals("A"));
+	
+	elt = cf.getElementAt(53);
+	assertTrue("should have found \"public A()\"",
+		elt != null &&
+		elt.getElementType() == IJavaElement.METHOD &&
+		elt.getElementName().equals("A"));
+
+	elt = cf.getElementAt(72);
+	assertTrue("should have found \"public void foo()\"",
+		elt != null &&
+		elt.getElementType() == IJavaElement.METHOD &&
+		elt.getElementName().equals("foo"));
+}
+/**
+ * Retrieves the source code for "A.class", which is
+ * the entire CU for "A.java".
+ */
+public void testClassRetrieval() throws JavaModelException {
+	IClassFile objectCF = this.root.getPackageFragment("x.y").getClassFile("A.class");
+	assertTrue("source code does not exist for the entire attached compilation unit", objectCF.getSource() != null);
+}
+/**
+ * Removes the source attachment from the jar.
+ */
+public void testDetachSource() throws JavaModelException {
+	this.attachSource(this.root, null, null);
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
+	assertTrue("source code should no longer exist for A", cf.getSource() == null);
+	assertTrue("name range should no longer exist for A", cf.getType().getNameRange().getOffset() == -1);
+	assertTrue("source range should no longer exist for A", cf.getType().getSourceRange().getOffset() == -1);
+	assertTrue("Source attachment path should be null", null == this.root.getSourceAttachmentPath());
+	assertTrue("Source attachment root path should be null", null ==this.root.getSourceAttachmentRootPath());
+}
+/**
+ * Attaches a source zip to a jar without specifying the source attachment root. 
+ * The source zip has a nested root structure and exists as a resource.  
+ * Tests that the source attachment root is detected.
+ */
+public void testDetectRootPath() throws JavaModelException {
+	IJavaProject project = getJavaProject("AttachSourceTests");
+	IFile jar = (IFile) project.getProject().findMember("attach2.jar");
+	IFile srcZip=(IFile) project.getProject().findMember("attach2src.zip");
+	IPackageFragmentRoot root = project.getPackageFragmentRoot(jar);
+	root.attachSource(srcZip.getFullPath(), null, null);
 
+	// ensure root path is detected
+	IPath rootSAPath= root.getSourceAttachmentRootPath();
+	assertEquals("Unexpected source attachment root path for " + root.getPath(), "src/nested", rootSAPath.toString());
+	
+	// ensure source can be retrieved
+	IClassFile cf = root.getPackageFragment("x.y").getClassFile("B.class");
+	assertTrue("source code does not exist for the entire attached compilation unit", cf.getSource() != null);
+	
+	// ensure root path is recomputed
+	root.close();
+	cf = root.getPackageFragment("x.y").getClassFile("B.class");
+	assertTrue("source code does not exist for the entire attached compilation unit", cf.getSource() != null);
+}
 /**
  * Ensures that name ranges exists for BinaryMembers that have
  * mapped source.
  */
-public void testAttachSourceNameRange() throws JavaModelException {
+public void testGetNameRange() throws JavaModelException {
 	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
 	IMethod method = cf.getType().getMethod("foo", null);
 	assertTrue("method name range not correct", method.getNameRange().getOffset() != -1 && method.getNameRange().getLength() != 0);
@@ -117,39 +201,18 @@ public void testAttachSourceNameRange() throws JavaModelException {
 	assertEquals("name should be 'A'", "A", source);
 }
 /**
- * Closes the jar, to ensure when it is re-opened the source
- * attachment still exists.
- */
-public void testAttachSourcePersisted() throws JavaModelException {
-	this.root.close();
-	testAttachSourceRetrievalClass();
-	testAttachSourceRetrievalMethod();
-}
-/**
- * Retrieves the source code for methods of class A.
- */
-public void testAttachSourceRetrievalMethod() throws JavaModelException {
-	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
-	IMethod[] methods = cf.getType().getMethods();
-	for (int i = 0; i < methods.length; i++) {
-		IMethod method = methods[i];
-		assertTrue("source code does not exist for the method " + method, method.getSource() != null);
-		assertTrue("method name range not correct", method.getNameRange().getOffset() != -1 && method.getNameRange().getLength() != 0);
-	}
-}
-/**
- * Retrieves the source code for "A.class", which is
- * the entire CU for "A.java".
+ * Retrieves the source attachment paths for jar root.
  */
-public void testAttachSourceRetrievalClass() throws JavaModelException {
-	IClassFile objectCF = this.root.getPackageFragment("x.y").getClassFile("A.class");
-	assertTrue("source code does not exist for the entire attached compilation unit", objectCF.getSource() != null);
+public void testGetSourceAttachmentPath() throws JavaModelException {
+	IPath saPath= this.root.getSourceAttachmentPath();
+	assertEquals("Source attachment path not correct for root " + this.root, "/AttachSourceTests/attachsrc.zip", saPath.toString());
+	assertEquals("Source attachment root path should be empty", new Path(""), this.root.getSourceAttachmentRootPath());
 }
 /**
  * Ensures that a source range exists for the class file that has
  * mapped source.
  */
-public void testAttachSourceSourceRange() throws JavaModelException {
+public void testGetSourceRange() throws JavaModelException {
 	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
 	assertTrue("Class file source range not correct", cf.getSourceRange().getOffset() == 0 && cf.getSourceRange().getLength() != 0);
 }
@@ -157,14 +220,14 @@ public void testAttachSourceSourceRange() throws JavaModelException {
  * Ensures that a source range exists for the (inner) class file that has
  * mapped source.
  */
-public void testAttachSourceSourceRangeInnerClass() throws JavaModelException {
+public void testGetSourceRangeInnerClass() throws JavaModelException {
 	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A$Inner.class");
 	assertTrue("Inner Class file source range not correct", cf.getSourceRange().getOffset() == 0 && cf.getSourceRange().getLength() != 0);
 }
 /**
  * Ensures that a source folder can be attached to a lib folder.
  */
-public void testAttachSourceToLibFolder() throws JavaModelException {
+public void testLibFolder() throws JavaModelException {
 	IPackageFragmentRoot root = this.getPackageFragmentRoot("/AttachSourceTests/lib");
 	this.attachSource(root, "/AttachSourceTests/srcLib", "");
 	
@@ -176,11 +239,32 @@ public void testAttachSourceToLibFolder() throws JavaModelException {
 		cf.getSource());
 }
 /**
+ * Retrieves the source code for methods of class A.
+ */
+public void testMethodRetrieval() throws JavaModelException {
+	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
+	IMethod[] methods = cf.getType().getMethods();
+	for (int i = 0; i < methods.length; i++) {
+		IMethod method = methods[i];
+		assertTrue("source code does not exist for the method " + method, method.getSource() != null);
+		assertTrue("method name range not correct", method.getNameRange().getOffset() != -1 && method.getNameRange().getLength() != 0);
+	}
+}
+/**
+ * Closes the jar, to ensure when it is re-opened the source
+ * attachment still exists.
+ */
+public void testPersistence() throws JavaModelException {
+	this.root.close();
+	testClassRetrieval();
+	testMethodRetrieval();
+}
+/**
  * Attaches a source zip to a jar.  The source zip has
  * a nested root structure and exists as a resource.  Tests that
  * the attachment is persisted as a server property for the jar.
  */
-public void testAttachSourceWithRootPath() throws JavaModelException {
+public void testRootPath() throws JavaModelException {
 	IJavaProject project = getJavaProject("AttachSourceTests");
 	IFile jar = (IFile) project.getProject().findMember("attach2.jar");
 	IFile srcZip=(IFile) project.getProject().findMember("attach2src.zip");
@@ -201,90 +285,4 @@ public void testAttachSourceWithRootPath() throws JavaModelException {
 	
 	root.close();
 }
-/**
- * Ensure that a class file with an attached source can retrieve its children given a source index.
- */
-public void testClassFileGetElementAt() throws JavaModelException {
-	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
-	IJavaElement elt = null;
-	
-	elt = cf.getElementAt(15);
-	assertTrue("should have found \"A\"",
-		elt != null &&
-		elt.getElementType() == IJavaElement.TYPE &&
-		elt.getElementName().equals("A"));
-	
-	elt = cf.getElementAt(53);
-	assertTrue("should have found \"public A()\"",
-		elt != null &&
-		elt.getElementType() == IJavaElement.METHOD &&
-		elt.getElementName().equals("A"));
-
-	elt = cf.getElementAt(72);
-	assertTrue("should have found \"public void foo()\"",
-		elt != null &&
-		elt.getElementType() == IJavaElement.METHOD &&
-		elt.getElementName().equals("foo"));
-}
-/**
- * Changing the source attachment file should update the java model.
- * (regression test for bug 23292 Must restart Eclipse after debug of source in .zip is updated)
- */
-public void testChangeSourceAttachmentFile() throws CoreException {
-	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
-	IMethod method = cf.getType().getMethod("foo", new String[] {});
-	String lineSeparator = System.getProperty("line.separator");
-	
-	// check initial source
-	assertEquals(
-		"unexpected initial source for foo()",
-		"public void foo() {" + lineSeparator +
-		"	}",
-		method.getSource());
-
-	// replace source attachment file
-	this.swapFiles("AttachSourceTests/attachsrc.zip", "AttachSourceTests/attachsrc.new.zip");
-	assertEquals(
-		"unexpected source for foo() after replacement",
-		"public void foo() {" + lineSeparator +
-		"		System.out.println(\"foo\");" + lineSeparator +
-		"	}",
-		method.getSource());
-		
-	// delete source attachment file
-	this.deleteFile("AttachSourceTests/attachsrc.zip");
-	assertEquals(
-		"unexpected source for foo() after deletion",
-		null,
-		method.getSource());
-		
-	// add source attachment file back
-	this.moveFile("AttachSourceTests/attachsrc.new.zip", "AttachSourceTests/attachsrc.zip");
-	assertEquals(
-		"unexpected source for foo() after addition",
-		"public void foo() {" + lineSeparator +
-		"	}",
-		method.getSource());
-}
-/**
- * Removes the source attachment from the jar.
- */
-public void testDetachSource() throws JavaModelException {
-	this.attachSource(this.root, null, null);
-	IClassFile cf = this.root.getPackageFragment("x.y").getClassFile("A.class");
-	assertTrue("source code should no longer exist for A", cf.getSource() == null);
-	assertTrue("name range should no longer exist for A", cf.getType().getNameRange().getOffset() == -1);
-	assertTrue("source range should no longer exist for A", cf.getType().getSourceRange().getOffset() == -1);
-	assertTrue("Source attachment path should be null", null == this.root.getSourceAttachmentPath());
-	assertTrue("Source attachment root path should be null", null ==this.root.getSourceAttachmentRootPath());
-}
-/**
- * Retrieves the source attachment paths for jar root.
- */
-public void testGetSourceAttachmentPath() throws JavaModelException {
-	IPath saPath= this.root.getSourceAttachmentPath();
-	assertEquals("Source attachment path not correct for root " + this.root, "/AttachSourceTests/attachsrc.zip", saPath.toString());
-	assertEquals("Source attachment root path should be empty", new Path(""), this.root.getSourceAttachmentRootPath());
-}
-
 }
diff --git a/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/.classpath b/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/.classpath
index 0e87d51..ee99411 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/.classpath
+++ b/org.eclipse.jdt.core.tests.model/workspace/AttachSourceTests/.classpath
@@ -4,6 +4,6 @@
     <classpathentry kind="lib" path="attach2.jar"/>
     <classpathentry kind="lib" path="lib"/>
     <classpathentry kind="src" path="src"/>
-    <classpathentry kind="var" path="JCL_LIB" sourcepath="JCL_SRC" rootpath="JCL_SRCROOT"/>
+    <classpathentry kind="var" path="JCL_LIB"/>
     <classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 57b1029..858a247 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -80,7 +80,9 @@ IProgressMonitor)</code> and <code>JavaCore.newLibraryEntry(...)</code>.
 </ul>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=26785>26785</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=3243>3243</a>
+SourceAttachment - automatic computation of the package root does not work (1GCMTLP) 
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=26785>26785</a>
 Unreachable empty blocks should be reported in 1.4 compliant mode
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=26664">26664</a>
 deprecated interfaces are not allways recognized
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 731b863..012fa50 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1886,9 +1886,8 @@ public final class JavaCore extends Plugin implements IExecutableExtension {
 	 * @param path the absolute path of the binary archive
 	 * @param sourceAttachmentPath the absolute path of the corresponding source archive or folder, 
 	 *    or <code>null</code> if none
-	 * @param sourceAttachmentRootPath the location of the root within the source archive
-	 *    or <code>null</code> if <code>archivePath</code> is also <code>null</code>. This is ignored
-	 *    if the source is in a folder.
+	 * @param sourceAttachmentRootPath the location of the root within the source archive or folder
+	 *    or <code>null</code> if <code>sourceAttachmentPath</code> is also <code>null</code>.
 	 * @return a new library classpath entry
 	 * 
 	 * @see #newLibraryEntry(IPath, IPath, IPath, boolean)
@@ -1922,9 +1921,8 @@ public final class JavaCore extends Plugin implements IExecutableExtension {
 	 * @param path the absolute path of the binary archive
 	 * @param sourceAttachmentPath the absolute path of the corresponding source archive or folder, 
 	 *    or <code>null</code> if none
-	 * @param sourceAttachmentRootPath the location of the root within the source archive
-	 *    or <code>null</code> if <code>archivePath</code> is also <code>null</code>. This is ignored
-	 *    if the source is in a folder.
+	 * @param sourceAttachmentRootPath the location of the root within the source archive or folder
+	 *    or <code>null</code> if <code>sourceAttachmentPath</code> is also <code>null</code>.
 	 * @param isExported indicates whether this entry is contributed to dependent
 	 * 	  projects in addition to the output location
 	 * @return a new library classpath entry
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMember.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMember.java
index 36e894d..bf7f613 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMember.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryMember.java
@@ -35,9 +35,12 @@ public void copy(IJavaElement container, IJavaElement sibling, String rename, bo
 /**
  * @see ISourceReference
  */
-public ISourceRange getNameRange() {
+public ISourceRange getNameRange() throws JavaModelException {
 	SourceMapper mapper= getSourceMapper();
 	if (mapper != null) {
+		// ensure the class file's buffer is open so that source ranges are computed
+		((ClassFile)getClassFile()).getBuffer();
+		
 		return mapper.getNameRange(this);
 	} else {
 		return SourceMapper.fgUnknownRange;
@@ -49,6 +52,9 @@ public ISourceRange getNameRange() {
 public ISourceRange getSourceRange() throws JavaModelException {
 	SourceMapper mapper= getSourceMapper();
 	if (mapper != null) {
+		// ensure the class file's buffer is open so that source ranges are computed
+		((ClassFile)getClassFile()).getBuffer();
+
 		return mapper.getSourceRange(this);
 	} else {
 		return SourceMapper.fgUnknownRange;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index 4dad340..36074a9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -240,6 +240,9 @@ public IJavaElement getElementAt(int position) throws JavaModelException {
 	if (mapper == null) {
 		return null;
 	} else {
+		// ensure this class file's buffer is open so that source ranges are computed
+		getBuffer();
+
 		IType type = getType();
 		return findElement(type, position, mapper);
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
index 55ec698..4fc15e4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClasspathEntry.java
@@ -220,14 +220,14 @@ public class ClasspathEntry implements IClasspathEntry {
 			path = projectPath.append(path);
 		}
 		// source attachment info (optional)
-		String sourceAttachmentPathStr = element.getAttribute("sourcepath");	//$NON-NLS-1$
-		IPath sourceAttachmentPath =
-			sourceAttachmentPathStr.equals("") ? null : new Path(sourceAttachmentPathStr); //$NON-NLS-1$
-		String sourceAttachmentRootPathStr = element.getAttribute("rootpath"); //$NON-NLS-1$
-		IPath sourceAttachmentRootPath =
-			sourceAttachmentRootPathStr.equals("") //$NON-NLS-1$
-				? null
-				: new Path(sourceAttachmentRootPathStr);
+		IPath sourceAttachmentPath = 
+			element.hasAttribute("sourcepath")	//$NON-NLS-1$
+			? new Path(element.getAttribute("sourcepath")) //$NON-NLS-1$
+			: null;
+		IPath sourceAttachmentRootPath = 
+			element.hasAttribute("rootpath") //$NON-NLS-1$
+			? new Path(element.getAttribute("rootpath")) //$NON-NLS-1$
+			: null;
 		
 		// exported flag (optional)
 		boolean isExported = element.getAttribute("exported").equals("true"); //$NON-NLS-1$ //$NON-NLS-2$
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
index 44f9b29..38795e4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java
@@ -431,7 +431,9 @@ public class DeltaProcessor implements IResourceChangeListener {
 				try {
 					// close the root so that source attachement cache is flushed
 					root = projectOfRoot.findPackageFragmentRoot(rootPath);
-					root.close();
+					if (root != null) {
+						root.close();
+					}
 				} catch (JavaModelException e) {
 				}
 				if (root == null) return;
@@ -1058,8 +1060,7 @@ public class DeltaProcessor implements IResourceChangeListener {
 				IPath sourceAttachmentPath;
 				if (propertyString != null) {
 					int index= propertyString.lastIndexOf(JarPackageFragmentRoot.ATTACHMENT_PROPERTY_DELIMITER);
-					if (index < 0) continue;
-					sourceAttachmentPath = new Path(propertyString.substring(0, index));
+					sourceAttachmentPath = (index < 0) ?  new Path(propertyString) : new Path(propertyString.substring(0, index));
 				} else {
 					sourceAttachmentPath = entry.getSourceAttachmentPath();
 				}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
index 44f942a..e811c3e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
@@ -61,19 +61,7 @@ public class JarPackageFragmentRoot extends PackageFragmentRoot {
 		super(resource, project);
 		this.jarPath = resource.getFullPath();
 	}
-	/**
-	 * Close the associated JAR file stored in the info of this element. If
-	 * this jar has an associated ZIP source attachment, close it too.
-	 *
-	 * @see IOpenable
-	 */
-	protected void closing(Object info) throws JavaModelException {
-		SourceMapper mapper= getSourceMapper();
-		if (mapper != null) {
-			mapper.close();
-		}
-		super.closing(info);
-	}
+
 	/**
 	 * Compute the package fragment children of this package fragment root.
 	 * These are all of the directory zip entries, and any directories implied
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index b669730..e14e833 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -104,7 +104,7 @@ public void attachSource(IPath sourcePath, IPath rootPath, IProgressMonitor moni
 				monitor.worked(1);
 			}
 			if (storedSourcePath != null) {
-				if (!(storedSourcePath.equals(sourcePath) && rootPath.equals(storedRootPath))) {
+				if (!(storedSourcePath.equals(sourcePath) && (rootPath != null && rootPath.equals(storedRootPath)) || storedRootPath == null)) {
 					rootNeedsToBeClosed= true;
 				}
 			}
@@ -118,15 +118,21 @@ public void attachSource(IPath sourcePath, IPath rootPath, IProgressMonitor moni
 			}
 			mapper= new SourceMapper(
 				sourcePath, 
-				rootPath.toOSString(), 
+				rootPath == null ? null : rootPath.toOSString(), 
 				this.isExternal() ? JavaCore.getOptions() : this.getJavaProject().getOptions(true)); // only project options if associated with resource
+			if (rootPath == null && mapper.rootPath != null) {
+				// as a side effect of calling the SourceMapper constructor, the root path was computed
+				rootPath = new Path(mapper.rootPath);
+			}
 		}
 		setSourceMapper(mapper);
 		if (sourcePath == null) {
 			setSourceAttachmentProperty(null); //remove the property
 		} else {
 			//set the property to the path of the mapped source
-			setSourceAttachmentProperty(sourcePath.toString() + ATTACHMENT_PROPERTY_DELIMITER + rootPath.toString());
+			setSourceAttachmentProperty(
+				sourcePath.toString() 
+				+ (rootPath == null ? "" : (ATTACHMENT_PROPERTY_DELIMITER + rootPath.toString()))); //$NON-NLS-1$
 		}
 		if (rootNeedsToBeClosed) {
 			if (oldMapper != null) {
@@ -154,6 +160,19 @@ public void attachSource(IPath sourcePath, IPath rootPath, IProgressMonitor moni
 		}
 	}
 }
+/**
+ * This root is being closed.  If this root has an associated source attachment, 
+ * close it too.
+ *
+ * @see JavaElement
+ */
+protected void closing(Object info) throws JavaModelException {
+	SourceMapper mapper= getSourceMapper();
+	if (mapper != null) {
+		mapper.close();
+	}
+	super.closing(info);
+}
 
 /**
  * Compute the package fragment children of this package fragment root.
@@ -496,9 +515,13 @@ public IPath getSourceAttachmentPath() throws JavaModelException {
 		return null;
 	}
 	int index= serverPathString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER);
-	if (index < 0) return null;
-	String serverSourcePathString= serverPathString.substring(0, index);
-	return new Path(serverSourcePathString);
+	if (index < 0) {
+		// no root path specified
+		return new Path(serverPathString);
+	} else {
+		String serverSourcePathString= serverPathString.substring(0, index);
+		return new Path(serverSourcePathString);
+	}
 }
 
 /**
@@ -512,12 +535,15 @@ protected String getSourceAttachmentProperty() throws JavaModelException {
 		propertyString = getWorkspace().getRoot().getPersistentProperty(qName);
 		
 		// if no existing source attachment information, then lookup a recommendation from classpath entries
-		if (propertyString == null || propertyString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER) < 0){
+		if (propertyString == null) {
 			IClasspathEntry recommendation = findSourceAttachmentRecommendation();
-			if (recommendation != null){
-				propertyString = recommendation.getSourceAttachmentPath().toString() 
-									+ ATTACHMENT_PROPERTY_DELIMITER 
-									+ (recommendation.getSourceAttachmentRootPath() == null ? "" : recommendation.getSourceAttachmentRootPath().toString()); //$NON-NLS-1$
+			if (recommendation != null) {
+				IPath rootPath = recommendation.getSourceAttachmentRootPath();
+				propertyString = 
+					recommendation.getSourceAttachmentPath().toString() 
+						+ ((rootPath == null) 
+							? "" : //$NON-NLS-1$
+							(ATTACHMENT_PROPERTY_DELIMITER + rootPath.toString())); 
 				setSourceAttachmentProperty(propertyString);
 			}
 		}
@@ -527,7 +553,15 @@ protected String getSourceAttachmentProperty() throws JavaModelException {
 	}
 }
 	
-public void setSourceAttachmentProperty(String property){
+/**
+ * Returns the qualified name for the source attachment property
+ * of this root.
+ */
+protected QualifiedName getSourceAttachmentPropertyName() throws JavaModelException {
+	return new QualifiedName(JavaCore.PLUGIN_ID, "sourceattachment: " + this.getPath().toOSString()); //$NON-NLS-1$
+}
+
+public void setSourceAttachmentProperty(String property) {
 	try {
 		getWorkspace().getRoot().setPersistentProperty(this.getSourceAttachmentPropertyName(), property);
 	} catch (CoreException ce) {
@@ -542,13 +576,7 @@ public void setSourceMapper(SourceMapper mapper) throws JavaModelException {
 	((PackageFragmentRootInfo) getElementInfo()).setSourceMapper(mapper);
 }
 
-/**
- * Returns the qualified name for the source attachment property
- * of this root.
- */
-protected QualifiedName getSourceAttachmentPropertyName() throws JavaModelException {
-	return new QualifiedName(JavaCore.PLUGIN_ID, "sourceattachment: " + this.getPath().toOSString()); //$NON-NLS-1$
-}
+
 
 /**
  * @see IPackageFragmentRoot
@@ -560,7 +588,8 @@ public IPath getSourceAttachmentRootPath() throws JavaModelException {
 	if (serverPathString == null) {
 		return null;
 	}
-	int index= serverPathString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER);
+	int index = serverPathString.lastIndexOf(ATTACHMENT_PROPERTY_DELIMITER);
+	if (index == -1) return null;
 	String serverRootPathString= IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH;
 	if (index != serverPathString.length() - 1) {
 		serverRootPathString= serverPathString.substring(index + 1);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SetClasspathOperation.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SetClasspathOperation.java
index 673c6eb..a550a09 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SetClasspathOperation.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SetClasspathOperation.java
@@ -100,9 +100,7 @@ public class SetClasspathOperation extends JavaModelOperation {
 				} catch (JavaModelException e) {
 				}
 				// force detach source on jar package fragment roots (source will be lazily computed when needed)
-				if (root instanceof JarPackageFragmentRoot) {
-					((JarPackageFragmentRoot) root).setSourceAttachmentProperty(null);// loose info - will be recomputed
-				}
+				((PackageFragmentRoot) root).setSourceAttachmentProperty(null);// loose info - will be recomputed
 			}
 		}
 	}
@@ -349,14 +347,17 @@ public class SetClasspathOperation extends JavaModelOperation {
 				}
 				
 				// check source attachment
+				IPath newSourcePath = newResolvedPath[index].getSourceAttachmentPath();
 				int sourceAttachmentFlags = 
 					this.getSourceAttachmentDeltaFlag(
 						oldResolvedPath[i].getSourceAttachmentPath(),
-						newResolvedPath[index].getSourceAttachmentPath());
+						newSourcePath,
+						null/*not a source root path*/);
 				int sourceAttachmentRootFlags = 
 					this.getSourceAttachmentDeltaFlag(
 						oldResolvedPath[i].getSourceAttachmentRootPath(),
-						newResolvedPath[index].getSourceAttachmentRootPath());
+						newResolvedPath[index].getSourceAttachmentRootPath(),
+						newSourcePath/*in case both root paths are null*/);
 				int flags = sourceAttachmentFlags | sourceAttachmentRootFlags;
 				if (flags != 0) {
 					addClasspathDeltas(
@@ -449,12 +450,17 @@ public class SetClasspathOperation extends JavaModelOperation {
 	 * Returns either F_SOURCEATTACHED, F_SOURCEDETACHED, F_SOURCEATTACHED | F_SOURCEDETACHED
 	 * or 0 if there is no difference.
 	 */
-	private int getSourceAttachmentDeltaFlag(IPath oldPath, IPath newPath) {
+	private int getSourceAttachmentDeltaFlag(IPath oldPath, IPath newPath, IPath sourcePath) {
 		if (oldPath == null) {
 			if (newPath != null) {
 				return IJavaElementDelta.F_SOURCEATTACHED;
 			} else {
-				return 0;
+				if (sourcePath != null) {
+					// if source path is specified and no root path, it needs to be recomputed dynamically
+					return IJavaElementDelta.F_SOURCEATTACHED | IJavaElementDelta.F_SOURCEDETACHED;
+				} else {
+					return 0;
+				}
 			}
 		} else if (newPath == null) {
 			return IJavaElementDelta.F_SOURCEDETACHED;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
index 20633eb..beb3b57 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceMapper.java
@@ -12,6 +12,7 @@ package org.eclipse.jdt.internal.core;
 
 import java.io.File;
 import java.io.IOException;
+import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.zip.ZipEntry;
@@ -26,12 +27,16 @@ import org.eclipse.core.runtime.IPath;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.*;
 import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.internal.compiler.*;
 import org.eclipse.jdt.internal.compiler.IProblemFactory;
 import org.eclipse.jdt.internal.compiler.ISourceElementRequestor;
 import org.eclipse.jdt.internal.compiler.SourceElementParser;
+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.parser.Parser;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.compiler.util.Util;
 import org.eclipse.jdt.internal.core.util.ReferenceInfoAdapter;
 
@@ -150,18 +155,23 @@ public class SourceMapper
 	 * at the given location in the specified package fragment root.
 	 */
 	public SourceMapper(IPath sourcePath, String rootPath, Map options) {
+		this.options = options;
+		this.encoding = (String)options.get(JavaCore.CORE_ENCODING);
 		this.sourcePath = sourcePath;
-		rootPath = rootPath.replace('\\', '/');
-		if (rootPath.endsWith("/" )) { //$NON-NLS-1$
-			rootPath =rootPath.substring(0, rootPath.lastIndexOf('/'));
+		if (rootPath == null) {
+			rootPath = this.computeRootPath();
+		}
+		if (rootPath != null) {
+			rootPath = rootPath.replace('\\', '/');
+			if (rootPath.endsWith("/" )) { //$NON-NLS-1$
+				rootPath = rootPath.substring(0, rootPath.lastIndexOf('/'));
+			}
 		}
 		this.rootPath = rootPath;
 		this.fSourceRanges = new HashMap();
 		this.fParameterNames = new HashMap();
 		this.importsTable = new HashMap();
 		this.importsCounterTable = new HashMap();
-		this.options = options;
-		this.encoding = (String)options.get(JavaCore.CORE_ENCODING);
 	}
 	
 	/**
@@ -256,6 +266,110 @@ public class SourceMapper
 		}
 		return typeSigs;
 	}
+	/*
+	 * Computes the root path by scanning the first .java file in this source archive or folder.
+	 * Returns null if could not compute the root path.
+	 */
+	private String computeRootPath() {
+		if (Util.isArchiveFileName(this.sourcePath.lastSegment())) {
+			JavaModelManager manager = JavaModelManager.getJavaModelManager();
+			ZipFile zip = null;
+			try {
+				zip = manager.getZipFile(this.sourcePath);
+				for (Enumeration entries = zip.entries(); entries.hasMoreElements(); ) {
+					ZipEntry entry = (ZipEntry) entries.nextElement();
+					String name;
+					if (!entry.isDirectory() && Util.isJavaFileName(name = entry.getName())) {
+						char[] contents = this.readSource(entry, zip);
+						String rootPath = computeRootPath(name, contents);
+						if (rootPath != null) {
+							return rootPath;
+						}
+					}
+				}
+				return null;
+			} catch (CoreException e) {
+				return null;
+			} finally {
+				manager.closeZipFile(zip); // handle null case
+			}
+		} else {
+			Object target = JavaModel.getTarget(ResourcesPlugin.getWorkspace().getRoot(), this.sourcePath, true);
+			if (target instanceof IFolder) {
+				IFolder folder = (IFolder)target;
+				final String[] rootPathHolder = new String[1];
+				try {
+					folder.accept(new IResourceVisitor() {
+						public boolean visit(IResource resource) throws CoreException {
+							if (resource instanceof IFile && Util.isJavaFileName(resource.getName())) {
+								char[] contents = org.eclipse.jdt.internal.core.Util.getResourceContentsAsCharArray((IFile)resource, encoding);
+								IPath fullPath = resource.getFullPath();
+								int sourcePathSegmentCount = sourcePath.segmentCount();
+								IPath javaFilePath = fullPath.removeFirstSegments(sourcePathSegmentCount);
+								String rootPath = computeRootPath(javaFilePath.toString(), contents);
+								if (rootPath != null) {
+									rootPathHolder[0] = rootPath;
+									throw new CoreException(new JavaModelStatus()); // abort visit
+								}
+							}
+							return true;
+						}
+					});
+				} catch (CoreException e) {
+				}
+				if (rootPathHolder[0] != null) {
+					return rootPathHolder[0];
+				}
+			} else if (target instanceof File) {
+				File file = (File)target;
+				if (file.isDirectory()) {
+					// TODO: Traverse directory
+				}
+			}
+		}
+		return null;
+	}
+
+	/*
+	 * Compute the root path from the given javaFilePath by extracting the package declaration
+	 * from its contents. The javaFilePath is the relative path (/ separated and relative to the source path) to the .java file.
+	 */
+	String computeRootPath(String javaFilePath, char[] contents) {
+		IErrorHandlingPolicy policy =
+			new IErrorHandlingPolicy() {
+					public boolean stopOnFirstError() {
+						return false;
+					}
+					public boolean proceedOnErrors() {
+						return true;
+					}
+				};						
+		ProblemReporter reporter = new ProblemReporter(policy, new CompilerOptions(this.options), new DefaultProblemFactory());
+		Parser parser = new Parser(reporter, false, false);
+		org.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = 
+			new BasicCompilationUnit(contents, null, javaFilePath, this.encoding);
+		CompilationResult unitResult = new CompilationResult(sourceUnit, 0, 1, 0); 
+		CompilationUnitDeclaration unit = parser.dietParse(sourceUnit, unitResult);
+		if (unit != null && unit.currentPackage != null && unit.currentPackage.tokens != null) {
+			String packagePath = new String(CharOperation.concatWith(unit.currentPackage.tokens, '/'));
+			if (packagePath != null) {
+				if (packagePath.length() == 0) {
+					int lastSlash = javaFilePath.lastIndexOf('/');
+					if (lastSlash > 0) {
+						return javaFilePath.substring(0, lastSlash-1);
+					} else {
+						return javaFilePath;
+					}
+				} else {
+					int index = javaFilePath.indexOf(packagePath);
+					if (index != -1) {
+						return javaFilePath.substring(0, index);
+					}
+				}
+			}
+		}
+		return null;
+	}
 	
 	/**
 	 * @see ISourceElementRequestor
@@ -583,8 +697,7 @@ public class SourceMapper
 		}
 
 		String fullName;
-		//add the root path if specified
-		if (!this.rootPath.equals(IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH)) {
+		if (this.rootPath != null && !this.rootPath.equals(IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH)) {
 			fullName = this.rootPath + '/' + name;
 		} else {
 			fullName = name;
@@ -595,28 +708,18 @@ public class SourceMapper
 			// try to get the entry
 			ZipEntry entry = null;
 			ZipFile zip = null;
+			JavaModelManager manager = JavaModelManager.getJavaModelManager();
 			try {
-				zip = getZip();
+				zip = manager.getZipFile(this.sourcePath);
 				entry = zip.getEntry(fullName);
 				if (entry != null) {
 					// now read the source code
-					byte[] bytes = null;
-					try {
-						bytes = Util.getZipEntryByteContent(entry, zip);
-					} catch (IOException e) {
-					}
-					if (bytes != null) {
-						try {
-							source = Util.bytesToChar(bytes, this.encoding);
-						} catch (IOException e) {
-							source = null;
-						}
-					}
+					source = readSource(entry, zip);
 				}
 			} catch (CoreException e) {
 				return null;
 			} finally {
-				JavaModelManager.getJavaModelManager().closeZipFile(zip);
+				manager.closeZipFile(zip); // handle null case
 			}
 		} else {
 			Object target = JavaModel.getTarget(ResourcesPlugin.getWorkspace().getRoot(), this.sourcePath, true);
@@ -642,6 +745,8 @@ public class SourceMapper
 		}
 		return source;
 	}
+
+
 	
 	/**
 	 * Returns the SourceRange for the name of the given element, or
@@ -761,14 +866,7 @@ public class SourceMapper
 		}
 		return result;
 	}
-	
-	/**
-	 * Returns the <code>ZipFile</code> that source is located in.
-	 */
-	public ZipFile getZip() throws CoreException {
-		return JavaModelManager.getJavaModelManager().getZipFile(this.sourcePath);
-	}
-	
+		
 	/**
 	 * Maps the given source code to the given binary type and its children.
 	 */
@@ -849,6 +947,16 @@ public class SourceMapper
 			this.typeDepth = -1;
 		}
 	}
+	private char[] readSource(ZipEntry entry, ZipFile zip) {
+		try {
+			byte[] bytes = Util.getZipEntryByteContent(entry, zip);
+			if (bytes != null) {
+				return Util.bytesToChar(bytes, this.encoding);
+			}
+		} catch (IOException e) {
+		}
+		return null;
+	}	
 	
 	/** 
 	 * Sets the mapping for this method to its parameter names.
