commit 562bd70d52b78a80d9ea0f036f9a91cfb91468db
Author: Ayushman Jain <ajain>
Date:   Tue Feb 28 21:40:06 2012 +0530

    Fixed bug 127575: Null reference checks don't handle Assert

12	7	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
209	61	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
712	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
1	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
1	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
1	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
38	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
0	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
1	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
48	79	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
29	31	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
1	17	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
52	89	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
1	65	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
17	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index e8f37f6..030f0fd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -11182,8 +11182,8 @@ public void test292_warn_options() {
 
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=325342
 // -warn option - regression tests to check option includeAssertNull
-// No null problems arising from asserts should be reported here
-// since includeAssertNull is not enabled
+// Null problems arising from asserts should be reported here
+// since includeAssertNull is enabled
 public void test293_warn_options() {
 	this.runConformTest(
 		new String[] {
@@ -11227,22 +11227,27 @@ public void test293_warn_options() {
 		"	    ^\n" + 
 		"Null comparison always yields false: The variable a can only be null at this location\n" + 
 		"----------\n" + 
-		"2. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 10)\n" + 
+		"2. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 9)\n" + 
+		"	a = null;\n" + 
+		"	^\n" + 
+		"Redundant assignment: The variable a can only be null at this location\n" + 
+		"----------\n" + 
+		"3. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 10)\n" + 
 		"	if (a== null) {}\n" + 
 		"	    ^\n" + 
 		"Redundant null check: The variable a can only be null at this location\n" + 
 		"----------\n" + 
-		"3. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 12)\n" + 
+		"4. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 12)\n" + 
 		"	if (b!=null) {\n" + 
 		"	    ^\n" + 
 		"Redundant null check: The variable b cannot be null at this location\n" + 
 		"----------\n" + 
-		"4. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 18)\n" + 
+		"5. WARNING in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 18)\n" + 
 		"	if (c.equals(a)) {\n" + 
-		"	    ^\n" +  
+		"	    ^\n" + 
 		"Null pointer access: The variable c can only be null at this location\n" + 
 		"----------\n" + 
-		"4 problems (4 warnings)", 
+		"5 problems (5 warnings)", 
 		true);
 }
 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index e24388f..4cb768e 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -49,7 +49,7 @@ public NullReferenceTest(String name) {
 // Only the highest compliance level is run; add the VM argument
 // -Dcompliance=1.4 (for example) to lower it if needed
 static {
-//		TESTS_NAMES = new String[] { "testBug360328" };
+//		TESTS_NAMES = new String[] { "testBug336428f" };
 //		TESTS_NUMBERS = new int[] { 561 };
 //		TESTS_RANGE = new int[] { 1, 2049 };
 }
@@ -8574,16 +8574,21 @@ public void test0953_assert_combined() {
 				"    if (o2 == null) { };\n" + 		// complain
 				"  }\n" +
 				"}\n"},
-			"----------\n" +
-			"1. ERROR in X.java (at line 4)\n" +
-			"	if (o1 == null) { };\n" +
-			"	    ^^\n" +
-			"Null comparison always yields false: The variable o1 cannot be null at this location\n" +
-			"----------\n" +
-			"2. ERROR in X.java (at line 5)\n" +
-			"	if (o2 == null) { };\n" +
-			"	    ^^\n" +
-			"Redundant null check: The variable o2 can only be null at this location\n" +
+			"----------\n" + 
+			"1. ERROR in X.java (at line 4)\n" + 
+			"	if (o1 == null) { };\n" + 
+			"	    ^^\n" + 
+			"Null comparison always yields false: The variable o1 cannot be null at this location\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 4)\n" + 
+			"	if (o1 == null) { };\n" + 
+			"	                ^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 5)\n" + 
+			"	if (o2 == null) { };\n" + 
+			"	    ^^\n" + 
+			"Redundant null check: The variable o2 can only be null at this location\n" + 
 			"----------\n",
 		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
@@ -8624,11 +8629,16 @@ public void test0955_assert_combined() {
 				"    if (o == null) { };\n" + 		// complain
 				"  }\n" +
 				"}\n"},
-		"----------\n" +
-		"1. ERROR in X.java (at line 4)\n" +
-		"	if (o == null) { };\n" +
-		"	    ^\n" +
-		"Null comparison always yields false: The variable o cannot be null at this location\n" +
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	if (o == null) { };\n" + 
+		"	    ^\n" + 
+		"Null comparison always yields false: The variable o cannot be null at this location\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	if (o == null) { };\n" + 
+		"	               ^^^\n" + 
+		"Dead code\n" + 
 		"----------\n",
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
@@ -8644,22 +8654,32 @@ public void test0956_assert_combined() {
 				"public class X {\n" +
 				"  void foo() {\n" +
 				"    Object o = null;\n" +
-				"    assert(o != null);\n" +    // don't complain
+				"    assert(o != null);\n" +    // complain
 				"    if (o == null) { };\n" +   // complain
 				"  }\n" +
 				"}\n"},
-		"----------\n" +
-		"1. ERROR in X.java (at line 5)\n" +
-		"	if (o == null) { };\n" +
-		"	    ^\n" +
-		"Null comparison always yields false: The variable o cannot be null at this location\n" +
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	assert(o != null);\n" + 
+		"	       ^\n" + 
+		"Null comparison always yields false: The variable o can only be null at this location\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	if (o == null) { };\n" + 
+		"	    ^\n" + 
+		"Null comparison always yields false: The variable o cannot be null at this location\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 5)\n" + 
+		"	if (o == null) { };\n" + 
+		"	               ^^^\n" + 
+		"Dead code\n" + 
 		"----------\n",
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
 }
 
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=250056
-// Test to verify that asserts are exempted from null comparison warnings,
+// Test to verify that asserts are exempted from redundant null check warnings,
 // but this doesn't affect the downstream info.
 public void test0957_assert() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_4) {
@@ -8682,26 +8702,46 @@ public void test0957_assert() {
 				"	 if (bar2 == null) {}\n" +
 				"  }\n" +
 				"}\n"},
-		"----------\n" +
+		"----------\n" + 
 		"1. ERROR in X.java (at line 5)\n" + 
 		"	if (foo == null) {}\n" + 
 		"	    ^^^\n" + 
 		"Null comparison always yields false: The variable foo cannot be null at this location\n" + 
-		"----------\n" +  
-		"2. ERROR in X.java (at line 8)\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 5)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	                 ^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	assert (foo2 == null);\n" + 
+		"	        ^^^^\n" + 
+		"Null comparison always yields false: The variable foo2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 8)\n" + 
 		"	if (foo2 == null) {}\n" + 
 		"	    ^^^^\n" + 
 		"Redundant null check: The variable foo2 can only be null at this location\n" + 
 		"----------\n" + 
-		"3. ERROR in X.java (at line 11)\n" + 
+		"5. ERROR in X.java (at line 11)\n" + 
 		"	if (bar == null) {}\n" + 
 		"	    ^^^\n" + 
 		"Redundant null check: The variable bar can only be null at this location\n" + 
 		"----------\n" + 
-		"4. ERROR in X.java (at line 14)\n" + 
+		"6. ERROR in X.java (at line 13)\n" + 
+		"	assert (bar2 != null);\n" + 
+		"	        ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 can only be null at this location\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 14)\n" + 
 		"	if (bar2 == null) {}\n" + 
 		"	    ^^^^\n" + 
 		"Null comparison always yields false: The variable bar2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"8. WARNING in X.java (at line 14)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	                  ^^\n" + 
+		"Dead code\n" + 
 		"----------\n",
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
@@ -8746,7 +8786,7 @@ public void test0958_assert() {
 }
 
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=250056
-// Test to verify that asserts are exempted from null comparison warnings in a looping context,
+// Test to verify that asserts are exempted from redundant null check warnings in a looping context,
 // but this doesn't affect the downstream info.
 public void test0959a_assert_loop() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_4) {
@@ -8771,33 +8811,53 @@ public void test0959a_assert_loop() {
 				"	 }\n" +
 				"  }\n" +
 				"}\n"},
-		"----------\n" +
+		"----------\n" + 
 		"1. ERROR in X.java (at line 9)\n" + 
 		"	if (foo == null) {}\n" + 
 		"	    ^^^\n" + 
 		"Null comparison always yields false: The variable foo cannot be null at this location\n" + 
 		"----------\n" + 
-		"2. ERROR in X.java (at line 11)\n" + 
+		"2. WARNING in X.java (at line 9)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	                 ^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 10)\n" + 
+		"	assert (foo2 == null);\n" + 
+		"	        ^^^^\n" + 
+		"Null comparison always yields false: The variable foo2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 11)\n" + 
 		"	if (foo2 == null) {}\n" + 
 		"	    ^^^^\n" + 
 		"Redundant null check: The variable foo2 can only be null at this location\n" + 
 		"----------\n" + 
-		"3. ERROR in X.java (at line 13)\n" + 
+		"5. ERROR in X.java (at line 13)\n" + 
 		"	if (bar == null) {}\n" + 
 		"	    ^^^\n" + 
 		"Redundant null check: The variable bar can only be null at this location\n" + 
 		"----------\n" + 
-		"4. ERROR in X.java (at line 15)\n" + 
+		"6. ERROR in X.java (at line 14)\n" + 
+		"	assert (bar2 != null);\n" + 
+		"	        ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 can only be null at this location\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 15)\n" + 
 		"	if (bar2 == null) {}\n" + 
 		"	    ^^^^\n" + 
 		"Null comparison always yields false: The variable bar2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"8. WARNING in X.java (at line 15)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	                  ^^\n" + 
+		"Dead code\n" + 
 		"----------\n",
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
 }
 
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=250056
-// Test to verify that asserts are exempted from null comparison warnings in a looping context,
+// Test to verify that asserts are exempted from redundant null check warnings in a looping context,
 // but this doesn't affect the downstream info.
 public void test0959b_assert_loop() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_4) {
@@ -8822,33 +8882,53 @@ public void test0959b_assert_loop() {
 				"	 }\n" +
 				"  }\n" +
 				"}\n"},
-		"----------\n" +
+		"----------\n" + 
 		"1. ERROR in X.java (at line 6)\n" + 
 		"	if (foo == null) {}\n" + 
 		"	    ^^^\n" + 
 		"Null comparison always yields false: The variable foo cannot be null at this location\n" + 
 		"----------\n" + 
-		"2. ERROR in X.java (at line 9)\n" + 
+		"2. WARNING in X.java (at line 6)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	                 ^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 8)\n" + 
+		"	assert (foo2 == null);\n" + 
+		"	        ^^^^\n" + 
+		"Null comparison always yields false: The variable foo2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 9)\n" + 
 		"	if (foo2 == null) {}\n" + 
 		"	    ^^^^\n" + 
 		"Redundant null check: The variable foo2 can only be null at this location\n" + 
 		"----------\n" + 
-		"3. ERROR in X.java (at line 12)\n" + 
+		"5. ERROR in X.java (at line 12)\n" + 
 		"	if (bar == null) {}\n" + 
 		"	    ^^^\n" + 
 		"Redundant null check: The variable bar can only be null at this location\n" + 
 		"----------\n" + 
-		"4. ERROR in X.java (at line 15)\n" + 
+		"6. ERROR in X.java (at line 14)\n" + 
+		"	assert (bar2 != null);\n" + 
+		"	        ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 can only be null at this location\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 15)\n" + 
 		"	if (bar2 == null) {}\n" + 
 		"	    ^^^^\n" + 
 		"Null comparison always yields false: The variable bar2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"8. WARNING in X.java (at line 15)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	                  ^^\n" + 
+		"Dead code\n" + 
 		"----------\n",
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
 }
 
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=250056
-// Test to verify that asserts are exempted from null comparison warnings in a finally context,
+// Test to verify that asserts are exempted from redundant null check warnings in a finally context,
 // but this doesn't affect the downstream info.
 public void test0960_assert_finally() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_4) {
@@ -8876,26 +8956,46 @@ public void test0960_assert_finally() {
 				"	 }\n" +
 				"  }\n" +
 				"}\n"},
-		"----------\n" +
-		"1. ERROR in X.java (at line 12)\n" +
-		"	if (foo == null) {}\n" +
-		"	    ^^^\n" +
-		"Null comparison always yields false: The variable foo cannot be null at this location\n" +
-		"----------\n" +
-		"2. ERROR in X.java (at line 14)\n" +
-		"	if (foo2 == null) {}\n" +
-		"	    ^^^^\n" +
-		"Redundant null check: The variable foo2 can only be null at this location\n" +
-		"----------\n" +
-		"3. ERROR in X.java (at line 16)\n" +
-		"	if (bar == null) {}\n" +
-		"	    ^^^\n" +
-		"Redundant null check: The variable bar can only be null at this location\n" +
-		"----------\n" +
-		"4. ERROR in X.java (at line 18)\n" +
-		"	if (bar2 == null) {}\n" +
-		"	    ^^^^\n" +
-		"Null comparison always yields false: The variable bar2 cannot be null at this location\n" +
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	    ^^^\n" + 
+		"Null comparison always yields false: The variable foo cannot be null at this location\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 12)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	                 ^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 13)\n" + 
+		"	assert (foo2 == null);\n" + 
+		"	        ^^^^\n" + 
+		"Null comparison always yields false: The variable foo2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 14)\n" + 
+		"	if (foo2 == null) {}\n" + 
+		"	    ^^^^\n" + 
+		"Redundant null check: The variable foo2 can only be null at this location\n" + 
+		"----------\n" + 
+		"5. ERROR in X.java (at line 16)\n" + 
+		"	if (bar == null) {}\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable bar can only be null at this location\n" + 
+		"----------\n" + 
+		"6. ERROR in X.java (at line 17)\n" + 
+		"	assert (bar2 != null);\n" + 
+		"	        ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 can only be null at this location\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 18)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	    ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"8. WARNING in X.java (at line 18)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	                  ^^\n" + 
+		"Dead code\n" + 
 		"----------\n",
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 	}
@@ -13798,12 +13898,26 @@ public void testBug325342b() {
 			"	    ^\n" + 
 			"Null comparison always yields false: The variable a can only be null at this location\n" + 
 			"----------\n" + 
-			"2. ERROR in Test.java (at line 10)\n" + 
+			"2. WARNING in Test.java (at line 4)\n" + 
+			"	if (a!=null) {\n" + 
+			"			System.out.println(\"a is not null\");\n" + 
+			"		 } else{\n" + 
+			"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"3. ERROR in Test.java (at line 10)\n" + 
 			"	if (b!=null) {\n" + 
 			"	    ^\n" + 
 			"Redundant null check: The variable b cannot be null at this location\n" + 
 			"----------\n" + 
-			"3. ERROR in Test.java (at line 16)\n" + 
+			"4. WARNING in Test.java (at line 12)\n" + 
+			"	} else{\n" + 
+			"			System.out.println(\"a is null\");\n" + 
+			"		 }\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"5. ERROR in Test.java (at line 16)\n" + 
 			"	if (c.equals(a)) {\n" + 
 			"	    ^\n" + 
 			"Null pointer access: The variable c can only be null at this location\n" + 
@@ -14172,6 +14286,40 @@ public void testBug336428e() {
 				"		do {\n" +
 				"           if (b1)\n" + 
 				"				o1 = null;\n" +
+				"           assert (o2 = o1) != null : \"bug\";\n" +
+				"		} while (true);\n" + 
+				"	}\n" + 
+				"}"	
+			},
+			"----------\n" + 
+			"1. ERROR in DoWhileBug.java (at line 7)\n" + 
+			"	o1 = null;\n" + 
+			"	^^\n" + 
+			"Redundant assignment: The variable o1 can only be null at this location\n" + 
+			"----------\n" +
+			"2. ERROR in DoWhileBug.java (at line 8)\n" + 
+			"	assert (o2 = o1) != null : \"bug\";\n" + 
+			"	       ^^^^^^^^^\n" + 
+			"Null comparison always yields false: The variable o2 can only be null at this location\n" + 
+			"----------\n");
+	}
+}
+
+// Bug 336428 - [compiler][null] bogus warning "redundant null check" in condition of do {} while() loop
+// same analysis, but assert instead of if suppresses the warning
+// condition inside assert is redundant null check and hence should not be warned against
+public void testBug336428f() {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
+		this.runNegativeTest(
+			new String[] {
+		"DoWhileBug.java",
+				"public class DoWhileBug {\n" + 
+				"	void test(boolean b1) {\n" + 
+				"		Object o1 = null;\n" + 
+				"		Object o2 = null;\n" + 
+				"		do {\n" +
+				"           if (b1)\n" + 
+				"				o1 = null;\n" +
 				"           assert (o2 = o1) == null : \"bug\";\n" +
 				"		} while (true);\n" + 
 				"	}\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
new file mode 100644
index 0000000..7915771
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTestAsserts.java
@@ -0,0 +1,712 @@
+/*******************************************************************************
+ * Copyright (c) 2012 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Map;
+
+import junit.framework.Test;
+
+import org.eclipse.core.runtime.FileLocator;
+import org.eclipse.core.runtime.Platform;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+
+/* See also NullReferenceTests for general null reference tests */
+public class NullReferenceTestAsserts extends AbstractRegressionTest {
+	
+// class libraries including org.eclipse.equinox.common
+String[] assertLib = null;
+public NullReferenceTestAsserts(String name) {
+	super(name);
+}
+
+// Static initializer to specify tests subset using TESTS_* static variables
+// All specified tests which does not belong to the class are skipped...
+// Only the highest compliance level is run; add the VM argument
+// -Dcompliance=1.4 (for example) to lower it if needed
+static {
+//		TESTS_NAMES = new String[] { "testBug127575o" };
+//		TESTS_NUMBERS = new int[] { 561 };
+//		TESTS_RANGE = new int[] { 1, 2049 };
+}
+
+public static Test suite() {
+	return buildAllCompliancesTestSuite(testClass());
+}
+
+public static Class testClass() {
+	return NullReferenceTestAsserts.class;
+}
+
+protected void setUp() throws Exception {
+	super.setUp();
+	if (this.assertLib == null) {
+		String[] defaultLibs = getDefaultClassPaths();
+		int len = defaultLibs.length;
+		this.assertLib = new String[len+1];
+		System.arraycopy(defaultLibs, 0, this.assertLib, 0, len);
+		File bundleFile = FileLocator.getBundleFile(Platform.getBundle("org.eclipse.equinox.common"));
+		if (bundleFile.isDirectory())
+			this.assertLib[len] = bundleFile.getPath()+"/bin";
+		else
+			this.assertLib[len] = bundleFile.getPath();
+	}
+}
+
+// Conditionally augment problem detection settings
+static boolean setNullRelatedOptions = true;
+protected Map getCompilerOptions() {
+    Map defaultOptions = super.getCompilerOptions();
+    if (setNullRelatedOptions) {
+	    defaultOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	    defaultOptions.put(CompilerOptions.OPTION_ReportPotentialNullReference, CompilerOptions.ERROR);
+	    defaultOptions.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.ERROR);
+		defaultOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
+		defaultOptions.put(CompilerOptions.OPTION_IncludeNullInfoFromAsserts, CompilerOptions.ENABLED);
+    }
+    return defaultOptions;
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+public void testBug127575a() throws IOException {
+		this.runConformTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void foo(Object o) {\n" +
+				"    boolean b = o != null;\n" + // sheds doubts upon o
+				"    org.eclipse.core.runtime.Assert.isLegal(o != null);\n" + 	// protection
+				"    o.toString();\n" + 		// quiet
+				"  }\n" +
+				"}\n"},
+			"",
+			this.assertLib,
+			false,
+			null);
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+public void testBug127575b() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void foo(Object o) {\n" +
+				"    org.eclipse.core.runtime.Assert.isLegal(o == null);\n" + 	// forces null
+				"    o.toString();\n" + 		// can only be null
+				"  }\n" +
+				"}\n"},
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	o.toString();\n" +
+		"	^\n" +
+		"Null pointer access: The variable o can only be null at this location\n" +
+		"----------\n",
+		this.assertLib,
+		true);
+}
+
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+public void testBug127575c() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void foo(Object o, boolean b) {\n" +
+				"    org.eclipse.core.runtime.Assert.isLegal(o != null || b, \"FAIL\");\n" + // shed doubts
+				"    o.toString();\n" + 		// complain
+				"  }\n" +
+				"}\n"},
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	o.toString();\n" +
+		"	^\n" +
+		"Potential null pointer access: The variable o may be null at this location\n" +
+		"----------\n",
+	    this.assertLib,
+	    true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+public void testBug127575d() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void foo(Object o1, Object o2) {\n" +
+				"    org.eclipse.core.runtime.Assert.isLegal(o1 != null && o2 == null);\n" +
+				"    if (o1 == null) { };\n" + 		// complain
+				"    if (o2 == null) { };\n" + 		// complain
+				"  }\n" +
+				"}\n"},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 4)\n" + 
+			"	if (o1 == null) { };\n" + 
+			"	    ^^\n" + 
+			"Null comparison always yields false: The variable o1 cannot be null at this location\n" + 
+			"----------\n" + 
+			"2. WARNING in X.java (at line 4)\n" + 
+			"	if (o1 == null) { };\n" + 
+			"	                ^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 5)\n" + 
+			"	if (o2 == null) { };\n" + 
+			"	    ^^\n" + 
+			"Redundant null check: The variable o2 can only be null at this location\n" + 
+			"----------\n",
+		    this.assertLib,
+		    true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+public void testBug127575e() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void foo(Object o) {\n" +
+				"    org.eclipse.core.runtime.Assert.isLegal(false && o != null);\n" +
+				"    if (o == null) { };\n" + 		// quiet
+				"  }\n" +
+				"}\n"},
+				"----------\n" + 
+				"1. WARNING in X.java (at line 3)\n" + 
+				"	org.eclipse.core.runtime.Assert.isLegal(false && o != null);\n" + 
+				"	                                                 ^^^^^^^^^\n" + 
+				"Dead code\n" + 
+				"----------\n",
+				this.assertLib, true);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+public void testBug127575e_1() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void foo(Object o) {\n" +
+				"	 o = null;\n" +
+				"    org.eclipse.core.runtime.Assert.isLegal(false && o != null);\n" +
+				"    if (o == null) { };\n" + 		// warn on o because o was null above.
+				"  }\n" +
+				"}\n"},
+				"----------\n" + 
+				"1. WARNING in X.java (at line 4)\n" + 
+				"	org.eclipse.core.runtime.Assert.isLegal(false && o != null);\n" + 
+				"	                                                 ^^^^^^^^^\n" + 
+				"Dead code\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 5)\n" + 
+				"	if (o == null) { };\n" + 
+				"	    ^\n" + 
+				"Redundant null check: The variable o can only be null at this location\n" + 
+				"----------\n",
+				this.assertLib, true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+public void testBug127575e_2() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void foo(Object o) {\n" +
+				"    org.eclipse.core.runtime.Assert.isLegal(true || o != null);\n" +
+				"    if (o == null) { };\n" + 		// quiet
+				"  }\n" +
+				"}\n"},
+				"----------\n" + 
+				"1. WARNING in X.java (at line 3)\n" + 
+				"	org.eclipse.core.runtime.Assert.isLegal(true || o != null);\n" + 
+				"	                                                ^^^^^^^^^\n" + 
+				"Dead code\n" + 
+				"----------\n",
+				this.assertLib, true);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+public void testBug127575f() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void foo(Object o) {\n" +
+				"    org.eclipse.core.runtime.Assert.isLegal(false || o != null);\n" +
+				"    if (o == null) { };\n" + 		// complain
+				"  }\n" +
+				"}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	if (o == null) { };\n" + 
+		"	    ^\n" + 
+		"Null comparison always yields false: The variable o cannot be null at this location\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 4)\n" + 
+		"	if (o == null) { };\n" + 
+		"	               ^^^\n" + 
+		"Dead code\n" + 
+		"----------\n",
+	    this.assertLib, true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+// do warn always false comparisons even inside org.eclipse.core.runtime.Assert.isLegal
+public void testBug127575g() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void foo() {\n" +
+				"    Object o = null;\n" +
+				"    org.eclipse.core.runtime.Assert.isLegal(o != null);\n" +    // don't complain
+				"    if (o == null) { };\n" +   // complain
+				"  }\n" +
+				"}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	org.eclipse.core.runtime.Assert.isLegal(o != null);\n" + 
+		"	                                        ^\n" + 
+		"Null comparison always yields false: The variable o can only be null at this location\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	if (o == null) { };\n" + 
+		"	    ^\n" + 
+		"Null comparison always yields false: The variable o cannot be null at this location\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 5)\n" + 
+		"	if (o == null) { };\n" + 
+		"	               ^^^\n" + 
+		"Dead code\n" + 
+		"----------\n",
+		this.assertLib, true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+// Test to verify that asserts are exempted from redundant null check warnings,
+// but this doesn't affect the downstream info.
+public void testBug127575h() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void m() {\n" +
+				"    X foo = new X();\n" +
+				"	 org.eclipse.core.runtime.Assert.isLegal (foo != null);\n" +	// redundant check - don't warn
+				"	 if (foo == null) {}\n" +
+				"    X foo2 = new X();\n" +
+				"	 org.eclipse.core.runtime.Assert.isLegal (foo2 == null);\n" +	// always false check - warn
+				"	 if (foo2 == null) {}\n" +
+				"    X bar = null;\n" +
+				"	 org.eclipse.core.runtime.Assert.isLegal (bar == null);\n" +	// redundant check - don't warn
+				"	 if (bar == null) {}\n" +
+				"    X bar2 = null;\n" +
+				"	 org.eclipse.core.runtime.Assert.isLegal (bar2 != null);\n" +	// always false check - warn
+				"	 if (bar2 == null) {}\n" +
+				"  }\n" +
+				"}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	    ^^^\n" + 
+		"Null comparison always yields false: The variable foo cannot be null at this location\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 5)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	                 ^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	org.eclipse.core.runtime.Assert.isLegal (foo2 == null);\n" + 
+		"	                                         ^^^^\n" + 
+		"Null comparison always yields false: The variable foo2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 8)\n" + 
+		"	if (foo2 == null) {}\n" + 
+		"	    ^^^^\n" + 
+		"Redundant null check: The variable foo2 can only be null at this location\n" + 
+		"----------\n" + 
+		"5. ERROR in X.java (at line 11)\n" + 
+		"	if (bar == null) {}\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable bar can only be null at this location\n" + 
+		"----------\n" + 
+		"6. ERROR in X.java (at line 13)\n" + 
+		"	org.eclipse.core.runtime.Assert.isLegal (bar2 != null);\n" + 
+		"	                                         ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 can only be null at this location\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 14)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	    ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"8. WARNING in X.java (at line 14)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	                  ^^\n" + 
+		"Dead code\n" + 
+		"----------\n",
+	    this.assertLib, true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+// Test to verify that asserts are exempted from redundant null check warnings,
+// but this doesn't affect the downstream info.
+public void testBug127575i() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void m() {\n" +
+				"	 X bar = null;\n" +
+				"    X foo = getX();\n" +
+				"    if (foo == null) {\n" +
+				"	 	foo = new X();\n" +
+				"	 }\n" +
+				"	 org.eclipse.core.runtime.Assert.isTrue (foo != null && bar == null);\n" +	// don't warn but do the null analysis
+				"	 if (foo != null) {}\n" +		// warn
+				"	 if (bar == null) {}\n" +		// warn
+				"  }\n" +
+				"  public X getX() { return new X();}\n" +
+				"}\n"},
+		"----------\n" +
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	if (foo != null) {}\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable foo cannot be null at this location\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 10)\n" + 
+		"	if (bar == null) {}\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable bar can only be null at this location\n" + 
+		"----------\n",
+	    this.assertLib, true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+// Test to verify that asserts are exempted from redundant null check warnings in a looping context,
+// but this doesn't affect the downstream info.
+public void testBug127575j() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void m() {\n" +
+				"    X foo = new X();\n" +
+				"    X foo2 = new X();\n" +
+				"    X bar = null;\n" +
+				"    X bar2 = null;\n" +
+				"	 while (true) {\n" +
+				"	 	org.eclipse.core.runtime.Assert.isLegal (foo != null);\n" +	//don't warn
+				"	 	if (foo == null) {}\n" +
+				"	 	org.eclipse.core.runtime.Assert.isLegal (foo2 == null);\n" +	//don't warn
+				"	 	if (foo2 == null) {}\n" +				
+				"	 	org.eclipse.core.runtime.Assert.isLegal (bar == null);\n" +	//don't warn
+				"	 	if (bar == null) {}\n" +				
+				"	 	org.eclipse.core.runtime.Assert.isLegal (bar2 != null);\n" +	//don't warn
+				"	 	if (bar2 == null) {}\n" +
+				"	 }\n" +
+				"  }\n" +
+				"}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	    ^^^\n" + 
+		"Null comparison always yields false: The variable foo cannot be null at this location\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 9)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	                 ^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 10)\n" + 
+		"	org.eclipse.core.runtime.Assert.isLegal (foo2 == null);\n" + 
+		"	                                         ^^^^\n" + 
+		"Null comparison always yields false: The variable foo2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 11)\n" + 
+		"	if (foo2 == null) {}\n" + 
+		"	    ^^^^\n" + 
+		"Redundant null check: The variable foo2 can only be null at this location\n" + 
+		"----------\n" + 
+		"5. ERROR in X.java (at line 13)\n" + 
+		"	if (bar == null) {}\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable bar can only be null at this location\n" + 
+		"----------\n" + 
+		"6. ERROR in X.java (at line 14)\n" + 
+		"	org.eclipse.core.runtime.Assert.isLegal (bar2 != null);\n" + 
+		"	                                         ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 can only be null at this location\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 15)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	    ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"8. WARNING in X.java (at line 15)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	                  ^^\n" + 
+		"Dead code\n" + 
+		"----------\n",
+	    this.assertLib, true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+// Test to verify that asserts are exempted from redundant null check warnings in a finally context,
+// but this doesn't affect the downstream info.
+public void testBug127575k() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  void m() {\n" +
+				"    X foo = new X();\n" +
+				"    X foo2 = new X();\n" +
+				"    X bar = null;\n" +
+				"    X bar2 = null;\n" +
+				"	 try {\n" +
+				"		System.out.println(\"Inside try\");\n" +
+				"	 }\n" +
+				"	 finally {\n" +
+				"	 	org.eclipse.core.runtime.Assert.isLegal (foo != null);\n" +	//don't warn
+				"	 	if (foo == null) {}\n" +
+				"	 	org.eclipse.core.runtime.Assert.isLegal (foo2 == null);\n" +	//don't warn
+				"	 	if (foo2 == null) {}\n" +				
+				"	 	org.eclipse.core.runtime.Assert.isLegal (bar == null);\n" +	//don't warn
+				"	 	if (bar == null) {}\n" +				
+				"	 	org.eclipse.core.runtime.Assert.isLegal (bar2 != null);\n" +	//don't warn
+				"	 	if (bar2 == null) {}\n" +
+				"	 }\n" +
+				"  }\n" +
+				"}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	    ^^^\n" + 
+		"Null comparison always yields false: The variable foo cannot be null at this location\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 12)\n" + 
+		"	if (foo == null) {}\n" + 
+		"	                 ^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 13)\n" + 
+		"	org.eclipse.core.runtime.Assert.isLegal (foo2 == null);\n" + 
+		"	                                         ^^^^\n" + 
+		"Null comparison always yields false: The variable foo2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 14)\n" + 
+		"	if (foo2 == null) {}\n" + 
+		"	    ^^^^\n" + 
+		"Redundant null check: The variable foo2 can only be null at this location\n" + 
+		"----------\n" + 
+		"5. ERROR in X.java (at line 16)\n" + 
+		"	if (bar == null) {}\n" + 
+		"	    ^^^\n" + 
+		"Redundant null check: The variable bar can only be null at this location\n" + 
+		"----------\n" + 
+		"6. ERROR in X.java (at line 17)\n" + 
+		"	org.eclipse.core.runtime.Assert.isLegal (bar2 != null);\n" + 
+		"	                                         ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 can only be null at this location\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 18)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	    ^^^^\n" + 
+		"Null comparison always yields false: The variable bar2 cannot be null at this location\n" + 
+		"----------\n" + 
+		"8. WARNING in X.java (at line 18)\n" + 
+		"	if (bar2 == null) {}\n" + 
+		"	                  ^^\n" + 
+		"Dead code\n" + 
+		"----------\n",
+	    this.assertLib, true);
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+// The condition of org.eclipse.core.runtime.Assert.isLegal is considered always true
+// and alters the following analysis suitably.
+public void testBug127575l() {
+		this.runNegativeTest(
+			new String[] {
+				"Test.java",
+				"public class Test {\n" +
+				"	void foo(Object a, Object b, Object c) {\n" +
+				"		org.eclipse.core.runtime.Assert.isLegal( a == null);\n " +
+				"		if (a!=null) {\n" +
+				"			System.out.println(\"a is not null\");\n" +
+				"		 } else{\n" +
+				"			System.out.println(\"a is null\");\n" +
+				"		 }\n" +
+				"		a = null;\n" +
+				"		if (a== null) {}\n" +
+				"		org.eclipse.core.runtime.Assert.isLegal(b != null);\n " +
+				"		if (b!=null) {\n" +
+				"			System.out.println(\"b is not null\");\n" +
+				"		 } else{\n" +
+				"			System.out.println(\"b is null\");\n" +
+				"		 }\n" +
+				"		org.eclipse.core.runtime.Assert.isLegal(c == null);\n" +
+				"		if (c.equals(a)) {\n" +
+				"			System.out.println(\"\");\n" +
+				"		 } else{\n" +
+				"			System.out.println(\"\");\n" +
+				"		 }\n" +
+				"	}\n" +
+				"	public static void main(String[] args){\n" +
+				"		Test test = new Test();\n" +
+				"		test.foo(null,null, null);\n" +
+				"	}\n" +
+				"}\n"},
+			"----------\n" + 
+			"1. ERROR in Test.java (at line 4)\n" + 
+			"	if (a!=null) {\n" + 
+			"	    ^\n" + 
+			"Null comparison always yields false: The variable a can only be null at this location\n" + 
+			"----------\n" + 
+			"2. WARNING in Test.java (at line 4)\n" + 
+			"	if (a!=null) {\n" + 
+			"			System.out.println(\"a is not null\");\n" + 
+			"		 } else{\n" + 
+			"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"3. ERROR in Test.java (at line 9)\n" + 
+			"	a = null;\n" + 
+			"	^\n" + 
+			"Redundant assignment: The variable a can only be null at this location\n" + 
+			"----------\n" + 
+			"4. ERROR in Test.java (at line 10)\n" + 
+			"	if (a== null) {}\n" + 
+			"	    ^\n" + 
+			"Redundant null check: The variable a can only be null at this location\n" + 
+			"----------\n" + 
+			"5. ERROR in Test.java (at line 12)\n" + 
+			"	if (b!=null) {\n" + 
+			"	    ^\n" + 
+			"Redundant null check: The variable b cannot be null at this location\n" + 
+			"----------\n" + 
+			"6. WARNING in Test.java (at line 14)\n" + 
+			"	} else{\n" + 
+			"			System.out.println(\"b is null\");\n" + 
+			"		 }\n" + 
+			"	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Dead code\n" + 
+			"----------\n" + 
+			"7. ERROR in Test.java (at line 18)\n" + 
+			"	if (c.equals(a)) {\n" + 
+			"	    ^\n" + 
+			"Null pointer access: The variable c can only be null at this location\n" + 
+			"----------\n",
+			this.assertLib, true);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+// NPE warnings should be given inside org.eclipse.core.runtime.Assert.isLegal too
+public void testBug127575m() {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
+		this.runNegativeTest(
+			new String[] {
+				"Info.java",
+				"public class Info {\n" +
+				"	public void test(Info[] infos) {\n" +
+				"		for (final Info info : infos) {\n " +
+				"			if (info != null) {\n" +
+				"				org.eclipse.core.runtime.Assert.isLegal( info.checkSomething());\n" +
+				"		 		info.doSomething();\n" +	
+				"			}\n" +
+				"		 }\n" +
+				"		for (final Info info : infos) {\n " +
+				"			if (info == null) {\n" +
+				"				org.eclipse.core.runtime.Assert.isLegal(info.checkSomething());\n" + // warn NPE
+				"		 		info.doSomething();\n" +	
+				"			}\n" +
+				"		 }\n" +
+				"	}\n" +
+				"	void doSomething()  {}\n" +
+				"	boolean checkSomething() {return true;}\n" +
+				"}\n"},
+				"----------\n" + 
+			"1. ERROR in Info.java (at line 11)\n" + 
+			"	org.eclipse.core.runtime.Assert.isLegal(info.checkSomething());\n" + 
+			"	                                        ^^^^\n" + 
+			"Null pointer access: The variable info can only be null at this location\n" + 
+			"----------\n",
+			this.assertLib,
+			true);
+	}
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+// always false comparison in Assert.isLegal in loop should be warned against
+public void testBug127575n() {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
+		this.runNegativeTest(
+			new String[] {
+		"DoWhileBug.java",
+				"public class DoWhileBug {\n" + 
+				"	void test(boolean b1) {\n" + 
+				"		Object o1 = null;\n" + 
+				"		Object o2 = null;\n" + 
+				"		do {\n" +
+				"           if (b1)\n" + 
+				"				o1 = null;\n" +
+				"           org.eclipse.core.runtime.Assert.isLegal ((o2 = o1) != null);\n" +
+				"		} while (true);\n" + 
+				"	}\n" + 
+				"}"	
+			},
+			"----------\n" + 
+			"1. ERROR in DoWhileBug.java (at line 7)\n" + 
+			"	o1 = null;\n" + 
+			"	^^\n" + 
+			"Redundant assignment: The variable o1 can only be null at this location\n" + 
+			"----------\n" + 
+			"2. ERROR in DoWhileBug.java (at line 8)\n" + 
+			"	org.eclipse.core.runtime.Assert.isLegal ((o2 = o1) != null);\n" + 
+			"	                                         ^^^^^^^^^\n" + 
+			"Null comparison always yields false: The variable o2 can only be null at this location\n" + 
+			"----------\n",
+			this.assertLib,
+			true);
+	}
+}
+
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=127575
+// "redundant null check" in Assert.isLegal in loop should not be warned against
+public void testBug127575o() {
+	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
+		this.runNegativeTest(
+			new String[] {
+		"DoWhileBug.java",
+				"public class DoWhileBug {\n" + 
+				"	void test(boolean b1) {\n" + 
+				"		Object o1 = null;\n" + 
+				"		Object o2 = null;\n" + 
+				"		do {\n" +
+				"           if (b1)\n" + 
+				"				o1 = null;\n" +
+				"           org.eclipse.core.runtime.Assert.isLegal ((o2 = o1) == null);\n" +
+				"		} while (true);\n" + 
+				"	}\n" + 
+				"}"	
+			},
+			"----------\n" + 
+			"1. ERROR in DoWhileBug.java (at line 7)\n" + 
+			"	o1 = null;\n" + 
+			"	^^\n" + 
+			"Redundant assignment: The variable o1 can only be null at this location\n" + 
+			"----------\n",
+			this.assertLib,
+			true);
+	}
+}
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index 5f2f3d8..b085b02 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -63,6 +63,7 @@ public static Test suite() {
 	standardTests.add(RuntimeTests.class);
 	standardTests.add(DebugAttributeTest.class);
 	standardTests.add(NullReferenceTest.class);
+	standardTests.add(NullReferenceTestAsserts.class);
 	if (UnconditionalFlowInfo.COVERAGE_TEST_FLAG) {
 		standardTests.add(NullReferenceImplTests.class);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 9763111..0a1d870 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -62,18 +62,12 @@ public class EqualExpression extends BinaryExpression {
 					initsWhenTrue.markAsComparedEqualToNonNull(local); // from thereon it is set
 					initsWhenFalse.markAsComparedEqualToNull(local); // from thereon it is set
 				}
-				if ((flowContext.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0) {
-					flowInfo.markedAsNullOrNonNullInAssertExpression(local);
-				}
 				break;
 			case FlowInfo.NON_NULL :
 				if (((this.bits & OperatorMASK) >> OperatorSHIFT) == EQUAL_EQUAL) {
 					flowContext.recordUsingNullReference(scope, local, reference,
 							FlowContext.CAN_ONLY_NULL | FlowContext.IN_COMPARISON_NON_NULL, flowInfo);
 					initsWhenTrue.markAsComparedEqualToNonNull(local); // from thereon it is set
-					if ((flowContext.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0) {
-						initsWhenTrue.markedAsNullOrNonNullInAssertExpression(local);
-					}
 				} else {
 					flowContext.recordUsingNullReference(scope, local, reference,
 							FlowContext.CAN_ONLY_NULL | FlowContext.IN_COMPARISON_NULL, flowInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index df21615..f04641e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -534,14 +534,8 @@ public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInf
 		}
 		flowInfo.markAsComparedEqualToNonNull(local);
 			// from thereon it is set
-		if ((flowContext.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0) {
-			flowInfo.markedAsNullOrNonNullInAssertExpression(local);
-		}
 		if (flowContext.initsOnFinally != null) {
 			flowContext.initsOnFinally.markAsComparedEqualToNonNull(local);
-			if ((flowContext.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0) {
-				flowContext.initsOnFinally.markedAsNullOrNonNullInAssertExpression(local);
-			}
 		}
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
index 3382ebb..92a05a1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -37,9 +37,6 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			unconditionalInits();
 		FlowInfo initsWhenTrue = flowInfo.copy();
 		initsWhenTrue.markAsComparedEqualToNonNull(local);
-		if ((flowContext.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0) {
-			initsWhenTrue.markedAsNullOrNonNullInAssertExpression(local);
-		}
 		flowContext.recordUsingNullReference(currentScope, local,
 				this.expression, FlowContext.CAN_ONLY_NULL | FlowContext.IN_INSTANCEOF, flowInfo);
 		// no impact upon enclosing try context
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 86d0370..c8bfc23 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -24,6 +24,7 @@ import org.eclipse.jdt.internal.compiler.codegen.CodeStream;
 import org.eclipse.jdt.internal.compiler.codegen.Opcodes;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
+import org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
@@ -65,6 +66,7 @@ public class MessageSend extends Expression implements InvocationSite {
 
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
 	boolean nonStatic = !this.binding.isStatic();
+	boolean wasInsideAssert = ((flowContext.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0);
 	flowInfo = this.receiver.analyseCode(currentScope, flowContext, flowInfo, nonStatic).unconditionalInits();
 	// recording the closing of AutoCloseable resources:
 	boolean analyseResources = currentScope.compilerOptions().analyseResourceLeaks;
@@ -93,16 +95,48 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 	}
 
+	FlowInfo conditionFlowInfo;
 	if (this.arguments != null) {
 		int length = this.arguments.length;
 		for (int i = 0; i < length; i++) {
-			if ((this.arguments[i].implicitConversion & TypeIds.UNBOXING) != 0) {
-				this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
+			Expression argument = this.arguments[i];
+			if ((argument.implicitConversion & TypeIds.UNBOXING) != 0) {
+				argument.checkNPE(currentScope, flowContext, flowInfo);
+			}
+			if (this.receiver.resolvedType != null 
+					&& this.receiver.resolvedType.id == TypeIds.T_OrgEclipseCoreRuntimeAssert
+					&& argument.resolvedType != null
+					&& argument.resolvedType.id == TypeIds.T_boolean) {
+				Constant cst = argument.optimizedBooleanConstant();
+				boolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;
+				boolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;
+				flowContext.tagBits |= FlowContext.HIDE_NULL_COMPARISON_WARNING;
+				conditionFlowInfo = argument.analyseCode(currentScope, flowContext, flowInfo.copy());
+				if (!wasInsideAssert) {
+					flowContext.tagBits &= ~FlowContext.HIDE_NULL_COMPARISON_WARNING;
+				}
+				UnconditionalFlowInfo assertWhenTrueInfo = conditionFlowInfo.initsWhenTrue().unconditionalInits();
+				FlowInfo assertInfo = conditionFlowInfo.initsWhenFalse();
+				if (isOptimizedTrueAssertion) {
+					assertInfo.setReachMode(FlowInfo.UNREACHABLE_OR_DEAD);
+				}
+				if (!isOptimizedFalseAssertion) {
+					// if assertion is not false for sure, only then it makes sense to carry the flow info ahead.
+					// if the code does reach ahead, it means the assert didn't cause an exit, and so
+					// the expression inside it shouldn't change the prior flowinfo
+					// viz. org.eclipse.core.runtime.Assert.isLegal(false && o != null)
+					
+					// keep the merge from the initial code for the definite assignment
+					// analysis, tweak the null part to influence nulls downstream
+					flowInfo = flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).
+						addInitializationsFrom(assertWhenTrueInfo.discardInitializationInfo());
+				}
+			} else {
+				flowInfo = argument.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
 			}
-			flowInfo = this.arguments[i].analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
 			if (analyseResources) {
 				// if argument is an AutoCloseable insert info that it *may* be closed (by the target method, i.e.)
-				flowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo, false);
+				flowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, argument, flowInfo, false);
 			}
 		}
 		analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index 55abfba..1277227 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -241,14 +241,8 @@ public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInf
 			}
 			flowInfo.markAsComparedEqualToNonNull(local);
 			// from thereon it is set
-			if ((flowContext.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0) {
-				flowInfo.markedAsNullOrNonNullInAssertExpression(local);
-			}
 			if (flowContext.initsOnFinally != null) {
 				flowContext.initsOnFinally.markAsComparedEqualToNonNull(local);
-				if ((flowContext.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0) {
-					flowContext.initsOnFinally.markedAsNullOrNonNullInAssertExpression(local);
-				}
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
index 5cb4166..b176b9b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ConditionalFlowInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -243,16 +243,6 @@ public UnconditionalFlowInfo unconditionalInitsWithoutSideEffect() {
 			mergedWith(this.initsWhenFalse.unconditionalInits());
 }
 
-public void markedAsNullOrNonNullInAssertExpression(LocalVariableBinding local) {
-	this.initsWhenTrue.markedAsNullOrNonNullInAssertExpression(local);
-	this.initsWhenFalse.markedAsNullOrNonNullInAssertExpression(local);
-}
-
-public boolean isMarkedAsNullOrNonNullInAssertExpression(LocalVariableBinding local) {
-	return (this.initsWhenTrue.isMarkedAsNullOrNonNullInAssertExpression(local)
-		|| this.initsWhenFalse.isMarkedAsNullOrNonNullInAssertExpression(local));
-}
-
 public void resetAssignmentInfo(LocalVariableBinding local) {
 	this.initsWhenTrue.resetAssignmentInfo(local);
 	this.initsWhenFalse.resetAssignmentInfo(local);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index 76784ee..e3d740f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -91,7 +91,7 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 	// check inconsistent null checks
 	if ((this.tagBits & FlowContext.DEFER_NULL_DIAGNOSTIC) != 0) { // within an enclosing loop, be conservative
 		for (int i = 0; i < this.nullCount; i++) {
-			if (this.nullCheckTypes[i] == ASSIGN_TO_NONNULL)
+			if ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == ASSIGN_TO_NONNULL)
 				this.parent.recordNullityMismatch(scope, (Expression)this.nullReferences[i],
 						flowInfo.nullStatus(this.nullLocals[i]), this.expectedTypes[i]);
 			else
@@ -105,18 +105,16 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 			ASTNode location = this.nullReferences[i];
 			// final local variable
 			LocalVariableBinding local = this.nullLocals[i];
-			switch (this.nullCheckTypes[i]) {
+			switch (this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) {
 				case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL:
 				case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL:
 					if (flowInfo.isDefinitelyNonNull(local)) {
-						if (this.nullCheckTypes[i] == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
-							if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+						if ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
+							if ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {
 								scope.problemReporter().localVariableRedundantCheckOnNonNull(local, location);
 							}
 						} else {
-							if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-								scope.problemReporter().localVariableNonNullComparedToNull(local, location);
-							}
+							scope.problemReporter().localVariableNonNullComparedToNull(local, location);
 						}
 						continue;
 					}
@@ -129,22 +127,20 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 					if (flowInfo.isDefinitelyNull(local)) {
 						switch(this.nullCheckTypes[i] & CONTEXT_MASK) {
 							case FlowContext.IN_COMPARISON_NULL:
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariableNullReference(local, expression);
 									continue;
 								}
-								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+								if ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {
 									scope.problemReporter().localVariableRedundantCheckOnNull(local, expression);
 								}
 								continue;
 							case FlowContext.IN_COMPARISON_NON_NULL:
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariableNullReference(local, expression);
 									continue;
 								}
-								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-									scope.problemReporter().localVariableNullComparedToNonNull(local, expression);
-								}
+								scope.problemReporter().localVariableNullComparedToNonNull(local, expression);
 								continue;
 							case FlowContext.IN_ASSIGNMENT:
 								scope.problemReporter().localVariableRedundantNullAssignment(local, expression);
@@ -157,14 +153,14 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 						switch(this.nullCheckTypes[i] & CONTEXT_MASK) {
 							case FlowContext.IN_COMPARISON_NULL:
 								this.nullReferences[i] = null;
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariablePotentialNullReference(local, expression);
 									continue;
 								}
 								break;
 							case FlowContext.IN_COMPARISON_NON_NULL:
 								this.nullReferences[i] = null;
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariablePotentialNullReference(local, expression);
 									continue;
 								}
@@ -236,8 +232,11 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 	public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 			ASTNode location, int checkType, FlowInfo flowInfo) {
 		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0 && !flowInfo.isDefinitelyUnknown(local))	{
+			// if reference is being recorded inside an assert, we will not raise redundant null check warnings
+			checkType |= (this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING);
+			int checkTypeWithoutHideNullWarning = checkType & ~FlowContext.HIDE_NULL_COMPARISON_WARNING_MASK;
 			if ((this.tagBits & FlowContext.DEFER_NULL_DIAGNOSTIC) != 0) { // within an enclosing loop, be conservative
-				switch (checkType) {
+				switch (checkTypeWithoutHideNullWarning) {
 					case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL:
 					case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL:
 					case CAN_ONLY_NULL | IN_COMPARISON_NULL:
@@ -246,48 +245,36 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 					case CAN_ONLY_NULL | IN_INSTANCEOF:
 						Expression reference = (Expression) location;
 						if (flowInfo.cannotBeNull(local)) {
-							if (checkType == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
-								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+							if (checkTypeWithoutHideNullWarning == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
+								if ((checkType & HIDE_NULL_COMPARISON_WARNING) == 0) {
 									scope.problemReporter().localVariableRedundantCheckOnNonNull(local, reference);
 								}
-								if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-									flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-								}
-							} else if (checkType == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {
-								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-									scope.problemReporter().localVariableNonNullComparedToNull(local, reference);
-								}
-								if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-									flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-								}
+								flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
+							} else if (checkTypeWithoutHideNullWarning == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {
+								scope.problemReporter().localVariableNonNullComparedToNull(local, reference);
+								flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 							}
 							return;
 						}
 						if (flowInfo.canOnlyBeNull(local)) {
-							switch(checkType & CONTEXT_MASK) {
+							switch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {
 								case FlowContext.IN_COMPARISON_NULL:
-									if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+									if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 										scope.problemReporter().localVariableNullReference(local, reference);
 										return;
 									}
-									if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+									if ((checkType & HIDE_NULL_COMPARISON_WARNING) == 0) {
 										scope.problemReporter().localVariableRedundantCheckOnNull(local, reference);
 									}
-									if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-										flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-									}
+									flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 									return;
 								case FlowContext.IN_COMPARISON_NON_NULL:
-									if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+									if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 										scope.problemReporter().localVariableNullReference(local, reference);
 										return;
 									}
-									if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-										scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
-									}
-									if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-										flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-									}
+									scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
+									flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 									return;
 								case FlowContext.IN_ASSIGNMENT:
 									scope.problemReporter().localVariableRedundantNullAssignment(local, reference);
@@ -297,15 +284,15 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 									return;
 							}
 						} else if (flowInfo.isPotentiallyNull(local)) {
-							switch(checkType & CONTEXT_MASK) {
+							switch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {
 								case FlowContext.IN_COMPARISON_NULL:
-									if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+									if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 										scope.problemReporter().localVariablePotentialNullReference(local, reference);
 										return;
 									}
 									break;
 								case FlowContext.IN_COMPARISON_NON_NULL:
-									if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+									if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 										scope.problemReporter().localVariablePotentialNullReference(local, reference);
 										return;
 									}
@@ -327,24 +314,18 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 				}
 			}
 			else { // no enclosing loop, be as precise as possible right now
-				switch (checkType) {
+				switch (checkTypeWithoutHideNullWarning) {
 					case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL:
 					case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL:
 						if (flowInfo.isDefinitelyNonNull(local)) {
-							if (checkType == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
-								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+							if (checkTypeWithoutHideNullWarning == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
+								if ((checkType & HIDE_NULL_COMPARISON_WARNING) == 0) {
 									scope.problemReporter().localVariableRedundantCheckOnNonNull(local, location);
 								}
-								if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-									flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-								}
+								flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 							} else {
-								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-									scope.problemReporter().localVariableNonNullComparedToNull(local, location);
-								}
-								if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-									flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-								}
+								scope.problemReporter().localVariableNonNullComparedToNull(local, location);
+								flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 							}
 							return;
 						}
@@ -355,30 +336,24 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 					case CAN_ONLY_NULL | IN_INSTANCEOF:
 						Expression reference = (Expression) location;
 						if (flowInfo.isDefinitelyNull(local)) {
-							switch(checkType & CONTEXT_MASK) {
+							switch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {
 								case FlowContext.IN_COMPARISON_NULL:
-									if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+									if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 										scope.problemReporter().localVariableNullReference(local, reference);
 										return;
 									}
-									if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+									if ((checkType & HIDE_NULL_COMPARISON_WARNING) == 0) {
 										scope.problemReporter().localVariableRedundantCheckOnNull(local, reference);
 									}
-									if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-										flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-									}
+									flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 									return;
 								case FlowContext.IN_COMPARISON_NON_NULL:
-									if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+									if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 										scope.problemReporter().localVariableNullReference(local, reference);
 										return;
 									}
-									if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-										scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
-									}
-									if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-										flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-									}
+									scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
+									flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 									return;
 								case FlowContext.IN_ASSIGNMENT:
 									scope.problemReporter().localVariableRedundantNullAssignment(local, reference);
@@ -388,15 +363,15 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 									return;
 							}
 						} else if (flowInfo.isPotentiallyNull(local)) {
-							switch(checkType & CONTEXT_MASK) {
+							switch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {
 								case FlowContext.IN_COMPARISON_NULL:
-									if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+									if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 										scope.problemReporter().localVariablePotentialNullReference(local, reference);
 										return;
 									}
 									break;
 								case FlowContext.IN_COMPARISON_NON_NULL:
-									if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+									if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 										scope.problemReporter().localVariablePotentialNullReference(local, reference);
 										return;
 									}
@@ -421,13 +396,7 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 						// never happens
 				}
 			}
-			// if the contention is inside assert statement, we want to avoid null warnings only in case of
-			// comparisons and not in case of assignment, instanceof, or may be null.
-			if(((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) || checkType == MAY_NULL
-					|| (checkType & CONTEXT_MASK) == FlowContext.IN_ASSIGNMENT
-					|| (checkType & CONTEXT_MASK) == FlowContext.IN_INSTANCEOF) {
-				recordNullReference(local, location, checkType);
-			}
+			recordNullReference(local, location, checkType);
 			// prepare to re-check with try/catch flow info
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index 489bb1d..5367ea1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -65,7 +65,8 @@ public class FlowContext implements TypeConstants {
 	/**
 	 * used to hide null comparison related warnings inside assert statements 
 	 */
-	public static final int HIDE_NULL_COMPARISON_WARNING = 0x4;
+	public static final int HIDE_NULL_COMPARISON_WARNING = 0x1000;
+	public static final int HIDE_NULL_COMPARISON_WARNING_MASK = 0xF000;
 
 public static final int CAN_ONLY_NULL_NON_NULL = 0x0000;
 //check against null and non null, with definite values -- comparisons
@@ -87,7 +88,7 @@ public static final int IN_ASSIGNMENT = 0x0300;
 // check happened in an assignment
 public static final int IN_INSTANCEOF = 0x0400;
 // check happened in an instanceof expression
-public static final int CONTEXT_MASK = ~CHECK_MASK;
+public static final int CONTEXT_MASK = ~CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK;
 
 public FlowContext(FlowContext parent, ASTNode associatedNode) {
 	this.parent = parent;
@@ -646,6 +647,8 @@ public void recordSettingFinal(VariableBinding variable, Reference finalReferenc
  * 		CAN_ONLY_NULL_NON_NULL}, {@link #MAY_NULL MAY_NULL}, potentially
  *      combined with a context indicator (one of {@link #IN_COMPARISON_NULL},
  *      {@link #IN_COMPARISON_NON_NULL}, {@link #IN_ASSIGNMENT} or {@link #IN_INSTANCEOF})
+ *      and a bit to indicate whether the reference is being recorded inside an assert, 
+ *      {@link #HIDE_NULL_COMPARISON_WARNING}
  * @param flowInfo the flow info at the check point; deferring contexts will
  *  	perform supplementary checks against flow info instances that cannot
  *  	be known at the time of calling this method (they are influenced by
@@ -657,24 +660,21 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 			flowInfo.isDefinitelyUnknown(local)) {
 		return;
 	}
-	switch (checkType) {
+	// if reference is being recorded inside an assert, we will not raise redundant null check warnings
+	checkType |= (this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING);
+	int checkTypeWithoutHideNullWarning = checkType & ~FlowContext.HIDE_NULL_COMPARISON_WARNING_MASK;
+	switch (checkTypeWithoutHideNullWarning) {
 		case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL:
 		case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL:
 			if (flowInfo.isDefinitelyNonNull(local)) {
-				if (checkType == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
-					if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+				if (checkTypeWithoutHideNullWarning == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
+					if ((checkType & HIDE_NULL_COMPARISON_WARNING) == 0) {
 						scope.problemReporter().localVariableRedundantCheckOnNonNull(local, location);
 					}
-					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-					}
+					flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 				} else {
-					if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-						scope.problemReporter().localVariableNonNullComparedToNull(local, location);
-					}
-					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-					}
+					scope.problemReporter().localVariableNonNullComparedToNull(local, location);
+					flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 				}
 				return;
 			}
@@ -688,30 +688,24 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 		case CAN_ONLY_NULL | IN_INSTANCEOF:
 			Expression reference = (Expression)location;
 			if (flowInfo.isDefinitelyNull(local)) {
-				switch(checkType & CONTEXT_MASK) {
+				switch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {
 					case FlowContext.IN_COMPARISON_NULL:
-						if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+						if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 							scope.problemReporter().localVariableNullReference(local, reference);
 							return;
 						}
-						if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+						if ((checkType & HIDE_NULL_COMPARISON_WARNING) == 0) {
 							scope.problemReporter().localVariableRedundantCheckOnNull(local, reference);
 						}
-						if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-							flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-						}
+						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 						return;
 					case FlowContext.IN_COMPARISON_NON_NULL:
-						if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+						if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 							scope.problemReporter().localVariableNullReference(local, reference);
 							return;
 						}
-						if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-							scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
-						}
-						if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-							flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-						}
+						scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
+						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 						return;
 					case FlowContext.IN_ASSIGNMENT:
 						scope.problemReporter().localVariableRedundantNullAssignment(local, reference);
@@ -721,15 +715,15 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 						return;
 				}
 			} else if (flowInfo.isPotentiallyNull(local)) {
-				switch(checkType & CONTEXT_MASK) {
+				switch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {
 					case FlowContext.IN_COMPARISON_NULL:
-						if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+						if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 							scope.problemReporter().localVariablePotentialNullReference(local, reference);
 							return;
 						}
 						break;
 					case FlowContext.IN_COMPARISON_NON_NULL:
-						if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+						if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 							scope.problemReporter().localVariablePotentialNullReference(local, reference);
 							return;
 						}
@@ -805,7 +799,11 @@ public void recordNullityMismatch(BlockScope currentScope, Expression expression
 		FlowContext currentContext = this;
 		while (currentContext != null) {
 			// some flow contexts implement deferred checking, should we participate in that?
-			if (currentContext.internalRecordNullityMismatch(expression, nullStatus, expectedType, ASSIGN_TO_NONNULL))
+			int isInsideAssert = 0x0;
+			if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) != 0) {
+				isInsideAssert = FlowContext.HIDE_NULL_COMPARISON_WARNING;
+			}
+			if (currentContext.internalRecordNullityMismatch(expression, nullStatus, expectedType, ASSIGN_TO_NONNULL | isInsideAssert))
 				return;
 			currentContext = currentContext.parent;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
index b931372..d2e1cb2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -595,22 +595,6 @@ abstract public UnconditionalFlowInfo unconditionalInits();
 abstract public UnconditionalFlowInfo unconditionalInitsWithoutSideEffect();
 
 /**
- * Tell the flowInfo that a local variable got marked as non null or null
- * due to comparison with null inside an assert expression.
- * This is to prevent over-aggressive code generation for subsequent if statements
- * where this variable is being checked against null
- */
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=303448
-abstract public void markedAsNullOrNonNullInAssertExpression(LocalVariableBinding local);
-
-/** 
- * Returns true if the local variable being checked for was marked as null or not null
- * inside an assert expression due to comparison against null.
- */
-//https://bugs.eclipse.org/bugs/show_bug.cgi?id=303448
-abstract public boolean isMarkedAsNullOrNonNullInAssertExpression(LocalVariableBinding local);
-
-/**
  * Resets the definite and potential initialization info for the given local variable
  * @param local
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index 2257835..bde8071 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -152,19 +152,17 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 			LocalVariableBinding local = this.nullLocals[i];
 			ASTNode location = this.nullReferences[i];
 			// final local variable
-			switch (this.nullCheckTypes[i]) {
+			switch (this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) {
 				case CAN_ONLY_NON_NULL | IN_COMPARISON_NULL:
 				case CAN_ONLY_NON_NULL | IN_COMPARISON_NON_NULL:
 					if (flowInfo.isDefinitelyNonNull(local)) {
 						this.nullReferences[i] = null;
-						if (this.nullCheckTypes[i] == (CAN_ONLY_NON_NULL | IN_COMPARISON_NON_NULL)) {
-							if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+						if ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == (CAN_ONLY_NON_NULL | IN_COMPARISON_NON_NULL)) {
+							if ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {
 								scope.problemReporter().localVariableRedundantCheckOnNonNull(local, location);
 							}
 						} else {
-							if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-								scope.problemReporter().localVariableNonNullComparedToNull(local, location);
-							}
+							scope.problemReporter().localVariableNonNullComparedToNull(local, location);
 						}
 						continue;
 					}
@@ -173,27 +171,23 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 				case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL:
 					if (flowInfo.isDefinitelyNonNull(local)) {
 						this.nullReferences[i] = null;
-						if (this.nullCheckTypes[i] == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
-							if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+						if ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
+							if ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {
 								scope.problemReporter().localVariableRedundantCheckOnNonNull(local, location);
 							}
 						} else {
-							if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-								scope.problemReporter().localVariableNonNullComparedToNull(local, location);
-							}
+							scope.problemReporter().localVariableNonNullComparedToNull(local, location);
 						}
 						continue;
 					}
 					if (flowInfo.isDefinitelyNull(local)) {
 						this.nullReferences[i] = null;
-						if (this.nullCheckTypes[i] == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {
-							if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+						if ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {
+							if ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {
 								scope.problemReporter().localVariableRedundantCheckOnNull(local, location);
 							}
 						} else {
-							if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-								scope.problemReporter().localVariableNullComparedToNonNull(local, location);
-							}
+							scope.problemReporter().localVariableNullComparedToNonNull(local, location);
 						}
 						continue;
 					}
@@ -207,22 +201,20 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 						this.nullReferences[i] = null;
 						switch(this.nullCheckTypes[i] & CONTEXT_MASK) {
 							case FlowContext.IN_COMPARISON_NULL:
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariableNullReference(local, expression);
 									continue;
 								}
-								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+								if ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {
 									scope.problemReporter().localVariableRedundantCheckOnNull(local, expression);
 								}
 								continue;
 							case FlowContext.IN_COMPARISON_NON_NULL:
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariableNullReference(local, expression);
 									continue;
 								}
-								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-									scope.problemReporter().localVariableNullComparedToNonNull(local, expression);
-								}
+								scope.problemReporter().localVariableNullComparedToNonNull(local, expression);
 								continue;
 							case FlowContext.IN_ASSIGNMENT:
 								scope.problemReporter().localVariableRedundantNullAssignment(local, expression);
@@ -235,14 +227,14 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 						switch(this.nullCheckTypes[i] & CONTEXT_MASK) {
 							case FlowContext.IN_COMPARISON_NULL:
 								this.nullReferences[i] = null;
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariablePotentialNullReference(local, expression);
 									continue;
 								}
 								break;
 							case FlowContext.IN_COMPARISON_NON_NULL:
 								this.nullReferences[i] = null;
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariablePotentialNullReference(local, expression);
 									continue;
 								}
@@ -288,19 +280,17 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 			ASTNode location = this.nullReferences[i];
 			// final local variable
 			LocalVariableBinding local = this.nullLocals[i];
-			switch (this.nullCheckTypes[i]) {
+			switch (this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) {
 				case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL:
 				case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL:
 					if (flowInfo.isDefinitelyNonNull(local)) {
 						this.nullReferences[i] = null;
-						if (this.nullCheckTypes[i] == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
-							if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+						if ((this.nullCheckTypes[i] & ~HIDE_NULL_COMPARISON_WARNING_MASK) == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
+							if ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {
 								scope.problemReporter().localVariableRedundantCheckOnNonNull(local, location);
 							}
 						} else {
-							if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-								scope.problemReporter().localVariableNonNullComparedToNull(local, location);
-							}
+							scope.problemReporter().localVariableNonNullComparedToNull(local, location);
 						}
 						continue;
 					}
@@ -314,22 +304,20 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 						this.nullReferences[i] = null;
 						switch(this.nullCheckTypes[i] & CONTEXT_MASK) {
 							case FlowContext.IN_COMPARISON_NULL:
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariableNullReference(local, expression);
 									continue;
 								}
-								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
+								if ((this.nullCheckTypes[i] & HIDE_NULL_COMPARISON_WARNING) == 0) {
 									scope.problemReporter().localVariableRedundantCheckOnNull(local, expression);
 								}
 								continue;
 							case FlowContext.IN_COMPARISON_NON_NULL:
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariableNullReference(local, expression);
 									continue;
 								}
-								if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-									scope.problemReporter().localVariableNullComparedToNonNull(local, expression);
-								}
+								scope.problemReporter().localVariableNullComparedToNonNull(local, expression);
 								continue;
 							case FlowContext.IN_ASSIGNMENT:
 								scope.problemReporter().localVariableRedundantNullAssignment(local, expression);
@@ -342,14 +330,14 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 						switch(this.nullCheckTypes[i] & CONTEXT_MASK) {
 							case FlowContext.IN_COMPARISON_NULL:
 								this.nullReferences[i] = null;
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariablePotentialNullReference(local, expression);
 									continue;
 								}
 								break;
 							case FlowContext.IN_COMPARISON_NON_NULL:
 								this.nullReferences[i] = null;
-								if (((this.nullCheckTypes[i] & CHECK_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+								if (((this.nullCheckTypes[i] & CHECK_MASK & ~HIDE_NULL_COMPARISON_WARNING_MASK) == CAN_ONLY_NULL) && (expression.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 									scope.problemReporter().localVariablePotentialNullReference(local, expression);
 									continue;
 								}
@@ -560,63 +548,50 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 			flowInfo.isDefinitelyUnknown(local)) {
 		return;
 	}
-	switch (checkType) {
+	// if reference is being recorded inside an assert, we will not raise redundant null check warnings
+	checkType |= (this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING);
+	int checkTypeWithoutHideNullWarning = checkType & ~FlowContext.HIDE_NULL_COMPARISON_WARNING_MASK;
+	switch (checkTypeWithoutHideNullWarning) {
 		case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL:
 		case CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL:
 			Expression reference = (Expression)location;
 			if (flowInfo.isDefinitelyNonNull(local)) {
-				if (checkType == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
+				if (checkTypeWithoutHideNullWarning == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NON_NULL)) {
 					if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
 						scope.problemReporter().localVariableRedundantCheckOnNonNull(local, reference);
 					}
-					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-					}
+					flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 				} else {
-					if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-						scope.problemReporter().localVariableNonNullComparedToNull(local, reference);
-					}
-					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-					}
+					scope.problemReporter().localVariableNonNullComparedToNull(local, reference);
+					flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 				}
 			} else if (flowInfo.isDefinitelyNull(local)) {
-				if (checkType == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {
+				if (checkTypeWithoutHideNullWarning == (CAN_ONLY_NULL_NON_NULL | IN_COMPARISON_NULL)) {
 					if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
 						scope.problemReporter().localVariableRedundantCheckOnNull(local, reference);
 					}
-					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-					}
+					flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 				} else {
-					if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-						scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
-					}
-					if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-					}
+					scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
+					flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 				}
 			} else if (this.upstreamNullFlowInfo.isDefinitelyNonNull(local) && !flowInfo.isPotentiallyNull(local) && !flowInfo.isPotentiallyUnknown(local)) {
 				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=291418
 				flowInfo.markAsDefinitelyNonNull(local);
-				if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-					recordNullReference(local, reference, checkType);
-				}
+				recordNullReference(local, reference, checkType);
 			} else if (flowInfo.cannotBeDefinitelyNullOrNonNull(local)) {
 				return; // no reason to complain, since there is definitely some uncertainty making the comparison relevant.
 			} else {
-				if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
 					// note: pot non-null & pot null is already captured by cannotBeDefinitelyNullOrNonNull()
 					if (flowInfo.isPotentiallyNonNull(local)) {
-						// knowing 'local' can be non-null, we're only interested in seeing whether it can *only* be non-null 
-						recordNullReference(local, reference, CAN_ONLY_NON_NULL | checkType & CONTEXT_MASK);
+						// knowing 'local' can be non-null, we're only interested in seeing whether it can *only* be non-null
+						recordNullReference(local, reference, CAN_ONLY_NON_NULL | checkType & (CONTEXT_MASK|HIDE_NULL_COMPARISON_WARNING_MASK));
 					} else if (flowInfo.isPotentiallyNull(local)) {
 						// knowing 'local' can be null, we're only interested in seeing whether it can *only* be null
-						recordNullReference(local, reference, CAN_ONLY_NULL | checkType & CONTEXT_MASK);
+						recordNullReference(local, reference, CAN_ONLY_NULL | checkType & (CONTEXT_MASK|HIDE_NULL_COMPARISON_WARNING_MASK));
 					} else {
 						recordNullReference(local, reference, checkType);
 					}
-				}
 			}
 			return;
 		case CAN_ONLY_NULL | IN_COMPARISON_NULL:
@@ -632,30 +607,24 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 				return;
 			}
 			if (flowInfo.isDefinitelyNull(local)) {
-				switch(checkType & CONTEXT_MASK) {
+				switch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {
 					case FlowContext.IN_COMPARISON_NULL:
-						if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+						if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 							scope.problemReporter().localVariableNullReference(local, reference);
 							return;
 						}
 						if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
 							scope.problemReporter().localVariableRedundantCheckOnNull(local, reference);
 						}
-						if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-							flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-						}
+						flowInfo.initsWhenFalse().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 						return;
 					case FlowContext.IN_COMPARISON_NON_NULL:
-						if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+						if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 							scope.problemReporter().localVariableNullReference(local, reference);
 							return;
 						}
-						if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0) {
-							scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
-						}
-						if (!flowInfo.isMarkedAsNullOrNonNullInAssertExpression(local)) {
-							flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
-						}
+						scope.problemReporter().localVariableNullComparedToNonNull(local, reference);
+						flowInfo.initsWhenTrue().setReachMode(FlowInfo.UNREACHABLE_BY_NULLANALYSIS);
 						return;
 					case FlowContext.IN_ASSIGNMENT:
 						scope.problemReporter().localVariableRedundantNullAssignment(local, reference);
@@ -665,28 +634,22 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 						return;
 				}
 			} else if (flowInfo.isPotentiallyNull(local)) {
-				switch(checkType & CONTEXT_MASK) {
+				switch(checkTypeWithoutHideNullWarning & CONTEXT_MASK) {
 					case FlowContext.IN_COMPARISON_NULL:
-						if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+						if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 							scope.problemReporter().localVariablePotentialNullReference(local, reference);
 							return;
 						}
 						break;
 					case FlowContext.IN_COMPARISON_NON_NULL:
-						if (((checkType & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
+						if (((checkTypeWithoutHideNullWarning & CHECK_MASK) == CAN_ONLY_NULL) && (reference.implicitConversion & TypeIds.UNBOXING) != 0) { // check for auto-unboxing first and report appropriate warning
 							scope.problemReporter().localVariablePotentialNullReference(local, reference);
 							return;
 						}
 						break;
 				}
 			}
-			// if the contention is inside assert statement, we want to avoid null warnings only in case of
-			// comparisons and not in case of assignment and instanceof
-			if ((this.tagBits & FlowContext.HIDE_NULL_COMPARISON_WARNING) == 0 
-					|| (checkType & CONTEXT_MASK) == FlowContext.IN_ASSIGNMENT
-					|| (checkType & CONTEXT_MASK) == FlowContext.IN_INSTANCEOF) {
-				recordNullReference(local, reference, checkType);
-			}
+			recordNullReference(local, reference, checkType);
 			return;
 		case MAY_NULL :
 			if (flowInfo.isDefinitelyNonNull(local)) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
index ed1ae7a..b86fddf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -90,7 +90,6 @@ public class UnconditionalFlowInfo extends FlowInfo {
 
 	// Constants
 	public static final int BitCacheSize = 64; // 64 bits in a long.
-	public int[] nullStatusChangedInAssert; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=303448
 
 public FlowInfo addInitializationsFrom(FlowInfo inits) {
 	return addInfoFrom(inits, true);
@@ -302,7 +301,6 @@ private FlowInfo addInfoFrom(FlowInfo inits, boolean handleInits) {
 			}
 		}
 	}
-	combineNullStatusChangeInAssertInfo(otherInits);
 	return this;
 }
 
@@ -510,7 +508,6 @@ public UnconditionalFlowInfo addPotentialNullInfoFrom(
 			}
 		}
 	}
-	combineNullStatusChangeInAssertInfo(otherInits);
 	if (thisHasNulls) {
 		this.tagBits |= NULL_FLAG_MASK;
 	}
@@ -642,7 +639,6 @@ public FlowInfo copy() {
 			}
 		}
 	}
-	copy.nullStatusChangedInAssert = this.nullStatusChangedInAssert;
 	return copy;
 }
 
@@ -1593,7 +1589,6 @@ public UnconditionalFlowInfo mergedWith(UnconditionalFlowInfo otherInits) {
 				throw new AssertionFailedException("COVERAGE 28"); //$NON-NLS-1$
 			}
 		}
-		combineNullStatusChangeInAssertInfo(otherInits);
 		return this;
 	}
 	if ((this.tagBits & UNREACHABLE_OR_DEAD) != 0) {
@@ -1602,7 +1597,6 @@ public UnconditionalFlowInfo mergedWith(UnconditionalFlowInfo otherInits) {
 				throw new AssertionFailedException("COVERAGE 29"); //$NON-NLS-1$
 			}
 		}
-		otherInits.combineNullStatusChangeInAssertInfo(this);
 		return (UnconditionalFlowInfo) otherInits.copy(); // make sure otherInits won't be affected
 	}
 
@@ -1868,7 +1862,6 @@ public UnconditionalFlowInfo mergedWith(UnconditionalFlowInfo otherInits) {
 			}
 		}
 	}
-	combineNullStatusChangeInAssertInfo(otherInits);
 	if (thisHasNulls) {
 		this.tagBits |= NULL_FLAG_MASK;
 	}
@@ -1900,7 +1893,6 @@ public UnconditionalFlowInfo nullInfoLessUnconditionalCopy() {
 	copy.potentialInits = this.potentialInits;
 	copy.tagBits = this.tagBits & ~NULL_FLAG_MASK;
 	copy.maxFieldCount = this.maxFieldCount;
-	copy.nullStatusChangedInAssert = this.nullStatusChangedInAssert;
 	if (this.extra != null) {
 		int length;
 		copy.extra = new long[extraLength][];
@@ -2033,7 +2025,6 @@ public UnconditionalFlowInfo unconditionalFieldLessCopy() {
 		copy.nullBit3 = this.nullBit3 & mask;
 		copy.nullBit4 = this.nullBit4 & mask;
 	}
-	copy.nullStatusChangedInAssert = this.nullStatusChangedInAssert;
 	// use extra vector
 	if (this.extra == null) {
 		return copy; // if vector not yet allocated, then not initialized
@@ -2077,61 +2068,6 @@ public UnconditionalFlowInfo unconditionalInitsWithoutSideEffect() {
 	return this;
 }
 
-public void markedAsNullOrNonNullInAssertExpression(LocalVariableBinding local) {
-	int position = local.id + this.maxFieldCount;
-	int oldLength;
-	if (this.nullStatusChangedInAssert == null) {
-		this.nullStatusChangedInAssert = new int[position + 1];
-	}
-	else {
-		if(position >= (oldLength = this.nullStatusChangedInAssert.length)) {
-			System.arraycopy(this.nullStatusChangedInAssert, 0, (this.nullStatusChangedInAssert = new int[position + 1]), 0, oldLength); 
-		}
-	}
-	this.nullStatusChangedInAssert[position] = 1;
-}
-
-public boolean isMarkedAsNullOrNonNullInAssertExpression(LocalVariableBinding local) {
-	int position = local.id + this.maxFieldCount;
-	if(this.nullStatusChangedInAssert == null || position >= this.nullStatusChangedInAssert.length) {
-		return false;
-	}
-	if(this.nullStatusChangedInAssert[position] == 1) {
-		return true;
-	}
-	return false;
-}
-
-/**
- * Combine the null status changes in assert expressions info
- * @param otherInits
- */
-// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=303448
-private void combineNullStatusChangeInAssertInfo(UnconditionalFlowInfo otherInits) {
-	if (this.nullStatusChangedInAssert != null || otherInits.nullStatusChangedInAssert != null) {
-		int mergedLength, length;
-		if (this.nullStatusChangedInAssert != null) {
-			if (otherInits.nullStatusChangedInAssert != null) {
-				if(otherInits.nullStatusChangedInAssert.length > this.nullStatusChangedInAssert.length) {
-					mergedLength = otherInits.nullStatusChangedInAssert.length;
-					length = this.nullStatusChangedInAssert.length;
-					System.arraycopy(this.nullStatusChangedInAssert, 0, (this.nullStatusChangedInAssert = new int[mergedLength]), 0, length);
-					for(int i = 0; i < length; i ++) {
-						this.nullStatusChangedInAssert[i] |= otherInits.nullStatusChangedInAssert[i];
-					}
-					System.arraycopy(otherInits.nullStatusChangedInAssert, length, this.nullStatusChangedInAssert, length, mergedLength - length);
-				} else {
-					for(int i = 0; i < otherInits.nullStatusChangedInAssert.length; i ++) {
-						this.nullStatusChangedInAssert[i] |= otherInits.nullStatusChangedInAssert[i];
-					}
-				}
-			}
-		} else if (otherInits.nullStatusChangedInAssert != null) {
-			this.nullStatusChangedInAssert = otherInits.nullStatusChangedInAssert;
-		}
-	}
-}
-
 public void resetAssignmentInfo(LocalVariableBinding local) {
 	resetAssignmentInfo(local.id + this.maxFieldCount);
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index ca96657..1503c6e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -675,12 +675,12 @@ public void computeId() {
 			}
 			break;
 		case 5 :
-			if (!CharOperation.equals(TypeConstants.JAVA, this.compoundName[0]))
+			if (!CharOperation.equals(TypeConstants.JAVA, this.compoundName[0]) && !CharOperation.equals(TypeConstants.ORG, this.compoundName[0]))
 				return;
 			packageName = this.compoundName[1];
 			if (packageName.length == 0) return; // just to be safe
 
-			if (CharOperation.equals(TypeConstants.LANG, packageName)) {
+			if (CharOperation.equals(TypeConstants.LANG, packageName) || CharOperation.equals(TypeConstants.ECLIPSE, packageName)) {
 				packageName = this.compoundName[2];
 				if (packageName.length == 0) return; // just to be safe
 				switch (packageName[0]) {
@@ -699,6 +699,21 @@ public void computeId() {
 							}
 						}
 						return;
+					case 'c' :
+						if (CharOperation.equals(packageName, TypeConstants.CORE)) { 
+							typeName = this.compoundName[3];
+							if (typeName.length == 0) return; // just to be safe
+							switch (typeName[0]) {
+								case 'r' :
+									char[] memberTypeName = this.compoundName[4];
+									if (memberTypeName.length == 0) return; // just to be safe
+									if (CharOperation.equals(typeName, TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT[3])
+											&& CharOperation.equals(memberTypeName, TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT[4]))
+										this.id = TypeIds.T_OrgEclipseCoreRuntimeAssert;
+									return;
+							}
+						}
+						return;
 				}
 				return;
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index e607732..95ebdc3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -210,6 +210,12 @@ public interface TypeConstants {
 		"CharArrayWriter".toCharArray(), //$NON-NLS-1$
 		"StringBufferInputStream".toCharArray(), //$NON-NLS-1$
 	};
+	
+	char[] ORG = "org".toCharArray(); //$NON-NLS-1$
+	char[] ECLIPSE = "eclipse".toCharArray(); //$NON-NLS-1$
+	char[] CORE = "core".toCharArray(); //$NON-NLS-1$
+	char[] RUNTIME = "runtime".toCharArray(); //$NON-NLS-1$
+	char[][] ORG_ECLIPSE_CORE_RUNTIME_ASSERT = new char[][] { ORG, ECLIPSE, CORE, RUNTIME, "Assert".toCharArray()}; //$NON-NLS-1$
 
 	// Constraints for generic type argument inference
 	int CONSTRAINT_EQUAL = 0;		// Actual = Formal
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
index 439b49e..cf057f4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
@@ -106,6 +106,9 @@ public interface TypeIds {
 	final int T_ConfiguredAnnotationNullable = 65;
 	final int T_ConfiguredAnnotationNonNull = 66;
 	final int T_ConfiguredAnnotationNonNullByDefault = 67;
+	
+	// new in 3.8 to identify org.eclipse.core.runtime.Assert
+	final int T_OrgEclipseCoreRuntimeAssert = 68;
 
 	final int NoId = Integer.MAX_VALUE;
 
