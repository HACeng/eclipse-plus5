commit aad96262e42cc2b94af7f7cb50d56aa2c91032d4
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Wed Sep 7 18:47:11 2016 -0700

    Bug 501034 - [newindex] Test failures in NullAnnotationModelTests
    
    Change-Id: I9c8fbb23818f5cc5f707fe472ccef9f7a64c8f72
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

4	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
142	78	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
19	10	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
4	35	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
37	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInConstant.java
39	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInMethod.java
39	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInMethodParameter.java
39	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInType.java
39	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInVariable.java
1	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
10	7	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
4	4	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
13	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
13	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
13	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
119	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotation.java
39	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInMethod.java
39	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInType.java
39	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInVariable.java
10	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
1	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
16	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
60	95	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
index 1501e5f..0ab9e89 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/db/Database.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2015 QNX Software Systems and others.
+ * Copyright (c) 2005, 2016 QNX Software Systems and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -510,6 +510,9 @@ public class Database {
 	 */
 	public void free(long address, short poolId) throws IndexException {
 		assert this.fExclusiveLock;
+		if (address == 0) {
+			return;
+		}
 		// TODO Look for opportunities to merge blocks
 		long block = address - BLOCK_HEADER_SIZE;
 		Chunk chunk = getChunk(block);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
index c2d25b1..b3ef2fb 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/ClassFileToIndexConverter.java
@@ -1,3 +1,13 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.indexer;
 
 import java.lang.reflect.Modifier;
@@ -10,6 +20,7 @@ import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationWalker;
+import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
 import org.eclipse.jdt.internal.compiler.env.ClassSignature;
 import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
@@ -30,6 +41,11 @@ import org.eclipse.jdt.internal.core.nd.db.IndexException;
 import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.JavaNames;
 import org.eclipse.jdt.internal.core.nd.java.NdAnnotation;
+import org.eclipse.jdt.internal.core.nd.java.NdAnnotationInConstant;
+import org.eclipse.jdt.internal.core.nd.java.NdAnnotationInMethod;
+import org.eclipse.jdt.internal.core.nd.java.NdAnnotationInMethodParameter;
+import org.eclipse.jdt.internal.core.nd.java.NdAnnotationInType;
+import org.eclipse.jdt.internal.core.nd.java.NdAnnotationInVariable;
 import org.eclipse.jdt.internal.core.nd.java.NdAnnotationValuePair;
 import org.eclipse.jdt.internal.core.nd.java.NdBinding;
 import org.eclipse.jdt.internal.core.nd.java.NdComplexTypeSignature;
@@ -44,6 +60,10 @@ import org.eclipse.jdt.internal.core.nd.java.NdMethodId;
 import org.eclipse.jdt.internal.core.nd.java.NdMethodParameter;
 import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
 import org.eclipse.jdt.internal.core.nd.java.NdType;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeAnnotation;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeAnnotationInMethod;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeAnnotationInType;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeAnnotationInVariable;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeArgument;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeBound;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeId;
@@ -126,9 +146,14 @@ public final class ClassFileToIndexConverter {
 			type = new NdType(getNd(), this.resource);
 		}
 
-		ITypeAnnotationWalker typeAnnotations = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
-		ITypeAnnotationWalker supertypeAnnotations = typeAnnotations.toSupertype((short) -1,
-				binaryType.getSuperclassName());
+		IBinaryTypeAnnotation[] typeAnnotations = binaryType.getTypeAnnotations();
+		if (typeAnnotations != null) {
+			for (IBinaryTypeAnnotation typeAnnotation : typeAnnotations) {
+				NdTypeAnnotationInType annotation = new NdTypeAnnotationInType(getNd(), type);
+
+				initTypeAnnotation(annotation, typeAnnotation);
+			}
+		}
 
 		type.setTypeId(name);
 
@@ -151,7 +176,7 @@ public final class ClassFileToIndexConverter {
 		type.setModifiers(binaryType.getModifiers());
 		type.setDeclaringType(createTypeIdFromBinaryName(binaryType.getEnclosingTypeName()));
 
-		readTypeParameters(type, typeAnnotations, signatureWrapper);
+		readTypeParameters(type, signatureWrapper);
 
 		char[] superclassFieldDescriptor;
 		char[] superclassBinaryName = binaryType.getSuperclassName();
@@ -160,7 +185,7 @@ public final class ClassFileToIndexConverter {
 		} else {
 			superclassFieldDescriptor = JavaNames.binaryNameToFieldDescriptor(superclassBinaryName);
 		}
-		type.setSuperclass(createTypeSignature(supertypeAnnotations, signatureWrapper, superclassFieldDescriptor));
+		type.setSuperclass(createTypeSignature(signatureWrapper, superclassFieldDescriptor));
 
 		short interfaceIdx = 0;
 		while (signatureWrapper.start < signatureWrapper.signature.length) {
@@ -170,8 +195,7 @@ public final class ClassFileToIndexConverter {
 			// interfaces list.
 			char[] interfaceSpec = interfaceIdx < interfaces.length ? interfaces[interfaceIdx] : EMPTY_CHAR_ARRAY;
 			new NdTypeInterface(getNd(), type,
-					createTypeSignature(typeAnnotations.toSupertype(interfaceIdx, interfaceSpec), signatureWrapper,
-							JavaNames.binaryNameToFieldDescriptor(interfaceSpec)));
+					createTypeSignature(signatureWrapper, JavaNames.binaryNameToFieldDescriptor(interfaceSpec)));
 			interfaceIdx++;
 		}
 
@@ -238,10 +262,38 @@ public final class ClassFileToIndexConverter {
 		return missingTypeString;
 	}
 
-	private void attachAnnotations(NdBinding type, IBinaryAnnotation[] annotations) {
+	private void attachAnnotations(NdMethod method, IBinaryAnnotation[] annotations) {
+		if (annotations != null) {
+			for (IBinaryAnnotation next : annotations) {
+				NdAnnotationInMethod annotation = new NdAnnotationInMethod(getNd(), method);
+				initAnnotation(annotation, next);
+			}
+		}
+	}
+
+	private void attachAnnotations(NdType type, IBinaryAnnotation[] annotations) {
+		if (annotations != null) {
+			for (IBinaryAnnotation next : annotations) {
+				NdAnnotationInType annotation = new NdAnnotationInType(getNd(), type);
+				initAnnotation(annotation, next);
+			}
+		}
+	}
+
+	private void attachAnnotations(NdVariable variable, IBinaryAnnotation[] annotations) {
 		if (annotations != null) {
 			for (IBinaryAnnotation next : annotations) {
-				createAnnotation(next).setParent(type);
+				NdAnnotationInVariable annotation = new NdAnnotationInVariable(getNd(), variable);
+				initAnnotation(annotation, next);
+			}
+		}
+	}
+
+	private void attachAnnotations(NdMethodParameter variable, IBinaryAnnotation[] annotations) {
+		if (annotations != null) {
+			for (IBinaryAnnotation next : annotations) {
+				NdAnnotationInMethodParameter annotation = new NdAnnotationInMethodParameter(getNd(), variable);
+				initAnnotation(annotation, next);
 			}
 		}
 	}
@@ -258,13 +310,21 @@ public final class ClassFileToIndexConverter {
 
 		attachAnnotations(method, next.getAnnotations());
 
-		ITypeAnnotationWalker typeAnnotations = getTypeAnnotationWalker(next.getTypeAnnotations());
 		if (next.getGenericSignature() != null) {
 			flags |= NdMethod.FLG_GENERIC_SIGNATURE_PRESENT;
 		}
 		SignatureWrapper signature = GenericSignatures.getGenericSignature(next);
 		SignatureWrapper descriptor = new SignatureWrapper(next.getMethodDescriptor());
-		readTypeParameters(method, typeAnnotations, signature);
+		readTypeParameters(method, signature);
+
+		IBinaryTypeAnnotation[] typeAnnotations = next.getTypeAnnotations();
+		if (typeAnnotations != null) {
+			for (IBinaryTypeAnnotation typeAnnotation : typeAnnotations) {
+				NdTypeAnnotationInMethod annotation = new NdTypeAnnotationInMethod(getNd(), method);
+
+				initTypeAnnotation(annotation, typeAnnotation);
+			}
+		}
 
 		skipChar(signature, '(');
 		skipChar(descriptor, '(');
@@ -321,8 +381,7 @@ public final class ClassFileToIndexConverter {
 				nextFieldSignature = new SignatureWrapper(nextFieldDescriptor);
 			}
 			NdMethodParameter parameter = new NdMethodParameter(method,
-					createTypeSignature(typeAnnotations.toMethodParameter(descriptorParameterIdx), nextFieldSignature,
-							nextFieldDescriptor));
+					createTypeSignature(nextFieldSignature, nextFieldDescriptor));
 
 			parameter.setCompilerDefined(isCompilerDefined);
 
@@ -330,11 +389,7 @@ public final class ClassFileToIndexConverter {
 				IBinaryAnnotation[] parameterAnnotations = next.getParameterAnnotations(descriptorParameterIdx,
 						binaryTypeName);
 
-				if (parameterAnnotations != null) {
-					for (IBinaryAnnotation nextAnnotation : parameterAnnotations) {
-						createAnnotation(nextAnnotation).setParent(parameter);
-					}
-				}
+				attachAnnotations(parameter, parameterAnnotations);
 			}
 			if (!isCompilerDefined && parameterNames != null && parameterNames.length > parameterNameIdx) {
 				parameter.setName(parameterNames[parameterNameIdx++]);
@@ -344,7 +399,7 @@ public final class ClassFileToIndexConverter {
 
 		skipChar(descriptor, ')');
 		char[] nextFieldDescriptor = readNextFieldDescriptor(descriptor);
-		method.setReturnType(createTypeSignature(typeAnnotations.toMethodReturn(), signature, nextFieldDescriptor));
+		method.setReturnType(createTypeSignature(signature, nextFieldDescriptor));
 
 		boolean hasExceptionsInSignature = hasAnotherException(signature);
 		char[][] exceptionTypes = next.getExceptionTypeNames();
@@ -355,7 +410,7 @@ public final class ClassFileToIndexConverter {
 		if (hasExceptionsInSignature) {
 			while (hasAnotherException(signature)) {
 				signature.start++;
-				new NdMethodException(method, createTypeSignature(typeAnnotations.toThrows(throwsIdx), signature,
+				new NdMethodException(method, createTypeSignature(signature,
 						JavaNames.binaryNameToFieldDescriptor(exceptionTypes[throwsIdx])));
 				throwsIdx++;
 			}
@@ -363,7 +418,7 @@ public final class ClassFileToIndexConverter {
 			for (;throwsIdx < exceptionTypes.length; throwsIdx++) {
 				char[] fieldDescriptor = JavaNames.binaryNameToFieldDescriptor(exceptionTypes[throwsIdx]);
 				SignatureWrapper convertedWrapper = new SignatureWrapper(fieldDescriptor);
-				new NdMethodException(method, createTypeSignature(typeAnnotations.toThrows(throwsIdx), convertedWrapper,
+				new NdMethodException(method, createTypeSignature(convertedWrapper,
 						JavaNames.binaryNameToFieldDescriptor(exceptionTypes[throwsIdx])));
 			}
 		}
@@ -405,19 +460,21 @@ public final class ClassFileToIndexConverter {
 			variable.setVariableFlag(NdVariable.FLG_GENERIC_SIGNATURE_PRESENT);
 		}
 
-		IBinaryAnnotation[] binaryAnnotations = nextField.getAnnotations();
-		if (binaryAnnotations != null) {
-			for (IBinaryAnnotation nextAnnotation : binaryAnnotations) {
-				createAnnotation(nextAnnotation).setParent(variable);
-			}
-		}
+		attachAnnotations(variable, nextField.getAnnotations());
 
 		variable.setConstant(NdConstant.create(getNd(), nextField.getConstant()));
 		variable.setModifiers(nextField.getModifiers());
 		SignatureWrapper nextTypeSignature = GenericSignatures.getGenericSignatureFor(nextField);
 
-		ITypeAnnotationWalker annotationWalker = getTypeAnnotationWalker(nextField.getTypeAnnotations());
-		variable.setType(createTypeSignature(annotationWalker, nextTypeSignature, nextField.getTypeName()));
+		IBinaryTypeAnnotation[] typeAnnotations = nextField.getTypeAnnotations();
+		if (typeAnnotations != null) {
+			for (IBinaryTypeAnnotation next : typeAnnotations) {
+				NdTypeAnnotationInVariable annotation = new NdTypeAnnotationInVariable(getNd(), variable);
+	
+				initTypeAnnotation(annotation, next);
+			}
+		}
+		variable.setType(createTypeSignature(nextTypeSignature, nextField.getTypeName()));
 		variable.setTagBits(nextField.getTagBits());
 
 		// char[] fieldDescriptor = nextField.getTypeName();
@@ -431,15 +488,13 @@ public final class ClassFileToIndexConverter {
 	 *
 	 * @throws CoreException
 	 */
-	private void readTypeParameters(NdBinding type, ITypeAnnotationWalker annotationWalker, SignatureWrapper wrapper)
+	private void readTypeParameters(NdBinding type, SignatureWrapper wrapper)
 			throws CoreException {
 		char[] genericSignature = wrapper.signature;
 		if (genericSignature.length == 0 || wrapper.charAtStart() != '<') {
 			return;
 		}
 
-		int parameterIndex = 0;
-		int boundIndex = 0;
 		int indexOfClosingBracket = wrapper.skipAngleContents(wrapper.start) - 1;
 		wrapper.start++;
 		NdTypeParameter parameter = null;
@@ -452,18 +507,13 @@ public final class ClassFileToIndexConverter {
 				wrapper.start = colonPos + 1;
 				// The first bound is a class as long as it doesn't start with a double-colon
 				parameter.setFirstBoundIsClass(wrapper.charAtStart() != ':');
-				parameterIndex++;
-				boundIndex = 0;
 			}
 
 			skipChar(wrapper, ':');
 
-			NdTypeSignature boundSignature = createTypeSignature(
-					annotationWalker.toTypeParameter(true, parameterIndex).toTypeBound((short) boundIndex), wrapper,
-					JAVA_LANG_OBJECT_FIELD_DESCRIPTOR);
+			NdTypeSignature boundSignature = createTypeSignature(wrapper, JAVA_LANG_OBJECT_FIELD_DESCRIPTOR);
 
 			new NdTypeBound(parameter, boundSignature);
-			boundIndex++;
 		}
 
 		skipChar(wrapper, '>');
@@ -577,8 +627,6 @@ public final class ClassFileToIndexConverter {
 	 * wrapper.start. On return, wrapper.start will point to the first character following the type signature. Returns
 	 * null if given an empty signature or the signature for the void type.
 	 *
-	 * @param annotations
-	 *            the type annotations for this type
 	 * @param genericSignature
 	 *            the generic signature to parse
 	 * @param fieldDescriptorIfVariable
@@ -586,8 +634,7 @@ public final class ClassFileToIndexConverter {
 	 *            for java.lang.Object will be used)
 	 * @throws CoreException
 	 */
-	private NdTypeSignature createTypeSignature(ITypeAnnotationWalker annotations, SignatureWrapper genericSignature,
-			char[] fieldDescriptorIfVariable)
+	private NdTypeSignature createTypeSignature(SignatureWrapper genericSignature, char[] fieldDescriptorIfVariable)
 			throws CoreException {
 		char[] signature = genericSignature.signature;
 
@@ -607,7 +654,6 @@ public final class ClassFileToIndexConverter {
 				}
 				typeSignature.setRawType(createTypeIdFromFieldDescriptor(fieldDescriptor));
 				typeSignature.setVariableIdentifier(genericSignature.nextWord());
-				attachAnnotations(typeSignature, annotations);
 				// Skip the trailing semicolon
 				skipChar(genericSignature, ';');
 				return typeSignature;
@@ -621,8 +667,7 @@ public final class ClassFileToIndexConverter {
 					nestedFieldDescriptor = CharArrayUtils.subarray(fieldDescriptorIfVariable, 1);
 				}
 				// Determine the array argument type
-				NdTypeSignature elementType = createTypeSignature(annotations.toNextArrayDimension(), genericSignature,
-						nestedFieldDescriptor);
+				NdTypeSignature elementType = createTypeSignature(genericSignature, nestedFieldDescriptor);
 				char[] computedFieldDescriptor = CharArrayUtils.concat(ARRAY_FIELD_DESCRIPTOR_PREFIX,
 						elementType.getRawType().getFieldDescriptor().getChars());
 				NdTypeId rawType = createTypeIdFromFieldDescriptor(computedFieldDescriptor);
@@ -632,7 +677,6 @@ public final class ClassFileToIndexConverter {
 				typeSignature.setRawType(rawType);
 				NdTypeArgument typeArgument = new NdTypeArgument(getNd(), typeSignature);
 				typeArgument.setType(elementType);
-				attachAnnotations(typeSignature, annotations);
 				return typeSignature;
 			}
 			case 'V':
@@ -649,7 +693,7 @@ public final class ClassFileToIndexConverter {
 				genericSignature.start++;
 				return createTypeIdFromFieldDescriptor(new char[] { firstChar });
 			case 'L':
-				return parseClassTypeSignature(null, annotations, genericSignature);
+				return parseClassTypeSignature(null, genericSignature);
 			case '+':
 			case '-':
 			case '*':
@@ -666,8 +710,8 @@ public final class ClassFileToIndexConverter {
 	 * read pointer should be located just after the identifier. The caller is expected to have already read the field
 	 * descriptor for the type.
 	 */
-	private NdTypeSignature parseClassTypeSignature(NdComplexTypeSignature parentTypeOrNull,
-			ITypeAnnotationWalker annotations, SignatureWrapper wrapper) throws CoreException {
+	private NdTypeSignature parseClassTypeSignature(NdComplexTypeSignature parentTypeOrNull, SignatureWrapper wrapper)
+			throws CoreException {
 		char[] identifier = wrapper.nextWord();
 		char[] fieldDescriptor;
 
@@ -690,15 +734,12 @@ public final class ClassFileToIndexConverter {
 		// Special optimization for signatures with no type annotations, no arrays, and no generic arguments that
 		// are not an inner type of a class that can't use this optimization. Basically, if there would be no attributes
 		// set on a NdComplexTypeSignature besides what it picks up from its raw type, we just use the raw type.
-		IBinaryAnnotation[] annotationList = annotations.getAnnotationsAtCursor(0);
-		if (annotationList.length != 0 || hasGenericArguments || parentTypeOrNull != null || isRawTypeWithNestedClass) {
+		if (hasGenericArguments || parentTypeOrNull != null || isRawTypeWithNestedClass) {
 			NdComplexTypeSignature typeSignature = new NdComplexTypeSignature(getNd());
 			typeSignature.setRawType(rawType);
-			attachAnnotations(typeSignature, annotations);
 
 			if (hasGenericArguments) {
 				wrapper.start++;
-				short argumentIndex = 0;
 				while (wrapper.start < genericSignature.length && (genericSignature[wrapper.start] != '>')) {
 					NdTypeArgument typeArgument = new NdTypeArgument(getNd(), typeSignature);
 
@@ -716,15 +757,12 @@ public final class ClassFileToIndexConverter {
 						case '*': {
 							typeArgument.setWildcard(NdTypeArgument.WILDCARD_QUESTION);
 							wrapper.start++;
-							argumentIndex++;
 							continue;
 						}
 					}
 
-					NdTypeSignature nextSignature = createTypeSignature(annotations.toTypeArgument(argumentIndex),
-							wrapper, null);
+					NdTypeSignature nextSignature = createTypeSignature(wrapper, null);
 					typeArgument.setType(nextSignature);
-					argumentIndex++;
 				}
 
 				skipChar(wrapper, '>');
@@ -741,7 +779,7 @@ public final class ClassFileToIndexConverter {
 				checkForSemicolon = false;
 				// Identifiers shouldn't start with '.'
 				skipChar(wrapper, '.');
-				result = parseClassTypeSignature(typeSignature, annotations.toNextNestedType(), wrapper);
+				result = parseClassTypeSignature(typeSignature, wrapper);
 			}
 		}
 
@@ -752,20 +790,6 @@ public final class ClassFileToIndexConverter {
 		return result;
 	}
 
-	/**
-	 * @param typeSignature
-	 * @param annotations
-	 */
-	private void attachAnnotations(NdComplexTypeSignature typeSignature, ITypeAnnotationWalker annotations) {
-		IBinaryAnnotation[] annotationList = annotations.getAnnotationsAtCursor(0);
-
-		for (IBinaryAnnotation next : annotationList) {
-			NdAnnotation annotation = createAnnotation(next);
-
-			annotation.setParent(typeSignature);
-		}
-	}
-
 	private ITypeAnnotationWalker getTypeAnnotationWalker(IBinaryTypeAnnotation[] typeAnnotations) {
 		if (typeAnnotations == null) {
 			return ITypeAnnotationWalker.EMPTY_ANNOTATION_WALKER;
@@ -804,19 +828,57 @@ public final class ClassFileToIndexConverter {
 		return this.index.createMethodId(methodId);
 	}
 
-	private NdAnnotation createAnnotation(IBinaryAnnotation next) {
-		NdAnnotation result = new NdAnnotation(getNd(), createTypeIdFromBinaryName(next.getTypeName()));
+	private void initTypeAnnotation(NdTypeAnnotation annotation, IBinaryTypeAnnotation next) {
+		int[] typePath = next.getTypePath();
+		if (typePath != null && typePath.length > 0) {
+			byte[] bytePath = new byte[typePath.length];
+			for (int idx = 0; idx < bytePath.length; idx++) {
+				bytePath[idx] = (byte)typePath[idx];
+			}
+			annotation.setPath(bytePath);
+		}
+		int targetType = next.getTargetType();
+		annotation.setTargetType(targetType);
+		switch (targetType) {
+			case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER:
+			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER:
+				annotation.setTargetInfo(next.getTypeParameterIndex());
+				break;				
+			case AnnotationTargetTypeConstants.CLASS_EXTENDS:
+				annotation.setTargetInfo(next.getSupertypeIndex());
+				break;
+			case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND:
+			case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND:
+				annotation.setTargetInfo((byte)next.getTypeParameterIndex(), (byte)next.getBoundIndex());
+				break;
+			case AnnotationTargetTypeConstants.FIELD:
+			case AnnotationTargetTypeConstants.METHOD_RETURN:
+			case AnnotationTargetTypeConstants.METHOD_RECEIVER:
+				break;
+			case AnnotationTargetTypeConstants.METHOD_FORMAL_PARAMETER :
+				annotation.setTargetInfo(next.getMethodFormalParameterIndex());
+				break;
+			case AnnotationTargetTypeConstants.THROWS :
+				annotation.setTargetInfo(next.getThrowsTypeIndex());
+				break;
+
+			default:
+				throw new IllegalStateException("Target type not handled " + targetType); //$NON-NLS-1$
+		}
+		initAnnotation(annotation, next.getAnnotation());
+	}
+
+	private void initAnnotation(NdAnnotation annotation, IBinaryAnnotation next) {
+		annotation.setType(createTypeIdFromBinaryName(next.getTypeName())); 
 
 		IBinaryElementValuePair[] pairs = next.getElementValuePairs();
 
 		if (pairs != null) {
 			for (IBinaryElementValuePair element : pairs) {
-				NdAnnotationValuePair nextPair = new NdAnnotationValuePair(result, element.getName());
+				NdAnnotationValuePair nextPair = new NdAnnotationValuePair(annotation, element.getName());
 				nextPair.setValue(createConstantFromMixedType(element.getValue()));
 			}
 		}
-
-		return result;
 	}
 
 	private void logInfo(String string) {
@@ -852,7 +914,9 @@ public final class ClassFileToIndexConverter {
 		} else if (value instanceof IBinaryAnnotation) {
 			IBinaryAnnotation binaryAnnotation = (IBinaryAnnotation) value;
 
-			return NdConstantAnnotation.create(getNd(), createAnnotation(binaryAnnotation));
+			NdAnnotationInConstant annotation = new NdAnnotationInConstant(getNd());
+			initAnnotation(annotation, binaryAnnotation);
+			return NdConstantAnnotation.create(getNd(), annotation);
 		} else if (value instanceof Object[]) {
 			NdConstantArray result = new NdConstantArray(getNd());
 			Object[] array = (Object[]) value;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
index dc1f6d2..9fe6213 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/JavaIndex.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
+ * Copyright (c) 2015, 2016 Google, Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -37,9 +37,9 @@ import org.eclipse.jdt.internal.core.nd.util.CharArrayUtils;
  */
 public class JavaIndex {
 	// Version constants
-	static final int CURRENT_VERSION = Nd.version(1, 36);
-	static final int MAX_SUPPORTED_VERSION = Nd.version(1, 36);
-	static final int MIN_SUPPORTED_VERSION = Nd.version(1, 36);
+	static final int CURRENT_VERSION = Nd.version(1, 37);
+	static final int MAX_SUPPORTED_VERSION = Nd.version(1, 37);
+	static final int MIN_SUPPORTED_VERSION = Nd.version(1, 37);
 
 	// Fields for the search header
 	public static final FieldSearchIndex<NdResourceFile> FILES;
@@ -252,10 +252,15 @@ public class JavaIndex {
 	static NdNodeTypeRegistry<NdNode> createTypeRegistry() {
 		NdNodeTypeRegistry<NdNode> registry = new NdNodeTypeRegistry<>();
 		registry.register(0x0001, NdAnnotation.type.getFactory());
-		registry.register(0x0010, NdAnnotationValuePair.type.getFactory());
-		registry.register(0x0020, NdBinding.type.getFactory());
-		registry.register(0x0028, NdComplexTypeSignature.type.getFactory());
-		registry.register(0x0030, NdConstant.type.getFactory());
+		registry.register(0x0004, NdAnnotationInConstant.type.getFactory());
+		registry.register(0x0008, NdAnnotationInMethod.type.getFactory());
+		registry.register(0x000c, NdAnnotationInMethodParameter.type.getFactory());
+		registry.register(0x0010, NdAnnotationInType.type.getFactory());
+		registry.register(0x0014, NdAnnotationInVariable.type.getFactory());
+		registry.register(0x0020, NdAnnotationValuePair.type.getFactory());
+		registry.register(0x0028, NdBinding.type.getFactory());
+		registry.register(0x0030, NdComplexTypeSignature.type.getFactory());
+		registry.register(0x0038, NdConstant.type.getFactory());
 		registry.register(0x0040, NdConstantAnnotation.type.getFactory());
 		registry.register(0x0050, NdConstantArray.type.getFactory());
 		registry.register(0x0060, NdConstantBoolean.type.getFactory());
@@ -276,8 +281,12 @@ public class JavaIndex {
 		registry.register(0x0150, NdResourceFile.type.getFactory());
 		registry.register(0x0160, NdTreeNode.type.getFactory());
 		registry.register(0x0170, NdType.type.getFactory());
-		registry.register(0x0180, NdTypeArgument.type.getFactory());
-		registry.register(0x0190, NdTypeBound.type.getFactory());
+		registry.register(0x0180, NdTypeAnnotation.type.getFactory());
+		registry.register(0x0184, NdTypeAnnotationInMethod.type.getFactory());
+		registry.register(0x0188, NdTypeAnnotationInType.type.getFactory());
+		registry.register(0x018c, NdTypeAnnotationInVariable.type.getFactory());
+		registry.register(0x0190, NdTypeArgument.type.getFactory());
+		registry.register(0x0194, NdTypeBound.type.getFactory());
 		registry.register(0x01A0, NdTypeInterface.type.getFactory());
 		registry.register(0x01B0, NdTypeParameter.type.getFactory());
 		registry.register(0x01C0, NdTypeSignature.type.getFactory());
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
index 8c3016a..e2ad83f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
+ * Copyright (c) 2015, 2016 Google, Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -16,31 +16,22 @@ import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.NdNode;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
-import org.eclipse.jdt.internal.core.nd.field.FieldOneToOne;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
 
 /**
  * @since 3.12
  */
 public class NdAnnotation extends NdNode {
-	public static final FieldManyToOne<NdBinding> PARENT_BINDING;
 	public static final FieldManyToOne<NdTypeSignature> ANNOTATION_TYPE;
 	public static final FieldOneToMany<NdAnnotationValuePair> ELEMENT_VALUE_PAIRS;
-	public static final FieldOneToOne<NdConstantAnnotation> PARENT_CONSTANT;
-	public static final FieldManyToOne<NdComplexTypeSignature> PARENT_TYPE_SIGNATURE;
-	public static final FieldManyToOne<NdMethodParameter> PARENT_METHOD_PARAMETER;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<NdAnnotation> type;
 
 	static {
 		type = StructDef.create(NdAnnotation.class, NdNode.type);
-		PARENT_BINDING = FieldManyToOne.createOwner(type, NdBinding.ANNOTATIONS);
 		ANNOTATION_TYPE = FieldManyToOne.create(type, NdTypeSignature.ANNOTATIONS_OF_THIS_TYPE);
 		ELEMENT_VALUE_PAIRS = FieldOneToMany.create(type, NdAnnotationValuePair.APPLIES_TO);
-		PARENT_CONSTANT = FieldOneToOne.createOwner(type, NdConstantAnnotation.class, NdConstantAnnotation.VALUE);
-		PARENT_TYPE_SIGNATURE = FieldManyToOne.createOwner(type, NdComplexTypeSignature.ANNOTATIONS);
-		PARENT_METHOD_PARAMETER = FieldManyToOne.createOwner(type, NdMethodParameter.ANNOTATIONS);
 		type.done();
 	}
 
@@ -48,41 +39,19 @@ public class NdAnnotation extends NdNode {
 		super(nd, address);
 	}
 
-	public NdAnnotation(Nd nd, NdTypeSignature type) {
+	public NdAnnotation(Nd nd) {
 		super(nd);
-
-		ANNOTATION_TYPE.put(getNd(), this.address, type);
-	}
-
-	public void setParent(NdBinding binding) {
-		PARENT_BINDING.put(getNd(), this.address, binding);
-	}
-
-	public void setParent(NdConstantAnnotation constant) {
-		PARENT_CONSTANT.put(getNd(), this.address, constant);
-	}
-
-	public void setParent(NdComplexTypeSignature signature) {
-		PARENT_TYPE_SIGNATURE.put(getNd(), this.address, signature);
 	}
 
 	public NdTypeSignature getType() {
 		return ANNOTATION_TYPE.get(getNd(), this.address);
 	}
 
-	public NdBinding getAppliesTo() {
-		return PARENT_BINDING.get(getNd(), this.address);
+	public void setType(NdTypeSignature type) {
+		ANNOTATION_TYPE.put(getNd(), this.address, type);
 	}
 
 	public List<NdAnnotationValuePair> getElementValuePairs() {
 		return ELEMENT_VALUE_PAIRS.asList(getNd(), this.address);
 	}
-
-	public void setParent(NdMethodParameter parameter) {
-		PARENT_METHOD_PARAMETER.put(getNd(), this.address, parameter);
-	}
-
-	public NdMethodParameter getMethodParameter() {
-		return PARENT_METHOD_PARAMETER.get(getNd(), this.address);
-	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInConstant.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInConstant.java
new file mode 100644
index 0000000..2328a49
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInConstant.java
@@ -0,0 +1,37 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java;
+
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.field.FieldOneToOne;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
+
+public class NdAnnotationInConstant extends NdAnnotation {
+	public static final FieldOneToOne<NdConstantAnnotation> OWNER;
+
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdAnnotationInConstant> type;
+
+	static {
+		type = StructDef.create(NdAnnotationInConstant.class, NdAnnotation.type);
+		OWNER = FieldOneToOne.createOwner(type, NdConstantAnnotation.class, NdConstantAnnotation.VALUE);
+		type.done();
+	}
+
+	public NdAnnotationInConstant(Nd nd, long address) {
+		super(nd, address);
+	}
+
+	public NdAnnotationInConstant(Nd nd) {
+		super(nd);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInMethod.java
new file mode 100644
index 0000000..e7e48eb
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInMethod.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java;
+
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
+
+public class NdAnnotationInMethod extends NdAnnotation {
+	public static final FieldManyToOne<NdMethod> OWNER;
+
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdAnnotationInMethod> type;
+
+	static {
+		type = StructDef.create(NdAnnotationInMethod.class, NdAnnotation.type);
+		OWNER = FieldManyToOne.createOwner(type, NdMethod.ANNOTATIONS);
+		type.done();
+	}
+
+	public NdAnnotationInMethod(Nd nd, long address) {
+		super(nd, address);
+	}
+
+	public NdAnnotationInMethod(Nd nd, NdMethod owner) {
+		super(nd);
+
+		OWNER.put(getNd(), this.address, owner);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInMethodParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInMethodParameter.java
new file mode 100644
index 0000000..0a4f3fb
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInMethodParameter.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java;
+
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
+
+public class NdAnnotationInMethodParameter extends NdAnnotation {
+	public static final FieldManyToOne<NdMethodParameter> OWNER;
+
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdAnnotationInMethodParameter> type;
+
+	static {
+		type = StructDef.create(NdAnnotationInMethodParameter.class, NdAnnotation.type);
+		OWNER = FieldManyToOne.createOwner(type, NdMethodParameter.ANNOTATIONS);
+		type.done();
+	}
+
+	public NdAnnotationInMethodParameter(Nd nd, long address) {
+		super(nd, address);
+	}
+
+	public NdAnnotationInMethodParameter(Nd nd, NdMethodParameter owner) {
+		super(nd);
+
+		OWNER.put(getNd(), this.address, owner);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInType.java
new file mode 100644
index 0000000..c220ed9
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInType.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java;
+
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
+
+public class NdAnnotationInType extends NdAnnotation {
+	public static final FieldManyToOne<NdType> OWNER;
+
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdAnnotationInType> type;
+
+	static {
+		type = StructDef.create(NdAnnotationInType.class, NdAnnotation.type);
+		OWNER = FieldManyToOne.createOwner(type, NdType.ANNOTATIONS);
+		type.done();
+	}
+
+	public NdAnnotationInType(Nd nd, long address) {
+		super(nd, address);
+	}
+
+	public NdAnnotationInType(Nd nd, NdType owner) {
+		super(nd);
+
+		OWNER.put(getNd(), this.address, owner);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInVariable.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInVariable.java
new file mode 100644
index 0000000..378b2d4
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdAnnotationInVariable.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java;
+
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
+
+public class NdAnnotationInVariable extends NdAnnotation {
+	public static final FieldManyToOne<NdVariable> OWNER;
+
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdAnnotationInVariable> type;
+
+	static {
+		type = StructDef.create(NdAnnotationInVariable.class, NdAnnotation.type);
+		OWNER = FieldManyToOne.createOwner(type, NdVariable.ANNOTATIONS);
+		type.done();
+	}
+
+	public NdAnnotationInVariable(Nd nd, long address) {
+		super(nd, address);
+	}
+
+	public NdAnnotationInVariable(Nd nd, NdVariable owner) {
+		super(nd);
+
+		OWNER.put(getNd(), this.address, owner);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
index 9e4ad65..d623524 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
+ * Copyright (c) 2015, 2016 Google, Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -28,7 +28,6 @@ import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
  * @since 3.12
  */
 public abstract class NdBinding extends NdNode implements IAdaptable {
-	public static final FieldOneToMany<NdAnnotation> ANNOTATIONS;
 	public static final FieldInt MODIFIERS;
 	public static final FieldOneToMany<NdTypeParameter> TYPE_PARAMETERS;
 	public static final FieldManyToOne<NdResourceFile> FILE;
@@ -39,7 +38,6 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 
 	static {
 		type = StructDef.create(NdBinding.class, NdNode.type);
-		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotation.PARENT_BINDING);
 		MODIFIERS = type.addInt();
 		TYPE_PARAMETERS = FieldOneToMany.create(type, NdTypeParameter.PARENT);
 		FILE = FieldManyToOne.createOwner(type, NdResourceFile.ALL_NODES);
@@ -79,10 +77,6 @@ public abstract class NdBinding extends NdNode implements IAdaptable {
 		return MODIFIERS.get(getNd(), this.address);
 	}
 
-	public List<NdAnnotation> getAnnotations() {
-		return ANNOTATIONS.asList(getNd(), this.address);
-	}
-
 	@Override
 	@SuppressWarnings({ "unchecked", "rawtypes" })
 	public Object getAdapter(Class adapter) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
index 82eb0c1..d460edf 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdComplexTypeSignature.java
@@ -1,3 +1,13 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.java;
 
 import java.util.ArrayList;
@@ -26,7 +36,6 @@ import org.eclipse.jdt.internal.core.util.CharArrayBuffer;
 public class NdComplexTypeSignature extends NdTypeSignature {
 	public static final FieldString VARIABLE_IDENTIFIER;
 	public static final FieldManyToOne<NdTypeId> RAW_TYPE;
-	public static final FieldOneToMany<NdAnnotation> ANNOTATIONS;
 	public static final FieldOneToMany<NdTypeArgument> TYPE_ARGUMENTS;
 	public static final FieldManyToOne<NdComplexTypeSignature> DECLARING_TYPE;
 	public static final FieldOneToMany<NdComplexTypeSignature> DECLARED_TYPES;
@@ -38,7 +47,6 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 		type = StructDef.create(NdComplexTypeSignature.class, NdTypeSignature.type);
 		VARIABLE_IDENTIFIER = type.addString();
 		RAW_TYPE = FieldManyToOne.create(type, NdTypeId.USED_AS_COMPLEX_TYPE);
-		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotation.PARENT_TYPE_SIGNATURE);
 		TYPE_ARGUMENTS = FieldOneToMany.create(type, NdTypeArgument.PARENT);
 		DECLARING_TYPE = FieldManyToOne.create(type, null);
 		DECLARED_TYPES = FieldOneToMany.create(type, DECLARING_TYPE);
@@ -96,11 +104,6 @@ public class NdComplexTypeSignature extends NdTypeSignature {
 	}
 
 	@Override
-	public List<NdAnnotation> getAnnotations() {
-		return ANNOTATIONS.asList(getNd(), this.address);
-	}
-
-	@Override
 	public NdTypeSignature getArrayDimensionType() {
 		if (isArrayType()) {
 			long size = TYPE_ARGUMENTS.size(getNd(), this.address);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
index 0836034..008d491 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdConstantAnnotation.java
@@ -9,14 +9,14 @@ import org.eclipse.jdt.internal.core.nd.field.StructDef;
  * @since 3.12
  */
 public final class NdConstantAnnotation extends NdConstant {
-	public static final FieldOneToOne<NdAnnotation> VALUE;
+	public static final FieldOneToOne<NdAnnotationInConstant> VALUE;
 
 	@SuppressWarnings("hiding")
 	public static StructDef<NdConstantAnnotation> type;
 
 	static {
 		type = StructDef.create(NdConstantAnnotation.class, NdConstant.type);
-		VALUE = FieldOneToOne.create(type, NdAnnotation.class, NdAnnotation.PARENT_CONSTANT);
+		VALUE = FieldOneToOne.create(type, NdAnnotationInConstant.class, NdAnnotationInConstant.OWNER);
 		type.done();
 	}
 
@@ -28,13 +28,13 @@ public final class NdConstantAnnotation extends NdConstant {
 		super(nd);
 	}
 
-	public static NdConstantAnnotation create(Nd nd, NdAnnotation value) {
+	public static NdConstantAnnotation create(Nd nd, NdAnnotationInConstant value) {
 		NdConstantAnnotation result = new NdConstantAnnotation(nd);
 		result.setValue(value);
 		return result;
 	}
 
-	public void setValue(NdAnnotation value) {
+	public void setValue(NdAnnotationInConstant value) {
 		VALUE.put(getNd(), this.address, value);
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
index c27059d..0e47ef5 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethod.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
+ * Copyright (c) 2015, 2016 Google, Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -35,6 +35,8 @@ public class NdMethod extends NdBinding {
 	public static final FieldOneToMany<NdMethodException> EXCEPTIONS;
 	public static final FieldManyToOne<NdTypeSignature> RETURN_TYPE;
 	public static final FieldLong TAG_BITS;
+	public static final FieldOneToMany<NdAnnotationInMethod> ANNOTATIONS;
+	public static final FieldOneToMany<NdTypeAnnotationInMethod> TYPE_ANNOTATIONS;
 
 	@SuppressWarnings("hiding")
 	public static final StructDef<NdMethod> type;
@@ -50,6 +52,8 @@ public class NdMethod extends NdBinding {
 		EXCEPTIONS = FieldOneToMany.create(type, NdMethodException.PARENT);
 		RETURN_TYPE = FieldManyToOne.create(type, NdTypeSignature.USED_AS_RETURN_TYPE);
 		TAG_BITS = type.addLong();
+		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotationInMethod.OWNER);
+		TYPE_ANNOTATIONS = FieldOneToMany.create(type, NdTypeAnnotationInMethod.OWNER);
 		type.done();
 	}
 
@@ -93,6 +97,10 @@ public class NdMethod extends NdBinding {
 		return PARAMETERS.asList(getNd(), this.address);
 	}
 
+	public List<NdAnnotationInMethod> getAnnotations() {
+		return ANNOTATIONS.asList(getNd(), this.address);
+	}
+
 	public void setDefaultValue(NdConstant value) {
 		DEFAULT_VALUE.put(getNd(), this.address, value);
 	}
@@ -109,6 +117,10 @@ public class NdMethod extends NdBinding {
 		METHOD_ID.put(getNd(), this.address, methodId);
 	}
 
+	public List<NdTypeAnnotationInMethod> getTypeAnnotations() {
+		return TYPE_ANNOTATIONS.asList(getNd(), this.address);
+	}
+
 	public List<NdMethodException> getExceptions() {
 		return EXCEPTIONS.asList(getNd(), this.address);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
index b22a2e7..7c2c2d0 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdMethodParameter.java
@@ -1,3 +1,13 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.java;
 
 import java.util.List;
@@ -19,7 +29,7 @@ public class NdMethodParameter extends NdNode {
 	public static final FieldManyToOne<NdMethod> PARENT;
 	public static final FieldManyToOne<NdTypeSignature> ARGUMENT_TYPE;
 	public static final FieldString NAME;
-	public static final FieldOneToMany<NdAnnotation> ANNOTATIONS;
+	public static final FieldOneToMany<NdAnnotationInMethodParameter> ANNOTATIONS;
 	public static final FieldByte FLAGS;
 
 	private static final byte FLG_COMPILER_DEFINED = 0x01;
@@ -32,7 +42,7 @@ public class NdMethodParameter extends NdNode {
 		PARENT = FieldManyToOne.create(type, NdMethod.PARAMETERS);
 		ARGUMENT_TYPE = FieldManyToOne.create(type, NdTypeSignature.USED_AS_METHOD_ARGUMENT);
 		NAME = type.addString();
-		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotation.PARENT_METHOD_PARAMETER);
+		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotationInMethodParameter.OWNER);
 		FLAGS = type.addByte();
 		type.done();
 	}
@@ -60,7 +70,7 @@ public class NdMethodParameter extends NdNode {
 		return NAME.get(getNd(), this.address);
 	}
 
-	public List<NdAnnotation> getAnnotations() {
+	public List<NdAnnotationInMethodParameter> getAnnotations() {
 		return ANNOTATIONS.asList(getNd(), this.address);
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
index 61b2468..a759d5e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
+ * Copyright (c) 2015, 2016 Google, Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -34,6 +34,8 @@ public class NdType extends NdBinding {
 	public static final FieldManyToOne<NdTypeId> DECLARING_TYPE;
 	public static final FieldManyToOne<NdMethodId> DECLARING_METHOD;
 	public static final FieldOneToMany<NdMethod> METHODS;
+	public static final FieldOneToMany<NdTypeAnnotationInType> TYPE_ANNOTATIONS;
+	public static final FieldOneToMany<NdAnnotationInType> ANNOTATIONS;
 	public static final FieldString MISSING_TYPE_NAMES;
 	public static final FieldString SOURCE_FILE_NAME;
 	public static final FieldString INNER_CLASS_SOURCE_NAME;
@@ -57,6 +59,8 @@ public class NdType extends NdBinding {
 		SUPERCLASS = FieldManyToOne.create(type, NdTypeSignature.SUBCLASSES);
 		DECLARING_METHOD = FieldManyToOne.create(type, NdMethodId.DECLARED_TYPES);
 		METHODS = FieldOneToMany.create(type, NdMethod.PARENT, 6);
+		TYPE_ANNOTATIONS = FieldOneToMany.create(type, NdTypeAnnotationInType.OWNER);
+		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotationInType.OWNER);
 		MISSING_TYPE_NAMES = type.addString();
 		SOURCE_FILE_NAME = type.addString();
 		INNER_CLASS_SOURCE_NAME = type.addString();
@@ -217,6 +221,14 @@ public class NdType extends NdBinding {
 		return TYPE_PARAMETERS.asList(getNd(), this.address);
 	}
 
+	public List<NdTypeAnnotationInType> getTypeAnnotations() {
+		return TYPE_ANNOTATIONS.asList(getNd(), this.address);
+	}
+
+	public List<NdAnnotationInType> getAnnotations() {
+		return ANNOTATIONS.asList(getNd(), this.address);
+	}
+
 	public List<NdMethod> getMethods() {
 		return METHODS.asList(getNd(), this.address);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotation.java
new file mode 100644
index 0000000..b55ce4a
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotation.java
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java;
+
+import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.db.Database;
+import org.eclipse.jdt.internal.core.nd.field.FieldByte;
+import org.eclipse.jdt.internal.core.nd.field.FieldPointer;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
+
+public class NdTypeAnnotation extends NdAnnotation {
+	public static final FieldByte TARGET_TYPE;
+	public static final FieldByte TARGET_ARG0;
+	public static final FieldByte TARGET_ARG1;
+	public static final FieldByte PATH_LENGTH;
+	public static final FieldPointer PATH;
+
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdTypeAnnotation> type;
+
+	static {
+		type = StructDef.create(NdTypeAnnotation.class, NdAnnotation.type);
+		TARGET_TYPE = type.addByte();
+		TARGET_ARG0 = type.addByte();
+		TARGET_ARG1 = type.addByte();
+		PATH_LENGTH = type.addByte();
+		PATH = type.addPointer();
+		type.done();
+	}
+
+	private static final byte[] NO_TYPE_PATH = new byte[0];
+
+	public NdTypeAnnotation(Nd nd, long address) {
+		super(nd, address);
+	}
+
+	public NdTypeAnnotation(Nd nd) {
+		super(nd);
+	}
+
+	public void setPath(byte[] path) {
+		freePath();
+		Nd nd = getNd();
+		PATH_LENGTH.put(nd, this.address, (byte)path.length);
+		if (path.length > 0) {
+			long pathArray = nd.getDB().malloc(path.length, Database.POOL_MISC);
+			PATH.put(nd, this.address, pathArray);
+			nd.getDB().putBytes(pathArray, path, path.length);
+		}
+	}
+
+	public void setTargetInfo(int arg) {
+		TARGET_ARG0.put(getNd(), this.address, (byte)((arg >> 8) & 0xff));
+		TARGET_ARG1.put(getNd(), this.address, (byte)(arg & 0xff));
+	}
+
+	public byte getTargetInfoArg0() {
+		return TARGET_ARG0.get(getNd(), this.address);
+	}
+
+	public byte getTargetInfoArg1() {
+		return TARGET_ARG1.get(getNd(), this.address);
+	}
+
+	public int getTarget() {
+		return (TARGET_ARG0.get(getNd(), this.address) << 8) & TARGET_ARG1.get(getNd(), this.address);
+	}
+
+	public void setTargetInfo(byte arg0, byte arg1) {
+		TARGET_ARG0.put(getNd(), this.address, arg0);
+		TARGET_ARG1.put(getNd(), this.address, arg1);
+	}
+
+	/**
+	 * @param targetType one of the constants from {@link AnnotationTargetTypeConstants}
+	 */
+	public void setTargetType(int targetType) {
+		TARGET_TYPE.put(getNd(), this.address, (byte)targetType);
+	}
+
+	/**
+	 * @return one of the constants from {@link AnnotationTargetTypeConstants}
+	 */
+	public int getTargetType() {
+		return TARGET_TYPE.get(getNd(), this.address);
+	}
+
+	public byte[] getTypePath() {
+		long pathPointer = PATH.get(getNd(), this.address);
+		if (pathPointer == 0) {
+			return NO_TYPE_PATH;
+		}
+		int pathLength = PATH_LENGTH.get(getNd(), this.address);
+		byte[] result = new byte[pathLength];
+		getNd().getDB().getBytes(pathPointer, result);
+		return result;
+	}
+
+	@Override
+	public void destruct() {
+		freePath();
+		super.destruct();
+	}
+
+	private void freePath() {
+		Nd nd = getNd();
+		long pathPointer = PATH.get(nd, this.address);
+		nd.getDB().free(pathPointer, Database.POOL_MISC);
+	}
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInMethod.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInMethod.java
new file mode 100644
index 0000000..894a1d5
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInMethod.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java;
+
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
+
+public class NdTypeAnnotationInMethod extends NdTypeAnnotation {
+	public static final FieldManyToOne<NdMethod> OWNER;
+
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdTypeAnnotationInMethod> type;
+
+	static {
+		type = StructDef.create(NdTypeAnnotationInMethod.class, NdTypeAnnotation.type);
+		OWNER = FieldManyToOne.createOwner(type, NdMethod.TYPE_ANNOTATIONS);
+		type.done();
+	}
+
+	public NdTypeAnnotationInMethod(Nd nd, long address) {
+		super(nd, address);
+	}
+
+	public NdTypeAnnotationInMethod(Nd nd, NdMethod variable) {
+		super(nd);
+
+		OWNER.put(getNd(), this.address, variable);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInType.java
new file mode 100644
index 0000000..7aff109
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInType.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java;
+
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
+
+public class NdTypeAnnotationInType extends NdTypeAnnotation {
+	public static final FieldManyToOne<NdType> OWNER;
+
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdTypeAnnotationInType> type;
+
+	static {
+		type = StructDef.create(NdTypeAnnotationInType.class, NdTypeAnnotation.type);
+		OWNER = FieldManyToOne.createOwner(type, NdType.TYPE_ANNOTATIONS);
+		type.done();
+	}
+
+	public NdTypeAnnotationInType(Nd nd, long address) {
+		super(nd, address);
+	}
+
+	public NdTypeAnnotationInType(Nd nd, NdType type) {
+		super(nd);
+
+		OWNER.put(getNd(), this.address, type);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInVariable.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInVariable.java
new file mode 100644
index 0000000..eb591fe
--- /dev/null
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotationInVariable.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.nd.java;
+
+import org.eclipse.jdt.internal.core.nd.Nd;
+import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.nd.field.StructDef;
+
+public class NdTypeAnnotationInVariable extends NdTypeAnnotation {
+	public static final FieldManyToOne<NdVariable> OWNER;
+
+	@SuppressWarnings("hiding")
+	public static final StructDef<NdTypeAnnotationInVariable> type;
+
+	static {
+		type = StructDef.create(NdTypeAnnotationInVariable.class, NdTypeAnnotation.type);
+		OWNER = FieldManyToOne.createOwner(type, NdVariable.TYPE_ANNOTATIONS);
+		type.done();
+	}
+
+	public NdTypeAnnotationInVariable(Nd nd, long address) {
+		super(nd, address);
+	}
+
+	public NdTypeAnnotationInVariable(Nd nd, NdVariable variable) {
+		super(nd);
+
+		OWNER.put(getNd(), this.address, variable);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
index 2f86f85..21815fe 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeId.java
@@ -1,3 +1,13 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.java;
 
 import java.util.ArrayList;
@@ -142,11 +152,6 @@ public class NdTypeId extends NdTypeSignature {
 	}
 
 	@Override
-	public List<NdAnnotation> getAnnotations() {
-		return Collections.emptyList();
-	}
-
-	@Override
 	public void getSignature(CharArrayBuffer result, boolean includeTrailingSemicolon) {
 		if (includeTrailingSemicolon) {
 			result.append(getFieldDescriptor().getChars());
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
index 4ee92e4..f4f5bb3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeSignature.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
+ * Copyright (c) 2015, 2016 Google, Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -105,11 +105,6 @@ public abstract class NdTypeSignature extends NdNode {
 	 */
 	public abstract NdTypeId getRawType();
 
-	/**
-	 * Returns the set of type annotations attached to this type signature
-	 */
-	public abstract List<NdAnnotation> getAnnotations();
-
 	public final void getSignature(CharArrayBuffer result) {
 		getSignature(result, true);
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
index f8117b0..b43ca6e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdVariable.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
+ * Copyright (c) 2015, 2016 Google, Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,12 +10,15 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.java;
 
+import java.util.List;
+
 import org.eclipse.jdt.internal.core.nd.Nd;
 import org.eclipse.jdt.internal.core.nd.db.IString;
 import org.eclipse.jdt.internal.core.nd.field.FieldByte;
 import org.eclipse.jdt.internal.core.nd.field.FieldInt;
 import org.eclipse.jdt.internal.core.nd.field.FieldLong;
 import org.eclipse.jdt.internal.core.nd.field.FieldManyToOne;
+import org.eclipse.jdt.internal.core.nd.field.FieldOneToMany;
 import org.eclipse.jdt.internal.core.nd.field.FieldOneToOne;
 import org.eclipse.jdt.internal.core.nd.field.FieldString;
 import org.eclipse.jdt.internal.core.nd.field.StructDef;
@@ -32,6 +35,8 @@ public class NdVariable extends NdBinding {
 	public static final FieldOneToOne<NdConstant> CONSTANT;
 	public static final FieldLong TAG_BITS;
 	public static final FieldByte VARIABLE_FLAGS;
+	public static final FieldOneToMany<NdAnnotationInVariable> ANNOTATIONS;
+	public static final FieldOneToMany<NdTypeAnnotationInVariable> TYPE_ANNOTATIONS;
 
 	@SuppressWarnings("hiding")
 	public static StructDef<NdVariable> type;
@@ -48,6 +53,8 @@ public class NdVariable extends NdBinding {
 		CONSTANT = FieldOneToOne.create(type, NdConstant.class, NdConstant.PARENT_VARIABLE);
 		TAG_BITS = type.addLong();
 		VARIABLE_FLAGS = type.addByte();
+		ANNOTATIONS = FieldOneToMany.create(type, NdAnnotationInVariable.OWNER);
+		TYPE_ANNOTATIONS = FieldOneToMany.create(type, NdTypeAnnotationInVariable.OWNER);
 		type.done();
 	}
 
@@ -102,6 +109,14 @@ public class NdVariable extends NdBinding {
 		TAG_BITS.put(getNd(), this.address, tagBits);
 	}
 
+	public List<NdTypeAnnotationInVariable> getTypeAnnotations() {
+		return TYPE_ANNOTATIONS.asList(getNd(), this.address);
+	}
+
+	public List<NdAnnotationInVariable> getAnnotations() {
+		return ANNOTATIONS.asList(getNd(), this.address);
+	}
+
 	public String toString() {
 		try {
 			StringBuilder result = new StringBuilder();
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index 48617cf..33f09e9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -6,6 +6,7 @@ import java.util.List;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.BinaryTypeFormatter;
 import org.eclipse.jdt.internal.compiler.classfmt.ElementValuePairInfo;
+import org.eclipse.jdt.internal.compiler.codegen.AnnotationTargetTypeConstants;
 import org.eclipse.jdt.internal.compiler.env.ClassSignature;
 import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
 import org.eclipse.jdt.internal.compiler.env.IBinaryAnnotation;
@@ -34,8 +35,7 @@ import org.eclipse.jdt.internal.core.nd.java.NdMethodId;
 import org.eclipse.jdt.internal.core.nd.java.NdMethodParameter;
 import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
 import org.eclipse.jdt.internal.core.nd.java.NdType;
-import org.eclipse.jdt.internal.core.nd.java.NdTypeArgument;
-import org.eclipse.jdt.internal.core.nd.java.NdTypeBound;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeAnnotation;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeId;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeInterface;
 import org.eclipse.jdt.internal.core.nd.java.NdTypeParameter;
@@ -66,6 +66,7 @@ public class IndexBinaryType implements IBinaryType {
 	private char[] binaryTypeName;
 
 	private static final IBinaryAnnotation[] NO_ANNOTATIONS = new IBinaryAnnotation[0];
+	private static final int[] NO_PATH = new int[0];
 
 	public IndexBinaryType(TypeRef type, char[] indexPath) {
 		this.typeRef = type;
@@ -105,7 +106,7 @@ public class IndexBinaryType implements IBinaryType {
 		}
 	}
 
-	private static IBinaryAnnotation[] toAnnotationArray(List<NdAnnotation> annotations) {
+	private static IBinaryAnnotation[] toAnnotationArray(List<? extends NdAnnotation> annotations) {
 		if (annotations.isEmpty()) {
 			return NO_ANNOTATIONS;
 		}
@@ -119,26 +120,13 @@ public class IndexBinaryType implements IBinaryType {
 
 	@Override
 	public IBinaryTypeAnnotation[] getTypeAnnotations() {
-		List<IBinaryTypeAnnotation> result = new ArrayList<>();
-		ITypeAnnotationBuilder annotationBuilder = TypeAnnotationBuilder.create();
 		try (IReader rl = this.typeRef.lock()) {
 			NdType type = this.typeRef.get();
 			if (type != null) {
-				NdTypeSignature superclass = type.getSuperclass();
-				if (superclass != null) {
-					buildAnnotations(result, annotationBuilder.toSupertype((short)-1), superclass);
-				}
-
-				List<NdTypeInterface> interfaces = type.getInterfaces();
-
-				for (short interfaceIdx = 0; interfaceIdx < interfaces.size(); interfaceIdx++) {
-					NdTypeInterface next = interfaces.get(interfaceIdx);
-
-					buildAnnotations(result, annotationBuilder.toSupertype(interfaceIdx), next.getInterface());
-				}
+				return createBinaryTypeAnnotations(type.getTypeAnnotations());
 			}
 		}
-		return toTypeAnnotationArray(result);
+		return null;
 	}
 
 	@Override
@@ -384,43 +372,6 @@ public class IndexBinaryType implements IBinaryType {
 	private IBinaryMethod createBinaryMethod(NdMethod ndMethod) {
 		NdMethodId methodId = ndMethod.getMethodId();
 
-		List<IBinaryTypeAnnotation> typeAnnotations = new ArrayList<>();
-		ITypeAnnotationBuilder annotationBuilder = TypeAnnotationBuilder.create();
-
-		List<NdTypeParameter> typeParameters = ndMethod.getTypeParameters();
-		for (int parameterIdx = 0; parameterIdx < typeParameters.size(); parameterIdx++) {
-			NdTypeParameter next = typeParameters.get(parameterIdx);
-
-			List<NdTypeBound> bounds = next.getBounds();
-			for (int boundsIdx = 0; boundsIdx < bounds.size(); boundsIdx++) {
-				NdTypeBound nextBound = bounds.get(boundsIdx);
-
-				NdTypeSignature type = nextBound.getType();
-
-				if (type != null) {
-					buildAnnotations(typeAnnotations,
-							annotationBuilder.toTypeParameter(false, parameterIdx).toTypeBound((short) boundsIdx),
-							type);
-				}
-			}
-		}
-
-		List<NdMethodParameter> args = ndMethod.getMethodParameters();
-		for (int argIdx = 0; argIdx < args.size(); argIdx++) {
-			buildAnnotations(typeAnnotations, annotationBuilder.toMethodParameter((short) argIdx),
-					args.get(argIdx).getType().getAnnotations());
-		}
-
-		buildAnnotations(typeAnnotations, annotationBuilder.toMethodReturn(), ndMethod.getReturnType());
-
-		List<NdMethodException> exceptions = ndMethod.getExceptions();
-
-		for (int exceptionIdx = 0; exceptionIdx < exceptions.size(); exceptionIdx++) {
-			NdMethodException next = exceptions.get(exceptionIdx);
-
-			buildAnnotations(typeAnnotations, annotationBuilder.toThrows(exceptionIdx), next.getExceptionType());
-		}
-
 		return IndexBinaryMethod.create().setAnnotations(toAnnotationArray(ndMethod.getAnnotations()))
 				.setModifiers(ndMethod.getModifiers()).setIsConstructor(methodId.isConstructor())
 				.setArgumentNames(getArgumentNames(ndMethod)).setDefaultValue(unpackValue(ndMethod.getDefaultValue()))
@@ -429,7 +380,58 @@ public class IndexBinaryType implements IBinaryType {
 				.setMethodDescriptor(methodId.getMethodDescriptor())
 				.setParameterAnnotations(getParameterAnnotations(ndMethod))
 				.setSelector(ndMethod.getMethodId().getSelector()).setTagBits(ndMethod.getTagBits())
-				.setIsClInit(methodId.isClInit()).setTypeAnnotations(toTypeAnnotationArray(typeAnnotations));
+				.setIsClInit(methodId.isClInit()).setTypeAnnotations(createBinaryTypeAnnotations(ndMethod.getTypeAnnotations()));
+	}
+
+	private static IBinaryTypeAnnotation[] createBinaryTypeAnnotations(List<? extends NdTypeAnnotation> typeAnnotations) {
+		IBinaryTypeAnnotation[] result = new IBinaryTypeAnnotation[typeAnnotations.size()];
+		int idx = 0;
+		for (NdTypeAnnotation next : typeAnnotations) {
+			IBinaryAnnotation annotation = createBinaryAnnotation(next);
+			int[] typePath = getTypePath(next.getTypePath());
+			int info = 0;
+			int info2 = 0;
+			switch (next.getTargetType()) {
+				case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER:
+				case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER:
+					info = next.getTargetInfoArg0();
+					break;
+				case AnnotationTargetTypeConstants.CLASS_EXTENDS:
+					info = next.getTarget();
+					break;
+				case AnnotationTargetTypeConstants.CLASS_TYPE_PARAMETER_BOUND:
+				case AnnotationTargetTypeConstants.METHOD_TYPE_PARAMETER_BOUND:
+					info = next.getTargetInfoArg0();
+					info2 = next.getTargetInfoArg1();
+					break;
+				case AnnotationTargetTypeConstants.FIELD:
+				case AnnotationTargetTypeConstants.METHOD_RETURN:
+				case AnnotationTargetTypeConstants.METHOD_RECEIVER:
+					break;
+				case AnnotationTargetTypeConstants.METHOD_FORMAL_PARAMETER :
+					info = next.getTargetInfoArg0();
+					break;
+				case AnnotationTargetTypeConstants.THROWS :
+					info = next.getTarget();
+					break;
+
+				default:
+					throw new IllegalStateException("Target type not handled " + next.getTargetType()); //$NON-NLS-1$
+			}
+			result[idx++] = new IndexBinaryTypeAnnotation(next.getTargetType(), info, info2, typePath, annotation);
+		}
+		return result;
+	}
+
+	private static int[] getTypePath(byte[] typePath) {
+		if (typePath.length == 0) {
+			return NO_PATH;
+		}
+		int[] result = new int[typePath.length];
+		for (int idx = 0; idx < typePath.length; idx++) {
+			result[idx] = typePath[idx];
+		}
+		return result;
 	}
 
 	private static char[] getGenericSignatureFor(NdMethod method) {
@@ -460,11 +462,6 @@ public class IndexBinaryType implements IBinaryType {
 		return result;
 	}
 
-	private IBinaryTypeAnnotation[] toTypeAnnotationArray(List<IBinaryTypeAnnotation> result) {
-		return result.isEmpty() ? null
-				: (IBinaryTypeAnnotation[]) result.toArray(new IBinaryTypeAnnotation[result.size()]);
-	}
-
 	private IBinaryAnnotation[][] getParameterAnnotations(NdMethod ndMethod) {
 		List<NdMethodParameter> parameters = ndMethod.getMethodParameters();
 		if (parameters.isEmpty()) {
@@ -527,11 +524,9 @@ public class IndexBinaryType implements IBinaryType {
 			constant = Constant.NotAConstant;
 		}
 
-		List<IBinaryTypeAnnotation> typeAnnotations = new ArrayList<>();
 		NdTypeSignature type = ndVariable.getType();
-		buildAnnotations(typeAnnotations, TypeAnnotationBuilder.create(), type);
-		IBinaryTypeAnnotation[] typeAnnotationArray = typeAnnotations.isEmpty() ? null
-				: (IBinaryTypeAnnotation[]) typeAnnotations.toArray(new IBinaryTypeAnnotation[typeAnnotations.size()]);
+
+		IBinaryTypeAnnotation[] typeAnnotationArray = createBinaryTypeAnnotations(ndVariable.getTypeAnnotations());
 
 		IBinaryAnnotation[] annotations = toAnnotationArray(ndVariable.getAnnotations());
 
@@ -578,36 +573,6 @@ public class IndexBinaryType implements IBinaryType {
 	}
 
 	private static void buildAnnotations(List<IBinaryTypeAnnotation> result, ITypeAnnotationBuilder builder,
-			NdTypeSignature signature) {
-		if (signature == null) {
-			return;
-		}
-		ITypeAnnotationBuilder nextAnnotations = builder;
-		List<NdTypeSignature> declaringTypes = signature.getDeclaringTypeChain();
-
-		for (NdTypeSignature next : declaringTypes) {
-			buildAnnotations(result, nextAnnotations, next.getAnnotations());
-
-			NdTypeSignature arrayArgument = next.getArrayDimensionType();
-			if (arrayArgument != null) {
-				buildAnnotations(result, nextAnnotations.toNextArrayDimension(), arrayArgument);
-			}
-
-			List<NdTypeArgument> typeArguments = next.getTypeArguments();
-			for (int rank = 0; rank < typeArguments.size(); rank++) {
-				NdTypeArgument argument = typeArguments.get(rank);
-
-				NdTypeSignature argumentType = argument.getType();
-				if (argumentType != null) {
-					buildAnnotations(result, nextAnnotations.toTypeArgument(rank), argumentType);
-				}
-			}
-
-			nextAnnotations = nextAnnotations.toNextNestedType();
-		}
-	}
-
-	private static void buildAnnotations(List<IBinaryTypeAnnotation> result, ITypeAnnotationBuilder builder,
 			List<NdAnnotation> annotations) {
 		for (NdAnnotation next : annotations) {
 			result.add(builder.build(createBinaryAnnotation(next)));
commit 1da02ba933e4e683b41daf230f8fb806348215a7
Author: Stefan Xenos <sxenos@gmail.com>
Date:   Thu Sep 8 12:00:18 2016 -0700

    Bug 501034 - [newindex] Test failures in NullAnnotationModelTests
    
    Add additional test coverage, and a self-test diagnostic mode
    for the indexer.
    
    Remove the use of the word "new" in the trace option keys.
    
    Change-Id: I7b62eb9cdd84a724e9060439aa62935951f481e7
    Signed-off-by: Stefan Xenos <sxenos@gmail.com>

43	25	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/nd/indexer/IndexerTest.java
8	5	org.eclipse.jdt.core/.options
12	10	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
5	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
27	25	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
43	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
4	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotation.java
13	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/nd/indexer/IndexerTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/nd/indexer/IndexerTest.java
index acc7be2..478fc40 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/nd/indexer/IndexerTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/nd/indexer/IndexerTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
+ * Copyright (c) 2015, 2016 Google, Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -14,19 +14,15 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
 
-import org.eclipse.core.resources.IProject;
 import org.eclipse.core.resources.IWorkspaceRoot;
 import org.eclipse.core.resources.ResourcesPlugin;
 import org.eclipse.core.runtime.CoreException;
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.core.runtime.NullProgressMonitor;
 import org.eclipse.core.runtime.SubMonitor;
 import org.eclipse.jdt.core.IClassFile;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.IParent;
-import org.eclipse.jdt.core.JavaCore;
 import org.eclipse.jdt.core.tests.model.AbstractJavaModelTests;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.core.PackageFragment;
@@ -58,37 +54,31 @@ public class IndexerTest extends AbstractJavaModelTests {
 	private static JavaIndex index;
 
 	@Override
-	public void setUpSuite() throws Exception {
-		super.setUpSuite();
-		index = createIndex(new NullProgressMonitor());
+	protected void setUp() throws Exception {
+		String testName = getName();
+		index = JavaIndexTestUtil.createTempIndex(testName);
+		super.setUp();
 	}
 
 	@Override
-	public void tearDownSuite() throws Exception {
+	protected void tearDown() throws Exception {
 		deleteProject(PROJECT_NAME);
+		index.getNd().getPath().delete();
 		index = null;
-		super.tearDownSuite();
+		super.tearDown();
 	}
 
 	public static Test suite() {
 		return buildModelTestSuite(IndexerTest.class);
 	}
 
-	private JavaIndex createIndex(IProgressMonitor monitor) throws CoreException {
-		SubMonitor subMonitor = SubMonitor.convert(monitor, 1);
-		String testName = getName();
-		JavaIndex localIndex = JavaIndexTestUtil.createTempIndex(testName);
-
+	public void testSubclassesOfGenericTypeCanBeFound() throws Exception {
 		createJavaProject(PROJECT_NAME, new String[] {"src"}, new String[] {"JCL18_FULL"}, "bin", "1.8", true);
 		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
-		Indexer indexer = new Indexer(localIndex.getNd(), root);
+		Indexer indexer = new Indexer(index.getNd(), root);
 
-		indexer.rescan(subMonitor.split(1));
+		indexer.rescan(SubMonitor.convert(null));
 
-		return localIndex;
-	}
-
-	public void testSubclassesOfGenericTypeCanBeFound() throws Exception {
 		try (IReader reader = IndexerTest.index.getNd().acquireReadLock()) {
 			NdTypeId javaUtilList = IndexerTest.index.findType("Ljava/util/List;".toCharArray());
 			NdTypeId javaUtilArrayList = IndexerTest.index.findType("Ljava/util/ArrayList;".toCharArray());
@@ -120,14 +110,42 @@ public class IndexerTest extends AbstractJavaModelTests {
 	}
 
 	public void testReadingAllClassesInIndexAreEquivalentToOriginalJarFiles() throws Exception {
+		IJavaProject javaProject = createJavaProject(PROJECT_NAME, new String[] {"src"}, new String[] {"JCL18_FULL"}, "bin", "1.8", true);
+		addClassFolder(javaProject, "lib", new String[] {
+				"p/Outer.java",
+				"import java.lang.annotation.*;\n" +
+				"\n" +
+				"@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_USE) @interface A {}\n" +
+				"@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @interface M {}\n" +
+				"@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.PARAMETER) @interface P {}\n" +
+				"\n" +
+				"class Outer {\n" +
+				"    class Middle1 {\n" +
+				"        class Inner {}\n" +
+				"    }\n" +
+				"    static class Middle2 {\n" +
+				"        class Inner {}\n" +
+				"        static class Middle3 {\n" +
+				"            class Inner2{};\n" +
+				"        }\n" +
+				"    }\n" +
+				"    Middle1.@A Inner e1;\n" +
+				"    Middle2.@A Inner e2;\n" +
+				"    Middle2.Middle3.@A Inner2 e3;\n" +
+				"    @M void foo(@P Middle2.Middle3.@A Inner2 e3) {};\n" +
+				"    class Middle4 extends @A Middle1 {}\n" +
+				"}\n",
+			}, "1.8");
+
+		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
+		Indexer indexer = new Indexer(index.getNd(), root);
+
+		indexer.rescan(SubMonitor.convert(null));
+
 		boolean foundAtLeastOneClass = false;
 		SubMonitor subMonitor = SubMonitor.convert(null);
-		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
 		JavaIndex localIndex = IndexerTest.index;
 		try (IReader reader = localIndex.getNd().acquireReadLock()) {
-			IProject project = root.getProject(PROJECT_NAME);
-
-			IJavaProject javaProject = JavaCore.create(project);
 			IPackageFragmentRoot[] roots = javaProject.getAllPackageFragmentRoots();
 			subMonitor.setWorkRemaining(roots.length);
 			for (IPackageFragmentRoot next : roots) {
diff --git a/org.eclipse.jdt.core/.options b/org.eclipse.jdt.core/.options
index d5de535..204f71d 100644
--- a/org.eclipse.jdt.core/.options
+++ b/org.eclipse.jdt.core/.options
@@ -54,19 +54,22 @@ org.eclipse.jdt.core/debug/javamodel=false
 org.eclipse.jdt.core/debug/javamodel/cache=false
 
 # Prints information about when the indexer runs and what files are being indexed
-org.eclipse.jdt.core/debug/newindex/indexer=false
+org.eclipse.jdt.core/debug/index/indexer=false
 
 # Prints a line whenever a class is added to or removed from the index
-org.eclipse.jdt.core/debug/newindex/insertions=false
+org.eclipse.jdt.core/debug/index/insertions=false
 
 # Prints diagnostic information about index database locks
-org.eclipse.jdt.core/debug/newindex/locks=false
+org.eclipse.jdt.core/debug/index/locks=false
 
 # Prints statistics about database memory usage
-org.eclipse.jdt.core/debug/newindex/space=false
+org.eclipse.jdt.core/debug/index/space=false
+
+# Performs self-testing during indexing by reading back every class and comparing it with the original .class file
+org.eclipse.jdt.core/debug/index/selftest=false
 
 # Prints statistics about indexing time
-org.eclipse.jdt.core/debug/newindex/timing=false
+org.eclipse.jdt.core/debug/index/timing=false
 
 # Reports post actions addition/run
 org.eclipse.jdt.core/debug/postaction=false
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index 07402dd..6f854c1 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -358,11 +358,12 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 	private static final String SEARCH_DEBUG = JavaCore.PLUGIN_ID + "/debug/search" ; //$NON-NLS-1$
 	private static final String SOURCE_MAPPER_DEBUG_VERBOSE = JavaCore.PLUGIN_ID + "/debug/sourcemapper" ; //$NON-NLS-1$
 	private static final String FORMATTER_DEBUG = JavaCore.PLUGIN_ID + "/debug/formatter" ; //$NON-NLS-1$
-	private static final String NEWINDEX_INDEXER_DEBUG = JavaCore.PLUGIN_ID + "/debug/newindex/indexer" ; //$NON-NLS-1$
-	private static final String NEWINDEX_INDEXER_INSERTIONS = JavaCore.PLUGIN_ID + "/debug/newindex/insertions" ; //$NON-NLS-1$
-	private static final String NEWINDEX_LOCKS_DEBUG = JavaCore.PLUGIN_ID + "/debug/newindex/locks" ; //$NON-NLS-1$
-	private static final String NEWINDEX_INDEXER_SPACE = JavaCore.PLUGIN_ID + "/debug/newindex/space" ; //$NON-NLS-1$
-	private static final String NEWINDEX_INDEXER_TIMING = JavaCore.PLUGIN_ID + "/debug/newindex/timing" ; //$NON-NLS-1$
+	private static final String INDEX_INDEXER_DEBUG = JavaCore.PLUGIN_ID + "/debug/index/indexer" ; //$NON-NLS-1$
+	private static final String INDEX_INDEXER_INSERTIONS = JavaCore.PLUGIN_ID + "/debug/index/insertions" ; //$NON-NLS-1$
+	private static final String INDEX_INDEXER_SELFTEST = JavaCore.PLUGIN_ID + "/debug/index/selftest" ; //$NON-NLS-1$
+	private static final String INDEX_LOCKS_DEBUG = JavaCore.PLUGIN_ID + "/debug/index/locks" ; //$NON-NLS-1$
+	private static final String INDEX_INDEXER_SPACE = JavaCore.PLUGIN_ID + "/debug/index/space" ; //$NON-NLS-1$
+	private static final String INDEX_INDEXER_TIMING = JavaCore.PLUGIN_ID + "/debug/index/timing" ; //$NON-NLS-1$
 
 	public static final String COMPLETION_PERF = JavaCore.PLUGIN_ID + "/perf/completion" ; //$NON-NLS-1$
 	public static final String SELECTION_PERF = JavaCore.PLUGIN_ID + "/perf/selection" ; //$NON-NLS-1$
@@ -1808,11 +1809,12 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 				JavaModelManager.ZIP_ACCESS_VERBOSE = debug && options.getBooleanOption(ZIP_ACCESS_DEBUG, false);
 				SourceMapper.VERBOSE = debug && options.getBooleanOption(SOURCE_MAPPER_DEBUG_VERBOSE, false);
 				DefaultCodeFormatter.DEBUG = debug && options.getBooleanOption(FORMATTER_DEBUG, false);
-				Indexer.DEBUG = debug && options.getBooleanOption(NEWINDEX_INDEXER_DEBUG, false);
-				Indexer.DEBUG_INSERTIONS = debug  && options.getBooleanOption(NEWINDEX_INDEXER_INSERTIONS, false);
-				Indexer.DEBUG_ALLOCATIONS = debug && options.getBooleanOption(NEWINDEX_INDEXER_SPACE, false);
-				Indexer.DEBUG_TIMING = debug && options.getBooleanOption(NEWINDEX_INDEXER_TIMING, false);
-				Nd.sDEBUG_LOCKS = debug && options.getBooleanOption(NEWINDEX_LOCKS_DEBUG, false);
+				Indexer.DEBUG = debug && options.getBooleanOption(INDEX_INDEXER_DEBUG, false);
+				Indexer.DEBUG_INSERTIONS = debug  && options.getBooleanOption(INDEX_INDEXER_INSERTIONS, false);
+				Indexer.DEBUG_ALLOCATIONS = debug && options.getBooleanOption(INDEX_INDEXER_SPACE, false);
+				Indexer.DEBUG_TIMING = debug && options.getBooleanOption(INDEX_INDEXER_TIMING, false);
+				Indexer.DEBUG_SELFTEST = debug && options.getBooleanOption(INDEX_INDEXER_SELFTEST, false);
+				Nd.sDEBUG_LOCKS = debug && options.getBooleanOption(INDEX_LOCKS_DEBUG, false);
 		
 				// configure performance options
 				if(PerformanceStats.ENABLED) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
index f8dc7da..98e9a69 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/Nd.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015 Google, Inc and others.
+ * Copyright (c) 2015, 2016 Google, Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -107,6 +107,10 @@ public class Nd {
 		}
 	}
 
+	public File getPath() {
+		return this.fPath;
+	}
+
 	public long getWriteNumber() {
 		return this.fWriteNumber;
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
index 018e658..c723385 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/IndexTester.java
@@ -1,9 +1,17 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.indexer;
 
 import java.util.Arrays;
-import java.util.HashSet;
 import java.util.Objects;
-import java.util.Set;
 
 import org.eclipse.jdt.internal.compiler.env.ClassSignature;
 import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
@@ -228,6 +236,13 @@ public class IndexTester {
 			return true;
 		}
 
+		if (o1 instanceof IBinaryTypeAnnotation) {
+			IBinaryTypeAnnotation binaryAnnotation = (IBinaryTypeAnnotation)o1;
+			IBinaryTypeAnnotation otherBinaryAnnotation = (IBinaryTypeAnnotation)o2;
+
+			return new TypeAnnotationWrapper(binaryAnnotation).equals(new TypeAnnotationWrapper(otherBinaryAnnotation));
+		}
+
 		if (o1 instanceof Constant) {
 			if (!(o2 instanceof Constant)) {
 				return false;
@@ -373,33 +388,20 @@ public class IndexTester {
 
 	private static void compareTypeAnnotations(String contextPrefix, IBinaryTypeAnnotation[] expectedTypeAnnotations,
 			IBinaryTypeAnnotation[] actualTypeAnnotations) {
-		Set<TypeAnnotationWrapper> expectedAnnotations = new HashSet<>();
-		if (expectedTypeAnnotations != null) {
-			for (IBinaryTypeAnnotation next : expectedTypeAnnotations) {
-				expectedAnnotations.add(new TypeAnnotationWrapper(next));
-			}
-		}
-
-		Set<TypeAnnotationWrapper> actualAnnotations = new HashSet<>();
-
-		if (actualTypeAnnotations != null) {
-			for (IBinaryTypeAnnotation next : actualTypeAnnotations) {
-				actualAnnotations.add(new TypeAnnotationWrapper(next));
+		if (expectedTypeAnnotations == null) {
+			if (actualTypeAnnotations != null) {
+				throw new IllegalStateException(contextPrefix + ": Expected null for the annotation list but found: " //$NON-NLS-1$
+						+ actualTypeAnnotations.toString());
 			}
+			return;
 		}
 
-		for (TypeAnnotationWrapper nextExpected : expectedAnnotations) {
-			if (!actualAnnotations.contains(nextExpected)) {
-				throw new IllegalStateException(contextPrefix + ": The index was missing an expected type annotation: " //$NON-NLS-1$
-						+ nextExpected.toString());
-			}
-		}
+		assertEquals(contextPrefix + ": The expected and actual number of type annotations did not match", //$NON-NLS-1$
+				expectedTypeAnnotations.length, actualTypeAnnotations.length);
 
-		for (TypeAnnotationWrapper nextActual : actualAnnotations) {
-			if (!expectedAnnotations.contains(nextActual)) {
-				throw new IllegalStateException(contextPrefix + ": The index contained an unexpected type annotation: " //$NON-NLS-1$
-						+ nextActual.toString());
-			}
+		for (int idx = 0; idx < expectedTypeAnnotations.length; idx++) {
+			assertEquals(contextPrefix + ": Type annotation number " + idx + " did not match", //$NON-NLS-1$//$NON-NLS-2$
+					expectedTypeAnnotations[idx], actualTypeAnnotations[idx]);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
index 7516304..08f8e9e 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/indexer/Indexer.java
@@ -1,3 +1,13 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.indexer;
 
 import java.io.File;
@@ -52,9 +62,12 @@ import org.eclipse.jdt.internal.core.nd.java.JavaIndex;
 import org.eclipse.jdt.internal.core.nd.java.NdBinding;
 import org.eclipse.jdt.internal.core.nd.java.NdResourceFile;
 import org.eclipse.jdt.internal.core.nd.java.NdType;
+import org.eclipse.jdt.internal.core.nd.java.NdTypeId;
 import org.eclipse.jdt.internal.core.nd.java.NdWorkspaceLocation;
+import org.eclipse.jdt.internal.core.nd.java.TypeRef;
 import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeDescriptor;
 import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeFactory;
+import org.eclipse.jdt.internal.core.nd.java.model.IndexBinaryType;
 import org.eclipse.jdt.internal.core.search.processing.IJob;
 
 public final class Indexer {
@@ -66,6 +79,7 @@ public final class Indexer {
 	public static boolean DEBUG_ALLOCATIONS;
 	public static boolean DEBUG_TIMING;
 	public static boolean DEBUG_INSERTIONS;
+	public static boolean DEBUG_SELFTEST;
 
 	/**
 	 * True iff automatic reindexing (that is, the {@link #rescanAll()} method) is disabled
@@ -709,6 +723,35 @@ public final class Indexer {
 				} finally {
 					this.nd.releaseWriteLock();
 				}
+
+				if (DEBUG_SELFTEST) {
+					// When this debug flag is on, we test everything written to the index by reading it back immediately after indexing
+					// and comparing it with the original class file.
+					JavaIndex index = JavaIndex.getIndex(this.nd);
+					try (IReader readLock = this.nd.acquireReadLock()) {
+						NdTypeId typeId = index.findType(descriptor.fieldDescriptor);
+						NdType targetType = null;
+						if (typeId != null) {
+							List<NdType> implementations = typeId.getTypes();
+							for (NdType nextType : implementations) {
+								NdResourceFile nextResourceFile = nextType.getResourceFile();
+								if (nextResourceFile.equals(resourceFile)) {
+									targetType = nextType;
+									break;
+								}
+							}
+						}
+
+						if (targetType != null) {
+							IndexBinaryType actualType = new IndexBinaryType(TypeRef.create(targetType), descriptor.indexPath);
+							IndexTester.testType(binaryType, actualType);
+						} else {
+							Package.logInfo("Could not find class in index immediately after indexing it: " + next.toString()); //$NON-NLS-1$
+						}
+					} catch (RuntimeException e) {
+						Package.log("Error during indexing: " + next.toString(), e); //$NON-NLS-1$
+					}
+				}
 			} catch (CoreException | ClassFormatException e) {
 				Package.log("Unable to index " + next.toString(), e); //$NON-NLS-1$
 			}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotation.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotation.java
index b55ce4a..e9bfa4a 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotation.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/NdTypeAnnotation.java
@@ -72,7 +72,10 @@ public class NdTypeAnnotation extends NdAnnotation {
 	}
 
 	public int getTarget() {
-		return (TARGET_ARG0.get(getNd(), this.address) << 8) & TARGET_ARG1.get(getNd(), this.address);
+		int arg0 = TARGET_ARG0.get(getNd(), this.address) & 0xff;
+		int arg1 = TARGET_ARG1.get(getNd(), this.address) & 0xff;
+		int result = (arg0 << 8) | arg1;
+		return result;
 	}
 
 	public void setTargetInfo(byte arg0, byte arg1) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index 33f09e9..3c51f90 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -1,3 +1,13 @@
+/*******************************************************************************
+ * Copyright (c) 2016 Google, Inc and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *   Stefan Xenos (Google) - Initial implementation
+ *******************************************************************************/
 package org.eclipse.jdt.internal.core.nd.java.model;
 
 import java.util.ArrayList;
@@ -384,6 +394,9 @@ public class IndexBinaryType implements IBinaryType {
 	}
 
 	private static IBinaryTypeAnnotation[] createBinaryTypeAnnotations(List<? extends NdTypeAnnotation> typeAnnotations) {
+		if (typeAnnotations.isEmpty()) {
+			return null;
+		}
 		IBinaryTypeAnnotation[] result = new IBinaryTypeAnnotation[typeAnnotations.size()];
 		int idx = 0;
 		for (NdTypeAnnotation next : typeAnnotations) {
