commit 1ddc6abfe5d6cd8ad8c71d5100cfa53f4e84487a
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Wed Nov 5 23:16:35 2014 +0530

    Fixed Bug 448954 + bug 448826

15	18	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
3	13	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
33	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaRegressionTest.java
5	5	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
2	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
10	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
44	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
140	38	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
11	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InvocationSite.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReductionResult.java
8	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
index 8f3c833..f29e5d2 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
@@ -612,7 +612,6 @@ public void testBug424712a() {
 			"    }\n" + 
 			"}\n"
 		},
-		// The extra error with <unknown> reads a bit weird.
 		"----------\n" + 
 		"1. ERROR in X.java (at line 12)\n" + 
 		"	Set<Y> rosterSet = (Set<Y>) foo(null, Set::new);\n" + 
@@ -626,16 +625,6 @@ public void testBug424712a() {
 		"----------\n" + 
 		"3. ERROR in X.java (at line 12)\n" + 
 		"	Set<Y> rosterSet = (Set<Y>) foo(null, Set::new);\n" + 
-		"	                            ^^^^^^^^^^^^^^^^^^^\n" + 
-		"Type mismatch: cannot convert from Collection<Object> to <unknown>\n" + 
-		"----------\n" + 
-		"4. ERROR in X.java (at line 12)\n" + 
-		"	Set<Y> rosterSet = (Set<Y>) foo(null, Set::new);\n" + 
-		"	                                      ^^^^^^^^\n" + 
-		"The target type of this expression must be a functional interface\n" + 
-		"----------\n" + 
-		"5. ERROR in X.java (at line 12)\n" + 
-		"	Set<Y> rosterSet = (Set<Y>) foo(null, Set::new);\n" + 
 		"	                                      ^^^\n" + 
 		"Cannot instantiate the type Set\n" + 
 		"----------\n");
@@ -1748,7 +1737,12 @@ public void testBug427164() {
 			"}\n"
 		},
 		"----------\n" + 
-		"1. ERROR in NNLambda.java (at line 13)\n" + 
+		"1. ERROR in NNLambda.java (at line 1)\n" + 
+		"	printem((i) -> {\n" + 
+		"	^^^^^^^\n" + 
+		"The method printem(FInter, INP) in the type NNLambda is not applicable for the arguments (FInter, String)\n" + 
+		"----------\n" + 
+		"2. ERROR in NNLambda.java (at line 13)\n" + 
 		"	Collections.<String>singletonList(\"const\")\n" + 
 		"	                                         ^\n" + 
 		"Syntax error, insert \";\" to complete BlockStatements\n" + 
@@ -2900,15 +2894,18 @@ public void testBug430296() {
 		"----------\n" + 
 		"1. ERROR in AnnotationCollector.java (at line 9)\n" + 
 		"	return persons.collect(Collectors.toMap((Person p) -> p.getLastName(),\n" + 
-		"                                                                Function::identity,\n" + 
-		"                                                        (p1, p2) -> p1));\n" + 
-		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-		"Type mismatch: cannot convert from Map<String,Object> to Map<String,Person>\n" + 
+		"	                                  ^^^^^\n" + 
+		"The method toMap(Function<? super T,? extends K>, Function<? super T,? extends U>, BinaryOperator<U>) in the type Collectors is not applicable for the arguments ((Person p) -> {}, Function::identity, BinaryOperator<U>)\n" + 
+		"----------\n" + 
+		"2. ERROR in AnnotationCollector.java (at line 9)\n" + 
+		"	return persons.collect(Collectors.toMap((Person p) -> p.getLastName(),\n" + 
+		"	                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Type mismatch: cannot convert from Function<Person,? extends K> to Function<? super T,? extends K>\n" + 
 		"----------\n" + 
-		"2. ERROR in AnnotationCollector.java (at line 10)\n" + 
+		"3. ERROR in AnnotationCollector.java (at line 10)\n" + 
 		"	Function::identity,\n" + 
 		"	^^^^^^^^^^^^^^^^^^\n" + 
-		"The type Function does not define identity(Person) that is applicable here\n" + 
+		"The type Function does not define identity(T) that is applicable here\n" + 
 		"----------\n");
 }
 public void testBug430759() {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
index 4043b11..fbe0f02 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
@@ -2189,11 +2189,6 @@ public void test424589() {
 		"----------\n" + 
 		"2. ERROR in X.java (at line 11)\n" + 
 		"	Set<Z> x = foo(Set::new);\n" + 
-		"	           ^^^^^^^^^^^^^\n" + 
-		"Type mismatch: cannot convert from Collection<Object> to Set<Z>\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 11)\n" + 
-		"	Set<Z> x = foo(Set::new);\n" + 
 		"	               ^^^\n" + 
 		"Cannot instantiate the type Set\n" + 
 		"----------\n");
@@ -4290,18 +4285,13 @@ public void test430766a() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 21)\n" + 
 			"	persons.sort(Comparator.comparing(Comparator.nullsLast(Person::<Runnable>isRunnable)));\n" + 
-			"	                        ^^^^^^^^^\n" + 
-			"The method comparing(Function<? super T,? extends U>) in the type Comparator is not applicable for the arguments (Comparator<Object>)\n" + 
+			"	                                             ^^^^^^^^^\n" + 
+			"The method nullsLast(Comparator<? super T>) in the type Comparator is not applicable for the arguments (Person::<Runnable>isRunnable)\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 21)\n" + 
 			"	persons.sort(Comparator.comparing(Comparator.nullsLast(Person::<Runnable>isRunnable)));\n" + 
-			"	                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Type mismatch: cannot convert from Comparator<Object> to Function<? super T,? extends U>\n" + 
-			"----------\n" + 
-			"3. ERROR in X.java (at line 21)\n" + 
-			"	persons.sort(Comparator.comparing(Comparator.nullsLast(Person::<Runnable>isRunnable)));\n" + 
 			"	                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"The type X.Person does not define isRunnable(Object, Object) that is applicable here\n" + 
+			"The type X.Person does not define isRunnable(T, T) that is applicable here\n" + 
 			"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=431190, [1.8] VerifyError when using a method reference
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaRegressionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaRegressionTest.java
index 7e307f9..d7fecba 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaRegressionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaRegressionTest.java
@@ -403,6 +403,39 @@ public void test449824() {
 	"The method call(X.RightHand<? super X.Target>) is ambiguous for the type X.Concrete<X.Target>\n" + 
 	"----------\n");
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=448954, [1.8][compiler] Suspect error: "The method foo(String, String, X::goo) is undefined for the type X"
+public void test448954() {
+	this.runConformTest(
+		new String[] {
+			"X.java", 
+			"interface I<T, U, V> {\n" +
+			"	T goo(U u, V v);\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static String goo(String s, String s2) {\n" +
+			"		return null;\n" +
+			"	}\n" +
+			"	static <T, U, V> T foo(T t, U u, J j) {\n" +
+			"		System.out.println(\"Wrong!\");\n" +
+			"		return null;\n" +
+			"	}\n" +
+			"	static <T, U, V> V foo(T t, U u, I<T, U, V> i) {\n" +
+			"		System.out.println(\"Right!\");\n" +
+			"		return null;\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		String s = goo(foo(\"String\", \"String\", X::goo));\n" +
+			"	}\n" +
+			"	static <T> T goo(T t) {\n" +
+			"		return t;\n" +
+			"	}\n" +
+			"}\n"
+	},
+	"Right!");
+}
 public static Class testClass() {
 	return LambdaRegressionTest.class;
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
index 2e5672b..e93c79a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
@@ -6217,11 +6217,6 @@ public void test402609() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 18)\n" + 
 			"	f(super::foo);\n" + 
-			"	^\n" + 
-			"The method f(I) in the type X is not applicable for the arguments (super::foo)\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 18)\n" + 
-			"	f(super::foo);\n" + 
 			"	  ^^^^^\n" + 
 			"Cannot use super in a static context\n" + 
 			"----------\n");
@@ -6868,6 +6863,11 @@ public void test412453() {
 		"----------\n" + 
 		"1. ERROR in X.java (at line 13)\n" + 
 		"	final Optional<Integer> min = empty.minBy((a, b) -> a - b);\n" + 
+		"	                                    ^^^^^\n" + 
+		"The method minBy(Function<Integer,C>) in the type Y<Integer> is not applicable for the arguments ((<no type> a, <no type> b) -> {})\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 13)\n" + 
+		"	final Optional<Integer> min = empty.minBy((a, b) -> a - b);\n" + 
 		"	                                          ^^^^^^^^^^^^^^^\n" + 
 		"Lambda expression\'s signature does not match the signature of the functional interface method apply(Integer)\n" + 
 		"----------\n",
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index f3f21d4..4a9f618 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -630,6 +630,8 @@ public final class CompletionEngine
 		public InferenceContext18 freshInferenceContext(Scope scope) { return null; }
 		public ExpressionContext getExpressionContext() { return ExpressionContext.VANILLA_CONTEXT; }
 		public boolean isQualifiedSuper() { return false; }
+		public boolean checkingPotentialCompatibility() { return false; }
+		public void acceptPotentiallyCompatibleMethods(MethodBinding[] methods) {/* ignore */}
 	};
 
 	private int foundTypesCount;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index eafc4e6..5dd8d3b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -1159,6 +1159,16 @@ public static void resolveDeprecatedAnnotations(BlockScope scope, Annotation[] a
 	}
 }
 
+	// ---- "default methods" for InvocationSite. Can we move to 1.8 and spare ourselves this ugliness please ?
+	public boolean checkingPotentialCompatibility() {
+		return false;
+	}
+	
+	public void acceptPotentiallyCompatibleMethods(MethodBinding [] methods) {
+		// Discard. Interested subclasses should override and grab these goodies. 
+	}
+	// --- "default methods" for InvocationSite
+	
 	public int sourceStart() {
 		return this.sourceStart;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
index da155d0..aa7b14e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
@@ -285,6 +285,8 @@ private static void checkAlternateBinding(BlockScope scope, Expression receiver,
 			public InferenceContext18 freshInferenceContext(Scope someScope) { return invocationSite.freshInferenceContext(someScope); }
 			public ExpressionContext getExpressionContext() { return invocationSite.getExpressionContext(); }
 			public boolean isQualifiedSuper() { return invocationSite.isQualifiedSuper(); }
+			public boolean checkingPotentialCompatibility() { return false; }
+			public void acceptPotentiallyCompatibleMethods(MethodBinding[] methods) {/* ignore */}
 		};
 		MethodBinding bindingIfNoCast;
 		if (binding.isConstructor()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 2f8cf57..423e118 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -742,6 +742,12 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 	}
 	
 	@Override
+	public boolean isPotentiallyCompatibleWith(TypeBinding targetType, Scope scope) {
+		return this.valueIfTrue.isPotentiallyCompatibleWith(targetType, scope) 
+				&& this.valueIfFalse.isPotentiallyCompatibleWith(targetType, scope);
+	}
+	
+	@Override
 	public boolean isFunctionalType() {
 		return this.valueIfTrue.isFunctionalType() || this.valueIfFalse.isFunctionalType(); // Even if only one arm is functional type, this will require a functional interface target
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 63f18ca..489f339 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -1251,4 +1251,8 @@ public boolean isFunctionalType() {
 public Expression [] getPolyExpressions() {
 	return isPolyExpression() ? new Expression [] { this } : NO_EXPRESSIONS;
 }
+
+public boolean isPotentiallyCompatibleWith(TypeBinding targetType, Scope scope) {
+	return isCompatibleWith(targetType, scope); // for all but functional expressions, potential compatibility is the same as compatibility.
+}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 3354b2d..078e763 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -228,9 +228,6 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 	 */
 	public TypeBinding resolveType(BlockScope blockScope) {
 		
-		if (this.resolvedType != null)
-			return this.resolvedType;
-		
 		if (this.expectedType != null && this.original == this) {  // final resolution ? may be not - i.e may be, but only in a non-final universe.
 			this.ordinal = recordFunctionalType(blockScope);
 		}
@@ -245,7 +242,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 				this.argumentTypes[i] = this.arguments[i].type.resolveType(blockScope, true /* check bounds*/);
 		}
 		if (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {
-			return new PolyTypeBinding(this);
+			return this.resolvedType = new PolyTypeBinding(this);
 		} 
 		
 		MethodScope methodScope = blockScope.methodScope();
@@ -700,7 +697,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		return false;
 	}
 		
-	private void analyzeShape() { // simple minded analysis for code assist.
+	private void analyzeShape() { // Simple minded analysis for code assist & potential compatibility.
 		class ShapeComputer extends ASTVisitor {
 			public boolean visit(TypeDeclaration type, BlockScope skope) {
 				return false;
@@ -724,15 +721,52 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		}
 		if (this.body instanceof Expression) {
 			// When completion is still in progress, it is not possible to ask if the expression constitutes a statement expression. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=435219
-			this.voidCompatible = /* ((Expression) this.body).statementExpression(); */ true;
+			this.voidCompatible = this.assistNode ? true : ((Expression) this.body).statementExpression();
 			this.valueCompatible = true;
 		} else {
-			// We need to be a bit tolerant/fuzzy here: the code is being written "just now", if we are too pedantic, selection/completion will break;
-			this.voidCompatible = true;
-			this.valueCompatible = true;
+			// For code assist, we need to be a bit tolerant/fuzzy here: the code is being written "just now", if we are too pedantic, selection/completion will break;
+			if (this.assistNode) {
+				this.voidCompatible = true;
+				this.valueCompatible = true;
+			}
 			this.body.traverse(new ShapeComputer(), null);
+			Block block = (Block) this.body;
+			// support the idiom that { throw new Exception(); } is value compatible.
+			if (block.statements != null && block.statements.length == 1 && block.statements[0] instanceof ThrowStatement)
+				this.valueCompatible = true;
+		}
+		if (this.assistNode)
+			this.shapeAnalysisComplete = true;
+	}
+	
+	@Override
+	public boolean isPotentiallyCompatibleWith(TypeBinding targetType, Scope skope) {
+		/* We get here only when the lambda is NOT pertinent to applicability and that too only for type elided lambdas. */
+		
+		/* 15.12.2.1: A lambda expression (§15.27) is potentially compatible with a functional interface type (§9.8) if all of the following are true:
+		       – The arity of the target type's function type is the same as the arity of the lambda expression.
+		       – If the target type's function type has a void return, then the lambda body is either a statement expression (§14.8) or a void-compatible block (§15.27.2).
+		       – If the target type's function type has a (non-void) return type, then the lambda body is either an expression or a value-compatible block (§15.27.2).
+		*/
+		if (!super.isPertinentToApplicability(targetType, null))
+			return true;
+		
+		final MethodBinding sam = targetType.getSingleAbstractMethod(skope, true);
+		if (sam == null || !sam.isValidBinding())
+			return false;
+		
+		if (sam.parameters.length != this.arguments.length)
+			return false;
+		
+		analyzeShape();
+		if (sam.returnType.id == TypeIds.T_void) {
+			if (!this.voidCompatible)
+				return false;
+		} else {
+			if (!this.valueCompatible)
+				return false;
 		}
-		this.shapeAnalysisComplete = true;
+		return true;
 	}
 	
 	public boolean isCompatibleWith(TypeBinding left, final Scope someScope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index d7bdf99..33b6f31 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -96,6 +96,8 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 	private TypeBinding[] freeParameters; // descriptor parameters as used for method lookup - may or may not include the receiver
 	public boolean trialResolution = false;
 	public int inferenceKind; // TODO: define life-cycle: when to re-initialize? How long to keep value?
+	private boolean checkingPotentialCompatibility;
+	private MethodBinding[] potentialMethods = Binding.NO_METHODS;
 	
 	public ReferenceExpression() {
 		super();
@@ -355,6 +357,17 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		return flowInfo;
 	}
 
+	@Override
+	public boolean checkingPotentialCompatibility() {
+		return this.checkingPotentialCompatibility;
+	}
+	
+	@Override
+	public void acceptPotentiallyCompatibleMethods(MethodBinding[] methods) {
+		if (this.checkingPotentialCompatibility)
+			this.potentialMethods = methods;
+	}
+	
 	public TypeBinding resolveType(BlockScope scope) {
 		
 		if (this.expectedType != null && !this.trialResolution) {  // final resolution ? may be not - i.e may be, but only in a non-final universe.
@@ -390,27 +403,49 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
     				return this.resolvedType = null;
     			}
     		}
+    		if (this.typeArgumentsHaveErrors || lhsType == null)
+				return this.resolvedType = null;
+	
+    		if (lhsType.problemId() == ProblemReasons.AttemptToBypassDirectSuper)
+    			lhsType = lhsType.closestMatch();	// improve resolving experience
+        	if (lhsType == null || !lhsType.isValidBinding()) 
+    			return this.resolvedType = null;	// nope, no useful type found
+        	
+    		this.receiverType = lhsType;
+			this.haveReceiver = true;
+			if (this.lhs instanceof NameReference) {
+				if ((this.lhs.bits & ASTNode.RestrictiveFlagMASK) == Binding.TYPE) {
+					this.haveReceiver = false;
+				}
+			} else if (this.lhs instanceof TypeReference) {
+				this.haveReceiver = false;
+			}
+			if (!this.haveReceiver && !this.lhs.isSuper() && !this.isArrayConstructorReference())
+				this.receiverType = lhsType.capture(scope, this.sourceStart, this.sourceEnd);
+
+			if (!lhsType.isRawType()) // RawType::m and RawType::new are not exact method references
+	    		this.exactMethodBinding = isMethodReference() ? scope.getExactMethod(lhsType, this.selector, this) : scope.getExactConstructor(lhsType, this);
+
+    		if (isConstructorReference() && !lhsType.canBeInstantiated()) {
+    			scope.problemReporter().cannotInstantiate(this.lhs, lhsType);
+    			return this.resolvedType = null;
+    		}
+    		
+    		if (this.lhs instanceof TypeReference && ((TypeReference)this.lhs).hasNullTypeAnnotation()) {
+    			scope.problemReporter().nullAnnotationUnsupportedLocation((TypeReference) this.lhs);
+    		}
+
+	    	if (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {
+	    		return this.resolvedType = new PolyTypeBinding(this);
+			}
     	} else {
     		lhsType = this.lhs.resolvedType;
     		if (this.typeArgumentsHaveErrors || lhsType == null)
 				return this.resolvedType = null;
     	}
 
-    	if (lhsType != null && !lhsType.isRawType()) // RawType::m and RawType::new are not exact method references
-    		this.exactMethodBinding = isMethodReference() ? scope.getExactMethod(lhsType, this.selector, this) : scope.getExactConstructor(lhsType, this);
-
-    	if (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {
-    		return new PolyTypeBinding(this);
-		}
-		super.resolveType(scope);
-		
-    	if (lhsType == null) 
-			return this.resolvedType = null; 	// no hope
-		if (lhsType.problemId() == ProblemReasons.AttemptToBypassDirectSuper)
-			lhsType = lhsType.closestMatch();	// improve resolving experience
-    	if (!lhsType.isValidBinding()) 
-			return this.resolvedType = null;	// nope, no useful type found
-    	
+    	super.resolveType(scope);
+		
     	// Convert parameters into argument expressions for look up.
 		TypeBinding[] descriptorParameters = descriptorParametersAsArgumentExpressions();
 		
@@ -419,15 +454,6 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 			return this.resolvedType = null;
 		}
 		
-		if (isConstructorReference() && !lhsType.canBeInstantiated()) {
-			scope.problemReporter().cannotInstantiate(this.lhs, lhsType);
-			return this.resolvedType = null;
-		}
-		
-		if (this.lhs instanceof TypeReference && ((TypeReference)this.lhs).hasNullTypeAnnotation()) {
-			scope.problemReporter().nullAnnotationUnsupportedLocation((TypeReference) this.lhs);
-		}
-
 		/* 15.13: "If a method reference expression has the form super :: [TypeArguments] Identifier or TypeName . super :: [TypeArguments] Identifier,
 		   it is a compile-time error if the expression occurs in a static context. ": This is nop since the primary when it resolves
 		   itself will complain automatically.
@@ -439,20 +465,6 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		*/
 		
 		// handle the special case of array construction first.
-		this.receiverType = lhsType;
-		
-		this.haveReceiver = true;
-		if (this.lhs instanceof NameReference) {
-			if ((this.lhs.bits & ASTNode.RestrictiveFlagMASK) == Binding.TYPE) {
-				this.haveReceiver = false;
-			}
-		} else if (this.lhs instanceof TypeReference) {
-			this.haveReceiver = false;
-		}
-		
-		if (!this.haveReceiver && !this.lhs.isSuper() && !this.isArrayConstructorReference())
-			this.receiverType = lhsType.capture(scope, this.sourceStart, this.sourceEnd);
-		
 		final int parametersLength = descriptorParameters.length;
         if (isConstructorReference() && lhsType.isArrayType()) {
         	final TypeBinding leafComponentType = lhsType.leafComponentType();
@@ -854,6 +866,96 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		return expressions;
 	}
 
+	@Override
+	public boolean isPotentiallyCompatibleWith(TypeBinding targetType, Scope scope) {
+		
+		// We get here only when the reference expression is NOT pertinent to applicability.
+		if (!super.isPertinentToApplicability(targetType, null))
+			return true;
+		final MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true);
+		if (sam == null || !sam.isValidBinding())
+			return false;
+		if (this.typeArgumentsHaveErrors || this.lhs.resolvedType == null || !this.lhs.resolvedType.isValidBinding())
+			return false;
+		
+		int parametersLength = sam.parameters.length;
+		TypeBinding[] descriptorParameters = new TypeBinding[parametersLength];
+		for (int i = 0; i < parametersLength; i++) {
+			descriptorParameters[i] = new ReferenceBinding() {
+				{
+					this.compoundName = CharOperation.NO_CHAR_CHAR;
+				}
+				public boolean isCompatibleWith(TypeBinding otherType, Scope captureScope) {
+					return true;
+				}
+				public TypeBinding findSuperTypeOriginatingFrom(TypeBinding otherType) {
+					return otherType;
+				}
+				public String toString() {
+					return "(wildcard)"; //$NON-NLS-1$
+				}
+			};
+		}
+		
+		// 15.13.1
+        final boolean isMethodReference = isMethodReference();
+        this.freeParameters = descriptorParameters;
+        this.checkingPotentialCompatibility = true;
+        try {
+        	MethodBinding compileTimeDeclaration = isMethodReference ? scope.getMethod(this.receiverType, this.selector, descriptorParameters, this) :
+        		scope.getConstructor((ReferenceBinding) this.receiverType, descriptorParameters, this);
+
+        	if (compileTimeDeclaration != null && compileTimeDeclaration.isValidBinding()) // we have the mSMB.
+        		this.potentialMethods = new MethodBinding [] { compileTimeDeclaration };
+        	else {
+        		/* We EITHER have potential methods that are input to Scope.mSMb already captured in this.potentialMethods 
+        	       OR there are no potentially compatible compile time declaration ...
+        		 */
+        	}
+
+        	/* 15.12.2.1: A method reference expression (§15.13) is potentially compatible with a functional interface type if, where the type's function type arity is n, 
+		       there exists at least one potentially applicable method for the method reference expression with arity n (§15.13.1), and one of the following is true:
+                   – The method reference expression has the form ReferenceType ::[TypeArguments] Identifier and at least one potentially applicable method is
+                        i) static and supports arity n, or ii) not static and supports arity n-1.
+                   – The method reference expression has some other form and at least one potentially applicable method is not static.
+        	*/
+
+        	for (int i = 0, length = this.potentialMethods.length; i < length; i++) {
+        		if (this.potentialMethods[i].isStatic() || this.potentialMethods[i].isConstructor()) {
+        			if (!this.haveReceiver) // form ReferenceType ::[TypeArguments] Identifier
+        				return true;
+        		} else {
+        			if (this.haveReceiver) // some other form.
+        				return true;
+        		}
+        	}
+
+        	if (this.haveReceiver || parametersLength == 0)
+        		return false;
+
+        	System.arraycopy(descriptorParameters, 1, descriptorParameters = new TypeBinding[parametersLength - 1], 0, parametersLength - 1);
+        	this.freeParameters = descriptorParameters;
+        	compileTimeDeclaration = scope.getMethod(this.receiverType, this.selector, descriptorParameters, this);
+        
+        	if (compileTimeDeclaration != null && compileTimeDeclaration.isValidBinding()) // we have the mSMB.
+        		this.potentialMethods = new MethodBinding [] { compileTimeDeclaration };
+        	else {
+        		/* We EITHER have potential methods that are input to Scope.mSMb already captured in this.potentialMethods 
+              	   OR there are no potentially compatible compile time declaration ...
+        		*/
+        	}
+        	for (int i = 0, length = this.potentialMethods.length; i < length; i++) {
+        		if (!this.potentialMethods[i].isStatic()) {
+        			return true;
+        		}
+        	}
+        } finally {
+        	this.checkingPotentialCompatibility = false;
+        	this.potentialMethods = Binding.NO_METHODS;
+        }
+        return false;
+	}
+	
 	public boolean isCompatibleWith(TypeBinding left, Scope scope) {
 		if (this.binding != null && this.binding.isValidBinding() // binding indicates if full resolution has already happened
 				&& this.resolvedType != null && this.resolvedType.isValidBinding()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index ec01160..acd4755 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -50,6 +50,17 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 	}
 
 	public Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException {
+		
+		if (this.relation == POTENTIALLY_COMPATIBLE) {
+			/* 15.12.2.1: ... The definition of potential applicability goes beyond a basic arity check to also take into account the presence and "shape" of functional interface 
+			   target types. In some cases involving type argument inference, a lambda expression appearing as a method invocation argument cannot be properly typed until after 
+			   overload resolution. These rules allow the form of the lambda expression to still be taken into account, discarding obviously incorrect target types that might 
+			   otherwise cause ambiguity errors.
+			*/
+			
+			return  this.left.isPotentiallyCompatibleWith(this.right, inferenceContext.scope) ? TRUE: FALSE;
+		}
+	
 		// JLS 18.2.1
 		if (this.right.isProperType(true)) {
 			return this.left.isCompatibleWith(this.right, inferenceContext.scope) || this.left.isBoxingCompatibleWith(this.right, inferenceContext.scope) ? TRUE : FALSE;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index 9855ee9..d2a1be5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -237,9 +237,13 @@ public class InferenceContext18 {
 			ownConstraints = false; // these are lifted from a nested poly expression.
 		}
 		for (int i = 0; i < len; i++) {
+			TypeBinding thetaF = substitute(parameters[i]);
 			if (this.invocationArguments[i].isPertinentToApplicability(parameters[i], method)) {
-				TypeBinding thetaF = substitute(parameters[i]);
 				this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.COMPATIBLE, ARGUMENT_CONSTRAINTS_ARE_SOFT);
+			} else {
+				if (parameters[i].isPertinentToApplicability(this.invocationArguments[i].resolvedType, method))
+					this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.POTENTIALLY_COMPATIBLE);
+				// else we know it is potentially compatible, no need to assert.
 			}
 		}
 		if (checkVararg && varArgsType instanceof ArrayBinding) {
@@ -248,6 +252,10 @@ public class InferenceContext18 {
 			for (int i = len; i < this.invocationArguments.length; i++) {
 				if (this.invocationArguments[i].isPertinentToApplicability(varArgsType, method)) {
 					this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.COMPATIBLE, ARGUMENT_CONSTRAINTS_ARE_SOFT);
+				} else {
+					if (varArgsType.isPertinentToApplicability(this.invocationArguments[i].resolvedType, method))
+						this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.POTENTIALLY_COMPATIBLE);
+					// else we know it is potentially compatible, no need to assert.
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InvocationSite.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InvocationSite.java
index 0527f27..322ae58 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InvocationSite.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InvocationSite.java
@@ -33,6 +33,9 @@ public interface InvocationSite {
 	int sourceStart();
 	TypeBinding invocationTargetType();
 	boolean receiverIsImplicitThis();
+	boolean checkingPotentialCompatibility();
+	void acceptPotentiallyCompatibleMethods(MethodBinding [] methods);
+	
 	/** When inference for this invocationSite starts, get a fresh inference context, initialized from this site. */
 	InferenceContext18 freshInferenceContext(Scope scope);
 	ExpressionContext getExpressionContext();
@@ -56,5 +59,7 @@ public interface InvocationSite {
 		public ExpressionContext getExpressionContext() { return ExpressionContext.VANILLA_CONTEXT; }
 		@Override
 		public boolean isQualifiedSuper() { return false; }
+		public boolean checkingPotentialCompatibility() { return false; }
+		public void acceptPotentiallyCompatibleMethods(MethodBinding[] methods) { /* ignore */ }
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index a3aea13..47d2a92 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -166,6 +166,10 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 		boolean invocationTypeInferred = false;
 		boolean requireBoxing = false;
 		
+		if (invocationSite.checkingPotentialCompatibility()) {
+			return scope.environment().createParameterizedGenericMethod(originalMethod, typeVariables);
+		}
+		
 		// See if we should start in loose inference mode.
 		TypeBinding [] argumentsCopy = new TypeBinding[arguments.length];
 		for (int i = 0, length = arguments.length, parametersLength = parameters.length ; i < length; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReductionResult.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReductionResult.java
index 8d0103a..97a0acc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReductionResult.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReductionResult.java
@@ -36,6 +36,7 @@ public abstract class ReductionResult {
 	protected static final int TYPE_ARGUMENT_CONTAINED = 5;
 	protected static final int CAPTURE = 6;
 	static final int EXCEPTIONS_CONTAINED = 7;
+	protected static final int POTENTIALLY_COMPATIBLE = 8;
 	
 	protected TypeBinding right; // note that the LHS differs between sub-classes.
 	protected int relation;
@@ -44,6 +45,7 @@ public abstract class ReductionResult {
 		switch (relation) {
 			case SAME: 			return " = "; //$NON-NLS-1$
 			case COMPATIBLE: 	return " \u2192 "; //$NON-NLS-1$
+			case POTENTIALLY_COMPATIBLE: return " \u2192? "; //$NON-NLS-1$
 			case SUBTYPE: 		return " <: "; //$NON-NLS-1$
 			case SUPERTYPE: 	return " :> "; //$NON-NLS-1$
 			case TYPE_ARGUMENT_CONTAINED:
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index e1f8402..02a6a03 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -4228,6 +4228,11 @@ public abstract class Scope {
 	protected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, final InvocationSite invocationSite, ReferenceBinding receiverType) {
 
 		boolean isJdk18 = compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8;
+		if (isJdk18 && invocationSite.checkingPotentialCompatibility()) {
+			if (visibleSize != visible.length)
+				System.arraycopy(visible, 0, visible = new MethodBinding[visibleSize], 0, visibleSize);
+			invocationSite.acceptPotentiallyCompatibleMethods(visible);
+		}
 		// common part for all compliance levels:
 		int[] compatibilityLevels = new int[visibleSize];
 		int compatibleCount = 0;
@@ -4339,6 +4344,8 @@ public abstract class Scope {
 				public InferenceContext18 freshInferenceContext(Scope scope) { return null; /* no inference when ignoring genericTypeArgs */ }
 				public ExpressionContext getExpressionContext() { return ExpressionContext.VANILLA_CONTEXT; }
 				public boolean isQualifiedSuper() { return invocationSite.isQualifiedSuper(); }
+				public boolean checkingPotentialCompatibility() { return false; }
+				public void acceptPotentiallyCompatibleMethods(MethodBinding[] methods) {/* ignore */}
 			};
 			int count = 0;
 			for (int level = 0, max = VARARGS_COMPATIBLE; level <= max; level++) {
@@ -4594,7 +4601,6 @@ public abstract class Scope {
 			   and only applicability was inferred and applicability inference instantiated it with jlO due to lack of upper bounds in the bound set.
 			*/
 			if (site instanceof Invocation && context != null) { // this block can be readily seen to be not relevant for reference expressions
-				MethodBinding shallowOriginal = method.shallowOriginal();
 				for (int i = 0, length = arguments.length; i < length; i++) {
 					TypeBinding argument = arguments[i];
 					if (!argument.isFunctionalType())
@@ -4604,17 +4610,7 @@ public abstract class Scope {
 						continue;
 					if (context.stepCompleted >= InferenceContext18.TYPE_INFERRED)
 						return NOT_COMPATIBLE;
-					// Next 6 lines have dubious sanction. Needs a rigorous solution.
-					TypeBinding shallowParameter = InferenceContext18.getParameter(shallowOriginal.parameters, i, context.isVarArgs());
-					if (!shallowParameter.isPertinentToApplicability(argument, shallowOriginal))
-						continue;
-					if (((Invocation) site).arguments()[i] instanceof ReferenceExpression)
-						continue;
-					return NOT_COMPATIBLE;
-					/* We ask the inverted question here, because we do want to check compatibility against lambdas and reference expressions that are not pertinent to
-					  applicability on account of being type elided and not being an exact method reference respectively i.e if we call 
-					  argument.isPertinentToApplicability(shallowParameter, shallowOriginal), it will answer true if type elided and we will miss catching incompatibilities.
-					*/ 
+					continue; // Engine has already asserted potential compatibility and that is all we can do.
 				}
 			}
 			switch (inferenceKind) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
index 3d1ab95..0000718 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
@@ -505,7 +505,7 @@ public class TypeVariableBinding extends ReferenceBinding {
 	}
 	
 	public boolean isPertinentToApplicability(TypeBinding argument, MethodBinding method) {
-		return argument.isPertinentToApplicability(this, method);
+		return argument != null && argument.isPertinentToApplicability(this, method);
 	}
 	
 	public boolean isProperType(boolean admitCapture18) {
commit 9043b6a8e4132c7e53a6fb980711e9a0982fef9b
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Thu Nov 6 05:12:07 2014 +0530

    Minor cleanup for the fix for Bug 448954

8	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
6	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index 33b6f31..43f638d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -902,14 +902,16 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
         this.freeParameters = descriptorParameters;
         this.checkingPotentialCompatibility = true;
         try {
-        	MethodBinding compileTimeDeclaration = isMethodReference ? scope.getMethod(this.receiverType, this.selector, descriptorParameters, this) :
-        		scope.getConstructor((ReferenceBinding) this.receiverType, descriptorParameters, this);
+        	MethodBinding compileTimeDeclaration = 
+        			this.exactMethodBinding != null ? this.exactMethodBinding :
+        							isMethodReference ? scope.getMethod(this.receiverType, this.selector, descriptorParameters, this) :
+        												scope.getConstructor((ReferenceBinding) this.receiverType, descriptorParameters, this);
 
         	if (compileTimeDeclaration != null && compileTimeDeclaration.isValidBinding()) // we have the mSMB.
         		this.potentialMethods = new MethodBinding [] { compileTimeDeclaration };
         	else {
         		/* We EITHER have potential methods that are input to Scope.mSMb already captured in this.potentialMethods 
-        	       OR there are no potentially compatible compile time declaration ...
+        	       OR there is no potentially compatible compile time declaration ...
         		 */
         	}
 
@@ -935,13 +937,13 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 
         	System.arraycopy(descriptorParameters, 1, descriptorParameters = new TypeBinding[parametersLength - 1], 0, parametersLength - 1);
         	this.freeParameters = descriptorParameters;
-        	compileTimeDeclaration = scope.getMethod(this.receiverType, this.selector, descriptorParameters, this);
+        	compileTimeDeclaration = this.exactMethodBinding != null ? this.exactMethodBinding : scope.getMethod(this.receiverType, this.selector, descriptorParameters, this);
         
         	if (compileTimeDeclaration != null && compileTimeDeclaration.isValidBinding()) // we have the mSMB.
         		this.potentialMethods = new MethodBinding [] { compileTimeDeclaration };
         	else {
         		/* We EITHER have potential methods that are input to Scope.mSMb already captured in this.potentialMethods 
-              	   OR there are no potentially compatible compile time declaration ...
+              	   OR there is no potentially compatible compile time declaration ...
         		*/
         	}
         	for (int i = 0, length = this.potentialMethods.length; i < length; i++) {
@@ -952,6 +954,7 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
         } finally {
         	this.checkingPotentialCompatibility = false;
         	this.potentialMethods = Binding.NO_METHODS;
+        	this.freeParameters = null; // not used after method lookup
         }
         return false;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index 47d2a92..0279ec4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -158,18 +158,19 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 
 	public static MethodBinding computeCompatibleMethod18(MethodBinding originalMethod, TypeBinding[] arguments, final Scope scope, InvocationSite invocationSite) {
 		
-		ParameterizedGenericMethodBinding methodSubstitute = null;
 		TypeVariableBinding[] typeVariables = originalMethod.typeVariables;
+		if (invocationSite.checkingPotentialCompatibility()) {
+			// Not interested in a solution, only that there could potentially be one.
+			return scope.environment().createParameterizedGenericMethod(originalMethod, typeVariables);
+		}
+		
+		ParameterizedGenericMethodBinding methodSubstitute = null;
 		InferenceContext18 infCtx18 = invocationSite.freshInferenceContext(scope);
 		TypeBinding[] parameters = originalMethod.parameters;
 		CompilerOptions compilerOptions = scope.compilerOptions();
 		boolean invocationTypeInferred = false;
 		boolean requireBoxing = false;
 		
-		if (invocationSite.checkingPotentialCompatibility()) {
-			return scope.environment().createParameterizedGenericMethod(originalMethod, typeVariables);
-		}
-		
 		// See if we should start in loose inference mode.
 		TypeBinding [] argumentsCopy = new TypeBinding[arguments.length];
 		for (int i = 0, length = arguments.length, parametersLength = parameters.length ; i < length; i++) {
commit df8af25e16f5b7e59c39fb5a8e8fbed4f0aa740c
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Nov 27 14:41:40 2014 +0100

    Bug 448954 - [1.8][compiler] Incorrect error: "The method foo(String,
    String, X::goo) is undefined for the type X"
    - remove unused methods

1	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
0	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
1	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
index da0a97f..9149909 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
@@ -38,20 +38,10 @@ public class PolyTypeBinding extends TypeBinding {
 	}
 	
 	@Override
-	public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
-		return this.expression.isPertinentToApplicability(targetType, method);
-	}
-	
-	@Override
 	public boolean isPotentiallyCompatibleWith(TypeBinding targetType, Scope scope) {
 		return this.expression.isPotentiallyCompatibleWith(targetType, scope);
 	}
-	
-	@Override
-	public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method) {
-		return this.expression.isPertinentToApplicability(typeVariable, method);
-	}
-	
+
 	@Override
 	public boolean isPolyType() {
 		return true;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 097755e..5bacca6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -545,14 +545,6 @@ public final boolean isBaseType() {
 	return (this.tagBits & TagBits.IsBaseType) != 0;
 }
 
-public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method) {
-	return true;
-}
-
-public boolean isPertinentToApplicability(TypeBinding argument, MethodBinding method) {
-	return true;
-}
-
 /* Answer true if the receiver is a base type other than void or null
  */
 public final boolean isPrimitiveType() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
index 6ff28c8..0586bbc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
@@ -509,11 +509,7 @@ public class TypeVariableBinding extends ReferenceBinding {
 	public boolean isPertinentToApplicability(Expression expression, MethodBinding method) {
 		return expression.isPertinentToApplicability(this, method);
 	}
-	
-	public boolean isPertinentToApplicability(TypeBinding argument, MethodBinding method) {
-		return argument != null && argument.isPertinentToApplicability(this, method);
-	}
-	
+
 	public boolean isProperType(boolean admitCapture18) {
 		// handle recursive calls:
 		if (this.inRecursiveFunction) // be optimistic, since this node is not an inference variable
commit e74a7e922535396e598f77f6ca74363a6e6d0498
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Nov 27 15:02:43 2014 +0100

    Bug 448954 - [1.8][compiler] Incorrect error: "The method foo(String,
    String, X::goo) is undefined for the type X"
    - inline method

2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
0	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
0	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index 08a588d..efb6517 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -242,7 +242,7 @@ public class InferenceContext18 {
 			if (this.invocationArguments[i].isPertinentToApplicability(parameters[i], method)) {
 				this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.COMPATIBLE, ARGUMENT_CONSTRAINTS_ARE_SOFT);
 			} else {
-				if (parameters[i].isPertinentToApplicability(this.invocationArguments[i], method))
+				if (!(parameters[i] instanceof TypeVariableBinding) || this.invocationArguments[i].isPertinentToApplicability(((TypeVariableBinding)parameters[i]), method))
 					this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.POTENTIALLY_COMPATIBLE);
 				// else we know it is potentially compatible, no need to assert.
 			}
@@ -254,7 +254,7 @@ public class InferenceContext18 {
 				if (this.invocationArguments[i].isPertinentToApplicability(varArgsType, method)) {
 					this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.COMPATIBLE, ARGUMENT_CONSTRAINTS_ARE_SOFT);
 				} else {
-					if (varArgsType.isPertinentToApplicability(this.invocationArguments[i], method))
+					if (!(varArgsType instanceof TypeVariableBinding) || this.invocationArguments[i].isPertinentToApplicability(((TypeVariableBinding)varArgsType), method))
 						this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.POTENTIALLY_COMPATIBLE);
 					// else we know it is potentially compatible, no need to assert.
 				}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 5bacca6..e1beb3e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -37,7 +37,6 @@ import java.util.List;
 import java.util.Set;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 
@@ -1678,8 +1677,4 @@ public void exitRecursiveFunction() {
 public boolean isFunctionalType() {
 	return false;
 }
-
-public boolean isPertinentToApplicability(Expression expression, MethodBinding method) {
-	return true;
-}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
index 0586bbc..24a25fa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
@@ -36,7 +36,6 @@ import java.util.Set;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
-import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
@@ -505,11 +504,6 @@ public class TypeVariableBinding extends ReferenceBinding {
 		this.inRecursiveFunction = false;
 	}
 	
-	@Override
-	public boolean isPertinentToApplicability(Expression expression, MethodBinding method) {
-		return expression.isPertinentToApplicability(this, method);
-	}
-
 	public boolean isProperType(boolean admitCapture18) {
 		// handle recursive calls:
 		if (this.inRecursiveFunction) // be optimistic, since this node is not an inference variable
commit 5132501fe32bc39d29df0ef5b05cc4e551a24910
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Thu Nov 27 15:18:10 2014 +0100

    Bug 448954 - [1.8][compiler] Incorrect error: "The method foo(String,
    String, X::goo) is undefined for the type X"
    - refactor condition, remove now unused methods

1	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
0	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
12	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
0	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IPolyExpression.java
18	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 412471b..079a108 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -728,12 +728,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		System.arraycopy(falsePolys, 0, allPolys, truePolys.length, falsePolys.length);
 		return allPolys;
 	}
-	
-	public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method) {
-		return this.valueIfTrue.isPertinentToApplicability(typeVariable, method) 
-				&& this.valueIfFalse.isPertinentToApplicability(typeVariable, method);
-	}
-	
+
 	public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
 		return this.valueIfTrue.isPertinentToApplicability(targetType, method) 
 				&& this.valueIfFalse.isPertinentToApplicability(targetType, method);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 458b644..13b768b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -959,10 +959,6 @@ public Constant optimizedBooleanConstant() {
 	return this.constant;
 }
 
-public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method) {
-	return true;
-}
-
 public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
 	return true;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
index 9fa5139..4f992eb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
@@ -107,22 +107,19 @@ public abstract class FunctionalExpression extends Expression {
 		return true;
 	}
 	
-	public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method) {
-		if (method != null) { // when called from type inference
-			if (typeVariable.declaringElement == method)
-				return false;
-			if (method.isConstructor() && typeVariable.declaringElement == method.declaringClass)
-				return false;
-		} else { // for internal calls
-			if (typeVariable.declaringElement instanceof MethodBinding)
-				return false;
-		}
-		return true;
-	}
-	
 	public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
-		if (targetType instanceof TypeVariableBinding)
-			return isPertinentToApplicability((TypeVariableBinding) targetType, method);
+		if (targetType instanceof TypeVariableBinding) {
+			TypeVariableBinding typeVariable = (TypeVariableBinding) targetType;
+			if (method != null) { // when called from type inference
+				if (typeVariable.declaringElement == method)
+					return false;
+				if (method.isConstructor() && typeVariable.declaringElement == method.declaringClass)
+					return false;
+			} else { // for internal calls
+				if (typeVariable.declaringElement instanceof MethodBinding)
+					return false;
+			}
+		}
 		return true;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IPolyExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IPolyExpression.java
index f0aa885..b499183 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IPolyExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IPolyExpression.java
@@ -19,7 +19,6 @@ import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
-import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 
 /**
  	Contract to be implemented by all poly expressions and potential poly expressions for uniform integration into overload resolution and type inference.
@@ -46,7 +45,6 @@ public interface IPolyExpression {
 	public boolean sIsMoreSpecific(TypeBinding s, TypeBinding t, Scope skope);	
 	
 	// Pertinence checks.
-	public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method);
 	public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method);
 
 	// Polyness checks
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index efb6517..67c7cf1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -241,11 +241,9 @@ public class InferenceContext18 {
 			TypeBinding thetaF = substitute(parameters[i]);
 			if (this.invocationArguments[i].isPertinentToApplicability(parameters[i], method)) {
 				this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.COMPATIBLE, ARGUMENT_CONSTRAINTS_ARE_SOFT);
-			} else {
-				if (!(parameters[i] instanceof TypeVariableBinding) || this.invocationArguments[i].isPertinentToApplicability(((TypeVariableBinding)parameters[i]), method))
-					this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.POTENTIALLY_COMPATIBLE);
-				// else we know it is potentially compatible, no need to assert.
-			}
+			} else if (!isTypeVariableOfCandidate(parameters[i], method)) {
+				this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.POTENTIALLY_COMPATIBLE);
+			} // else we know it is potentially compatible, no need to assert.
 		}
 		if (checkVararg && varArgsType instanceof ArrayBinding) {
 			varArgsType = ((ArrayBinding)varArgsType).elementsType();
@@ -253,11 +251,9 @@ public class InferenceContext18 {
 			for (int i = len; i < this.invocationArguments.length; i++) {
 				if (this.invocationArguments[i].isPertinentToApplicability(varArgsType, method)) {
 					this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.COMPATIBLE, ARGUMENT_CONSTRAINTS_ARE_SOFT);
-				} else {
-					if (!(varArgsType instanceof TypeVariableBinding) || this.invocationArguments[i].isPertinentToApplicability(((TypeVariableBinding)varArgsType), method))
-						this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.POTENTIALLY_COMPATIBLE);
-					// else we know it is potentially compatible, no need to assert.
-				}
+				} else if (!isTypeVariableOfCandidate(varArgsType, method)) {
+					this.initialConstraints[numConstraints++] = new ConstraintExpressionFormula(this.invocationArguments[i], thetaF, ReductionResult.POTENTIALLY_COMPATIBLE);
+				} // else we know it is potentially compatible, no need to assert.
 			}
 		}
 		if (numConstraints == 0)
@@ -270,6 +266,18 @@ public class InferenceContext18 {
 		}
 	}
 
+	private boolean isTypeVariableOfCandidate(TypeBinding type, MethodBinding candidate) {
+		// cf. FunctionalExpression.isPertinentToApplicability()
+		if (type instanceof TypeVariableBinding) {
+			Binding declaringElement = ((TypeVariableBinding) type).declaringElement;
+			if (declaringElement == candidate)
+				return true;
+			if (candidate.isConstructor() && declaringElement == candidate.declaringClass)
+				return true;
+		}
+		return false;
+	}
+
 	private InferenceVariable[] addInitialTypeVariableSubstitutions(TypeBinding[] typeVariables) {
 		int len = typeVariables.length;
 		if (len == 0) {
