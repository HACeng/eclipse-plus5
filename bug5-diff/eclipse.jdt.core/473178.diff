commit 0a7e159e5583b9d90c024b9f588fa970acb3427f
Author: Lars Vogel <Lars.Vogel@vogella.com>
Date:   Tue Jul 28 23:41:00 2015 +0200

    Bug 473178 - Remove redundant type arguments (1.7 or highter) from Java
    7 code in JDT core
    
    This is the first small set of changes, just to see if these changes are
    accepted by JDT core.
    
    Change-Id: I620bb41f95291f588f5a828614beb0a5c95101c6
    Signed-off-by: Lars Vogel <Lars.Vogel@vogella.com>

4	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
5	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
14	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
6	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
7	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
7	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
10	8	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ConflictIdentifier.java
9	7	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ImportEditor.java
9	7	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ImportGroupComparator.java
10	8	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java
3	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
3	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
3	1	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/CommentWrapExecutor.java
5	3	org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/FieldAligner.java
4	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ExternalAnnotationTracker.java
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
index f2273fc..0aa748d 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
@@ -9,6 +9,8 @@
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
  *								Bug 440687 - [compiler][batch][null] improve command line option for external annotations
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.batch;
 
@@ -168,7 +170,7 @@ public boolean hasAnnotationFileFor(String qualifiedTypeName) {
  *  Add all the secondary types in the package
  */
 private Hashtable<String, String> getPackageTypes(char[] typeName, String qualifiedPackageName) {
-	Hashtable<String, String> packageEntry = new Hashtable<String, String>();
+	Hashtable<String, String> packageEntry = new Hashtable<>();
 
 	String[] dirList = (String[]) this.directoryCache.get(qualifiedPackageName);
 	if (dirList == this.missingPackageHolder // package exists in another classpath directory or jar 
@@ -207,7 +209,7 @@ private Hashtable<String, String> getPackageTypes(char[] typeName, String qualif
 }
 private NameEnvironmentAnswer findSourceSecondaryType(char[] typeName, String qualifiedPackageName, String qualifiedBinaryFileName) {
 	
-	if (this.packageSecondaryTypes == null) this.packageSecondaryTypes = new Hashtable<String, Hashtable<String,String>>();
+	if (this.packageSecondaryTypes == null) this.packageSecondaryTypes = new Hashtable<>();
 	Hashtable<String, String> packageEntry = this.packageSecondaryTypes.get(qualifiedPackageName);
 	if (packageEntry == null) {
 		packageEntry = 	getPackageTypes(typeName, qualifiedPackageName);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index b35f4f6..fc4bf02 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -46,6 +46,8 @@
  *                          Bug 409245 - [1.8][compiler] Type annotations dropped when call is routed through a synthetic bridge method
  *     Till Brychcy - Contributions for
  *     						bug 413460 - NonNullByDefault is not inherited to Constructors when accessed via Class File
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -720,7 +722,7 @@ public void registerInferenceContext(ParameterizedGenericMethodBinding method, I
 public void registerResult(TypeBinding targetType, MethodBinding method) {
 	if (method != null && method.isConstructor()) { // ignore the factory.
 		if (this.solutionsPerTargetType == null)
-			this.solutionsPerTargetType = new HashMap<TypeBinding, MethodBinding>();
+			this.solutionsPerTargetType = new HashMap<>();
 		this.solutionsPerTargetType.put(targetType, method);
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 13b768b..ac87691 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -26,6 +26,8 @@
  *								Bug 428274 - [1.8] [compiler] Cannot cast from Number to double
  *								Bug 428352 - [1.8][compiler] Resolution errors don't always surface
  *								Bug 452788 - [1.8][compiler] Type not correctly inferred in lambda expression
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -843,7 +845,7 @@ public void generateOptimizedStringConcatenationCreation(BlockScope blockScope,
 }
 
 private MethodBinding[] getAllOriginalInheritedMethods(ReferenceBinding binding) {
-	ArrayList<MethodBinding> collector = new ArrayList<MethodBinding>();
+	ArrayList<MethodBinding> collector = new ArrayList<>();
 	getAllInheritedMethods0(binding, collector);
 	for (int i = 0, len = collector.size(); i < len; i++) {
 		collector.set(i, collector.get(i).original());
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
index 6b61bcf..bdce24e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationProvider.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     Stephan Herrmann - initial API and implementation
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
@@ -123,15 +125,15 @@ public class ExternalAnnotationProvider {
 				annotSig = trimTail(annotSig);
 				if (isSuper) {
 					if (this.supertypeAnnotationSources == null)
-						this.supertypeAnnotationSources = new HashMap<String, String>();
+						this.supertypeAnnotationSources = new HashMap<>();
 					this.supertypeAnnotationSources.put('L'+selector+rawSig+';', annotSig);
 				} else if (rawSig.contains("(")) { //$NON-NLS-1$
 					if (this.methodAnnotationSources == null)
-						this.methodAnnotationSources = new HashMap<String, String>();
+						this.methodAnnotationSources = new HashMap<>();
 					this.methodAnnotationSources.put(selector+rawSig, annotSig);
 				} else {
 					if (this.fieldAnnotationSources == null)
-						this.fieldAnnotationSources = new HashMap<String, String>();
+						this.fieldAnnotationSources = new HashMap<>();
 					this.fieldAnnotationSources.put(selector+':'+rawSig, annotSig);
 				}
 			} while (((line = pendingLine) != null) || (line = reader.readLine()) != null);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index 68770ad..61d54b5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     Stephan Herrmann - initial API and implementation
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -49,13 +51,13 @@ class BoundSet {
 		public boolean addBound(TypeBound bound) {
 			switch (bound.relation) {
 				case ReductionResult.SUPERTYPE:
-					if (this.superBounds == null) this.superBounds = new HashSet<TypeBound>();
+					if (this.superBounds == null) this.superBounds = new HashSet<>();
 					return this.superBounds.add(bound);
 				case ReductionResult.SAME:
-					if (this.sameBounds == null) this.sameBounds = new HashSet<TypeBound>();
+					if (this.sameBounds == null) this.sameBounds = new HashSet<>();
 					return this.sameBounds.add(bound);
 				case ReductionResult.SUBTYPE:
-					if (this.subBounds == null) this.subBounds = new HashSet<TypeBound>();
+					if (this.subBounds == null) this.subBounds = new HashSet<>();
 					return this.subBounds.add(bound);
 				default:
 					throw new IllegalArgumentException("Unexpected bound relation in : " + bound); //$NON-NLS-1$
@@ -171,11 +173,11 @@ class BoundSet {
 		public ThreeSets copy() {
 			ThreeSets copy = new ThreeSets();
 			if (this.superBounds != null)
-				copy.superBounds = new HashSet<TypeBound>(this.superBounds);
+				copy.superBounds = new HashSet<>(this.superBounds);
 			if (this.sameBounds != null)
-				copy.sameBounds = new HashSet<TypeBound>(this.sameBounds);
+				copy.sameBounds = new HashSet<>(this.sameBounds);
 			if (this.subBounds != null)
-				copy.subBounds = new HashSet<TypeBound>(this.subBounds);
+				copy.subBounds = new HashSet<>(this.subBounds);
 			copy.instantiation = this.instantiation;
 			return copy;
 		}
@@ -294,15 +296,15 @@ class BoundSet {
 		}
 	}
 	// main storage of type bounds:
-	HashMap<InferenceVariable, ThreeSets> boundsPerVariable = new HashMap<InferenceVariable, ThreeSets>();
+	HashMap<InferenceVariable, ThreeSets> boundsPerVariable = new HashMap<>();
 	
 	/**
 	 * 18.1.3 bullet 4: G<α1, ..., αn> = capture(G<A1, ..., An>)
 	 * On both sides we only enter types with nonnull arguments. 
 	 */
-	HashMap<ParameterizedTypeBinding,ParameterizedTypeBinding> captures = new HashMap<ParameterizedTypeBinding, ParameterizedTypeBinding>();
+	HashMap<ParameterizedTypeBinding,ParameterizedTypeBinding> captures = new HashMap<>();
 	/** 18.1.3 bullet 5: throws α */
-	Set<InferenceVariable> inThrows = new HashSet<InferenceVariable>();
+	Set<InferenceVariable> inThrows = new HashSet<>();
 
 	private TypeBound [] incorporatedBounds = new TypeBound[0];
 	private TypeBound [] unincorporatedBounds = new TypeBound [1024];
@@ -410,7 +412,7 @@ class BoundSet {
 				if (three == null)
 					this.boundsPerVariable.put(rightIV, (three = new ThreeSets()));
 				if (three.inverseBounds == null)
-					three.inverseBounds = new HashMap<InferenceVariable,TypeBound>();
+					three.inverseBounds = new HashMap<>();
 				three.inverseBounds.put(rightIV, bound);
 			}
 		}
@@ -822,7 +824,7 @@ class BoundSet {
 		TypeBinding[] tis = t.typeArguments();
 		if (sis == null || tis == null || sis.length != tis.length)
 			return null;
-		List<ConstraintTypeFormula> result = new ArrayList<ConstraintTypeFormula>(); 
+		List<ConstraintTypeFormula> result = new ArrayList<>(); 
 		for (int i = 0; i < sis.length; i++) {
 			TypeBinding si = sis[i];
 			TypeBinding ti = tis[i];
@@ -1010,7 +1012,7 @@ class BoundSet {
 		// ii) B2 contains two bounds of the forms S1 <: α and S2 <: α, where
 		//     S1 and S2 have supertypes (4.10) that are two different parameterizations of the same generic class or interface.
 		if (ts.superBounds != null) {
-			ArrayList<TypeBound> superBounds = new ArrayList<TypeBound>(ts.superBounds);
+			ArrayList<TypeBound> superBounds = new ArrayList<>(ts.superBounds);
 			int len = superBounds.size();
 			for (int i=0; i<len; i++) {
 				TypeBinding s1 = superBounds.get(i).right;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
index 129a977..46455ee 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
@@ -24,6 +24,8 @@
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 415821 - [1.8][compiler] CLASS_EXTENDS target type annotation missing for anonymous classes
  *     het@google.com - Bug 456986 - Bogus error when annotation processor generates annotation type
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1137,7 +1139,7 @@ public class ClassScope extends Scope {
 	public boolean deferCheck(Runnable check) {
 		if (compilationUnitScope().connectingHierarchy) {
 			if (this.deferredBoundChecks == null)
-				this.deferredBoundChecks = new ArrayList<Object>();
+				this.deferredBoundChecks = new ArrayList<>();
 			this.deferredBoundChecks.add(check);
 			return true;
 		} else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
index c716b53..9532099 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExceptionFormula.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013, 2014 GK Software AG.
+ * Copyright (c) 2013, 2015 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     Stephan Herrmann - initial API and implementation
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -93,7 +95,7 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 		if (ePrime == null)
 			return TRUE;
 		int m = ePrime.length;
-		List<ConstraintFormula> result = new ArrayList<ConstraintFormula>();
+		List<ConstraintFormula> result = new ArrayList<>();
 		actual: for (int i = 0; i < m; i++) {
 			if (ePrime[i].isUncheckedException(false))
 				continue;
@@ -117,7 +119,7 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 			if (this.right.isFunctionalInterface(context.scope)) {
 				LambdaExpression lambda = (LambdaExpression) this.left;
 				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true); // TODO derive with target type?
-				final Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
+				final Set<InferenceVariable> variables = new HashSet<>();
 				if (lambda.argumentsTypeElided()) {
 					// i)
 					int len = sam.parameters.length;
@@ -137,7 +139,7 @@ public class ConstraintExceptionFormula extends ConstraintFormula {
 			}
 			if (this.right.isFunctionalInterface(context.scope)) { // TODO: && this.left is inexact
 				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true); // TODO derive with target type?
-				final Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
+				final Set<InferenceVariable> variables = new HashSet<>();
 				int len = sam.parameters.length;
 				for (int i = 0; i < len; i++) {
 					sam.parameters[i].collectInferenceVariables(variables);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index dc660b7..9b4b32e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     Stephan Herrmann - initial API and implementation
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -168,7 +170,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 					if (!lambda.isValueCompatible())
 						return FALSE;
 				}
-				List<ConstraintFormula> result = new ArrayList<ConstraintFormula>();
+				List<ConstraintFormula> result = new ArrayList<>();
 				if (!lambda.argumentsTypeElided()) {
 					Argument[] arguments = lambda.arguments();
 					for (int i = 0; i < parameters.length; i++)
@@ -246,7 +248,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		if (potentiallyApplicable == null)
 			return FALSE;
 		if (reference.isExactMethodReference()) {
-			List<ConstraintFormula> newConstraints = new ArrayList<ConstraintFormula>();
+			List<ConstraintFormula> newConstraints = new ArrayList<>();
 			TypeBinding[] p = functionType.parameters;
 			int n = p.length;
 			TypeBinding[] pPrime = potentiallyApplicable.parameters;
@@ -428,7 +430,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			if (this.right.isFunctionalInterface(context.scope)) {
 				LambdaExpression lambda = (LambdaExpression) this.left;
 				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true); // TODO derive with target type?
-				final Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
+				final Set<InferenceVariable> variables = new HashSet<>();
 				if (lambda.argumentsTypeElided()) {
 					// i)
 					int len = sam.parameters.length;
@@ -453,7 +455,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			}
 			if (this.right.isFunctionalInterface(context.scope) && !this.left.isExactMethodReference()) {
 				MethodBinding sam = this.right.getSingleAbstractMethod(context.scope, true);
-				final Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
+				final Set<InferenceVariable> variables = new HashSet<>();
 				int len = sam.parameters.length;
 				for (int i = 0; i < len; i++) {
 					sam.parameters[i].collectInferenceVariables(variables);
@@ -462,7 +464,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			}			
 		} else if (this.left instanceof ConditionalExpression && this.left.isPolyExpression()) {
 			ConditionalExpression expr = (ConditionalExpression) this.left;
-			Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
+			Set<InferenceVariable> variables = new HashSet<>();
 			variables.addAll(new ConstraintExpressionFormula(expr.valueIfTrue, this.right, COMPATIBLE).inputVariables(context));
 			variables.addAll(new ConstraintExpressionFormula(expr.valueIfFalse, this.right, COMPATIBLE).inputVariables(context));
 			return variables;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
index 1b5eba7..9178eb2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintFormula.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013, 2014 GK Software AG.
+ * Copyright (c) 2013, 2015 GK Software AG.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     Stephan Herrmann - initial API and implementation
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -35,7 +37,7 @@ abstract class ConstraintFormula extends ReductionResult {
 	}
 	
 	Collection<InferenceVariable> outputVariables(InferenceContext18 context) {
-		Set<InferenceVariable> variables = new HashSet<InferenceVariable>();
+		Set<InferenceVariable> variables = new HashSet<>();
 		this.right.collectInferenceVariables(variables);
 		if (!variables.isEmpty())
 			variables.removeAll(inputVariables(context));
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
index 360a5ab..9daff30e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     Stephan Herrmann - initial API and implementation
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -240,7 +242,7 @@ class ConstraintTypeFormula extends ConstraintFormula {
 				}
 			case Binding.PARAMETERIZED_TYPE:
 				{
-					List<ConstraintFormula> constraints = new ArrayList<ConstraintFormula>();
+					List<ConstraintFormula> constraints = new ArrayList<>();
 					while (superCandidate != null && superCandidate.kind() == Binding.PARAMETERIZED_TYPE && subCandidate != null)  {
 						if (!addConstraintsFromTypeParameters(subCandidate, (ParameterizedTypeBinding) superCandidate, constraints))
 							return FALSE;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
index 110a27e..0541f2a 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/rewrite/ImportRewrite.java
@@ -8,6 +8,8 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     John Glassmyer <jogl@google.com> - import group sorting is broken - https://bugs.eclipse.org/430303
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 
 package org.eclipse.jdt.core.dom.rewrite;
@@ -296,10 +298,10 @@ public final class ImportRewrite {
 				return findInImports(qualifier, name, kind);
 			}
 		};
-		this.addedImports= new ArrayList<String>();
-		this.removedImports= new ArrayList<String>();
-		this.typeExplicitSimpleNames = new HashSet<String>();
-		this.staticExplicitSimpleNames = new HashSet<String>();
+		this.addedImports= new ArrayList<>();
+		this.removedImports= new ArrayList<>();
+		this.typeExplicitSimpleNames = new HashSet<>();
+		this.staticExplicitSimpleNames = new HashSet<>();
 		this.createdImports= null;
 		this.createdStaticImports= null;
 
@@ -1287,7 +1289,7 @@ public final class ImportRewrite {
 		if (imports == null) {
 			return CharOperation.NO_STRINGS;
 		}
-		List<String> res= new ArrayList<String>();
+		List<String> res= new ArrayList<>();
 		for (String curr : imports) {
 			if (prefix == curr.charAt(0)) {
 				res.add(curr.substring(1));
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ConflictIdentifier.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ConflictIdentifier.java
index a5bcb07..f4a857e 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ConflictIdentifier.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ConflictIdentifier.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2014 Google Inc and others.
+ * Copyright (c) 2014, 2015 Google Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     John Glassmyer <jogl@google.com> - import group sorting is broken - https://bugs.eclipse.org/430303
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.dom.rewrite.imports;
 
@@ -29,8 +31,8 @@ public class ConflictIdentifier {
 		final Set<String> staticConflicts;
 
 		Conflicts(Set<String> typeConflicts, Set<String> staticConflicts) {
-			this.typeConflicts = Collections.unmodifiableSet(new HashSet<String>(typeConflicts));
-			this.staticConflicts = Collections.unmodifiableSet(new HashSet<String>(staticConflicts));
+			this.typeConflicts = Collections.unmodifiableSet(new HashSet<>(typeConflicts));
+			this.staticConflicts = Collections.unmodifiableSet(new HashSet<>(staticConflicts));
 		}
 
 		@Override
@@ -83,8 +85,8 @@ public class ConflictIdentifier {
 		Collection<OnDemandReduction> onDemandCandidates = this.onDemandComputer.identifyPossibleReductions(
 				imports, addedImports, typeExplicitSimpleNames, staticExplicitSimpleNames);
 
-		Set<String> typeOnDemandContainers = new HashSet<String>(extractContainerNames(onDemandCandidates, false));
-		Set<String> staticOnDemandContainers = new HashSet<String>(extractContainerNames(onDemandCandidates, true));
+		Set<String> typeOnDemandContainers = new HashSet<>(extractContainerNames(onDemandCandidates, false));
+		Set<String> staticOnDemandContainers = new HashSet<>(extractContainerNames(onDemandCandidates, true));
 
 		if (!typeOnDemandContainers.isEmpty()) {
 			// Existing on-demands might conflict with new or existing on-demands.
@@ -113,7 +115,7 @@ public class ConflictIdentifier {
 
 	private Collection<String> extractContainerNames(
 			Collection<OnDemandReduction> onDemandCandidates, boolean isStatic) {
-		Collection<String> containerNames = new ArrayList<String>(onDemandCandidates.size());
+		Collection<String> containerNames = new ArrayList<>(onDemandCandidates.size());
 		for (OnDemandReduction onDemandCandidate : onDemandCandidates) {
 			ImportName containerOnDemand = onDemandCandidate.containerOnDemand;
 			if (containerOnDemand.isStatic == isStatic) {
@@ -126,7 +128,7 @@ public class ConflictIdentifier {
 
 	private Collection<String> extractOnDemandContainerNames(
 			Collection<ImportName> imports, boolean isStatic) {
-		Collection<String> onDemandContainerNames = new ArrayList<String>(imports.size());
+		Collection<String> onDemandContainerNames = new ArrayList<>(imports.size());
 		for (ImportName importName : imports) {
 			if (importName.isOnDemand() && importName.isStatic == isStatic) {
 				onDemandContainerNames.add(importName.containerName);
@@ -146,7 +148,7 @@ public class ConflictIdentifier {
 			return Collections.emptySet();
 		}
 
-		Set<String> simpleNames = new HashSet<String>();
+		Set<String> simpleNames = new HashSet<>();
 		for (ImportName currentImport : imports) {
 			if (currentImport.isStatic == isStatic) {
 				simpleNames.add(currentImport.simpleName);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ImportEditor.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ImportEditor.java
index 144de49..0c3b038 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ImportEditor.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ImportEditor.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     John Glassmyer <jogl@google.com> - import group sorting is broken - https://bugs.eclipse.org/430303
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.dom.rewrite.imports;
 
@@ -81,7 +83,7 @@ final class ImportEditor {
 	 */
 	private static Map<ImportName, ImportEntry> mapPrecedingImports(Collection<? extends ImportEntry> importEntries) {
 		Map<ImportName, ImportEntry> precedingImports =
-				new IdentityHashMap<ImportName, ImportEntry>(importEntries.size());
+				new IdentityHashMap<>(importEntries.size());
 
 		ImportEntry previousImport = null;
 		for (ImportEntry currentImport : importEntries) {
@@ -251,7 +253,7 @@ final class ImportEditor {
 	private Collection<TextEdit> determineEditsForImports(
 			IRegion importsRegion,
 			Collection<ImportEntry> resultantImports) {
-		Collection<TextEdit> edits = new ArrayList<TextEdit>();
+		Collection<TextEdit> edits = new ArrayList<>();
 
 		Map<ImportEntry, Collection<ImportComment>> commentReassignments =
 				this.commentReassigner.reassignComments(resultantImports);
@@ -264,7 +266,7 @@ final class ImportEditor {
 		edits.addAll(deleteRemainingText(importsRegion, edits));
 
 		// Omit the RangeMarkers used temporarily to mark the text of non-relocated imports.
-		Collection<TextEdit> editsWithoutRangeMarkers = new ArrayList<TextEdit>(edits.size());
+		Collection<TextEdit> editsWithoutRangeMarkers = new ArrayList<>(edits.size());
 		for (TextEdit edit : edits) {
 			if (!(edit instanceof RangeMarker)) {
 				editsWithoutRangeMarkers.add(edit);
@@ -281,7 +283,7 @@ final class ImportEditor {
 			OriginalImportsCursor cursor,
 			Collection<ImportEntry> resultantImports,
 			Map<ImportEntry, Collection<ImportComment>> commentReassignments) {
-		Collection<TextEdit> edits = new ArrayList<TextEdit>();
+		Collection<TextEdit> edits = new ArrayList<>();
 
 		ImportEntry lastResultantImport = null;
 		for (ImportEntry currentResultantImport : resultantImports) {
@@ -478,7 +480,7 @@ final class ImportEditor {
 			return Collections.emptyList();
 		}
 
-		Collection<TextEdit> edits = new ArrayList<TextEdit>(reassignedComments.size() * 3);
+		Collection<TextEdit> edits = new ArrayList<>(reassignedComments.size() * 3);
 
 		ImportComment lastComment = null;
 		for (ImportComment currentComment : reassignedComments) {
@@ -505,7 +507,7 @@ final class ImportEditor {
 	 * Creates TextEdits that delete text remaining between and after resultant imports.
 	 */
 	private static Collection<TextEdit> deleteRemainingText(IRegion importRegion, Collection<TextEdit> edits) {
-		List<TextEdit> sortedEdits = new ArrayList<TextEdit>(edits);
+		List<TextEdit> sortedEdits = new ArrayList<>(edits);
 		Collections.sort(sortedEdits, new Comparator<TextEdit>() {
 			@Override
 			public int compare(TextEdit o1, TextEdit o2) {
@@ -515,7 +517,7 @@ final class ImportEditor {
 
 		int deletePosition = importRegion.getOffset();
 
-		Collection<TextEdit> deleteRemainingTextEdits = new ArrayList<TextEdit>();
+		Collection<TextEdit> deleteRemainingTextEdits = new ArrayList<>();
 		for (TextEdit edit : sortedEdits) {
 			if (edit.getOffset() > deletePosition) {
 				deleteRemainingTextEdits.add(new DeleteEdit(deletePosition, edit.getOffset() - deletePosition));
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ImportGroupComparator.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ImportGroupComparator.java
index 178dcc1..4339466 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ImportGroupComparator.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/rewrite/imports/ImportGroupComparator.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     John Glassmyer <jogl@google.com> - import group sorting is broken - https://bugs.eclipse.org/430303
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.dom.rewrite.imports;
 
@@ -82,7 +84,7 @@ final class ImportGroupComparator implements Comparator<ImportName>{
 			return importOrder;
 		}
 
-		List<String> augmentedOrder = new ArrayList<String>(importOrder.size() + 2);
+		List<String> augmentedOrder = new ArrayList<>(importOrder.size() + 2);
 
 		if (needsStaticMatchAll) {
 			augmentedOrder.add(STATIC_MATCH_ALL);
@@ -102,8 +104,8 @@ final class ImportGroupComparator implements Comparator<ImportName>{
 			return memoizedIndexedImportGroups;
 		}
 
-		Map<String, Integer> typeGroupsAndIndices = new HashMap<String, Integer>();
-		Map<String, Integer> staticGroupsAndIndices = new HashMap<String, Integer>();
+		Map<String, Integer> typeGroupsAndIndices = new HashMap<>();
+		Map<String, Integer> staticGroupsAndIndices = new HashMap<>();
 		for (int i = 0; i < importOrder.size(); i++) {
 			String importGroupString = importOrder.get(i);
 
@@ -132,12 +134,12 @@ final class ImportGroupComparator implements Comparator<ImportName>{
 			importGroupNamesAndIndices = Collections.singletonMap(MATCH_ALL, 0);
 		}
 
-		List<String> sortedNames = new ArrayList<String>(importGroupNamesAndIndices.keySet());
+		List<String> sortedNames = new ArrayList<>(importGroupNamesAndIndices.keySet());
 		Collections.sort(sortedNames);
 
-		ArrayList<ImportGroup> importGroups = new ArrayList<ImportGroup>(sortedNames.size());
+		ArrayList<ImportGroup> importGroups = new ArrayList<>(sortedNames.size());
 
-		Deque<ImportGroup> prefixingGroups = new ArrayDeque<ImportGroup>();
+		Deque<ImportGroup> prefixingGroups = new ArrayDeque<>();
 		for (String name : sortedNames) {
 			while (!prefixingGroups.isEmpty()
 					&& !isWholeSegmentPrefix(prefixingGroups.getLast().getName(), name)) {
@@ -152,7 +154,7 @@ final class ImportGroupComparator implements Comparator<ImportName>{
 			prefixingGroups.addLast(group);
 		}
 
-		NavigableMap<String, ImportGroup> groupsByName = new TreeMap<String, ImportGroup>();
+		NavigableMap<String, ImportGroup> groupsByName = new TreeMap<>();
 		for (ImportGroup group : importGroups) {
 			groupsByName.put(group.getName(), group);
 		}
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java
index c9d0d3e..9dcd35a 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CommentsPreparator.java
@@ -9,6 +9,8 @@
  *     Mateusz Matela <mateusz.matela@gmail.com> - [formatter] Formatter does not format Java code correctly, especially when max line width is set - https://bugs.eclipse.org/303519
  *     Mateusz Matela <mateusz.matela@gmail.com> - [formatter] IndexOutOfBoundsException in TokenManager - https://bugs.eclipse.org/462945
  *     Mateusz Matela <mateusz.matela@gmail.com> - [formatter] Bad line breaking in Eclipse javadoc comments - https://bugs.eclipse.org/348338
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.formatter;
 
@@ -220,7 +222,7 @@ public class CommentsPreparator extends ASTVisitor {
 			if (previous.originalEnd + 1 >= commentToken.originalStart)
 				return;
 			if (structure == null || structure.isEmpty()) {
-				structure = new ArrayList<Token>();
+				structure = new ArrayList<>();
 				structure.add(new Token(previous.originalEnd + 1, commentToken.originalEnd, TokenNameCOMMENT_LINE));
 			} else {
 				structure.add(0, new Token(previous.originalEnd + 1, commentToken.originalStart - 1,
@@ -255,7 +257,7 @@ public class CommentsPreparator extends ASTVisitor {
 		if (stringLiterals.isEmpty())
 			return;
 
-		List<Token> commentFragments = new ArrayList<Token>();
+		List<Token> commentFragments = new ArrayList<>();
 		Matcher matcher = NLS_TAG_PATTERN.matcher(this.tm.toString(comment));
 		int previousMatcherEnd = 0;
 		boolean nlsFound = false;
@@ -287,7 +289,7 @@ public class CommentsPreparator extends ASTVisitor {
 	}
 
 	private List<Token> findStringLiteralsInLine(int lastTokenIndex) {
-		List<Token> stringLiterals = new ArrayList<Token>();
+		List<Token> stringLiterals = new ArrayList<>();
 		Token previous = this.tm.get(lastTokenIndex);
 		for (int i = lastTokenIndex - 1; i >= 0; i--) {
 			Token token = this.tm.get(i);
@@ -306,7 +308,7 @@ public class CommentsPreparator extends ASTVisitor {
 		if (fragments == null) {
 			fragments = Arrays.asList(commentToken);
 		}
-		ArrayList<Token> result = new ArrayList<Token>();
+		ArrayList<Token> result = new ArrayList<>();
 		for (int i = 0; i < fragments.size(); i++) {
 			Token token = fragments.get(i);
 			if (token.hasNLSTag()) {
@@ -445,7 +447,7 @@ public class CommentsPreparator extends ASTVisitor {
 	}
 
 	private List<Token> commentToLines(Token commentToken, int commentStartPositionInLine) {
-		List<Token> lines = new ArrayList<Token>();
+		List<Token> lines = new ArrayList<>();
 
 		int tab = this.options.tab_size;
 		String commentText = this.tm.toString(commentToken);
@@ -940,7 +942,7 @@ public class CommentsPreparator extends ASTVisitor {
 				? this.options.comment_clear_blank_lines_in_javadoc_comment
 				: this.options.comment_clear_blank_lines_in_block_comment;
 
-		List<Token> structure = new ArrayList<Token>();
+		List<Token> structure = new ArrayList<>();
 
 		int firstTokenEnd = commentToken.originalStart + 1;
 		while (firstTokenEnd < commentToken.originalEnd - 1 && this.tm.charAt(firstTokenEnd + 1) == '*')
@@ -1201,7 +1203,7 @@ public class CommentsPreparator extends ASTVisitor {
 	private List<Token> translateFormattedTokens(int startPosition, List<Token> formattedTokens, int[] positionMapping,
 			HashMap<Token, Token> translationMap) {
 		int previousLineBreaks = 0;
-		List<Token> result = new ArrayList<Token>();
+		List<Token> result = new ArrayList<>();
 		for (Token token : formattedTokens) {
 			int newStart = Arrays.binarySearch(positionMapping, token.originalStart);
 			while (newStart > 0 && positionMapping[newStart - 1] == token.originalStart)
@@ -1219,7 +1221,7 @@ public class CommentsPreparator extends ASTVisitor {
 			List<Token> structure = token.getInternalStructure();
 			if (structure != null && !structure.isEmpty()) {
 				if (translationMap == null)
-					translationMap = new HashMap<Token, Token>();
+					translationMap = new HashMap<>();
 				translated.setInternalStructure(translateFormattedTokens(startPosition, structure, positionMapping,
 						translationMap));
 			}
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
index f7a3580..701f0da 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatter.java
@@ -12,6 +12,8 @@
  *     Harry Terkelsen (het@google.com) - Bug 449262 - Allow the use of third-party Java formatters
  *     Mateusz Matela <mateusz.matela@gmail.com> - [formatter] Formatter does not format Java code correctly, especially when max line width is set - https://bugs.eclipse.org/303519
  *     Mateusz Matela <mateusz.matela@gmail.com> - [formatter] follow up bug for comments - https://bugs.eclipse.org/458208
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.formatter;
 
@@ -76,7 +78,7 @@ public class DefaultCodeFormatter extends CodeFormatter {
 	private char[] sourceArray;
 
 	private ASTNode astRoot;
-	private List<Token> tokens = new ArrayList<Token>();
+	private List<Token> tokens = new ArrayList<>();
 	private TokenManager tokenManager;
 
 	public DefaultCodeFormatter() {
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
index 21b926a..93ef1e4 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/DefaultCodeFormatterOptions.java
@@ -11,6 +11,8 @@
  *     Ray V. (voidstar@gmail.com) - Contribution for bug 282988
  *     Jesper S Moller - Contribution for bug 402173
  *     Mateusz Matela <mateusz.matela@gmail.com> - [formatter] Formatter does not format Java code correctly, especially when max line width is set - https://bugs.eclipse.org/303519
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.formatter;
 
@@ -423,7 +425,7 @@ public class DefaultCodeFormatterOptions {
 	}
 
 	public Map<String, String> getMap() {
-		Map<String, String> options = new HashMap<String, String>();
+		Map<String, String> options = new HashMap<>();
 		options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_ARGUMENTS_IN_ALLOCATION_EXPRESSION, getAlignment(this.alignment_for_arguments_in_allocation_expression));
 		options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_ARGUMENTS_IN_ANNOTATION, getAlignment(this.alignment_for_arguments_in_annotation));
 		options.put(DefaultCodeFormatterConstants.FORMATTER_ALIGNMENT_FOR_ARGUMENTS_IN_ENUM_CONSTANT, getAlignment(this.alignment_for_arguments_in_enum_constant));
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/CommentWrapExecutor.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/CommentWrapExecutor.java
index 9eb02b7..e5b8ba8 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/CommentWrapExecutor.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/CommentWrapExecutor.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     Mateusz Matela <mateusz.matela@gmail.com> - [formatter] Formatter does not format Java code correctly, especially when max line width is set - https://bugs.eclipse.org/303519
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.formatter.linewrap;
 
@@ -30,7 +32,7 @@ public class CommentWrapExecutor extends TokenTraverser {
 	private final TokenManager tm;
 	private final DefaultCodeFormatterOptions options;
 
-	private final ArrayList<Token> nlsTags = new ArrayList<Token>();
+	private final ArrayList<Token> nlsTags = new ArrayList<>();
 
 	private int lineStartPosition;
 	private List<Token> blockStructure;
diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/FieldAligner.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/FieldAligner.java
index 8321a34..121e36f 100644
--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/FieldAligner.java
+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/linewrap/FieldAligner.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     Mateusz Matela <mateusz.matela@gmail.com> - [formatter] Formatter does not format Java code correctly, especially when max line width is set - https://bugs.eclipse.org/303519
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.formatter.linewrap;
 
@@ -62,7 +64,7 @@ public class FieldAligner {
 		}
 	}
 
-	private final List<List<FieldDeclaration>> fieldAlignGroups = new ArrayList<List<FieldDeclaration>>();
+	private final List<List<FieldDeclaration>> fieldAlignGroups = new ArrayList<>();
 
 	final TokenManager tm;
 
@@ -75,7 +77,7 @@ public class FieldAligner {
 
 	public void prepareAlign(TypeDeclaration node) {
 		List<FieldDeclaration> bodyDeclarations = node.bodyDeclarations();
-		ArrayList<FieldDeclaration> alignGroup = new ArrayList<FieldDeclaration>();
+		ArrayList<FieldDeclaration> alignGroup = new ArrayList<>();
 		BodyDeclaration previous = null;
 		for (BodyDeclaration declaration : bodyDeclarations) {
 			if (!alignGroup.isEmpty()) {
@@ -83,7 +85,7 @@ public class FieldAligner {
 					alignGroup.add((FieldDeclaration) declaration);
 				} else {
 					alignFields(alignGroup);
-					alignGroup = new ArrayList<FieldDeclaration>();
+					alignGroup = new ArrayList<>();
 				}
 			}
 			if (alignGroup.isEmpty()) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ExternalAnnotationTracker.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ExternalAnnotationTracker.java
index fd6da1c..19c4747 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ExternalAnnotationTracker.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ExternalAnnotationTracker.java
@@ -7,6 +7,8 @@
  *
  * Contributors:
  *     Stephan Herrmann - initial API and implementation
+ *     Lars Vogel <Lars.Vogel@vogella.com> - Contributions for
+ *     						Bug 473178
  *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
@@ -62,13 +64,13 @@ public class ExternalAnnotationTracker implements IResourceChangeListener {
 
 		Map<IPath, DirectoryNode> getChildren() {
 			if (this.children == null)
-				this.children = new HashMap<IPath, DirectoryNode>();
+				this.children = new HashMap<>();
 			return this.children;
 		}
 
 		void registerClassFile(IPath relativeAnnotationPath, ClassFile classFile) {
 			if (this.classFiles == null)
-				this.classFiles = new HashMap<IPath, ClassFile>();
+				this.classFiles = new HashMap<>();
 			this.classFiles.put(relativeAnnotationPath, classFile);
 			if (this.modelRoot == null)
 				this.modelRoot = classFile.getPackageFragmentRoot();
commit 8715eeccf865a33f86687c2ed1edfa7db42faeec
Author: Lars Vogel <Lars.Vogel@vogella.com>
Date:   Tue Oct 6 12:19:59 2015 +0200

    Bug 473178 - Remove redundant type arguments (1.7 or highter) from Java
    7 code in JDT core
    
    This removes the redundant type information from
    org.eclipse.jdt.apt.core.
    
    Change-Id: Ibc5b2d99e6fbe91cd1710407a4e1bd0ba50549aa
    Signed-off-by: Lars Vogel <Lars.Vogel@vogella.com>

12	12	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java
19	19	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AnnotationProcessorFactoryLoader.java
4	4	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptCompilationParticipant.java
3	3	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptPlugin.java
5	5	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/FactoryPluginManager.java
4	4	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/JarClassLoader.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/JarFactoryContainer.java
3	3	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/LoadFailureHandler.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/PluginFactoryContainer.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ASTBasedDeclarationImpl.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/AnnotationMirrorImpl.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ClassDeclarationImpl.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/DeclarationImpl.java
3	3	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/EclipseDeclarationImpl.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/EnumDeclarationImpl.java
7	7	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ExecutableUtil.java
5	5	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/PackageDeclarationImpl.java
7	7	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeDeclarationImpl.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeParameterDeclarationImpl.java
9	9	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AbstractCompilationEnv.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AnnotationInvocationHandler.java
9	9	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java
9	9	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BuildEnv.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/ClasspathUtil.java
25	25	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileMap.java
3	3	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedResourceChangeListener.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Factory.java
4	4	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPath.java
3	3	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPathUtil.java
9	9	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/ManyToMany.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/PackageUtil.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/ScannerUtil.java
3	3	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Visitors.java
8	8	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptConfig.java
2	2	org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptPreferenceConstants.java
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java
index d827cf5..5a2c131 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/APTDispatchRunnable.java
@@ -1,5 +1,5 @@
  /*******************************************************************************
- * Copyright (c) 2005, 2011 BEA Systems, Inc. and others
+ * Copyright (c) 2005, 2015 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -391,13 +391,13 @@ public class APTDispatchRunnable implements IWorkspaceRunnable
 				allGeneratedFiles = java5GeneratedFiles;
 			}
 			else {
-				allGeneratedFiles = new HashSet<IFile>(java6GeneratedFiles);
+				allGeneratedFiles = new HashSet<>(java6GeneratedFiles);
 				allGeneratedFiles.addAll(java5GeneratedFiles);
 			}
 		}
 		
 		// figure out exactly what got deleted
-		final List<IFile> deletedFiles = new ArrayList<IFile>(); 
+		final List<IFile> deletedFiles = new ArrayList<>(); 
 		IFile parentFile = curResult.getFile();
 		cleanupNoLongerGeneratedFiles(
 				parentFile, 
@@ -448,7 +448,7 @@ public class APTDispatchRunnable implements IWorkspaceRunnable
 	{
 		final BuildContext[] cpResults = processorEnv.getFilesWithAnnotation();
 		final Map<BuildContext, Set<AnnotationTypeDeclaration>> file2AnnotationDecls = 
-			new HashMap<BuildContext, Set<AnnotationTypeDeclaration>>(cpResults.length * 4/3 + 1);
+			new HashMap<>(cpResults.length * 4/3 + 1);
 		final Map<String, AnnotationTypeDeclaration> annotationDecls = 
 			processorEnv.getAllAnnotationTypes(file2AnnotationDecls);
 		
@@ -465,11 +465,11 @@ public class APTDispatchRunnable implements IWorkspaceRunnable
 
 		// file based processing factory to the set of annotations that it 'claims'
 		final Map<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>> fileFactory2Annos =
-			new HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( _factories.size() * 4/3 + 1 );
+			new HashMap<>( _factories.size() * 4/3 + 1 );
 		
 		// batch processing factory to the set of annotations that it 'claims'
 		final Map<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>> batchFactory2Annos =
-			new HashMap<AnnotationProcessorFactory, Set<AnnotationTypeDeclaration>>( _factories.size() * 4/3 + 1 );		
+			new HashMap<>( _factories.size() * 4/3 + 1 );
 		
 		for( Map.Entry<AnnotationProcessorFactory, FactoryPath.Attributes> entry : _factories.entrySet() ){
 			AnnotationProcessorFactory factory = entry.getKey();
@@ -481,7 +481,7 @@ public class APTDispatchRunnable implements IWorkspaceRunnable
 					batch ? batchFactory2Annos : fileFactory2Annos;
 				if( annotationTypes.size() == 0 ){
 					// this factory is claiming all (remaining) annotations. 
-					annotationTypes = new HashSet<AnnotationTypeDeclaration>(annotationDecls.values());
+					annotationTypes = new HashSet<>(annotationDecls.values());
 					factory2Annos.put(factory, annotationTypes);
 					annotationDecls.clear();
 					break;
@@ -509,7 +509,7 @@ public class APTDispatchRunnable implements IWorkspaceRunnable
 				// the order of the factory doesn't matter.
 				// But in order to make things consists between runs, will 
 				// dispatch base on factory order.
-				_currentDispatchBatchFactories = new LinkedHashSet<AnnotationProcessorFactory>();
+				_currentDispatchBatchFactories = new LinkedHashSet<>();
 				for(AnnotationProcessorFactory factory : _factories.keySet() ){			
 					final Set<AnnotationTypeDeclaration> annotationTypes = batchFactory2Annos.get(factory);
 					if( annotationTypes == null ) continue;
@@ -639,7 +639,7 @@ public class APTDispatchRunnable implements IWorkspaceRunnable
 			Set<AnnotationTypeDeclaration> factoryDecls = getFactorySupportedAnnotations(factory, annotationDecls);
 			if( factoryDecls != null ){
 				if(factoryDecls.size() == 0 ){
-					factoryDecls = new HashSet<AnnotationTypeDeclaration>(annotationDecls.values());
+					factoryDecls = new HashSet<>(annotationDecls.values());
 					annotationDecls.clear();
 				}
 			}
@@ -729,7 +729,7 @@ public class APTDispatchRunnable implements IWorkspaceRunnable
 		for( AnnotationTypeDeclaration obj : one ){
 			if( two.contains(obj) ){
 				if( intersect == null )
-					intersect = new HashSet<AnnotationTypeDeclaration>();
+					intersect = new HashSet<>();
 				intersect.add(obj);
 			}
 		}
@@ -745,7 +745,7 @@ public class APTDispatchRunnable implements IWorkspaceRunnable
 		if (cpResults == null) {
 			return;
 		}
-		final Set<IFile> deleted = new HashSet<IFile>();
+		final Set<IFile> deleted = new HashSet<>();
 		GeneratedFileManager gfm = _aptProject.getGeneratedFileManager();
 		Set<IFile> java6GeneratedFiles = AptCompilationParticipant.getInstance().getJava6GeneratedFiles();
 		for( BuildContext cpResult : cpResults){
@@ -813,7 +813,7 @@ public class APTDispatchRunnable implements IWorkspaceRunnable
 		if (supportedTypes == null || supportedTypes.size() == 0)
 			return Collections.emptySet();
 
-		final Set<AnnotationTypeDeclaration> fDecls = new HashSet<AnnotationTypeDeclaration>();
+		final Set<AnnotationTypeDeclaration> fDecls = new HashSet<>();
 
 		for (Iterator<String> it = supportedTypes.iterator(); it.hasNext();) {
 			final String typeName = it.next();
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AnnotationProcessorFactoryLoader.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AnnotationProcessorFactoryLoader.java
index ce33d4f..5cebcad 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AnnotationProcessorFactoryLoader.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AnnotationProcessorFactoryLoader.java
@@ -130,11 +130,11 @@ public class AnnotationProcessorFactoryLoader {
 	// See class comments for lifecycle of items in this cache.
 	// Guarded by cacheMutex
 	private final Map<IJavaProject, Map<AnnotationProcessorFactory, FactoryPath.Attributes>> _project2Java5Factories = 
-		new HashMap<IJavaProject, Map<AnnotationProcessorFactory, FactoryPath.Attributes>>();
+		new HashMap<>();
 	
 	// Guarded by cacheMutex
 	private final Map<IJavaProject, Map<IServiceFactory, FactoryPath.Attributes>> _project2Java6Factories =
-		new HashMap<IJavaProject, Map<IServiceFactory, FactoryPath.Attributes>>();
+		new HashMap<>();
     
 	// Caches the iterative classloaders so that iterative processors
 	// are not reloaded on every batch build, unlike batch processors 
@@ -142,18 +142,18 @@ public class AnnotationProcessorFactoryLoader {
 	// See class comments for lifecycle of items in this cache.
 	// Guarded by cacheMutex
 	private final Map<IJavaProject, ClassLoader> _iterativeLoaders = 
-		new HashMap<IJavaProject, ClassLoader>();
+		new HashMap<>();
 	
 	// Guarded by cacheMutex
 	private final Map<IJavaProject,ClassLoader> _batchLoaders = 
-		new HashMap<IJavaProject,ClassLoader>();
+		new HashMap<>();
 	
 	// Caches information about which resources affect which projects'
 	// factory paths.
 	// See class comments for lifecycle of items in this cache.
 	// Guarded by cacheMutex	
 	private final Map<String, Set<IJavaProject>> _container2Project =
-		new HashMap<String, Set<IJavaProject>>();
+		new HashMap<>();
 	
    
 	/**
@@ -164,7 +164,7 @@ public class AnnotationProcessorFactoryLoader {
 
 		@Override
 		public void resourceChanged(IResourceChangeEvent event) {
-			Map<IJavaProject, LoadFailureHandler> failureHandlers = new HashMap<IJavaProject, LoadFailureHandler>();
+			Map<IJavaProject, LoadFailureHandler> failureHandlers = new HashMap<>();
 			switch (event.getType()) {
 			
 			// Project deletion
@@ -213,7 +213,7 @@ public class AnnotationProcessorFactoryLoader {
 		
 		private void addAffected(Set<IJavaProject> projects) {
 			if (_affected == null) {
-				 _affected = new HashSet<IJavaProject>(5);
+				 _affected = new HashSet<>(5);
 			}
 			_affected.addAll(projects);
 		}
@@ -322,7 +322,7 @@ public class AnnotationProcessorFactoryLoader {
      */
     public void resetAll() {
     	removeAptBuildProblemMarkers( null );
-    	Set<ClassLoader> toClose = new HashSet<ClassLoader>();
+    	Set<ClassLoader> toClose = new HashSet<>();
     	
     	synchronized (cacheMutex) {
     		toClose.addAll(_iterativeLoaders.values());
@@ -475,7 +475,7 @@ public class AnnotationProcessorFactoryLoader {
     	Map<AnnotationProcessorFactory, FactoryPath.Attributes> factoriesAndAttrs = 
     		getJava5FactoriesAndAttributesForProject(jproj);
     	final List<AnnotationProcessorFactory> factories = 
-    		new ArrayList<AnnotationProcessorFactory>(factoriesAndAttrs.keySet());
+    		new ArrayList<>(factoriesAndAttrs.keySet());
     	return Collections.unmodifiableList(factories);
     }
     
@@ -489,7 +489,7 @@ public class AnnotationProcessorFactoryLoader {
 		synchronized (cacheMutex) {
 			Set<IJavaProject> s = _container2Project.get(key);
 			if (s == null) {
-				s = new HashSet<IJavaProject>();
+				s = new HashSet<>();
 				_container2Project.put(key, s);
 			}
 			s.add(jproj);
@@ -531,9 +531,9 @@ public class AnnotationProcessorFactoryLoader {
 			LoadFailureHandler failureHandler)
 	{
 		Map<AnnotationProcessorFactory, FactoryPath.Attributes> java5Factories = 
-			new LinkedHashMap<AnnotationProcessorFactory, FactoryPath.Attributes>();
+			new LinkedHashMap<>();
 		Map<IServiceFactory, FactoryPath.Attributes> java6Factories =
-			new LinkedHashMap<IServiceFactory, FactoryPath.Attributes>();
+			new LinkedHashMap<>();
 		
 		removeAptBuildProblemMarkers(project);
 		Set<FactoryContainer> badContainers = verifyFactoryPath(project);
@@ -600,7 +600,7 @@ public class AnnotationProcessorFactoryLoader {
 			throws IOException
 	{
 		Map<String, String> factoryNames = fc.getFactoryNames();
-		List<AnnotationProcessorFactory> factories = new ArrayList<AnnotationProcessorFactory>(); 
+		List<AnnotationProcessorFactory> factories = new ArrayList<>();
 		for ( Entry<String, String> entry : factoryNames.entrySet() )
 		{
 			if (AptPlugin.JAVA5_FACTORY_NAME.equals(entry.getValue())) {
@@ -623,7 +623,7 @@ public class AnnotationProcessorFactoryLoader {
 			throws IOException
 	{
 		Map<String, String> factoryNames = fc.getFactoryNames();
-		List<IServiceFactory> factories = new ArrayList<IServiceFactory>(); 
+		List<IServiceFactory> factories = new ArrayList<>();
 		for ( Entry<String, String> entry : factoryNames.entrySet() )
 		{
 			if (AptPlugin.JAVA6_FACTORY_NAME.equals(entry.getValue())) {
@@ -715,7 +715,7 @@ public class AnnotationProcessorFactoryLoader {
 		// note that _project2Java6Factories.keySet() should be same as that for Java5.
 		Set<IJavaProject> jprojects;
 		synchronized (cacheMutex) {
-			jprojects = (jproj == null) ? new HashSet<IJavaProject>(_project2Java5Factories.keySet())
+			jprojects = (jproj == null) ? new HashSet<>(_project2Java5Factories.keySet())
 					: Collections.singleton(jproj);
 		}
 		try {
@@ -789,7 +789,7 @@ public class AnnotationProcessorFactoryLoader {
 			}
 			if ( !fc.exists() ) {
 				if (badContainers == null) {
-					badContainers = new HashSet<FactoryContainer>();
+					badContainers = new HashSet<>();
 				}
 				badContainers.add(fc);
 			}
@@ -802,7 +802,7 @@ public class AnnotationProcessorFactoryLoader {
 	 */
 	private static ClassLoader _createIterativeClassLoader( Map<FactoryContainer, FactoryPath.Attributes> containers )
 	{
-		ArrayList<File> fileList = new ArrayList<File>( containers.size() );
+		ArrayList<File> fileList = new ArrayList<>( containers.size() );
 		for (Map.Entry<FactoryContainer, FactoryPath.Attributes> entry : containers.entrySet()) {
 			FactoryPath.Attributes attr = entry.getValue();
 			FactoryContainer fc = entry.getKey();
@@ -827,7 +827,7 @@ public class AnnotationProcessorFactoryLoader {
 	 */
 	private ClassLoader _createBatchClassLoader(Map<FactoryContainer, FactoryPath.Attributes> containers,
 			IJavaProject p) {		
-		ArrayList<File> fileList = new ArrayList<File>( containers.size() );
+		ArrayList<File> fileList = new ArrayList<>( containers.size() );
 		for (Map.Entry<FactoryContainer, FactoryPath.Attributes> entry : containers.entrySet()) {
 			FactoryPath.Attributes attr = entry.getValue();
 			FactoryContainer fc = entry.getKey();
@@ -877,7 +877,7 @@ public class AnnotationProcessorFactoryLoader {
 
 	private static ClassLoader createClassLoader(List<File> files, ClassLoader parentCL) {
 		//return new JarClassLoader(files, parentCL);
-		List<URL> urls = new ArrayList<URL>(files.size());
+		List<URL> urls = new ArrayList<>(files.size());
 		for (int i=0;i<files.size();i++) {
 			try {
 				urls.add(files.get(i).toURI().toURL());
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptCompilationParticipant.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptCompilationParticipant.java
index 4b2d61d..25f0b81 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptCompilationParticipant.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptCompilationParticipant.java
@@ -1,5 +1,5 @@
  /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc. 
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -48,7 +48,7 @@ public class AptCompilationParticipant extends CompilationParticipant
 	 * and hence cause APT rounding.
 	 * The set is an order preserving. The order is determined by their first invocation.
 	 */
-	private Set<AnnotationProcessorFactory> _previousRoundsBatchFactories = new LinkedHashSet<AnnotationProcessorFactory>();
+	private Set<AnnotationProcessorFactory> _previousRoundsBatchFactories = new LinkedHashSet<>();
 	private int _buildRound = 0;
 	private boolean _isBatch = false; 
 	private static final AptCompilationParticipant INSTANCE = new AptCompilationParticipant();
@@ -246,8 +246,8 @@ public class AptCompilationParticipant extends CompilationParticipant
 		}		
 		_buildRound = 0; // reset
 		// Note that for each project build, we blow away the last project's processed files.
-		_processedFiles = new HashMap<IFile, CategorizedProblem[]>();
-		_java6GeneratedFiles = new HashSet<IFile>();
+		_processedFiles = new HashMap<>();
+		_java6GeneratedFiles = new HashSet<>();
 		// TODO: (wharley) if the factory path is different we need a full build
 		return CompilationParticipant.READY_FOR_BUILD;
 	}
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptPlugin.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptPlugin.java
index 1aec290..818291b 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptPlugin.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/AptPlugin.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 BEA Systems, Inc. and others.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc. and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -81,7 +81,7 @@ public class AptPlugin extends Plugin implements DebugOptionsListener {
 	// Entries are added lazily in getAptProject(), and removed upon
 	// project deletion in deleteAptProject().
 	private static final Map<IJavaProject,AptProject> PROJECT_MAP = 
-		new HashMap<IJavaProject,AptProject>();
+		new HashMap<>();
 
 	// Qualified names of services for which these containers may provide implementations
 	public static final String JAVA5_FACTORY_NAME = "com.sun.mirror.apt.AnnotationProcessorFactory"; //$NON-NLS-1$
@@ -92,7 +92,7 @@ public class AptPlugin extends Plugin implements DebugOptionsListener {
 		super.start(context);
 
 		// register debug options listener
-		Hashtable<String, String> properties = new Hashtable<String, String>(2);
+		Hashtable<String, String> properties = new Hashtable<>(2);
 		properties.put(DebugOptions.LISTENER_SYMBOLICNAME, PLUGIN_ID);
 		debugRegistration = context.registerService(DebugOptionsListener.class, this, properties);
 
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/FactoryPluginManager.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/FactoryPluginManager.java
index ed7485c..910777d 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/FactoryPluginManager.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/FactoryPluginManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 BEA Systems, Inc. 
+ * Copyright (c) 2007, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -41,7 +41,7 @@ public class FactoryPluginManager {
 	 * To support lazy initialization, this should only be accessed by calling
 	 * @see #getJava5PluginFactoryMap() . 
 	 */
-	private static final HashMap<String, AnnotationProcessorFactory> PLUGIN_JAVA5_FACTORY_MAP = new HashMap<String, AnnotationProcessorFactory>();
+	private static final HashMap<String, AnnotationProcessorFactory> PLUGIN_JAVA5_FACTORY_MAP = new HashMap<>();
 	
 	/** 
 	 * Map of factory names -> factories.  A single plugin factory container may 
@@ -49,7 +49,7 @@ public class FactoryPluginManager {
 	 * To support lazy initialization, this should only be accessed by calling
 	 * @see #getJava5PluginFactoryMap() . 
 	 */
-	private static final HashMap<String, IServiceFactory> PLUGIN_JAVA6_FACTORY_MAP = new HashMap<String, IServiceFactory>();
+	private static final HashMap<String, IServiceFactory> PLUGIN_JAVA6_FACTORY_MAP = new HashMap<>();
 
 	/** 
 	 * Map of plugin names -> plugin factory containers, sorted by plugin name.
@@ -58,7 +58,7 @@ public class FactoryPluginManager {
 	 * To support lazy initialization, this should only be accessed by calling
 	 * @see #getPluginFactoryContainerMap() . 
 	 */
-	private static final TreeMap<String, PluginFactoryContainer> PLUGIN_CONTAINER_MAP = new TreeMap<String, PluginFactoryContainer>();
+	private static final TreeMap<String, PluginFactoryContainer> PLUGIN_CONTAINER_MAP = new TreeMap<>();
 
 	/** 
 	 * true if PLUGIN_FACTORY_MAP and PLUGIN_CONTAINER_MAP have been initialized,
@@ -77,7 +77,7 @@ public class FactoryPluginManager {
 	public static synchronized Map<FactoryContainer, FactoryPath.Attributes> getAllPluginFactoryContainers()
 	{
 		Map<FactoryContainer, FactoryPath.Attributes> map = 
-			new LinkedHashMap<FactoryContainer, FactoryPath.Attributes>(getPluginContainerMap().size());
+			new LinkedHashMap<>(getPluginContainerMap().size());
 		for (PluginFactoryContainer pfc : getPluginContainerMap().values()) {
 			FactoryPath.Attributes a = new FactoryPath.Attributes(pfc.getEnableDefault(), false);
 			map.put(pfc, a);
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/JarClassLoader.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/JarClassLoader.java
index 90e878e..f00bb17 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/JarClassLoader.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/JarClassLoader.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc. 
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -44,13 +44,13 @@ public class JarClassLoader extends ClassLoader {
 	// This is nulled out when the classloader is closed
 	private List<JarFile> _jars;
 	private final LinkedHashSet<File> _files;
-	private List<JarCLInputStream> _openStreams = new LinkedList<JarCLInputStream>();
+	private List<JarCLInputStream> _openStreams = new LinkedList<>();
 	private boolean _open = true;
 	
 	public JarClassLoader(List<File> jarFiles, final ClassLoader parent) {
 		super(parent);
 		// Handle manifest classpath entries
-		_files = new LinkedHashSet<File>(jarFiles);
+		_files = new LinkedHashSet<>(jarFiles);
 		for (File f : jarFiles) {
 			_recursiveGetManifestJars(f, _files);
 		}
@@ -59,7 +59,7 @@ public class JarClassLoader extends ClassLoader {
 	
 	private void open() {
 		// Create all jar files
-		_jars = new ArrayList<JarFile>(_files.size());
+		_jars = new ArrayList<>(_files.size());
 		for (File f : _files) {
 			try {
 				JarFile jar = new JarFile(f);
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/JarFactoryContainer.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/JarFactoryContainer.java
index dcf70a5..386c946 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/JarFactoryContainer.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/JarFactoryContainer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -69,7 +69,7 @@ public abstract class JarFactoryContainer extends FactoryContainer
      */
     protected static Map<String, String> getServiceClassnamesFromJar(File jar) throws IOException
     {
-        Map<String, String> classNames = new LinkedHashMap<String, String>();
+        Map<String, String> classNames = new LinkedHashMap<>();
         JarFile jarFile = null;
         try {
             jarFile = new JarFile(jar);
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/LoadFailureHandler.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/LoadFailureHandler.java
index 59df020..6f2fba0 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/LoadFailureHandler.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/LoadFailureHandler.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2008 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -33,8 +33,8 @@ import org.eclipse.jdt.core.IJavaProject;
 public class LoadFailureHandler {
 	
 	private final IProject _project;
-	private final List<String> _missingLibraries = new ArrayList<String>();
-	private final List<String> _failedFactories = new ArrayList<String>();
+	private final List<String> _missingLibraries = new ArrayList<>();
+	private final List<String> _failedFactories = new ArrayList<>();
 	
 	public LoadFailureHandler(IJavaProject proj) {
 		_project = proj.getProject();
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/PluginFactoryContainer.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/PluginFactoryContainer.java
index 0b515c6..f5e0be9 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/PluginFactoryContainer.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/PluginFactoryContainer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -54,7 +54,7 @@ public class PluginFactoryContainer extends FactoryContainer
 
 	protected Map<String, String> loadFactoryNames() {
 		// The list is populated when factory plugins are loaded.
-		return new LinkedHashMap<String, String>();
+		return new LinkedHashMap<>();
 	}
 	
 	public String getId() {
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ASTBasedDeclarationImpl.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ASTBasedDeclarationImpl.java
index ccbd6da..93260bb 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ASTBasedDeclarationImpl.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ASTBasedDeclarationImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2009 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -82,7 +82,7 @@ public abstract class ASTBasedDeclarationImpl extends EclipseDeclarationImpl {
 	
 	private Collection<Modifier> getModifiers(int modBits)
 	{	
-		final List<Modifier> mods = new ArrayList<Modifier>(4);
+		final List<Modifier> mods = new ArrayList<>(4);
         if( org.eclipse.jdt.core.dom.Modifier.isAbstract(modBits) )		
         	mods.add(Modifier.ABSTRACT);
         if( org.eclipse.jdt.core.dom.Modifier.isFinal(modBits) ) 		
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/AnnotationMirrorImpl.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/AnnotationMirrorImpl.java
index 4136800..8b02e79 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/AnnotationMirrorImpl.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/AnnotationMirrorImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -88,7 +88,7 @@ public class AnnotationMirrorImpl implements AnnotationMirror, EclipseMirrorObje
 		}
 
 		final Map<AnnotationTypeElementDeclaration, AnnotationValue> result =
-			new LinkedHashMap<AnnotationTypeElementDeclaration, AnnotationValue>(pairs.length * 4 / 3 + 1 );
+			new LinkedHashMap<>(pairs.length * 4 / 3 + 1 );
 		for( IMemberValuePairBinding pair : pairs ){
 			 final String name = pair.getName();
              if( name == null ) continue;
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ClassDeclarationImpl.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ClassDeclarationImpl.java
index aff8cc5..f1b91c9 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ClassDeclarationImpl.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ClassDeclarationImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2013 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -77,7 +77,7 @@ public class ClassDeclarationImpl extends TypeDeclarationImpl implements ClassDe
 
     public Collection<ConstructorDeclaration> getConstructors()
     {
-    	final List<ConstructorDeclaration> results = new ArrayList<ConstructorDeclaration>();
+    	final List<ConstructorDeclaration> results = new ArrayList<>();
     	if( isFromSource() ){
     		// need to consult the ast since methods with broken signature 
     		// do not appear in bindings.
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/DeclarationImpl.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/DeclarationImpl.java
index 0df837e..f5a0107 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/DeclarationImpl.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/DeclarationImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -58,7 +58,7 @@ public abstract class DeclarationImpl extends EclipseDeclarationImpl {
     public Collection<Modifier> getModifiers()
     {
         final int modBits = getDeclarationBinding().getModifiers();
-        final List<Modifier> mods = new ArrayList<Modifier>(4);
+        final List<Modifier> mods = new ArrayList<>(4);
         if( org.eclipse.jdt.core.dom.Modifier.isAbstract(modBits) )		
         	mods.add(Modifier.ABSTRACT);
         if( org.eclipse.jdt.core.dom.Modifier.isFinal(modBits) ) 		
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/EclipseDeclarationImpl.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/EclipseDeclarationImpl.java
index 270f06f..a293f2e 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/EclipseDeclarationImpl.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/EclipseDeclarationImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2013 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -88,7 +88,7 @@ public abstract class EclipseDeclarationImpl implements Declaration, EclipseMirr
     {
         if( annoInstances == null || annoInstances.length == 0 ) 
         	return Collections.emptyList();
-        final List<AnnotationMirror> result = new ArrayList<AnnotationMirror>(annoInstances.length);
+        final List<AnnotationMirror> result = new ArrayList<>(annoInstances.length);
         for(IAnnotationBinding annoInstance : annoInstances){
         	if (annoInstance != null) {
 	            final AnnotationMirrorImpl annoMirror =
@@ -102,7 +102,7 @@ public abstract class EclipseDeclarationImpl implements Declaration, EclipseMirr
 	Collection<AnnotationMirror> _getAnnotationMirrors(List<org.eclipse.jdt.core.dom.Annotation> annoInstances)
 	{
 		if( annoInstances == null || annoInstances.size() == 0 ) return Collections.emptyList();
-		final List<AnnotationMirror> result = new ArrayList<AnnotationMirror>(annoInstances.size());
+		final List<AnnotationMirror> result = new ArrayList<>(annoInstances.size());
 		for( org.eclipse.jdt.core.dom.Annotation annoInstance : annoInstances){
 			if (annoInstance != null) {
 				final AnnotationMirrorImpl annoMirror =
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/EnumDeclarationImpl.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/EnumDeclarationImpl.java
index 67d7a20..ad2a70f 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/EnumDeclarationImpl.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/EnumDeclarationImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -44,7 +44,7 @@ public class EnumDeclarationImpl extends ClassDeclarationImpl implements EnumDec
     {
         final ITypeBinding enumBinding = getDeclarationBinding();
         final IVariableBinding[] fields = enumBinding.getDeclaredFields();
-        final List<EnumConstantDeclaration> results = new ArrayList<EnumConstantDeclaration>(4);
+        final List<EnumConstantDeclaration> results = new ArrayList<>(4);
         for( IVariableBinding field : fields ){
             if( field.isEnumConstant() ){
                 final Declaration mirrorDecl = Factory.createDeclaration(field, _env);
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ExecutableUtil.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ExecutableUtil.java
index 95a1d93..8499299 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ExecutableUtil.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/ExecutableUtil.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2013 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -55,7 +55,7 @@ class ExecutableUtil {
 			if (methodAstNode == null)
 				return Collections.emptyList();
 	    	final List<TypeParameter> typeParams = methodAstNode.typeParameters();
-	    	final List<TypeParameterDeclaration> result = new ArrayList<TypeParameterDeclaration>();
+	    	final List<TypeParameterDeclaration> result = new ArrayList<>();
 	    	for(TypeParameter typeParam : typeParams){
 	    		final ITypeBinding typeBinding = typeParam.resolveBinding();
 	    		if( typeBinding == null ){
@@ -77,7 +77,7 @@ class ExecutableUtil {
 				final ITypeBinding[] typeParams = methodBinding.getTypeParameters();        
 		        if( typeParams == null || typeParams.length == 0 )
 		            return Collections.emptyList();
-		        final List<TypeParameterDeclaration> result = new ArrayList<TypeParameterDeclaration>();
+		        final List<TypeParameterDeclaration> result = new ArrayList<>();
 		        for( ITypeBinding typeVar : typeParams ){
 		            final TypeParameterDeclaration typeParamDecl = 
 		            	(TypeParameterDeclaration)Factory.createDeclaration(typeVar, env);
@@ -119,7 +119,7 @@ class ExecutableUtil {
 	    	final List<SingleVariableDeclaration> params = methodAstNode.parameters();
 	    	if( params == null || params.size() == 0 )
 	    		return Collections.emptyList();  
-	    	final List<ParameterDeclaration> result = new ArrayList<ParameterDeclaration>(params.size());
+	    	final List<ParameterDeclaration> result = new ArrayList<>(params.size());
 	    	for( int i=0, size=params.size(); i<size; i++ ){   		
 	    		final SingleVariableDeclaration varDecl = params.get(i);
 	    		final ParameterDeclaration param = 
@@ -138,7 +138,7 @@ class ExecutableUtil {
 	        final ITypeBinding[] paramTypes = methodBinding.getParameterTypes();
 	        if( paramTypes == null || paramTypes.length == 0 )
 	            return Collections.emptyList();        
-	        final List<ParameterDeclaration> result = new ArrayList<ParameterDeclaration>(paramTypes.length);        
+	        final List<ParameterDeclaration> result = new ArrayList<>(paramTypes.length);
 	        
 	        for( int i=0; i<paramTypes.length; i++ ){
 	            final ITypeBinding type = paramTypes[i];
@@ -178,7 +178,7 @@ class ExecutableUtil {
 	    	final List<Type> exceptions = methodAstNode.thrownExceptionTypes();
 	    	if(exceptions == null || exceptions.size() == 0 )
 	    		return Collections.emptyList();
-	    	final List<ReferenceType> results = new ArrayList<ReferenceType>(4);
+	    	final List<ReferenceType> results = new ArrayList<>(4);
 	    	for(Type exception : exceptions ){
 	    		final ITypeBinding eType = exception.resolveBinding();
 	    		final ReferenceType refType;
@@ -197,7 +197,7 @@ class ExecutableUtil {
 			final ExecutableDeclarationImpl impl = (ExecutableDeclarationImpl)executable;
 			final IMethodBinding methodBinding = impl.getDeclarationBinding();			
 	        final ITypeBinding[] exceptions = methodBinding.getExceptionTypes();
-	        final List<ReferenceType> results = new ArrayList<ReferenceType>(4);
+	        final List<ReferenceType> results = new ArrayList<>(4);
 	        for( ITypeBinding exception : exceptions ){
 	            final TypeDeclaration mirrorDecl = Factory.createReferenceType(exception, env);
 	            if( mirrorDecl != null)
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/PackageDeclarationImpl.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/PackageDeclarationImpl.java
index 399e355..5341618 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/PackageDeclarationImpl.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/PackageDeclarationImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2008 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -106,7 +106,7 @@ public class PackageDeclarationImpl extends DeclarationImpl implements PackageDe
     public Collection<ClassDeclaration> getClasses() {
     	initFragments();
     	List<IType> types = getTypesInPackage(_pkgFragments);
-		List<ClassDeclaration> classes = new ArrayList<ClassDeclaration>();
+		List<ClassDeclaration> classes = new ArrayList<>();
 		for (IType type : types) {
 			try {
 				// isClass() will return true if TypeDeclaration is an InterfaceDeclaration
@@ -126,7 +126,7 @@ public class PackageDeclarationImpl extends DeclarationImpl implements PackageDe
     public Collection<EnumDeclaration> getEnums() {
     	initFragments();
     	List<IType> types = getTypesInPackage(_pkgFragments);
-		List<EnumDeclaration> enums = new ArrayList<EnumDeclaration>();
+		List<EnumDeclaration> enums = new ArrayList<>();
 		for (IType type : types) {
 			try {
 				if (type.isEnum()) {
@@ -142,7 +142,7 @@ public class PackageDeclarationImpl extends DeclarationImpl implements PackageDe
     public Collection<InterfaceDeclaration> getInterfaces() {
     	initFragments();
     	List<IType> types = getTypesInPackage(_pkgFragments);
-		List<InterfaceDeclaration> interfaces = new ArrayList<InterfaceDeclaration>();
+		List<InterfaceDeclaration> interfaces = new ArrayList<>();
 		for (IType type : types) {
 			try {
 				if (type.isInterface()) {
@@ -219,7 +219,7 @@ public class PackageDeclarationImpl extends DeclarationImpl implements PackageDe
 	}
 	
 	private static List<IType> getTypesInPackage(final IPackageFragment[] fragments) {
-		List<IType> types = new ArrayList<IType>();
+		List<IType> types = new ArrayList<>();
 		try {
 			// Get all top-level classes -- ignore local, member, and anonymous classes
 			for (IPackageFragment fragment : fragments) {
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeDeclarationImpl.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeDeclarationImpl.java
index d77db5fe..1adb188 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeDeclarationImpl.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeDeclarationImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2013 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -103,7 +103,7 @@ public abstract class TypeDeclarationImpl extends MemberDeclarationImpl
 
     public Collection<FieldDeclaration> getFields()
     {
-    	final List<FieldDeclaration> results = new ArrayList<FieldDeclaration>();
+    	final List<FieldDeclaration> results = new ArrayList<>();
     	final ITypeBinding typeBinding = getDeclarationBinding();
     	if( isFromSource() ){
     		final ASTNode node = 
@@ -144,7 +144,7 @@ public abstract class TypeDeclarationImpl extends MemberDeclarationImpl
     public Collection<TypeDeclaration> getNestedTypes()
     {
         final ITypeBinding[] memberTypes = getDeclarationBinding().getDeclaredTypes();
-        final List<TypeDeclaration> results = new ArrayList<TypeDeclaration>(memberTypes.length);
+        final List<TypeDeclaration> results = new ArrayList<>(memberTypes.length);
         for( ITypeBinding type : memberTypes ){
             Declaration mirrorDecl = Factory.createReferenceType(type, _env);
             if( mirrorDecl != null )
@@ -156,7 +156,7 @@ public abstract class TypeDeclarationImpl extends MemberDeclarationImpl
     public Collection<TypeParameterDeclaration> getFormalTypeParameters()
     {
         final ITypeBinding[] typeParams = getDeclarationBinding().getTypeParameters();
-        final List<TypeParameterDeclaration> results = new ArrayList<TypeParameterDeclaration>(typeParams.length);
+        final List<TypeParameterDeclaration> results = new ArrayList<>(typeParams.length);
         for( ITypeBinding typeParam : typeParams ){
             Declaration mirrorDecl = Factory.createDeclaration(typeParam, _env);
             if( mirrorDecl != null )
@@ -181,7 +181,7 @@ public abstract class TypeDeclarationImpl extends MemberDeclarationImpl
         if( typeArgs == null || typeArgs.length == 0 )
     		return Collections.emptyList();
 
-        final Collection<TypeMirror> result = new ArrayList<TypeMirror>(typeArgs.length);
+        final Collection<TypeMirror> result = new ArrayList<>(typeArgs.length);
         for( ITypeBinding arg : typeArgs ){
             final TypeMirror mirror = Factory.createTypeMirror(arg, _env);
             if (mirror == null)
@@ -211,7 +211,7 @@ public abstract class TypeDeclarationImpl extends MemberDeclarationImpl
         final ITypeBinding[] superInterfaceBindings = getDeclarationBinding().getInterfaces();
         if( superInterfaceBindings == null || superInterfaceBindings.length == 0 )
             return Collections.emptyList();
-        final List<InterfaceType> results = new ArrayList<InterfaceType>(superInterfaceBindings.length);
+        final List<InterfaceType> results = new ArrayList<>(superInterfaceBindings.length);
         for( ITypeBinding binding : superInterfaceBindings ){
             if( binding.isInterface() ){
                 final TypeDeclarationImpl mirrorDecl = Factory.createReferenceType(binding, _env);
@@ -282,7 +282,7 @@ public abstract class TypeDeclarationImpl extends MemberDeclarationImpl
 
     protected List<? extends MethodDeclaration> _getMethods()
     {
-    	final List<MethodDeclaration> results = new ArrayList<MethodDeclaration>();
+    	final List<MethodDeclaration> results = new ArrayList<>();
     	if( isFromSource() ){
     		// need to consult the ast since methods with broken signature 
     		// do not appear in bindings.
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeParameterDeclarationImpl.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeParameterDeclarationImpl.java
index 711e097..da05b72 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeParameterDeclarationImpl.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/declaration/TypeParameterDeclarationImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -65,7 +65,7 @@ public class TypeParameterDeclarationImpl extends DeclarationImpl implements
         if( bounds == null || bounds.length == 0 )
             return Collections.emptyList();
 
-        final Collection<ReferenceType> result = new ArrayList<ReferenceType>(4);
+        final Collection<ReferenceType> result = new ArrayList<>(4);
         for( ITypeBinding bound : bounds ){
             final ReferenceType type = Factory.createReferenceType(bound, _env);
              if( type != null )
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AbstractCompilationEnv.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AbstractCompilationEnv.java
index 5c03153..9841180 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AbstractCompilationEnv.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AbstractCompilationEnv.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2013 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -61,13 +61,13 @@ public abstract class AbstractCompilationEnv
 	
 	private Set<AnnotationProcessorListener> _listeners = null;
 	
-	protected List<APTProblem> _problems = new ArrayList<APTProblem>();
+	protected List<APTProblem> _problems = new ArrayList<>();
 	private boolean _isClosed = false;
 	
 	EnvCallback _callback;
 
-    private Set<IFile> _allGeneratedSourceFiles = new HashSet<IFile>();
-    private Set<IFile> _modifiedGeneratedSourceFiles = new HashSet<IFile>();	
+    private Set<IFile> _allGeneratedSourceFiles = new HashSet<>();
+    private Set<IFile> _modifiedGeneratedSourceFiles = new HashSet<>();
 
     /**
 	 * Currently open dom pipeline, used to request type bindings.
@@ -145,7 +145,7 @@ public abstract class AbstractCompilationEnv
     {
 		checkValid();
         if(_listeners == null )
-			_listeners = new HashSet<AnnotationProcessorListener>();
+			_listeners = new HashSet<>();
 		_listeners.add(listener);
     }
 
@@ -162,12 +162,12 @@ public abstract class AbstractCompilationEnv
 			return Collections.emptySet();
 		// Return a copy, to avoid ConcurrentModificationException if a listener
 		// removes itself in response to the callback.
-		return new HashSet<AnnotationProcessorListener>(_listeners);
+		return new HashSet<>(_listeners);
 	}
 	
 	public Map<String, String> getOptions()
     {
-        final HashMap<String, String> options = new HashMap<String, String>(_options);
+        final HashMap<String, String> options = new HashMap<>(_options);
 		options.put("phase", getPhase().toString()); //$NON-NLS-1$
 		return options;
     }
@@ -259,9 +259,9 @@ public abstract class AbstractCompilationEnv
 	public Map<String, AnnotationTypeDeclaration> getAnnotationTypes()
     {
     	checkValid();
-    	final List<Annotation> instances = new ArrayList<Annotation>();
+    	final List<Annotation> instances = new ArrayList<>();
 		final Map<String, AnnotationTypeDeclaration> decls = 
-			new HashMap<String, AnnotationTypeDeclaration>();
+			new HashMap<>();
 		final AnnotationVisitor visitor = new AnnotationVisitor(instances);
 		_astRoot.accept(visitor);
 			
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AnnotationInvocationHandler.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AnnotationInvocationHandler.java
index dff9c00..5533931 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AnnotationInvocationHandler.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/AnnotationInvocationHandler.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -92,7 +92,7 @@ public class AnnotationInvocationHandler implements InvocationHandler
                 if( classTypes == null || classTypes.length == 0 )
                     mirrorTypes = Collections.emptyList();
                 else{
-                    mirrorTypes = new ArrayList<TypeMirror>(classTypes.length);
+                    mirrorTypes = new ArrayList<>(classTypes.length);
                     for( ITypeBinding type : classTypes ){
                         TypeMirror mirror = Factory.createTypeMirror(type, _instance.getEnvironment() );
                         if( mirror == null )
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java
index 84522db..7967042 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BaseProcessorEnv.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2013 BEA Systems Inc. and others
+ * Copyright (c) 2005, 2015 BEA Systems Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -132,7 +132,7 @@ public class BaseProcessorEnv implements AnnotationProcessorEnvironment
 	// This type cache exists for the duration of a single round. 
 	// We store positive as well as negative hits. Negative hits are
 	// stored with a value of null
-	protected final Map<String,TypeDeclaration> _typeCache = new HashMap<String,TypeDeclaration>();
+	protected final Map<String,TypeDeclaration> _typeCache = new HashMap<>();
 	
 	protected IPackageFragmentRoot[] _packageRootsCache;
 	
@@ -146,8 +146,8 @@ public class BaseProcessorEnv implements AnnotationProcessorEnvironment
 		_javaProject = javaProj;
 		_phase = phase;
 		_options = initOptions(javaProj);
-		_modelCompUnit2astCompUnit = new HashMap<ICompilationUnit, CompilationUnit>();
-		_typeBinding2ModelCompUnit = new HashMap<ITypeBinding, ICompilationUnit>();
+		_modelCompUnit2astCompUnit = new HashMap<>();
+		_typeBinding2ModelCompUnit = new HashMap<>();
 		_aptProject = AptPlugin.getAptProject(javaProj);
 	}
   
@@ -170,7 +170,7 @@ public class BaseProcessorEnv implements AnnotationProcessorEnvironment
 	private Map<String, String> initOptions(IJavaProject jproj) {
 		Map<String, String> procOptions = AptConfig.getProcessorOptions(jproj);
 		// options is large enough to include the translated -A options
-		Map<String, String> options = new HashMap<String, String>(procOptions.size() * 2);
+		Map<String, String> options = new HashMap<>(procOptions.size() * 2);
 		
 		// Add configured options
 		for (Map.Entry<String, String> entry : procOptions.entrySet()) {
@@ -221,7 +221,7 @@ public class BaseProcessorEnv implements AnnotationProcessorEnvironment
     	final List<ITypeBinding> bindings = getTypeBindings();
 		if( bindings.isEmpty() )
 			return Collections.emptyList();
-		final List<TypeDeclaration> mirrorDecls = new ArrayList<TypeDeclaration>(bindings.size());
+		final List<TypeDeclaration> mirrorDecls = new ArrayList<>(bindings.size());
 
 		for( ITypeBinding binding : bindings ){
 			final TypeDeclaration mirrorDecl = Factory.createReferenceType(binding, this);
@@ -242,7 +242,7 @@ public class BaseProcessorEnv implements AnnotationProcessorEnvironment
     	final List<AbstractTypeDeclaration> declTypes = searchLocallyForTypeDeclarations();    	
 		if( declTypes == null || declTypes.isEmpty() )
 			return Collections.emptyList();
-		final List<ITypeBinding> typeBindings = new ArrayList<ITypeBinding>(declTypes.size());
+		final List<ITypeBinding> typeBindings = new ArrayList<>(declTypes.size());
 
 		for( AbstractTypeDeclaration decl : declTypes ){
 			getTypeBindings(decl.resolveBinding(), typeBindings);
@@ -284,7 +284,7 @@ public class BaseProcessorEnv implements AnnotationProcessorEnvironment
      */
     protected Map<ASTNode, List<Annotation>> getASTNodesWithAnnotations()
     {
-    	final Map<ASTNode, List<Annotation>> astNode2Anno = new HashMap<ASTNode, List<Annotation>>();
+    	final Map<ASTNode, List<Annotation>> astNode2Anno = new HashMap<>();
         final AnnotatedNodeVisitor visitor = new AnnotatedNodeVisitor(astNode2Anno);
         _astRoot.accept(visitor);
         return astNode2Anno;
@@ -295,7 +295,7 @@ public class BaseProcessorEnv implements AnnotationProcessorEnvironment
         final Map<ASTNode, List<Annotation>> astNode2Anno = getASTNodesWithAnnotations();       
 		if( astNode2Anno.isEmpty() )
 			return Collections.emptyList();
-		final List<Declaration> decls = new ArrayList<Declaration>();
+		final List<Declaration> decls = new ArrayList<>();
 		for(Map.Entry<ASTNode, List<Annotation>> entry : astNode2Anno.entrySet() ){
 			final ASTNode node = entry.getKey();
 			for( Annotation anno : entry.getValue() ){
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BuildEnv.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BuildEnv.java
index 64b6771..1cec13b 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BuildEnv.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/env/BuildEnv.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2013 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -53,7 +53,7 @@ public class BuildEnv extends AbstractCompilationEnv
 	 * Set of strings that indicate new type dependencies introduced on the file
 	 * each string is a fully-qualified type name.
 	 */
-	private Set<String> _typeDependencies = new HashSet<String>();
+	private Set<String> _typeDependencies = new HashSet<>();
 	
 	/**
 	 * Indicates whether we are in batch mode or not. This gets flipped only 
@@ -100,8 +100,8 @@ public class BuildEnv extends AbstractCompilationEnv
 		_filer = new BuildFilerImpl(this);
 		_filesWithAnnotation = filesWithAnnotations;
 		_additionFiles = additionalFiles;
-		_problems = new ArrayList<APTProblem>();
-		_markerInfos = new ArrayList<MarkerInfo>();
+		_problems = new ArrayList<>();
+		_markerInfos = new ArrayList<>();
 		
 		if (AptPlugin.DEBUG_COMPILATION_ENV) AptPlugin.trace( 
 				"constructed " + this + " for " + _filesWithAnnotation.length + " files"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
@@ -287,15 +287,15 @@ public class BuildEnv extends AbstractCompilationEnv
     	if( _filesWithAnnotation == null )  
     		return getAnnotationTypes();
     	
-		final List<Annotation> instances = new ArrayList<Annotation>();
+		final List<Annotation> instances = new ArrayList<>();
 		final Map<String, AnnotationTypeDeclaration> decls = 
-			new HashMap<String, AnnotationTypeDeclaration>();
+			new HashMap<>();
 		final AnnotationVisitor visitor = new AnnotationVisitor(instances);
 		for( int astIndex=0, len=_astRoots.length; astIndex<len; astIndex++ ){
 			if( _astRoots == null || _astRoots[astIndex] == null  )
 				System.err.println();
 			_astRoots[astIndex].accept(visitor);
-			final Set<AnnotationTypeDeclaration> perFileAnnos = new HashSet<AnnotationTypeDeclaration>(); 
+			final Set<AnnotationTypeDeclaration> perFileAnnos = new HashSet<>();
 			
 			for (int instanceIndex=0, size = instances.size(); instanceIndex < size; instanceIndex++) {
 				final Annotation instance = instances.get(instanceIndex);
@@ -426,7 +426,7 @@ public class BuildEnv extends AbstractCompilationEnv
     {
 		if( !_batchMode )
 			return super.searchLocallyForTypeDeclarations();
-		final List<AbstractTypeDeclaration> typeDecls = new ArrayList<AbstractTypeDeclaration>();
+		final List<AbstractTypeDeclaration> typeDecls = new ArrayList<>();
 		for( int i=0, len=_astRoots.length; i<len; i++ )
         	typeDecls.addAll( _astRoots[i].types() );
 		
@@ -460,7 +460,7 @@ public class BuildEnv extends AbstractCompilationEnv
     {
 		if( !_batchMode )
 			return super.getASTNodesWithAnnotations();
-    	final Map<ASTNode, List<Annotation>> astNode2Anno = new HashMap<ASTNode, List<Annotation>>();
+    	final Map<ASTNode, List<Annotation>> astNode2Anno = new HashMap<>();
         final AnnotatedNodeVisitor visitor = new AnnotatedNodeVisitor(astNode2Anno);        
         for( int i=0, len=_astRoots.length; i<len; i++ )
         	_astRoots[i].accept( visitor );
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/ClasspathUtil.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/ClasspathUtil.java
index 2a656e7..b46c8ab 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/ClasspathUtil.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/ClasspathUtil.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -156,7 +156,7 @@ public class ClasspathUtil {
 		if (!found) 
 		{
 			// update exclusion patterns
-			ArrayList<IPath> exclusions = new ArrayList<IPath>();
+			ArrayList<IPath> exclusions = new ArrayList<>();
 			for ( int i = 0; i< cp.length; i++ )
 			{
 				if ( cp[i].getPath().isPrefixOf( path ) )
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java
index cd877b4..47690dc 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2009 BEA Systems, Inc. and others
+ * Copyright (c) 2005, 2015 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -318,11 +318,11 @@ public class GeneratedFileManager
 		_jProject = aptProject.getJavaProject();
 		_gsfm = gsfm;
 		_buildDeps = new GeneratedFileMap(_jProject.getProject());
-		_clearDuringReconcile = new HashSet<IFile>();
-		_reconcileDeps = new ManyToMany<IFile, IFile>();
-		_reconcileNonDeps = new ManyToMany<IFile, IFile>();
-		_hiddenBuiltTypes = new HashMap<IFile, ICompilationUnit>();
-		_reconcileGenTypes = new HashMap<IFile, ICompilationUnit>();
+		_clearDuringReconcile = new HashSet<>();
+		_reconcileDeps = new ManyToMany<>();
+		_reconcileNonDeps = new ManyToMany<>();
+		_hiddenBuiltTypes = new HashMap<>();
+		_reconcileGenTypes = new HashMap<>();
 		_generatedPackageFragmentRoot = new GeneratedPackageFragmentRoot();
 	}
 
@@ -386,8 +386,8 @@ public class GeneratedFileManager
 	public Set<IFile> deleteObsoleteFilesAfterBuild(IFile parentFile, Set<IFile> newlyGeneratedFiles)
 	{
 		Set<IFile> deleted;
-		List<ICompilationUnit> toDiscard = new ArrayList<ICompilationUnit>();
-		Set<IFile> toReport = new HashSet<IFile>();
+		List<ICompilationUnit> toDiscard = new ArrayList<>();
+		Set<IFile> toReport = new HashSet<>();
 		deleted = computeObsoleteFiles(parentFile, newlyGeneratedFiles, toDiscard, toReport);
 		
 		for (IFile toDelete : deleted) {
@@ -427,8 +427,8 @@ public class GeneratedFileManager
 	{
 		IFile parentFile = (IFile) parentWC.getResource();
 
-		List<ICompilationUnit> toSetBlank = new ArrayList<ICompilationUnit>();
-		List<ICompilationUnit> toDiscard = new ArrayList<ICompilationUnit>();
+		List<ICompilationUnit> toSetBlank = new ArrayList<>();
+		List<ICompilationUnit> toDiscard = new ArrayList<>();
 		computeObsoleteReconcileTypes(parentFile, newlyGeneratedFiles, _CUHELPER, toSetBlank, toDiscard);
 
 		for (ICompilationUnit wcToDiscard : toDiscard) {
@@ -774,7 +774,7 @@ public class GeneratedFileManager
 		// keys in _reconcileGenTypes.
 		Set<IFile> depChildren = _reconcileDeps.getValueSet(); // copy - safe to modify
 		Set<IFile> genTypes = _reconcileGenTypes.keySet(); // not a copy!
-		List<IFile> extraFiles = new ArrayList<IFile>(); 
+		List<IFile> extraFiles = new ArrayList<>();
 		for (IFile f : genTypes) {
 			if (!depChildren.remove(f)) {
 				extraFiles.add(f);
@@ -790,7 +790,7 @@ public class GeneratedFileManager
 		}
 		
 		// Every file in _clearDuringReconcile must be a value in _buildDeps.
-		List<IFile> extraClearDuringReconcileFiles = new ArrayList<IFile>();
+		List<IFile> extraClearDuringReconcileFiles = new ArrayList<>();
 		for (IFile clearDuringReconcile : _clearDuringReconcile) {
 			if (!_buildDeps.containsValue(clearDuringReconcile)) {
 				extraClearDuringReconcileFiles.add(clearDuringReconcile);
@@ -802,7 +802,7 @@ public class GeneratedFileManager
 		}
 		
 		// Every key in _hiddenBuiltTypes must be a value in _reconcileNonDeps.
-		List<IFile> extraHiddenTypes = new ArrayList<IFile>();
+		List<IFile> extraHiddenTypes = new ArrayList<>();
 		for (IFile hidden : _hiddenBuiltTypes.keySet()) {
 			if (!_reconcileNonDeps.containsValue(hidden)) {
 				extraHiddenTypes.add(hidden);
@@ -815,7 +815,7 @@ public class GeneratedFileManager
 		
 		// There can be no parent/child pairs that exist in both _reconcileDeps
 		// and _reconcileNonDeps.
-		Map<IFile, IFile> reconcileOverlaps = new HashMap<IFile, IFile>();
+		Map<IFile, IFile> reconcileOverlaps = new HashMap<>();
 		for (IFile parent : _reconcileNonDeps.getKeySet()) {
 			for (IFile child : _reconcileNonDeps.getValues(parent)) {
 				if (_reconcileDeps.containsKeyValuePair(parent, child)) {
@@ -830,7 +830,7 @@ public class GeneratedFileManager
 		
 		// Every parent/child pair in _reconcileNonDeps must have a matching
 		// parent/child pair in _buildDeps.
-		Map<IFile, IFile> extraNonDeps = new HashMap<IFile, IFile>();
+		Map<IFile, IFile> extraNonDeps = new HashMap<>();
 		for (IFile parent : _reconcileNonDeps.getKeySet()) {
 			for (IFile child : _reconcileNonDeps.getValues(parent)) {
 				if (!_buildDeps.containsKeyValuePair(parent, child)) {
@@ -844,7 +844,7 @@ public class GeneratedFileManager
 		}
 		
 		// Values in _hiddenBuiltTypes must not be null
-		List<IFile> nullHiddenTypes = new ArrayList<IFile>();
+		List<IFile> nullHiddenTypes = new ArrayList<>();
 		for (Map.Entry<IFile, ICompilationUnit> entry : _hiddenBuiltTypes.entrySet()) {
 			if (entry.getValue() == null) {
 				nullHiddenTypes.add(entry.getKey());
@@ -855,7 +855,7 @@ public class GeneratedFileManager
 		}
 		
 		// Values in _reconcileGenTypes must not be null
-		List<IFile> nullReconcileTypes = new ArrayList<IFile>();
+		List<IFile> nullReconcileTypes = new ArrayList<>();
 		for (Map.Entry<IFile, ICompilationUnit> entry : _reconcileGenTypes.entrySet()) {
 			if (entry.getValue() == null) {
 				nullReconcileTypes.add(entry.getKey());
@@ -889,7 +889,7 @@ public class GeneratedFileManager
 	private synchronized List<ICompilationUnit> computeProjectClosed(boolean deleteState)
 	{
 		int size = _hiddenBuiltTypes.size() + _reconcileGenTypes.size();
-		List<ICompilationUnit> toDiscard = new ArrayList<ICompilationUnit>(size);
+		List<ICompilationUnit> toDiscard = new ArrayList<>(size);
 		toDiscard.addAll(_hiddenBuiltTypes.values());
 		toDiscard.addAll(_reconcileGenTypes.values());
 		_reconcileGenTypes.clear();
@@ -963,7 +963,7 @@ public class GeneratedFileManager
 		_buildDeps.clearState();
 		_clearDuringReconcile.clear();
 		_reconcileNonDeps.clear();
-		List<ICompilationUnit> toDiscard = new ArrayList<ICompilationUnit>(_hiddenBuiltTypes.values());
+		List<ICompilationUnit> toDiscard = new ArrayList<>(_hiddenBuiltTypes.values());
 		_hiddenBuiltTypes.clear();
 		
 		assert checkIntegrity();
@@ -980,7 +980,7 @@ public class GeneratedFileManager
 	 */
 	private Set<IFolder> computeNewPackageFolders(String pkgName, IFolder parent)
 	{
-		Set<IFolder> newFolders = new HashSet<IFolder>();
+		Set<IFolder> newFolders = new HashSet<>();
 		String[] folders = _PACKAGE_DELIMITER.split(pkgName);
 		for (String folderName : folders) {
 			final IFolder folder = parent.getFolder(folderName);
@@ -1018,7 +1018,7 @@ public class GeneratedFileManager
 			List<ICompilationUnit> toDiscard,
 			Set<IFile> toReport)
 	{
-		Set<IFile> deleted = new HashSet<IFile>();
+		Set<IFile> deleted = new HashSet<>();
 		Set<IFile> obsoleteFiles = _buildDeps.getValues(parentFile);
 		// spare all the newly generated files
 		obsoleteFiles.removeAll(newlyGeneratedFiles);
@@ -1071,7 +1071,7 @@ public class GeneratedFileManager
 		{
 			// Get types previously but no longer generated during reconcile
 			Set<IFile> obsoleteFiles = _reconcileDeps.getValues(parentFile);
-			Map<IFile, ICompilationUnit> typesToDiscard = new HashMap<IFile, ICompilationUnit>();
+			Map<IFile, ICompilationUnit> typesToDiscard = new HashMap<>();
 			obsoleteFiles.removeAll(newlyGeneratedFiles);
 			for (IFile obsoleteFile : obsoleteFiles) {
 				_reconcileDeps.remove(parentFile, obsoleteFile);
@@ -1137,7 +1137,7 @@ public class GeneratedFileManager
 	 */
 	private synchronized List<ICompilationUnit> computeObsoleteHiddenTypes(IFile parentFile, Set<IFile> deletedFiles)
 	{
-		List<ICompilationUnit> toDiscard = new ArrayList<ICompilationUnit>();
+		List<ICompilationUnit> toDiscard = new ArrayList<>();
 		for (IFile deletedFile : deletedFiles) {
 			if (_reconcileNonDeps.remove(parentFile, deletedFile)) {
 				ICompilationUnit wc = _hiddenBuiltTypes.remove(deletedFile);
@@ -1396,7 +1396,7 @@ public class GeneratedFileManager
 	 */
 	private synchronized List<IFile> removeFileFromBuildMaps(IFile f)
 	{
-		List<IFile> toDelete = new ArrayList<IFile>();
+		List<IFile> toDelete = new ArrayList<>();
 		// Is this file the sole parent of files generated during build?
 		// If so, add them to the deletion list. Then remove the file from
 		// the build dependency list.
@@ -1435,7 +1435,7 @@ public class GeneratedFileManager
 	 */
 	private synchronized List<ICompilationUnit> removeFileFromReconcileMaps(IFile file)
 	{
-		List<ICompilationUnit> toDiscard = new ArrayList<ICompilationUnit>();
+		List<ICompilationUnit> toDiscard = new ArrayList<>();
 		// remove all the orphaned children
 		Set<IFile> genFiles = _reconcileDeps.getValues(file);
 		for (IFile child : genFiles) {
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileMap.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileMap.java
index 9743606..49d5fb1 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileMap.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedFileMap.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2008 BEA Systems, Inc.
+ * Copyright (c) 2006, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -49,7 +49,7 @@ public class GeneratedFileMap extends ManyToMany<IFile, IFile> {
 	
 	private final IProject _proj;
 	
-	private final Map<IFile, Set<Flags>> _flags = new HashMap<IFile, Set<Flags>>();
+	private final Map<IFile, Set<Flags>> _flags = new HashMap<>();
 	
 	public GeneratedFileMap(IProject proj) {
 		_proj = proj;
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedResourceChangeListener.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedResourceChangeListener.java
index afcbadc..f56186e 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedResourceChangeListener.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/generatedfile/GeneratedResourceChangeListener.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc. 
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -150,9 +150,9 @@ public class GeneratedResourceChangeListener implements IResourceChangeListener
 	private class PreBuildVisitor implements IResourceDeltaVisitor
 	{
 		// projects that we need to add the generated source folder to.
-		private final Set<IProject> _addGenFolderTo = new HashSet<IProject>();
+		private final Set<IProject> _addGenFolderTo = new HashSet<>();
 		// any projects that is closed or about to be deleted
-		private final Set<IProject> _removedProjects = new HashSet<IProject>();
+		private final Set<IProject> _removedProjects = new HashSet<>();
 		public boolean visit(IResourceDelta delta) throws CoreException 
 		{
 			IResource r = delta.getResource();
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Factory.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Factory.java
index acaafc6..bbdc53b 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Factory.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Factory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2012 BEA Systems, Inc. and others
+ * Copyright (c) 2005, 2015 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -337,7 +337,7 @@ public class Factory
 		{
 			final Object[] elements = (Object[])domValue;
 			final int len = elements.length;
-            final List<AnnotationValue> annoValues = new ArrayList<AnnotationValue>(len);
+            final List<AnnotationValue> annoValues = new ArrayList<>(len);
             final TypeMirror leaf; 
             if( expectedType instanceof ArrayType )
             	leaf = ((ArrayType)expectedType).getComponentType();
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPath.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPath.java
index 224d480..fafa720 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPath.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPath.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -211,7 +211,7 @@ public class FactoryPath implements IFactoryPath {
 			// so we're forced to do two copies.  Make the new map
 			// large enough that we don't have to rehash midway through the putAll().
 			Map<FactoryContainer, Attributes> newPath = 
-				new LinkedHashMap<FactoryContainer, Attributes>(1 + 4*(_path.size() + 1)/3);
+				new LinkedHashMap<>(1 + 4*(_path.size() + 1)/3);
 			newPath.put(fc, a);
 			newPath.putAll(_path);
 			_path.clear();
@@ -220,7 +220,7 @@ public class FactoryPath implements IFactoryPath {
 	}
 
 	public Map<FactoryContainer, Attributes> getEnabledContainers() {
-		Map<FactoryContainer, Attributes> map = new LinkedHashMap<FactoryContainer, Attributes>();
+		Map<FactoryContainer, Attributes> map = new LinkedHashMap<>();
 		synchronized(_path) {
 			for (Map.Entry<FactoryContainer, Attributes> entry : _path.entrySet()) {
 				Attributes attr = entry.getValue();
@@ -237,7 +237,7 @@ public class FactoryPath implements IFactoryPath {
 	 * @return a copy of the path
 	 */
 	public Map<FactoryContainer, Attributes> getAllContainers() {
-		Map<FactoryContainer, Attributes> map = new LinkedHashMap<FactoryContainer, Attributes>(_path.size());
+		Map<FactoryContainer, Attributes> map = new LinkedHashMap<>(_path.size());
 		synchronized(_path) {
 			for( Map.Entry<FactoryContainer, Attributes> entry : _path.entrySet() ){
 				map.put( entry.getKey(), new Attributes(entry.getValue()) );
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPathUtil.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPathUtil.java
index d939b1e..169f1d0 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPathUtil.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/FactoryPathUtil.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc. 
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -213,7 +213,7 @@ public final class FactoryPathUtil {
 	public static Map<FactoryContainer, FactoryPath.Attributes> decodeFactoryPath(final String xmlFactoryPath) 
 	throws CoreException
 	{
-		Map<FactoryContainer, FactoryPath.Attributes> result = new LinkedHashMap<FactoryContainer, FactoryPath.Attributes>();
+		Map<FactoryContainer, FactoryPath.Attributes> result = new LinkedHashMap<>();
 		StringReader reader = new StringReader(xmlFactoryPath);
 		Element fpElement = null;
 
@@ -357,7 +357,7 @@ public final class FactoryPathUtil {
 		}
 		// if no project and no workspace data was found, we'll get the defaults
 		if (map == null) {
-			map = new LinkedHashMap<FactoryContainer, FactoryPath.Attributes>();
+			map = new LinkedHashMap<>();
 		}
 		boolean disableNewPlugins = (jproj != null) && foundPerProjFile;
 		updatePluginContainers(map, disableNewPlugins);
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/ManyToMany.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/ManyToMany.java
index 6de20ff..0a6ac68 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/ManyToMany.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/ManyToMany.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2007 BEA Systems, Inc.
+ * Copyright (c) 2006, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -37,8 +37,8 @@ import java.util.Set;
  */
 public class ManyToMany<T1, T2> {
 	
-	private final Map<T1, Set<T2>> _forward = new HashMap<T1, Set<T2>>();
-	private final Map<T2, Set<T1>> _reverse = new HashMap<T2, Set<T1>>();
+	private final Map<T1, Set<T2>> _forward = new HashMap<>();
+	private final Map<T2, Set<T1>> _reverse = new HashMap<>();
 	private boolean _dirty = false;
 	
 	/**
@@ -105,7 +105,7 @@ public class ManyToMany<T1, T2> {
 		if (null == keys) {
 			return Collections.emptySet();
 		}
-		return new HashSet<T1>(keys);
+		return new HashSet<>(keys);
 	}
 	
 	/**
@@ -119,7 +119,7 @@ public class ManyToMany<T1, T2> {
 		if (null == values) {
 			return Collections.emptySet();
 		}
-		return new HashSet<T2>(values);
+		return new HashSet<>(values);
 	}
 
 	/**
@@ -129,7 +129,7 @@ public class ManyToMany<T1, T2> {
 	 * @see #getValueSet()
 	 */
 	public synchronized Set<T1> getKeySet() {
-		Set<T1> keys = new HashSet<T1>(_forward.keySet());
+		Set<T1> keys = new HashSet<>(_forward.keySet());
 		return keys;
 	}
 	
@@ -140,7 +140,7 @@ public class ManyToMany<T1, T2> {
 	 * @see #getKeySet()
 	 */
 	public synchronized Set<T2> getValueSet() {
-		Set<T2> values = new HashSet<T2>(_reverse.keySet());
+		Set<T2> values = new HashSet<>(_reverse.keySet());
 		return values;
 	}
 	
@@ -193,7 +193,7 @@ public class ManyToMany<T1, T2> {
 		// Add to forward map
 		Set<T2> values = _forward.get(key);
 		if (null == values) {
-			values = new HashSet<T2>();
+			values = new HashSet<>();
 			_forward.put(key, values);
 		}
 		boolean added = values.add(value);
@@ -202,7 +202,7 @@ public class ManyToMany<T1, T2> {
 		// Add to reverse map
 		Set<T1> keys = _reverse.get(value);
 		if (null == keys) {
-			keys = new HashSet<T1>();
+			keys = new HashSet<>();
 			_reverse.put(value, keys);
 		}
 		keys.add(key);
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/PackageUtil.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/PackageUtil.java
index e28407f..1a49d76 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/PackageUtil.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/PackageUtil.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -29,7 +29,7 @@ public class PackageUtil {
 			final String packageName, 
 			final BaseProcessorEnv env) {
 		
-		List<IPackageFragment> packages = new ArrayList<IPackageFragment>();
+		List<IPackageFragment> packages = new ArrayList<>();
 		try {
 			// The environment caches our package fragment roots
 			IPackageFragmentRoot[] roots = env.getAllPackageFragmentRoots();
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/ScannerUtil.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/ScannerUtil.java
index 80194b6..6b51acf 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/ScannerUtil.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/ScannerUtil.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc. 
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -134,7 +134,7 @@ public class ScannerUtil {
 	};
 	
 	private static final Set<String> SINGLE_BYTE_ENCODINGS = 
-		new HashSet<String>(SINGLE_BYTE_ENCODING_ARRAY.length);
+		new HashSet<>(SINGLE_BYTE_ENCODING_ARRAY.length);
 		
 	static {
 		for (String encoding : SINGLE_BYTE_ENCODING_ARRAY) {
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Visitors.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Visitors.java
index b9d31c0..70503ce 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Visitors.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/internal/util/Visitors.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2013 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -185,7 +185,7 @@ public class Visitors {
             for( IExtendedModifier extMod : extMods ){
                 if( extMod.isAnnotation() ){
 					if( annos == null ){
-                        annos = new ArrayList<Annotation>(2);
+                        annos = new ArrayList<>(2);
                         _result.put(node, annos);
 					}
                     annos.add((Annotation)extMod);
@@ -203,7 +203,7 @@ public class Visitors {
             for( IExtendedModifier extMod : extMods ){
                 if( extMod.isAnnotation() ){
 					if( annos == null ){
-                        annos = new ArrayList<Annotation>(2);
+                        annos = new ArrayList<>(2);
                         _result.put(node, annos);
 					}
                     annos.add((Annotation)extMod);
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptConfig.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptConfig.java
index 2f6af8c..18fe11f 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptConfig.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptConfig.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 BEA Systems, Inc. 
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -168,7 +168,7 @@ public class AptConfig {
     public static Map<String, String> getProcessorOptions(IJavaProject jproj) {
     	Map<String,String> rawOptions = getRawProcessorOptions(jproj);
     	// map is large enough to also include the programmatically generated options
-    	Map<String, String> options = new HashMap<String, String>(rawOptions.size() + 6);
+    	Map<String, String> options = new HashMap<>(rawOptions.size() + 6);
     	
     	// Resolve path metavariables like %ROOT%
     	for (Map.Entry<String, String> entry : rawOptions.entrySet()) {
@@ -187,12 +187,12 @@ public class AptConfig {
     	// Add sourcepath and classpath variables
     	try {
     		IClasspathEntry[] classpathEntries = jproj.getResolvedClasspath(true);
-    		Set<String> classpath = new LinkedHashSet<String>();
-    		Set<String> sourcepath = new LinkedHashSet<String>();
+    		Set<String> classpath = new LinkedHashSet<>();
+    		Set<String> sourcepath = new LinkedHashSet<>();
     		
     		// For projects on the classpath, loops can exist; need to make sure we 
     		// don't loop forever
-    		Set<IJavaProject> projectsProcessed = new HashSet<IJavaProject>();
+    		Set<IJavaProject> projectsProcessed = new HashSet<>();
     		projectsProcessed.add(jproj);
     		for (IClasspathEntry entry : classpathEntries) {
     			int kind = entry.getEntryKind();
@@ -478,7 +478,7 @@ public class AptConfig {
      * The value part can contain spaces, if it is quoted: -Afoo="bar baz".
      */
 	public static Map<String, String> getRawProcessorOptions(IJavaProject jproj) {
-		Map<String, String> options = new HashMap<String, String>();
+        Map<String, String> options = new HashMap<>();
 		
 	    // TODO: this code is needed only for backwards compatibility with
 	    // settings files previous to 2005.11.13.  At some point it should be
@@ -532,7 +532,7 @@ public class AptConfig {
 		Map<String, String> options;
 		String allOptions = getString(jproj, AptPreferenceConstants.APT_PROCESSOROPTIONS);
 		if (null == allOptions) {
-    		options = new HashMap<String, String>();
+    		options = new HashMap<>();
     	}
     	else {
     		ProcessorOptionsParser op = new ProcessorOptionsParser(allOptions);
@@ -562,7 +562,7 @@ public class AptConfig {
     	}
     	
      	public Map<String, String> parse() {
-        	Map<String, String> options = new HashMap<String, String>();
+        	Map<String, String> options = new HashMap<>();
         	String key;
         	while (null != (key = parseKey())) {
        			options.put(key, parseVal());
diff --git a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptPreferenceConstants.java b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptPreferenceConstants.java
index 08d6bc3..ab18c4c 100644
--- a/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptPreferenceConstants.java
+++ b/org.eclipse.jdt.apt.core/src/org/eclipse/jdt/apt/core/util/AptPreferenceConstants.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2008 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -58,7 +58,7 @@ public class AptPreferenceConstants {
 	public static Map<String,String> DEFAULT_OPTIONS_MAP;
 	
 	static {
-		Map<String,String> options = new HashMap<String,String>();
+		Map<String,String> options = new HashMap<>();
 		options.put(AptPreferenceConstants.APT_ENABLED, "false"); //$NON-NLS-1$
 		options.put(AptPreferenceConstants.APT_GENSRCDIR, DEFAULT_GENERATED_SOURCE_FOLDER_NAME);
 		options.put(AptPreferenceConstants.APT_PROCESSOROPTIONS, ""); //$NON-NLS-1$
commit 4e130c9d5bb20bb7b53d05cfcbc0214ae1f6f2b8
Author: Lars Vogel <Lars.Vogel@vogella.com>
Date:   Tue Oct 6 12:21:34 2015 +0200

    Bug 473178 - Remove redundant type arguments (1.7 or highter) from Java
    7 code in JDT core
    
    This does the change for org.eclipse.jdt.apt.ui
    
    Change-Id: I5028bbc960218cc0570e92b7b49ca3f2714aad05
    Signed-off-by: Lars Vogel <Lars.Vogel@vogella.com>

43	0	org.eclipse.jdt.apt.ui/.settings/org.eclipse.jdt.core.prefs
5	5	org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/AptConfigurationBlock.java
8	8	org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/BaseConfigurationBlock.java
7	7	org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/FactoryPathConfigurationBlock.java
2	2	org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/ProcessorOptionInputDialog.java
diff --git a/org.eclipse.jdt.apt.ui/.settings/org.eclipse.jdt.core.prefs b/org.eclipse.jdt.apt.ui/.settings/org.eclipse.jdt.core.prefs
index 1589433..57998ea 100644
--- a/org.eclipse.jdt.apt.ui/.settings/org.eclipse.jdt.core.prefs
+++ b/org.eclipse.jdt.apt.ui/.settings/org.eclipse.jdt.core.prefs
@@ -7,6 +7,12 @@ org.eclipse.jdt.core.builder.resourceCopyExclusionFilter=*.launch
 org.eclipse.jdt.core.circularClasspath=error
 org.eclipse.jdt.core.classpath.exclusionPatterns=enabled
 org.eclipse.jdt.core.classpath.multipleOutputLocations=enabled
+org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations=disabled
+org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation=ignore
+org.eclipse.jdt.core.compiler.annotation.nonnull=org.eclipse.jdt.annotation.NonNull
+org.eclipse.jdt.core.compiler.annotation.nonnullbydefault=org.eclipse.jdt.annotation.NonNullByDefault
+org.eclipse.jdt.core.compiler.annotation.nullable=org.eclipse.jdt.annotation.Nullable
+org.eclipse.jdt.core.compiler.annotation.nullanalysis=disabled
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
@@ -20,17 +26,23 @@ org.eclipse.jdt.core.compiler.maxProblemPerUnit=100
 org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
 org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
 org.eclipse.jdt.core.compiler.problem.deprecation=warning
 org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
 org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
 org.eclipse.jdt.core.compiler.problem.discouragedReference=ignore
 org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable=ignore
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=disabled
 org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
 org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
 org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
 org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
 org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.includeNullInfoFromAsserts=disabled
 org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
 org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
 org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
@@ -41,7 +53,10 @@ org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
 org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=protected
 org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
 org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDefaultCase=ignore
 org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingEnumCaseDespiteDefault=disabled
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
 org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
 org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=disabled
 org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=protected
@@ -49,19 +64,39 @@ org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
 org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=disabled
 org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=protected
 org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
 org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
 org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
 org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
 org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=warning
+org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped=warning
+org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict=error
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.nullSpecViolation=error
+org.eclipse.jdt.core.compiler.problem.nullUncheckedConversion=warning
 org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
 org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=error
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic=ignore
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic=ignore
 org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
 org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
 org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields=disabled
 org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
 org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
 org.eclipse.jdt.core.compiler.problem.unavoidableGenericTypeProblems=disabled
 org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.unclosedCloseable=warning
 org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
 org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.uninternedIdentityComparison=enabled
@@ -69,13 +104,21 @@ org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
 org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=warning
 org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedExceptionParameter=ignore
 org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
 org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=ignore
 org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
 org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
 org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
 org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=ignore
+org.eclipse.jdt.core.compiler.problem.unusedTypeParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.7
 org.eclipse.jdt.core.incompatibleJDKLevel=ignore
diff --git a/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/AptConfigurationBlock.java b/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/AptConfigurationBlock.java
index 314f3cf..cf210f3 100644
--- a/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/AptConfigurationBlock.java
+++ b/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/AptConfigurationBlock.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2013 BEA Systems, Inc. and others.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc. and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -225,7 +225,7 @@ public class AptConfigurationBlock extends BaseConfigurationBlock {
 			Messages.AptConfigurationBlock_remove
 		};
 		ProcessorOptionsAdapter optionsAdapter = new ProcessorOptionsAdapter();
-		fProcessorOptionsField = new ListDialogField<ProcessorOption>(optionsAdapter, buttons, new ProcessorOptionsLabelProvider());
+		fProcessorOptionsField = new ListDialogField<>(optionsAdapter, buttons, new ProcessorOptionsLabelProvider());
 		fProcessorOptionsField.setDialogFieldListener(optionsAdapter);
 		fProcessorOptionsField.setRemoveButtonIndex(IDX_REMOVE);
 		String[] columnHeaders= new String[] {
@@ -426,7 +426,7 @@ public class AptConfigurationBlock extends BaseConfigurationBlock {
 	 * @return true if they did.
 	 */
 	private boolean procOptionsChanged() {
-		Map<String, String> savedProcOptions = new HashMap<String, String>(fOriginalProcOptions);
+		Map<String, String> savedProcOptions = new HashMap<>(fOriginalProcOptions);
 		for (ProcessorOption o : getListElements()) {
 			final String savedVal = savedProcOptions.get(o.key);
 			if (savedVal != null && savedVal.equals(o.value)) {
@@ -559,7 +559,7 @@ public class AptConfigurationBlock extends BaseConfigurationBlock {
 	 * Save the contents of the options list.
 	 */
 	private void saveProcessorOptions(List<ProcessorOption> elements) {
-		Map<String, String> map = new LinkedHashMap<String, String>(elements.size());
+		Map<String, String> map = new LinkedHashMap<>(elements.size());
 		for (ProcessorOption o : elements) {
 			map.put(o.key, (o.value.length() > 0) ? o.value : null);
 		}
@@ -570,7 +570,7 @@ public class AptConfigurationBlock extends BaseConfigurationBlock {
 	 * Set the processor options list contents
 	 */
 	private void loadProcessorOptions(IJavaProject jproj) {
-		List<ProcessorOption> options= new ArrayList<ProcessorOption>();
+		List<ProcessorOption> options= new ArrayList<>();
 		Map<String, String> parsedOptions = AptConfig.getRawProcessorOptions(jproj);
 		for (Map.Entry<String, String> entry : parsedOptions.entrySet()) {
 			ProcessorOption o = new ProcessorOption();
diff --git a/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/BaseConfigurationBlock.java b/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/BaseConfigurationBlock.java
index 04beaec..c57c38b 100644
--- a/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/BaseConfigurationBlock.java
+++ b/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/BaseConfigurationBlock.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2011 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -235,7 +235,7 @@ public abstract class BaseConfigurationBlock {
 		if (fProject == null || hasProjectSpecificOptionsNoCache(fProject)) {
 			fDisabledProjectSettings= null;
 		} else {
-			fDisabledProjectSettings= new IdentityHashMap<Key, String>();
+			fDisabledProjectSettings= new IdentityHashMap<>();
 			for (int i= 0; i < keys.length; i++) {
 				Key curr= keys[i];
 				fDisabledProjectSettings.put(curr, curr.getStoredValue(fLookupOrder, false, fManager));
@@ -244,11 +244,11 @@ public abstract class BaseConfigurationBlock {
 		
 		settingsUpdated();
 		
-		fCheckBoxes= new ArrayList<Button>();
-		fComboBoxes= new ArrayList<Combo>();
-		fTextBoxes= new ArrayList<Text>(2);
-		fLabels= new HashMap<Scrollable, Label>();
-		fExpandedComposites= new ArrayList<ExpandableComposite>();
+		fCheckBoxes= new ArrayList<>();
+		fComboBoxes= new ArrayList<>();
+		fTextBoxes= new ArrayList<>(2);
+		fLabels= new HashMap<>();
+		fExpandedComposites= new ArrayList<>();
 	}
 	
 	protected Button addCheckBox(Composite parent, String label, Key key, String[] values, int indent) {
@@ -918,7 +918,7 @@ public abstract class BaseConfigurationBlock {
 				fDisabledProjectSettings= null;
 				updateControls();
 			} else {
-				fDisabledProjectSettings= new IdentityHashMap<Key, String>();
+				fDisabledProjectSettings= new IdentityHashMap<>();
 				for (int i= 0; i < fAllKeys.length; i++) {
 					Key curr= fAllKeys[i];
 					String oldSetting= curr.getStoredValue(fLookupOrder, false, fManager);
diff --git a/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/FactoryPathConfigurationBlock.java b/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/FactoryPathConfigurationBlock.java
index 2beb645..2410a9a 100644
--- a/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/FactoryPathConfigurationBlock.java
+++ b/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/FactoryPathConfigurationBlock.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2011 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -164,14 +164,14 @@ public class FactoryPathConfigurationBlock extends BaseConfigurationBlock {
 		// CONVERSION TO/FROM INDIVIDUAL ELEMENTS
 		public static Map<FactoryContainer, Attributes> pathMapFromList(List<FactoryPathEntry> list) {
 			Map<FactoryContainer, FactoryPath.Attributes> map =
-				new LinkedHashMap<FactoryContainer, FactoryPath.Attributes>(list.size());
+				new LinkedHashMap<>(list.size());
 			for (FactoryPathEntry fpe : list) {
 				map.put(fpe._fc, fpe._attr);
 			}
 			return map;
 		}
 		public static List<FactoryPathEntry> pathListFromMap(Map<FactoryContainer, Attributes> map) {
-			List<FactoryPathEntry> list = new ArrayList<FactoryPathEntry>(map.size());
+			List<FactoryPathEntry> list = new ArrayList<>(map.size());
 			for (Map.Entry<FactoryContainer, Attributes> entry : map.entrySet()) {
 				FactoryPathEntry fpe = new FactoryPathEntry(entry.getKey(), entry.getValue());
 				list.add(fpe);
@@ -225,7 +225,7 @@ public class FactoryPathConfigurationBlock extends BaseConfigurationBlock {
 		FactoryPathAdapter adapter= new FactoryPathAdapter();
 		FactoryPathLabelProvider labelProvider = new FactoryPathLabelProvider();
 		
-		fFactoryPathList= new CheckedListDialogField<FactoryPathEntry>(adapter, buttonLabels, labelProvider);
+		fFactoryPathList= new CheckedListDialogField<>(adapter, buttonLabels, labelProvider);
 		fFactoryPathList.setDialogFieldListener(adapter);
 		fFactoryPathList.setLabelText(Messages.FactoryPathConfigurationBlock_pluginsAndJars);
 		fFactoryPathList.setUpButtonIndex(IDX_UP);
@@ -558,7 +558,7 @@ public class FactoryPathConfigurationBlock extends BaseConfigurationBlock {
 			if (results == null) {
 				return null;
 			}
-			ArrayList<FactoryPathEntry> res= new ArrayList<FactoryPathEntry>();
+			ArrayList<FactoryPathEntry> res= new ArrayList<>();
 			for (int i= 0; i < results.length; i++) {
 				IResource resource= root.findMember(results[i]);
 				if (resource instanceof IFile) {
@@ -603,7 +603,7 @@ public class FactoryPathConfigurationBlock extends BaseConfigurationBlock {
 			if (selected == null) {
 				return null;
 			}
-			ArrayList<FactoryPathEntry> res= new ArrayList<FactoryPathEntry>();
+			ArrayList<FactoryPathEntry> res= new ArrayList<>();
 			for (int i= 0; i < selected.length; i++) {
 				FactoryContainer fc = FactoryPathUtil.newExtJarFactoryContainer(selected[i].toFile());
 				// assume defaults of enabled=true, runInAptMode=false
@@ -639,7 +639,7 @@ public class FactoryPathConfigurationBlock extends BaseConfigurationBlock {
 			if (selected == null) {
 				return null;
 			}
-			ArrayList<FactoryPathEntry> res= new ArrayList<FactoryPathEntry>();
+			ArrayList<FactoryPathEntry> res= new ArrayList<>();
 			for (int i= 0; i < selected.length; i++) {
 				FactoryContainer fc= FactoryPathUtil.newVarJarFactoryContainer(selected[i]);
 				// assume defaults of enabled=true, runInAptMode=false
diff --git a/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/ProcessorOptionInputDialog.java b/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/ProcessorOptionInputDialog.java
index 5ce4f60..68b6265 100644
--- a/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/ProcessorOptionInputDialog.java
+++ b/org.eclipse.jdt.apt.ui/src/org/eclipse/jdt/apt/ui/internal/preferences/ProcessorOptionInputDialog.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -49,7 +49,7 @@ public class ProcessorOptionInputDialog extends StatusDialog {
 	public ProcessorOptionInputDialog(Shell parent, ProcessorOption option, List<ProcessorOption> existingEntries) {
 		super(parent);
 		
-		fExistingNames= new ArrayList<String>(existingEntries.size());
+		fExistingNames= new ArrayList<>(existingEntries.size());
 		for (ProcessorOption o : existingEntries) {
 			if (!o.equals(option)) {
 				fExistingNames.add(o.key);
commit e18e2062279631b50cbdb527a42eeb74dde9b023
Author: Lars Vogel <Lars.Vogel@vogella.com>
Date:   Tue Oct 6 12:31:59 2015 +0200

    Bug 473178 - Remove redundant type arguments (1.7 or highter) from Java
    7 code in JDT core
    
    This one is for org.eclipse.jdt.compiler.apt
    
    Change-Id: Ic18a69511cb875892afd0b3e5e6f56072d13168f
    Signed-off-by: Lars Vogel <Lars.Vogel@vogella.com>

39	0	org.eclipse.jdt.compiler.apt/.settings/org.eclipse.jdt.core.prefs
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
2	2	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseAnnotationProcessorManager.java
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseMessagerImpl.java
4	4	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
3	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchAnnotationProcessorManager.java
2	2	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchFilerImpl.java
3	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchProcessingEnvImpl.java
3	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundDispatcher.java
2	2	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundEnvImpl.java
4	4	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
3	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationValueImpl.java
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
3	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/DeclaredTypeImpl.java
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
11	11	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
3	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
4	4	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
5	5	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
5	5	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/NoTypeImpl.java
3	3	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PackageElementImpl.java
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PrimitiveTypeImpl.java
5	5	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeElementImpl.java
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
2	2	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeVariableImpl.java
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
9	9	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/ManyToMany.java
1	1	org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/lookup/AptSourceLocalVariableBinding.java
diff --git a/org.eclipse.jdt.compiler.apt/.settings/org.eclipse.jdt.core.prefs b/org.eclipse.jdt.compiler.apt/.settings/org.eclipse.jdt.core.prefs
index b6c59ff..5d0b000 100644
--- a/org.eclipse.jdt.compiler.apt/.settings/org.eclipse.jdt.core.prefs
+++ b/org.eclipse.jdt.compiler.apt/.settings/org.eclipse.jdt.core.prefs
@@ -7,6 +7,12 @@ org.eclipse.jdt.core.builder.resourceCopyExclusionFilter=*.launch
 org.eclipse.jdt.core.circularClasspath=error
 org.eclipse.jdt.core.classpath.exclusionPatterns=enabled
 org.eclipse.jdt.core.classpath.multipleOutputLocations=enabled
+org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations=disabled
+org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation=ignore
+org.eclipse.jdt.core.compiler.annotation.nonnull=org.eclipse.jdt.annotation.NonNull
+org.eclipse.jdt.core.compiler.annotation.nonnullbydefault=org.eclipse.jdt.annotation.NonNullByDefault
+org.eclipse.jdt.core.compiler.annotation.nullable=org.eclipse.jdt.annotation.Nullable
+org.eclipse.jdt.core.compiler.annotation.nullanalysis=disabled
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
@@ -19,40 +25,66 @@ org.eclipse.jdt.core.compiler.maxProblemPerUnit=100
 org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
 org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
 org.eclipse.jdt.core.compiler.problem.deprecation=warning
 org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
 org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
 org.eclipse.jdt.core.compiler.problem.discouragedReference=ignore
 org.eclipse.jdt.core.compiler.problem.emptyStatement=warning
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable=ignore
 org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=disabled
 org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
 org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
 org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
 org.eclipse.jdt.core.compiler.problem.forbiddenReference=ignore
 org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.includeNullInfoFromAsserts=disabled
 org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
 org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=warning
 org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
 org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
 org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDefaultCase=ignore
 org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingEnumCaseDespiteDefault=disabled
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
 org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
 org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
 org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
 org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
 org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=warning
+org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped=warning
+org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict=error
 org.eclipse.jdt.core.compiler.problem.nullReference=ignore
+org.eclipse.jdt.core.compiler.problem.nullSpecViolation=error
+org.eclipse.jdt.core.compiler.problem.nullUncheckedConversion=warning
 org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
 org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
 org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable=ignore
 org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=error
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic=ignore
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic=ignore
 org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
 org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
 org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields=disabled
 org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
 org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.unavoidableGenericTypeProblems=enabled
 org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.unclosedCloseable=warning
 org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
 org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.uninternedIdentityComparison=enabled
@@ -60,14 +92,21 @@ org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
 org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
 org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
 org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedExceptionParameter=ignore
 org.eclipse.jdt.core.compiler.problem.unusedImport=warning
 org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
 org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=ignore
 org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
 org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
 org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
 org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedTypeParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.7
 org.eclipse.jdt.core.incompatibleJDKLevel=ignore
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
index 1d19404..66212fc 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/AnnotationDiscoveryVisitor.java
@@ -55,7 +55,7 @@ public class AnnotationDiscoveryVisitor extends ASTVisitor {
 	public AnnotationDiscoveryVisitor(BaseProcessingEnvImpl env) {
 		_env = env;
 		_factory = env.getFactory();
-		_annoToElement = new ManyToMany<TypeElement, Element>();
+		_annoToElement = new ManyToMany<>();
 	}
 
 	@Override
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseAnnotationProcessorManager.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseAnnotationProcessorManager.java
index 38e5bdf..fb4001a 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseAnnotationProcessorManager.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseAnnotationProcessorManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2011 BEA Systems, Inc. 
+ * Copyright (c) 2007, 2015 BEA Systems, Inc. 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -49,7 +49,7 @@ public abstract class BaseAnnotationProcessorManager extends AbstractAnnotationP
 	 * The list of processors that have been loaded so far.  A processor on this
 	 * list has been initialized, but may not yet have been called to process().
 	 */
-	protected List<ProcessorInfo> _processors = new ArrayList<ProcessorInfo>();
+	protected List<ProcessorInfo> _processors = new ArrayList<>();
 	
 	// Tracing
 	protected boolean _printProcessorInfo = false;
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseMessagerImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseMessagerImpl.java
index 5c930e3..c9613d8 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseMessagerImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseMessagerImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2012 BEA Systems, Inc. and others 
+ * Copyright (c) 2007, 2015 BEA Systems, Inc. and others 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
index e4e1fdd..a7b2a2d 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BaseProcessingEnvImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2011 BEA Systems, Inc. 
+ * Copyright (c) 2007, 2015 BEA Systems, Inc. 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -53,9 +53,9 @@ public abstract class BaseProcessingEnvImpl implements ProcessingEnvironment {
 	private Factory _factory;
 
 	public BaseProcessingEnvImpl() {
-		_addedUnits = new ArrayList<ICompilationUnit>();
-		_addedClassFiles = new ArrayList<ReferenceBinding>();
-		_deletedUnits = new ArrayList<ICompilationUnit>();
+		_addedUnits = new ArrayList<>();
+		_addedClassFiles = new ArrayList<>();
+		_deletedUnits = new ArrayList<>();
 		_elementUtils = new ElementsImpl(this);
 		_typeUtils = new TypesImpl(this);
 		_factory = new Factory(this);
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchAnnotationProcessorManager.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchAnnotationProcessorManager.java
index 941023d..67cc77c 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchAnnotationProcessorManager.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchAnnotationProcessorManager.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2011 IBM Corporation and others.
+ * Copyright (c) 2005, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -90,7 +90,7 @@ public class BatchAnnotationProcessorManager extends BaseAnnotationProcessorMana
 				_printRounds = true;
 			}
 			else if ("-processor".equals(option)) { //$NON-NLS-1$
-				commandLineProcessors = new ArrayList<String>();
+				commandLineProcessors = new ArrayList<>();
 				String procs = commandLineArguments[++i];
 				for (String proc : procs.split(",")) { //$NON-NLS-1$
 					commandLineProcessors.add(proc);
@@ -221,7 +221,7 @@ public class BatchAnnotationProcessorManager extends BaseAnnotationProcessorMana
 		}
 		// Cast all the processors here, rather than failing later.
 		// But don't call init() until the processor is actually needed.
-		_setProcessors = new ArrayList<Processor>(processors.length);
+		_setProcessors = new ArrayList<>(processors.length);
 		for (Object o : processors) {
 			Processor p = (Processor)o;
 			_setProcessors.add(p);
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchFilerImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchFilerImpl.java
index 21e0c64..c7a784e 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchFilerImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchFilerImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2011 BEA Systems, Inc. 
+ * Copyright (c) 2006, 2015 BEA Systems, Inc. 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -47,7 +47,7 @@ public class BatchFilerImpl implements Filer {
 		_dispatchManager = dispatchManager;
 		_fileManager = env._fileManager;
 		_env = env;
-		_createdFiles = new HashSet<URI>();
+		_createdFiles = new HashSet<>();
 	}
 
 	public void addNewUnit(ICompilationUnit unit) {
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchProcessingEnvImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchProcessingEnvImpl.java
index 989f82b..706e65f 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchProcessingEnvImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/BatchProcessingEnvImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2011 BEA Systems, Inc.
+ * Copyright (c) 2006, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -80,7 +80,7 @@ public class BatchProcessingEnvImpl extends BaseProcessingEnvImpl {
 			String encoding = (String) batchCompiler.options.get(CompilerOptions.OPTION_Encoding);
 			Charset charset = encoding != null ? Charset.forName(encoding) : null;
 			JavaFileManager manager = new EclipseFileManager(batchCompiler.compilerLocale, charset);
-			ArrayList<String> options = new ArrayList<String>();
+			ArrayList<String> options = new ArrayList<>();
 			for (String argument : commandLineArguments) {
 				options.add(argument);
 			}
@@ -107,7 +107,7 @@ public class BatchProcessingEnvImpl extends BaseProcessingEnvImpl {
 	 * value "bar".
 	 */
 	private Map<String, String> parseProcessorOptions(String[] args) {
-		Map<String, String> options = new LinkedHashMap<String, String>();
+		Map<String, String> options = new LinkedHashMap<>();
 		for (String arg : args) {
 			if (!arg.startsWith("-A")) { //$NON-NLS-1$
 				continue;
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundDispatcher.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundDispatcher.java
index 86e0687..cb8197e 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundDispatcher.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundDispatcher.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2007 BEA Systems, Inc. 
+ * Copyright (c) 2006, 2015 BEA Systems, Inc. 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -58,7 +58,7 @@ public class RoundDispatcher {
 		_provider = provider;
 		_processors = provider.getDiscoveredProcessors();
 		_roundEnv = env;
-		_unclaimedAnnotations = new HashSet<TypeElement>(rootAnnotations);
+		_unclaimedAnnotations = new HashSet<>(rootAnnotations);
 		_traceProcessorInfo = traceProcessorInfo;
 		_traceRounds = traceRounds;
 	}
@@ -132,7 +132,7 @@ public class RoundDispatcher {
 	private void handleProcessor(ProcessorInfo pi)
 	{
 		try {
-			Set<TypeElement> annotationsToProcess = new HashSet<TypeElement>();
+			Set<TypeElement> annotationsToProcess = new HashSet<>();
 			boolean shouldCall = pi.computeSupportedAnnotations(
 					_unclaimedAnnotations, annotationsToProcess);
 			if (shouldCall) {
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundEnvImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundEnvImpl.java
index b2379e9..169a6ca 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundEnvImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/dispatch/RoundEnvImpl.java
@@ -132,7 +132,7 @@ public class RoundEnvImpl implements RoundEnvironment
 		}
 		Binding annoBinding = ((TypeElementImpl)a)._binding;
 		if (0 != (annoBinding.getAnnotationTagBits() & TagBits.AnnotationInherited)) {
-			Set<Element> annotatedElements = new HashSet<Element>(_annoToUnit.getValues(a));
+			Set<Element> annotatedElements = new HashSet<>(_annoToUnit.getValues(a));
 			// For all other root elements that are TypeElements, and for their recursively enclosed
 			// types, add each element if it has a superclass are annotated with 'a'
 			ReferenceBinding annoTypeBinding = (ReferenceBinding) annoBinding;
@@ -208,7 +208,7 @@ public class RoundEnvImpl implements RoundEnvironment
 			return Collections.emptySet();
 		}
 		if (_rootElements == null) {
-			Set<Element> elements = new HashSet<Element>(_units.length);
+			Set<Element> elements = new HashSet<>(_units.length);
 			for (CompilationUnitDeclaration unit : _units) {
 				if (null == unit.scope || null == unit.scope.topLevelTypes)
 					continue;
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
index 07b72e6..044386a 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationMirrorImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 IBM Corporation and others.
+ * Copyright (c) 2005, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -115,7 +115,7 @@ public class AnnotationMirrorImpl implements AnnotationMirror, InvocationHandler
 		}
 		ElementValuePair[] pairs = _binding.getElementValuePairs();
 		Map<ExecutableElement, AnnotationValue> valueMap =
-			new LinkedHashMap<ExecutableElement, AnnotationValue>(pairs.length);
+			new LinkedHashMap<>(pairs.length);
 		for (ElementValuePair pair : pairs) {
 			MethodBinding method = pair.getMethodBinding();
 			if (method == null) {
@@ -141,7 +141,7 @@ public class AnnotationMirrorImpl implements AnnotationMirror, InvocationHandler
 		ElementValuePair[] pairs = _binding.getElementValuePairs();
 		ReferenceBinding annoType = _binding.getAnnotationType();
 		Map<ExecutableElement, AnnotationValue> valueMap =
-			new LinkedHashMap<ExecutableElement, AnnotationValue>();
+			new LinkedHashMap<>();
 		for (MethodBinding method : annoType.methods()) {
 			// if binding is in ElementValuePair list, then get value from there
 			boolean foundExplicitValue = false;
@@ -323,7 +323,7 @@ public class AnnotationMirrorImpl implements AnnotationMirror, InvocationHandler
 				if (actualType.isArrayType() && actualValue instanceof Object[] &&
 						((ArrayBinding)actualType).leafComponentType.erasure().id == TypeIds.T_JavaLangClass) {
 					Object[] bindings = (Object[])actualValue;
-					List<TypeMirror> mirrors = new ArrayList<TypeMirror>(bindings.length);
+					List<TypeMirror> mirrors = new ArrayList<>(bindings.length);
 					for (int i = 0; i < bindings.length; ++i) {
 						if (bindings[i] instanceof TypeBinding) {
 							mirrors.add(_env.getFactory().newTypeMirror((TypeBinding)bindings[i]));
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationValueImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationValueImpl.java
index 5a89a28..4a2831a 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationValueImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/AnnotationValueImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 IBM Corporation and others.
+ * Copyright (c) 2005, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -96,12 +96,12 @@ public class AnnotationValueImpl implements AnnotationValue, TypeIds {
 			TypeBinding valueType = ((ArrayBinding)type).elementsType();
 			if (value instanceof Object[]) {
 				Object[] values = (Object[])value;
-				convertedValues = new ArrayList<AnnotationValue>(values.length);
+				convertedValues = new ArrayList<>(values.length);
 				for (Object oneValue : values) {
 					convertedValues.add(new AnnotationValueImpl(_env, oneValue, valueType));
 				}
 			} else {
-				convertedValues = new ArrayList<AnnotationValue>(1);
+				convertedValues = new ArrayList<>(1);
 				convertedValues.add(new AnnotationValueImpl(_env, value, valueType));
 			}
 			_value = Collections.unmodifiableList(convertedValues);
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
index 8e7ab86..1a8041d 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ArrayTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2013 BEA Systems, Inc. and others.
+ * Copyright (c) 2007, 2014 BEA Systems, Inc. and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/DeclaredTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/DeclaredTypeImpl.java
index 95c6103..00e172b 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/DeclaredTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/DeclaredTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2011 BEA Systems, Inc. 
+ * Copyright (c) 2006, 2015 BEA Systems, Inc. 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -83,7 +83,7 @@ public class DeclaredTypeImpl extends TypeMirrorImpl implements DeclaredType {
 			TypeBinding[] arguments = ptb.arguments;
 			int length = arguments == null ? 0 : arguments.length;
 			if (length == 0) return Collections.emptyList();
-			List<TypeMirror> args = new ArrayList<TypeMirror>(length);
+			List<TypeMirror> args = new ArrayList<>(length);
 			for (TypeBinding arg : arguments) {
 				args.add(_env.getFactory().newTypeMirror(arg));
 			}
@@ -91,7 +91,7 @@ public class DeclaredTypeImpl extends TypeMirrorImpl implements DeclaredType {
 		}
 		if (binding.isGenericType()) {
 			TypeVariableBinding[] typeVariables = binding.typeVariables();
-			List<TypeMirror> args = new ArrayList<TypeMirror>(typeVariables.length);
+			List<TypeMirror> args = new ArrayList<>(typeVariables.length);
 			for (TypeBinding arg : typeVariables) {
 				args.add(_env.getFactory().newTypeMirror(arg));
 			}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
index 5e1bb69..c82b8ad 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2013 IBM Corporation and others.
+ * Copyright (c) 2005, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
index 5700a3f..6ac10f8 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ElementsImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2013 BEA Systems, Inc. and others
+ * Copyright (c) 2006, 2015 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -86,9 +86,9 @@ public class ElementsImpl implements Elements {
 	public List<? extends AnnotationMirror> getAllAnnotationMirrors(Element e) {
 		// if e is a class, walk up its superclass hierarchy looking for @Inherited annotations not already in the list
 		if (e.getKind() == ElementKind.CLASS && e instanceof TypeElementImpl) {
-			List<AnnotationBinding> annotations = new ArrayList<AnnotationBinding>();
+			List<AnnotationBinding> annotations = new ArrayList<>();
 			// A class can only have one annotation of a particular annotation type.
-			Set<ReferenceBinding> annotationTypes = new HashSet<ReferenceBinding>();
+			Set<ReferenceBinding> annotationTypes = new HashSet<>();
 			ReferenceBinding binding = (ReferenceBinding)((TypeElementImpl)e)._binding;
 			boolean checkIfInherited = false;
 			while (null != binding) {
@@ -108,7 +108,7 @@ public class ElementsImpl implements Elements {
 				binding = binding.superclass();
 				checkIfInherited = true;
 			}
-			List<AnnotationMirror> list = new ArrayList<AnnotationMirror>(annotations.size());
+			List<AnnotationMirror> list = new ArrayList<>(annotations.size());
 			for (AnnotationBinding annotation : annotations) {
 				list.add(_env.getFactory().newAnnotationMirror(annotation));
 			}
@@ -144,16 +144,16 @@ public class ElementsImpl implements Elements {
 		}
 		ReferenceBinding binding = (ReferenceBinding)((TypeElementImpl)type)._binding;
 		// Map of element simple name to binding
-		Map<String, ReferenceBinding> types = new HashMap<String, ReferenceBinding>();
+		Map<String, ReferenceBinding> types = new HashMap<>();
 		// Javac implementation does not take field name collisions into account
-		List<FieldBinding> fields = new ArrayList<FieldBinding>();
+		List<FieldBinding> fields = new ArrayList<>();
 		// For methods, need to compare parameters, not just names
-		Map<String, Set<MethodBinding>> methods = new HashMap<String, Set<MethodBinding>>();
-		Set<ReferenceBinding> superinterfaces = new LinkedHashSet<ReferenceBinding>();
+		Map<String, Set<MethodBinding>> methods = new HashMap<>();
+		Set<ReferenceBinding> superinterfaces = new LinkedHashSet<>();
 		boolean ignoreVisibility = true;
 		while (null != binding) {
 			addMembers(binding, ignoreVisibility, types, fields, methods);
-			Set<ReferenceBinding> newfound = new LinkedHashSet<ReferenceBinding>();
+			Set<ReferenceBinding> newfound = new LinkedHashSet<>();
 			collectSuperInterfaces(binding, superinterfaces, newfound);
 			for (ReferenceBinding superinterface : newfound) {
 				addMembers(superinterface, false, types, fields, methods);
@@ -162,7 +162,7 @@ public class ElementsImpl implements Elements {
 			binding = binding.superclass();
 			ignoreVisibility = false;
 		}
-		List<Element> allMembers = new ArrayList<Element>();
+		List<Element> allMembers = new ArrayList<>();
 		for (ReferenceBinding nestedType : types.values()) {
 			allMembers.add(_env.getFactory().newElement(nestedType));
 		}
@@ -229,7 +229,7 @@ public class ElementsImpl implements Elements {
 				if (null == sameNamedMethods) {
 					// New method name.  Create a set for it and add it to the list.
 					// We don't expect many methods with same name, so only 4 slots:
-					sameNamedMethods = new HashSet<MethodBinding>(4);
+					sameNamedMethods = new HashSet<>(4);
 					methods.put(methodName, sameNamedMethods);
 					sameNamedMethods.add(method);
 				}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
index 9e606cd..63538fe 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeElement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2013 IBM Corporation and others.
+ * Copyright (c) 2007, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
index 2c893fe..837e9fc 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ErrorTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2013 IBM Corporation and others.
+ * Copyright (c) 2007, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -62,7 +62,7 @@ public class ErrorTypeImpl extends DeclaredTypeImpl implements ErrorType {
 			TypeBinding[] arguments = ptb.arguments;
 			int length = arguments == null ? 0 : arguments.length;
 			if (length == 0) return Collections.emptyList();
-			List<TypeMirror> args = new ArrayList<TypeMirror>(length);
+			List<TypeMirror> args = new ArrayList<>(length);
 			for (TypeBinding arg : arguments) {
 				args.add(_env.getFactory().newTypeMirror(arg));
 			}
@@ -70,7 +70,7 @@ public class ErrorTypeImpl extends DeclaredTypeImpl implements ErrorType {
 		}
 		if (binding.isGenericType()) {
 			TypeVariableBinding[] typeVariables = binding.typeVariables();
-			List<TypeMirror> args = new ArrayList<TypeMirror>(typeVariables.length);
+			List<TypeMirror> args = new ArrayList<>(typeVariables.length);
 			for (TypeBinding arg : typeVariables) {
 				args.add(_env.getFactory().newTypeMirror(arg));
 			}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
index bbedb9b..9f40a57 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableElementImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 IBM Corporation and others.
+ * Copyright (c) 2005, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -135,7 +135,7 @@ public class ExecutableElementImpl extends ElementImpl implements
 		int length = binding.parameters == null ? 0 : binding.parameters.length;
 		if (0 != length) {
 			AbstractMethodDeclaration methodDeclaration = binding.sourceMethod();
-			List<VariableElement> params = new ArrayList<VariableElement>(length);
+			List<VariableElement> params = new ArrayList<>(length);
 			if (methodDeclaration != null) {
 				for (Argument argument : methodDeclaration.arguments) {
 					VariableElement param = new VariableElementImpl(_env, argument.binding);
@@ -197,7 +197,7 @@ public class ExecutableElementImpl extends ElementImpl implements
 		if (binding.thrownExceptions.length == 0) {
 			return Collections.emptyList();
 		}
-		List<TypeMirror> list = new ArrayList<TypeMirror>(binding.thrownExceptions.length);
+		List<TypeMirror> list = new ArrayList<>(binding.thrownExceptions.length);
 		for (ReferenceBinding exception : binding.thrownExceptions) {
 			list.add(_env.getFactory().newTypeMirror(exception));
 		}
@@ -211,7 +211,7 @@ public class ExecutableElementImpl extends ElementImpl implements
 		if (variables.length == 0) {
 			return Collections.emptyList();
 		}
-		List<TypeParameterElement> params = new ArrayList<TypeParameterElement>(variables.length); 
+		List<TypeParameterElement> params = new ArrayList<>(variables.length); 
 		for (TypeVariableBinding variable : variables) {
 			params.add(_env.getFactory().newTypeParameterElement(variable, this));
 		}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
index aaf4581..e6cfa6d 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/ExecutableTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2013 IBM Corporation and others.
+ * Copyright (c) 2006, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -53,14 +53,14 @@ public class ExecutableTypeImpl extends TypeMirrorImpl implements ExecutableType
 			if (length == 2) {
 				return Collections.emptyList();
 			}
-			ArrayList<TypeMirror> list = new ArrayList<TypeMirror>();
+			ArrayList<TypeMirror> list = new ArrayList<>();
 			for (int i = 2; i < length; i++) {
 				list.add(_env.getFactory().newTypeMirror(parameters[i]));
 			}
 			return Collections.unmodifiableList(list);
 		}
 		if (length != 0) {
-			ArrayList<TypeMirror> list = new ArrayList<TypeMirror>();
+			ArrayList<TypeMirror> list = new ArrayList<>();
 			for (TypeBinding typeBinding : parameters) {
 				list.add(_env.getFactory().newTypeMirror(typeBinding));
 			}
@@ -82,7 +82,7 @@ public class ExecutableTypeImpl extends TypeMirrorImpl implements ExecutableType
 	 */
 	@Override
 	public List<? extends TypeMirror> getThrownTypes() {
-		ArrayList<TypeMirror> list = new ArrayList<TypeMirror>();
+		ArrayList<TypeMirror> list = new ArrayList<>();
 		ReferenceBinding[] thrownExceptions = ((MethodBinding) this._binding).thrownExceptions;
 		if (thrownExceptions.length != 0) {
 			for (ReferenceBinding referenceBinding : thrownExceptions) {
@@ -97,7 +97,7 @@ public class ExecutableTypeImpl extends TypeMirrorImpl implements ExecutableType
 	 */
 	@Override
 	public List<? extends TypeVariable> getTypeVariables() {
-		ArrayList<TypeVariable> list = new ArrayList<TypeVariable>();
+		ArrayList<TypeVariable> list = new ArrayList<>();
 		TypeVariableBinding[] typeVariables = ((MethodBinding) this._binding).typeVariables();
 		if (typeVariables.length != 0) {
 			for (TypeVariableBinding typeVariableBinding : typeVariables) {
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
index b6c5019..94f593a 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/Factory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2014 BEA Systems, Inc. and others
+ * Copyright (c) 2007, 2015 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -89,7 +89,7 @@ public class Factory {
 		if (null == annotations || 0 == annotations.length) {
 			return Collections.emptyList();
 		}
-		List<AnnotationMirror> list = new ArrayList<AnnotationMirror>(annotations.length);
+		List<AnnotationMirror> list = new ArrayList<>(annotations.length);
 		for (AnnotationBinding annotation : annotations) {
 			if (annotation == null) continue;
 			list.add(newAnnotationMirror(annotation));
@@ -117,7 +117,7 @@ public class Factory {
 		String annoTypeName = annotationClass.getName();
 		if(annoTypeName == null ) return null;
 
-		List<A> list = new ArrayList<A>(annoInstances.length);
+		List<A> list = new ArrayList<>(annoInstances.length);
 		for(AnnotationBinding annoInstance : annoInstances) {
 			if (annoInstance == null)
 				continue;
@@ -805,7 +805,7 @@ public class Factory {
 						System.arraycopy(repackagedBindings, 0, repackagedBindings = new AnnotationBinding[length], 0, length);
 					repackagedBindings[j] = null; // so it is not double packed.
 					if (containees == null) {
-						containees = new ArrayList<AnnotationBinding>();
+						containees = new ArrayList<>();
 						containees.add(annotation);
 					}
 					containees.add(otherAnnotation);
@@ -843,7 +843,7 @@ public class Factory {
 		if (length == 0)
 			return annotations;
 		
-		List<AnnotationBinding> unpackedAnnotations = new ArrayList<AnnotationBinding>();
+		List<AnnotationBinding> unpackedAnnotations = new ArrayList<>();
 		for (int i = 0; i < length; i++) {
 			AnnotationBinding annotation = annotations[i];
 			if (annotation == null) continue;
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/NoTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/NoTypeImpl.java
index 6672ed3..2efe713 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/NoTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/NoTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2013 BEA Systems, Inc. and others
+ * Copyright (c) 2007, 2015 BEA Systems, Inc. and others
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PackageElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PackageElementImpl.java
index 7e0e4c8..f1bd620 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PackageElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PackageElementImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007 BEA Systems, Inc. 
+ * Copyright (c) 2007, 2015 BEA Systems, Inc. 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -70,7 +70,7 @@ public class PackageElementImpl extends ElementImpl implements PackageElement {
 		if (nameEnvironment instanceof FileSystem) {
 			typeNames = ((FileSystem) nameEnvironment).findTypeNames(binding.compoundName);
 		}
-		HashSet<Element> set = new HashSet<Element>(); 
+		HashSet<Element> set = new HashSet<>(); 
 		if (typeNames != null) {
 			for (char[][] typeName : typeNames) {
 				ReferenceBinding type = environment.getType(typeName);
@@ -79,7 +79,7 @@ public class PackageElementImpl extends ElementImpl implements PackageElement {
 				}
 			}
 		}
-		ArrayList<Element> list = new ArrayList<Element>(set.size());
+		ArrayList<Element> list = new ArrayList<>(set.size());
 		list.addAll(set);
 		return Collections.unmodifiableList(list);
 	}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PrimitiveTypeImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PrimitiveTypeImpl.java
index 7ff3f2e..9679147 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PrimitiveTypeImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/PrimitiveTypeImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2013 BEA Systems, Inc. and others.
+ * Copyright (c) 2007, 2014 BEA Systems, Inc. and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeElementImpl.java
index 328e938..5b9961b 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeElementImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2011 IBM Corporation and others.
+ * Copyright (c) 2005, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -55,7 +55,7 @@ public class TypeElementImpl extends ElementImpl implements TypeElement {
 	 *
 	 */
 	private static final class SourceLocationComparator implements Comparator<Element> {
-		private final IdentityHashMap<ElementImpl, Integer> sourceStartCache = new IdentityHashMap<ElementImpl, Integer>();
+		private final IdentityHashMap<ElementImpl, Integer> sourceStartCache = new IdentityHashMap<>();
 
 		@Override
 		public int compare(Element o1, Element o2) {
@@ -146,7 +146,7 @@ public class TypeElementImpl extends ElementImpl implements TypeElement {
 	@Override
 	public List<? extends Element> getEnclosedElements() {
 		ReferenceBinding binding = (ReferenceBinding)_binding;
-		List<Element> enclosed = new ArrayList<Element>(binding.fieldCount() + binding.methods().length + binding.memberTypes().length);
+		List<Element> enclosed = new ArrayList<>(binding.fieldCount() + binding.methods().length + binding.memberTypes().length);
 		for (MethodBinding method : binding.methods()) {
 			ExecutableElement executable = new ExecutableElementImpl(_env, method);
 			enclosed.add(executable);
@@ -195,7 +195,7 @@ public class TypeElementImpl extends ElementImpl implements TypeElement {
 		if (null == binding.superInterfaces() || binding.superInterfaces().length == 0) {
 			return Collections.emptyList();
 		}
-		List<TypeMirror> interfaces = new ArrayList<TypeMirror>(binding.superInterfaces().length);
+		List<TypeMirror> interfaces = new ArrayList<>(binding.superInterfaces().length);
 		for (ReferenceBinding interfaceBinding : binding.superInterfaces()) {
 			TypeMirror interfaceType = _env.getFactory().newTypeMirror(interfaceBinding);
 			if (interfaceType.getKind() == TypeKind.ERROR) {
@@ -309,7 +309,7 @@ public class TypeElementImpl extends ElementImpl implements TypeElement {
 		if (variables.length == 0) {
 			return Collections.emptyList();
 		}
-		List<TypeParameterElement> params = new ArrayList<TypeParameterElement>(variables.length); 
+		List<TypeParameterElement> params = new ArrayList<>(variables.length); 
 		for (TypeVariableBinding variable : variables) {
 			params.add(_env.getFactory().newTypeParameterElement(variable, this));
 		}
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
index 7442957..c5de505 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeMirrorImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2013 BEA Systems, Inc. and others.
+ * Copyright (c) 2007, 2014 BEA Systems, Inc. and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
index 34f0de5..8028649 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeParameterElementImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2007, 2013 BEA Systems, Inc.
+ * Copyright (c) 2007, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -92,7 +92,7 @@ public class TypeParameterElementImpl extends ElementImpl implements TypeParamet
 			superinterfacesLength = superinterfaces.length;
 			boundsLength += superinterfacesLength;
 		}
-		List<TypeMirror> typeBounds = new ArrayList<TypeMirror>(boundsLength);
+		List<TypeMirror> typeBounds = new ArrayList<>(boundsLength);
 		if (boundsLength != 0) {
 			if (firstClassOrArrayBound != null) {
 				TypeMirror typeBinding = _env.getFactory().newTypeMirror(firstClassOrArrayBound);
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeVariableImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeVariableImpl.java
index 2fd4f4f..444376c 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeVariableImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypeVariableImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2011 IBM Corporation and others.
+ * Copyright (c) 2006, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
index 820a899..91006a5 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/model/TypesImpl.java
@@ -176,7 +176,7 @@ public class TypesImpl implements Types {
         Binding binding = typeMirrorImpl._binding;
         if (binding instanceof ReferenceBinding) {
             ReferenceBinding referenceBinding = (ReferenceBinding) binding;
-            ArrayList<TypeMirror> list = new ArrayList<TypeMirror>();
+            ArrayList<TypeMirror> list = new ArrayList<>();
             ReferenceBinding superclass = referenceBinding.superclass();
             if (superclass != null) {
                 list.add(this._env.getFactory().newTypeMirror(superclass));
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/ManyToMany.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/ManyToMany.java
index 62e1a12..6517830c 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/ManyToMany.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/apt/util/ManyToMany.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2007 BEA Systems, Inc.
+ * Copyright (c) 2006, 2015 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -36,8 +36,8 @@ import java.util.Set;
  */
 public class ManyToMany<T1, T2> {
 	
-	private final Map<T1, Set<T2>> _forward = new HashMap<T1, Set<T2>>();
-	private final Map<T2, Set<T1>> _reverse = new HashMap<T2, Set<T1>>();
+	private final Map<T1, Set<T2>> _forward = new HashMap<>();
+	private final Map<T2, Set<T1>> _reverse = new HashMap<>();
 	private boolean _dirty = false;
 	
 	/**
@@ -104,7 +104,7 @@ public class ManyToMany<T1, T2> {
 		if (null == keys) {
 			return Collections.emptySet();
 		}
-		return new HashSet<T1>(keys);
+		return new HashSet<>(keys);
 	}
 	
 	/**
@@ -118,7 +118,7 @@ public class ManyToMany<T1, T2> {
 		if (null == values) {
 			return Collections.emptySet();
 		}
-		return new HashSet<T2>(values);
+		return new HashSet<>(values);
 	}
 
 	/**
@@ -128,7 +128,7 @@ public class ManyToMany<T1, T2> {
 	 * @see #getValueSet()
 	 */
 	public synchronized Set<T1> getKeySet() {
-		Set<T1> keys = new HashSet<T1>(_forward.keySet());
+		Set<T1> keys = new HashSet<>(_forward.keySet());
 		return keys;
 	}
 	
@@ -139,7 +139,7 @@ public class ManyToMany<T1, T2> {
 	 * @see #getKeySet()
 	 */
 	public synchronized Set<T2> getValueSet() {
-		Set<T2> values = new HashSet<T2>(_reverse.keySet());
+		Set<T2> values = new HashSet<>(_reverse.keySet());
 		return values;
 	}
 	
@@ -192,7 +192,7 @@ public class ManyToMany<T1, T2> {
 		// Add to forward map
 		Set<T2> values = _forward.get(key);
 		if (null == values) {
-			values = new HashSet<T2>();
+			values = new HashSet<>();
 			_forward.put(key, values);
 		}
 		boolean added = values.add(value);
@@ -201,7 +201,7 @@ public class ManyToMany<T1, T2> {
 		// Add to reverse map
 		Set<T1> keys = _reverse.get(value);
 		if (null == keys) {
-			keys = new HashSet<T1>();
+			keys = new HashSet<>();
 			_reverse.put(value, keys);
 		}
 		keys.add(key);
diff --git a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/lookup/AptSourceLocalVariableBinding.java b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/lookup/AptSourceLocalVariableBinding.java
index 81441c8..515d5b4 100644
--- a/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/lookup/AptSourceLocalVariableBinding.java
+++ b/org.eclipse.jdt.compiler.apt/src/org/eclipse/jdt/internal/compiler/lookup/AptSourceLocalVariableBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2009 IBM Corporation and others.
+ * Copyright (c) 2009, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
