commit 4ddddb5424dafb4b8650d4349863e03fece6ac06
Author: Jesper Steen MÃ¸ller <jesper@selskabet.org>
Date:   Thu Aug 8 02:34:02 2013 +0200

    Bug 406973: [1.8] Parse MethodParameters attribute from classfiles

350	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodParametersAttributeTest.java
3	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
-	-	org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames$1.class
-	-	org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames$1Local.class
-	-	org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames.class
36	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AttributeNamesConstants.java
8	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IAttributeNamesConstants.java
52	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IMethodParametersAttribute.java
14	2	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IModifierConstants.java
63	18	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
3	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
4	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MethodInfo.java
87	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MethodParametersAttribute.java
3	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodParametersAttributeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodParametersAttributeTest.java
new file mode 100644
index 0000000..85a6efc
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/MethodParametersAttributeTest.java
@@ -0,0 +1,350 @@
+/*******************************************************************************
+ * Copyright (c) 2013 Jesper Steen Moeller and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     Jesper Steen Moeller - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+import java.io.File;
+
+import junit.framework.Test;
+
+import org.eclipse.jdt.core.ToolFactory;
+import org.eclipse.jdt.core.tests.util.Util;
+import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
+import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
+
+public class MethodParametersAttributeTest extends AbstractRegressionTest {
+	public MethodParametersAttributeTest(String name) {
+		super(name);
+	}
+
+	public static Class testClass() {
+		return MethodParametersAttributeTest.class;
+	}
+
+	// Use this static initializer to specify subset for tests
+	// All specified tests which does not belong to the class are skipped...
+	static {
+//		TESTS_PREFIX = "testBug95521";
+//		TESTS_NAMES = new String[] { "testBug359495" };
+//		TESTS_NUMBERS = new int[] { 53 };
+//		TESTS_RANGE = new int[] { 23 -1,};
+	}
+	public static Test suite() {
+		return buildMinimalComplianceTestSuite(testClass(), F_1_8);
+	}
+	
+	String originalSource =
+		"import java.util.concurrent.Callable;\n" + 
+		"\n" + 
+		"public class ParameterNames {\n" + 
+		"	\n" + 
+		"	public void someMethod(int simple, final double complex) {\n" + 
+		"	}\n" + 
+		"	\n" + 
+		"	public Callable<String> makeInnerWithCapture(final String finalMessage, String mutableMessage) {\n" + 
+		"		return new Callable<String>()  {\n" + 
+		"			public String call() throws Exception {\n" + 
+		"				return finalMessage;\n" + 
+		"			}\n" + 
+		"		};\n" + 
+		"	}\n" + 
+		"\n" + 
+		"	public int localMath(final String finalMessage, String mutableMessage) {\n" + 
+		"		int capturedB = 42;\n" + 
+		"		\n" + 
+		"		class Local {\n" + 
+		"			int fieldA;\n" + 
+		"			Local(int a) {\n" + 
+		"				this.fieldA = a;\n" + 
+		"			}\n" + 
+		"			int calculate(final int parameterC) {\n" + 
+		"				return  this.fieldA + capturedB + parameterC;\n" + 
+		"			}\n" + 
+		"		}\n" + 
+		"		\n" + 
+		"		return new Local(2).calculate(3);\n" + 
+		"	}\n" + 
+		"\n" + 
+		"}\n" + 
+		"";
+
+	public void test001() throws Exception {
+
+			ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
+			String path = this.getCompilerTestsPluginDirectoryPath() + File.separator + "workspace" + File.separator + "ParameterNames.class";
+			byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(new File(path));
+			String actualOutput =
+				disassembler.disassemble(
+					classFileBytes,
+					"\n",
+					ClassFileBytesDisassembler.DETAILED);
+
+			String expectedOutput =
+					"// Compiled from ParameterNames.java (version 1.8 : 52.0, super bit)\n" + 
+					"public class ParameterNames {\n" + 
+					"  \n" + 
+					"  // Method descriptor #12 ()V\n" + 
+					"  // Stack: 1, Locals: 1\n" + 
+					"  public ParameterNames();\n" + 
+					"    0  aload_0 [this]\n" + 
+					"    1  invokespecial java.lang.Object() [1]\n" + 
+					"    4  return\n" + 
+					"      Line numbers:\n" + 
+					"        [pc: 0, line: 3]\n" + 
+					"  \n" + 
+					"  // Method descriptor #16 (ID)V\n" + 
+					"  // Stack: 0, Locals: 4\n" + 
+					"  public void someMethod(int simple, double complex);\n" + 
+					"    0  return\n" + 
+					"      Line numbers:\n" + 
+					"        [pc: 0, line: 6]\n" + 
+					"      Method Parameters:\n" + 
+					"        simple\n" + 
+					"        final complex\n" + 
+					"  \n" + 
+					"  // Method descriptor #21 (Ljava/lang/String;Ljava/lang/String;)Ljava/util/concurrent/Callable;\n" + 
+					"  // Signature: (Ljava/lang/String;Ljava/lang/String;)Ljava/util/concurrent/Callable<Ljava/lang/String;>;\n" + 
+					"  // Stack: 4, Locals: 3\n" + 
+					"  public java.util.concurrent.Callable makeInnerWithCapture(java.lang.String finalMessage, java.lang.String mutableMessage);\n" + 
+					"     0  new ParameterNames$1 [2]\n" + 
+					"     3  dup\n" + 
+					"     4  aload_0 [this]\n" + 
+					"     5  aload_1 [finalMessage]\n" + 
+					"     6  invokespecial ParameterNames$1(ParameterNames, java.lang.String) [3]\n" + 
+					"     9  areturn\n" + 
+					"      Line numbers:\n" + 
+					"        [pc: 0, line: 9]\n" + 
+					"      Method Parameters:\n" + 
+					"        final finalMessage\n" + 
+					"        mutableMessage\n" + 
+					"  \n" + 
+					"  // Method descriptor #27 (Ljava/lang/String;Ljava/lang/String;)I\n" + 
+					"  // Stack: 5, Locals: 4\n" + 
+					"  public int localMath(java.lang.String finalMessage, java.lang.String mutableMessage);\n" + 
+					"     0  bipush 42\n" + 
+					"     2  istore_3\n" + 
+					"     3  new ParameterNames$1Local [4]\n" + 
+					"     6  dup\n" + 
+					"     7  aload_0 [this]\n" + 
+					"     8  iconst_2\n" + 
+					"     9  iload_3\n" + 
+					"    10  invokespecial ParameterNames$1Local(ParameterNames, int, int) [5]\n" + 
+					"    13  iconst_3\n" + 
+					"    14  invokevirtual ParameterNames$1Local.calculate(int) : int [6]\n" + 
+					"    17  ireturn\n" + 
+					"      Line numbers:\n" + 
+					"        [pc: 0, line: 17]\n" + 
+					"        [pc: 3, line: 29]\n" + 
+					"      Method Parameters:\n" + 
+					"        final finalMessage\n" + 
+					"        mutableMessage\n" + 
+					"\n" + 
+					"  Inner classes:\n" + 
+					"    [inner class info: #4 ParameterNames$1Local, outer class info: #0\n" + 
+					"     inner name: #9 Local, accessflags: 0 default],\n" + 
+					"    [inner class info: #2 ParameterNames$1, outer class info: #0\n" + 
+					"     inner name: #0, accessflags: 0 default]\n" + 
+					"}";
+
+
+			int index = actualOutput.indexOf(expectedOutput);
+			if (index == -1 || expectedOutput.length() == 0) {
+				System.out.println(Util.displayString(actualOutput, 2));
+			}
+			if (index == -1) {
+				assertEquals("Wrong contents", expectedOutput, actualOutput);
+			}
+	}
+	public void test002() throws Exception {
+
+		ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
+		String path = this.getCompilerTestsPluginDirectoryPath() + File.separator + "workspace" + File.separator + "ParameterNames$1.class";
+		byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(new File(path));
+		String actualOutput =
+			disassembler.disassemble(
+				classFileBytes,
+				"\n",
+				ClassFileBytesDisassembler.DETAILED);
+
+		String expectedOutput =
+			"// Compiled from ParameterNames.java (version 1.8 : 52.0, super bit)\n" + 
+			"// Signature: Ljava/lang/Object;Ljava/util/concurrent/Callable<Ljava/lang/String;>;\n" + 
+			"class ParameterNames$1 implements java.util.concurrent.Callable {\n" + 
+			"  \n" + 
+			"  // Field descriptor #9 Ljava/lang/String;\n" + 
+			"  final synthetic java.lang.String val$finalMessage;\n" + 
+			"  \n" + 
+			"  // Field descriptor #11 LParameterNames;\n" + 
+			"  final synthetic ParameterNames this$0;\n" + 
+			"  \n" + 
+			"  // Method descriptor #13 (LParameterNames;Ljava/lang/String;)V\n" + 
+			"  // Stack: 2, Locals: 3\n" + 
+			"  ParameterNames$1(ParameterNames this$0, java.lang.String val$finalMessage);\n" + 
+			"     0  aload_0 [this]\n" + 
+			"     1  aload_1 [this$0]\n" + 
+			"     2  putfield ParameterNames$1.this$0 : ParameterNames [1]\n" + 
+			"     5  aload_0 [this]\n" + 
+			"     6  aload_2 [val$finalMessage]\n" + 
+			"     7  putfield ParameterNames$1.val$finalMessage : java.lang.String [2]\n" + 
+			"    10  aload_0 [this]\n" + 
+			"    11  invokespecial java.lang.Object() [3]\n" + 
+			"    14  return\n" + 
+			"      Line numbers:\n" + 
+			"        [pc: 0, line: 9]\n" + 
+			"      Method Parameters:\n" + 
+			"        final mandated this$0\n" + 
+			"        final synthetic val$finalMessage\n" + 
+			"  \n" + 
+			"  // Method descriptor #18 ()Ljava/lang/String;\n" + 
+			"  // Stack: 1, Locals: 1\n" + 
+			"  public java.lang.String call() throws java.lang.Exception;\n" + 
+			"    0  aload_0 [this]\n" + 
+			"    1  getfield ParameterNames$1.val$finalMessage : java.lang.String [2]\n" + 
+			"    4  areturn\n" + 
+			"      Line numbers:\n" + 
+			"        [pc: 0, line: 11]\n" + 
+			"  \n" + 
+			"  // Method descriptor #21 ()Ljava/lang/Object;\n" + 
+			"  // Stack: 1, Locals: 1\n" + 
+			"  public bridge synthetic java.lang.Object call() throws java.lang.Exception;\n" + 
+			"    0  aload_0 [this]\n" + 
+			"    1  invokevirtual ParameterNames$1.call() : java.lang.String [4]\n" + 
+			"    4  areturn\n" + 
+			"      Line numbers:\n" + 
+			"        [pc: 0, line: 9]\n" + 
+			"\n" + 
+			"  Inner classes:\n" + 
+			"    [inner class info: #5 ParameterNames$1, outer class info: #0\n" + 
+			"     inner name: #0, accessflags: 0 default]\n" + 
+			"  Enclosing Method: #27  #28 ParameterNames.makeInnerWithCapture(Ljava/lang/String;Ljava/lang/String;)Ljava/util/concurrent/Callable;\n" + 
+			"}";
+
+		int index = actualOutput.indexOf(expectedOutput);
+		if (index == -1 || expectedOutput.length() == 0) {
+			System.out.println(Util.displayString(actualOutput, 2));
+		}
+		if (index == -1) {
+			assertEquals("Wrong contents", expectedOutput, actualOutput);
+		}
+	}
+
+	public void test003() throws Exception {
+
+		ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
+		String path = this.getCompilerTestsPluginDirectoryPath() + File.separator + "workspace" + File.separator + "ParameterNames$1Local.class";
+		byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(new File(path));
+		String actualOutput =
+			disassembler.disassemble(
+				classFileBytes,
+				"\n",
+				ClassFileBytesDisassembler.DETAILED);
+
+		String expectedOutput =
+			"// Compiled from ParameterNames.java (version 1.8 : 52.0, super bit)\n" + 
+			"class ParameterNames$1Local {\n" + 
+			"  \n" + 
+			"  // Field descriptor #8 I\n" + 
+			"  int fieldA;\n" + 
+			"  \n" + 
+			"  // Field descriptor #8 I\n" + 
+			"  final synthetic int val$capturedB;\n" + 
+			"  \n" + 
+			"  // Field descriptor #11 LParameterNames;\n" + 
+			"  final synthetic ParameterNames this$0;\n" + 
+			"  \n" + 
+			"  // Method descriptor #13 (LParameterNames;II)V\n" + 
+			"  // Signature: (I)V\n" + 
+			"  // Stack: 2, Locals: 4\n" + 
+			"  ParameterNames$1Local(ParameterNames this$0, int val$capturedB, int a);\n" + 
+			"     0  aload_0 [this]\n" + 
+			"     1  aload_1 [this$0]\n" + 
+			"     2  putfield ParameterNames$1Local.this$0 : ParameterNames [1]\n" + 
+			"     5  aload_0 [this]\n" + 
+			"     6  iload_3 [a]\n" + 
+			"     7  putfield ParameterNames$1Local.val$capturedB : int [2]\n" + 
+			"    10  aload_0 [this]\n" + 
+			"    11  invokespecial java.lang.Object() [3]\n" + 
+			"    14  aload_0 [this]\n" + 
+			"    15  iload_2 [val$capturedB]\n" + 
+			"    16  putfield ParameterNames$1Local.fieldA : int [4]\n" + 
+			"    19  return\n" + 
+			"      Line numbers:\n" + 
+			"        [pc: 0, line: 21]\n" + 
+			"        [pc: 14, line: 22]\n" + 
+			"        [pc: 19, line: 23]\n" + 
+			"      Method Parameters:\n" + 
+			"        final mandated this$0\n" + 
+			"        final synthetic val$capturedB\n" + 
+			"        a\n" + 
+			"  \n" + 
+			"  // Method descriptor #21 (I)I\n" + 
+			"  // Stack: 2, Locals: 2\n" + 
+			"  int calculate(int parameterC);\n" + 
+			"     0  aload_0 [this]\n" + 
+			"     1  getfield ParameterNames$1Local.fieldA : int [4]\n" + 
+			"     4  aload_0 [this]\n" + 
+			"     5  getfield ParameterNames$1Local.val$capturedB : int [2]\n" + 
+			"     8  iadd\n" + 
+			"     9  iload_1 [parameterC]\n" + 
+			"    10  iadd\n" + 
+			"    11  ireturn\n" + 
+			"      Line numbers:\n" + 
+			"        [pc: 0, line: 25]\n" + 
+			"      Method Parameters:\n" + 
+			"        final parameterC\n" + 
+			"\n" + 
+			"  Inner classes:\n" + 
+			"    [inner class info: #5 ParameterNames$1Local, outer class info: #0\n" + 
+			"     inner name: #33 Local, accessflags: 0 default]\n" + 
+			"  Enclosing Method: #26  #27 ParameterNames.localMath(Ljava/lang/String;Ljava/lang/String;)I\n" + 
+			"}";
+
+		int index = actualOutput.indexOf(expectedOutput);
+		if (index == -1 || expectedOutput.length() == 0) {
+			System.out.println(Util.displayString(actualOutput, 2));
+		}
+		if (index == -1) {
+			assertEquals("Wrong contents", expectedOutput, actualOutput);
+		}
+	}
+
+	public void test004() throws Exception {
+
+		// Test the results of the ClassFileReader
+		String path = this.getCompilerTestsPluginDirectoryPath() + File.separator + "workspace" + File.separator + "ParameterNames.class";
+		
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader classFileReader = ClassFileReader.read(path);
+		IBinaryMethod[] methodInfos = classFileReader.getMethods();
+		assertNotNull("No method infos", methodInfos);
+		int length = methodInfos.length;
+		assertEquals("Must have four methods", 4, length);
+		assertEquals("finalMessage", new String(methodInfos[2].getArgumentNames()[0]));
+		assertEquals("mutableMessage", new String(methodInfos[2].getArgumentNames()[1]));
+	}
+
+	public void test005() throws Exception {
+		// Test the results of the ClassFileReader where some of the paramers are synthetic and/or mandated
+		String path = this.getCompilerTestsPluginDirectoryPath() + File.separator + "workspace" + File.separator + "ParameterNames$1Local.class";
+		
+		org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader classFileReader = ClassFileReader.read(path);
+		IBinaryMethod[] methodInfos = classFileReader.getMethods();
+		assertNotNull("No method infos", methodInfos);
+		int length = methodInfos.length;
+		assertEquals("Must have two methods", 2, length);
+		assertEquals("this$0", new String(methodInfos[0].getArgumentNames()[0]));
+		assertEquals("val$capturedB", new String(methodInfos[0].getArgumentNames()[1]));
+	}
+
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index a2d15a6..0c57269 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -16,6 +16,8 @@
  *								bug 358903 - Filter practically unimportant resource leak warnings
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+ *       Jesper Steen Moeller - Contributions for:
+ *                          Bug 406973 - [compiler] Parse MethodParameters attribute
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -137,6 +139,7 @@ public static Test suite() {
 	since_1_8.add(FlowAnalysisTest8.class);
 	since_1_8.add(TypeAnnotationTest.class);
 	since_1_8.add(Deprecated18Test.class);
+	since_1_8.add(MethodParametersAttributeTest.class);
 
 	// Build final test suite
 	TestSuite all = new TestSuite(TestAll.class.getName());
diff --git a/org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames$1.class b/org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames$1.class
new file mode 100644
index 0000000..0b38bb0
Binary files /dev/null and b/org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames$1.class differ
diff --git a/org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames$1Local.class b/org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames$1Local.class
new file mode 100644
index 0000000..92ba68b
Binary files /dev/null and b/org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames$1Local.class differ
diff --git a/org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames.class b/org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames.class
new file mode 100644
index 0000000..9b92bf5
Binary files /dev/null and b/org.eclipse.jdt.core.tests.compiler/workspace/ParameterNames.class differ
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
index 88d60ac..bbe5654 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
@@ -1,13 +1,19 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2011 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
+ *     Jesper Steen Moeller - Contribution for bug 406973 - [compiler] Parse MethodParameters attribute
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
@@ -21,6 +27,7 @@ import org.eclipse.jdt.internal.compiler.util.Util;
 public class MethodInfo extends ClassFileStruct implements IBinaryMethod, Comparable {
 	static private final char[][] noException = CharOperation.NO_CHAR_CHAR;
 	static private final char[][] noArgumentNames = CharOperation.NO_CHAR_CHAR;
+	static private final char[] ARG = "arg".toCharArray();  //$NON-NLS-1$
 	protected int accessFlags;
 	protected int attributeBytes;
 	protected char[] descriptor;
@@ -30,7 +37,6 @@ public class MethodInfo extends ClassFileStruct implements IBinaryMethod, Compar
 	protected int signatureUtf8Offset;
 	protected long tagBits;
 	protected char[][] argumentNames;
-	protected int argumentNamesIndex;
 
 public static MethodInfo createMethod(byte classFileBytes[], int offsets[], int offset) {
 	MethodInfo methodInfo = new MethodInfo(classFileBytes, offsets, offset);
@@ -44,6 +50,11 @@ public static MethodInfo createMethod(byte classFileBytes[], int offsets[], int
 		char[] attributeName = methodInfo.utf8At(utf8Offset + 3, methodInfo.u2At(utf8Offset + 1));
 		if (attributeName.length > 0) {
 			switch(attributeName[0]) {
+				case 'M' :
+					if (CharOperation.equals(attributeName, AttributeNamesConstants.MethodParametersName)) {
+						methodInfo.decodeMethodParameters(readOffset, methodInfo);
+					}
+					break;
 				case 'S' :
 					if (CharOperation.equals(AttributeNamesConstants.SignatureName, attributeName))
 						methodInfo.signatureUtf8Offset = methodInfo.constantPoolOffsets[methodInfo.u2At(readOffset + 6)] - methodInfo.structOffset;
@@ -474,7 +485,7 @@ private void decodeLocalVariableAttribute(int offset, int codeLength) {
 	if (length != 0) {
 		readOffset += 2;
 		this.argumentNames = new char[length][];
-		this.argumentNamesIndex = 0;
+		int argumentNamesIndex = 0;
 		for (int i = 0; i < length; i++) {
 			int startPC = u2At(readOffset);
 			if (startPC == 0) {
@@ -482,16 +493,35 @@ private void decodeLocalVariableAttribute(int offset, int codeLength) {
 				int utf8Offset = this.constantPoolOffsets[nameIndex] - this.structOffset;
 				char[] localVariableName = utf8At(utf8Offset + 3, u2At(utf8Offset + 1));
 				if (!CharOperation.equals(localVariableName, ConstantPool.This)) {
-					this.argumentNames[this.argumentNamesIndex++] = localVariableName;
+					this.argumentNames[argumentNamesIndex++] = localVariableName;
 				}
 			} else {
 				break;
 			}
 			readOffset += 10;
 		}
-		if (this.argumentNamesIndex != this.argumentNames.length) {
+		if (argumentNamesIndex != this.argumentNames.length) {
 			// resize
-			System.arraycopy(this.argumentNames, 0, (this.argumentNames = new char[this.argumentNamesIndex][]), 0, this.argumentNamesIndex);
+			System.arraycopy(this.argumentNames, 0, (this.argumentNames = new char[argumentNamesIndex][]), 0, argumentNamesIndex);
+		}
+	}
+}
+private void decodeMethodParameters(int offset, MethodInfo methodInfo) {
+	int readOffset = offset + 6;
+	final int length = u1At(readOffset);
+	if (length != 0) {
+		readOffset += 1;
+		this.argumentNames = new char[length][];
+		for (int i = 0; i < length; i++) {
+			int nameIndex = u2At(readOffset);
+			if (nameIndex != 0) {
+				int utf8Offset = this.constantPoolOffsets[nameIndex] - this.structOffset;
+				char[] parameterName = utf8At(utf8Offset + 3, u2At(utf8Offset + 1));
+				this.argumentNames[i] = parameterName;
+			} else {
+				this.argumentNames[i] = CharOperation.concat(ARG, String.valueOf(i).toCharArray());
+			}
+			readOffset += 4;
 		}
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AttributeNamesConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AttributeNamesConstants.java
index 8fd41ec..534eef0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AttributeNamesConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/AttributeNamesConstants.java
@@ -13,6 +13,7 @@
  *     IBM Corporation - initial API and implementation
  *     Jesper S Moller - Contributions for
  *							Bug 405066 - [1.8][compiler][codegen] Implement code generation infrastructure for JSR335             
+ *							Bug 406973 - [compiler] Parse MethodParameters attribute
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
  *******************************************************************************/
@@ -45,4 +46,6 @@ public interface AttributeNamesConstants {
 	// jsr308
 	final char[] RuntimeVisibleTypeAnnotationsName = "RuntimeVisibleTypeAnnotations".toCharArray(); //$NON-NLS-1$
 	final char[] RuntimeInvisibleTypeAnnotationsName = "RuntimeInvisibleTypeAnnotations".toCharArray(); //$NON-NLS-1$
+	// jep118
+	final char[] MethodParametersName = "MethodParameters".toCharArray(); //$NON-NLS-1$
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IAttributeNamesConstants.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IAttributeNamesConstants.java
index 056de2b..da7d26b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IAttributeNamesConstants.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IAttributeNamesConstants.java
@@ -13,6 +13,8 @@
  *     IBM Corporation - initial API and implementation
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+ *        Jesper Steen Moller - Contributions for
+ *							Bug 406973 - [compiler] Parse MethodParameters attribute
  *******************************************************************************/
 package org.eclipse.jdt.core.util;
 
@@ -165,4 +167,10 @@ public interface IAttributeNamesConstants {
 	 * @since 3.8
 	 */
 	char[] BOOTSTRAP_METHODS = "BootstrapMethods".toCharArray(); //$NON-NLS-1$
+
+	/**
+	 * "MethodParameters" attribute (added in jep118).
+	 * @since 3.9 BETA_JAVA8
+	 */
+	char[] METHOD_PARAMETERS = "MethodParameters".toCharArray(); //$NON-NLS-1$
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IMethodParametersAttribute.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IMethodParametersAttribute.java
new file mode 100644
index 0000000..def60c9
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IMethodParametersAttribute.java
@@ -0,0 +1,52 @@
+/*******************************************************************************
+ * Copyright (c) 2013 Jesper Steen Moeller and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     Jesper Steen Moeller - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.util;
+
+/**
+ * Description of a method's parameters names as described in the JVM specifications.
+ *
+ * This interface may be implemented by clients.
+ *
+ * @since 3.9 BETA_JAVA8
+ */
+public interface IMethodParametersAttribute extends IClassFileAttribute {
+
+	/**
+	 * Answer back the number of parameters for this method as specified in
+	 * the JVM specifications.
+	 *
+	 * @return the number of parameters for this method as specified in
+	 * the JVM specifications
+	 */
+	int getMethodParameterLength();
+
+	/**
+	 * Answer back the name for the i'th parameter. Answer null if no
+	 * name is available.
+	 *
+	 * @return back the name for the i'th parameter. Returns null if no
+	 * name is available.
+	 */
+	char[] getParameterName(int i);
+
+	/**
+	 * Answer back the access flags for the i'th parameter, a mask of
+	 * <code>ACC_FINAL</code>, <code>ACC_SYNTHETIC</code>, and <code>ACC_MANDATED</code>.
+	 *
+	 * @return the access flags for the i'th parameter.
+	 */
+	short getAccessFlags(int i);
+
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IModifierConstants.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IModifierConstants.java
index dd64c0b..87402aa 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IModifierConstants.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IModifierConstants.java
@@ -1,12 +1,18 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2013 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Jesper Steen Moeller - Contribution for bug 406973 - [compiler] Parse MethodParameters attribute
  *******************************************************************************/
 package org.eclipse.jdt.core.util;
 
@@ -44,7 +50,7 @@ public interface IModifierConstants {
 	int ACC_ABSTRACT     = 0x0400;
 	int ACC_STRICT       = 0x0800;
 	/**
-	 * Indicates a synthetic member.
+	 * Indicates a synthetic member or method parameter.
 	 * @since 3.0
 	 */
 	int ACC_SYNTHETIC    = 0x1000;
@@ -60,4 +66,10 @@ public interface IModifierConstants {
 	 * @since 3.0
 	 */
 	int ACC_ENUM         = 0x4000;
+
+	/**
+	 * Indicates a mandated parameter, such as this$1 (added in Java SE 8).
+	 * @since 3.9 BETA_JAVA8
+	 */
+	int ACC_MANDATED     = 0x8000;
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
index c7960b4..c8f98e4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
@@ -13,6 +13,8 @@
  *     IBM Corporation - initial API and implementation
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+ *       Jesper Steen Moeller - Contributions for:
+ *                          Bug 406973 - [compiler] Parse MethodParameters attribute
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
 
@@ -95,6 +97,12 @@ public class Disassembler extends ClassFileBytesDisassembler {
 				case IModifierConstants.ACC_ENUM :
 					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_ENUM, "enum", firstModifier); //$NON-NLS-1$
 					break;
+				case IModifierConstants.ACC_SYNTHETIC :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_SYNTHETIC, "synthetic", firstModifier); //$NON-NLS-1$
+					break;
+				case IModifierConstants.ACC_MANDATED :
+					firstModifier = appendModifier(buffer, accessFlags, IModifierConstants.ACC_MANDATED, "mandated", firstModifier); //$NON-NLS-1$
+					break;
 			}
 		}
 		if (!firstModifier) {
@@ -156,6 +164,14 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		});
 	}
 
+	private final void decodeModifiersForMethodParameters(StringBuffer buffer, int accessFlags) {
+		decodeModifiers(buffer, accessFlags, false, true, new int[] {
+				IModifierConstants.ACC_FINAL,
+				IModifierConstants.ACC_MANDATED,
+				IModifierConstants.ACC_SYNTHETIC,
+		});
+	}
+
 	private final void decodeModifiersForType(StringBuffer buffer, int accessFlags) {
 		decodeModifiers(buffer, accessFlags, new int[] {
 				IModifierConstants.ACC_PUBLIC,
@@ -577,9 +593,22 @@ public class Disassembler extends ClassFileBytesDisassembler {
 			}));
 	}
 
+	private void disassemble(IMethodParametersAttribute methodParametersAttribute, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
+		tabNumber += 2;
+		writeNewLine(buffer, lineSeparator, tabNumber);
+		buffer.append(Messages.disassembler_methodparametersheader);
+		for (int i = 0; i < methodParametersAttribute.getMethodParameterLength(); ++i) {
+			writeNewLine(buffer, lineSeparator, tabNumber + 1);
+			short accessFlags = methodParametersAttribute.getAccessFlags(i);
+			decodeModifiersForMethodParameters(buffer, accessFlags);
+			buffer.append(methodParametersAttribute.getParameterName(i));
+		}
+	}
+
 	private void disassembleEnumConstructor(IClassFileReader classFileReader, char[] className, IMethodInfo methodInfo, StringBuffer buffer, String lineSeparator, int tabNumber, int mode) {
 		writeNewLine(buffer, lineSeparator, tabNumber);
 		final ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
+		IMethodParametersAttribute methodParametersAttribute = (IMethodParametersAttribute) Util.getAttribute(methodInfo, IAttributeNamesConstants.METHOD_PARAMETERS);
 		char[] methodDescriptor = methodInfo.getDescriptor();
 		final IClassFileAttribute runtimeVisibleAnnotationsAttribute = Util.getAttribute(methodInfo, IAttributeNamesConstants.RUNTIME_VISIBLE_ANNOTATIONS);
 		final IClassFileAttribute runtimeInvisibleAnnotationsAttribute = Util.getAttribute(methodInfo, IAttributeNamesConstants.RUNTIME_INVISIBLE_ANNOTATIONS);
@@ -596,7 +625,7 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		decodeModifiersForMethod(buffer, accessFlags & IModifierConstants.ACC_PRIVATE);
 		CharOperation.replace(methodDescriptor, '/', '.');
 		final boolean isVarArgs = (accessFlags & IModifierConstants.ACC_VARARGS) != 0;
-		final char[] signature = Signature.toCharArray(methodDescriptor, returnClassName(className, '.', COMPACT), getParameterNames(methodDescriptor, codeAttribute, accessFlags) , !checkMode(mode, COMPACT), false, isVarArgs);
+		final char[] signature = Signature.toCharArray(methodDescriptor, returnClassName(className, '.', COMPACT), getParameterNames(methodDescriptor, codeAttribute, methodParametersAttribute, accessFlags) , !checkMode(mode, COMPACT), false, isVarArgs);
 		int index = CharOperation.indexOf(',', signature);
 		index = CharOperation.indexOf(',', signature, index + 1);
 		buffer.append(signature, 0, CharOperation.indexOf('(', signature) + 1);
@@ -669,6 +698,7 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		final IClassFileAttribute runtimeInvisibleTypeAnnotationsAttribute = Util.getAttribute(methodInfo, IAttributeNamesConstants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
 		final IClassFileAttribute runtimeVisibleParameterAnnotationsAttribute = Util.getAttribute(methodInfo, IAttributeNamesConstants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS);
 		final IClassFileAttribute runtimeInvisibleParameterAnnotationsAttribute = Util.getAttribute(methodInfo, IAttributeNamesConstants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS);
+		final IClassFileAttribute methodParametersAttribute = Util.getAttribute(methodInfo, IAttributeNamesConstants.METHOD_PARAMETERS);
 		final IClassFileAttribute annotationDefaultAttribute = Util.getAttribute(methodInfo, IAttributeNamesConstants.ANNOTATION_DEFAULT);
 		if (checkMode(mode, SYSTEM | DETAILED)) {
 			buffer.append(Messages.bind(Messages.classfileformat_methoddescriptor,
@@ -715,7 +745,7 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		char[] methodHeader = null;
 		char[][] parameterNames = null;
 		if (!methodInfo.isClinit()) {
-			parameterNames = getParameterNames(methodDescriptor, codeAttribute, accessFlags);
+			parameterNames = getParameterNames(methodDescriptor, codeAttribute, (IMethodParametersAttribute)methodParametersAttribute, accessFlags);
 		}
 		if (methodInfo.isConstructor()) {
 			if (checkMode(mode, WORKING_COPY) && signatureAttribute != null) {
@@ -875,6 +905,11 @@ public class Disassembler extends ClassFileBytesDisassembler {
 				disassemble(codeAttribute, parameterNames, methodDescriptor, (accessFlags & IModifierConstants.ACC_STATIC) != 0, buffer, lineSeparator, tabNumber, mode);
 			}
 		}
+		if (checkMode(mode, SYSTEM | DETAILED)) {
+			if (methodParametersAttribute != null) {
+				disassemble((IMethodParametersAttribute)methodParametersAttribute, buffer, lineSeparator, tabNumber, mode);
+			}
+		}
 		if (checkMode(mode, SYSTEM)) {
 			IClassFileAttribute[] attributes = methodInfo.getAttributes();
 			int length = attributes.length;
@@ -891,6 +926,7 @@ public class Disassembler extends ClassFileBytesDisassembler {
 							&& attribute != runtimeVisibleTypeAnnotationsAttribute
 							&& attribute != runtimeInvisibleParameterAnnotationsAttribute
 							&& attribute != runtimeVisibleParameterAnnotationsAttribute
+							&& attribute != methodParametersAttribute
 							&& !CharOperation.equals(attribute.getAttributeName(), IAttributeNamesConstants.DEPRECATED)
 							&& !CharOperation.equals(attribute.getAttributeName(), IAttributeNamesConstants.SYNTHETIC)) {
 						disassemble(attribute, buffer, lineSeparator, tabNumber, mode);
@@ -2402,28 +2438,37 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		return null;
 	}
 
-	private char[][] getParameterNames(char[] methodDescriptor, ICodeAttribute codeAttribute, int accessFlags) {
+	private char[][] getParameterNames(char[] methodDescriptor, ICodeAttribute codeAttribute, IMethodParametersAttribute parametersAttribute, int accessFlags) {
 		int paramCount = Signature.getParameterCount(methodDescriptor);
 		char[][] parameterNames = new char[paramCount][];
 		// check if the code attribute has debug info for this method
-		if (codeAttribute != null) {
-			ILocalVariableAttribute localVariableAttribute = codeAttribute.getLocalVariableAttribute();
-			if (localVariableAttribute != null) {
-				ILocalVariableTableEntry[] entries = localVariableAttribute.getLocalVariableTable();
-				final int startingIndex = (accessFlags & IModifierConstants.ACC_STATIC) != 0 ? 0 : 1;
-				for (int i = 0; i < paramCount; i++) {
-					ILocalVariableTableEntry searchedEntry = getEntryFor(getLocalIndex(startingIndex, i, methodDescriptor), entries);
-					if (searchedEntry != null) {
-						parameterNames[i] = searchedEntry.getName();
-					} else {
-						parameterNames[i] = CharOperation.concat(Messages.disassembler_parametername.toCharArray(), Integer.toString(i).toCharArray());
-					}
-				}
-			} else {
-				for (int i = 0; i < paramCount; i++) {
+		if (parametersAttribute != null) {
+			int parameterCount = parametersAttribute.getMethodParameterLength();
+			for (int i = 0; i < paramCount; i++) {
+				if (i < parameterCount && parametersAttribute.getParameterName(i) != null) {
+					parameterNames[i] = parametersAttribute.getParameterName(i);
+				} else {
 					parameterNames[i] = CharOperation.concat(Messages.disassembler_parametername.toCharArray(), Integer.toString(i).toCharArray());
 				}
 			}
+		} else if (codeAttribute != null) {
+				ILocalVariableAttribute localVariableAttribute = codeAttribute.getLocalVariableAttribute();
+				if (localVariableAttribute != null) {
+					ILocalVariableTableEntry[] entries = localVariableAttribute.getLocalVariableTable();
+					final int startingIndex = (accessFlags & IModifierConstants.ACC_STATIC) != 0 ? 0 : 1;
+					for (int i = 0; i < paramCount; i++) {
+						ILocalVariableTableEntry searchedEntry = getEntryFor(getLocalIndex(startingIndex, i, methodDescriptor), entries);
+						if (searchedEntry != null) {
+							parameterNames[i] = searchedEntry.getName();
+						} else {
+							parameterNames[i] = CharOperation.concat(Messages.disassembler_parametername.toCharArray(), Integer.toString(i).toCharArray());
+						}
+					}
+				} else {
+					for (int i = 0; i < paramCount; i++) {
+						parameterNames[i] = CharOperation.concat(Messages.disassembler_parametername.toCharArray(), Integer.toString(i).toCharArray());
+					}
+				}
 		} else {
 			for (int i = 0; i < paramCount; i++) {
 				parameterNames[i] = CharOperation.concat(Messages.disassembler_parametername.toCharArray(), Integer.toString(i).toCharArray());
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
index 2de3362..4207cbc 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Messages.java
@@ -13,6 +13,8 @@
  *     IBM Corporation - initial API and implementation
  *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+ *     Jesper Steen Moeller - Contribution for
+ *                          Bug 406973 - [compiler] Parse MethodParameters attribute
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
 
@@ -255,6 +257,7 @@ public final class Messages extends NLS {
 	public static String disassembler_enclosingmethodheader;
 	public static String disassembler_exceptiontableheader;
 	public static String disassembler_linenumberattributeheader;
+	public static String disassembler_methodparametersheader;
 	public static String disassembler_localvariabletableattributeheader;
 	public static String disassembler_localvariabletypetableattributeheader;
 	public static String disassembler_arraydimensions;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MethodInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MethodInfo.java
index 71bf782..0b3c3b0 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MethodInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MethodInfo.java
@@ -13,6 +13,8 @@
  *     IBM Corporation - initial API and implementation
  *        Andy Clement - Contributions for
  *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+ *        Jesper Steen Moeller - Contribution for
+ *                          Bug 406973 - [compiler] Parse MethodParameters attribute
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.util;
 
@@ -124,6 +126,8 @@ public class MethodInfo extends ClassFileStruct implements IMethodInfo {
 				this.attributes[attributesIndex++] = new RuntimeVisibleTypeAnnotationsAttribute(classFileBytes, constantPool, offset + readOffset);
 			} else if (equals(attributeName, IAttributeNamesConstants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS)) {
 				this.attributes[attributesIndex++] = new RuntimeInvisibleTypeAnnotationsAttribute(classFileBytes, constantPool, offset + readOffset);
+			} else if (equals(attributeName, IAttributeNamesConstants.METHOD_PARAMETERS)) {
+				this.attributes[attributesIndex++] = new MethodParametersAttribute(classFileBytes, constantPool, offset + readOffset);
 			} else {
 				this.attributes[attributesIndex++] = new ClassFileAttribute(classFileBytes, constantPool, offset + readOffset);
 			}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MethodParametersAttribute.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MethodParametersAttribute.java
new file mode 100644
index 0000000..10ce77b
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/MethodParametersAttribute.java
@@ -0,0 +1,87 @@
+/*******************************************************************************
+ * Copyright (c) 2013 Jesper Steen Moeller and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     Jesper Steen Moeller - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.internal.core.util;
+
+import org.eclipse.jdt.core.util.ClassFormatException;
+import org.eclipse.jdt.core.util.IConstantPool;
+import org.eclipse.jdt.core.util.IConstantPoolConstant;
+import org.eclipse.jdt.core.util.IConstantPoolEntry;
+import org.eclipse.jdt.core.util.IMethodParametersAttribute;
+
+/**
+ * @since 3.9 BETA_JAVA8
+ */
+public class MethodParametersAttribute extends ClassFileAttribute implements IMethodParametersAttribute {
+
+	private static final char[][] NO_NAMES = new char[0][];
+	private static final short[] NO_ACCES_FLAGS = new short[0];
+	
+	private final int numberOfEntries;
+	private final char[][] names;
+	private final short[] accessFlags;
+	
+
+	MethodParametersAttribute(byte[] classFileBytes, IConstantPool constantPool, int offset) throws ClassFormatException {
+		super(classFileBytes, constantPool, offset);
+		
+		final int length = u1At(classFileBytes, 6, offset);
+		this.numberOfEntries = length;
+		if (length != 0) {
+			int readOffset = offset + 7;
+			this.names = new char[length][];
+			this.accessFlags = new short[length];
+			for (int i = 0; i < length; i++) {
+				int nameIndex = u2At(classFileBytes, 0, readOffset);
+				int mask = u2At(classFileBytes, 2, readOffset);
+				readOffset += 4;
+				if (nameIndex != 0) {
+					IConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(nameIndex);
+					if (constantPoolEntry.getKind() != IConstantPoolConstant.CONSTANT_Utf8) {
+						throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
+					}
+					this.names[i] = constantPoolEntry.getUtf8Value();
+				} else {
+					this.names[i] = null;
+				}
+				this.accessFlags[i] = (short) (mask & 0xFFFF);
+			}
+		} else {
+			this.names = NO_NAMES;
+			this.accessFlags = NO_ACCES_FLAGS;
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IMethodParametersAttribute#getMethodParameterLength()
+	 */
+	public int getMethodParameterLength() {
+		return this.numberOfEntries;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IMethodParametersAttribute#getParameterName(int)
+	 */
+	public char[] getParameterName(int i) {
+		return this.names[i];
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.util.IMethodParametersAttribute#getAccessFlags(int)
+	 */
+	public short getAccessFlags(int i) {
+		return this.accessFlags[i];
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
index 30fad38..7715a7e 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/messages.properties
@@ -13,6 +13,8 @@
 #     IBM Corporation - initial API and implementation
 #        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
 #                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+#        Jesper Steen Moeller - Contribution for
+#                          Bug 406973 - [compiler] Parse MethodParameters attribute
 ###############################################################################
 
 ### JavaModel messages.
@@ -279,6 +281,7 @@ disassembler_sourceattributeheader = Compiled from\
 disassembler_enclosingmethodheader = Enclosing Method:
 disassembler_exceptiontableheader = Exception Table:
 disassembler_linenumberattributeheader = Line numbers:
+disassembler_methodparametersheader = Method Parameters:
 disassembler_localvariabletableattributeheader = Local variable table:
 disassembler_localvariabletypetableattributeheader = Local variable type table:
 disassembler_arraydimensions = []
commit adbbf7460be9edd65891c81d46250a9d2d89f5be
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Mon Aug 26 15:57:25 2013 +0530

    Minor follow up to fix for Bug 406973 - [1.8] Parse MethodParameters
    attribute from classfiles
    
    Signed-off-by: ssankaran <srikanth_sankaran@in.ibm.com>

1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
index c8f98e4..c08a006 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
@@ -597,7 +597,7 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		tabNumber += 2;
 		writeNewLine(buffer, lineSeparator, tabNumber);
 		buffer.append(Messages.disassembler_methodparametersheader);
-		for (int i = 0; i < methodParametersAttribute.getMethodParameterLength(); ++i) {
+		for (int i = 0, length = methodParametersAttribute.getMethodParameterLength(); i < length; ++i) {
 			writeNewLine(buffer, lineSeparator, tabNumber + 1);
 			short accessFlags = methodParametersAttribute.getAccessFlags(i);
 			decodeModifiersForMethodParameters(buffer, accessFlags);
