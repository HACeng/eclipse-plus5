commit 8f6891d448939e984803e732396c844070896f56
Author: David Audel <daudel>
Date:   Fri Dec 8 15:05:58 2006 +0000

    HEAD - bug 152123

510	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
709	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
385	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
35	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
index 7ab7400..c5d6f16 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
@@ -13343,4 +13343,514 @@ public void testBug164311() throws JavaModelException {
 			"zzzzzz[FIELD_REF]{zzzzzz, Ltest.Test;, I, zzzzzz, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
 			requestor.getResults());
 }
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports001() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[FIELD_REF]{test.p.ZZZ.foo, Ltest.p.ZZZ;, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports002() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports003() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports004() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports005() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports006() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports007() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import test.p.ZZZ.*;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports009() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import test.p.ZZZ.*;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports011() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import test.p.ZZZ.foo;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports013() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import test.p.ZZZ.foo;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports016() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public class foo {\n" +
+			"        public void method() {\n" +
+			"            foo\n" +
+			"        }\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"Test.foo[TYPE_REF]{foo, test, Ltest.Test$foo;, null, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports017() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void foo() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"foo[METHOD_REF]{foo(), Ltest.Test;, ()V, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports018() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public int foo;\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"foo[FIELD_REF]{foo, Ltest.Test;, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports019() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        int foo = 0;\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"foo[LOCAL_VARIABLE_REF]{foo, null, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports020() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"    public static int foo(int i){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, (I)I, foo, (i), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports022() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo();\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo(";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
index 3f009a5..dba041f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
@@ -9425,4 +9425,713 @@ public void testEC001() throws JavaModelException {
 			"Test<T>[TYPE_REF]{, test, Ltest.Test<TT;>;, null, null, ["+startOffset+", "+endOffset+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_EXPECTED_TYPE + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports001() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[FIELD_REF]{test.p.ZZZ.foo, Ltest.p.ZZZ;, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports002() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports003() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports004() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports005() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[FIELD_REF]{test.p.ZZZ.foo, Ltest.p.ZZZ;, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports006() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports007() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import test.p.ZZZ.*;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports008() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import static test.p.ZZZ.*;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED +R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports009() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import test.p.ZZZ.*;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports010() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import static test.p.ZZZ.*;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports011() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import test.p.ZZZ.foo;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports012() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import static test.p.ZZZ.foo;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports013() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import test.p.ZZZ.foo;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports014() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import static test.p.ZZZ.foo;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports015() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import static test.p.ZZZ.foo;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	this.workingCopies[2] = getWorkingCopy(
+			"/Completion/src3/test/q/ZZZ2.java",
+			"package test.q;\n" +
+			"public class ZZZ2 {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.q.ZZZ2.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.q.ZZZ2.foo(), Ltest.q.ZZZ2;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports016() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public class foo {\n" +
+			"        public void method() {\n" +
+			"            foo\n" +
+			"        }\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"Test.foo[TYPE_REF]{foo, test, Ltest.Test$foo;, null, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports017() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void foo() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"foo[METHOD_REF]{foo(), Ltest.Test;, ()V, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports018() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public int foo;\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"foo[FIELD_REF]{foo, Ltest.Test;, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports019() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        int foo = 0;\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"foo[LOCAL_VARIABLE_REF]{foo, null, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports020() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"    public static int foo(int i){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, (I)I, foo, (i), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports021() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        <Object>foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static <T> int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, <T:Ljava.lang.Object;>()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports022() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo();\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){}\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo(";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 1de10e0..d045dbf 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -230,6 +230,8 @@ public final class CompletionEngine
 	int forbbidenBindingsPtr = -1;
 	Binding[] forbbidenBindings = new Binding[1];
 	
+	ImportBinding[] favoriteReferenceBindings;
+	
 	boolean assistNodeIsClass;
 	boolean assistNodeIsEnum;
 	boolean assistNodeIsException;
@@ -3073,6 +3075,81 @@ public final class CompletionEngine
 		}
 	}
 	
+	private void findFieldsAndMethodsFromFavorites(
+			char[] token,
+			Scope scope,
+			InvocationSite invocationSite,
+			Scope invocationScope,
+			ObjectVector localsFound,
+			ObjectVector fieldsFound,
+			ObjectVector methodsFound) {
+		
+		ImportBinding[] favoriteBindings = getFavoriteReferenceBindings(invocationScope);
+		
+		if (favoriteBindings != null && favoriteBindings.length > 0) {
+			for (int i = 0; i < favoriteBindings.length; i++) {
+				ImportBinding favoriteBinding = favoriteBindings[i];
+				switch (favoriteBinding.resolvedImport.kind()) {
+					case Binding.FIELD:
+						FieldBinding fieldBinding = (FieldBinding) favoriteBinding.resolvedImport;
+						findFieldsFromFavorites(
+								token,
+								new FieldBinding[]{fieldBinding},
+								scope,
+								fieldsFound,
+								localsFound,
+								fieldBinding.declaringClass,
+								invocationSite,
+								invocationScope);
+						break;
+					case Binding.METHOD:
+						MethodBinding methodBinding = (MethodBinding) favoriteBinding.resolvedImport;
+						MethodBinding[] methods = methodBinding.declaringClass.availableMethods();
+						long range;
+						if ((range = ReferenceBinding.binarySearch(methodBinding.selector, methods)) >= 0) {
+							int start = (int) range, end = (int) (range >> 32);
+							int length = end - start + 1;
+							System.arraycopy(methods, start, methods = new MethodBinding[length], 0, length);
+						} else {
+							methods = Binding.NO_METHODS;			
+						}
+						findLocalMethodsFromFavorites(
+								token,
+								methods,
+								scope,
+								methodsFound,
+								methodBinding.declaringClass,
+								invocationSite,
+								invocationScope);
+						break;
+					case Binding.TYPE:
+						ReferenceBinding referenceBinding = (ReferenceBinding) favoriteBinding.resolvedImport;
+						if(favoriteBinding.onDemand) {
+							findFieldsFromFavorites(
+									token,
+									referenceBinding.availableFields(),
+									scope,
+									fieldsFound,
+									localsFound,
+									referenceBinding,
+									invocationSite,
+									invocationScope);
+							
+							findLocalMethodsFromFavorites(
+									token,
+									referenceBinding.availableMethods(),
+									scope,
+									methodsFound,
+									referenceBinding,
+									invocationSite,
+									invocationScope);
+						}
+						break;
+				}
+			}
+		}
+	}
+	
 	private void findFieldsAndMethodsFromMissingFieldType(
 		char[] token,
 		Scope scope,
@@ -3240,6 +3317,81 @@ public final class CompletionEngine
 		missingTypesConverter.guess(typeRef, scope, substitutionRequestor);
 	}
 	
+	private void findFieldsFromFavorites(
+			char[] fieldName,
+			FieldBinding[] fields,
+			Scope scope,
+			ObjectVector fieldsFound,
+			ObjectVector localsFound,
+			ReferenceBinding receiverType,
+			InvocationSite invocationSite,
+			Scope invocationScope) {
+		
+		char[] typeName = CharOperation.concatWith(receiverType.compoundName, '.');
+
+		int fieldLength = fieldName.length;
+		next : for (int f = fields.length; --f >= 0;) {			
+			FieldBinding field = fields[f];
+
+			if (field.isSynthetic())	continue next;
+			
+			// only static fields must be proposed
+			if (!field.isStatic()) continue next;
+
+			if (fieldLength > field.name.length) continue next;
+
+			if (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */)
+					&& !(this.options.camelCaseMatch && CharOperation.camelCaseMatch(fieldName, field.name)))	continue next;
+
+			if (this.options.checkDeprecation &&
+					field.isViewedAsDeprecated() &&
+					!scope.isDefinedInSameUnit(field.declaringClass))
+				continue next;
+			
+			if (this.options.checkVisibility
+				&& !field.canBeSeenBy(receiverType, invocationSite, scope))	continue next;
+			
+			for (int i = fieldsFound.size; --i >= 0;) {
+				Object[] other = (Object[])fieldsFound.elementAt(i);
+				FieldBinding otherField = (FieldBinding) other[0];
+				
+				if (field == otherField) continue next;
+			}
+			
+			fieldsFound.add(new Object[]{field, receiverType});
+			
+			char[] completion = CharOperation.concat(typeName, field.name, '.');
+
+			int relevance = computeBaseRelevance();
+			relevance += computeRelevanceForInterestingProposal(field);
+			if (fieldName != null) relevance += computeRelevanceForCaseMatching(fieldName, field.name);
+			relevance += computeRelevanceForExpectingType(field.type);
+			relevance += computeRelevanceForStatic(true, true);
+			relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE);
+			
+			this.noProposal = false;
+			
+			if (!this.isIgnored(CompletionProposal.FIELD_REF)) {
+				CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF, this.actualCompletionPosition);
+				proposal.setDeclarationSignature(getSignature(field.declaringClass));
+				proposal.setSignature(getSignature(field.type));
+				proposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
+				proposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
+				proposal.setPackageName(field.type.qualifiedPackageName());
+				proposal.setTypeName(field.type.qualifiedSourceName()); 
+				proposal.setName(field.name);
+				proposal.setCompletion(completion);
+				proposal.setFlags(field.modifiers);
+				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+				proposal.setRelevance(relevance);
+				this.requestor.accept(proposal);
+				if(DEBUG) {
+					this.printDebug(proposal);
+				}
+			}
+		}
+	}
+	
 	private void findImports(CompletionOnImportReference importReference, boolean findMembers) {
 		char[][] tokens = importReference.tokens;
 			
@@ -4485,6 +4637,130 @@ public final class CompletionEngine
 		methodsFound.addAll(newMethodsFound);
 	}
 	
+	private void findLocalMethodsFromFavorites(
+			char[] methodName,
+			MethodBinding[] methods,
+			Scope scope,
+			ObjectVector methodsFound,
+			ReferenceBinding receiverType,
+			InvocationSite invocationSite,
+			Scope invocationScope) {
+		
+			char[] typeName = CharOperation.concatWith(receiverType.compoundName, '.');
+
+			int methodLength = methodName.length;
+
+			next : for (int f = methods.length; --f >= 0;) {
+				MethodBinding method = methods[f];
+
+				if (method.isSynthetic()) continue next;
+
+				if (method.isDefaultAbstract())	continue next;
+
+				if (method.isConstructor()) continue next;
+				
+				if (this.options.checkDeprecation &&
+						method.isViewedAsDeprecated() &&
+						!scope.isDefinedInSameUnit(method.declaringClass))
+					continue next;
+				
+				if (!method.isStatic()) continue next;
+
+				if (this.options.checkVisibility
+					&& !method.canBeSeenBy(receiverType, invocationSite, scope)) continue next;
+
+				if (methodLength > method.selector.length) continue next;
+					
+				if (!CharOperation.prefixEquals(methodName, method.selector, false /* ignore case */)
+						&& !(this.options.camelCaseMatch && CharOperation.camelCaseMatch(methodName, method.selector))) {
+					continue next;
+				}
+				
+				for (int i = methodsFound.size; --i >= 0;) {
+					Object[] other = (Object[]) methodsFound.elementAt(i);
+					MethodBinding otherMethod = (MethodBinding) other[0];
+					
+					if (method == otherMethod) continue next;
+				}
+				
+				methodsFound.add(new Object[]{method, receiverType});
+				
+				ReferenceBinding superTypeWithSameErasure = (ReferenceBinding)receiverType.findSuperTypeWithSameErasure(method.declaringClass);
+				if (method.declaringClass != superTypeWithSameErasure) {
+					MethodBinding[] otherMethods = superTypeWithSameErasure.getMethods(method.selector);
+					for (int i = 0; i < otherMethods.length; i++) {
+						if(otherMethods[i].original() == method.original()) {
+							method = otherMethods[i];
+						}
+					}
+				}
+				
+				int length = method.parameters.length;
+				char[][] parameterPackageNames = new char[length][];
+				char[][] parameterTypeNames = new char[length][];
+
+				for (int i = 0; i < length; i++) {
+					TypeBinding type = method.original().parameters[i];
+					parameterPackageNames[i] = type.qualifiedPackageName();
+					parameterTypeNames[i] = type.qualifiedSourceName();
+				}
+				char[][] parameterNames = findMethodParameterNames(method,parameterTypeNames);
+
+				char[] completion = CharOperation.NO_CHAR;
+				
+				int previousStartPosition = this.startPosition;
+				
+				if (this.source != null
+					&& this.source.length > this.endPosition
+					&& this.source[this.endPosition] == '(') {
+					completion = method.selector;
+				} else {
+					completion = CharOperation.concat(method.selector, new char[] { '(', ')' });
+				}
+				
+				completion = CharOperation.concat(typeName, completion, '.');
+
+				int relevance = computeBaseRelevance();
+				relevance += computeRelevanceForInterestingProposal();
+				if (methodName != null) relevance += computeRelevanceForCaseMatching(methodName, method.selector);
+				relevance += computeRelevanceForExpectingType(method.returnType);
+				relevance += computeRelevanceForStatic(true, method.isStatic());
+				relevance += computeRelevanceForQualification(true);
+				relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE);
+
+				
+				this.noProposal = false;
+				// Standard proposal
+				if(!this.isIgnored(CompletionProposal.METHOD_REF)) {
+					CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
+					proposal.setDeclarationSignature(getSignature(method.declaringClass));
+					proposal.setSignature(getSignature(method));
+					MethodBinding original = method.original();
+					if(original != method) {
+						proposal.setOriginalSignature(getSignature(original));
+					}
+					proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
+					proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
+					proposal.setParameterPackageNames(parameterPackageNames);
+					proposal.setParameterTypeNames(parameterTypeNames);
+					proposal.setPackageName(method.returnType.qualifiedPackageName());
+					proposal.setTypeName(method.returnType.qualifiedSourceName());
+					proposal.setName(method.selector);
+					proposal.setCompletion(completion);
+					proposal.setFlags(method.modifiers);
+					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+					proposal.setRelevance(relevance);
+					if(parameterNames != null) proposal.setParameterNames(parameterNames);
+					this.requestor.accept(proposal);
+					if(DEBUG) {
+						this.printDebug(proposal);
+					}
+				}
+				
+				this.startPosition = previousStartPosition;
+			}
+		}
+	
 	private CompletionProposal createRequiredTypeProposal(Binding binding, int start, int end, int relevance) {
 		CompletionProposal proposal = null;
 		if (binding instanceof ReferenceBinding) {
@@ -4525,8 +4801,11 @@ public final class CompletionEngine
 		char[] methodName,
 		MethodBinding[] methods,
 		Scope scope,
+		ObjectVector methodsFound,
 		ReferenceBinding receiverType,
 		InvocationSite invocationSite) {
+		
+		ObjectVector newMethodsFound =  new ObjectVector();
 
 		next : for (int f = methods.length; --f >= 0;) {
 			MethodBinding method = methods[f];
@@ -4550,6 +4829,22 @@ public final class CompletionEngine
 			if (!CharOperation.equals(methodName, method.selector, false /* ignore case */)
 					&& !(this.options.camelCaseMatch && CharOperation.camelCaseMatch(methodName, method.selector)))
 				continue next;
+			
+			for (int i = methodsFound.size; --i >= 0;) {
+				Object[] other = (Object[]) methodsFound.elementAt(i);
+				MethodBinding otherMethod = (MethodBinding) other[0];
+				ReferenceBinding otherReceiverType = (ReferenceBinding) other[1];
+				if (method == otherMethod && receiverType == otherReceiverType)
+					continue next;
+				
+				if (CharOperation.equals(method.selector, otherMethod.selector, true)) {
+					if (lookupEnvironment.methodVerifier().doesMethodOverride(otherMethod, method)) {
+						continue next;
+					}
+				}
+			}
+
+			newMethodsFound.add(new Object[]{method, receiverType});
 
 			int length = method.parameters.length;
 			char[][] parameterPackageNames = new char[length][];
@@ -4611,6 +4906,8 @@ public final class CompletionEngine
 			}
 			this.startPosition = previousStartPosition;
 		}
+		
+		methodsFound.addAll(newMethodsFound);
 	}
 	int computeRelevanceForCaseMatching(char[] token, char[] proposalName){
 		if (this.options.camelCaseMatch) {
@@ -5103,6 +5400,10 @@ public final class CompletionEngine
 			(missingTypes && !this.requestor.isAllowingRequiredProposals(kind, CompletionProposal.TYPE_REF));
 	}
 	
+	private boolean isIgnored(int kind) {
+		return this.requestor.isIgnored(kind);
+	}
+	
 	private void findMethods(
 		char[] selector,
 		TypeBinding[] typeArgTypes,
@@ -6173,6 +6474,7 @@ public final class CompletionEngine
 				currentScope = currentScope.parent;
 			}
 			
+			// search in static import
 			ImportBinding[] importBindings = scope.compilationUnitScope().imports;
 			for (int i = 0; i < importBindings.length; i++) {
 				ImportBinding importBinding = importBindings[i];
@@ -6249,6 +6551,7 @@ public final class CompletionEngine
 											methodBinding.selector,
 											methodBinding.declaringClass.methods(),
 											scope,
+											methodsFound,
 											methodBinding.declaringClass,
 											invocationSite);
 								}
@@ -6257,6 +6560,18 @@ public final class CompletionEngine
 					}
 				}
 			}
+			
+			if (this.assistNodeInJavadoc == 0) {
+				// search in favorites import
+				findFieldsAndMethodsFromFavorites(
+						token,
+						scope,
+						invocationSite,
+						invocationScope,
+						localsFound,
+						fieldsFound,
+						methodsFound);
+			}
 		}
 	}
 	private char[][] findVariableFromUnresolvedReference(LocalDeclaration variable, BlockScope scope, final char[][] discouragedNames) {
@@ -6495,6 +6810,76 @@ public final class CompletionEngine
 		}*/
 	}
 	
+	private ImportBinding[] getFavoriteReferenceBindings(Scope scope) {
+		if (this.favoriteReferenceBindings != null) return this.favoriteReferenceBindings;
+		
+		String[] favoriteReferences = this.requestor.getFavoriteReferences();
+		
+		if (favoriteReferences == null || favoriteReferences.length == 0) return null;
+		
+		ImportBinding[] resolvedImports = new ImportBinding[favoriteReferences.length];
+		
+		int count = 0;
+		next : for (int i = 0; i < favoriteReferences.length; i++) {
+			String favoriteReference = favoriteReferences[i];
+			
+			int length;
+			if (favoriteReference == null || (length = favoriteReference.length()) == 0) continue next;
+			
+			boolean onDemand = favoriteReference.charAt(length - 1) == '*';
+			
+			char[][] compoundName = CharOperation.splitOn('.', favoriteReference.toCharArray());
+			if (onDemand) {
+				compoundName = CharOperation.subarray(compoundName, 0, compoundName.length - 1);
+			}
+			
+			// remove duplicate and conflicting
+			for (int j = 0; j < count; j++) {
+				ImportReference f = resolvedImports[j].reference;
+				
+				if (CharOperation.equals(f.tokens, compoundName)) continue next;
+				
+				if (!onDemand && !f.onDemand) {
+					if (CharOperation.equals(f.tokens[f.tokens.length - 1], compoundName[compoundName.length - 1]))
+						continue next;
+				}
+			}
+			
+			boolean isStatic = this.compilerOptions.sourceLevel > ClassFileConstants.JDK1_4;
+			
+			ImportReference importReference =
+				new ImportReference(
+						compoundName,
+						new long[compoundName.length],
+						onDemand,
+						isStatic ? ClassFileConstants.AccStatic : ClassFileConstants.AccDefault);
+			
+			Binding importBinding = this.unitScope.findImport(compoundName, isStatic, onDemand);
+			
+			if (!importBinding.isValidBinding()) {
+				continue next;
+			}
+			
+			if (onDemand) {
+				if (importReference.isStatic() && importBinding instanceof PackageBinding) {
+					importReference.modifiers = importReference.modifiers & ~ClassFileConstants.AccStatic;
+				}
+			} else {
+				if (importBinding instanceof PackageBinding) {
+					continue next;
+				}
+			}
+			
+			resolvedImports[count++] =
+				new ImportBinding(compoundName, onDemand, importBinding, importReference);
+		}
+		
+		if (resolvedImports.length > count)
+			System.arraycopy(resolvedImports, 0, resolvedImports = new ImportBinding[count], 0, count);
+		
+		return this.favoriteReferenceBindings = resolvedImports;
+	}
+	
 	public AssistParser getParser() {
 
 		return this.parser;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index bd5e25f..56fdc37 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -428,6 +428,14 @@ public void faultInTypes() {
 	for (int i = 0, length = topLevelTypes.length; i < length; i++)
 		topLevelTypes[i].faultInTypesForFieldsAndMethods();
 }
+// this API is for code assist purpose
+public Binding findImport(char[][] compoundName, boolean findStaticImports, boolean onDemand) {
+	if(onDemand) {
+		return findImport(compoundName, compoundName.length);
+	} else {
+		return findSingleImport(compoundName, findStaticImports);
+	}
+}
 private Binding findImport(char[][] compoundName, int length) {
 	recordQualifiedReference(compoundName);
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
index 7be594b..297e670 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
@@ -60,6 +60,8 @@ public abstract class CompletionRequestor {
 	 */
 	private int ignoreSet = 0;
 	
+	private String[] favoriteReferences;
+	
 	/**
 	 * The set of CompletionProposal kinds that this requestor
 	 * allows for required proposals; <code>0</code> means the set is empty.
@@ -194,6 +196,39 @@ public abstract class CompletionRequestor {
 	}
 	
 	/**
+	 * Returns the favorites references which are used to compute some completion proposals.
+	 * <p>
+	 * A favorite reference is a qualified reference as it can be seen in an import statement.<br>
+	 * e.g. <code>{"java.util.Arrays"}</code><br>
+	 * It can be an on demand reference.<br>
+	 * e.g. <code>{"java.util.Arrays.*"}</code>
+	 * It can be a reference to a static method or field (as in a static import)<br>
+	 * e.g. <code>{"java.util.Arrays.equals"}</code>
+	 * </p>
+	 *
+	 * @return favorites imports
+	 * 
+	 * @since 3.3
+	 */
+	public String[] getFavoriteReferences() {
+		return this.favoriteReferences;
+	}
+	
+	/**
+	 * Set the favorites references which will be used to compute some completion proposals.
+	 * A favorite reference is a qualified reference as it can be seen in an import statement.<br>
+	 * 
+	 * @param favoriteImports
+	 * 
+	 * @see #getFavoriteReferences()
+	 * 
+	 * @since 3.3
+	 */
+	public void setFavoriteReferences(String[] favoriteImports) {
+		this.favoriteReferences = favoriteImports;
+	}
+	
+	/**
 	 * Pro forma notification sent before reporting a batch of
 	 * completion proposals.
 	 * <p>
commit 382b067fdb60eb61ee53faad83800b76fff0bbbf
Author: David Audel <daudel>
Date:   Fri Jan 12 17:58:59 2007 +0000

    HEAD - complementary fix for bug 152123

424	36	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
14	2	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
464	51	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
152	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
274	53	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
10	0	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java
51	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionFlags.java
207	18	org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
11	7	org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
13	1	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
1	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
1	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
index 6be0b7a..e4b9a6c 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests.java
@@ -13397,16 +13397,23 @@ public void testFavoriteImports001() throws JavaModelException {
 			"    public static int foo;\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
 	String completeBehind = "foo";
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
-
+	
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[FIELD_REF]{test.p.ZZZ.foo, Ltest.p.ZZZ;, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[FIELD_REF]{ZZZ.foo, Ltest.p.ZZZ;, I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13428,7 +13435,8 @@ public void testFavoriteImports002() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13436,8 +13444,14 @@ public void testFavoriteImports002() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13459,7 +13473,8 @@ public void testFavoriteImports003() throws JavaModelException {
 			"    public static int foo;\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13490,7 +13505,8 @@ public void testFavoriteImports004() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13521,7 +13537,8 @@ public void testFavoriteImports005() throws JavaModelException {
 			"    public static int foo;\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13529,8 +13546,14 @@ public void testFavoriteImports005() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"",
+			"foo[FIELD_REF]{ZZZ.foo, Ltest.p.ZZZ;, I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13552,7 +13575,8 @@ public void testFavoriteImports006() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13560,8 +13584,14 @@ public void testFavoriteImports006() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"",
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13584,7 +13614,8 @@ public void testFavoriteImports007() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13592,8 +13623,14 @@ public void testFavoriteImports007() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13616,7 +13653,8 @@ public void testFavoriteImports009() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13624,8 +13662,14 @@ public void testFavoriteImports009() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"",
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13648,7 +13692,8 @@ public void testFavoriteImports011() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13656,8 +13701,14 @@ public void testFavoriteImports011() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13680,7 +13731,8 @@ public void testFavoriteImports013() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13688,8 +13740,14 @@ public void testFavoriteImports013() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"",
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13713,17 +13771,24 @@ public void testFavoriteImports016() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
 	String completeBehind = "foo";
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
-
+	
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class Test");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"Test.foo[TYPE_REF]{foo, test, Ltest.Test$foo;, null, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n"+
+			"Test.foo[TYPE_REF]{foo, test, Ltest.Test$foo;, null, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13745,7 +13810,8 @@ public void testFavoriteImports017() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13753,9 +13819,10 @@ public void testFavoriteImports017() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"foo[METHOD_REF]{foo(), Ltest.Test;, ()V, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.Test;, ()V, foo, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13778,7 +13845,8 @@ public void testFavoriteImports018() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13786,9 +13854,15 @@ public void testFavoriteImports018() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class Test");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"foo[FIELD_REF]{foo, Ltest.Test;, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n"+
+			"foo[FIELD_REF]{foo, Ltest.Test;, I, foo, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13811,7 +13885,8 @@ public void testFavoriteImports019() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13819,9 +13894,15 @@ public void testFavoriteImports019() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class Test");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"foo[LOCAL_VARIABLE_REF]{foo, null, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n"+
+			"foo[LOCAL_VARIABLE_REF]{foo, null, I, foo, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13844,7 +13925,8 @@ public void testFavoriteImports020() throws JavaModelException {
 			"    public static int foo(int i){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13852,9 +13934,16 @@ public void testFavoriteImports020() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class Test");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, (I)I, foo, (i), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n"+
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, (I)I, foo, (i), ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -13876,7 +13965,8 @@ public void testFavoriteImports022() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -13888,4 +13978,302 @@ public void testFavoriteImports022() throws JavaModelException {
 			"",
 			requestor.getResults());
 }
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports023() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"/** */\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("/** */");
+	int end2 = start2 + "".length();
+	assertResults(
+			"foo[FIELD_REF]{ZZZ.foo, Ltest.p.ZZZ;, I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports024() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports025() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports026() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public int foo(){return 0;};\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports027() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public int foo(){return 0;};\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports028() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import test.p.ZZZ;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){return 0;};\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	assertResults(
+			"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports030() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_SUGGEST_STATIC_IMPORTS, JavaCore.DISABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+				"/Completion/src3/test/Test.java",
+				"package test;\n" +
+				"public class Test {\n" +
+				"    public void method() {\n" +
+				"        foo\n" +
+				"    }\n" +
+				"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+				"/Completion/src3/test/p/ZZZ.java",
+				"package test.p;\n" +
+				"public class ZZZ {\n" +
+				"    public static int foo(){}\n" +
+				"}");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+		
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "foo";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+		
+		int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+		int start1 = str.lastIndexOf("foo") + "".length();
+		int end1 = start1 + "foo".length();
+		int start2 = str.lastIndexOf("public class");
+		int end2 = start2 + "".length();
+		assertResults(
+				"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+				"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports031() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_SUGGEST_STATIC_IMPORTS, JavaCore.ENABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+				"/Completion/src3/test/Test.java",
+				"package test;\n" +
+				"public class Test {\n" +
+				"    public void method() {\n" +
+				"        foo\n" +
+				"    }\n" +
+				"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+				"/Completion/src3/test/p/ZZZ.java",
+				"package test.p;\n" +
+				"public class ZZZ {\n" +
+				"    public static int foo(){}\n" +
+				"}");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+		
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "foo";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+		
+		int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+		int start1 = str.lastIndexOf("foo") + "".length();
+		int end1 = start1 + "foo".length();
+		int start2 = str.lastIndexOf("public class");
+		int end2 = start2 + "".length();
+		assertResults(
+				"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+				"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
index 37f7cd0..523afb7 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTestsRequestor2.java
@@ -71,8 +71,8 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 	}
 	
 	public void allowAllRequiredProposals() {
-		for (int i = CompletionProposal.ANONYMOUS_CLASS_DECLARATION; i <= CompletionProposal.JAVADOC_INLINE_TAG; i++) {
-			for (int j = CompletionProposal.ANONYMOUS_CLASS_DECLARATION; j <= CompletionProposal.JAVADOC_INLINE_TAG; j++) {
+		for (int i = CompletionProposal.ANONYMOUS_CLASS_DECLARATION; i <= CompletionProposal.TYPE_IMPORT; i++) {
+			for (int j = CompletionProposal.ANONYMOUS_CLASS_DECLARATION; j <= CompletionProposal.TYPE_IMPORT; j++) {
 				this.setAllowsRequiredProposals(i, j, true);
 			}
 		}
@@ -289,6 +289,15 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 			case CompletionProposal.JAVADOC_VALUE_REF :
 				buffer.append("JAVADOC_VALUE_REF"); //$NON-NLS-1$
 				break;
+			case CompletionProposal.FIELD_IMPORT :
+				buffer.append("FIELD_IMPORT"); //$NON-NLS-1$
+				break;
+			case CompletionProposal.METHOD_IMPORT :
+				buffer.append("METHOD_IMPORT"); //$NON-NLS-1$
+				break;
+			case CompletionProposal.TYPE_IMPORT :
+				buffer.append("TYPE_IMPORT"); //$NON-NLS-1$
+				break;
 			default :
 				buffer.append("PROPOSAL"); //$NON-NLS-1$
 				break;
@@ -412,6 +421,7 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 			case CompletionProposal.ANONYMOUS_CLASS_DECLARATION :
 				return new String(Signature.getSignatureSimpleName(proposal.getDeclarationSignature()));
 			case CompletionProposal.TYPE_REF :
+			case CompletionProposal.TYPE_IMPORT :
 			case CompletionProposal.JAVADOC_TYPE_REF :
 				return new String(Signature.getSignatureSimpleName(proposal.getSignature()));
 			case CompletionProposal.FIELD_REF :
@@ -430,6 +440,8 @@ public class CompletionTestsRequestor2 extends CompletionRequestor {
 			case CompletionProposal.JAVADOC_METHOD_REF :
 			case CompletionProposal.JAVADOC_PARAM_REF :
 			case CompletionProposal.JAVADOC_VALUE_REF :
+			case CompletionProposal.FIELD_IMPORT :
+			case CompletionProposal.METHOD_IMPORT :
 				return new String(proposal.getName());
 			case CompletionProposal.PACKAGE_REF:
 				return new String(proposal.getDeclarationSignature());	
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
index dba041f..bad8bb2 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/CompletionTests_1_5.java
@@ -9444,7 +9444,8 @@ public void testFavoriteImports001() throws JavaModelException {
 			"    public static int foo;\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9452,8 +9453,14 @@ public void testFavoriteImports001() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[FIELD_REF]{test.p.ZZZ.foo, Ltest.p.ZZZ;, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[FIELD_REF]{foo, Ltest.p.ZZZ;, I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[FIELD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9475,16 +9482,23 @@ public void testFavoriteImports002() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
 	String completeBehind = "foo";
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
-
+	
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9506,7 +9520,8 @@ public void testFavoriteImports003() throws JavaModelException {
 			"    public static int foo;\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9537,7 +9552,8 @@ public void testFavoriteImports004() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9568,16 +9584,23 @@ public void testFavoriteImports005() throws JavaModelException {
 			"    public static int foo;\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
 	String completeBehind = "foo";
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
-
+	
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[FIELD_REF]{test.p.ZZZ.foo, Ltest.p.ZZZ;, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[FIELD_REF]{foo, Ltest.p.ZZZ;, I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[FIELD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9599,7 +9622,8 @@ public void testFavoriteImports006() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9607,8 +9631,14 @@ public void testFavoriteImports006() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9631,7 +9661,8 @@ public void testFavoriteImports007() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9639,8 +9670,14 @@ public void testFavoriteImports007() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9663,16 +9700,19 @@ public void testFavoriteImports008() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
 	String completeBehind = "foo";
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
-
+	
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
 	assertResults(
-			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED +R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED +R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9695,7 +9735,8 @@ public void testFavoriteImports009() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9703,8 +9744,14 @@ public void testFavoriteImports009() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9727,7 +9774,8 @@ public void testFavoriteImports010() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9735,8 +9783,10 @@ public void testFavoriteImports010() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
 	assertResults(
-			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED +R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9759,7 +9809,8 @@ public void testFavoriteImports011() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9767,8 +9818,14 @@ public void testFavoriteImports011() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9791,7 +9848,8 @@ public void testFavoriteImports012() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9799,8 +9857,10 @@ public void testFavoriteImports012() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
 	assertResults(
-			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED +R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9823,7 +9883,8 @@ public void testFavoriteImports013() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9831,8 +9892,14 @@ public void testFavoriteImports013() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9855,7 +9922,8 @@ public void testFavoriteImports014() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9863,8 +9931,10 @@ public void testFavoriteImports014() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
 	assertResults(
-			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED +R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9894,7 +9964,8 @@ public void testFavoriteImports015() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.q.ZZZ2.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9902,9 +9973,10 @@ public void testFavoriteImports015() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
 	assertResults(
-			"foo[METHOD_REF]{test.q.ZZZ2.foo(), Ltest.q.ZZZ2;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9928,17 +10000,24 @@ public void testFavoriteImports016() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
 	String completeBehind = "foo";
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
-
+	
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class Test");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"Test.foo[TYPE_REF]{foo, test, Ltest.Test$foo;, null, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], " + (relevance1) + "}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n" +
+			"Test.foo[TYPE_REF]{foo, test, Ltest.Test$foo;, null, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9960,7 +10039,8 @@ public void testFavoriteImports017() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -9968,9 +10048,10 @@ public void testFavoriteImports017() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"foo[METHOD_REF]{foo(), Ltest.Test;, ()V, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.Test;, ()V, foo, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -9993,7 +10074,8 @@ public void testFavoriteImports018() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -10001,9 +10083,15 @@ public void testFavoriteImports018() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"foo[FIELD_REF]{foo, Ltest.Test;, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n"+
+			"foo[FIELD_REF]{foo, Ltest.Test;, I, foo, null, ["+start1+", "+end1+"], " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -10026,7 +10114,8 @@ public void testFavoriteImports019() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -10034,9 +10123,15 @@ public void testFavoriteImports019() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"foo[LOCAL_VARIABLE_REF]{foo, null, I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n"+
+			"foo[LOCAL_VARIABLE_REF]{foo, null, I, foo, null, ["+start1+", "+end1+"], "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_UNQUALIFIED + R_NON_RESTRICTED)+"}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -10059,7 +10154,8 @@ public void testFavoriteImports020() throws JavaModelException {
 			"    public static int foo(int i){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -10067,9 +10163,16 @@ public void testFavoriteImports020() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, " + (R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED) + "}\n" +
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, (I)I, foo, (i), "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}\n"+
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, (I)I, foo, (i), ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, (I)I, foo, (i), ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -10091,7 +10194,8 @@ public void testFavoriteImports021() throws JavaModelException {
 			"    public static <T> int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -10099,8 +10203,14 @@ public void testFavoriteImports021() throws JavaModelException {
 	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
 	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
 
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
 	assertResults(
-			"foo[METHOD_REF]{test.p.ZZZ.foo(), Ltest.p.ZZZ;, <T:Ljava.lang.Object;>()I, foo, null, "+(R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED)+"}",
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, <T:Ljava.lang.Object;>()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, <T:Ljava.lang.Object;>()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
 			requestor.getResults());
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
@@ -10122,7 +10232,8 @@ public void testFavoriteImports022() throws JavaModelException {
 			"    public static int foo(){}\n" +
 			"}");
 	
-	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true);
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
 	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
 	
 	String str = this.workingCopies[0].getSource();
@@ -10134,4 +10245,306 @@ public void testFavoriteImports022() throws JavaModelException {
 			"",
 			requestor.getResults());
 }
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports023() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"/** */\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("/** */");
+	int end2 = start2 + "".length();
+	assertResults(
+			"foo[FIELD_REF]{foo, Ltest.p.ZZZ;, I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[FIELD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports024() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports025() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public int foo;\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports026() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public int foo(){return 0;};\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports027() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public int foo(){return 0;};\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	assertResults(
+			"",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports029() throws JavaModelException {
+	this.workingCopies = new ICompilationUnit[2];
+	this.workingCopies[0] = getWorkingCopy(
+			"/Completion/src3/test/Test.java",
+			"package test;\n" +
+			"import test.p.ZZZ;\n" +
+			"public class Test {\n" +
+			"    public void method() {\n" +
+			"        foo\n" +
+			"    }\n" +
+			"}");
+	
+	this.workingCopies[1] = getWorkingCopy(
+			"/Completion/src3/test/p/ZZZ.java",
+			"package test.p;\n" +
+			"public class ZZZ {\n" +
+			"    public static int foo(){return 0;};\n" +
+			"}");
+	
+	CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+	requestor.allowAllRequiredProposals();
+	requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.foo"});
+	
+	String str = this.workingCopies[0].getSource();
+	String completeBehind = "foo";
+	int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+	this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+
+	int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+	int start1 = str.lastIndexOf("foo") + "".length();
+	int end1 = start1 + "foo".length();
+	int start2 = str.lastIndexOf("public class");
+	int end2 = start2 + "".length();
+	assertResults(
+			"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+			"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+			requestor.getResults());
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports030() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_SUGGEST_STATIC_IMPORTS, JavaCore.DISABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+				"/Completion/src3/test/Test.java",
+				"package test;\n" +
+				"public class Test {\n" +
+				"    public void method() {\n" +
+				"        foo\n" +
+				"    }\n" +
+				"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+				"/Completion/src3/test/p/ZZZ.java",
+				"package test.p;\n" +
+				"public class ZZZ {\n" +
+				"    public static int foo(){}\n" +
+				"}");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+		
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "foo";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+		
+		int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+		int start1 = str.lastIndexOf("foo") + "".length();
+		int end1 = start1 + "foo".length();
+		int start2 = str.lastIndexOf("public class");
+		int end2 = start2 + "".length();
+		assertResults(
+				"foo[METHOD_REF]{ZZZ.foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+				"   ZZZ[TYPE_IMPORT]{import test.p.ZZZ;\n, test.p, Ltest.p.ZZZ;, null, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152123
+public void testFavoriteImports031() throws JavaModelException {
+	this.oldOptions = JavaCore.getOptions();
+	
+	try {
+		Hashtable options = new Hashtable(this.oldOptions);
+		options.put(JavaCore.CODEASSIST_SUGGEST_STATIC_IMPORTS, JavaCore.ENABLED);
+		JavaCore.setOptions(options);
+		
+		this.workingCopies = new ICompilationUnit[2];
+		this.workingCopies[0] = getWorkingCopy(
+				"/Completion/src3/test/Test.java",
+				"package test;\n" +
+				"public class Test {\n" +
+				"    public void method() {\n" +
+				"        foo\n" +
+				"    }\n" +
+				"}");
+		
+		this.workingCopies[1] = getWorkingCopy(
+				"/Completion/src3/test/p/ZZZ.java",
+				"package test.p;\n" +
+				"public class ZZZ {\n" +
+				"    public static int foo(){}\n" +
+				"}");
+		
+		CompletionTestsRequestor2 requestor = new CompletionTestsRequestor2(true, false, true, false, true);
+		requestor.allowAllRequiredProposals();
+		requestor.setFavoriteReferences(new String[]{"test.p.ZZZ.*"});
+		
+		String str = this.workingCopies[0].getSource();
+		String completeBehind = "foo";
+		int cursorLocation = str.lastIndexOf(completeBehind) + completeBehind.length();
+		this.workingCopies[0].codeComplete(cursorLocation, requestor, this.wcOwner);
+		
+		int relevance1 = R_DEFAULT + R_INTERESTING + R_CASE + R_EXACT_NAME + R_NON_RESTRICTED;
+		int start1 = str.lastIndexOf("foo") + "".length();
+		int end1 = start1 + "foo".length();
+		int start2 = str.lastIndexOf("public class");
+		int end2 = start2 + "".length();
+		assertResults(
+				"foo[METHOD_REF]{foo(), Ltest.p.ZZZ;, ()I, foo, null, ["+start1+", "+end1+"], "+(relevance1)+"}\n" +
+				"   foo[METHOD_IMPORT]{import static test.p.ZZZ.foo;\n, Ltest.p.ZZZ;, ()I, foo, null, ["+start2+", "+end2+"], " + (relevance1) + "}",
+				requestor.getResults());
+	} finally {
+		JavaCore.setOptions(oldOptions);
+	}
+}
 }
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 24e438c..a5ff3b5 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -55,10 +55,161 @@ Eclipse SDK 3.3M5 - ?th January 2007
 <li>The compiler is now better able to detect unused private constructors, it now tolerates more than the 
 private constructor with no parameter as the known pattern for blocking instantiation. Basically, unless a
 non private constructor is defined as well, it will ignore unused private constructors from now on (also see bug <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=163443">163443</a>).</li>
+<li>Code Assist can propose import statements:
+<pre>
+public class CompletionProposal {
+	...
+	/**
+	 * Completion is an import of reference to a static field.
+	 * &lt;p&gt;
+	 * The following additional context information is available
+	 * for this kind of completion proposal at little extra cost:
+	 * &lt;ul&gt;
+	 * &lt;li&gt;{@link #getDeclarationSignature()} -
+	 * the type signature of the type that declares the field that is imported
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getFlags()} -
+	 * the modifiers flags (including ACC_ENUM) of the field that is imported
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getName()} -
+	 * the simple name of the field that is imported
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getSignature()} -
+	 * the type signature of the field's type (as opposed to the
+	 * signature of the type in which the referenced field
+	 * is declared)
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getAdditionalFlags()} -
+	 * the completion flags (including ComletionFlags.StaticImport)
+	 * of the proposed import
+	 * &lt;/li&gt;
+	 * &lt;/ul&gt;
+	 * &lt;/p&gt;
+	 * 
+	 * @see #getKind()
+	 * 
+	 * @since 3.3
+	 */
+	public static final int FIELD_IMPORT;
+	
+	/**
+	 * Completion is an import of reference to a static method.
+	 * &lt;p&gt;
+	 * The following additional context information is available
+	 * for this kind of completion proposal at little extra cost:
+	 * &lt;ul&gt;
+	 * &lt;li&gt;{@link #getDeclarationSignature()} -
+	 * the type signature of the type that declares the method that is imported
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getFlags()} -
+	 * the modifiers flags of the method that is imported
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getName()} -
+	 * the simple name of the method that is imported
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getSignature()} -
+	 * the method signature of the method that is imported
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getAdditionalFlags()} -
+	 * the completion flags (including ComletionFlags.StaticImport)
+	 * of the proposed import
+	 * &lt;/li&gt;
+	 * &lt;/ul&gt;
+	 * &lt;/p&gt;
+	 * 
+	 * @see #getKind()
+	 * 
+	 * @since 3.3
+	 */
+	public static final int METHOD_IMPORT;
+	
+	/**
+	 * Completion is an import of reference to a type.
+	 * Only reference to reference types are allowed.
+	 * &lt;p&gt;
+	 * The following additional context information is available
+	 * for this kind of completion proposal at little extra cost:
+	 * &lt;ul&gt;
+	 * &lt;li&gt;{@link #getDeclarationSignature()} -
+	 * the dot-based package name of the package that contains
+	 * the type that is imported
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getSignature()} -
+	 * the type signature of the type that is imported
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getFlags()} -
+	 * the modifiers flags (including Flags.AccInterface, AccEnum,
+	 * and AccAnnotation) of the type that is imported
+	 * &lt;/li&gt;
+	 * &lt;li&gt;{@link #getAdditionalFlags()} -
+	 * the completion flags (including ComletionFlags.StaticImport)
+	 * of the proposed import
+	 * &lt;/li&gt;
+	 * &lt;/ul&gt;
+	 * &lt;/p&gt;
+	 * 
+	 * @see #getKind()
+	 * 
+	 * @since 3.3
+	 */
+	public static final int TYPE_IMPORT;
+	...
+}
+</pre></li>
+<li>Code Assist propose completions computed from a list a favorite references.
+<pre>
+public class CompletionRequestor {
+	...
+	/**
+	 * Returns the favorite references which are used to compute some completion proposals.
+	 * &lt;p&gt;
+	 * A favorite reference is a qualified reference as it can be seen in an import statement.&lt;br&gt;
+	 * e.g. &lt;code&gt;{"java.util.Arrays"}&lt;/code&gt;&lt;br&gt;
+	 * It can be an on demand reference.&lt;br&gt;
+	 * e.g. &lt;code&gt;{"java.util.Arrays.*"}&lt;/code&gt;
+	 * It can be a reference to a static method or field (as in a static import)&lt;br&gt;
+	 * e.g. &lt;code&gt;{"java.util.Arrays.equals"}&lt;/code&gt;
+	 * &lt;/p&gt;
+	 * &lt;p&gt;
+	 * Currently only on demand type references (&lt;code&gt;"java.util.Arrays.*"&lt;/code&gt;),
+	 * references to a static method or a static field are used to compute completion proposals.
+	 * Other kind of reference could be used in the future.
+	 * &lt;/p&gt;
+	 * @return favorite imports
+	 * 
+	 * @since 3.3
+	 */
+	public String[] getFavoriteReferences() {...}
+	
+	/**
+	 * Set the favorite references which will be used to compute some completion proposals.
+	 * A favorite reference is a qualified reference as it can be seen in an import statement.&lt;br&gt;
+	 * 
+	 * @param favoriteImports
+	 * 
+	 * @see #getFavoriteReferences()
+	 * 
+	 * @since 3.3
+	 */
+	public void setFavoriteReferences(String[] favoriteImports) {...}
+	...
+}
+</pre>
+With the following example if the favorite reference is <b>"java.util.Arrays.*"</b> then a proposal
+will be the method <b>"sort()"</b> with a required proposal of a static import <b>"import static java.util.Arrays.sort;"</b>.
+If the completion level is lesser than 1.5 the proposal will be <b>"Arrays.sort()"</b> with a required proposal of an import
+<b>"import java.util.Arrays;"</b>.
+<p>
+The option <code>JavaCore.CODEASSIST_SUGGEST_STATIC_IMPORTS</code> can be disabled to avoid to propose static import
+even if compliance is 1.5 or greater.
+</p>
+</li>
 </ul>
 
 <h3>Problem Reports Fixed</h3>
-<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=170247">170247</a>
+<a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=152123">152123</a>
+[1.5][assist] Code assist for references that require static imports
+<br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=170247">170247</a>
 [model] Document reasons to use or not use CompilationParticipant
 <br><a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=140340">140340</a>
 [5.0][templates] foreach template does not work when an Iterable over a static inner class exists
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index d045dbf..20ccf89 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2006 IBM Corporation and others.
+ * Copyright (c) 2000, 2007 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -15,6 +15,7 @@ import java.util.Locale;
 import java.util.Map;
 
 import org.eclipse.jdt.core.CompletionContext;
+import org.eclipse.jdt.core.CompletionFlags;
 import org.eclipse.jdt.core.CompletionProposal;
 import org.eclipse.jdt.core.CompletionRequestor;
 import org.eclipse.jdt.core.Flags;
@@ -214,6 +215,11 @@ public final class CompletionEngine
 	
 	private final static char[] VARARGS = "...".toCharArray();  //$NON-NLS-1$
 	
+	private final static char[] IMPORT = "import".toCharArray();  //$NON-NLS-1$
+	private final static char[] STATIC = "static".toCharArray();  //$NON-NLS-1$
+	private final static char[] ON_DEMAND = ".*".toCharArray();  //$NON-NLS-1$
+	private final static char[] IMPORT_END = ";\n".toCharArray();  //$NON-NLS-1$
+	
 	private final static int SUPERTYPE = 1;
 	private final static int SUBTYPE = 2;
 	
@@ -3360,8 +3366,6 @@ public final class CompletionEngine
 			
 			fieldsFound.add(new Object[]{field, receiverType});
 			
-			char[] completion = CharOperation.concat(typeName, field.name, '.');
-
 			int relevance = computeBaseRelevance();
 			relevance += computeRelevanceForInterestingProposal(field);
 			if (fieldName != null) relevance += computeRelevanceForCaseMatching(fieldName, field.name);
@@ -3369,24 +3373,92 @@ public final class CompletionEngine
 			relevance += computeRelevanceForStatic(true, true);
 			relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE);
 			
+			CompilationUnitDeclaration cu = this.unitScope.referenceContext;
+			int importStart = cu.types[0].declarationSourceStart;
+			int importEnd = importStart;
+			
 			this.noProposal = false;
 			
-			if (!this.isIgnored(CompletionProposal.FIELD_REF)) {
-				CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF, this.actualCompletionPosition);
-				proposal.setDeclarationSignature(getSignature(field.declaringClass));
-				proposal.setSignature(getSignature(field.type));
-				proposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
-				proposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
-				proposal.setPackageName(field.type.qualifiedPackageName());
-				proposal.setTypeName(field.type.qualifiedSourceName()); 
-				proposal.setName(field.name);
-				proposal.setCompletion(completion);
-				proposal.setFlags(field.modifiers);
-				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-				proposal.setRelevance(relevance);
-				this.requestor.accept(proposal);
-				if(DEBUG) {
-					this.printDebug(proposal);
+			if (this.compilerOptions.complianceLevel < ClassFileConstants.JDK1_5 ||
+					!this.options.suggestStaticImport) {
+				if (!this.isIgnored(CompletionProposal.FIELD_REF, CompletionProposal.TYPE_IMPORT)) {
+					char[] completion = CharOperation.concat(receiverType.sourceName, field.name, '.');
+					
+					CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF, this.actualCompletionPosition);
+					proposal.setDeclarationSignature(getSignature(field.declaringClass));
+					proposal.setSignature(getSignature(field.type));
+					proposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
+					proposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
+					proposal.setPackageName(field.type.qualifiedPackageName());
+					proposal.setTypeName(field.type.qualifiedSourceName()); 
+					proposal.setName(field.name);
+					proposal.setCompletion(completion);
+					proposal.setFlags(field.modifiers);
+					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+					proposal.setRelevance(relevance);
+					
+					char[] typeImportCompletion = createImportCharArray(typeName, false, false);
+					
+					CompletionProposal typeImportProposal = this.createProposal(CompletionProposal.TYPE_IMPORT, this.actualCompletionPosition);
+					typeImportProposal.nameLookup = this.nameEnvironment.nameLookup;
+					typeImportProposal.completionEngine = this;
+					char[] packageName = receiverType.qualifiedPackageName();
+					typeImportProposal.setDeclarationSignature(packageName);
+					typeImportProposal.setSignature(getSignature(receiverType));
+					typeImportProposal.setPackageName(packageName);
+					typeImportProposal.setTypeName(receiverType.qualifiedSourceName());
+					typeImportProposal.setCompletion(typeImportCompletion);
+					typeImportProposal.setFlags(receiverType.modifiers);
+					typeImportProposal.setAdditionalFlags(CompletionFlags.Default);
+					typeImportProposal.setReplaceRange(importStart - this.offset, importEnd - this.offset);
+					typeImportProposal.setRelevance(relevance);
+					
+					proposal.setRequiredProposals(new CompletionProposal[]{typeImportProposal});
+					
+					this.requestor.accept(proposal);
+					if(DEBUG) {
+						this.printDebug(proposal);
+					}
+				}
+			} else {
+				if (!this.isIgnored(CompletionProposal.FIELD_REF, CompletionProposal.FIELD_IMPORT)) {
+					char[] completion = field.name;
+					
+					CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF, this.actualCompletionPosition);
+					proposal.setDeclarationSignature(getSignature(field.declaringClass));
+					proposal.setSignature(getSignature(field.type));
+					proposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
+					proposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
+					proposal.setPackageName(field.type.qualifiedPackageName());
+					proposal.setTypeName(field.type.qualifiedSourceName()); 
+					proposal.setName(field.name);
+					proposal.setCompletion(completion);
+					proposal.setFlags(field.modifiers);
+					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+					proposal.setRelevance(relevance);
+					
+					char[] fieldImportCompletion = createImportCharArray(CharOperation.concat(typeName, field.name, '.'), true, false);
+
+					CompletionProposal fieldImportProposal = this.createProposal(CompletionProposal.FIELD_IMPORT, this.actualCompletionPosition);
+					fieldImportProposal.setDeclarationSignature(getSignature(field.declaringClass));
+					fieldImportProposal.setSignature(getSignature(field.type));
+					fieldImportProposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
+					fieldImportProposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
+					fieldImportProposal.setPackageName(field.type.qualifiedPackageName());
+					fieldImportProposal.setTypeName(field.type.qualifiedSourceName()); 
+					fieldImportProposal.setName(field.name);
+					fieldImportProposal.setCompletion(fieldImportCompletion);
+					fieldImportProposal.setFlags(field.modifiers);
+					fieldImportProposal.setAdditionalFlags(CompletionFlags.StaticImport);
+					fieldImportProposal.setReplaceRange(importStart - this.offset, importEnd - this.offset);
+					fieldImportProposal.setRelevance(relevance);
+					
+					proposal.setRequiredProposals(new CompletionProposal[]{fieldImportProposal});
+					
+					this.requestor.accept(proposal);
+					if(DEBUG) {
+						this.printDebug(proposal);
+					}
 				}
 			}
 		}
@@ -4681,6 +4753,32 @@ public final class CompletionEngine
 					MethodBinding otherMethod = (MethodBinding) other[0];
 					
 					if (method == otherMethod) continue next;
+					
+					if (CharOperation.equals(method.selector, otherMethod.selector, true)) {
+						if (lookupEnvironment.methodVerifier().doesMethodOverride(otherMethod, method)) {
+							continue next;
+						}
+					}
+				}
+				
+				boolean proposeStaticImport = !(this.compilerOptions.complianceLevel < ClassFileConstants.JDK1_5) &&
+					this.options.suggestStaticImport;
+				
+				boolean isAlreadyImported = false;
+				if (!proposeStaticImport) {
+					if(!this.importCachesInitialized) {
+						this.initializeImportCaches();
+					}
+					for (int j = 0; j < this.importCacheCount; j++) {
+						char[][] importName = this.importsCache[j];
+						if(CharOperation.equals(receiverType.sourceName, importName[0])) {
+							if (!CharOperation.equals(typeName, importName[1])) {
+								continue next;
+							} else {
+								isAlreadyImported = true;
+							}
+						}
+					}
 				}
 				
 				methodsFound.add(new Object[]{method, receiverType});
@@ -4718,8 +4816,6 @@ public final class CompletionEngine
 					completion = CharOperation.concat(method.selector, new char[] { '(', ')' });
 				}
 				
-				completion = CharOperation.concat(typeName, completion, '.');
-
 				int relevance = computeBaseRelevance();
 				relevance += computeRelevanceForInterestingProposal();
 				if (methodName != null) relevance += computeRelevanceForCaseMatching(methodName, method.selector);
@@ -4728,32 +4824,138 @@ public final class CompletionEngine
 				relevance += computeRelevanceForQualification(true);
 				relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE);
 
+				CompilationUnitDeclaration cu = this.unitScope.referenceContext;
+				int importStart = cu.types[0].declarationSourceStart;
+				int importEnd = importStart;
 				
 				this.noProposal = false;
-				// Standard proposal
-				if(!this.isIgnored(CompletionProposal.METHOD_REF)) {
-					CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
-					proposal.setDeclarationSignature(getSignature(method.declaringClass));
-					proposal.setSignature(getSignature(method));
-					MethodBinding original = method.original();
-					if(original != method) {
-						proposal.setOriginalSignature(getSignature(original));
+				
+				if (!proposeStaticImport) {
+					if (isAlreadyImported) {
+						if (!isIgnored(CompletionProposal.METHOD_REF)) {
+							completion = CharOperation.concat(receiverType.sourceName, completion, '.');
+							
+							CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
+							proposal.setDeclarationSignature(getSignature(method.declaringClass));
+							proposal.setSignature(getSignature(method));
+							MethodBinding original = method.original();
+							if(original != method) {
+								proposal.setOriginalSignature(getSignature(original));
+							}
+							proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
+							proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
+							proposal.setParameterPackageNames(parameterPackageNames);
+							proposal.setParameterTypeNames(parameterTypeNames);
+							proposal.setPackageName(method.returnType.qualifiedPackageName());
+							proposal.setTypeName(method.returnType.qualifiedSourceName());
+							proposal.setName(method.selector);
+							proposal.setCompletion(completion);
+							proposal.setFlags(method.modifiers);
+							proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+							proposal.setRelevance(relevance);
+							if(parameterNames != null) proposal.setParameterNames(parameterNames);
+							
+							this.requestor.accept(proposal);
+							if(DEBUG) {
+								this.printDebug(proposal);
+							}
+						}
+					} else if (!this.isIgnored(CompletionProposal.METHOD_REF, CompletionProposal.TYPE_IMPORT)) {
+						completion = CharOperation.concat(receiverType.sourceName, completion, '.');
+						
+						CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
+						proposal.setDeclarationSignature(getSignature(method.declaringClass));
+						proposal.setSignature(getSignature(method));
+						MethodBinding original = method.original();
+						if(original != method) {
+							proposal.setOriginalSignature(getSignature(original));
+						}
+						proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
+						proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
+						proposal.setParameterPackageNames(parameterPackageNames);
+						proposal.setParameterTypeNames(parameterTypeNames);
+						proposal.setPackageName(method.returnType.qualifiedPackageName());
+						proposal.setTypeName(method.returnType.qualifiedSourceName());
+						proposal.setName(method.selector);
+						proposal.setCompletion(completion);
+						proposal.setFlags(method.modifiers);
+						proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+						proposal.setRelevance(relevance);
+						if(parameterNames != null) proposal.setParameterNames(parameterNames);
+						
+						char[] typeImportCompletion = createImportCharArray(typeName, false, false);
+						
+						CompletionProposal typeImportProposal = this.createProposal(CompletionProposal.TYPE_IMPORT, this.actualCompletionPosition);
+						typeImportProposal.nameLookup = this.nameEnvironment.nameLookup;
+						typeImportProposal.completionEngine = this;
+						char[] packageName = receiverType.qualifiedPackageName();
+						typeImportProposal.setDeclarationSignature(packageName);
+						typeImportProposal.setSignature(getSignature(receiverType));
+						typeImportProposal.setPackageName(packageName);
+						typeImportProposal.setTypeName(receiverType.qualifiedSourceName());
+						typeImportProposal.setCompletion(typeImportCompletion);
+						typeImportProposal.setFlags(receiverType.modifiers);
+						typeImportProposal.setAdditionalFlags(CompletionFlags.Default);
+						typeImportProposal.setReplaceRange(importStart - this.offset, importEnd - this.offset);
+						typeImportProposal.setRelevance(relevance);
+						
+						proposal.setRequiredProposals(new CompletionProposal[]{typeImportProposal});
+						
+						this.requestor.accept(proposal);
+						if(DEBUG) {
+							this.printDebug(proposal);
+						}
 					}
-					proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
-					proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
-					proposal.setParameterPackageNames(parameterPackageNames);
-					proposal.setParameterTypeNames(parameterTypeNames);
-					proposal.setPackageName(method.returnType.qualifiedPackageName());
-					proposal.setTypeName(method.returnType.qualifiedSourceName());
-					proposal.setName(method.selector);
-					proposal.setCompletion(completion);
-					proposal.setFlags(method.modifiers);
-					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-					proposal.setRelevance(relevance);
-					if(parameterNames != null) proposal.setParameterNames(parameterNames);
-					this.requestor.accept(proposal);
-					if(DEBUG) {
-						this.printDebug(proposal);
+				} else {
+					if (!this.isIgnored(CompletionProposal.METHOD_REF, CompletionProposal.METHOD_IMPORT)) {
+						CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
+						proposal.setDeclarationSignature(getSignature(method.declaringClass));
+						proposal.setSignature(getSignature(method));
+						MethodBinding original = method.original();
+						if(original != method) {
+							proposal.setOriginalSignature(getSignature(original));
+						}
+						proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
+						proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
+						proposal.setParameterPackageNames(parameterPackageNames);
+						proposal.setParameterTypeNames(parameterTypeNames);
+						proposal.setPackageName(method.returnType.qualifiedPackageName());
+						proposal.setTypeName(method.returnType.qualifiedSourceName());
+						proposal.setName(method.selector);
+						proposal.setCompletion(completion);
+						proposal.setFlags(method.modifiers);
+						proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+						proposal.setRelevance(relevance);
+						if(parameterNames != null) proposal.setParameterNames(parameterNames);
+						
+						char[] methodImportCompletion = createImportCharArray(CharOperation.concat(typeName, method.selector, '.'), true, false);
+						
+						CompletionProposal methodImportProposal = this.createProposal(CompletionProposal.METHOD_IMPORT, this.actualCompletionPosition);
+						methodImportProposal.setDeclarationSignature(getSignature(method.declaringClass));
+						methodImportProposal.setSignature(getSignature(method));
+						if(original != method) {
+							proposal.setOriginalSignature(getSignature(original));
+						}
+						methodImportProposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
+						methodImportProposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
+						methodImportProposal.setParameterPackageNames(parameterPackageNames);
+						methodImportProposal.setParameterTypeNames(parameterTypeNames);
+						methodImportProposal.setPackageName(method.returnType.qualifiedPackageName());
+						methodImportProposal.setTypeName(method.returnType.qualifiedSourceName());
+						methodImportProposal.setName(method.selector);
+						methodImportProposal.setCompletion(methodImportCompletion);
+						methodImportProposal.setFlags(method.modifiers);
+						methodImportProposal.setAdditionalFlags(CompletionFlags.StaticImport);
+						methodImportProposal.setReplaceRange(importStart - this.offset, importEnd - this.offset);
+						methodImportProposal.setRelevance(relevance);
+						if(parameterNames != null) methodImportProposal.setParameterNames(parameterNames);
+						
+						proposal.setRequiredProposals(new CompletionProposal[]{methodImportProposal});
+						
+						this.requestor.accept(proposal);
+						if(DEBUG) {
+							this.printDebug(proposal);
+						}
 					}
 				}
 				
@@ -5326,6 +5528,17 @@ public final class CompletionEngine
 			createType(type, completion);
 		}
 	}
+	private char[] createImportCharArray(char[] importedElement, boolean isStatic, boolean onDemand) {
+		char[] result = IMPORT;
+		if (isStatic) {
+			result = CharOperation.concat(result, STATIC, ' ');
+		}
+		result = CharOperation.concat(result, importedElement, ' ');
+		if (onDemand) {
+			result = CharOperation.concat(result, ON_DEMAND);
+		}
+		return CharOperation.concat(result, IMPORT_END);
+	}
 	private void createMethod(MethodBinding method, char[][] parameterPackageNames, char[][] parameterTypeNames, char[][] parameterNames, StringBuffer completion) {
 		//// Modifiers
 		// flush uninteresting modifiers
@@ -5404,6 +5617,11 @@ public final class CompletionEngine
 		return this.requestor.isIgnored(kind);
 	}
 	
+	private boolean isIgnored(int kind, int requiredProposalKind) {
+		return this.requestor.isIgnored(kind) ||
+			!this.requestor.isAllowingRequiredProposals(kind, requiredProposalKind);
+	}
+	
 	private void findMethods(
 		char[] selector,
 		TypeBinding[] typeArgTypes,
@@ -6845,7 +7063,7 @@ public final class CompletionEngine
 				}
 			}
 			
-			boolean isStatic = this.compilerOptions.sourceLevel > ClassFileConstants.JDK1_4;
+			boolean isStatic = true;
 			
 			ImportReference importReference =
 				new ImportReference(
@@ -6860,14 +7078,8 @@ public final class CompletionEngine
 				continue next;
 			}
 			
-			if (onDemand) {
-				if (importReference.isStatic() && importBinding instanceof PackageBinding) {
-					importReference.modifiers = importReference.modifiers & ~ClassFileConstants.AccStatic;
-				}
-			} else {
-				if (importBinding instanceof PackageBinding) {
-					continue next;
-				}
+			if (importBinding instanceof PackageBinding) {
+				continue next;
 			}
 			
 			resolvedImports[count++] =
@@ -7878,6 +8090,15 @@ public final class CompletionEngine
 			case CompletionProposal.ANNOTATION_ATTRIBUTE_REF :
 				buffer.append("ANNOTATION_ATTRIBUT_REF"); //$NON-NLS-1$
 				break;
+			case CompletionProposal.FIELD_IMPORT :
+				buffer.append("FIELD_IMPORT"); //$NON-NLS-1$
+				break;
+			case CompletionProposal.METHOD_IMPORT :
+				buffer.append("METHOD_IMPORT"); //$NON-NLS-1$
+				break;
+			case CompletionProposal.TYPE_IMPORT :
+				buffer.append("TYPE_IMPORT"); //$NON-NLS-1$
+				break;
 			default :
 				buffer.append("PROPOSAL"); //$NON-NLS-1$
 				break;
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java
index 4039d50..552b8ab 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistOptions.java
@@ -46,6 +46,8 @@ public class AssistOptions {
 		"org.eclipse.jdt.core.codeComplete.discouragedReferenceCheck"; 	//$NON-NLS-1$
 	public static final String OPTION_CamelCaseMatch =
 		"org.eclipse.jdt.core.codeComplete.camelCaseMatch"; 	//$NON-NLS-1$
+	public static final String OPTION_SuggestStaticImports =
+		"org.eclipse.jdt.core.codeComplete.suggestStaticImports"; 	//$NON-NLS-1$
 	
 	public static final String ENABLED = "enabled"; //$NON-NLS-1$
 	public static final String DISABLED = "disabled"; //$NON-NLS-1$
@@ -56,6 +58,7 @@ public class AssistOptions {
 	public boolean checkDiscouragedReference = false;
 	public boolean forceImplicitQualification = false;
 	public boolean camelCaseMatch = true;
+	public boolean suggestStaticImport = true;
 	public char[][] fieldPrefixes = null;
 	public char[][] staticFieldPrefixes = null;
 	public char[][] localPrefixes = null;
@@ -206,6 +209,13 @@ public class AssistOptions {
 				this.checkDeprecation = false;
 			}
 		}
+		if ((optionValue = optionsMap.get(OPTION_SuggestStaticImports)) != null) {
+			if (ENABLED.equals(optionValue)) {
+				this.suggestStaticImport = true;
+			} else if (DISABLED.equals(optionValue)) {
+				this.suggestStaticImport = false;
+			}
+		}
 	}
 	
 	private char[][] splitAndTrimOn(char divider, char[] arrayToSplit) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionFlags.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionFlags.java
new file mode 100644
index 0000000..bda7c36
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionFlags.java
@@ -0,0 +1,51 @@
+/*******************************************************************************
+ * Copyright (c) 2007 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core;
+
+/**
+ * Utility class for decoding additional flags in completion proposal.
+ * <p>
+ * This class provides static methods only; it is not intended to be
+ * instantiated or subclassed by clients.
+ * </p>
+ *
+ * @see CompletionProposal#getAdditionalFlags()
+ * 
+ * @since 3.3
+ */
+public final class CompletionFlags {
+	/**
+	 * Constant representing the absence of any flag
+	 */
+	public static final int Default = 0x0000;
+	
+	/**
+	 * Constant representing a static import
+	 */
+	public static final int StaticImport = 0x0001;
+
+	/**
+	 * Not instantiable.
+	 */
+	private CompletionFlags() {
+		// Not instantiable
+	}
+	
+	/**
+	 * Returns whether the given integer includes the {@link #StaticImport} flag.
+	 *
+	 * @param flags the flags
+	 * @return <code>true</code> if the {@link #StaticImport} flag is included
+	 */
+	public static boolean isStaticImport(int flags) {
+		return (flags & StaticImport) != 0;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
index 49949f2..ac27cc9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionProposal.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2006 IBM Corporation and others.
+ * Copyright (c) 2004, 2007 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -631,6 +631,101 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	public static final int JAVADOC_INLINE_TAG = 20;
 
 	/**
+	 * Completion is an import of reference to a static field.
+	 * <p>
+	 * The following additional context information is available
+	 * for this kind of completion proposal at little extra cost:
+	 * <ul>
+	 * <li>{@link #getDeclarationSignature()} -
+	 * the type signature of the type that declares the field that is imported
+	 * </li>
+	 * <li>{@link #getFlags()} -
+	 * the modifiers flags (including ACC_ENUM) of the field that is imported
+	 * </li>
+	 * <li>{@link #getName()} -
+	 * the simple name of the field that is imported
+	 * </li>
+	 * <li>{@link #getSignature()} -
+	 * the type signature of the field's type (as opposed to the
+	 * signature of the type in which the referenced field
+	 * is declared)
+	 * </li>
+	 * <li>{@link #getAdditionalFlags()} -
+	 * the completion flags (including ComletionFlags.StaticImport)
+	 * of the proposed import
+	 * </li>
+	 * </ul>
+	 * </p>
+	 * 
+	 * @see #getKind()
+	 * 
+	 * @since 3.3
+	 */
+	public static final int FIELD_IMPORT = 21;
+	
+	/**
+	 * Completion is an import of reference to a static method.
+	 * <p>
+	 * The following additional context information is available
+	 * for this kind of completion proposal at little extra cost:
+	 * <ul>
+	 * <li>{@link #getDeclarationSignature()} -
+	 * the type signature of the type that declares the method that is imported
+	 * </li>
+	 * <li>{@link #getFlags()} -
+	 * the modifiers flags of the method that is imported
+	 * </li>
+	 * <li>{@link #getName()} -
+	 * the simple name of the method that is imported
+	 * </li>
+	 * <li>{@link #getSignature()} -
+	 * the method signature of the method that is imported
+	 * </li>
+	 * <li>{@link #getAdditionalFlags()} -
+	 * the completion flags (including ComletionFlags.StaticImport)
+	 * of the proposed import
+	 * </li>
+	 * </ul>
+	 * </p>
+	 * 
+	 * @see #getKind()
+	 * 
+	 * @since 3.3
+	 */
+	public static final int METHOD_IMPORT = 22;
+	
+	/**
+	 * Completion is an import of reference to a type.
+	 * Only reference to reference types are allowed.
+	 * <p>
+	 * The following additional context information is available
+	 * for this kind of completion proposal at little extra cost:
+	 * <ul>
+	 * <li>{@link #getDeclarationSignature()} -
+	 * the dot-based package name of the package that contains
+	 * the type that is imported
+	 * </li>
+	 * <li>{@link #getSignature()} -
+	 * the type signature of the type that is imported
+	 * </li>
+	 * <li>{@link #getFlags()} -
+	 * the modifiers flags (including Flags.AccInterface, AccEnum,
+	 * and AccAnnotation) of the type that is imported
+	 * </li>
+	 * <li>{@link #getAdditionalFlags()} -
+	 * the completion flags (including ComletionFlags.StaticImport)
+	 * of the proposed import
+	 * </li>
+	 * </ul>
+	 * </p>
+	 * 
+	 * @see #getKind()
+	 * 
+	 * @since 3.3
+	 */
+	public static final int TYPE_IMPORT = 23;
+	
+	/**
 	 * First valid completion kind.
 	 * 
 	 * @since 3.1
@@ -642,7 +737,7 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * 
 	 * @since 3.1
 	 */
-	protected static final int LAST_KIND = JAVADOC_INLINE_TAG;
+	protected static final int LAST_KIND = TYPE_IMPORT;
 	
 	/**
 	 * Kind of completion request.
@@ -732,7 +827,7 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	
 	/**
 	 * Array of required completion proposals, or <code>null</code> if none.
-	 * The proposal can not be applied if the required prooposals aren't applied.
+	 * The proposal can not be applied if the required proposals aren't applied.
 	 * Defaults to <code>null</code>.
 	 */
 	private CompletionProposal[] requiredProposals;
@@ -745,6 +840,13 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	private int flags = Flags.AccDefault;
 	
 	/**
+	 * Completion flags relevant in the context, or
+	 * <code>CompletionFlags.Default</code> if none.
+	 * Defaults to <code>CompletionFlags.Default</code>.
+	 */
+	private int additionalFlags = CompletionFlags.Default;
+	
+	/**
 	 * Parameter names (for method completions), or
 	 * <code>null</code> if none. Lazily computed.
 	 * Defaults to <code>null</code>.
@@ -804,6 +906,56 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	}
 	
 	/**
+	 * Returns the completion flags relevant in the context, or
+	 * <code>CompletionFlags.Default</code> if none.
+	 * <p>
+	 * This field is available for the following kinds of
+	 * completion proposals:
+	 * <ul>
+	 * <li><code>FIELD_IMPORT</code> - completion flags
+	 * of the attribute that is referenced. Completion flags for
+	 * this proposal kind can only include <code>CompletionFlags.StaticImport</code></li>
+	 * <li><code>METHOD_IMPORT</code> - completion flags
+	 * of the attribute that is referenced. Completion flags for
+	 * this proposal kind can only include <code>CompletionFlags.StaticImport</code></li>
+	 * <li><code>TYPE_IMPORT</code> - completion flags
+	 * of the attribute that is referenced. Completion flags for
+	 * this proposal kind can only include <code>CompletionFlags.StaticImport</code></li>
+	 * </ul>
+	 * For other kinds of completion proposals, this method returns
+	 * <code>CompletionFlags.Default</code>.
+	 * </p>
+	 * 
+	 * @return the completion flags, or
+	 * <code>CompletionFlags.Default</code> if none
+	 * @see CompletionFlags
+	 * 
+	 * @since 3.3
+	 */
+	public int getAdditionalFlags() {
+		return this.additionalFlags;
+	}
+
+	/**
+	 * Sets the completion flags relevant in the context.
+	 * <p>
+	 * If not set, defaults to none.
+	 * </p>
+	 * <p>
+	 * The completion engine creates instances of this class and sets
+	 * its properties; this method is not intended to be used by other clients.
+	 * </p>
+	 * 
+	 * @param additionalFlags the completion flags, or
+	 * <code>CompletionFlags.Default</code> if none
+	 * 
+	 * @since 3.3
+	 */
+	public void setAdditionalFlags(int additionalFlags) {
+		this.additionalFlags = additionalFlags;
+	}
+	
+	/**
 	 * Returns the kind of completion being proposed.
 	 * <p>
 	 * The set of different kinds of completion proposals is
@@ -1057,16 +1209,22 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * of the annotation that declares the attribute that is referenced</li>
 	 * <li><code>ANONYMOUS_CLASS_DECLARATION</code> - type signature
 	 * of the type that is being subclassed or implemented</li>
-	 * 	<li><code>FIELD_REF</code> - type signature
+	 * 	<li><code>FIELD_IMPORT</code> - type signature
+	 * of the type that declares the field that is imported</li>
+	 *  <li><code>FIELD_REF</code> - type signature
 	 * of the type that declares the field that is referenced</li>
-	 * 	<li><code>METHOD_REF</code> - type signature
+	 * 	<li><code>METHOD_IMPORT</code> - type signature
+	 * of the type that declares the method that is imported</li>
+	 *  <li><code>METHOD_REF</code> - type signature
 	 * of the type that declares the method that is referenced</li>
 	 * 	<li><code>METHOD_DECLARATION</code> - type signature
 	 * of the type that declares the method that is being
 	 * implemented or overridden</li>
 	 * 	<li><code>PACKAGE_REF</code> - dot-based package 
 	 * name of the package that is referenced</li>
-	 * 	<li><code>TYPE_REF</code> - dot-based package 
+	 * 	<li><code>TYPE_IMPORT</code> - dot-based package 
+	 * name of the package containing the type that is imported</li>
+	 *  <li><code>TYPE_REF</code> - dot-based package 
 	 * name of the package containing the type that is referenced</li>
 	 *  <li><code>POTENTIAL_METHOD_DECLARATION</code> - type signature
 	 * of the type that declares the method that is being created</li>
@@ -1156,11 +1314,13 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * completion proposals:
 	 * <ul>
 	 *  <li><code>ANNOTATION_ATTRIBUT_REF</code> - the name of the attribute</li>
-	 * 	<li><code>FIELD_REF</code> - the name of the field</li>
+	 * 	<li><code>FIELD_IMPORT</code> - the name of the field</li>
+	 *  <li><code>FIELD_REF</code> - the name of the field</li>
 	 * 	<li><code>KEYWORD</code> - the keyword</li>
 	 * 	<li><code>LABEL_REF</code> - the name of the label</li>
 	 * 	<li><code>LOCAL_VARIABLE_REF</code> - the name of the local variable</li>
-	 * 	<li><code>METHOD_REF</code> - the name of the method (the type simple name for constructor)</li>
+	 * 	<li><code>METHOD_IMPORT</code> - the name of the method</li>
+	 *  <li><code>METHOD_REF</code> - the name of the method (the type simple name for constructor)</li>
 	 * 	<li><code>METHOD_DECLARATION</code> - the name of the method (the type simple name for constructor)</li>
 	 * 	<li><code>VARIABLE_DECLARATION</code> - the name of the variable</li>
 	 *  <li><code>POTENTIAL_METHOD_DECLARATION</code> - the name of the method</li>
@@ -1208,14 +1368,20 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * of the referenced attribute's type</li>
 	 * <li><code>ANONYMOUS_CLASS_DECLARATION</code> - method signature
 	 * of the constructor that is being invoked</li>
-	 * 	<li><code>FIELD_REF</code> - the type signature
+	 * 	<li><code>FIELD_IMPORT</code> - the type signature
+	 * of the referenced field's type</li>
+	 *  <li><code>FIELD_REF</code> - the type signature
 	 * of the referenced field's type</li>
 	 * 	<li><code>LOCAL_VARIABLE_REF</code> - the type signature
 	 * of the referenced local variable's type</li>
-	 * 	<li><code>METHOD_REF</code> - method signature
+	 * 	<li><code>METHOD_IMPORT</code> - method signature
+	 * of the method that is imported</li>
+	 *  <li><code>METHOD_REF</code> - method signature
 	 * of the method that is referenced</li>
 	 * 	<li><code>METHOD_DECLARATION</code> - method signature
 	 * of the method that is being implemented or overridden</li>
+	 * 	<li><code>TYPE_IMPORT</code> - type signature
+	 * of the type that is imported</li>
 	 * 	<li><code>TYPE_REF</code> - type signature
 	 * of the type that is referenced</li>
 	 * 	<li><code>VARIABLE_DECLARATION</code> - the type signature
@@ -1306,10 +1472,10 @@ public final class CompletionProposal extends InternalCompletionProposal {
 //	 * of the type that is being subclassed or implemented</li>
 //	 * 	<li><code>FIELD_REF</code> - the dot-based type name
 //	 * of the type that declares the field that is referenced
-//	 * or an anonymous type instanciation ("new X(){}") if it is an anonymous type</li>
+//	 * or an anonymous type instantiation ("new X(){}") if it is an anonymous type</li>
 //	 * 	<li><code>METHOD_REF</code> - the dot-based type name
 //	 * of the type that declares the method that is referenced
-//	 * or an anonymous type instanciation ("new X(){}") if it is an anonymous type</li>
+//	 * or an anonymous type instantiation ("new X(){}") if it is an anonymous type</li>
 //	 * 	<li><code>METHOD_DECLARATION</code> - the dot-based type name
 //	 * of the type that declares the method that is being
 //	 * implemented or overridden</li>
@@ -1437,7 +1603,7 @@ public final class CompletionProposal extends InternalCompletionProposal {
 //	}
 //	
 //	/**
-//	 * Returns the parameter type names without teh package fragment of
+//	 * Returns the parameter type names without the package fragment of
 //	 * the method relevant in the context, or <code>null</code> if none.
 //	 * <p>
 //	 * This field is available for the following kinds of
@@ -1512,23 +1678,33 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * of the attribute that is referenced; 
 	 * <li><code>ANONYMOUS_CLASS_DECLARATION</code> - modifier flags
 	 * of the constructor that is referenced</li>
-	 * 	<li><code>FIELD_REF</code> - modifier flags
+	 * 	<li><code>FIELD_IMPORT</code> - modifier flags
+	 * of the field that is imported.</li>
+	 *  <li><code>FIELD_REF</code> - modifier flags
 	 * of the field that is referenced; 
 	 * <code>Flags.AccEnum</code> can be used to recognize
 	 * references to enum constants
 	 * </li>
 	 * 	<li><code>KEYWORD</code> - modifier flag
-	 * corrresponding to the modifier keyword</li>
+	 * corresponding to the modifier keyword</li>
 	 * 	<li><code>LOCAL_VARIABLE_REF</code> - modifier flags
 	 * of the local variable that is referenced</li>
+	 *  <li><code>METHOD_IMPORT</code> - modifier flags
+	 * of the method that is imported;
+	 *  </li>
 	 * 	<li><code>METHOD_REF</code> - modifier flags
 	 * of the method that is referenced;
 	 * <code>Flags.AccAnnotation</code> can be used to recognize
 	 * references to annotation type members
 	 * </li>
-	 * 	<li><code>METHOD_DECLARATION</code> - modifier flags
+	 * <li><code>METHOD_DECLARATION</code> - modifier flags
 	 * for the method that is being implemented or overridden</li>
-	 * 	<li><code>TYPE_REF</code> - modifier flags
+	 * <li><code>TYPE_IMPORT</code> - modifier flags
+	 * of the type that is imported; <code>Flags.AccInterface</code>
+	 * can be used to recognize references to interfaces, 
+	 * <code>Flags.AccEnum</code> enum types,
+	 * and <code>Flags.AccAnnotation</code> annotation types</li>
+	 * <li><code>TYPE_REF</code> - modifier flags
 	 * of the type that is referenced; <code>Flags.AccInterface</code>
 	 * can be used to recognize references to interfaces, 
 	 * <code>Flags.AccEnum</code> enum types,
@@ -1571,7 +1747,7 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	/**
 	 * Returns the required completion proposals.
 	 * The proposal can be apply only if these required completion proposals are also applied.
-	 * If the required proposal aren't applied the completion could create complations problems.
+	 * If the required proposal aren't applied the completion could create completion problems.
 	 * 
 	 * <p>
 	 * This field is available for the following kinds of
@@ -1580,11 +1756,15 @@ public final class CompletionProposal extends InternalCompletionProposal {
 	 * 	<li><code>FIELD_REF</code> - The allowed required proposals for this kind are:
 	 *   <ul>
 	 *    <li><code>TYPE_REF</code></li>
+	 *    <li><code>TYPE_IMPORT</code></li>
+	 *    <li><code>FIELD_IMPORT</code></li>
 	 *   </ul>
 	 * </li>
 	 * 	<li><code>METHOD_REF</code> - The allowed required proposals for this kind are:
 	 *   <ul>
 	 *    <li><code>TYPE_REF</code></li>
+	 *    <li><code>TYPE_IMPORT</code></li>
+	 *    <li><code>METHOD_IMPORT</code></li>
 	 *   </ul>
 	 *  </li>
 	 * </ul>
@@ -1837,6 +2017,15 @@ public final class CompletionProposal extends InternalCompletionProposal {
 			case CompletionProposal.JAVADOC_VALUE_REF :
 				buffer.append("JAVADOC_VALUE_REF"); //$NON-NLS-1$
 				break;
+			case CompletionProposal.FIELD_IMPORT :
+				buffer.append("FIELD_IMPORT"); //$NON-NLS-1$
+				break;
+			case CompletionProposal.METHOD_IMPORT :
+				buffer.append("METHOD_IMPORT"); //$NON-NLS-1$
+				break;
+			case CompletionProposal.TYPE_IMPORT :
+				buffer.append("TYPE_IMPORT"); //$NON-NLS-1$
+				break;
 			default :
 				buffer.append("PROPOSAL"); //$NON-NLS-1$
 				break;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
index 297e670..fe1fb1c 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/CompletionRequestor.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2005 IBM Corporation and others.
+ * Copyright (c) 2004, 2007 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -20,7 +20,7 @@ import org.eclipse.jdt.core.compiler.IProblem;
  * </p>
  * <p>
  * The code assist engine normally invokes methods on completion
- * requestors in the following sequence:
+ * requestor in the following sequence:
  * <pre>
  * requestor.beginReporting();
  * requestor.acceptContext(context);
@@ -158,7 +158,7 @@ public abstract class CompletionRequestor {
 	 * Sets whether a proposal of a given kind with a required proposal
 	 * of the given kind is allowed.
 	 * 
-	 * Currenlty only a subset of kinds support required proposals. To see what combinations
+	 * Currently only a subset of kinds support required proposals. To see what combinations
 	 * are supported you must look at {@link CompletionProposal#getRequiredProposals()}
 	 * documentation.
 	 * 
@@ -196,7 +196,7 @@ public abstract class CompletionRequestor {
 	}
 	
 	/**
-	 * Returns the favorites references which are used to compute some completion proposals.
+	 * Returns the favorite references which are used to compute some completion proposals.
 	 * <p>
 	 * A favorite reference is a qualified reference as it can be seen in an import statement.<br>
 	 * e.g. <code>{"java.util.Arrays"}</code><br>
@@ -205,8 +205,12 @@ public abstract class CompletionRequestor {
 	 * It can be a reference to a static method or field (as in a static import)<br>
 	 * e.g. <code>{"java.util.Arrays.equals"}</code>
 	 * </p>
-	 *
-	 * @return favorites imports
+	 * <p>
+	 * Currently only on demand type references (<code>"java.util.Arrays.*"</code>),
+	 * references to a static method or a static field are used to compute completion proposals.
+	 * Other kind of reference could be used in the future.
+	 * </p>
+	 * @return favorite imports
 	 * 
 	 * @since 3.3
 	 */
@@ -215,7 +219,7 @@ public abstract class CompletionRequestor {
 	}
 	
 	/**
-	 * Set the favorites references which will be used to compute some completion proposals.
+	 * Set the favorite references which will be used to compute some completion proposals.
 	 * A favorite reference is a qualified reference as it can be seen in an import statement.<br>
 	 * 
 	 * @param favoriteImports
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index f431802..cbb5352 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -935,7 +935,12 @@ public final class JavaCore extends Plugin {
 	 * @since 3.1
 	 */
 	public static final String CODEASSIST_DISCOURAGED_REFERENCE_CHECK= PLUGIN_ID + ".codeComplete.discouragedReferenceCheck"; //$NON-NLS-1$
-
+	/**
+	 * Possible  configurable option ID.
+	 * @see #getDefaultOptions()
+	 * @since 3.3
+	 */
+	public static final String CODEASSIST_SUGGEST_STATIC_IMPORTS= PLUGIN_ID + ".codeComplete.suggestStaticImports"; //$NON-NLS-1$
 	/**
 	 * Possible  configurable option ID.
 	 * @see #getDefaultOptions()
@@ -2603,6 +2608,13 @@ public final class JavaCore extends Plugin {
 	 *     - option id:         "org.eclipse.jdt.core.codeComplete.camelCaseMatch"
 	 *     - possible values:   { "enabled", "disabled" }
 	 *     - default:           "enabled"
+	 *     
+	 * CODEASSIST / Activate Suggestion of Static Import
+	 *    When enabled, completion proposals can contain static import
+	 *    pattern.
+	 *     - option id:         "org.eclipse.jdt.core.codeComplete.suggestStaticImport"
+	 *     - possible values:   { "enabled", "disabled" }
+	 *     - default:           "enabled"
 	 * </pre>
 	 */
  	public static Hashtable getDefaultOptions(){
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
index 81f969c..bb13da6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaCorePreferenceInitializer.java
@@ -86,6 +86,7 @@ public class JavaCorePreferenceInitializer extends AbstractPreferenceInitializer
 		defaultOptionsMap.put(JavaCore.CODEASSIST_FORBIDDEN_REFERENCE_CHECK, JavaCore.ENABLED);
 		defaultOptionsMap.put(JavaCore.CODEASSIST_DISCOURAGED_REFERENCE_CHECK, JavaCore.DISABLED);
 		defaultOptionsMap.put(JavaCore.CODEASSIST_CAMEL_CASE_MATCH, JavaCore.ENABLED);
+		defaultOptionsMap.put(JavaCore.CODEASSIST_SUGGEST_STATIC_IMPORTS, JavaCore.ENABLED);
 		
 		// Time out for parameter names
 		defaultOptionsMap.put(JavaCore.TIMEOUT_FOR_PARAMETER_NAME_FROM_ATTACHED_JAVADOC, "50"); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index ef0ca4c..b0d0a9f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -1583,6 +1583,7 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 		defaultOptionsMap.put(JavaCore.CODEASSIST_FORBIDDEN_REFERENCE_CHECK, JavaCore.ENABLED);
 		defaultOptionsMap.put(JavaCore.CODEASSIST_DISCOURAGED_REFERENCE_CHECK, JavaCore.DISABLED);
 		defaultOptionsMap.put(JavaCore.CODEASSIST_CAMEL_CASE_MATCH, JavaCore.ENABLED);
+		defaultOptionsMap.put(JavaCore.CODEASSIST_SUGGEST_STATIC_IMPORTS, JavaCore.ENABLED);
 		
 		// Time out for parameter names
 		defaultOptionsMap.put(JavaCore.TIMEOUT_FOR_PARAMETER_NAME_FROM_ATTACHED_JAVADOC, "50"); //$NON-NLS-1$
