commit ceb9e880c1b5f4a965f8c0bb64e2584c9ba904dc
Author: shankha banerjee <shankhba@in.ibm.com>
Date:   Sat Oct 12 09:47:53 2013 +0530

    First batch of changes for Bug 417803 - [1.8][internal] Build a build
    environment compiler to warn on TypeBinding comparisons
    
    Signed-off-by: shankha banerjee <shankhba@in.ibm.com>

1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
13	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
6	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
14	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 40455e6..0c8aa06 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1984,6 +1984,7 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unclosedCloseable\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unhandledWarningToken\" value=\"warning\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.uninternedIdentityComparison\" value=\"disabled\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unnecessaryElse\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess\" value=\"ignore\"/>\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 88fbfed..2bed3d3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -909,6 +909,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("UninitializedNonNullField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UninitializedNonNullFieldHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("UninternedIdentityComparison", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("UnmatchedBracket", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", DEPRECATED);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
@@ -1631,6 +1632,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UninitializedNonNullField", SKIP);
 		expectedProblemAttributes.put("UninitializedNonNullFieldHintMissingDefault", SKIP);
+		expectedProblemAttributes.put("UninternedIdentityComparison", SKIP);
 		expectedProblemAttributes.put("UnmatchedBracket", SKIP);
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", SKIP);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(JavaCore.COMPILER_PB_UNNECESSARY_TYPE_CHECK));
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 2884f7e..e200117 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -883,6 +883,9 @@ void setSourceStart(int sourceStart);
 	/** @since 3.2 */
 	int EnumConstantsCannotBeSurroundedByParenthesis = Syntax + Internal + 442;
 
+	 /** @since 3.10 */
+	int UninternedIdentityComparison = Syntax + Internal + 443;
+
 	// detected task
 	/** @since 2.1 */
 	int Task = Internal + 450;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 909bc0d..7aeb403 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -833,8 +833,12 @@ public class EqualExpression extends BinaryExpression {
 			return null;
 		}
 
+		final CompilerOptions compilerOptions = scope.compilerOptions();
+		if (compilerOptions.complainOnUninternedIdentityComparison && originalRightType.hasTypeBit(TypeIds.BitUninternedType) && originalLeftType.hasTypeBit(TypeIds.BitUninternedType))
+			scope.problemReporter().uninternedIdentityComparison(this, originalLeftType, originalRightType);
+
 		// autoboxing support
-		boolean use15specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;
+		boolean use15specifics = compilerOptions.sourceLevel >= ClassFileConstants.JDK1_5;
 		TypeBinding leftType = originalLeftType, rightType = originalRightType;
 		if (use15specifics) {
 			if (leftType != TypeBinding.NULL && leftType.isBaseType()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 7e71149..dd5abc3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -163,6 +163,7 @@ public class CompilerOptions {
 	public static final String OPTION_NullableAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nullable"; //$NON-NLS-1$
 	public static final String OPTION_NonNullAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nonnull"; //$NON-NLS-1$
 	public static final String OPTION_NonNullByDefaultAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nonnullbydefault"; //$NON-NLS-1$
+	public static final String OPTION_ReportUninternedIdentityComparison = "org.eclipse.jdt.core.compiler.problem.uninternedIdentityComparison"; //$NON-NLS-1$
 	// defaults for the above:
 	static final char[][] DEFAULT_NULLABLE_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.Nullable".toCharArray()); //$NON-NLS-1$
 	static final char[][] DEFAULT_NONNULL_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNull".toCharArray()); //$NON-NLS-1$
@@ -443,6 +444,8 @@ public class CompilerOptions {
 	/** Should immediate null-check for fields be considered during null analysis (syntactical match)? */
 	public boolean enableSyntacticNullAnalysisForFields;
 
+	public boolean complainOnUninternedIdentityComparison;
+
 	// keep in sync with warningTokenToIrritant and warningTokenFromIrritant
 	public final static String[] warningTokens = {
 		"all", //$NON-NLS-1$
@@ -1139,6 +1142,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_SyntacticNullAnalysisForFields, this.enableSyntacticNullAnalysisForFields ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_InheritNullAnnotations, this.inheritNullAnnotations ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
+		optionsMap.put(OPTION_ReportUninternedIdentityComparison, this.complainOnUninternedIdentityComparison ? ENABLED : DISABLED);
 		return optionsMap;
 	}
 
@@ -1304,6 +1308,8 @@ public class CompilerOptions {
 		this.analyseResourceLeaks = true;
 
 		this.reportMissingEnumCaseDespiteDefault = false;
+
+		this.complainOnUninternedIdentityComparison = false;
 	}
 
 	public void set(Map optionsMap) {
@@ -1757,6 +1763,13 @@ public class CompilerOptions {
 				this.storeAnnotations = false;
 			}
 		}
+		if ((optionValue = optionsMap.get(OPTION_ReportUninternedIdentityComparison)) != null) {
+			if (ENABLED.equals(optionValue)) {
+				this.complainOnUninternedIdentityComparison = true;
+			} else if (DISABLED.equals(optionValue)) {
+				this.complainOnUninternedIdentityComparison = false;
+			}
+		}
 	}
 	public String toString() {
 		StringBuffer buf = new StringBuffer("CompilerOptions:"); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index c39a17b..cab7fa0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -795,6 +795,12 @@ public void computeId() {
 					return;
 			}
 			break;
+		case 7 :
+			if (!CharOperation.equals(TypeConstants.JDT, this.compoundName[2]) || !CharOperation.equals(TypeConstants.TYPEBINDING, this.compoundName[6]))
+				return;
+			if (CharOperation.equals(TypeConstants.ORG_ECLIPSE_JDT_INTERNAL_COMPILER_LOOKUP_TYPEBINDING, this.compoundName))
+				this.typeBits |= TypeIds.BitUninternedType;
+			break;
 	}
 }
 
@@ -1051,8 +1057,6 @@ boolean hasNonNullDefault() {
 public final boolean hasRestrictedAccess() {
 	return (this.modifiers & ExtraCompilerModifiers.AccRestrictedAccess) != 0;
 }
-/** Answer an additional bit characterizing this type, like {@link TypeIds#BitAutoCloseable}. */
-abstract public boolean hasTypeBit(int bit);
 
 /** Answer true if the receiver implements anInterface or is identical to anInterface.
 * If searchHierarchy is true, then also search the receiver's superclasses.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index a2c9ae0..eda0a6e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -1217,4 +1217,9 @@ public void swapUnresolved(UnresolvedReferenceBinding unresolvedType,
 public TypeVariableBinding[] typeVariables() {
 	return Binding.NO_TYPE_VARIABLES;
 }
+
+/** Answer an additional bit characterizing this type, like {@link TypeIds#BitAutoCloseable}. */
+public boolean hasTypeBit(int bit) {
+	return false;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index 6c801d9..b708a57 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -95,7 +95,12 @@ public interface TypeConstants {
     char[] LANG3 = "lang3".toCharArray(); //$NON-NLS-1$
     char[] COM = "com".toCharArray(); //$NON-NLS-1$
     char[] GOOGLE = "google".toCharArray(); //$NON-NLS-1$
-
+    char[] JDT = "jdt".toCharArray(); //$NON-NLS-1$
+    char[] INTERNAL = "internal".toCharArray(); //$NON-NLS-1$
+    char[] COMPILER = "compiler".toCharArray(); //$NON-NLS-1$
+    char[] LOOKUP = "lookup".toCharArray(); //$NON-NLS-1$
+    char[] TYPEBINDING = "TypeBinding".toCharArray(); //$NON-NLS-1$
+    
 	// Constant compound names
 	char[][] JAVA_LANG = {JAVA, LANG};
 	char[][] JAVA_IO = {JAVA, IO};
@@ -272,6 +277,7 @@ public interface TypeConstants {
 	char[] VALIDATE_CLASS = "Validate".toCharArray(); //$NON-NLS-1$
 	char[][] ORG_APACHE_COMMONS_LANG_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG, VALIDATE_CLASS };
 	char[][] ORG_APACHE_COMMONS_LANG3_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG3, VALIDATE_CLASS };
+	char[][] ORG_ECLIPSE_JDT_INTERNAL_COMPILER_LOOKUP_TYPEBINDING = new char[][] { ORG, ECLIPSE, JDT, INTERNAL, COMPILER, LOOKUP, TYPEBINDING };
 	// ... methods:
 	char[] IS_TRUE = "isTrue".toCharArray(); //$NON-NLS-1$
 	char[] NOT_NULL = "notNull".toCharArray(); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
index 5703e17..e19710a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
@@ -231,8 +231,9 @@ public interface TypeIds {
 	 */
 	final int BitResourceFreeCloseable = 8;
 	
+	final int BitUninternedType = 16;
 	/**
 	 * Set of type bits that should be inherited by any sub types.
 	 */
-	final int InheritableBits = BitAutoCloseable | BitCloseable;
+	final int InheritableBits = BitAutoCloseable | BitCloseable | BitUninternedType;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 48f56a2..5742758 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -8744,4 +8744,18 @@ public void missingNonNullByDefaultAnnotation(TypeDeclaration type) {
 			compUnitDecl.currentPackage.sourceEnd);
 	}
 }
+public void uninternedIdentityComparison(EqualExpression expr, TypeBinding lhs, TypeBinding rhs) {
+	this.handle(
+			IProblem.UninternedIdentityComparison,
+			new String[] {
+					new String(lhs.readableName()),
+					new String(rhs.readableName())
+			},
+			new String[] {
+					new String(lhs.shortReadableName()),
+					new String(rhs.shortReadableName())
+			},
+			expr.sourceStart,
+			expr.sourceEnd);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 5609e9c..52d7743 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -394,6 +394,7 @@
 440 = 'assert' should not be used as an identifier, since it is a reserved keyword from source level 1.4 on
 441 = 'enum' should not be used as an identifier, since it is a reserved keyword from source level 1.5 on
 442 = Enum constants cannot be surrounded by parenthesis
+443 = The uninterned types {0} and {1} should not be compared using ==/!= operators.
 
 450 = {0}{1}
 
commit 531d1e64d23aeb6d2b637e206fcbdf2c2d6b6bc5
Author: shankha banerjee <shankhba@in.ibm.com>
Date:   Sun Nov 10 17:07:09 2013 +0530

    Fixed Bug 417803 - [internal] Build a build environment compiler to
    warn on TypeBinding comparisons
    
    Signed-off-by: shankha banerjee <shankhba@in.ibm.com>

279	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
2	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
2	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
9	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
29	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
index afe429e..c7d2266 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
@@ -2422,4 +2422,283 @@ public void test0059() throws Exception {
 		true/*shouldFlushOutputDirectory*/,
 		customOptions);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417803,  [internal] Build a build environment compiler to warn on TypeBinding comparisons
+public void test0060() throws Exception {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportUninternedIdentityComparison, CompilerOptions.ENABLED);
+	this.runNegativeTest(
+		new String[] {
+			"org/eclipse/jdt/internal/compiler/lookup/X.java",
+			"package org.eclipse.jdt.internal.compiler.lookup;\n" +
+			"class TypeBinding {\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void gain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void vain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void cain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in org\\eclipse\\jdt\\internal\\compiler\\lookup\\X.java (at line 7)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"2. ERROR in org\\eclipse\\jdt\\internal\\compiler\\lookup\\X.java (at line 9)\n" + 
+		"	if (t1 == t2) {\n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"3. ERROR in org\\eclipse\\jdt\\internal\\compiler\\lookup\\X.java (at line 16)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"4. ERROR in org\\eclipse\\jdt\\internal\\compiler\\lookup\\X.java (at line 18)\n" + 
+		"	if (t1 == t2) {\n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"5. ERROR in org\\eclipse\\jdt\\internal\\compiler\\lookup\\X.java (at line 28)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417803,  [internal] Build a build environment compiler to warn on TypeBinding comparisons
+public void test0061() throws Exception {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportUninternedIdentityComparison, CompilerOptions.ENABLED);
+	this.runNegativeTest(
+		new String[] {
+			"org/eclipse/nonjdt/internal/compiler/lookup/X.java",
+			"package org.eclipse.nonjdt.internal.compiler.lookup;\n" +
+			"class TypeBinding {\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void gain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void vain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void cain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417803,  [internal] Build a build environment compiler to warn on TypeBinding comparisons
+public void test0062() throws Exception {
+	Map customOptions = getCompilerOptions();
+	this.runNegativeTest(
+		new String[] {
+			"org/eclipse/jdt/internal/compiler/lookup/X.java",
+			"package org.eclipse.jdt.internal.compiler.lookup;\n" +
+			"class TypeBinding {\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void gain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void vain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void cain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417803,  [internal] Build a build environment compiler to warn on TypeBinding comparisons
+public void test0063() throws Exception {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportUninternedIdentityComparison, CompilerOptions.ENABLED);
+	this.runNegativeTest(
+		new String[] {
+			"org/eclipse/jdt/core/dom/X.java",
+			"package org.eclipse.jdt.core.dom;\n" +
+			"interface ITypeBinding {\n" +
+			"}\n" +
+			"class TypeBinding implements ITypeBinding {\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void gain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void vain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void cain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in org\\eclipse\\jdt\\core\\dom\\X.java (at line 9)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"2. ERROR in org\\eclipse\\jdt\\core\\dom\\X.java (at line 11)\n" + 
+		"	if (t1 == t2) {\n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"3. ERROR in org\\eclipse\\jdt\\core\\dom\\X.java (at line 18)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"4. ERROR in org\\eclipse\\jdt\\core\\dom\\X.java (at line 20)\n" + 
+		"	if (t1 == t2) {\n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"5. ERROR in org\\eclipse\\jdt\\core\\dom\\X.java (at line 30)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
index 570ce27..9cc5a4b 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
@@ -4470,8 +4470,8 @@ public void initialize() {
 	this.labelPtr = -1;
 	initializeForBlockStatements();
 }
-public void initialize(boolean initializeNLS) {
-	super.initialize(initializeNLS);
+public void initialize(boolean parsingCompilationUnit) {
+	super.initialize(parsingCompilationUnit);
 	this.labelPtr = -1;
 	initializeForBlockStatements();
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
index 10f68d5..c8b613b 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
@@ -1168,8 +1168,8 @@ public void initialize() {
 	this.previousIdentifierPtr = -1;
 	this.bracketDepth = 0;
 }
-public void initialize(boolean initializeNLS) {
-	super.initialize(initializeNLS);
+public void initialize(boolean parsingCompilationUnit) {
+	super.initialize(parsingCompilationUnit);
 	flushAssistState();
 	flushElementStack();
 	this.previousIdentifierPtr = -1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
index 6f85571..b356a9d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
@@ -72,6 +72,8 @@ public class CompilationUnitDeclaration extends ASTNode implements ProblemSeveri
 	private int stringLiteralsPtr;
 	private HashSetOfInt stringLiteralsStart;
 
+	public boolean[] validIdentityComparisonLines;
+
 	IrritantSet[] suppressWarningIrritants;  // irritant for suppressed warnings
 	Annotation[] suppressWarningAnnotations;
 	long[] suppressWarningScopePositions; // (start << 32) + end
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 7aeb403..2497f59 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -835,7 +835,7 @@ public class EqualExpression extends BinaryExpression {
 
 		final CompilerOptions compilerOptions = scope.compilerOptions();
 		if (compilerOptions.complainOnUninternedIdentityComparison && originalRightType.hasTypeBit(TypeIds.BitUninternedType) && originalLeftType.hasTypeBit(TypeIds.BitUninternedType))
-			scope.problemReporter().uninternedIdentityComparison(this, originalLeftType, originalRightType);
+			scope.problemReporter().uninternedIdentityComparison(this, originalLeftType, originalRightType, scope.referenceCompilationUnit());
 
 		// autoboxing support
 		boolean use15specifics = compilerOptions.sourceLevel >= ClassFileConstants.JDK1_5;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index cab7fa0..92ec115 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -795,6 +795,12 @@ public void computeId() {
 					return;
 			}
 			break;
+		case 6:
+			if (!CharOperation.equals(TypeConstants.JDT, this.compoundName[2]) || !CharOperation.equals(TypeConstants.ITYPEBINDING, this.compoundName[5]))
+				return;
+			if (CharOperation.equals(TypeConstants.ORG_ECLIPSE_JDT_CORE_DOM_ITYPEBINDING, this.compoundName))
+				this.typeBits |= TypeIds.BitUninternedType;
+			break;
 		case 7 :
 			if (!CharOperation.equals(TypeConstants.JDT, this.compoundName[2]) || !CharOperation.equals(TypeConstants.TYPEBINDING, this.compoundName[6]))
 				return;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index b708a57..4157f6a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -100,6 +100,8 @@ public interface TypeConstants {
     char[] COMPILER = "compiler".toCharArray(); //$NON-NLS-1$
     char[] LOOKUP = "lookup".toCharArray(); //$NON-NLS-1$
     char[] TYPEBINDING = "TypeBinding".toCharArray(); //$NON-NLS-1$
+    char[] DOM = "dom".toCharArray(); //$NON-NLS-1$
+    char[] ITYPEBINDING = "ITypeBinding".toCharArray(); //$NON-NLS-1$
     
 	// Constant compound names
 	char[][] JAVA_LANG = {JAVA, LANG};
@@ -278,6 +280,8 @@ public interface TypeConstants {
 	char[][] ORG_APACHE_COMMONS_LANG_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG, VALIDATE_CLASS };
 	char[][] ORG_APACHE_COMMONS_LANG3_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG3, VALIDATE_CLASS };
 	char[][] ORG_ECLIPSE_JDT_INTERNAL_COMPILER_LOOKUP_TYPEBINDING = new char[][] { ORG, ECLIPSE, JDT, INTERNAL, COMPILER, LOOKUP, TYPEBINDING };
+	char[][] ORG_ECLIPSE_JDT_CORE_DOM_ITYPEBINDING = new char[][] { ORG, ECLIPSE, JDT, CORE, DOM, ITYPEBINDING };
+
 	// ... methods:
 	char[] IS_TRUE = "isTrue".toCharArray(); //$NON-NLS-1$
 	char[] NOT_NULL = "notNull".toCharArray(); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index 63c8250..c952db5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -9241,7 +9241,7 @@ protected void ignoreExpressionAssignment() {
 public void initialize() {
 	this.initialize(false);
 }
-public void initialize(boolean initializeNLS) {
+public void initialize(boolean parsingCompilationUnit) {
 	//positioning the parser for a new compilation unit
 	//avoiding stack reallocation and all that....
 	this.javadoc = null;
@@ -9285,7 +9285,8 @@ public void initialize(boolean initializeNLS) {
 	this.recordStringLiterals = true;
 	final boolean checkNLS = this.options.getSeverity(CompilerOptions.NonExternalizedString) != ProblemSeverities.Ignore;
 	this.checkExternalizeStrings = checkNLS;
-	this.scanner.checkNonExternalizedStringLiterals = initializeNLS && checkNLS;
+	this.scanner.checkNonExternalizedStringLiterals = parsingCompilationUnit && checkNLS;
+	this.scanner.checkUninternedIdentityComparison = parsingCompilationUnit && this.options.complainOnUninternedIdentityComparison;
 	this.scanner.lastPosition = -1;
 
 	resetModifiers();
@@ -9720,6 +9721,12 @@ protected void parse() {
 	}
 
 	this.scanner.checkNonExternalizedStringLiterals = false;
+	
+	if (this.scanner.checkUninternedIdentityComparison) {
+		this.compilationUnit.validIdentityComparisonLines = this.scanner.getIdentityComparisonLines();
+		this.scanner.checkUninternedIdentityComparison = false;
+	}
+	
 	if (this.reportSyntaxErrorIsRequired && this.hasError && !this.statementRecoveryActivated) {
 		if(!this.options.performStatementsRecovery) {
 			reportSyntaxErrors(isDietParse, oldFirstToken);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
index b381b01..05abcfe 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
@@ -161,6 +161,12 @@ public class Scanner implements TerminalTokens {
 	public static final int TAG_PREFIX_LENGTH= TAG_PREFIX.length;
 	public static final char TAG_POSTFIX= '$';
 	public static final int TAG_POSTFIX_LENGTH= 1;
+
+	// support for complaining on uninterned type comparisons.
+	public static final char[] IDENTITY_COMPARISON_TAG = "//$IDENTITY-COMPARISON$".toCharArray(); //$NON-NLS-1$
+	public boolean [] validIdentityComparisonLines;
+	public boolean checkUninternedIdentityComparison;
+
 	private NLSTag[] nlsTags = null;
 	protected int nlsTagsPtr;
 	public boolean checkNonExternalizedStringLiterals;
@@ -1588,7 +1594,7 @@ public int getNextToken() throws InvalidInputException {
 								recordComment(TokenNameCOMMENT_LINE);
 								if (this.taskTags != null) checkTaskTag(this.startPosition, this.currentPosition);
 								if ((this.currentCharacter == '\r') || (this.currentCharacter == '\n')) {
-									if (this.checkNonExternalizedStringLiterals &&
+									if ((this.checkNonExternalizedStringLiterals || this.checkUninternedIdentityComparison) &&
 											this.lastPosition < this.currentPosition) {
 										parseTags();
 									}
@@ -1607,7 +1613,7 @@ public int getNextToken() throws InvalidInputException {
 								this.currentPosition--;
 								recordComment(TokenNameCOMMENT_LINE);
 								if (this.taskTags != null) checkTaskTag(this.startPosition, this.currentPosition);
-								if (this.checkNonExternalizedStringLiterals &&
+								if ((this.checkNonExternalizedStringLiterals || this.checkUninternedIdentityComparison) &&
 										this.lastPosition < this.currentPosition) {
 									parseTags();
 								}
@@ -1850,6 +1856,11 @@ public NLSTag[] getNLSTags() {
 	}
 	return null;
 }
+public boolean[] getIdentityComparisonLines() {
+	boolean [] retVal = this.validIdentityComparisonLines;
+	this.validIdentityComparisonLines = null;
+	return retVal;
+}
 public char[] getSource(){
 	return this.source;
 }
@@ -2049,7 +2060,7 @@ public final void jumpOverMethodBody() {
 								recordComment(TokenNameCOMMENT_LINE);
 								if (this.recordLineSeparator
 									&& ((this.currentCharacter == '\r') || (this.currentCharacter == '\n'))) {
-										if (this.checkNonExternalizedStringLiterals &&
+										if ((this.checkNonExternalizedStringLiterals || this.checkUninternedIdentityComparison) &&
 												this.lastPosition < this.currentPosition) {
 											parseTags();
 										}
@@ -2065,7 +2076,7 @@ public final void jumpOverMethodBody() {
 								 //an eof will then be generated
 								this.currentPosition--;
 								recordComment(TokenNameCOMMENT_LINE);
-								if (this.checkNonExternalizedStringLiterals &&
+								if ((this.checkNonExternalizedStringLiterals || this.checkUninternedIdentityComparison) &&
 										this.lastPosition < this.currentPosition) {
 									parseTags();
 								}
@@ -2510,8 +2521,9 @@ private void parseTags() {
 	} else {
 		s = this.source;
 	}
-	int pos = CharOperation.indexOf(TAG_PREFIX, s, true, sourceStart, sourceEnd);
-	if (pos != -1) {
+	int pos;
+	if (this.checkNonExternalizedStringLiterals &&
+			(pos = CharOperation.indexOf(TAG_PREFIX, s, true, sourceStart, sourceEnd)) != -1) {
 		if (this.nlsTags == null) {
 			this.nlsTags = new NLSTag[10];
 			this.nlsTagsPtr = 0;
@@ -2537,6 +2549,17 @@ private void parseTags() {
 			}
 			pos = CharOperation.indexOf(TAG_PREFIX, s, true, end, sourceEnd);
 		}
+	} 
+	
+	if (this.checkUninternedIdentityComparison &&
+			(pos = CharOperation.indexOf(IDENTITY_COMPARISON_TAG, s, true, sourceStart, sourceEnd)) != -1) {
+		if (this.validIdentityComparisonLines == null) {
+			this.validIdentityComparisonLines = new boolean[0];
+		}
+		int currentLine = currentLinePtr + 1;
+		int length = this.validIdentityComparisonLines.length;
+		System.arraycopy(this.validIdentityComparisonLines, 0, this.validIdentityComparisonLines = new boolean[currentLine + 1], 0, length);
+		this.validIdentityComparisonLines[currentLine] = true;
 	}
 }
 private int extractInt(char[] array, int start, int end) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index cd44835..2d20e64 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -135,6 +135,7 @@ import org.eclipse.jdt.internal.compiler.parser.RecoveryScanner;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
 import org.eclipse.jdt.internal.compiler.util.Messages;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class ProblemReporter extends ProblemHandler {
 
@@ -8744,7 +8745,7 @@ public void missingNonNullByDefaultAnnotation(TypeDeclaration type) {
 			compUnitDecl.currentPackage.sourceEnd);
 	}
 }
-public void uninternedIdentityComparison(EqualExpression expr, TypeBinding lhs, TypeBinding rhs) {
+public void uninternedIdentityComparison(EqualExpression expr, TypeBinding lhs, TypeBinding rhs, CompilationUnitDeclaration unit) {
 	
 	char [] lhsName = lhs.sourceName();
 	char [] rhsName = rhs.sourceName();
@@ -8759,6 +8760,17 @@ public void uninternedIdentityComparison(EqualExpression expr, TypeBinding lhs,
 			|| CharOperation.equals(rhsName, "ProblemReferenceBinding".toCharArray())) //$NON-NLS-1$
 		return;
 	
+	boolean[] validIdentityComparisonLines = unit.validIdentityComparisonLines;
+	if (validIdentityComparisonLines != null) {
+		int problemStartPosition = expr.left.sourceStart;
+		int[] lineEnds;
+		int lineNumber = problemStartPosition >= 0
+				? Util.getLineNumber(problemStartPosition, lineEnds = unit.compilationResult().getLineSeparatorPositions(), 0, lineEnds.length-1)
+						: 0;
+		if (lineNumber <= validIdentityComparisonLines.length && validIdentityComparisonLines[lineNumber - 1])
+			return;
+	}
+	
 	this.handle(
 			IProblem.UninternedIdentityComparison,
 			new String[] {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
index 597b56c..0d46d20 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
@@ -1129,10 +1129,10 @@ public CompilationUnitDeclaration endParse(int act) {
 	}
 	return super.endParse(act);
 }
-public void initialize(boolean initializeNLS) {
+public void initialize(boolean parsingCompilationUnit) {
 	//positionning the parser for a new compilation unit
 	//avoiding stack reallocation and all that....
-	super.initialize(initializeNLS);
+	super.initialize(parsingCompilationUnit);
 	this.intArrayPtr = -1;
 }
 public void initialize() {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
index f789b58..3f27fc8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
@@ -203,8 +203,8 @@ public class CommentRecorderParser extends Parser {
 	/* (non-Javadoc)
 	 * @see org.eclipse.jdt.internal.compiler.parser.Parser#initialize()
 	 */
-	public void initialize(boolean initializeNLS) {
-		super.initialize(initializeNLS);
+	public void initialize(boolean parsingCompilationUnit) {
+		super.initialize(parsingCompilationUnit);
 		this.commentPtr = -1;
 	}
 	/* (non-Javadoc)
commit 7b78243b59a21f4401b3ec3e9d2215dc9a75a7b5
Author: shankha banerjee <shankhba@in.ibm.com>
Date:   Sat Oct 12 09:47:53 2013 +0530

    First batch of changes for Bug 417803 - [1.8][internal] Build a build
    environment compiler to warn on TypeBinding comparisons
    
    Signed-off-by: shankha banerjee <shankhba@in.ibm.com>
    Conflicts:
    	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
    	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
    	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
    	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties

1	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
13	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
6	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
14	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index f317bf6..dcf25e0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1993,6 +1993,7 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unclosedCloseable\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unhandledWarningToken\" value=\"warning\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.uninternedIdentityComparison\" value=\"disabled\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unnecessaryElse\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess\" value=\"ignore\"/>\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 68eb209..e32467f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1009,6 +1009,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("UninitializedNonNullField", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("UninitializedNonNullFieldHintMissingDefault", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("UninternedIdentityComparison", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("UnmatchedBracket", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", DEPRECATED);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
@@ -1816,6 +1817,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UninitializedLocalVariableHintMissingDefault", SKIP);
 		expectedProblemAttributes.put("UninitializedNonNullField", SKIP);
 		expectedProblemAttributes.put("UninitializedNonNullFieldHintMissingDefault", SKIP);
+		expectedProblemAttributes.put("UninternedIdentityComparison", SKIP);
 		expectedProblemAttributes.put("UnmatchedBracket", SKIP);
 		expectedProblemAttributes.put("UnnecessaryArgumentCast", SKIP);
 		expectedProblemAttributes.put("UnnecessaryCast", new ProblemAttributes(JavaCore.COMPILER_PB_UNNECESSARY_TYPE_CHECK));
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index f3a89d9..33bd8dee 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -948,6 +948,9 @@ void setSourceStart(int sourceStart);
 
 	/** @since 3.9 BETA_JAVA8 */
 	int IllegalUseOfUnderscoreAsAnIdentifier = Syntax + Internal + 443;
+	 /** @since 3.9 BETA_JAVA8 */
+	int UninternedIdentityComparison = Syntax + Internal + 444;
+
 	// detected task
 	/** @since 2.1 */
 	int Task = Internal + 450;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 9053199..480f406 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -839,8 +839,12 @@ public class EqualExpression extends BinaryExpression {
 			return null;
 		}
 
+		final CompilerOptions compilerOptions = scope.compilerOptions();
+		if (compilerOptions.complainOnUninternedIdentityComparison && originalRightType.hasTypeBit(TypeIds.BitUninternedType) && originalLeftType.hasTypeBit(TypeIds.BitUninternedType))
+			scope.problemReporter().uninternedIdentityComparison(this, originalLeftType, originalRightType);
+
 		// autoboxing support
-		boolean use15specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;
+		boolean use15specifics = compilerOptions.sourceLevel >= ClassFileConstants.JDK1_5;
 		TypeBinding leftType = originalLeftType, rightType = originalRightType;
 		if (use15specifics) {
 			if (leftType != TypeBinding.NULL && leftType.isBaseType()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index a1160f6..ecd2f94 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -171,6 +171,7 @@ public class CompilerOptions {
 	public static final String OPTION_NullableAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nullable"; //$NON-NLS-1$
 	public static final String OPTION_NonNullAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nonnull"; //$NON-NLS-1$
 	public static final String OPTION_NonNullByDefaultAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nonnullbydefault"; //$NON-NLS-1$
+	public static final String OPTION_ReportUninternedIdentityComparison = "org.eclipse.jdt.core.compiler.problem.uninternedIdentityComparison"; //$NON-NLS-1$
 	// defaults for the above:
 	static final char[][] DEFAULT_NULLABLE_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.Nullable".toCharArray()); //$NON-NLS-1$
 	static final char[][] DEFAULT_NONNULL_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNull".toCharArray()); //$NON-NLS-1$
@@ -454,6 +455,8 @@ public class CompilerOptions {
 	/** Should immediate null-check for fields be considered during null analysis (syntactical match)? */
 	public boolean enableSyntacticNullAnalysisForFields;
 
+	public boolean complainOnUninternedIdentityComparison;
+
 	// keep in sync with warningTokenToIrritant and warningTokenFromIrritant
 	public final static String[] warningTokens = {
 		"all", //$NON-NLS-1$
@@ -1158,6 +1161,7 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_SyntacticNullAnalysisForFields, this.enableSyntacticNullAnalysisForFields ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_InheritNullAnnotations, this.inheritNullAnnotations ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportNonnullParameterAnnotationDropped, getSeverityString(NonnullParameterAnnotationDropped));
+		optionsMap.put(OPTION_ReportUninternedIdentityComparison, this.complainOnUninternedIdentityComparison ? ENABLED : DISABLED);
 		return optionsMap;
 	}
 
@@ -1325,6 +1329,8 @@ public class CompilerOptions {
 		this.analyseResourceLeaks = true;
 
 		this.reportMissingEnumCaseDespiteDefault = false;
+
+		this.complainOnUninternedIdentityComparison = false;
 	}
 
 	public void set(Map optionsMap) {
@@ -1795,6 +1801,13 @@ public class CompilerOptions {
 					this.storeAnnotations = false;
 			}
 		}
+		if ((optionValue = optionsMap.get(OPTION_ReportUninternedIdentityComparison)) != null) {
+			if (ENABLED.equals(optionValue)) {
+				this.complainOnUninternedIdentityComparison = true;
+			} else if (DISABLED.equals(optionValue)) {
+				this.complainOnUninternedIdentityComparison = false;
+			}
+		}
 	}
 	public String toString() {
 		StringBuffer buf = new StringBuffer("CompilerOptions:"); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 8830e03..0b05b8a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -839,6 +839,12 @@ public void computeId() {
 					return;
 			}
 			break;
+		case 7 :
+			if (!CharOperation.equals(TypeConstants.JDT, this.compoundName[2]) || !CharOperation.equals(TypeConstants.TYPEBINDING, this.compoundName[6]))
+				return;
+			if (CharOperation.equals(TypeConstants.ORG_ECLIPSE_JDT_INTERNAL_COMPILER_LOOKUP_TYPEBINDING, this.compoundName))
+				this.typeBits |= TypeIds.BitUninternedType;
+			break;
 	}
 }
 
@@ -1095,8 +1101,6 @@ boolean hasNonNullDefault() {
 public final boolean hasRestrictedAccess() {
 	return (this.modifiers & ExtraCompilerModifiers.AccRestrictedAccess) != 0;
 }
-/** Answer an additional bit characterizing this type, like {@link TypeIds#BitAutoCloseable}. */
-abstract public boolean hasTypeBit(int bit);
 
 /** Answer true if the receiver implements anInterface or is identical to anInterface.
 * If searchHierarchy is true, then also search the receiver's superclasses.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index 65334f2..43e2935 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -1443,4 +1443,8 @@ public boolean isUnresolvedType() {
 	return false;
 }
 
+/** Answer an additional bit characterizing this type, like {@link TypeIds#BitAutoCloseable}. */
+public boolean hasTypeBit(int bit) {
+	return false;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index 55bb8bc..f7dfb23 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -107,7 +107,12 @@ public interface TypeConstants {
     char[] LANG3 = "lang3".toCharArray(); //$NON-NLS-1$
     char[] COM = "com".toCharArray(); //$NON-NLS-1$
     char[] GOOGLE = "google".toCharArray(); //$NON-NLS-1$
-
+    char[] JDT = "jdt".toCharArray(); //$NON-NLS-1$
+    char[] INTERNAL = "internal".toCharArray(); //$NON-NLS-1$
+    char[] COMPILER = "compiler".toCharArray(); //$NON-NLS-1$
+    char[] LOOKUP = "lookup".toCharArray(); //$NON-NLS-1$
+    char[] TYPEBINDING = "TypeBinding".toCharArray(); //$NON-NLS-1$
+    
 	// Constant compound names
 	char[][] JAVA_LANG = {JAVA, LANG};
 	char[][] JAVA_IO = {JAVA, IO};
@@ -288,6 +293,7 @@ public interface TypeConstants {
 	char[] VALIDATE_CLASS = "Validate".toCharArray(); //$NON-NLS-1$
 	char[][] ORG_APACHE_COMMONS_LANG_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG, VALIDATE_CLASS };
 	char[][] ORG_APACHE_COMMONS_LANG3_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG3, VALIDATE_CLASS };
+	char[][] ORG_ECLIPSE_JDT_INTERNAL_COMPILER_LOOKUP_TYPEBINDING = new char[][] { ORG, ECLIPSE, JDT, INTERNAL, COMPILER, LOOKUP, TYPEBINDING };
 	// ... methods:
 	char[] IS_TRUE = "isTrue".toCharArray(); //$NON-NLS-1$
 	char[] NOT_NULL = "notNull".toCharArray(); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
index 66b0dc3..cae2eb1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
@@ -243,8 +243,9 @@ public interface TypeIds {
 	 */
 	final int BitResourceFreeCloseable = 8;
 	
+	final int BitUninternedType = 16;
 	/**
 	 * Set of type bits that should be inherited by any sub types.
 	 */
-	final int InheritableBits = BitAutoCloseable | BitCloseable;
+	final int InheritableBits = BitAutoCloseable | BitCloseable | BitUninternedType;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index adf597b..24ad1af 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -9865,4 +9865,18 @@ public void disallowedTargetForContainerAnnotation(Annotation annotation, TypeBi
 		annotation.sourceStart,
 		annotation.sourceEnd);
 }
+public void uninternedIdentityComparison(EqualExpression expr, TypeBinding lhs, TypeBinding rhs) {
+	this.handle(
+			IProblem.UninternedIdentityComparison,
+			new String[] {
+					new String(lhs.readableName()),
+					new String(rhs.readableName())
+			},
+			new String[] {
+					new String(lhs.shortReadableName()),
+					new String(rhs.shortReadableName())
+			},
+			expr.sourceStart,
+			expr.sourceEnd);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index a643d33..af4eb8a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -423,6 +423,7 @@
 441 = 'enum' should not be used as an identifier, since it is a reserved keyword from source level 1.5 on
 442 = Enum constants cannot be surrounded by parenthesis
 443 = '_' should not be used as an identifier, since it is a reserved keyword from source level 1.8 on
+444 = The uninterned types {0} and {1} should not be compared using ==/!= operators.
 
 450 = {0}{1}
 
commit 70c32f642e3ae167f066dab591b4e71a779e4a20
Author: shankha banerjee <shankhba@in.ibm.com>
Date:   Sun Nov 10 17:07:09 2013 +0530

    Fixed Bug 417803 - [internal] Build a build environment compiler to
    warn on TypeBinding comparisons
    
    Signed-off-by: shankha banerjee <shankhba@in.ibm.com>

279	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
2	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
2	2	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
9	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
29	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
2	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
index afe429e..c7d2266 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ProgrammingProblemsTest.java
@@ -2422,4 +2422,283 @@ public void test0059() throws Exception {
 		true/*shouldFlushOutputDirectory*/,
 		customOptions);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417803,  [internal] Build a build environment compiler to warn on TypeBinding comparisons
+public void test0060() throws Exception {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportUninternedIdentityComparison, CompilerOptions.ENABLED);
+	this.runNegativeTest(
+		new String[] {
+			"org/eclipse/jdt/internal/compiler/lookup/X.java",
+			"package org.eclipse.jdt.internal.compiler.lookup;\n" +
+			"class TypeBinding {\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void gain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void vain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void cain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in org\\eclipse\\jdt\\internal\\compiler\\lookup\\X.java (at line 7)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"2. ERROR in org\\eclipse\\jdt\\internal\\compiler\\lookup\\X.java (at line 9)\n" + 
+		"	if (t1 == t2) {\n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"3. ERROR in org\\eclipse\\jdt\\internal\\compiler\\lookup\\X.java (at line 16)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"4. ERROR in org\\eclipse\\jdt\\internal\\compiler\\lookup\\X.java (at line 18)\n" + 
+		"	if (t1 == t2) {\n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"5. ERROR in org\\eclipse\\jdt\\internal\\compiler\\lookup\\X.java (at line 28)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417803,  [internal] Build a build environment compiler to warn on TypeBinding comparisons
+public void test0061() throws Exception {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportUninternedIdentityComparison, CompilerOptions.ENABLED);
+	this.runNegativeTest(
+		new String[] {
+			"org/eclipse/nonjdt/internal/compiler/lookup/X.java",
+			"package org.eclipse.nonjdt.internal.compiler.lookup;\n" +
+			"class TypeBinding {\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void gain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void vain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void cain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417803,  [internal] Build a build environment compiler to warn on TypeBinding comparisons
+public void test0062() throws Exception {
+	Map customOptions = getCompilerOptions();
+	this.runNegativeTest(
+		new String[] {
+			"org/eclipse/jdt/internal/compiler/lookup/X.java",
+			"package org.eclipse.jdt.internal.compiler.lookup;\n" +
+			"class TypeBinding {\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void gain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void vain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void cain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417803,  [internal] Build a build environment compiler to warn on TypeBinding comparisons
+public void test0063() throws Exception {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportUninternedIdentityComparison, CompilerOptions.ENABLED);
+	this.runNegativeTest(
+		new String[] {
+			"org/eclipse/jdt/core/dom/X.java",
+			"package org.eclipse.jdt.core.dom;\n" +
+			"interface ITypeBinding {\n" +
+			"}\n" +
+			"class TypeBinding implements ITypeBinding {\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void gain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) {\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void vain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		//$IDENTITY-COMPARISON$\n" +
+			"		if (t1 == t2) { \n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"	public static void cain(String[] args) {\n" +
+			"		TypeBinding t1 = null, t2 = null;\n" +
+			"		if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"			if (t2 == t1) {  //$IDENTITY-COMPARISON$\n" +
+			"				if (t1 == t2) { //$IDENTITY-COMPARISON$\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in org\\eclipse\\jdt\\core\\dom\\X.java (at line 9)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"2. ERROR in org\\eclipse\\jdt\\core\\dom\\X.java (at line 11)\n" + 
+		"	if (t1 == t2) {\n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"3. ERROR in org\\eclipse\\jdt\\core\\dom\\X.java (at line 18)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"4. ERROR in org\\eclipse\\jdt\\core\\dom\\X.java (at line 20)\n" + 
+		"	if (t1 == t2) {\n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n" + 
+		"5. ERROR in org\\eclipse\\jdt\\core\\dom\\X.java (at line 30)\n" + 
+		"	if (t1 == t2) { \n" + 
+		"	    ^^^^^^^^\n" + 
+		"The uninterned types TypeBinding and TypeBinding should not be compared using ==/!= operators.\n" + 
+		"----------\n",
+		null/*classLibraries*/,
+		true/*shouldFlushOutputDirectory*/,
+		customOptions);
+}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
index 99fc088..b8cbc0e 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionParser.java
@@ -4604,8 +4604,8 @@ public void initialize() {
 	this.labelPtr = -1;
 	initializeForBlockStatements();
 }
-public void initialize(boolean initializeNLS) {
-	super.initialize(initializeNLS);
+public void initialize(boolean parsingCompilationUnit) {
+	super.initialize(parsingCompilationUnit);
 	this.labelPtr = -1;
 	initializeForBlockStatements();
 }
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
index 5093451..1c2c24c 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/impl/AssistParser.java
@@ -1174,8 +1174,8 @@ public void initialize() {
 	this.previousIdentifierPtr = -1;
 	this.bracketDepth = 0;
 }
-public void initialize(boolean initializeNLS) {
-	super.initialize(initializeNLS);
+public void initialize(boolean parsingCompilationUnit) {
+	super.initialize(parsingCompilationUnit);
 	flushAssistState();
 	flushElementStack();
 	this.previousIdentifierPtr = -1;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
index 1306b97..9a08907 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
@@ -78,6 +78,8 @@ public class CompilationUnitDeclaration extends ASTNode implements ProblemSeveri
 	private int stringLiteralsPtr;
 	private HashSetOfInt stringLiteralsStart;
 
+	public boolean[] validIdentityComparisonLines;
+
 	IrritantSet[] suppressWarningIrritants;  // irritant for suppressed warnings
 	Annotation[] suppressWarningAnnotations;
 	long[] suppressWarningScopePositions; // (start << 32) + end
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index 480f406..c108ccf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -841,7 +841,7 @@ public class EqualExpression extends BinaryExpression {
 
 		final CompilerOptions compilerOptions = scope.compilerOptions();
 		if (compilerOptions.complainOnUninternedIdentityComparison && originalRightType.hasTypeBit(TypeIds.BitUninternedType) && originalLeftType.hasTypeBit(TypeIds.BitUninternedType))
-			scope.problemReporter().uninternedIdentityComparison(this, originalLeftType, originalRightType);
+			scope.problemReporter().uninternedIdentityComparison(this, originalLeftType, originalRightType, scope.referenceCompilationUnit());
 
 		// autoboxing support
 		boolean use15specifics = compilerOptions.sourceLevel >= ClassFileConstants.JDK1_5;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 0b05b8a..b417b84 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -839,6 +839,12 @@ public void computeId() {
 					return;
 			}
 			break;
+		case 6:
+			if (!CharOperation.equals(TypeConstants.JDT, this.compoundName[2]) || !CharOperation.equals(TypeConstants.ITYPEBINDING, this.compoundName[5]))
+				return;
+			if (CharOperation.equals(TypeConstants.ORG_ECLIPSE_JDT_CORE_DOM_ITYPEBINDING, this.compoundName))
+				this.typeBits |= TypeIds.BitUninternedType;
+			break;
 		case 7 :
 			if (!CharOperation.equals(TypeConstants.JDT, this.compoundName[2]) || !CharOperation.equals(TypeConstants.TYPEBINDING, this.compoundName[6]))
 				return;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index f7dfb23..fada286 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -112,6 +112,8 @@ public interface TypeConstants {
     char[] COMPILER = "compiler".toCharArray(); //$NON-NLS-1$
     char[] LOOKUP = "lookup".toCharArray(); //$NON-NLS-1$
     char[] TYPEBINDING = "TypeBinding".toCharArray(); //$NON-NLS-1$
+    char[] DOM = "dom".toCharArray(); //$NON-NLS-1$
+    char[] ITYPEBINDING = "ITypeBinding".toCharArray(); //$NON-NLS-1$
     
 	// Constant compound names
 	char[][] JAVA_LANG = {JAVA, LANG};
@@ -294,6 +296,8 @@ public interface TypeConstants {
 	char[][] ORG_APACHE_COMMONS_LANG_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG, VALIDATE_CLASS };
 	char[][] ORG_APACHE_COMMONS_LANG3_VALIDATE = new char[][] { ORG, APACHE, COMMONS, LANG3, VALIDATE_CLASS };
 	char[][] ORG_ECLIPSE_JDT_INTERNAL_COMPILER_LOOKUP_TYPEBINDING = new char[][] { ORG, ECLIPSE, JDT, INTERNAL, COMPILER, LOOKUP, TYPEBINDING };
+	char[][] ORG_ECLIPSE_JDT_CORE_DOM_ITYPEBINDING = new char[][] { ORG, ECLIPSE, JDT, CORE, DOM, ITYPEBINDING };
+
 	// ... methods:
 	char[] IS_TRUE = "isTrue".toCharArray(); //$NON-NLS-1$
 	char[] NOT_NULL = "notNull".toCharArray(); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index 19b3138..1161c79 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -10372,7 +10372,7 @@ protected void ignoreExpressionAssignment() {
 public void initialize() {
 	this.initialize(false);
 }
-public void initialize(boolean initializeNLS) {
+public void initialize(boolean parsingCompilationUnit) {
 	//positioning the parser for a new compilation unit
 	//avoiding stack reallocation and all that....
 	this.javadoc = null;
@@ -10419,7 +10419,8 @@ public void initialize(boolean initializeNLS) {
 	this.recordStringLiterals = true;
 	final boolean checkNLS = this.options.getSeverity(CompilerOptions.NonExternalizedString) != ProblemSeverities.Ignore;
 	this.checkExternalizeStrings = checkNLS;
-	this.scanner.checkNonExternalizedStringLiterals = initializeNLS && checkNLS;
+	this.scanner.checkNonExternalizedStringLiterals = parsingCompilationUnit && checkNLS;
+	this.scanner.checkUninternedIdentityComparison = parsingCompilationUnit && this.options.complainOnUninternedIdentityComparison;
 	this.scanner.lastPosition = -1;
 
 	resetModifiers();
@@ -10932,6 +10933,12 @@ try {
 	}
 
 	this.scanner.checkNonExternalizedStringLiterals = false;
+	
+	if (this.scanner.checkUninternedIdentityComparison) {
+		this.compilationUnit.validIdentityComparisonLines = this.scanner.getIdentityComparisonLines();
+		this.scanner.checkUninternedIdentityComparison = false;
+	}
+	
 	if (this.reportSyntaxErrorIsRequired && this.hasError && !this.statementRecoveryActivated) {
 		if(!this.options.performStatementsRecovery) {
 			reportSyntaxErrors(isDietParse, oldFirstToken);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
index 717a93a..9725ebd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
@@ -166,6 +166,12 @@ public class Scanner implements TerminalTokens {
 	public static final int TAG_PREFIX_LENGTH= TAG_PREFIX.length;
 	public static final char TAG_POSTFIX= '$';
 	public static final int TAG_POSTFIX_LENGTH= 1;
+
+	// support for complaining on uninterned type comparisons.
+	public static final char[] IDENTITY_COMPARISON_TAG = "//$IDENTITY-COMPARISON$".toCharArray(); //$NON-NLS-1$
+	public boolean [] validIdentityComparisonLines;
+	public boolean checkUninternedIdentityComparison;
+
 	private NLSTag[] nlsTags = null;
 	protected int nlsTagsPtr;
 	public boolean checkNonExternalizedStringLiterals;
@@ -1633,7 +1639,7 @@ protected int getNextToken0() throws InvalidInputException {
 								recordComment(TokenNameCOMMENT_LINE);
 								if (this.taskTags != null) checkTaskTag(this.startPosition, this.currentPosition);
 								if ((this.currentCharacter == '\r') || (this.currentCharacter == '\n')) {
-									if (this.checkNonExternalizedStringLiterals &&
+									if ((this.checkNonExternalizedStringLiterals || this.checkUninternedIdentityComparison) &&
 											this.lastPosition < this.currentPosition) {
 										parseTags();
 									}
@@ -1652,7 +1658,7 @@ protected int getNextToken0() throws InvalidInputException {
 								this.currentPosition--;
 								recordComment(TokenNameCOMMENT_LINE);
 								if (this.taskTags != null) checkTaskTag(this.startPosition, this.currentPosition);
-								if (this.checkNonExternalizedStringLiterals &&
+								if ((this.checkNonExternalizedStringLiterals || this.checkUninternedIdentityComparison) &&
 										this.lastPosition < this.currentPosition) {
 									parseTags();
 								}
@@ -1895,6 +1901,11 @@ public NLSTag[] getNLSTags() {
 	}
 	return null;
 }
+public boolean[] getIdentityComparisonLines() {
+	boolean [] retVal = this.validIdentityComparisonLines;
+	this.validIdentityComparisonLines = null;
+	return retVal;
+}
 public char[] getSource(){
 	return this.source;
 }
@@ -2094,7 +2105,7 @@ public final void jumpOverMethodBody() {
 								recordComment(TokenNameCOMMENT_LINE);
 								if (this.recordLineSeparator
 									&& ((this.currentCharacter == '\r') || (this.currentCharacter == '\n'))) {
-										if (this.checkNonExternalizedStringLiterals &&
+										if ((this.checkNonExternalizedStringLiterals || this.checkUninternedIdentityComparison) &&
 												this.lastPosition < this.currentPosition) {
 											parseTags();
 										}
@@ -2110,7 +2121,7 @@ public final void jumpOverMethodBody() {
 								 //an eof will then be generated
 								this.currentPosition--;
 								recordComment(TokenNameCOMMENT_LINE);
-								if (this.checkNonExternalizedStringLiterals &&
+								if ((this.checkNonExternalizedStringLiterals || this.checkUninternedIdentityComparison) &&
 										this.lastPosition < this.currentPosition) {
 									parseTags();
 								}
@@ -2555,8 +2566,9 @@ private void parseTags() {
 	} else {
 		s = this.source;
 	}
-	int pos = CharOperation.indexOf(TAG_PREFIX, s, true, sourceStart, sourceEnd);
-	if (pos != -1) {
+	int pos;
+	if (this.checkNonExternalizedStringLiterals &&
+			(pos = CharOperation.indexOf(TAG_PREFIX, s, true, sourceStart, sourceEnd)) != -1) {
 		if (this.nlsTags == null) {
 			this.nlsTags = new NLSTag[10];
 			this.nlsTagsPtr = 0;
@@ -2582,6 +2594,17 @@ private void parseTags() {
 			}
 			pos = CharOperation.indexOf(TAG_PREFIX, s, true, end, sourceEnd);
 		}
+	} 
+	
+	if (this.checkUninternedIdentityComparison &&
+			(pos = CharOperation.indexOf(IDENTITY_COMPARISON_TAG, s, true, sourceStart, sourceEnd)) != -1) {
+		if (this.validIdentityComparisonLines == null) {
+			this.validIdentityComparisonLines = new boolean[0];
+		}
+		int currentLine = currentLinePtr + 1;
+		int length = this.validIdentityComparisonLines.length;
+		System.arraycopy(this.validIdentityComparisonLines, 0, this.validIdentityComparisonLines = new boolean[currentLine + 1], 0, length);
+		this.validIdentityComparisonLines[currentLine] = true;
 	}
 }
 private int extractInt(char[] array, int start, int end) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 0f55e44..566a586 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -167,6 +167,7 @@ import org.eclipse.jdt.internal.compiler.parser.RecoveryScanner;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
 import org.eclipse.jdt.internal.compiler.util.Messages;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class ProblemReporter extends ProblemHandler {
 
@@ -9865,7 +9866,7 @@ public void disallowedTargetForContainerAnnotation(Annotation annotation, TypeBi
 		annotation.sourceStart,
 		annotation.sourceEnd);
 }
-public void uninternedIdentityComparison(EqualExpression expr, TypeBinding lhs, TypeBinding rhs) {
+public void uninternedIdentityComparison(EqualExpression expr, TypeBinding lhs, TypeBinding rhs, CompilationUnitDeclaration unit) {
 	
 	char [] lhsName = lhs.sourceName();
 	char [] rhsName = rhs.sourceName();
@@ -9880,6 +9881,17 @@ public void uninternedIdentityComparison(EqualExpression expr, TypeBinding lhs,
 			|| CharOperation.equals(rhsName, "ProblemReferenceBinding".toCharArray())) //$NON-NLS-1$
 		return;
 	
+	boolean[] validIdentityComparisonLines = unit.validIdentityComparisonLines;
+	if (validIdentityComparisonLines != null) {
+		int problemStartPosition = expr.left.sourceStart;
+		int[] lineEnds;
+		int lineNumber = problemStartPosition >= 0
+				? Util.getLineNumber(problemStartPosition, lineEnds = unit.compilationResult().getLineSeparatorPositions(), 0, lineEnds.length-1)
+						: 0;
+		if (lineNumber <= validIdentityComparisonLines.length && validIdentityComparisonLines[lineNumber - 1])
+			return;
+	}
+	
 	this.handle(
 			IProblem.UninternedIdentityComparison,
 			new String[] {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
index 8f3016a..7f83fff 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/DocumentElementParser.java
@@ -1282,10 +1282,10 @@ public CompilationUnitDeclaration endParse(int act) {
 	}
 	return super.endParse(act);
 }
-public void initialize(boolean initializeNLS) {
+public void initialize(boolean parsingCompilationUnit) {
 	//positionning the parser for a new compilation unit
 	//avoiding stack reallocation and all that....
-	super.initialize(initializeNLS);
+	super.initialize(parsingCompilationUnit);
 	this.intArrayPtr = -1;
 }
 public void initialize() {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
index f789b58..3f27fc8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/CommentRecorderParser.java
@@ -203,8 +203,8 @@ public class CommentRecorderParser extends Parser {
 	/* (non-Javadoc)
 	 * @see org.eclipse.jdt.internal.compiler.parser.Parser#initialize()
 	 */
-	public void initialize(boolean initializeNLS) {
-		super.initialize(initializeNLS);
+	public void initialize(boolean parsingCompilationUnit) {
+		super.initialize(parsingCompilationUnit);
 		this.commentPtr = -1;
 	}
 	/* (non-Javadoc)
