commit 158f15ed7305b84f608a44b2b3e60c3a50fa4c1b
Author: Stephan Herrmann <stephan.herrmann@berlin.de>
Date:   Sun Nov 15 12:32:07 2015 +0100

    Bug 481332 - [null] Inconsistent error reporting for annotated leaf type
    in generic method
    
    Change-Id: Ifb459f27fd3a2a2c9c2f8a530cebd938803e5831

157	14	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
121	43	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
2	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
3	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
12	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionTypeBinding18.java
14	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
15	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
7	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
8	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
19	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
63	28	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
19	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index a0069d6..588d8ee 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -3034,6 +3034,31 @@ public class NullTypeAnnotationTest extends AbstractNullAnnotationTest {
 			"----------\n");
 	}
 
+	// overriding an unconstrained return with nullable
+	public void testNullableReturn() {
+		runConformTestWithLibs(
+			new String[] {
+				"X.java",
+				"\n" + 
+				"import org.eclipse.jdt.annotation.*;\n" + 
+				"\n" + 
+				"public abstract class X {\n" + 
+				"	X foo1() {\n" + 
+				"		return null;\n" + 
+				"	}\n" + 
+				"}\n" + 
+				"\n" + 
+				"abstract class Z extends X {\n" + 
+				"	@Override\n" +
+				"	@Nullable X foo1() {\n" +
+				"		return null;\n" + 
+				"	}\n" + 
+				"}\n"
+			},
+			getCompilerOptions(),
+			"");
+	}
+
 	public void testBug416175() {
 		runNegativeTestWithLibs(
 			new String[] {
@@ -6080,6 +6105,22 @@ public void testTypeVariable19a() {
 		"Potential null pointer access: The method get2() may return null\n" + 
 		"----------\n");
 }
+public void testTypeVariable20() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.Nullable;\n" +
+			"interface I<@Nullable T> { }\n" +
+			"public class X implements I<String> {}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	public class X implements I<String> {}\n" + 
+		"	                            ^^^^^^\n" + 
+		"Null constraint mismatch: The type \'String\' is not a valid substitute for the type parameter \'@Nullable T\'\n" + 
+		"----------\n");
+}
 public void testBug434600() {
 	runConformTestWithLibs(
 		new String[] {
@@ -6154,28 +6195,33 @@ public void testBug434600b() {
 			"I.java",
 			"import java.util.*;\n" +
 			"import org.eclipse.jdt.annotation.*;\n" +
-			"interface I<S, T extends @Nullable List<@NonNull List<S>>> {\n" +
+			"interface I<S, T extends @NonNull List<@NonNull List<S>>> {\n" +
 			"}\n",
 			"C.java",
 			"import java.util.*;\n" +
 			"import org.eclipse.jdt.annotation.*;\n" +
 			"public class C implements I<@Nullable String, ArrayList<@NonNull List<@Nullable String>>> {}\n" +
 			"class C1 {\n" +
-			"	I<String, @Nullable ArrayList<@Nullable List<String>>> field;\n" +
+			"	I<String, @NonNull ArrayList<@Nullable List<String>>> field;\n" +
 			"}\n" +
-			"class C2 implements I<@NonNull String, @Nullable ArrayList<@NonNull List<@Nullable String>>> {}\n" // FIXME: cross checking for contradictory substitution for 'S' NYI
+			"class C2 implements I<@NonNull String, @NonNull ArrayList<@NonNull List<@Nullable String>>> {}\n"
 		},
 		getCompilerOptions(),
 		"----------\n" + 
 		"1. ERROR in C.java (at line 3)\n" + 
 		"	public class C implements I<@Nullable String, ArrayList<@NonNull List<@Nullable String>>> {}\n" + 
 		"	                                              ^^^^^^^^^\n" + 
-		"Null constraint mismatch: The type \'ArrayList<@NonNull List<@Nullable String>>\' is not a valid substitute for the type parameter \'T extends @Nullable List<@NonNull List<S>>\'\n" + 
+		"Null constraint mismatch: The type \'ArrayList<@NonNull List<@Nullable String>>\' is not a valid substitute for the type parameter \'T extends @NonNull List<@NonNull List<S>>\'\n" + 
 		"----------\n" + 
 		"2. ERROR in C.java (at line 5)\n" + 
-		"	I<String, @Nullable ArrayList<@Nullable List<String>>> field;\n" + 
-		"	          ^^^^^^^^^^^^^^^^^^^\n" + 
-		"Null constraint mismatch: The type \'@Nullable ArrayList<@Nullable List<String>>\' is not a valid substitute for the type parameter \'T extends @Nullable List<@NonNull List<S>>\'\n" + 
+		"	I<String, @NonNull ArrayList<@Nullable List<String>>> field;\n" + 
+		"	          ^^^^^^^^^^^^^^^^^^\n" + 
+		"Null constraint mismatch: The type \'@NonNull ArrayList<@Nullable List<String>>\' is not a valid substitute for the type parameter \'T extends @NonNull List<@NonNull List<S>>\'\n" + 
+		"----------\n" + 
+		"3. ERROR in C.java (at line 7)\n" + 
+		"	class C2 implements I<@NonNull String, @NonNull ArrayList<@NonNull List<@Nullable String>>> {}\n" + 
+		"	                                       ^^^^^^^^^^^^^^^^^^\n" + 
+		"Null constraint mismatch: The type \'@NonNull ArrayList<@NonNull List<@Nullable String>>\' is not a valid substitute for the type parameter \'T extends @NonNull List<@NonNull List<S>>\'\n" + 
 		"----------\n");
 }
 public void testBug434600b_qualified() {
@@ -6194,19 +6240,19 @@ public void testBug434600b_qualified() {
 			"class C1 {\n" +
 			"	p.I<String, @Nullable ArrayList<@Nullable List<String>>> field;\n" +
 			"}\n" +
-			"class C2 implements p.I<@NonNull String, @Nullable ArrayList<@NonNull List<@Nullable String>>> {}\n" // FIXME: cross checking for contradictory substitution for 'S' NYI
+			"class C2 implements p.I<@NonNull String, @Nullable ArrayList<@NonNull List<@Nullable String>>> {}\n"
 		},
 		getCompilerOptions(),
 		"----------\n" + 
-		"1. ERROR in C.java (at line 3)\n" + 
-		"	public class C implements p.I<@Nullable String, ArrayList<@NonNull List<@Nullable String>>> {}\n" + 
-		"	                                                ^^^^^^^^^\n" + 
-		"Null constraint mismatch: The type \'ArrayList<@NonNull List<@Nullable String>>\' is not a valid substitute for the type parameter \'T extends @Nullable List<@NonNull List<S>>\'\n" + 
-		"----------\n" + 
-		"2. ERROR in C.java (at line 5)\n" + 
+		"1. ERROR in C.java (at line 5)\n" + 
 		"	p.I<String, @Nullable ArrayList<@Nullable List<String>>> field;\n" + 
 		"	            ^^^^^^^^^^^^^^^^^^^\n" + 
 		"Null constraint mismatch: The type \'@Nullable ArrayList<@Nullable List<String>>\' is not a valid substitute for the type parameter \'T extends @Nullable List<@NonNull List<S>>\'\n" + 
+		"----------\n" + 
+		"2. ERROR in C.java (at line 7)\n" + 
+		"	class C2 implements p.I<@NonNull String, @Nullable ArrayList<@NonNull List<@Nullable String>>> {}\n" + 
+		"	                                         ^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null constraint mismatch: The type \'@Nullable ArrayList<@NonNull List<@Nullable String>>\' is not a valid substitute for the type parameter \'T extends @Nullable List<@NonNull List<S>>\'\n" + 
 		"----------\n");
 }
 public void testBug435399() {
@@ -8503,4 +8549,101 @@ public void testBug440398_comment2a() {
 		getCompilerOptions(),
 		"");
 }
+public void testBug481332() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import java.util.*;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"	public void foo() {\n" + 
+			"		@Nullable\n" + 
+			"		List<@NonNull String> list = new ArrayList<>();\n" + 
+			"		checkNotNull(list); // OK\n" + 
+			"\n" + 
+			"		@Nullable\n" + 
+			"		Map<@NonNull String, @NonNull String> map = new HashMap<>();\n" + 
+			"		checkNotNull(map); // OK\n" + 
+			"\n" + 
+			"		@NonNull\n" + 
+			"		Object @Nullable [] objects = null;\n" + 
+			"		// Error: Null type mismatch (type annotations): required '@NonNull Object @NonNull[]' but this expression ...\n" + 
+			"		checkNotNull(objects);\n" + 
+			"	}\n" + 
+			"	\n" + 
+			"	public static <@Nullable T> T[] checkNotNull(T @Nullable [] array) {\n" + 
+			"		if (array == null) {\n" + 
+			"			throw new NullPointerException();\n" + 
+			"		}\n" + 
+			"		return array;\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	public static <@Nullable T, C extends Iterable<T>> C checkNotNull(@Nullable C container) {\n" + 
+			"		if (container == null) {\n" + 
+			"			throw new NullPointerException();\n" + 
+			"		}\n" + 
+			"		return container;\n" + 
+			"	}\n" + 
+			"\n" + 
+			"	public static <@Nullable K, @Nullable V, M extends Map<K, V>> M checkNotNull(@Nullable M map) {\n" + 
+			"		if (map == null) {\n" + 
+			"			throw new NullPointerException();\n" + 
+			"		}\n" + 
+			"		return map;\n" + 
+			"	}\n" +
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	checkNotNull(list); // OK\n" + 
+		"	^^^^^^^^^^^^^^^^^^\n" + 
+		"Null constraint mismatch: The type \'List<@NonNull String>\' is not a valid substitute for the type parameter \'C extends Iterable<@Nullable T>\'\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 11)\n" + 
+		"	checkNotNull(map); // OK\n" + 
+		"	^^^^^^^^^^^^^^^^^\n" + 
+		"Null constraint mismatch: The type \'Map<@NonNull String,@NonNull String>\' is not a valid substitute for the type parameter \'M extends Map<@Nullable K,@Nullable V>\'\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 16)\n" + 
+		"	checkNotNull(objects);\n" + 
+		"	             ^^^^^^^\n" + 
+		"Null type mismatch (type annotations): required \'@Nullable Object @Nullable[]\' but this expression has type \'@NonNull Object @Nullable[]\'\n" + 
+		"----------\n");
+}
+public void testBug481322a() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import java.util.ArrayList;\n" + 
+			"import java.util.List;\n" + 
+			"\n" + 
+			"import org.eclipse.jdt.annotation.NonNull;\n" + 
+			"import org.eclipse.jdt.annotation.Nullable;\n" + 
+			"\n" + 
+			"class Super<S, T extends List<S>> {\n" + 
+			"	S pick(T list) {\n" + 
+			"		return list.get(0);\n" + 
+			"	}\n" + 
+			"}\n" + 
+			"public class X extends Super<@NonNull String, List<@Nullable String>> {\n" + 
+			"	@Override\n" + 
+			"	public @NonNull String pick(List<@Nullable String> list) {\n" + 
+			"		return super.pick(list);\n" + 
+			"	}\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		List<@Nullable String> withNulls = new ArrayList<@Nullable String>();\n" + 
+			"		withNulls.add(null);\n" + 
+			"		System.out.println(new X().pick(withNulls).toUpperCase());\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		getCompilerOptions(),
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	public class X extends Super<@NonNull String, List<@Nullable String>> {\n" + 
+		"	                                              ^^^^\n" + 
+		"Null constraint mismatch: The type \'List<@Nullable String>\' is not a valid substitute for the type parameter \'T extends List<S>\'\n" + 
+		"----------\n");
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 1100add..85dfc19 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -501,7 +501,7 @@ public TypeBinding resolveType(BlockScope scope) {
 			if (this.binding instanceof ParameterizedGenericMethodBinding && this.typeArguments != null) {
 				TypeVariableBinding[] typeVariables = this.binding.original().typeVariables();
 				for (int i = 0; i < this.typeArguments.length; i++)
-					this.typeArguments[i].checkNullConstraints(scope, typeVariables, i);
+					this.typeArguments[i].checkNullConstraints(scope, (ParameterizedGenericMethodBinding) this.binding, typeVariables, i);
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 4814553..d5a6b9c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -788,7 +788,7 @@ public TypeBinding resolveType(BlockScope scope) {
 			if (this.binding instanceof ParameterizedGenericMethodBinding && this.typeArguments != null) {
 				TypeVariableBinding[] typeVariables = this.binding.original().typeVariables();
 				for (int i = 0; i < this.typeArguments.length; i++)
-					this.typeArguments[i].checkNullConstraints(scope, typeVariables, i);
+					this.typeArguments[i].checkNullConstraints(scope, (ParameterizedGenericMethodBinding) this.binding, typeVariables, i);
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
index 8f590f7..1d5bdd8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/NullAnnotationMatching.java
@@ -27,6 +27,7 @@ import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
 import org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.Substitution;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor;
@@ -50,10 +51,26 @@ public class NullAnnotationMatching {
 	public enum CheckMode {
 		/** in this mode we check normal assignment compatibility. */
 		COMPATIBLE,
-		/** in this mode we do not tolerate incompatibly missing annotations on type parameters (for overriding analysis) */
-		OVERRIDE,
+		/** in this mode we check similar to isTypeArgumentContained. */
+		EXACT,
 		/** in this mode we check compatibility of a type argument against the corresponding type parameter. */
-		BOUND_CHECK
+		BOUND_CHECK,
+		/** allow covariant return types, but no other deviations. */
+		OVERRIDE_RETURN {
+			@Override CheckMode toDetail() {
+				return OVERRIDE;
+			}			
+		},
+		/** in this mode we do not tolerate incompatibly missing annotations on type parameters (for overriding analysis) */
+		OVERRIDE {
+			@Override CheckMode toDetail() {
+				return OVERRIDE;
+			}
+		};
+		
+		CheckMode toDetail() {
+			return CheckMode.EXACT;
+		}
 	}
 
 	/** 0 = OK, 1 = unchecked, 2 = definite mismatch */
@@ -126,7 +143,7 @@ public class NullAnnotationMatching {
 	 * @return a status object representing the severity of mismatching plus optionally a supertype hint
 	 */
 	public static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {
-		return analyse(requiredType, providedType, null, nullStatus, CheckMode.COMPATIBLE);
+		return analyse(requiredType, providedType, null, null, nullStatus, CheckMode.COMPATIBLE);
 	}
 	/**
 	 * Find any mismatches between the two given types, which are caused by null type annotations.
@@ -134,11 +151,12 @@ public class NullAnnotationMatching {
 	 * @param providedType
 	 * @param providedSubstitute in inheritance situations this maps the providedType into the realm of the subclass, needed for TVB identity checks.
 	 * 		Pass null if not interested in these added checks.
+	 * @param substitution TODO
 	 * @param nullStatus we are only interested in NULL or NON_NULL, -1 indicates that we are in a recursion, where flow info is ignored
 	 * @param mode controls the kind of check performed (see {@link CheckMode}).
 	 * @return a status object representing the severity of mismatching plus optionally a supertype hint
 	 */
-	public static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, int nullStatus, CheckMode mode) {
+	public static NullAnnotationMatching analyse(TypeBinding requiredType, TypeBinding providedType, TypeBinding providedSubstitute, Substitution substitution, int nullStatus, CheckMode mode) {
 		if (!requiredType.enterRecursiveFunction())
 			return NullAnnotationMatching.NULL_ANNOTATIONS_OK;
 		try {
@@ -150,23 +168,32 @@ public class NullAnnotationMatching {
 					return NullAnnotationMatching.NULL_ANNOTATIONS_OK_NONNULL;
 				return okStatus;
 			}
+			if (requiredType instanceof TypeVariableBinding && substitution != null && (mode == CheckMode.EXACT || mode == CheckMode.COMPATIBLE)) {
+				requiredType.exitRecursiveFunction();
+				requiredType = Scope.substitute(substitution, requiredType);
+				if (!requiredType.enterRecursiveFunction())
+					return NullAnnotationMatching.NULL_ANNOTATIONS_OK;
+			}
 			if (mode == CheckMode.BOUND_CHECK && requiredType instanceof TypeVariableBinding) {
-				// during bound check against a type variable check the provided type against all upper bounds:
-				TypeBinding superClass = requiredType.superclass();
-				if (superClass != null && superClass.hasNullTypeAnnotations()) {
-					NullAnnotationMatching status = analyse(superClass, providedType, null, nullStatus, mode);
-					severity = Math.max(severity, status.severity);
-					if (severity == 2)
-						return new NullAnnotationMatching(severity, nullStatus, superTypeHint);
-				}
-				TypeBinding[] superInterfaces = requiredType.superInterfaces();
-				if (superInterfaces != null) {
-					for (int i = 0; i < superInterfaces.length; i++) {
-						if (superInterfaces[i].hasNullTypeAnnotations()) {
-							NullAnnotationMatching status = analyse(superInterfaces[i], providedType, null, nullStatus, mode);
-							severity = Math.max(severity, status.severity);
-							if (severity == 2)
-								return new NullAnnotationMatching(severity, nullStatus, superTypeHint);						
+				boolean passedBoundCheck = (substitution instanceof ParameterizedTypeBinding) && (((ParameterizedTypeBinding) substitution).tagBits & TagBits.PassedBoundCheck) != 0;
+				if (!passedBoundCheck) {
+					// during bound check against a type variable check the provided type against all upper bounds:
+					TypeBinding superClass = requiredType.superclass();
+					if (superClass != null && (superClass.hasNullTypeAnnotations() || substitution != null)) { // annotations may enter when substituting a nested type variable
+						NullAnnotationMatching status = analyse(superClass, providedType, null, substitution, nullStatus, CheckMode.COMPATIBLE);
+						severity = Math.max(severity, status.severity);
+						if (severity == 2)
+							return new NullAnnotationMatching(severity, nullStatus, superTypeHint);
+					}
+					TypeBinding[] superInterfaces = requiredType.superInterfaces();
+					if (superInterfaces != null) {
+						for (int i = 0; i < superInterfaces.length; i++) {
+							if (superInterfaces[i].hasNullTypeAnnotations() || substitution != null) { // annotations may enter when substituting a nested type variable
+								NullAnnotationMatching status = analyse(superInterfaces[i], providedType, null, substitution, nullStatus, CheckMode.COMPATIBLE);
+								severity = Math.max(severity, status.severity);
+								if (severity == 2)
+									return new NullAnnotationMatching(severity, nullStatus, superTypeHint);
+							}
 						}
 					}
 				}
@@ -185,7 +212,7 @@ public class NullAnnotationMatching {
 							long providedBits = validNullTagBits(providedDimsTagBits[i]);
 							if (i > 0)
 								currentNullStatus = -1; // don't use beyond the outermost dimension
-							severity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, currentNullStatus, mode == CheckMode.OVERRIDE && nullStatus == -1));
+							severity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, currentNullStatus, i == 0 ? mode : mode.toDetail(), false));
 							if (severity == 2)
 								return NullAnnotationMatching.NULL_ANNOTATIONS_MISMATCH;
 							if (severity == 0)
@@ -202,7 +229,7 @@ public class NullAnnotationMatching {
 						|| nullStatus == -1) // only at detail/recursion even nullable must be matched exactly
 				{
 					long providedBits = providedNullTagBits(providedType);
-					int s = computeNullProblemSeverity(requiredBits, providedBits, nullStatus, mode == CheckMode.OVERRIDE && nullStatus == -1);
+					int s = computeNullProblemSeverity(requiredBits, providedBits, nullStatus, mode, requiredType.isTypeVariable());
 					severity = Math.max(severity, s);
 					if (severity == 0 && (providedBits & TagBits.AnnotationNonNull) != 0)
 						okStatus = NullAnnotationMatching.NULL_ANNOTATIONS_OK_NONNULL;
@@ -219,7 +246,7 @@ public class NullAnnotationMatching {
 						if (requiredArguments != null && providedArguments != null && requiredArguments.length == providedArguments.length) {
 							for (int i = 0; i < requiredArguments.length; i++) {
 								TypeBinding providedArgSubstitute = providedSubstitutes != null ? providedSubstitutes[i] : null;
-								NullAnnotationMatching status = analyse(requiredArguments[i], providedArguments[i], providedArgSubstitute, -1, mode);
+								NullAnnotationMatching status = analyse(requiredArguments[i], providedArguments[i], providedArgSubstitute, substitution, -1, mode.toDetail());
 								severity = Math.max(severity, status.severity);
 								if (severity == 2)
 									return new NullAnnotationMatching(severity, nullStatus, superTypeHint);
@@ -230,7 +257,7 @@ public class NullAnnotationMatching {
 					TypeBinding providedEnclosing = providedType.enclosingType();
 					if (requiredEnclosing != null && providedEnclosing != null) {
 						TypeBinding providedEnclSubstitute = providedSubstitute != null ? providedSubstitute.enclosingType() : null;
-						NullAnnotationMatching status = analyse(requiredEnclosing, providedEnclosing, providedEnclSubstitute, -1, mode);
+						NullAnnotationMatching status = analyse(requiredEnclosing, providedEnclosing, providedEnclSubstitute, substitution, -1, mode);
 						severity = Math.max(severity, status.severity);
 					}
 				}
@@ -307,8 +334,13 @@ public class NullAnnotationMatching {
 						return TagBits.AnnotationNullable; // type cannot require @NonNull
 				}
 			}
-			if (mode != CheckMode.BOUND_CHECK) // no pessimistic checks during boundcheck (we *have* the instantiation)
-				return TagBits.AnnotationNonNull; // instantiation could require @NonNull
+			switch (mode) {
+				case BOUND_CHECK: // no pessimistic checks during boundcheck (we *have* the instantiation)
+				case OVERRIDE_RETURN: // allow covariance
+					break;
+				default:
+					return TagBits.AnnotationNonNull; // instantiation could require @NonNull
+			}
 		}
 
 		return 0;
@@ -398,27 +430,60 @@ public class NullAnnotationMatching {
 	 * @param requiredBits null tagBits of the required type
 	 * @param providedBits null tagBits of the provided type
 	 * @param nullStatus -1 means: don't use, other values see constants in FlowInfo
-	 * @param overrideDetailChecking true enables strictest mode during override analysis when checking type details (type argument, array content)
+	 * @param mode check mode (see {@link CheckMode})
+	 * @param requiredIsTypeVariable is the required type a type variable (possibly: "free type variable")?
 	 * @return see {@link #severity} for interpretation of values
 	 */
-	private static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus, boolean overrideDetailChecking) {
-		// nullStatus: 
-		// overrideDetailChecking: 
-		if ((requiredBits != 0 || overrideDetailChecking) && requiredBits != providedBits) {
-			if (requiredBits == TagBits.AnnotationNonNull && nullStatus == FlowInfo.NON_NULL) {
-				return 0; // OK by flow analysis
+	private static int computeNullProblemSeverity(long requiredBits, long providedBits, int nullStatus, CheckMode mode, boolean requiredIsTypeVariable) {
+		if (requiredBits == providedBits)
+			return 0;
+		if (requiredBits == 0) { 
+			switch (mode) {
+				case COMPATIBLE:
+				case BOUND_CHECK:
+				case EXACT:
+					return 0;
+				case OVERRIDE_RETURN:
+					if (providedBits == TagBits.AnnotationNonNull)
+						return 0; // covariant redefinition to nonnull is good
+					if (!requiredIsTypeVariable)
+						return 0; // refining an unconstrained non-TVB return to nullable is also legal
+					return 1;
+				case OVERRIDE:
+					return 1; // warn about dropped annotation
 			}
-			if (requiredBits == TagBits.AnnotationNullMASK)
-				return 0; // OK since LHS accepts either
-			if (nullStatus != -1 && !overrideDetailChecking && requiredBits == TagBits.AnnotationNullable)
-				return 0; // when using flow info, everything is compatible to nullable
-			if (providedBits != 0) {
-				return 2; // mismatching annotations
-			} else {
-				return 1; // need unchecked conversion regarding type detail
+		} else if (requiredBits == TagBits.AnnotationNullMASK) {
+			return 0; // OK since LHS accepts either
+		} else if (requiredBits == TagBits.AnnotationNonNull) {
+			switch (mode) {
+				case COMPATIBLE:
+					if (nullStatus == FlowInfo.NON_NULL)
+						return 0; // OK by flow analysis
+					//$FALL-THROUGH$
+				case BOUND_CHECK:
+				case EXACT:
+				case OVERRIDE_RETURN:
+				case OVERRIDE:
+					if (providedBits == 0)
+						return 1;
+					return 2;
+			}
+			
+		} else if (requiredBits == TagBits.AnnotationNullable) {
+			switch (mode) {
+				case COMPATIBLE:
+				case OVERRIDE_RETURN:
+					return 0; // in these modes everything is compatible to nullable
+				case BOUND_CHECK:
+				case EXACT:
+					if (providedBits == 0)
+						return 1;
+					return 2;
+				case OVERRIDE:
+					return 2;
 			}
 		}
-		return 0; // OK by tagBits
+		return 0; // shouldn't get here, requiredBits should be one of the listed cases
 	}
 
 	static class SearchContradictions extends TypeBindingVisitor {
@@ -565,4 +630,17 @@ public class NullAnnotationMatching {
 		}
 		return mainType;
 	}
+
+	@SuppressWarnings("nls")
+	@Override
+	public String toString() {
+		if (this == NULL_ANNOTATIONS_OK) return "OK";
+		if (this == NULL_ANNOTATIONS_MISMATCH) return "MISMATCH";
+		if (this == NULL_ANNOTATIONS_OK_NONNULL) return "OK NonNull";
+		if (this == NULL_ANNOTATIONS_UNCHECKED) return "UNCHECKED";
+		StringBuilder buf = new StringBuilder();
+		buf.append("Analysis result: severity="+this.severity);
+		buf.append(" nullStatus="+this.nullStatus);
+		return buf.toString();
+	} 
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index f9531bd..0b6752c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -85,7 +85,6 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 				parameterizedType.boundCheck(scope, this.typeArguments[index]);
 			}
 		}
-		checkNullConstraints(scope, this.typeArguments[index]);
 	}
 	public TypeReference augmentTypeWithAdditionalDimensions(int additionalDimensions, Annotation[][] additionalAnnotations, boolean isVarargs) {
 		int totalDimensions = this.dimensions() + additionalDimensions;
@@ -198,9 +197,9 @@ public class ParameterizedQualifiedTypeReference extends ArrayQualifiedTypeRefer
 		TypeBinding type = internalResolveLeafType(scope, checkBounds);
 		createArrayType(scope);
 		resolveAnnotations(scope, location);
-		if (this.typeArguments != null && checkBounds)
+		if (this.typeArguments != null)
 			// relevant null annotations are on the inner most type:
-			checkNullConstraints(scope, this.typeArguments[this.typeArguments.length-1]); 
+			checkIllegalNullAnnotations(scope, this.typeArguments[this.typeArguments.length-1]);
 		return type == null ? type : this.resolvedType;
 	}
 	private TypeBinding internalResolveLeafType(Scope scope, boolean checkBounds) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
index 9d42096..8b13a2f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedSingleTypeReference.java
@@ -61,14 +61,11 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 
 		if (this.resolvedType.leafComponentType() instanceof ParameterizedTypeBinding) {
 			ParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding) this.resolvedType.leafComponentType();
-			ReferenceBinding currentType = parameterizedType.genericType();
-			TypeVariableBinding[] typeVariables = currentType.typeVariables();
 			TypeBinding[] argTypes = parameterizedType.arguments;
-			if (argTypes != null && typeVariables != null) { // may be null in error cases
+			if (argTypes != null) { // may be null in error cases
 				parameterizedType.boundCheck(scope, this.typeArguments);
 			}
 		}
-		checkNullConstraints(scope, this.typeArguments);
 	}
 	
 	public TypeReference augmentTypeWithAdditionalDimensions(int additionalDimensions, Annotation [][] additionalAnnotations, boolean isVarargs) {
@@ -171,21 +168,15 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 		if (type == null) {
 			this.resolvedType = createArrayType(scope, this.resolvedType);
 			resolveAnnotations(scope, 0); // no defaultNullness for buggy type
-			if (checkBounds)
-				checkNullConstraints(scope, this.typeArguments);
 			return null;							// (1) no useful type, but still captured dimensions into this.resolvedType
 		} else {
 			type = createArrayType(scope, type);
 			if (!this.resolvedType.isValidBinding() && this.resolvedType.dimensions() == type.dimensions()) {
 				resolveAnnotations(scope, 0); // no defaultNullness for buggy type
-				if (checkBounds)
-					checkNullConstraints(scope, this.typeArguments);
 				return type;						// (2) found some error, but could recover useful type (like closestMatch)
 			} else {
 				this.resolvedType = type; 			// (3) no complaint, keep fully resolved type (incl. dimensions)
 				resolveAnnotations(scope, location);
-				if (checkBounds)
-					checkNullConstraints(scope, this.typeArguments);
 				return this.resolvedType; // pick up any annotated type.
 			}
 		}
@@ -321,6 +312,8 @@ public class ParameterizedSingleTypeReference extends ArrayTypeReference {
 		if (isTypeUseDeprecated(parameterizedType, scope))
 			reportDeprecatedType(parameterizedType, scope);
 
+		checkIllegalNullAnnotations(scope, this.typeArguments);
+
 		if (!this.resolvedType.isValidBinding()) {
 			return parameterizedType;
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 5e0b024..4bca0f1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -296,7 +296,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 					if (this.binding instanceof ParameterizedGenericMethodBinding && this.typeArguments != null) {
 						TypeVariableBinding[] typeVariables = this.binding.original().typeVariables();
 						for (int i = 0; i < this.typeArguments.length; i++)
-							this.typeArguments[i].checkNullConstraints(scope, typeVariables, i);
+							this.typeArguments[i].checkNullConstraints(scope, (ParameterizedGenericMethodBinding) this.binding, typeVariables, i);
 					}
 				}
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
index 606bba7..ce7b8fa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
@@ -53,10 +53,10 @@ import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.Substitution;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
-import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 @SuppressWarnings({"rawtypes", "unchecked"})
 public abstract class TypeReference extends Expression {
@@ -669,31 +669,30 @@ protected void resolveAnnotations(Scope scope, int location) {
 public int getAnnotatableLevels() {
 	return 1;
 }
-/** Check all typeArguments against null constraints on their corresponding type variables. */
-protected void checkNullConstraints(Scope scope, TypeReference[] typeArguments) {
-	if (scope.environment().usesNullTypeAnnotations()
-			&& typeArguments != null)
-	{
-		TypeVariableBinding[] typeVariables = this.resolvedType.original().typeVariables();
+/** Check all typeArguments for illegal null annotations on base types. */
+protected void checkIllegalNullAnnotations(Scope scope, TypeReference[] typeArguments) {
+	if (scope.environment().usesNullTypeAnnotations() && typeArguments != null) {
 		for (int i = 0; i < typeArguments.length; i++) {
 			TypeReference arg = typeArguments[i];
 			if (arg.resolvedType != null)
-				arg.checkNullConstraints(scope, typeVariables, i);
+				arg.checkIllegalNullAnnotation(scope);
 		}
 	}
 }
 /** Check whether this type reference conforms to the null constraints defined for the corresponding type variable. */
-protected void checkNullConstraints(Scope scope, TypeBinding[] variables, int rank) {
+protected void checkNullConstraints(Scope scope, Substitution substitution, TypeBinding[] variables, int rank) {
 	if (variables != null && variables.length > rank) {
 		TypeBinding variable = variables[rank];
 		if (variable.hasNullTypeAnnotations()) {
-			if (NullAnnotationMatching.analyse(variable, this.resolvedType, null, -1, CheckMode.BOUND_CHECK).isAnyMismatch())
+			if (NullAnnotationMatching.analyse(variable, this.resolvedType, null, substitution, -1, CheckMode.BOUND_CHECK).isAnyMismatch())
 				scope.problemReporter().nullityMismatchTypeArgument(variable, this.resolvedType, this);
     	}
 	}
-	if (this.resolvedType.leafComponentType().isBaseType() && hasNullTypeAnnotation(AnnotationPosition.LEAF_TYPE)) {
-		scope.problemReporter().illegalAnnotationForBaseType(this, this.annotations[0], this.resolvedType.tagBits & TagBits.AnnotationNullMASK);
-	}
+	checkIllegalNullAnnotation(scope);
+}
+protected void checkIllegalNullAnnotation(Scope scope) {
+	if (this.resolvedType.leafComponentType().isBaseType() && hasNullTypeAnnotation(AnnotationPosition.LEAF_TYPE))
+		scope.problemReporter().illegalAnnotationForBaseType(this, this.annotations[0], this.resolvedType.tagBits & TagBits.AnnotationNullMASK);	
 }
 /** Retrieve the null annotation that has been translated to the given nullTagBits. */
 public Annotation findAnnotation(long nullTagBits) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
index 9ef8ba3..7a08e9c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ArrayBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -482,4 +482,10 @@ public TypeBinding uncapture(Scope scope) {
 public boolean acceptsNonNullDefault() {
 	return true;
 }
+@Override
+public long updateTagBits() {
+	if (this.leafComponentType != null)
+		this.tagBits |= this.leafComponentType.updateTagBits(); 
+	return super.updateTagBits();
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
index 46455ee..aabd3c7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
@@ -1012,7 +1012,7 @@ public class ClassScope extends Scope {
 		sourceType.tagBits |= (superType.tagBits & TagBits.HierarchyHasProblems); // propagate if missing supertpye
 		sourceType.setSuperClass(superType);
 		// bound check (in case of bogus definition of Enum type)
-		if (refTypeVariables[0].boundCheck(superType, sourceType, this) != TypeConstants.OK) {
+		if (!refTypeVariables[0].boundCheck(superType, sourceType, this, null).isOKbyJLS()) {
 			problemReporter().typeMismatchError(rootEnumType, refTypeVariables[0], sourceType, null);
 		}
 		return !foundCycle;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
index 4057cee..9939c8e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ImplicitNullAnnotationVerifier.java
@@ -294,7 +294,7 @@ public class ImplicitNullAnnotationVerifier {
 						ParameterizedGenericMethodBinding substitute = this.environment.createParameterizedGenericMethod(currentMethod, typeVariables);
 						substituteReturnType = substitute.returnType;
 					}
-					if (NullAnnotationMatching.analyse(inheritedMethod.returnType, currentMethod.returnType, substituteReturnType, 0, CheckMode.OVERRIDE).isAnyMismatch()) {
+					if (NullAnnotationMatching.analyse(inheritedMethod.returnType, currentMethod.returnType, substituteReturnType, null, 0, CheckMode.OVERRIDE_RETURN).isAnyMismatch()) {
 						if (srcMethod != null)
 							scope.problemReporter().illegalReturnRedefinition(srcMethod, inheritedMethod,
 																	this.environment.getNonNullAnnotationName());
@@ -425,7 +425,7 @@ public class ImplicitNullAnnotationVerifier {
 				if (useTypeAnnotations) {
 					TypeBinding inheritedParameter = inheritedMethod.parameters[i];
 					TypeBinding substituteParameter = substituteParameters != null ? substituteParameters[i] : null;
-					if (NullAnnotationMatching.analyse(currentMethod.parameters[i], inheritedParameter, substituteParameter, 0, CheckMode.OVERRIDE).isAnyMismatch()) {
+					if (NullAnnotationMatching.analyse(currentMethod.parameters[i], inheritedParameter, substituteParameter, null, 0, CheckMode.OVERRIDE).isAnyMismatch()) {
 						if (currentArgument != null)
 							scope.problemReporter().illegalParameterRedefinition(currentArgument, inheritedMethod.declaringClass, inheritedParameter);
 						else
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionTypeBinding18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionTypeBinding18.java
index 538c0ec..4a3df99 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionTypeBinding18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/IntersectionTypeBinding18.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -289,4 +289,10 @@ public class IntersectionTypeBinding18 extends ReferenceBinding { // abstraction
 		}
 		return false;
 	}
+	@Override
+	public long updateTagBits() {
+		for (TypeBinding intersectingType : this.intersectingTypes)
+			this.tagBits |= intersectingType.updateTagBits();
+		return super.updateTagBits();
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index f7ab036..488e547 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -26,6 +26,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.Invocation;
 import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
@@ -168,8 +169,8 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 		    }
 		    
 		    if (uncheckedArguments != null && uncheckedArguments[i] == null) continue; // only bound check if inferred through 15.12.2.6
-			switch (typeVariable.boundCheck(substitution, substituteForChecks, scope)) {
-				case TypeConstants.MISMATCH :
+			switch (typeVariable.boundCheck(substitution, substituteForChecks, scope, null)) {
+				case MISMATCH :
 			        // incompatible due to bound check
 					int argLength = arguments.length;
 					TypeBinding[] augmentedArguments = new TypeBinding[argLength + 2]; // append offending substitute and typeVariable
@@ -177,10 +178,12 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 					augmentedArguments[argLength] = substitute;
 					augmentedArguments[argLength+1] = typeVariable;
 			        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, augmentedArguments, ProblemReasons.ParameterBoundMismatch);
-				case TypeConstants.UNCHECKED :
+				case UNCHECKED :
 					// tolerate unchecked bounds
 					methodSubstitute.tagBits |= TagBits.HasUncheckedTypeArgumentForBoundCheck;
 					break;
+				default:
+					break;
 			}
 		}
 		// check presence of unchecked argument conversion a posteriori (15.12.2.6)
@@ -275,7 +278,7 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 					if (invocationTypeInferred) {
 						if (compilerOptions.isAnnotationBasedNullAnalysisEnabled)
 							NullAnnotationMatching.checkForContradictions(methodSubstitute, invocationSite, scope);
-						MethodBinding problemMethod = methodSubstitute.boundCheck18(scope, arguments);
+						MethodBinding problemMethod = methodSubstitute.boundCheck18(scope, arguments, invocationSite);
 						if (problemMethod != null) {
 							return problemMethod;
 						}
@@ -299,7 +302,7 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 		}
 	}
 	
-	MethodBinding boundCheck18(Scope scope, TypeBinding[] arguments) {
+	MethodBinding boundCheck18(Scope scope, TypeBinding[] arguments, InvocationSite site) {
 		Substitution substitution = this;
 		ParameterizedGenericMethodBinding methodSubstitute = this;
 		TypeVariableBinding[] originalTypeVariables = this.originalMethod.typeVariables;
@@ -318,8 +321,9 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 		    	substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(originalTypeVariables, null, scope), substitute); // while using this for bounds check
 		    }
 		    
-			switch (typeVariable.boundCheck(substitution, substituteForChecks, scope)) {
-				case TypeConstants.MISMATCH :
+			ASTNode location = site instanceof ASTNode ? (ASTNode) site : null;
+			switch (typeVariable.boundCheck(substitution, substituteForChecks, scope, location)) {
+				case MISMATCH :
 			        // incompatible due to bound check
 					int argLength = arguments.length;
 					TypeBinding[] augmentedArguments = new TypeBinding[argLength + 2]; // append offending substitute and typeVariable
@@ -327,10 +331,12 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 					augmentedArguments[argLength] = substitute;
 					augmentedArguments[argLength+1] = typeVariable;
 			        return new ProblemMethodBinding(methodSubstitute, this.originalMethod.selector, augmentedArguments, ProblemReasons.ParameterBoundMismatch);
-				case TypeConstants.UNCHECKED :
+				case UNCHECKED :
 					// tolerate unchecked bounds
 					methodSubstitute.tagBits |= TagBits.HasUncheckedTypeArgumentForBoundCheck;
 					break;
+				default:
+					break;
 			}
 		}
 		return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index 50fed54..29f971f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -54,6 +54,7 @@ import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants.BoundCheckStatus;
 
 /**
  * A parameterized type encapsulates a type with type arguments,
@@ -112,13 +113,12 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 			TypeVariableBinding[] typeVariables = this.type.typeVariables();
 			if (this.arguments != null && typeVariables != null) { // arguments may be null in error cases
 				for (int i = 0, length = typeVariables.length; i < length; i++) {
-				    if (typeVariables[i].boundCheck(this, this.arguments[i], scope)  != TypeConstants.OK) {
-				    	hasErrors = true;
-				    	if ((this.arguments[i].tagBits & TagBits.HasMissingType) == 0) {
-				    		// do not report secondary error, if type reference already got complained against
-							scope.problemReporter().typeMismatchError(this.arguments[i], typeVariables[i], this.type, argumentReferences[i]);
-				    	}
-				    }
+				    BoundCheckStatus checkStatus = typeVariables[i].boundCheck(this, this.arguments[i], scope, argumentReferences[i]);
+				    hasErrors |= checkStatus != BoundCheckStatus.OK;
+			    	if (!checkStatus.isOKbyJLS() && (this.arguments[i].tagBits & TagBits.HasMissingType) == 0) {
+			    		// do not report secondary error, if type reference already got complained against
+						scope.problemReporter().typeMismatchError(this.arguments[i], typeVariables[i], this.type, argumentReferences[i]);
+			    	}
 				}
 			}
 			if (!hasErrors) this.tagBits |= TagBits.PassedBoundCheck; // no need to recheck it in the future
@@ -1433,7 +1433,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		declaringType = scope.environment().createParameterizedType(genericType, types, genericType.enclosingType());
 		TypeVariableBinding [] typeParameters = genericType.typeVariables();
 		for (int i = 0, length = typeParameters.length; i < length; i++) {
-			if (typeParameters[i].boundCheck(declaringType, types[i], scope) != TypeConstants.OK)
+			if (!typeParameters[i].boundCheck(declaringType, types[i], scope, null).isOKbyJLS())
 				return this.singleAbstractMethod[index] = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);			
 		}
 		ReferenceBinding substitutedDeclaringType = (ReferenceBinding) declaringType.findSuperTypeOriginatingFrom(theAbstractMethod.declaringClass);
@@ -1516,4 +1516,11 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		}
 		return types;
 	}
+	@Override
+	public long updateTagBits() {
+		if (this.arguments != null)
+			for (TypeBinding argument : this.arguments)
+				this.tagBits |= argument.updateTagBits();
+		return super.updateTagBits();
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 33ded17..b686948 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -944,8 +944,14 @@ public abstract class Scope {
 		}
 		// after bounds have been resolved we're ready for resolving the type parameter itself,
 		// which includes resolving/evaluating type annotations and checking for inconsistencies
-		for (int i = 0; i < paramLength; i++)
+		boolean declaresNullTypeAnnotation = false;
+		for (int i = 0; i < paramLength; i++) {
 			resolveTypeParameter(typeParameters[i]);
+			declaresNullTypeAnnotation |= typeParameters[i].binding.hasNullTypeAnnotations();
+		}
+		if (declaresNullTypeAnnotation)
+			for (int i = 0; i < paramLength; i++)
+				typeParameters[i].binding.updateTagBits(); // <T extends List<U>, @NonNull U> --> tag T as having null type annotations 
 		return noProblems;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index e1beb3e..52c8148 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1677,4 +1677,11 @@ public void exitRecursiveFunction() {
 public boolean isFunctionalType() {
 	return false;
 }
+/**
+ * Refresh some tagBits from details into the main type.
+ * Currently handled: TagBits.HasNullTypeAnnotation
+ */
+public long updateTagBits() {
+	return this.tagBits & TagBits.HasNullTypeAnnotation; // subclasses to override
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index 03b69f7..3a5eece 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -345,10 +345,25 @@ public interface TypeConstants {
 	int CONSTRAINT_EXTENDS = 1;	// Actual << Formal
 	int CONSTRAINT_SUPER = 2;		// Actual >> Formal
 
-	// Constants used to perform bound checks
-	int OK = 0;
-	int UNCHECKED = 1;
-	int MISMATCH = 2;
+	// status of bound checks
+	public static enum BoundCheckStatus {
+		OK, NULL_PROBLEM, UNCHECKED, MISMATCH;
+		/** true if no problem or only a null problem. */
+		boolean isOKbyJLS() {
+			switch (this) {
+				case OK:
+				case NULL_PROBLEM:
+					return true;
+				default:
+					return false;
+			}
+		}
+		public BoundCheckStatus betterOf(BoundCheckStatus other) {
+			if (this.ordinal() < other.ordinal())
+				return this;
+			return other;
+		}
+	}
 
 	// Synthetics
 	char[] INIT = "<init>".toCharArray(); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
index 55374ca..591ed61 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeVariableBinding.java
@@ -40,13 +40,16 @@ package org.eclipse.jdt.internal.compiler.lookup;
 import java.util.Set;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
 import org.eclipse.jdt.internal.compiler.ast.TypeParameter;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
+import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.CheckMode;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants.BoundCheckStatus;
 
 /**
  * Binding for a type parameter, held by source/binary type or method.
@@ -104,31 +107,32 @@ public class TypeVariableBinding extends ReferenceBinding {
 
 	/**
 	 * Returns true if the argument type satisfies all bounds of the type parameter
+	 * @param location if non-null this may be used for reporting errors relating to null type annotations (if enabled)
 	 */
-	public int boundCheck(Substitution substitution, TypeBinding argumentType, Scope scope) {
-		int code = internalBoundCheck(substitution, argumentType, scope);
-		if (code == TypeConstants.MISMATCH) {
+	public TypeConstants.BoundCheckStatus boundCheck(Substitution substitution, TypeBinding argumentType, Scope scope, ASTNode location) {
+		TypeConstants.BoundCheckStatus code = internalBoundCheck(substitution, argumentType, scope, location);
+		if (code == BoundCheckStatus.MISMATCH) {
 			if (argumentType instanceof TypeVariableBinding && scope != null) {
 				TypeBinding bound = ((TypeVariableBinding)argumentType).firstBound;
 				if (bound instanceof ParameterizedTypeBinding) {
-					int code2 = boundCheck(substitution, bound.capture(scope, -1, -1), scope); // no position needed as this capture will never escape this context
-					return Math.min(code, code2);
+					BoundCheckStatus code2 = boundCheck(substitution, bound.capture(scope, -1, -1), scope, location); // no capture position needed as this capture will never escape this context
+					return code.betterOf(code2);
 				}
 			}
 		}
 		return code;
 	}
-	private int internalBoundCheck(Substitution substitution, TypeBinding argumentType, Scope scope) {
+	private TypeConstants.BoundCheckStatus internalBoundCheck(Substitution substitution, TypeBinding argumentType, Scope scope, ASTNode location) {
 		if (argumentType == TypeBinding.NULL || TypeBinding.equalsEquals(argumentType, this)) {
-			return TypeConstants.OK;
+			return BoundCheckStatus.OK;
 		}
 		boolean hasSubstitution = substitution != null;
 		if (!(argumentType instanceof ReferenceBinding || argumentType.isArrayType()))
-			return TypeConstants.MISMATCH;
+			return BoundCheckStatus.MISMATCH;
 		// special case for re-entrant source types (selection, code assist, etc)...
 		// can request additional types during hierarchy walk that are found as source types that also 'need' to connect their hierarchy
 		if (this.superclass == null)
-			return TypeConstants.OK;
+			return BoundCheckStatus.OK;
 
 		if (argumentType.kind() == Binding.WILDCARD_TYPE) {
 			WildcardBinding wildcard = (WildcardBinding) argumentType;
@@ -136,30 +140,30 @@ public class TypeVariableBinding extends ReferenceBinding {
 				case Wildcard.EXTENDS :
 					TypeBinding wildcardBound = wildcard.bound;
 					if (TypeBinding.equalsEquals(wildcardBound, this))
-						return TypeConstants.OK;
+						return BoundCheckStatus.OK;
 					boolean isArrayBound = wildcardBound.isArrayType();
 					if (!wildcardBound.isInterface()) {
 						TypeBinding substitutedSuperType = hasSubstitution ? Scope.substitute(substitution, this.superclass) : this.superclass;
 						if (substitutedSuperType.id != TypeIds.T_JavaLangObject) {
 							if (isArrayBound) {
 								if (!wildcardBound.isCompatibleWith(substitutedSuperType, scope))
-									return TypeConstants.MISMATCH;
+									return BoundCheckStatus.MISMATCH;
 							} else {
 								TypeBinding match = wildcardBound.findSuperTypeOriginatingFrom(substitutedSuperType);
 								if (match != null) {
 									if (substitutedSuperType.isProvablyDistinct(match)) {
-										return TypeConstants.MISMATCH;
+										return BoundCheckStatus.MISMATCH;
 									}
 								} else {
 									match =  substitutedSuperType.findSuperTypeOriginatingFrom(wildcardBound);
 									if (match != null) {
 										if (match.isProvablyDistinct(wildcardBound)) {
-											return TypeConstants.MISMATCH;
+											return BoundCheckStatus.MISMATCH;
 										}
 									} else {
 										if (denotesRelevantSuperClass(wildcardBound) && denotesRelevantSuperClass(substitutedSuperType)) {
 											// non-object real superclass should have produced a valid 'match' above
-											return TypeConstants.MISMATCH;
+											return BoundCheckStatus.MISMATCH;
 										}
 									}
 								}
@@ -171,15 +175,15 @@ public class TypeVariableBinding extends ReferenceBinding {
 						TypeBinding substitutedSuperType = hasSubstitution ? Scope.substitute(substitution, this.superInterfaces[i]) : this.superInterfaces[i];
 						if (isArrayBound) {
 							if (!wildcardBound.isCompatibleWith(substitutedSuperType, scope))
-									return TypeConstants.MISMATCH;
+									return BoundCheckStatus.MISMATCH;
 						} else {
 							TypeBinding match = wildcardBound.findSuperTypeOriginatingFrom(substitutedSuperType);
 							if (match != null) {
 								if (substitutedSuperType.isProvablyDistinct(match)) {
-									return TypeConstants.MISMATCH;
+									return BoundCheckStatus.MISMATCH;
 								}
 							} else if (mustImplement) {
-									return TypeConstants.MISMATCH; // cannot be extended further to satisfy missing bounds
+									return BoundCheckStatus.MISMATCH; // cannot be extended further to satisfy missing bounds
 							}
 						}
 
@@ -190,19 +194,21 @@ public class TypeVariableBinding extends ReferenceBinding {
 					// if the wildcard is lower-bounded by a type variable that has no relevant upper bound there's nothing to check here (bug 282152):
 					if (wildcard.bound.isTypeVariable() && ((TypeVariableBinding)wildcard.bound).superclass.id == TypeIds.T_JavaLangObject)
 						break;
-					return boundCheck(substitution, wildcard.bound, scope);
+					return boundCheck(substitution, wildcard.bound, scope, location);
 
 				case Wildcard.UNBOUND :
 					break;
 			}
-			return TypeConstants.OK;
+			return BoundCheckStatus.OK;
 		}
 		boolean unchecked = false;
+		boolean checkNullAnnotations = scope.environment().usesNullTypeAnnotations();
+		boolean haveReportedNullProblem = false;
 		if (this.superclass.id != TypeIds.T_JavaLangObject) {
 			TypeBinding substitutedSuperType = hasSubstitution ? Scope.substitute(substitution, this.superclass) : this.superclass;
 	    	if (TypeBinding.notEquals(substitutedSuperType, argumentType)) {
 				if (!argumentType.isCompatibleWith(substitutedSuperType, scope)) {
-				    return TypeConstants.MISMATCH;
+				    return BoundCheckStatus.MISMATCH;
 				}
 				TypeBinding match = argumentType.findSuperTypeOriginatingFrom(substitutedSuperType);
 				if (match != null){
@@ -211,12 +217,18 @@ public class TypeVariableBinding extends ReferenceBinding {
 						unchecked = true;
 				}
 	    	}
+			if (location != null && checkNullAnnotations) {
+				if (NullAnnotationMatching.analyse(this, argumentType, substitutedSuperType, substitution, -1, CheckMode.BOUND_CHECK).isAnyMismatch()) {
+					scope.problemReporter().nullityMismatchTypeArgument(this, argumentType, location);
+					haveReportedNullProblem = true;
+				}
+			}
 		}
 	    for (int i = 0, length = this.superInterfaces.length; i < length; i++) {
 			TypeBinding substitutedSuperType = hasSubstitution ? Scope.substitute(substitution, this.superInterfaces[i]) : this.superInterfaces[i];
 	    	if (TypeBinding.notEquals(substitutedSuperType, argumentType)) {
 				if (!argumentType.isCompatibleWith(substitutedSuperType, scope)) {
-				    return TypeConstants.MISMATCH;
+				    return BoundCheckStatus.MISMATCH;
 				}
 				TypeBinding match = argumentType.findSuperTypeOriginatingFrom(substitutedSuperType);
 				if (match != null){
@@ -225,15 +237,21 @@ public class TypeVariableBinding extends ReferenceBinding {
 						unchecked = true;
 				}
 	    	}
+			if (location != null && checkNullAnnotations) {
+				if (NullAnnotationMatching.analyse(this, argumentType, substitutedSuperType, substitution, -1, CheckMode.BOUND_CHECK).isAnyMismatch()) {
+					scope.problemReporter().nullityMismatchTypeArgument(this, argumentType, location);
+					haveReportedNullProblem = true;
+				}
+			}
 	    }
-	    long nullTagBits = NullAnnotationMatching.validNullTagBits(this.tagBits);
-	    if (nullTagBits != 0) {
-	    	long argBits = NullAnnotationMatching.validNullTagBits(argumentType.tagBits);
-	    	if (argBits != nullTagBits) {
-//	    		System.err.println("TODO(stephan): issue proper error: bound conflict at "+String.valueOf(this.declaringElement.readableName()));
-	    	}
+	    if (location != null && checkNullAnnotations && !haveReportedNullProblem) {
+	    	long nullBits = this.tagBits & TagBits.AnnotationNullMASK;
+	    	if (nullBits != 0 && nullBits != (argumentType.tagBits & TagBits.AnnotationNullMASK)) {
+				scope.problemReporter().nullityMismatchTypeArgument(this, argumentType, location);
+				haveReportedNullProblem = true;
+			}
 	    }
-	    return unchecked ? TypeConstants.UNCHECKED : TypeConstants.OK;
+	    return unchecked ? BoundCheckStatus.UNCHECKED : haveReportedNullProblem ? BoundCheckStatus.NULL_PROBLEM : BoundCheckStatus.OK;
 	}
 
 	boolean denotesRelevantSuperClass(TypeBinding type) {
@@ -997,4 +1015,21 @@ public class TypeVariableBinding extends ReferenceBinding {
 	public boolean acceptsNonNullDefault() {
 		return false;
 	}
+
+	@Override
+	public long updateTagBits() {
+		if (!this.inRecursiveFunction) {
+			this.inRecursiveFunction = true;
+			try {
+				if (this.superclass != null)
+					this.tagBits |= this.superclass.updateTagBits();
+				if (this.superInterfaces != null)
+					for (TypeBinding superIfc : this.superInterfaces)
+						this.tagBits |= superIfc.updateTagBits();
+			} finally {
+				this.inRecursiveFunction = false;
+			}
+		}
+		return super.updateTagBits();
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
index 3ff895c..01bcc3a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/WildcardBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2014 IBM Corporation and others.
+ * Copyright (c) 2005, 2015 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -941,4 +941,22 @@ public class WildcardBinding extends ReferenceBinding {
 	public boolean acceptsNonNullDefault() {
 		return false;
 	}
+
+	@Override
+	public long updateTagBits() {
+		if (!this.inRecursiveFunction) {
+			this.inRecursiveFunction = true;
+			try {
+				if (this.bound != null)
+					this.tagBits |= this.bound.updateTagBits();
+				if (this.otherBounds != null) {
+					for (int i = 0, length = this.otherBounds.length; i < length; i++)
+						this.tagBits |= this.otherBounds[i].updateTagBits();
+				}
+			} finally {
+				this.inRecursiveFunction = false;
+			}
+		}
+		return super.updateTagBits();
+	}
 }
