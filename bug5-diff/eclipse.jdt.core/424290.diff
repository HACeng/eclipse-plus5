commit a52f17f8883dd812875c341ff752527a9011d961
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sat Nov 8 08:05:56 2014 +0530

    Fixed Bug 424290 - [1.8] Evaluate alternate options for lambda shape
    analysis.

2360	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
3	28	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
2	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
2	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnly335CompilerTests.java
2	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
13	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
11	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java
34	58	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
49	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
19	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
14	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
10	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
new file mode 100644
index 0000000..7c4fb9a
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
@@ -0,0 +1,2360 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+import junit.framework.Test;
+
+public class LambdaShapeTests extends AbstractRegressionTest {
+static {
+//		TESTS_NAMES = new String[] { "testWhileThis"};
+//		TESTS_NUMBERS = new int[] { 50 };
+//		TESTS_RANGE = new int[] { 11, -1 };
+}
+public LambdaShapeTests(String name) {
+	super(name);
+}
+public static Test suite() {
+	return buildMinimalComplianceTestSuite(testClass(), F_1_8);
+}
+public void test001() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface VoidI {\n" + 
+			"	void foo(String s);\n" + 
+			"}\n" + 
+			"class Test {\n" + 
+			"	public String gooVoid(VoidI i){return \"\";}\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		Test test = new Test();\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (false) {\n" + 
+			"				x += \"a\";\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (true);\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (true) {\n" + 
+			"				x += \"a\";\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			final boolean val = true;\n" +
+			"			if (val) {\n" + 
+			"				x += \"a\";\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			final boolean val = true;\n" +
+			"			if (val);\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			final boolean val = false;\n" +
+			"			if (val) {\n" + 
+			"				x += \"a\";\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (x != null) {\n" + 
+			"				x += \"a\";\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			final boolean val = true;\n" +
+			"			if (x != null);\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (false) {\n" + 
+			"				x += \"a\";\n" + 
+			"			} else {\n" + 
+			"				x += \"b\";\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (false) {\n" + 
+			"				x += \"a\";\n" + 
+			"			} else;\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			final boolean val = false;\n" +
+			"			if (val) {\n" + 
+			"				x += \"a\";\n" + 
+			"			} else {\n" + 
+			"				x += \"b\";\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			final boolean val = false;\n" +
+			"			if (val) {\n" + 
+			"				x += \"a\";\n" + 
+			"			} else;\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (x != null) {\n" + 
+			"				x += \"a\";\n" + 
+			"			} else {\n" + 
+			"				x += \"b\";\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (x != null) {\n" + 
+			"				x += \"a\";\n" + 
+			"			} else;\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n",
+		});
+}
+public void test002() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x); \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		final boolean FALSE = false;\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(true) return \"\";\n" + 
+			"			else return null;\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(false) return \"\";\n" + 
+			"			else return null;\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(x > 0) return \"\";\n" + 
+			"			else return null;\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(FALSE) return \"\";\n" + 
+			"			else return null;\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(!FALSE) return \"\";\n" + 
+			"			else return null;\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(!FALSE) return \"\";\n" + 
+			"			else return null;\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		});
+}
+public void test003() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface VoidI {\n" + 
+			"	void foo(String s);\n" + 
+			"}\n" + 
+			"class Test {\n" + 
+			"	public String gooVoid(VoidI i){return \"\";}\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		Test test = new Test();\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (true) {\n" + 
+			"				return 0;\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	test.gooVoid((x) -> {\n" + 
+		"	     ^^^^^^^\n" + 
+		"The method gooVoid(VoidI) in the type Test is not applicable for the arguments ((<no type> x) -> {})\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 12)\n" + 
+		"	return 0;\n" + 
+		"	^^^^^^^^^\n" + 
+		"Void methods cannot return a value\n" + 
+		"----------\n");
+}
+public void test004() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface VoidI {\n" + 
+			"	void foo(String s);\n" + 
+			"}\n" + 
+			"class Test {\n" + 
+			"	public String gooVoid(VoidI i){return \"\";}\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		Test test = new Test();\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			final boolean val = true;\n" + 
+			"			if (val) {\n" + 
+			"				return x;\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	test.gooVoid((x) -> {\n" + 
+		"	     ^^^^^^^\n" + 
+		"The method gooVoid(VoidI) in the type Test is not applicable for the arguments ((<no type> x) -> {})\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 13)\n" + 
+		"	return x;\n" + 
+		"	^^^^^^^^^\n" + 
+		"Void methods cannot return a value\n" + 
+		"----------\n");
+}
+public void test005() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface VoidI {\n" + 
+			"	void foo(String s);\n" + 
+			"}\n" + 
+			"class Test {\n" + 
+			"	public String gooVoid(VoidI i){return \"\";}\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		Test test = new Test();\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (x != null) {\n" + 
+			"				return 0;\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	test.gooVoid((x) -> {\n" + 
+		"	     ^^^^^^^\n" + 
+		"The method gooVoid(VoidI) in the type Test is not applicable for the arguments ((<no type> x) -> {})\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 12)\n" + 
+		"	return 0;\n" + 
+		"	^^^^^^^^^\n" + 
+		"Void methods cannot return a value\n" + 
+		"----------\n");
+}
+public void test006() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface VoidI {\n" + 
+			"	void foo(String s);\n" + 
+			"}\n" + 
+			"class Test {\n" + 
+			"	public String gooVoid(VoidI i){return \"\";}\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		Test test = new Test();\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (false) {\n" + 
+			"				x += \"a\";\n" + 
+			"			} else {\n" + 
+			"				return 0;\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	test.gooVoid((x) -> {\n" + 
+		"	     ^^^^^^^\n" + 
+		"The method gooVoid(VoidI) in the type Test is not applicable for the arguments ((<no type> x) -> {})\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 14)\n" + 
+		"	return 0;\n" + 
+		"	^^^^^^^^^\n" + 
+		"Void methods cannot return a value\n" + 
+		"----------\n");
+}
+public void test007() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface VoidI {\n" + 
+			"	void foo(String s);\n" + 
+			"}\n" + 
+			"class Test {\n" + 
+			"	public String gooVoid(VoidI i){return \"\";}\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		Test test = new Test();\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			final boolean val = false;\n" + 
+			"			if (val) {\n" + 
+			"				x += \"a\";\n" + 
+			"			} else {\n" + 
+			"				return 0;\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	test.gooVoid((x) -> {\n" + 
+		"	     ^^^^^^^\n" + 
+		"The method gooVoid(VoidI) in the type Test is not applicable for the arguments ((<no type> x) -> {})\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 15)\n" + 
+		"	return 0;\n" + 
+		"	^^^^^^^^^\n" + 
+		"Void methods cannot return a value\n" + 
+		"----------\n");
+}
+public void test008() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface VoidI {\n" + 
+			"	void foo(String s);\n" + 
+			"}\n" + 
+			"class Test {\n" + 
+			"	public String gooVoid(VoidI i){return \"\";}\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	public static void main(String[] args) {\n" + 
+			"		Test test = new Test();\n" + 
+			"		test.gooVoid((x) -> {\n" + 
+			"			if (x != null) {\n" + 
+			"				x += \"a\";\n" + 
+			"			} else {\n" + 
+			"				return 0;\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	test.gooVoid((x) -> {\n" + 
+		"	     ^^^^^^^\n" + 
+		"The method gooVoid(VoidI) in the type Test is not applicable for the arguments ((<no type> x) -> {})\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 14)\n" + 
+		"	return 0;\n" + 
+		"	^^^^^^^^^\n" + 
+		"Void methods cannot return a value\n" + 
+		"----------\n");
+}
+public void test009() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x); \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		final boolean FALSE = false;\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(FALSE) return \"\";\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 8)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test010() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x); \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(true);\n" + 
+			"			else return \"\";\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 9)\n" + 
+		"	else return \"\";\n" + 
+		"	     ^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n");
+}
+public void test011() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x); \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(false) return null;\n" + 
+			"			else;\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 8)\n" + 
+		"	if(false) return null;\n" + 
+		"	          ^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 9)\n" + 
+		"	else;\n" + 
+		"	    ^\n" + 
+		"Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally\n" + 
+		"----------\n");
+}
+public void test012() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x); \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(x > 0) return \"\";\n" + 
+			"			else;\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 9)\n" + 
+		"	else;\n" + 
+		"	    ^\n" + 
+		"Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally\n" + 
+		"----------\n");
+}
+public void test013() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x); \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(x > 0);\n" + 
+			"			else return \"\";\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test014() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x); \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(x < 0) return null;\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test015() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x); \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		final boolean FALSE = false;\n" + 
+			"		goo((x) -> {\n" + 
+			"			if(!FALSE) return \"\";\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 8)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test016() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		final boolean FALSE = false;\n" + 
+			"		goo((x) -> {while (FALSE) throw new Exception();});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 8)\n" + 
+		"	goo((x) -> {while (FALSE) throw new Exception();});\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
+		"----------\n");
+}
+public void test017() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {while (false) return \"\";});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {while (false) return \"\";});\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {while (false) return \"\";});\n" + 
+		"	                          ^^^^^^^^^^\n" + 
+		"Unreachable code\n" + 
+		"----------\n");
+}
+public void test018() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {while (x > 0) {\n" + 
+			"			if(x > 0) {return \"\";} else {break;}\n" + 
+			"			}});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {while (x > 0) {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 8)\n" + 
+		"	if(x > 0) {return \"\";} else {break;}\n" + 
+		"	                            ^^^^^^^^\n" + 
+		"Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally\n" + 
+		"----------\n");
+}
+public void test019() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {while (x > 0) {\n" + 
+			"			if(x > 0) {return \"\";}\n" + 
+			"		}});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {while (x > 0) {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test020() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		final boolean TRUE = true;\n" + 
+			"		goo((x) -> {while (TRUE) {\n" + 
+			"			if(x > 0) {System.out.println();}\n" + 
+			"			}});\n" + 
+			"		goo((x) -> {while (true) {\n" + 
+			"			if(x > 0) {System.out.println();}\n" + 
+			"			}});\n" + 
+			"	}\n" + 
+			"}\n"
+		});
+}
+public void test021() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {\n" + 
+			"			int i = 100;\n" + 
+			"			outer: while(x > 0) {\n" + 
+			"				inner: while(i > 0) {\n" + 
+			"				if(--i > 50) {\n" + 
+			"					return \"\";\n" + 
+			"				}\n" + 
+			"				if(i > 90) {\n" + 
+			"					break outer;\n" + 
+			"				}\n" + 
+			"				return \"\";\n" + 
+			"				}\n" + 
+			"			}});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 10)\n" + 
+		"	inner: while(i > 0) {\n" + 
+		"	^^^^^\n" + 
+		"The label inner is never explicitly referenced\n" + 
+		"----------\n");
+}
+public void test022() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	void foo(String s) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void zoo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		final boolean FALSE = false;\n" + 
+			"		final boolean TRUE = true;\n" + 
+			"		zoo((x) -> {while (TRUE) throw new Exception();});\n" + 
+			"		zoo((x) -> {while (!FALSE) return ;});\n" + 
+			"		zoo((x) -> {while (x.length() > 0) {\n" + 
+			"			if(x.length() > 0) {return ;} else {break;}\n" + 
+			"			}});\n" + 
+			"		zoo((x) -> {while (x.length() > 0) {\n" + 
+			"			if(x.length() > 0) {return ;}\n" + 
+			"			}});\n" + 
+			"		zoo((x) -> {while (true) {\n" + 
+			"			if(x.length() > 0) {System.out.println();}\n" + 
+			"			}});\n" + 
+			"		zoo((x) -> {while (TRUE) {\n" + 
+			"			if(x.length() > 0) {System.out.println();}\n" + 
+			"			}});\n" + 
+			"		zoo((x) -> {\n" + 
+			"			int i = 100;\n" + 
+			"			outer: while(x.length() > 0) {\n" + 
+			"				inner: while(i > 0) {\n" + 
+			"				if(--i > 50) {\n" + 
+			"					break inner ;\n" + 
+			"				}\n" + 
+			"				if(i > 90) {\n" + 
+			"					break outer;\n" + 
+			"				}\n" + 
+			"				return ;\n" + 
+			"				}\n" + 
+			"			}});\n" + 
+			"	}\n" + 
+			"}\n"
+		});
+}
+public void test023() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		final boolean FALSE = false;\n" + 
+			"		final boolean TRUE = true;\n" + 
+			"		goo((x) -> {do {throw new Exception();}while (FALSE);});\n" + 
+			"		goo((x) -> {do { return \"\";}while (false);});\n" + 
+			"		goo((x) -> {do {\n" + 
+			"			if(x > 0) {System.out.println();}\n" + 
+			"			}while (true);});\n" + 
+			"		goo((x) -> {do {\n" + 
+			"			if(x > 0) {System.out.println();}\n" + 
+			"			}while (TRUE);});\n" + 
+			"	}\n" + 
+			"}\n"
+		});
+}
+public void test024() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {do {\n" + 
+			"			if(x > 0) {return \"\";} else {break;}\n" + 
+			"			}while (x > 0);});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {do {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 8)\n" + 
+		"	if(x > 0) {return \"\";} else {break;}\n" + 
+		"	                            ^^^^^^^^\n" + 
+		"Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally\n" + 
+		"----------\n");
+}
+public void test025() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {do {\n" + 
+			"			if(x > 0) {return \"\";}\n" + 
+			"			}while (x > 0);});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {do {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test026() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	String foo(int x) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {\n" + 
+			"			int i = 100;\n" + 
+			"			outer: do {\n" + 
+			"				inner: do {\n" + 
+			"				if(--i > 50) {\n" + 
+			"					return \"\";\n" + 
+			"				}\n" + 
+			"				if(i > 90) {\n" + 
+			"					break outer;\n" + 
+			"				}\n" + 
+			"				return \"\";\n" + 
+			"				}while(i > 0);\n" + 
+			"			}while(x > 0);});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 10)\n" + 
+		"	inner: do {\n" + 
+		"	^^^^^\n" + 
+		"The label inner is never explicitly referenced\n" + 
+		"----------\n");
+}
+public void test027() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" + 
+			"	void foo(String s) throws Exception;\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void zoo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		zoo((x) -> {do {\n" + 
+			"			if(x.length() > 0) {System.out.println();}\n" + 
+			"			}while (true);});\n" + 
+			"		zoo((x) -> {do {throw new Exception();}while (false);});\n" + 
+			"		zoo((x) -> {do { return ;}while (false);});\n" + 
+			"		zoo((x) -> {do { continue ;}while (true);});\n" + 
+			"		zoo((x) -> {do {\n" + 
+			"			if(x.length() > 0) {return ;} else {break;}\n" + 
+			"			}while (x.length() > 0);\n" + 
+			"		});\n" + 
+			"		zoo((x) -> {do {\n" + 
+			"			if(x.length() > 0) {return ;}\n" + 
+			"			}while (x.length() > 0);\n" + 
+			"		});\n" + 
+			"		zoo((x) -> {\n" + 
+			"		int i = 100;\n" + 
+			"		outer: do {\n" + 
+			"			inner: do {\n" + 
+			"			if(--i > 50) {\n" + 
+			"				break inner ;\n" + 
+			"			}\n" + 
+			"			if(i > 90) {\n" + 
+			"				break outer;\n" + 
+			"			}\n" + 
+			"			return ;\n" + 
+			"			}while(i > 0);\n" + 
+			"		}while(x.length() > 0);});\n" + 
+			"	}\n" + 
+			"}\n"
+		});
+}
+public void test028() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		final boolean FALSE = false; \n" + 
+			"		final boolean TRUE = true; \n" + 
+			"		goo((x) -> {\n" + 
+			"			for(;TRUE;){\n" + 
+			"			}});\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(int i = 0;i < 100; i+= 10){\n" + 
+			"				switch(i) {\n" + 
+			"				case 90: {\n" + 
+			"					System.out.println();\n" + 
+			"					break;\n" + 
+			"				}\n" + 
+			"				case 80: {\n" + 
+			"					if(x > 10) return null;\n" + 
+			"					break;\n" + 
+			"				}\n" + 
+			"				default:\n" + 
+			"					return \"\";\n" + 
+			"				}\n" + 
+			"			}\n" + 
+			"			return \"\";\n" + 
+			"		});\n" + 
+			"		\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(;TRUE;){\n" + 
+			"				if(x < 100) return \"\";\n" + 
+			"				else return null;\n" + 
+			"		}});\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(;x > 0;){\n" + 
+			"				if(x < 100) return \"\";\n" + 
+			"				else return null;\n" + 
+			"			}\n" + 
+			"			return null;\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		});
+}
+public void test029() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		final boolean FALSE = false; \n" + 
+			"		goo((x) -> {\n" + 
+			"			for(;FALSE;){\n" + 
+			"			}});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 8)\n" + 
+		"	goo((x) -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
+		"----------\n");
+}
+public void test030() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(;x > 0;){\n" + 
+			"				if(x < 100) return \"\";\n" + 
+			"				else return null;\n" + 
+			"		}});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 10)\n" + 
+		"	else return null;\n" + 
+		"	     ^^^^^^^^^^^^\n" + 
+		"Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally\n" + 
+		"----------\n");
+}
+public void test031() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(int i = 0;i < 100; i+= 10){\n" + 
+			"				switch(i) {\n" + 
+			"				case 90: {\n" + 
+			"					System.out.println();\n" + 
+			"					break;\n" + 
+			"				}\n" + 
+			"				case 80: {\n" + 
+			"					if(x > 10) return null;\n" + 
+			"					break;\n" + 
+			"				}\n" + 
+			"				default:\n" + 
+			"					return \"\";\n" + 
+			"				}\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test032() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test() {\n" + 
+			"		goo((x) -> {\n" + 
+			"			outer: for(int i = 0;i < 100; i+= 10){\n" + 
+			"				inner : for(int j = x; j > 0; j--) {\n" + 
+			"					switch(i) {\n" + 
+			"					case 90: {\n" + 
+			"						System.out.println();\n" + 
+			"						break inner;\n" + 
+			"					}\n" + 
+			"					case 80: {\n" + 
+			"						if(x > 10) return null;\n" + 
+			"						break outer;\n" + 
+			"					}\n" + 
+			"					default:\n" + 
+			"						return \"\";\n" + 
+			"					}\n" + 
+			"				}\n" + 
+			"				\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 9)\n" + 
+		"	inner : for(int j = x; j > 0; j--) {\n" + 
+		"	                              ^^^\n" + 
+		"Dead code\n" + 
+		"----------\n");
+}
+public void test033() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(String str : strs){\n" + 
+			"				if(str.length() > 0) {\n" + 
+			"					return \"yes\";\n" + 
+			"				} else {\n" + 
+			"					return \"no\";\n" + 
+			"				}\n" + 
+			"			}\n" + 
+			"			return null;\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(String str : strs){\n" + 
+			"				return \"no\";\n" + 
+			"			}\n" + 
+			"			return \"\";\n" + 
+			"		});\n" + 
+			"		\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(String str : strs){\n" + 
+			"				if(str.length() > 0) break;\n" + 
+			"				System.out.println();\n" + 
+			"			}\n" + 
+			"			return \"\";\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		});
+}
+public void test034() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(String str : strs){\n" + 
+			"				if(str.length() > 0) {\n" + 
+			"					return \"yes\";\n" + 
+			"				} else {\n" + 
+			"					return \"no\";\n" + 
+			"				}\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 11)\n" + 
+		"	} else {\n" + 
+		"					return \"no\";\n" + 
+		"				}\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally\n" + 
+		"----------\n");
+}
+public void test035() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(String str : strs){\n" + 
+			"				return \"no\";\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test036() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" + 
+			"		goo((x) -> {\n" + 
+			"			for(String str : strs){\n" + 
+			"				switch(str.length()) {\n" + 
+			"				case 9: {\n" + 
+			"					System.out.println();\n" + 
+			"					return \"nine\";\n" + 
+			"				}\n" + 
+			"				case 1: {\n" + 
+			"					if(x > 10) return null;\n" + 
+			"					return \"one\";\n" + 
+			"				}\n" + 
+			"				default:\n" + 
+			"					return \"\";\n" + 
+			"				}\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test037() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" + 
+			"		goo((x) -> {\n" + 
+			"			outer: for(String str : strs){\n" + 
+			"				inner : for(int j = x; j > 0; j--) {\n" + 
+			"					switch(str.length()) {\n" + 
+			"					case 9: {\n" + 
+			"						System.out.println();\n" + 
+			"						break inner;\n" + 
+			"					}\n" + 
+			"					case 8: {\n" + 
+			"						if(x > 10) return null;\n" + 
+			"						break outer;\n" + 
+			"					}\n" + 
+			"					default:\n" + 
+			"						return \"\";\n" + 
+			"					}\n" + 
+			"				}\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 9)\n" + 
+		"	inner : for(int j = x; j > 0; j--) {\n" + 
+		"	                              ^^^\n" + 
+		"Dead code\n" + 
+		"----------\n");
+}
+public void test038() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" + 
+			"		goo((x) -> {\n" + 
+			"			switch(x) {\n" + 
+			"			case 0 : if(x > 10) return \">10\";\n" + 
+			"			case 1: return \"1\";\n" + 
+			"			default: return \"-1\";\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"			String str = \"\";\n" + 
+			"			switch(x) {\n" + 
+			"			case 0 : if(x > 10) break; else {str = \"0\"; break;}\n" + 
+			"			case 1: str = \"1\";break;\n" + 
+			"			default: break;\n" + 
+			"			}\n" + 
+			"			return str;\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"			String str = \"\";\n" + 
+			"			switch(x){}\n" + 
+			"			return str;\n" + 
+			"		});\n" +  
+			"	}\n" + 
+			"}\n"
+		});
+}
+public void test039() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" + 
+			"		goo((x) -> {\n" + 
+			"			switch(x) {\n" + 
+			"			case 0 : if(x > 10) return \">10\";\n" + 
+			"			case 1: return \"1\";\n" + 
+			"			}\n" + 
+			"		});\n" +  
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test040() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" + 
+			"		goo((x) -> {\n" + 
+			"			String str = \"\";\n" + 
+			"			switch(x) {\n" + 
+			"			case 0 : if(x > 10) break; else {str = \"0\"; break;}\n" + 
+			"			case 1: str = \"1\";break;\n" + 
+			"			default: break;\n" + 
+			"			}\n" + 
+			"		});\n" +
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
+		"----------\n");
+}
+public void test041() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" + 
+			"		goo((x) -> {\n" + 
+			"			try {\n" + 
+			"				return \"\";\n" + 
+			"			} finally {\n" + 
+			"				\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"				try {\n" + 
+			"					throw new Exception();\n" + 
+			"				} finally {\n" + 
+			"				}\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"				try {\n" + 
+			"					if(x > 0) \n" + 
+			"						throw new RuntimeException();\n" + 
+			"				} catch (NullPointerException e) {return null;} \n" + 
+			"				catch(ClassCastException c) {\n" + 
+			"				}\n" + 
+			"				finally {\n" + 
+			"					return \"\";\n" + 
+			"				}\n" + 
+			"		});\n" + 
+			"		\n" + 
+			"	}\n" + 
+			"}\n"
+		});
+}
+public void test042() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" +  
+			"		goo((x) -> {\n" + 
+			"			try {\n" + 
+			"				if(x > 0) {\n" + 
+			"					return \"\";\n" + 
+			"				}\n" + 
+			"			} finally {}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test043() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" +  
+			"		goo((x) -> {\n" + 
+			"			try {\n" + 
+			"				return \"\";\n" + 
+			"			}catch (Exception e) {}\n" + 
+			"			finally {\n" + 
+			"				\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test044() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" +  
+			"		goo((x) -> {\n" + 
+			"			try {\n" + 
+			"				//if(x > 0) \n" + 
+			"					throw new RuntimeException();\n" + 
+			"			} catch (NullPointerException e) {return null;} \n" + 
+			"			catch(ClassCastException c) {\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"		goo((x) -> {\n" + 
+			"			try {\n" + 
+			"				if(x > 0) \n" + 
+			"					throw new RuntimeException();\n" + 
+			"			} catch (NullPointerException e) {return null;} \n" + 
+			"			catch(ClassCastException c) {\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 15)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test045() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" +  
+			"		goo((x) -> {\n" + 
+			"			try {\n" + 
+			"				if(x > 0) \n" + 
+			"					throw new RuntimeException();\n" + 
+			"			} catch (NullPointerException e) {return null;} \n" + 
+			"			catch(ClassCastException c) {\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n");
+}
+public void test046() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I { \n" + 
+			"	String foo(int x) throws Exception; \n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"	void goo(I i) {}\n" + 
+			"	void test(String[] strs) {\n" +  
+			"		goo((x) -> {\n" + 
+			"			if (true) {\n" + 
+			"				try {\n" + 
+			"					if(x > 0)\n" + 
+			"						throw new Exception();\n" + 
+			"				} finally {\n" + 
+			"					return \"\";\n" + 
+			"				}\n" + 
+			"			}\n" + 
+			"		});\n" + 
+			"	}\n" + 
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	goo((x) -> {\n" + 
+		"	    ^^^^^^\n" + 
+		"This method must return a result of type String\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 12)\n" + 
+		"	} finally {\n" + 
+		"					return \"\";\n" + 
+		"				}\n" + 
+		"	          ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"finally block does not complete normally\n" + 
+		"----------\n");
+}
+public void testSwitch() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			switch (args.length) {\n" +
+			"			case 0:\n" +
+			"				System.out.println(0);\n" +
+			"				throw new RuntimeException();\n" +
+			"			case 1:\n" +
+			"				System.out.println(1);\n" +
+			"				throw new RuntimeException();\n" +
+			"			case 2:\n" +
+			"				System.out.println(2);\n" +
+			"				throw new RuntimeException();\n" +
+			"			default: \n" +
+			"				System.out.println(\"default\");\n" +
+			"				throw new RuntimeException();\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
+public void testSwitch2() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			switch (args.length) {\n" +
+			"			case 0:\n" +
+			"				System.out.println(0);\n" +
+			"				break;\n" +
+			"			case 1:\n" +
+			"				System.out.println(1);\n" +
+			"				throw new RuntimeException();\n" +
+			"			case 2:\n" +
+			"				System.out.println(2);\n" +
+			"				throw new RuntimeException();\n" +
+			"			default: \n" +
+			"				System.out.println(\"default\");\n" +
+			"				throw new RuntimeException();\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testSwitch3() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			switch (args.length) {\n" +
+			"			case 0:\n" +
+			"				System.out.println(0);\n" +
+			"				throw new RuntimeException();\n" +
+			"			case 1:\n" +
+			"				System.out.println(1);\n" +
+			"				throw new RuntimeException();\n" +
+			"			case 2:\n" +
+			"				System.out.println(2);\n" +
+			"				throw new RuntimeException();\n" +
+			"			default: \n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testSwitch4() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			switch (args.length) {\n" +
+			"			case 0:\n" +
+			"				System.out.println(0);\n" +
+			"				throw new RuntimeException();\n" +
+			"			case 1:\n" +
+			"				System.out.println(1);\n" +
+			"				throw new RuntimeException();\n" +
+			"			case 2:\n" +
+			"				System.out.println(2);\n" +
+			"				throw new RuntimeException();\n" +
+			"			default: \n" +
+			"			    break;\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testWhileThis() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			boolean t = true;\n" +
+			"			while (t) {\n" +
+			"				System.out.println();\n" +
+			"				throw new RuntimeException();\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testWhile2() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			while (t) {\n" +
+			"				System.out.println();\n" +
+			"				throw new RuntimeException();\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
+public void testWhile3() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			while (t && !!t) {\n" +
+			"				System.out.println();\n" +
+			"				throw new RuntimeException();\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
+public void testWhile4() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			while (t && !!!t) {\n" +
+			"				System.out.println();\n" +
+			"				throw new RuntimeException();\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			boolean t = true;\n" +
+			"			do {\n" +
+			"				System.out.println();\n" +
+			"				throw new RuntimeException();\n" +
+			"			} while (t);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
+public void testDo2() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			do {\n" +
+			"				System.out.println();\n" +
+			"				throw new RuntimeException();\n" +
+			"			} while (t);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
+public void testDo3() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			do { \n" +
+			"				System.out.println();\n" +
+			"				throw new RuntimeException();\n" +
+			"			} while (t && !!t);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
+public void testDo4() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			do {\n" +
+			"				System.out.println();\n" +
+			"			} while (t && !!!t);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testForeach() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			for (String s: args) {\n" +
+			"				System.out.println();\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testForeach2() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			for (String s: args) {\n" +
+			"				System.out.println();\n" +
+			"			do {\n" +
+			"				System.out.println();\n" +
+			"				switch (args.length) {\n" +
+			"				case 0:\n" +
+			"					System.out.println(0);\n" +
+			"					break;\n" +
+			"				case 1:\n" +
+			"					System.out.println(1);\n" +
+			"					throw new RuntimeException();\n" +
+			"				case 2:\n" +
+			"					System.out.println(2);\n" +
+			"					throw new RuntimeException();\n" +
+			"				default: \n" +
+			"					System.out.println(\"default\");\n" +
+			"					throw new RuntimeException();\n" +
+			"				}\n" +
+			"			} while (t);\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testForeach3() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			for (String s: args) {\n" +
+			"				System.out.println();\n" +
+			"			do {\n" +
+			"				System.out.println();\n" +
+			"				switch (args.length) {\n" +
+			"				case 0:\n" +
+			"					System.out.println(0);\n" +
+			"					throw new RuntimeException();\n" +
+			"				case 1:\n" +
+			"					System.out.println(1);\n" +
+			"					throw new RuntimeException();\n" +
+			"				case 2:\n" +
+			"					System.out.println(2);\n" +
+			"					throw new RuntimeException();\n" +
+			"				default: \n" +
+			"					System.out.println(\"default\");\n" +
+			"					throw new RuntimeException();\n" +
+			"				}\n" +
+			"			} while (t);\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testForeach4() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			for (String s: args) {\n" +
+			"				System.out.println();\n" +
+			"				throw new RuntimeException();\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testIf() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			if (t) \n" +
+			"               throw new RuntimeException();\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testIf2() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			if (true) \n" +
+			"               throw new RuntimeException();\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testIf3() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			if (true) \n" +
+			"               throw new RuntimeException();\n" +
+			"           else \n" +
+			"               throw new RuntimeException();\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
+public void testCFor() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			boolean t = true;\n" +
+			"			for (; t ;) { \n" +
+			"               throw new RuntimeException();\n" +
+			"           }\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testCFor2() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			final boolean t = true;\n" +
+			"			for (; t ;) { \n" +
+			"               throw new RuntimeException();\n" +
+			"           }\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
+public void testTry() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"           try {\n" +
+			"           } finally {\n" +
+			"               throw new RuntimeException();\n" +
+			"           }\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
+public void testTry2() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"           try {\n" +
+			"           } finally {\n" +
+			"           }\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testTry3() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"           try {\n" +
+			"           } catch (RuntimeException e) {\n" +
+			"               throw new RuntimeException();\n" +
+			"           }\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testTry4() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"           try {\n" +
+			"               throw new RuntimeException();\n" +
+			"           } catch (RuntimeException e) {\n" +
+			"               throw new RuntimeException();\n" +
+			"           }\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
+public void testWhileTrue() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"            System.out.println(\"goo(I)\");\n" +
+			"        }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			while (true) {\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n" 
+		},
+		"goo(I)");
+}
+public void testWhileTrue2() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"            System.out.println(\"goo(I)\");\n" +
+			"        }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			while (true) {\n" +
+			"			    while (true) {\n" +
+			"                   if (args == null) break;\n" +
+			"			    }\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n" 
+		},
+		"goo(I)");
+}
+public void testWhileTrue3() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"            System.out.println(\"goo(I)\");\n" +
+			"        }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			while (true) {\n" +
+			"                   if (args == null) break;\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n" 
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public static Class testClass() {
+	return LambdaShapeTests.class;
+}
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
index c530778..2d87012 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
@@ -5784,42 +5784,17 @@ public void test401939b() {
 				"	^^^\n" + 
 				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
 				"----------\n" + 
-				"2. ERROR in X.java (at line 15)\n" + 
-				"	goo((x) -> { while (TRUE) throw new Exception(); });\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 16)\n" + 
-				"	goo((x) -> { while (NIJAM) throw new Exception(); });\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 17)\n" + 
+				"2. ERROR in X.java (at line 17)\n" + 
 				"	goo((x) -> { while (POI) throw new Exception(); });\n" + 
 				"	^^^\n" + 
 				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
 				"----------\n" + 
-				"5. ERROR in X.java (at line 18)\n" + 
-				"	goo((x) -> { if (TRUE) throw new Exception(); else throw new Exception(); });\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
-				"----------\n" + 
-				"6. ERROR in X.java (at line 19)\n" + 
+				"3. ERROR in X.java (at line 19)\n" + 
 				"	goo((x) -> { if (TRUE) throw new Exception(); });\n" + 
 				"	^^^\n" + 
 				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
 				"----------\n" + 
-				"7. ERROR in X.java (at line 20)\n" + 
-				"	goo((x) -> { if (true) throw new Exception(); else throw new Exception(); });\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
-				"----------\n" + 
-				"8. ERROR in X.java (at line 21)\n" + 
-				"	goo((x) -> { if (false) throw new Exception(); else throw new Exception(); });\n" + 
-				"	^^^\n" + 
-				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
-				"----------\n" + 
-				"9. ERROR in X.java (at line 22)\n" + 
+				"4. ERROR in X.java (at line 22)\n" + 
 				"	goo((x) -> { while (BLANK) throw new Exception(); });\n" + 
 				"	^^^\n" + 
 				"The method goo(I) in the type X is not applicable for the arguments ((<no type> x) -> {})\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index 2c0ba06..fe52638 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -147,6 +147,7 @@ public static Test suite() {
 	since_1_8.add(RepeatableAnnotationTest.class);
 	since_1_8.add(GenericsRegressionTest_1_8.class);
 	since_1_8.add(Unicode18Test.class);
+	since_1_8.add(LambdaShapeTests.class);
 
 	// Build final test suite
 	TestSuite all = new TestSuite(TestAll.class.getName());
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnly335CompilerTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnly335CompilerTests.java
index 3484594..92ac3df 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnly335CompilerTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnly335CompilerTests.java
@@ -23,6 +23,7 @@ import org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest_1_7
 import org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest_1_8;
 import org.eclipse.jdt.core.tests.compiler.regression.LambdaExpressionsTest;
 import org.eclipse.jdt.core.tests.compiler.regression.LambdaRegressionTest;
+import org.eclipse.jdt.core.tests.compiler.regression.LambdaShapeTests;
 import org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest;
 import org.eclipse.jdt.core.tests.compiler.regression.NullTypeAnnotationTest;
 import org.eclipse.jdt.core.tests.compiler.regression.OverloadResolutionTest8;
@@ -41,6 +42,7 @@ public class RunOnly335CompilerTests extends TestCase {
 			LambdaRegressionTest.class,
 			NegativeLambdaExpressionsTest.class,
 			OverloadResolutionTest8.class,
+			LambdaShapeTests.class,
 			NullTypeAnnotationTest.class, // tests type inference
 		};
 	}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
index 3288895..9f37664 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnlyJava8Tests.java
@@ -41,6 +41,7 @@ import org.eclipse.jdt.core.tests.compiler.regression.JSR308SpecSnippetTests;
 import org.eclipse.jdt.core.tests.compiler.regression.JSR335ClassFileTest;
 import org.eclipse.jdt.core.tests.compiler.regression.LambdaExpressionsTest;
 import org.eclipse.jdt.core.tests.compiler.regression.LambdaRegressionTest;
+import org.eclipse.jdt.core.tests.compiler.regression.LambdaShapeTests;
 import org.eclipse.jdt.core.tests.compiler.regression.MethodParametersAttributeTest;
 import org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest;
 import org.eclipse.jdt.core.tests.compiler.regression.NegativeTypeAnnotationTest;
@@ -78,6 +79,7 @@ public class RunOnlyJava8Tests extends TestCase {
 			NegativeLambdaExpressionsTest.class,
 			LambdaExpressionsTest.class,
 			LambdaRegressionTest.class,
+			LambdaShapeTests.class,
 			SerializableLambdaTest.class,
 			OverloadResolutionTest8.class,
 			JSR335ClassFileTest.class,
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
index e7af82f..3845938 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -147,4 +147,8 @@ public void branchChainTo(BranchLabel label) {
 		this.statements[this.statements.length - 1].branchChainTo(label);
 	}
 }
+@Override
+public boolean doesNotCompleteNormally() {
+	return this.statements != null && this.statements.length > 0 && this.statements[this.statements.length - 1].doesNotCompleteNormally();
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java
index 79f2eb0..47cfc81 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BreakStatement.java
@@ -95,4 +95,8 @@ public void traverse(ASTVisitor visitor, BlockScope blockscope) {
 	visitor.visit(this, blockscope);
 	visitor.endVisit(this, blockscope);
 }
+@Override
+public boolean doesNotCompleteNormally() {
+	return true;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
index 1337cdd..11a20e5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
@@ -98,4 +98,8 @@ public void traverse(ASTVisitor visitor, 	BlockScope blockScope) {
 	visitor.visit(this, blockScope);
 	visitor.endVisit(this, blockScope);
 }
+@Override
+public boolean doesNotCompleteNormally() {
+	return true;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
index 267ba15..a5f7e05 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -226,4 +226,16 @@ public void traverse(ASTVisitor visitor, BlockScope scope) {
 	}
 	visitor.endVisit(this, scope);
 }
+
+@Override
+public boolean doesNotCompleteNormally() {
+	Constant cst = this.condition.constant;
+	boolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
+	cst = this.condition.optimizedBooleanConstant();
+	boolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
+	
+	if (isConditionTrue || isConditionOptimizedTrue)
+		return this.action == null || !this.action.breaksOutOfLoop();
+	return this.action.doesNotCompleteNormally();
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
index 37dac8e..5b0b2e5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -427,4 +427,14 @@ public class ForStatement extends Statement {
 		}
 		visitor.endVisit(this, blockScope);
 	}
+
+	@Override
+	public boolean doesNotCompleteNormally() {
+		Constant cst = this.condition.constant;
+		boolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
+		cst = this.condition.optimizedBooleanConstant();
+		boolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
+		
+		return (isConditionTrue || isConditionOptimizedTrue) && (this.action == null || !this.action.breaksOutOfLoop());
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
index e794b07..60bcadd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForeachStatement.java
@@ -576,4 +576,9 @@ public class ForeachStatement extends Statement {
 		}
 		visitor.endVisit(this, blockScope);
 	}
+
+	@Override
+	public boolean doesNotCompleteNormally() {
+		return false; // may not be entered at all.
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index 254ff71..5ee4535 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -284,4 +284,9 @@ public void traverse(ASTVisitor visitor, BlockScope blockScope) {
 	}
 	visitor.endVisit(this, blockScope);
 }
+
+@Override
+public boolean doesNotCompleteNormally() {
+	return this.thenStatement != null && this.thenStatement.doesNotCompleteNormally() && this.elseStatement != null && this.elseStatement.doesNotCompleteNormally();
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java
index 9fffa3e..d7cc8c2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -140,4 +140,9 @@ public class LabeledStatement extends Statement {
 		}
 		visitor.endVisit(this, blockScope);
 	}
+
+	@Override
+	public boolean doesNotCompleteNormally() {
+		return this.statement.doesNotCompleteNormally();
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 9357c04..baecd6a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -422,6 +422,12 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 			new ReturnStatement(expression, expression.sourceStart, expression.sourceEnd, true).resolve(this.scope); // :-) ;-)
 		} else {
 			this.body.resolve(this.scope);
+			/* At this point, shape analysis is complete for ((see returnsExpression(...))
+		       - a lambda with an expression body,
+			   - a lambda with a block body in which we saw a return statement naked or otherwise.
+		    */
+			if (!this.returnsVoid && !this.returnsValue)
+				this.valueCompatible = this.body.doesNotCompleteNormally();
 		}
 		if (this.expectedType instanceof IntersectionTypeBinding18) {
 			ReferenceBinding[] intersectingTypes =  ((IntersectionTypeBinding18)this.expectedType).intersectingTypes;
@@ -441,7 +447,7 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		if (this.shouldCaptureInstance && this.scope.isConstructorCall) {
 			this.scope.problemReporter().fieldsOrThisBeforeConstructorInvocation(this);
 		}
-		return this.resolvedType;
+		return argumentsHaveErrors ? this.resolvedType = null : this.resolvedType;
 	}
 
 	private ReferenceBinding findGroundTargetType(BlockScope blockScope, TypeBinding targetType, boolean argumentTypesElided) {
@@ -475,20 +481,13 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		return this.arguments.length > 0 && this.arguments[0].hasElidedType();
 	}
 
-	private boolean doesNotCompleteNormally() {
+	private void analyzeExceptions() {
 		try {
-			return this.body.analyseCode(this.scope, 
+			this.body.analyseCode(this.scope, 
 									 new ExceptionHandlingFlowContext(null, this, Binding.NO_EXCEPTIONS, null, this.scope, FlowInfo.DEAD_END), 
-									 UnconditionalFlowInfo.fakeInitializedFlowInfo(this.scope.outerMostMethodScope().analysisIndex, this.scope.referenceType().maxFieldCount)) == FlowInfo.DEAD_END;
-		} catch (RuntimeException e) {
-			/* See https://bugs.eclipse.org/bugs/show_bug.cgi?id=432110 for an example of where the flow analysis can result in run time error.
-			   We can recover and do the right thing by falling back on the results of the structural analysis done already and be right 99.99%
-			   of the time. Strictly speaking void/value compatibility is not a structural property. { throw NPE(); } is value compatible despite
-			   structurally there not being a return statement. Likewise { if (x) return value; } is not value compatible despite there being a
-			   return statement. We will miss the former case, but that is mostly pedantic. We would misclassify the latter case *here*, but it
-			   would be caught elsewhere, so it should all wash out in the end. 
-			*/ 
-			return this.valueCompatible;
+									 UnconditionalFlowInfo.fakeInitializedFlowInfo(this.scope.outerMostMethodScope().analysisIndex, this.scope.referenceType().maxFieldCount));
+		} catch (Exception e) {
+			// drop silently.
 		}
 	}
 	public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, final FlowInfo flowInfo) {
@@ -713,9 +712,11 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		    	if (returnStatement.expression != null) {
 		    		LambdaExpression.this.valueCompatible = true;
 		    		LambdaExpression.this.voidCompatible = false;
+		    		LambdaExpression.this.returnsValue = true;
 		    	} else {
 		    		LambdaExpression.this.voidCompatible = true;
 		    		LambdaExpression.this.valueCompatible = false;
+		    		LambdaExpression.this.returnsVoid = true;
 		    	}
 		    	return false;
 		    }
@@ -723,7 +724,7 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		if (this.body instanceof Expression) {
 			// When completion is still in progress, it is not possible to ask if the expression constitutes a statement expression. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=435219
 			this.voidCompatible = this.assistNode ? true : ((Expression) this.body).statementExpression();
-			this.valueCompatible = true;
+			this.valueCompatible = true; // expression could be of type void - we can't determine that as we are working with unresolved expressions, for potential compatibility it is OK.
 		} else {
 			// For code assist, we need to be a bit tolerant/fuzzy here: the code is being written "just now", if we are too pedantic, selection/completion will break;
 			if (this.assistNode) {
@@ -731,10 +732,8 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 				this.valueCompatible = true;
 			}
 			this.body.traverse(new ShapeComputer(), null);
-			Block block = (Block) this.body;
-			// support the idiom that { throw new Exception(); } is value compatible.
-			if (block.statements != null && block.statements.length == 1 && block.statements[0] instanceof ThrowStatement)
-				this.valueCompatible = true;
+			if (!this.returnsValue && !this.returnsVoid)
+				this.valueCompatible = this.body.doesNotCompleteNormally();
 		}
 	}
 	
@@ -775,7 +774,7 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		
 		LambdaExpression copy = null;
 		try {
-			copy = cachedResolvedCopy(targetType, argumentsTypeElided()); // if argument types are elided, we don't care for result expressions against *this* target, any port in a storm is ok.
+			copy = cachedResolvedCopy(targetType, argumentsTypeElided()); // if argument types are elided, we don't care for result expressions against *this* target, any valid target is OK.
 		} catch (CopyFailureException cfe) {
 			if (this.assistNode)
 				return true; // can't type check result expressions, just say yes.
@@ -784,30 +783,7 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		if (copy == null)
 			return false;
 		
-		IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
-		final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
-		boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
-		compilerOptions.isAnnotationBasedNullAnalysisEnabled = false;
-		try {
-			/* At this point, shape analysis is complete for ((see returnsExpression(...))
-			       - a lambda with an expression body,
-				   - a lambda with a block body in which we saw a return statement naked or otherwise.
-			*/
-			if (copy.body instanceof Block && !copy.returnsVoid && !copy.returnsValue && !copy.valueCompatible) {
-				// Do not proceed with data/control flow analysis if resolve encountered errors.
-				if (copy.hasIgnoredMandatoryErrors || enclosingScopesHaveErrors()) {
-					if (isPertinentToApplicability(targetType, null))
-						if (copy.arguments.length != 0) // ?? Needs check. 
-							return false;
-				} else {
-					copy.valueCompatible = copy.doesNotCompleteNormally();
-				}
-			}
-		} finally {
-			compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
-			this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
-		}
-
+		// copy here is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and result expressions have been gathered.
 		targetType = findGroundTargetType(this.enclosingScope, targetType, argumentsTypeElided());
 		MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true);
 		if (sam.returnType.id == TypeIds.T_void) {
@@ -897,22 +873,22 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		if (copy == null) {
 			return null;
 		}
-		final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
-		boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
-		IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
-		try {
-			compilerOptions.isAnnotationBasedNullAnalysisEnabled = false;
-			// Do not proceed with data/control flow analysis if resolve encountered errors.
-			if (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {
-				// value compatibility of block lambda's is the only open question.
-				copy.valueCompatible |= copy.doesNotCompleteNormally();
-			} else {
-				if (!copy.returnsVoid)
-					copy.valueCompatible = true; // optimistically, TODO: is this OK??
+		
+		/* copy is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and 
+		   result expressions have been gathered. Proceed with flow analysis to gather precise thrown exceptions. However, we can do this only
+		   if resolve encountered no errors - if it did, we will miss precise exceptions, but that is OK.
+		*/
+		if (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {
+			final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
+			boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
+			IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
+			try {
+				compilerOptions.isAnnotationBasedNullAnalysisEnabled = false;
+				copy.analyzeExceptions();
+			} finally {
+				compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
+				this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
 			}
-		} finally {
-			compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
-			this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
 		}
 		return copy;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 0aafbc1..8844347 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -170,6 +170,10 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	flowContext.recordAbruptExit();
 	return FlowInfo.DEAD_END;
 }
+@Override
+public boolean doesNotCompleteNormally() {
+	return true;
+}
 void checkAgainstNullAnnotation(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
 	int nullStatus = this.expression.nullStatus(flowInfo, flowContext);
 	long tagBits;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index bfa50da..fb6710b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -36,6 +36,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.*;
 import org.eclipse.jdt.internal.compiler.flow.*;
@@ -78,6 +79,10 @@ public abstract class Statement extends ASTNode {
 	}
 public abstract FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo);
 
+public boolean doesNotCompleteNormally() {
+	return false;
+}
+
 	public static final int NOT_COMPLAINED = 0;
 	public static final int COMPLAINED_FAKE_REACHABLE = 1;
 	public static final int COMPLAINED_UNREACHABLE = 2;
@@ -203,6 +208,50 @@ public void branchChainTo(BranchLabel label) {
 	// do nothing by default
 }
 
+public boolean breaksOutOfLoop() {
+	class LoopVisitor extends ASTVisitor {
+		Statement loopBody;
+		boolean breaks;
+		public LoopVisitor(Statement statement) {
+			this.loopBody = statement;
+			this.breaks = false;
+		}
+		public boolean visit(TypeDeclaration type, BlockScope skope) {
+			return false;
+		}
+		public boolean visit(TypeDeclaration type, ClassScope skope) {
+			return false;
+		}
+		public boolean visit(LambdaExpression lambda, BlockScope skope) {
+			return false;
+		}
+		public boolean visit(WhileStatement whileStatement, BlockScope skope) {
+			return false;
+		}
+		public boolean visit(DoStatement doStatement, BlockScope skope) {
+			return false;
+		}
+		public boolean visit(ForeachStatement foreachStatement, BlockScope skope) {
+			return false;
+		}
+		public boolean visit(ForStatement forStatement, BlockScope skope) {
+			return false;
+		}
+		public boolean visit(SwitchStatement switchStatement, BlockScope skope) {
+			return false;
+		}
+		public boolean visit(BreakStatement breakStatement, BlockScope skope) {
+	    	this.breaks = true;
+	    	return false;
+	    }
+		public boolean breaksOutOfLoop() {
+			this.loopBody.traverse(this, null);
+			return this.breaks;
+		}
+	}
+	return new LoopVisitor(this).breaksOutOfLoop();
+}
+
 // Report an error if necessary (if even more unreachable than previously reported
 // complaintLevel = 0 if was reachable up until now, 1 if fake reachable (deadcode), 2 if fatal unreachable (error)
 public int complainIfUnreachable(FlowInfo flowInfo, BlockScope scope, int previousComplaintLevel, boolean endOfBlock) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
index 90f3842..eb8e1a1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
@@ -632,4 +632,23 @@ public class SwitchStatement extends Statement {
 			label.becomeDelegateFor(this.breakLabel);
 		}
 	}
+
+	@Override
+	public boolean doesNotCompleteNormally() {
+		if (this.statements == null || this.statements.length == 0)
+			return false;
+		Statement lastStatement = null;
+		for (int i = 0, length = this.statements.length; i < length; i++) {
+			Statement statement = this.statements[i];
+			if (statement instanceof CaseStatement) {
+				if (lastStatement != null)
+					if (lastStatement instanceof BreakStatement)
+						return false;
+			} else {
+				lastStatement = statement;
+			}
+		}
+		lastStatement = this.statements[this.statements.length - 1];
+		return lastStatement instanceof BreakStatement ? false : lastStatement.doesNotCompleteNormally();
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
index b2c6dfd..a098e42 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
@@ -213,4 +213,9 @@ public void traverse(ASTVisitor visitor, BlockScope blockScope) {
 	}
 	visitor.endVisit(this, blockScope);
 }
+
+@Override
+public boolean doesNotCompleteNormally() {
+	return this.block.doesNotCompleteNormally();
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
index 32967ca..666d002 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
@@ -87,4 +87,9 @@ public void traverse(ASTVisitor visitor, BlockScope blockScope) {
 		this.exception.traverse(visitor, blockScope);
 	visitor.endVisit(this, blockScope);
 }
+
+@Override
+public boolean doesNotCompleteNormally() {
+	return true;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index f696fad..80c2f88 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -1210,4 +1210,18 @@ protected void verifyDuplicationAndOrder(int length, TypeBinding[] argumentTypes
 		}
 	}
 }
+@Override
+public boolean doesNotCompleteNormally() {
+	if (!this.tryBlock.doesNotCompleteNormally()) {
+		return (this.finallyBlock != null) ? this.finallyBlock.doesNotCompleteNormally() : false;
+	}
+	if (this.catchBlocks != null) {
+		for (int i = 0; i < this.catchBlocks.length; i++) {
+			if (!this.catchBlocks[i].doesNotCompleteNormally()) {
+				return (this.finallyBlock != null) ? this.finallyBlock.doesNotCompleteNormally() : false;
+			}
+		}
+	}
+	return true;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
index 837f432..362b045 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -285,4 +285,13 @@ public class WhileStatement extends Statement {
 		}
 		visitor.endVisit(this, blockScope);
 	}
+
+	@Override
+	public boolean doesNotCompleteNormally() {
+		Constant cst = this.condition.constant;
+		boolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
+		cst = this.condition.optimizedBooleanConstant();
+		boolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
+		return (isConditionTrue || isConditionOptimizedTrue) && (this.action == null || !this.action.breaksOutOfLoop());
+	}
 }
commit 47fec6f9bf985f83eeb8e1c5ce1ae9eaeda93048
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sat Nov 8 12:02:41 2014 +0530

    Follow on changes for bug 424290 - lambda shape analysis

103	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
index 7c4fb9a..280951b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
@@ -1904,6 +1904,109 @@ public void testDo4() {
 		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
 		"----------\n");
 }
+public void testDo5() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				break;\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo6() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				if (args == null) break;\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo7() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				if (args == null) throw new RuntimeException();\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo8() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	int foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"   static void goo(I i) {\n" +
+			"		System.out.println(\"goo(I)\");\n" +
+			"   }\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				throw new RuntimeException();\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"goo(I)");
+}
 public void testForeach() {
 	this.runNegativeTest(
 		new String[] {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
index a5f7e05..d38c938 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
@@ -236,6 +236,8 @@ public boolean doesNotCompleteNormally() {
 	
 	if (isConditionTrue || isConditionOptimizedTrue)
 		return this.action == null || !this.action.breaksOutOfLoop();
+	if (this.action == null || this.action.breaksOutOfLoop())
+		return false;
 	return this.action.doesNotCompleteNormally();
 }
 }
commit 48a78bfcb529886e24e5f62b1bc56f7d3678e46a
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sat Nov 8 23:35:32 2014 +0530

    Precise exception analysis for Bug 424290 + bug 429430

40	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
0	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
36	52	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
0	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
0	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
0	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
32	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionInferenceFlowContext.java
19	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
index f29e5d2..302a02c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
@@ -2647,8 +2647,7 @@ public void testBug429430a() {
 		"----------\n");
 }
 // one of two incompatible exceptions is caught
-// FIXME: should be possible to infer X to EmptyStream
-public void _testBug429430b() {
+public void testBug429430b() {
 	runConformTest(
 		new String[] {
 			"Main.java",
@@ -2675,6 +2674,45 @@ public void _testBug429430b() {
 			"}\n"
 		});
 }
+public void testBug429430b2() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.io.*;\n" +
+			"@SuppressWarnings(\"serial\") class EmptyStream extends Exception {}\n" +
+			"public class X {\n" +
+			"  public static interface Closer<T, V extends Exception> {\n" +
+			"    void closeIt(T it) throws V;\n" +
+			"  }\n" +
+			"\n" +
+			"  public static void close( Closer<InputStream, EmptyStream> closer, InputStream it ) throws EmptyStream {\n" +
+			"    closer.closeIt(it);\n" +
+			"  }\n" +
+			"\n" +
+			"  public static void main(String[] args) throws EmptyStream {\n" +
+			"    InputStream in = new ByteArrayInputStream(\"hello\".getBytes());\n" +
+			"    close( x ->  {\n" +
+			"			if (x == null)\n" +
+			"				throw new IOException();\n" +
+			"			else \n" +
+			"				throw new EmptyStream(); \n" +
+			"		},\n" +
+			"		in);\n" +
+			"  }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 16)\n" + 
+		"	throw new IOException();\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Unhandled exception type IOException\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 18)\n" + 
+		"	throw new EmptyStream(); \n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally\n" + 
+		"----------\n");
+}
 // ensure type annotation on exception doesn't confuse the inference
 public void testBug429430c() {
 	Map options = getCompilerOptions();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index fd5ea25..40209ae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -490,7 +490,6 @@ public TypeBinding resolveType(BlockScope scope) {
 		new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
 				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
 	}
-	recordExceptionsForEnclosingLambda(scope, this.binding.thrownExceptions);
 	return this.resolvedType;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 5d8d70c..3578986 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -57,6 +57,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.CodeStream;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
 import org.eclipse.jdt.internal.compiler.flow.ExceptionHandlingFlowContext;
+import org.eclipse.jdt.internal.compiler.flow.ExceptionInferenceFlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo;
@@ -482,10 +483,12 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 	}
 
 	private void analyzeExceptions() {
+		ExceptionHandlingFlowContext ehfc;
 		try {
 			this.body.analyseCode(this.scope, 
-									 new ExceptionHandlingFlowContext(null, this, Binding.NO_EXCEPTIONS, null, this.scope, FlowInfo.DEAD_END), 
+									 ehfc = new ExceptionInferenceFlowContext(null, this, Binding.NO_EXCEPTIONS, null, this.scope, FlowInfo.DEAD_END), 
 									 UnconditionalFlowInfo.fakeInitializedFlowInfo(this.scope.outerMostMethodScope().analysisIndex, this.scope.referenceType().maxFieldCount));
+			this.thrownExceptions = ehfc.extendedExceptions == null ? Collections.emptySet() : new HashSet<TypeBinding>(ehfc.extendedExceptions);
 		} catch (Exception e) {
 			// drop silently.
 		}
@@ -774,7 +777,7 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		
 		LambdaExpression copy = null;
 		try {
-			copy = cachedResolvedCopy(targetType, argumentsTypeElided()); // if argument types are elided, we don't care for result expressions against *this* target, any valid target is OK.
+			copy = cachedResolvedCopy(targetType, argumentsTypeElided(), false); // if argument types are elided, we don't care for result expressions against *this* target, any valid target is OK.
 		} catch (CopyFailureException cfe) {
 			if (this.assistNode)
 				return true; // can't type check result expressions, just say yes.
@@ -812,7 +815,7 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		private static final long serialVersionUID = 1L;
 	}
 
-	private LambdaExpression cachedResolvedCopy(TypeBinding targetType, boolean anyTargetOk) {
+	private LambdaExpression cachedResolvedCopy(TypeBinding targetType, boolean anyTargetOk, boolean requireExceptionAnalysis) {
 
 		targetType = findGroundTargetType(this.enclosingScope, targetType, argumentsTypeElided());
 		if (targetType == null)
@@ -828,30 +831,39 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		LambdaExpression copy = null;
 		if (this.copiesPerTargetType != null) {
 			copy = this.copiesPerTargetType.get(targetType);
-			if (copy != null)
-				return copy;
-			if (anyTargetOk && this.copiesPerTargetType.values().size() > 0)
-				return this.copiesPerTargetType.values().iterator().next();
+			if (copy == null) {
+				if (anyTargetOk && this.copiesPerTargetType.values().size() > 0)
+					copy = this.copiesPerTargetType.values().iterator().next();
+			}
 		}
-		
+		final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
+		boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
 		IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
+		compilerOptions.isAnnotationBasedNullAnalysisEnabled = false;
 		try {
-			copy = copy();
-			if (copy == null)
-				throw new CopyFailureException();
-			
-			copy.setExpressionContext(this.expressionContext);
-			copy.setExpectedType(targetType);
-			TypeBinding type = copy.resolveType(this.enclosingScope);
-			if (type == null || !type.isValidBinding())
-				return null;
-	
-			if (this.copiesPerTargetType == null)
-				this.copiesPerTargetType = new HashMap<TypeBinding, LambdaExpression>();
-			this.copiesPerTargetType.put(targetType, copy);
-			
+			if (copy == null) {
+				copy = copy();
+				if (copy == null)
+					throw new CopyFailureException();
+
+				copy.setExpressionContext(this.expressionContext);
+				copy.setExpectedType(targetType);
+				TypeBinding type = copy.resolveType(this.enclosingScope);
+				if (type == null || !type.isValidBinding())
+					return null;
+
+				if (this.copiesPerTargetType == null)
+					this.copiesPerTargetType = new HashMap<TypeBinding, LambdaExpression>();
+				this.copiesPerTargetType.put(targetType, copy);
+			}
+			if (!requireExceptionAnalysis)
+				return copy;
+			if (copy.thrownExceptions == null)
+				if (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors())
+					copy.analyzeExceptions();
 			return copy;
 		} finally {
+			compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
 			this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
 		}
 	}
@@ -866,30 +878,10 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 	public LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope) {
 		LambdaExpression copy = null;
 		try {
-			copy = cachedResolvedCopy(targetType, false);
+			copy = cachedResolvedCopy(targetType, false, true);
 		} catch (CopyFailureException cfe) {
 			return null;
 		}
-		if (copy == null) {
-			return null;
-		}
-		
-		/* copy is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and 
-		   result expressions have been gathered. Proceed with flow analysis to gather precise thrown exceptions. However, we can do this only
-		   if resolve encountered no errors - if it did, we will miss precise exceptions, but that is OK.
-		*/
-		if (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {
-			final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
-			boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
-			IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
-			try {
-				compilerOptions.isAnnotationBasedNullAnalysisEnabled = false;
-				copy.analyzeExceptions();
-			} finally {
-				compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
-				this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
-			}
-		}
 		return copy;
 	}
 
@@ -923,7 +915,7 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		if (r1.isCompatibleWith(r2, skope))
 			return true;
 		
-		LambdaExpression copy = cachedResolvedCopy(s, true /* any resolved copy is good */);
+		LambdaExpression copy = cachedResolvedCopy(s, true /* any resolved copy is good */, false); // we expect a cached copy - otherwise control won't reach here.
 		Expression [] returnExpressions = copy.resultExpressions;
 		int returnExpressionsLength = returnExpressions == null ? 0 : returnExpressions.length;
 		
@@ -1077,14 +1069,6 @@ public class LambdaExpression extends FunctionalExpression implements IPolyExpre
 		}
 	}
 	
-	public void throwsException(TypeBinding exceptionType) {
-		if (this.expressionContext != INVOCATION_CONTEXT)
-			return;
-		if (this.thrownExceptions == null)
-			this.thrownExceptions = new HashSet<TypeBinding>();
-		this.thrownExceptions.add(exceptionType);
-	}
-
 	public Set<TypeBinding> getThrownExceptions() {
 		if (this.thrownExceptions == null)
 			return Collections.emptySet();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 500343f..8b01214 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -863,7 +863,6 @@ public TypeBinding resolveType(BlockScope scope) {
 	if (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {
 		scope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);
 	}
-	recordExceptionsForEnclosingLambda(scope, this.binding.thrownExceptions);
 	return (this.resolvedType.tagBits & TagBits.HasMissingType) == 0
 				? this.resolvedType
 				: null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index fb6710b..b2ac751 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -412,16 +412,4 @@ protected MethodBinding findConstructorBinding(BlockScope scope, Invocation site
 	resolvePolyExpressionArguments(site, ctorBinding, argumentTypes, scope);
 	return ctorBinding;
 }
-/**
- * If an exception-throwing statement is resolved within the scope of a lambda, record the exception type(s).
- * It is likely wrong to do this during resolve, should probably use precise flow information.
- */
-protected void recordExceptionsForEnclosingLambda(BlockScope scope, TypeBinding... thrownExceptions) {
-	MethodScope methodScope = scope.methodScope();
-	if (methodScope != null && methodScope.referenceContext instanceof LambdaExpression) {
-		LambdaExpression lambda = (LambdaExpression) methodScope.referenceContext;
-		for (int i = 0; i < thrownExceptions.length; i++)
-			lambda.throwsException(thrownExceptions[i]);
-	}
-}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
index 666d002..a8f2626 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ThrowStatement.java
@@ -68,7 +68,6 @@ public StringBuffer printStatement(int indent, StringBuffer output) {
 
 public void resolve(BlockScope scope) {
 	this.exceptionType = this.exception.resolveType(scope);
-	recordExceptionsForEnclosingLambda(scope, this.exceptionType);
 	if (this.exceptionType != null && this.exceptionType.isValidBinding()) {
 		if (this.exceptionType == TypeBinding.NULL) {
 			if (scope.compilerOptions().complianceLevel <= ClassFileConstants.JDK1_3){
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionInferenceFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionInferenceFlowContext.java
new file mode 100644
index 0000000..a94d4d0
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/ExceptionInferenceFlowContext.java
@@ -0,0 +1,32 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.flow;
+
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
+
+/**
+ * Reflects the context of code analysis, keeping track of enclosing
+ * try statements, exception handlers, etc...
+ */
+
+public class ExceptionInferenceFlowContext extends ExceptionHandlingFlowContext {
+	public ExceptionInferenceFlowContext(
+			FlowContext parent,
+			ASTNode associatedNode,
+			ReferenceBinding[] handledExceptions,
+			FlowContext initializationParent,
+			BlockScope scope,
+			UnconditionalFlowInfo flowInfo) {
+	super(parent, associatedNode, handledExceptions, initializationParent, scope, flowInfo);
+}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index af0b19c..79c475b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -289,16 +289,18 @@ public void checkExceptionHandlers(TypeBinding raisedException, ASTNode location
 			if (exceptionContext.isMethodContext) {
 				if (raisedException.isUncheckedException(false))
 					return;
+				boolean shouldMergeUnhandledExceptions = exceptionContext instanceof ExceptionInferenceFlowContext;
 
 				// anonymous constructors are allowed to throw any exceptions (their thrown exceptions
 				// clause will be fixed up later as per JLS 8.6).
-				if (exceptionContext.associatedNode instanceof AbstractMethodDeclaration){
+				if (exceptionContext.associatedNode instanceof AbstractMethodDeclaration) {
 					AbstractMethodDeclaration method = (AbstractMethodDeclaration)exceptionContext.associatedNode;
-					if (method.isConstructor() && method.binding.declaringClass.isAnonymousType()){
-
-						exceptionContext.mergeUnhandledException(raisedException);
-						return; // no need to complain, will fix up constructor exceptions
-					}
+					if (method.isConstructor() && method.binding.declaringClass.isAnonymousType())
+						shouldMergeUnhandledExceptions = true;
+				}
+				if (shouldMergeUnhandledExceptions) {
+					exceptionContext.mergeUnhandledException(raisedException);
+					return; // no need to complain, will fix up constructor/lambda exceptions
 				}
 				break; // not handled anywhere, thus jump to error handling
 			}
@@ -431,20 +433,22 @@ public void checkExceptionHandlers(TypeBinding[] raisedExceptions, ASTNode locat
 						}
 					}
 				}
+				boolean shouldMergeUnhandledException = exceptionContext instanceof ExceptionInferenceFlowContext;
 				// anonymous constructors are allowed to throw any exceptions (their thrown exceptions
 				// clause will be fixed up later as per JLS 8.6).
-				if (exceptionContext.associatedNode instanceof AbstractMethodDeclaration){
+				if (exceptionContext.associatedNode instanceof AbstractMethodDeclaration) {
 					AbstractMethodDeclaration method = (AbstractMethodDeclaration)exceptionContext.associatedNode;
-					if (method.isConstructor() && method.binding.declaringClass.isAnonymousType()){
-
-						for (int i = 0; i < raisedCount; i++) {
-							TypeBinding raisedException;
-							if ((raisedException = raisedExceptions[i]) != null) {
-								exceptionContext.mergeUnhandledException(raisedException);
-							}
+					if (method.isConstructor() && method.binding.declaringClass.isAnonymousType())
+						shouldMergeUnhandledException = true;
+				}
+				if (shouldMergeUnhandledException) {
+					for (int i = 0; i < raisedCount; i++) {
+						TypeBinding raisedException;
+						if ((raisedException = raisedExceptions[i]) != null) {
+							exceptionContext.mergeUnhandledException(raisedException);
 						}
-						return; // no need to complain, will fix up constructor exceptions
 					}
+					return; // no need to complain, will fix up constructor/lambda exceptions
 				}
 				break; // not handled anywhere, thus jump to error handling
 			}
commit 3b34d278ba258a10a58d188a2047da908229b941
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Mon Nov 10 09:38:29 2014 +0530

    Several more tests and a few bug fixes for Bug 424290 - [1.8] Evaluate
    alternate options for lambda shape analysis.

706	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
10	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
8	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
10	5	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
7	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java
52	35	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
12	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
16	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
6	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
index 9a92f6e..860704c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaShapeTests.java
@@ -2064,6 +2064,553 @@ public void testDo8() {
 		},
 		"goo(I)");
 }
+public void testDo9() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				continue;\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"J");
+}
+public void testDo10() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"               if (true) \n" +
+			"				    continue;\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo11() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"               if (true) \n" +
+			"				    continue;\n" +
+			"               else \n" +
+			"                   continue;\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo12() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"               if (true) \n" +
+			"				    continue;\n" +
+			"               else \n" +
+			"                   throw new RuntimeException();\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo13() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"               if (true) \n" +
+			"                   throw new RuntimeException();\n" +
+			"               else \n" +
+			"                   throw new RuntimeException();\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"I");
+}
+public void testDo14() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"               if (true) { \n" +
+			"                   System.out.println();\n" +
+			"				    continue;\n" +
+			"               }\n" +
+			"               else {\n" +
+			"                   continue;\n" +
+			"               }\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 12)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo15() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			label:\n" +
+			"			do {\n" +
+			"				continue label;\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo16() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				blah:\n" +
+			"				continue;\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo17() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				synchronized(args) {\n" +
+			"				    continue;\n" +
+			"               }\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 9)\n" + 
+		"	goo(() -> {\n" + 
+		"	^^^\n" + 
+		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
+		"----------\n");
+}
+public void testDo18() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				try {\n" +
+			"					continue;\n" +
+			"				} finally {\n" +
+			"					throw new RuntimeException();\n" +
+			"				}\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"I");
+}
+public void testDo19() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				try {\n" +
+			"					continue;\n" +
+			"				} finally {\n" +
+			"				}\n" +
+			"			} while (false);	\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"J");
+}
+public void testDo20() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				switch (args.length){\n" +
+			"				default:\n" +
+			"					continue;\n" +
+			"				}\n" +
+			"			} while (false);	\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"J");
+}
+public void testDo21() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				while (true) {\n" +
+			"					continue;\n" +
+			"				}\n" +
+			"			} while (false);	\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"I");
+}
+public void testDo22() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			label:\n" +
+			"			do {\n" +
+			"				while (true) {\n" +
+			"					continue label;\n" +
+			"				}\n" +
+			"			} while (false);	\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"J");
+}
+public void testDo23() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			label:\n" +
+			"			while (true) {\n" +
+			"				while (true) {\n" +
+			"					continue label;\n" +
+			"				}\n" +
+			"			}	\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"I");
+}
+public void testDo24() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			label:\n" +
+			"			do {\n" +
+			"				for (;;) {\n" +
+			"					continue label;\n" +
+			"				}\n" +
+			"			} while (false);	\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"J");
+}
+public void testDo25() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			label:\n" +
+			"			do {\n" +
+			"				do {\n" +
+			"					continue label;\n" +
+			"				} while (true);\n" +
+			"			} while (false);	\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"J");
+}
+public void testDo26() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			do {\n" +
+			"				label:\n" +
+			"					while (true) {\n" +
+			"						continue label;\n" +
+			"					}\n" +
+			"			} while (false);\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"I");
+}
 public void testForeach() {
 	this.runNegativeTest(
 		new String[] {
@@ -2514,6 +3061,165 @@ public void testWhileTrue3() {
 		"The method goo(I) in the type X is not applicable for the arguments (() -> {})\n" + 
 		"----------\n");
 }
+public void testLabeledStatement() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			label: \n" +
+			"			while (true) {\n" +
+			"				while (true) {\n" +
+			"					break label;\n" +
+			"				}\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n" 
+		},
+		"J");
+}
+public void testLabeledStatement2() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			outerlabel: \n" +
+			"			label: \n" +
+			"			while (true) {\n" +
+			"				while (true) {\n" +
+			"					break outerlabel;\n" +
+			"				}\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n" 
+		},
+		"J");
+}
+public void testLabeledStatement3() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			outerlabel: \n" +
+			"			label: \n" +
+			"			while (true) {\n" +
+			"				while (true) {\n" +
+			"					break outerlabel;\n" +
+			"				}\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n" 
+		},
+		"J");
+}
+public void testLabeledStatement4() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			outerlabel: \n" +
+			"			label: \n" +
+			"			while (true) {\n" +
+			"				while (true) {\n" +
+			"					break label;\n" +
+			"				}\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n" 
+		},
+		"J");
+}
+public void testLabeledStatement5() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"interface I {\n" +
+			"	String foo();\n" +
+			"}\n" +
+			"interface J {\n" +
+			"	void foo();\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static void goo(I i) {\n" +
+			"		System.out.println(\"I\");\n" +
+			"	}\n" +
+			"	static void goo(J i) {\n" +
+			"		System.out.println(\"J\");\n" +
+			"	}\n" +
+			"	public static void main(String[] args) {\n" +
+			"		goo(() -> {\n" +
+			"			outerlabel: \n" +
+			"			label: \n" +
+			"			while (true) {\n" +
+			"				while (true) {\n" +
+			"					break;\n" +
+			"				}\n" +
+			"			}\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n" 
+		},
+		"I");
+}
 public static Class testClass() {
 	return LambdaShapeTests.class;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
index 3845938..cd07041 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Block.java
@@ -147,8 +147,17 @@ public void branchChainTo(BranchLabel label) {
 		this.statements[this.statements.length - 1].branchChainTo(label);
 	}
 }
+
+// A block does not complete normally if the last statement which we presume is reachable does not complete normally.
 @Override
 public boolean doesNotCompleteNormally() {
-	return this.statements != null && this.statements.length > 0 && this.statements[this.statements.length - 1].doesNotCompleteNormally();
+	int length = this.statements == null ? 0 : this.statements.length;
+	return length > 0 && this.statements[length - 1].doesNotCompleteNormally();
+}
+
+@Override
+public boolean completesByContinue() {
+	int length = this.statements == null ? 0 : this.statements.length;
+	return length > 0 && this.statements[length - 1].completesByContinue();
 }
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
index 11a20e5..a6f946d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ContinueStatement.java
@@ -102,4 +102,8 @@ public void traverse(ASTVisitor visitor, 	BlockScope blockScope) {
 public boolean doesNotCompleteNormally() {
 	return true;
 }
+@Override
+public boolean completesByContinue() {
+	return true;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
index 09e00fe..2912fcd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
@@ -235,9 +235,14 @@ public boolean doesNotCompleteNormally() {
 	boolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
 	
 	if (isConditionTrue || isConditionOptimizedTrue)
-		return this.action == null || !this.action.breaksOut();
-	if (this.action == null || this.action.breaksOut())
+		return this.action == null || !this.action.breaksOut(null);
+	if (this.action == null || this.action.breaksOut(null))
 		return false;
-	return this.action.doesNotCompleteNormally();
+	return this.action.doesNotCompleteNormally() && !this.action.completesByContinue();
+}
+
+@Override
+public boolean completesByContinue() {
+	return this.action.continuesAtOuterLabel();
 }
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
index 2c4ad46..bba7c51 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
@@ -430,11 +430,16 @@ public class ForStatement extends Statement {
 
 	@Override
 	public boolean doesNotCompleteNormally() {
-		Constant cst = this.condition.constant;
-		boolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
-		cst = this.condition.optimizedBooleanConstant();
-		boolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
+		Constant cst = this.condition == null ? null : this.condition.constant;
+		boolean isConditionTrue = cst == null || cst != Constant.NotAConstant && cst.booleanValue() == true;
+		cst = this.condition == null ? null : this.condition.optimizedBooleanConstant();
+		boolean isConditionOptimizedTrue = cst == null ? true : cst != Constant.NotAConstant && cst.booleanValue() == true;
 		
-		return (isConditionTrue || isConditionOptimizedTrue) && (this.action == null || !this.action.breaksOut());
+		return (isConditionTrue || isConditionOptimizedTrue) && (this.action == null || !this.action.breaksOut(null));
+	}
+	
+	@Override
+	public boolean completesByContinue() {
+		return this.action.continuesAtOuterLabel();
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
index 5ee4535..936c293 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/IfStatement.java
@@ -289,4 +289,8 @@ public void traverse(ASTVisitor visitor, BlockScope blockScope) {
 public boolean doesNotCompleteNormally() {
 	return this.thenStatement != null && this.thenStatement.doesNotCompleteNormally() && this.elseStatement != null && this.elseStatement.doesNotCompleteNormally();
 }
+@Override
+public boolean completesByContinue() {
+	return this.thenStatement != null && this.thenStatement.completesByContinue() || this.elseStatement != null && this.elseStatement.completesByContinue();
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java
index d7cc8c2..3045815 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LabeledStatement.java
@@ -143,6 +143,13 @@ public class LabeledStatement extends Statement {
 
 	@Override
 	public boolean doesNotCompleteNormally() {
+		if (this.statement.breaksOut(this.label))
+			return false;
 		return this.statement.doesNotCompleteNormally();
 	}
+	
+	@Override
+	public boolean completesByContinue() {
+		return this.statement instanceof ContinueStatement; // NOT this.statement.continuesAtOuterLabel
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index 6a22df9..6a56fd4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -36,6 +36,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.*;
@@ -79,10 +80,24 @@ public abstract class Statement extends ASTNode {
 	}
 public abstract FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo);
 
+/** Lambda shape analysis: *Assuming* this is reachable, analyze if this completes normally i.e control flow can reach the textually next statement.
+   For blocks, we don't perform intra-reachability analysis. We assume the lambda body is free of intrinsic control flow errors (if such errors
+   exist they will not be flagged by this analysis, but are guaranteed to surface later on.) 
+   
+   @see Block#doesNotCompleteNormally
+*/
 public boolean doesNotCompleteNormally() {
 	return false;
 }
 
+/** Lambda shape analysis: *Assuming* this is reachable, analyze if this completes by continuing i.e control flow cannot reach the textually next statement.
+    This is necessitated by the fact that continue claims to not complete normally. So this is necessary to discriminate between do { continue; } while (false); 
+    which completes normally and do { throw new Exception(); } while (false); which does not complete normally.
+*/
+public boolean completesByContinue() {
+	return false;
+}
+
 	public static final int NOT_COMPLAINED = 0;
 	public static final int COMPLAINED_FAKE_REACHABLE = 1;
 	public static final int COMPLAINED_UNREACHABLE = 2;
@@ -208,48 +223,50 @@ public void branchChainTo(BranchLabel label) {
 	// do nothing by default
 }
 
-public boolean breaksOut() {
-	class ControlStructureVisitor extends ASTVisitor {
-		Statement body;
+// Inspect AST nodes looking for a break statement, descending into nested control structures only when necessary (looking for a break with a specific label.)
+public boolean breaksOut(final char[] label) {
+	return new ASTVisitor() {
+		
 		boolean breaksOut;
-		public ControlStructureVisitor(Statement statement) {
-			this.body = statement;
-			this.breaksOut = false;
-		}
-		public boolean visit(TypeDeclaration type, BlockScope skope) {
-			return false;
-		}
-		public boolean visit(TypeDeclaration type, ClassScope skope) {
-			return false;
-		}
-		public boolean visit(LambdaExpression lambda, BlockScope skope) {
-			return false;
-		}
-		public boolean visit(WhileStatement whileStatement, BlockScope skope) {
-			return false;
-		}
-		public boolean visit(DoStatement doStatement, BlockScope skope) {
-			return false;
-		}
-		public boolean visit(ForeachStatement foreachStatement, BlockScope skope) {
-			return false;
-		}
-		public boolean visit(ForStatement forStatement, BlockScope skope) {
-			return false;
-		}
-		public boolean visit(SwitchStatement switchStatement, BlockScope skope) {
-			return false;
-		}
+		public boolean visit(TypeDeclaration type, BlockScope skope) { return label != null; }
+		public boolean visit(TypeDeclaration type, ClassScope skope) { return label != null; }
+		public boolean visit(LambdaExpression lambda, BlockScope skope) { return label != null;}
+		public boolean visit(WhileStatement whileStatement, BlockScope skope) { return label != null; }
+		public boolean visit(DoStatement doStatement, BlockScope skope) { return label != null; }
+		public boolean visit(ForeachStatement foreachStatement, BlockScope skope) { return label != null; }
+		public boolean visit(ForStatement forStatement, BlockScope skope) { return label != null; }
+		public boolean visit(SwitchStatement switchStatement, BlockScope skope) { return label != null; }
+		
 		public boolean visit(BreakStatement breakStatement, BlockScope skope) {
-	    	this.breaksOut = true;
+			if (label == null || CharOperation.equals(label,  breakStatement.label))
+				this.breaksOut = true;
 	    	return false;
 	    }
+		
 		public boolean breaksOut() {
-			this.body.traverse(this, null);
+			Statement.this.traverse(this, null);
 			return this.breaksOut;
 		}
-	}
-	return new ControlStructureVisitor(this).breaksOut();
+	}.breaksOut();
+}
+
+/* Inspect AST nodes looking for a continue statement with a label, descending into nested control structures.
+   The label is presumed to be NOT attached to this. This condition is certainly true for lambda shape analysis
+   where this analysis triggers only from do {} while (false); situations. See LabeledStatement.continuesAtOuterLabel
+*/
+public boolean continuesAtOuterLabel() {
+	return new ASTVisitor() {
+		boolean continuesToLabel;
+		public boolean visit(ContinueStatement continueStatement, BlockScope skope) {
+			if (continueStatement.label != null)
+				this.continuesToLabel = true;
+	    	return false;
+	    }
+		public boolean continuesAtOuterLabel() {
+			Statement.this.traverse(this, null);
+			return this.continuesToLabel;
+		}
+	}.continuesAtOuterLabel();
 }
 
 // Report an error if necessary (if even more unreachable than previously reported
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
index f4ae940..65a29a5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SwitchStatement.java
@@ -638,9 +638,20 @@ public class SwitchStatement extends Statement {
 		if (this.statements == null || this.statements.length == 0)
 			return false;
 		for (int i = 0, length = this.statements.length; i < length; i++) {
-			if (this.statements[i].breaksOut())
+			if (this.statements[i].breaksOut(null))
 				return false;
 		}
 		return this.statements[this.statements.length - 1].doesNotCompleteNormally();
 	}
+	
+	@Override
+	public boolean completesByContinue() {
+		if (this.statements == null || this.statements.length == 0)
+			return false;
+		for (int i = 0, length = this.statements.length; i < length; i++) {
+			if (this.statements[i].completesByContinue())
+				return true;
+		}
+		return false;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
index a098e42..cd2c2a4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SynchronizedStatement.java
@@ -218,4 +218,8 @@ public void traverse(ASTVisitor visitor, BlockScope blockScope) {
 public boolean doesNotCompleteNormally() {
 	return this.block.doesNotCompleteNormally();
 }
+@Override
+public boolean completesByContinue() {
+	return this.block.completesByContinue();
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
index 80c2f88..3890394 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java
@@ -1224,4 +1224,20 @@ public boolean doesNotCompleteNormally() {
 	}
 	return true;
 }
+@Override
+public boolean completesByContinue() {
+	if (this.tryBlock.completesByContinue()) {
+		return (this.finallyBlock == null) ? true :
+			!this.finallyBlock.doesNotCompleteNormally() || this.finallyBlock.completesByContinue(); 
+	}
+	if (this.catchBlocks != null) {
+		for (int i = 0; i < this.catchBlocks.length; i++) {
+			if (this.catchBlocks[i].completesByContinue()) {
+				return (this.finallyBlock == null) ? true :
+					!this.finallyBlock.doesNotCompleteNormally() || this.finallyBlock.completesByContinue();
+			}
+		}
+	}
+	return this.finallyBlock != null && this.finallyBlock.completesByContinue();
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
index d04b14e..42c3cd7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
@@ -292,6 +292,11 @@ public class WhileStatement extends Statement {
 		boolean isConditionTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
 		cst = this.condition.optimizedBooleanConstant();
 		boolean isConditionOptimizedTrue = cst != Constant.NotAConstant && cst.booleanValue() == true;
-		return (isConditionTrue || isConditionOptimizedTrue) && (this.action == null || !this.action.breaksOut());
+		return (isConditionTrue || isConditionOptimizedTrue) && (this.action == null || !this.action.breaksOut(null));
+	}
+	
+	@Override
+	public boolean completesByContinue() {
+		return this.action.continuesAtOuterLabel();
 	}
 }
