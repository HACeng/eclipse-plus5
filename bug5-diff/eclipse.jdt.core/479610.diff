commit 405faf960c58dafb52aa54f9dbcfeeffbb9bee88
Author: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
Date:   Mon Jan 25 17:36:31 2016 +0530

    bug 479610 - basic code gen support for module-info
    
    Change-Id: I07775ec15c13eff7f10e9cf57405acf0951afdad

8	6	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractSyntaxTreeTest.java
163	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ModuleDeclarationSyntaxTest.java
23	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
138	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
31	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExportReference.java
98	23	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
18	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
10	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
10	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractSyntaxTreeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractSyntaxTreeTest.java
index 6c8d70b..b91ebe3 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractSyntaxTreeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/AbstractSyntaxTreeTest.java
@@ -67,14 +67,16 @@ public class AbstractSyntaxTreeTest extends AbstractCompilerTest implements IDoc
 		this.referenceCompiler = referenceCompiler;
 		this.referenceCompilerTestsScratchArea = referenceCompilerTestsScratchArea;
 	}
-
 	public void checkParse(int parserToCheck, char[] source, String expectedSyntaxErrorDiagnosis,
 			String testName, String expectedUnitToString, ASTVisitor visitor) throws IOException {
-			
-				CompilerOptions options = new CompilerOptions(getCompilerOptions());
-				options.complianceLevel = ClassFileConstants.JDK1_8;
-				options.sourceLevel = ClassFileConstants.JDK1_8;
-				options.targetJDK = ClassFileConstants.JDK1_8;
+		CompilerOptions options = new CompilerOptions(getCompilerOptions());
+		options.complianceLevel = ClassFileConstants.JDK1_8;
+		options.sourceLevel = ClassFileConstants.JDK1_8;
+		options.targetJDK = ClassFileConstants.JDK1_8;
+		checkParse(parserToCheck, source, expectedSyntaxErrorDiagnosis, testName, expectedUnitToString, visitor, options);
+	}
+	public void checkParse(int parserToCheck, char[] source, String expectedSyntaxErrorDiagnosis,
+			String testName, String expectedUnitToString, ASTVisitor visitor, CompilerOptions options) throws IOException {
 			
 				ICompilationUnit sourceUnit = null;
 				CompilationResult compilationResult = null;
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ModuleDeclarationSyntaxTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ModuleDeclarationSyntaxTest.java
new file mode 100644
index 0000000..b8a6d0b
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/ModuleDeclarationSyntaxTest.java
@@ -0,0 +1,163 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.parser;
+
+import java.io.IOException;
+
+import org.eclipse.jdt.core.tests.util.CompilerTestSetup;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+
+import junit.framework.Test;
+
+public class ModuleDeclarationSyntaxTest extends AbstractSyntaxTreeTest {
+
+	public ModuleDeclarationSyntaxTest(String name, String referenceCompiler,
+			String referenceCompilerTestsScratchArea) {
+		super(name, referenceCompiler, referenceCompilerTestsScratchArea);
+	}
+	public static Class<?> testClass() {
+		return ModuleDeclarationSyntaxTest.class;
+	}
+	public void initialize(CompilerTestSetup setUp) {
+		super.initialize(setUp);
+	}
+	public static Test suite() {
+		return buildMinimalComplianceTestSuite(testClass(), F_1_9);
+	}
+
+	static {
+		//		TESTS_NAMES = new String[] { "test0012" };
+		//		TESTS_NUMBERS = new int[] { 133, 134, 135 };
+	}
+	public ModuleDeclarationSyntaxTest(String testName){
+		super(testName, null, null);
+	}
+	public void test0001() throws IOException {
+		String source = 
+				"module com.greetings {\n" +
+				"}\n";
+		String expectedUnitToString = 
+				"module com.greetings {\n" +
+				"}\n";
+		CompilerOptions options = new CompilerOptions(getCompilerOptions());
+		options.complianceLevel = ClassFileConstants.JDK1_9;
+		options.sourceLevel = ClassFileConstants.JDK1_9;
+		options.targetJDK = ClassFileConstants.JDK1_9;
+		checkParse(CHECK_PARSER, source.toCharArray(), null, "module-info", expectedUnitToString, null, options);
+	}
+	public void test0002() throws IOException {
+		String source = 
+				"module com.greetings {\n" +
+				    "requires org.astro;" +
+				"}\n";
+		String expectedUnitToString = 
+				"module com.greetings {\n" +
+				"  requires org.astro;\n" +
+				"}\n";
+		CompilerOptions options = new CompilerOptions(getCompilerOptions());
+		options.complianceLevel = ClassFileConstants.JDK1_9;
+		options.sourceLevel = ClassFileConstants.JDK1_9;
+		options.targetJDK = ClassFileConstants.JDK1_9;
+		checkParse(CHECK_PARSER, source.toCharArray(), null, "module-info", expectedUnitToString, null, options);
+	}
+	public void test0003() throws IOException {
+		String source = 
+				"module org.astro {\n" +
+				"    exports org.astro;\n" +
+				"}\n";
+		String expectedUnitToString = 
+				"module org.astro {\n" +
+				"  exports org.astro;\n" +
+				"}\n";
+		CompilerOptions options = new CompilerOptions(getCompilerOptions());
+		options.complianceLevel = ClassFileConstants.JDK1_9;
+		options.sourceLevel = ClassFileConstants.JDK1_9;
+		options.targetJDK = ClassFileConstants.JDK1_9;
+		checkParse(CHECK_PARSER, source.toCharArray(), null, "module-info", expectedUnitToString, null, options);
+	}
+	public void test0004() throws IOException {
+		String source = 
+				"module org.astro {\n" +
+				"    exports org.astro to com.greetings, com.example1, com.example2;\n" +
+				"}\n";
+		String expectedUnitToString = 
+				"module org.astro {\n" +
+				"  exports org.astro to com.greetings, com.example1, com.example2;\n" +
+				"}\n";
+		CompilerOptions options = new CompilerOptions(getCompilerOptions());
+		options.complianceLevel = ClassFileConstants.JDK1_9;
+		options.sourceLevel = ClassFileConstants.JDK1_9;
+		options.targetJDK = ClassFileConstants.JDK1_9;
+		checkParse(CHECK_PARSER, source.toCharArray(), null, "module-info", expectedUnitToString, null, options);
+	}
+	public void test0005() throws IOException {
+		String source = 
+				"module com.socket {\n" +
+				"    exports com.socket;\n" +
+				"    exports com.socket.spi;\n" +
+				"    uses com.socket.spi.NetworkSocketProvider;\n" +
+				"}\n";
+		String expectedUnitToString = 
+				"module com.socket {\n" +
+				"  exports com.socket;\n" +
+				"  exports com.socket.spi;\n" +
+				"  uses com.socket.spi.NetworkSocketProvider;\n" +
+				"}\n";
+		CompilerOptions options = new CompilerOptions(getCompilerOptions());
+		options.complianceLevel = ClassFileConstants.JDK1_9;
+		options.sourceLevel = ClassFileConstants.JDK1_9;
+		options.targetJDK = ClassFileConstants.JDK1_9;
+		checkParse(CHECK_PARSER, source.toCharArray(), null, "module-info", expectedUnitToString, null, options);
+	}
+	public void test0006() throws IOException {
+		String source = 
+				"module org.fastsocket {\n" +
+				"    requires com.socket;\n" +
+				"    provides com.socket.spi.NetworkSocketProvider\n" +
+				"      with org.fastsocket.FastNetworkSocketProvider;\n" +
+				"}\n";
+		String expectedUnitToString = 
+				"module org.fastsocket {\n" +
+				"  requires com.socket;\n" +
+				"  provides com.socket.spi.NetworkSocketProvider\n" +
+				"    with org.fastsocket.FastNetworkSocketProvider;\n" +
+				"}\n";
+		CompilerOptions options = new CompilerOptions(getCompilerOptions());
+		options.complianceLevel = ClassFileConstants.JDK1_9;
+		options.sourceLevel = ClassFileConstants.JDK1_9;
+		options.targetJDK = ClassFileConstants.JDK1_9;
+		checkParse(CHECK_PARSER, source.toCharArray(), null, "module-info", expectedUnitToString, null, options);
+	}
+	public void test0007() throws IOException {
+		String source = 
+				"module org.fastsocket {\n" +
+				"    requires com.socket;\n" +
+				"    provides com.socket.spi.NetworkSocketProvider;\n" +
+				"}\n";
+		String expectedErrorString = 
+				"----------\n" +
+				"1. ERROR in module-info (at line 3)\n" +
+				"	provides com.socket.spi.NetworkSocketProvider;\n" +
+				"	                        ^^^^^^^^^^^^^^^^^^^^^\n" +
+				"Syntax error on token \"NetworkSocketProvider\", WithClause expected after this token\n" +
+				"----------\n";
+		CompilerOptions options = new CompilerOptions(getCompilerOptions());
+		options.complianceLevel = ClassFileConstants.JDK1_9;
+		options.sourceLevel = ClassFileConstants.JDK1_9;
+		options.targetJDK = ClassFileConstants.JDK1_9;
+		checkParse(CHECK_PARSER, source.toCharArray(), expectedErrorString, "module-info", null, null, options);
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
index c227179..01501b2 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TestAll.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -147,7 +151,24 @@ public static TestSuite getTestSuite(boolean addComplianceDiagnoseTest) {
 		TestCase.RUN_ONLY_ID = null;
 		all.addTest(AbstractCompilerTest.buildComplianceTestSuite(ClassFileConstants.JDK1_8, tests_1_8));
 	}
-
+	if ((possibleComplianceLevels & AbstractCompilerTest.F_1_9) != 0) {
+		ArrayList tests_1_9 = (ArrayList)testClasses.clone();
+		tests_1_9.addAll(TEST_CLASSES_1_5);
+		tests_1_9.add(ParserTest1_7.class);
+		tests_1_9.add(LambdaExpressionSyntaxTest.class);
+		tests_1_9.add(ReferenceExpressionSyntaxTest.class);
+		tests_1_9.add(TypeAnnotationSyntaxTest.class);
+		tests_1_9.add(CompletionParserTest18.class);
+		tests_1_9.add(SelectionParserTest18.class);
+		tests_1_9.add(ModuleDeclarationSyntaxTest.class);
+		// Reset forgotten subsets tests
+		TestCase.TESTS_PREFIX = null;
+		TestCase.TESTS_NAMES = null;
+		TestCase.TESTS_NUMBERS= null;
+		TestCase.TESTS_RANGE = null;
+		TestCase.RUN_ONLY_ID = null;
+		all.addTest(AbstractCompilerTest.buildComplianceTestSuite(ClassFileConstants.JDK1_9, tests_1_9));
+	}
 	return all;
 }
 public static Test suite() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
index 8809103..da799e3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2015 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Jesper S Moller - Contributions for
@@ -50,6 +54,7 @@ import org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;
 import org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;
+import org.eclipse.jdt.internal.compiler.ast.ExportReference;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.FunctionalExpression;
@@ -57,6 +62,8 @@ import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
 import org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
 import org.eclipse.jdt.internal.compiler.ast.Receiver;
@@ -347,6 +354,9 @@ public class ClassFile implements TypeConstants, TypeIds {
 			// to the @fieldBinding
 			attributesNumber += generateDeprecatedAttribute();
 		}
+		if (this.referenceBinding.isModule()) {
+			attributesNumber += generateModuleAttribute();
+		}
 		// add signature attribute
 		char[] genericSignature = this.referenceBinding.genericSignature();
 		if (genericSignature != null) {
@@ -2318,7 +2328,11 @@ public class ClassFile implements TypeConstants, TypeIds {
 	 * @return char[]
 	 */
 	public char[] fileName() {
-		return this.constantPool.UTF8Cache.returnKeyFor(2);
+		// TODO Is there a better way of doing this?
+		char[] name = this.constantPool.UTF8Cache.returnKeyFor(2);
+		if (CharOperation.endsWith(name, TypeConstants.MODULE_INFO_NAME))
+			return TypeConstants.MODULE_INFO_NAME;
+		return name;
 	}
 
 	private void generateAnnotation(Annotation annotation, int currentOffset) {
@@ -2556,6 +2570,127 @@ public class ClassFile implements TypeConstants, TypeIds {
 		this.contentsOffset = localContentsOffset;
 		return 1;
 	}
+	private int generateModuleAttribute() {
+		ModuleDeclaration module = (ModuleDeclaration)this.referenceBinding.scope.referenceContext;
+		int localContentsOffset = this.contentsOffset;
+		if (localContentsOffset + 18 >= this.contents.length) {
+			resizeContents(18);
+		}
+		int moduleAttributeNameIndex =
+			this.constantPool.literalIndex(AttributeNamesConstants.ModuleName);
+		this.contents[localContentsOffset++] = (byte) (moduleAttributeNameIndex >> 8);
+		this.contents[localContentsOffset++] = (byte) moduleAttributeNameIndex;
+		int attrLengthOffset = localContentsOffset;
+		int attrLength = 0;
+		localContentsOffset += 4;
+		// ================= requires section =================
+		/** u2 requires_count;
+	    	{   u2 requires_index;
+	        	u2 requires_flags;
+	    	} requires[requires_count];
+	    **/
+		int requiresCountOffset = localContentsOffset;
+		localContentsOffset += 2;
+		boolean javabaseSeen = false;
+		for(int i = 0; i < module.requiresCount; i++) {
+			ModuleReference ref = module.requires[i];
+			if (CharOperation.equals(ref.moduleName, TypeConstants.JAVA_BASE)) {
+				javabaseSeen = true;
+			}
+			int nameIndex = this.constantPool.literalIndex(ref.moduleName);
+			this.contents[localContentsOffset++] = (byte) (nameIndex >> 8);
+			this.contents[localContentsOffset++] = (byte) (nameIndex);
+			int flags = ref.isPublic() ? ClassFileConstants.ACC_PUBLIC : ClassFileConstants.AccDefault;
+			this.contents[localContentsOffset++] = (byte) (flags >> 8);
+			this.contents[localContentsOffset++] = (byte) (flags);
+		}
+		if (!javabaseSeen) {
+			int javabase_index = this.constantPool.literalIndex(TypeConstants.JAVA_BASE);
+			this.contents[localContentsOffset++] = (byte) (javabase_index >> 8);
+			this.contents[localContentsOffset++] = (byte) (javabase_index);
+			int flags = ClassFileConstants.AccMandated;
+			this.contents[localContentsOffset++] = (byte) (flags >> 8);
+			this.contents[localContentsOffset++] = (byte) flags;
+		}
+		int requiresCount = javabaseSeen ? module.requiresCount : module.requiresCount + 1;
+		this.contents[requiresCountOffset++] = (byte) (requiresCount >> 8);
+		this.contents[requiresCountOffset++] = (byte) requiresCount;
+		attrLength += 2 + 4 * requiresCount;
+		// ================= end requires section =================
+
+		// ================= exports section =================
+		/**
+		 * u2 exports_count;
+		 * {   u2 exports_index;
+		 *     u2 exports_to_count;
+		 *     u2 exports_to_index[exports_to_count];
+		 * } exports[exports_count];
+		 */
+		this.contents[localContentsOffset++] = (byte) (module.exportsCount >> 8);
+		this.contents[localContentsOffset++] = (byte) module.exportsCount;
+		for (int i = 0; i < module.exportsCount; i++) {
+			ExportReference ref = module.exports[i];
+			int nameIndex = this.constantPool.literalIndex(ref.pkgName);
+			this.contents[localContentsOffset++] = (byte) (nameIndex >> 8);
+			this.contents[localContentsOffset++] = (byte) (nameIndex);
+			
+			int exportsToCount = ref.isTargeted() ? ref.targets.length : 0; 
+			this.contents[localContentsOffset++] = (byte) (exportsToCount >> 8);
+			this.contents[localContentsOffset++] = (byte) (exportsToCount);
+			if (exportsToCount > 0) {
+				for(int j = 0; j < exportsToCount; j++) {
+					nameIndex = this.constantPool.literalIndex(ref.targets[j].moduleName);
+					this.contents[localContentsOffset++] = (byte) (nameIndex >> 8);
+					this.contents[localContentsOffset++] = (byte) (nameIndex);
+				}
+				attrLength += 2 * exportsToCount;
+			}
+		}
+		attrLength += 2 + 4 * module.exportsCount;
+		// ================= end exports section =================
+
+		// ================= uses section =================
+		/**
+		 * u2 uses_count;
+		 * u2 uses_index[uses_count];
+		 */
+		this.contents[localContentsOffset++] = (byte) (module.usesCount >> 8);
+		this.contents[localContentsOffset++] = (byte) module.usesCount;
+		for(int i = 0; i < module.usesCount; i++) {
+			int nameIndex = this.constantPool.literalIndex(module.uses[i].resolvedType);
+			this.contents[localContentsOffset++] = (byte) (nameIndex >> 8);
+			this.contents[localContentsOffset++] = (byte) (nameIndex);
+		}
+		attrLength += 2 + 2 * module.usesCount;
+		// ================= end uses section =================
+
+		// ================= provides section =================
+		/**
+		 * u2 provides_count;
+		 * {   u2 provides_index;
+		 *     u2 with_index;
+		 * } provides[provides_count];
+		 */
+		this.contents[localContentsOffset++] = (byte) (module.servicesCount >> 8);
+		this.contents[localContentsOffset++] = (byte) module.servicesCount;
+		for(int i = 0; i < module.servicesCount; i++) {
+			int nameIndex = this.constantPool.literalIndex(module.interfaces[i].resolvedType);
+			this.contents[localContentsOffset++] = (byte) (nameIndex >> 8);
+			this.contents[localContentsOffset++] = (byte) (nameIndex);
+			nameIndex = this.constantPool.literalIndex(module.implementations[i].resolvedType);
+			this.contents[localContentsOffset++] = (byte) (nameIndex >> 8);
+			this.contents[localContentsOffset++] = (byte) (nameIndex);
+		}
+		attrLength += 2 + 4 * module.servicesCount;
+		// ================= end provides section =================
+
+		this.contents[attrLengthOffset++] = (byte)(attrLength >> 24);
+		this.contents[attrLengthOffset++] = (byte)(attrLength >> 16);
+		this.contents[attrLengthOffset++] = (byte)(attrLength >> 8);
+		this.contents[attrLengthOffset++] = (byte)attrLength;
+		this.contentsOffset = localContentsOffset;
+		return 1;
+	}
 	private void generateElementValue(
 			Expression defaultValue,
 			TypeBinding memberValuePairReturnType,
@@ -4935,7 +5070,7 @@ public class ClassFile implements TypeConstants, TypeIds {
 					| ClassFileConstants.AccNative);
 
 		// set the AccSuper flag (has to be done after clearing AccSynchronized - since same value)
-		if (!aType.isInterface()) { // class or enum
+		if (!aType.isInterface() && !aType.isModule()) { // class or enum
 			accessFlags |= ClassFileConstants.AccSuper;
 		}
 		if (aType.isAnonymousType()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
index 816369e..5c4eb66 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
@@ -202,10 +202,10 @@ public void createPackageInfoType() {
 	this.types[0] = declaration; // Assumes the first slot is meant for this type
 }
 
-public void createModuleInfoType() {
-	TypeDeclaration declaration = new TypeDeclaration(this.compilationResult);
+public void createModuleInfoType(ModuleDeclaration declaration) {
+	//TypeDeclaration declaration = new TypeDeclaration(this.compilationResult);
 	declaration.name = TypeConstants.MODULE_INFO_NAME;
-	declaration.modifiers = ClassFileConstants.AccDefault | ClassFileConstants.AccInterface;
+	declaration.modifiers = ClassFileConstants.AccModule;
 	declaration.javadoc = this.javadoc;
 	this.types[0] = declaration; // Assumes the first slot is meant for this type
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExportReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExportReference.java
index 8b74dca..5e615d5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExportReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExportReference.java
@@ -1,34 +1,63 @@
+/*******************************************************************************
+ * Copyright (c) 2015, 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     
+ *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import org.eclipse.jdt.core.compiler.CharOperation;
+
 public class ExportReference extends ASTNode {
 	public char[][] tokens;
 	public long[] sourcePositions; //each entry is using the code : (start<<32) + end
 	public int declarationEnd; // doesn't include an potential trailing comment
 	public int declarationSourceStart;
 	public int declarationSourceEnd;
-	public ImportReference[] targets;
+	public ModuleReference[] targets;
+	public char[] pkgName;
 
 	public ExportReference(char[][] tokens, long[] sourcePositions) {
 		this.tokens = tokens;
 		this.sourcePositions = sourcePositions;
 		this.sourceEnd = (int) (sourcePositions[sourcePositions.length - 1] & 0x00000000FFFFFFFF);
 		this.sourceStart = (int) (sourcePositions[0] >>> 32);
+		this.pkgName = CharOperation.concatWith(tokens, '.');
 	}
 	
 	public boolean isTargeted() {
 		return this.targets != null && this.targets.length > 0;
 	}
 	
-	public ImportReference[] getTargetedModules() {
+	public ModuleReference[] getTargetedModules() {
 		return this.targets;
 	}
 
 	@Override
 	public StringBuffer print(int indent, StringBuffer output) {
+		printIndent(indent, output);
+		output.append("exports "); //$NON-NLS-1$
 		for (int i = 0; i < this.tokens.length; i++) {
 			if (i > 0) output.append('.');
 			output.append(this.tokens[i]);
 		}
+		if (this.isTargeted()) {
+			output.append(" to "); //$NON-NLS-1$
+			for (int i = 0; i < this.targets.length; i++) {
+				if (i > 0) output.append(", "); //$NON-NLS-1$
+				this.targets[i].print(0, output);
+			}
+		}
+		output.append(";"); //$NON-NLS-1$
 		return output;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
index 073e05b..cd0507c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
@@ -1,12 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2015, 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     
+ *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
-import org.eclipse.jdt.internal.compiler.codegen.CodeStream;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
-public class ModuleDeclaration extends Statement {
+public class ModuleDeclaration extends TypeDeclaration {
 
 	public ExportReference[] exports;
 	public ModuleReference[] requires;
@@ -18,41 +34,34 @@ public class ModuleDeclaration extends Statement {
 	public int usesCount;
 	public int servicesCount;
 
-	public char[][] moduleName;
+	public char[][] tokens;
+	public char[] moduleName;
 	public long[] sourcePositions;
 
-	public int declarationSourceStart;
-	public int declarationSourceEnd;
-	public int bodyStart;
-	public int bodyEnd; // doesn't include the trailing comment if any.
-	public CompilationResult compilationResult;
+//	public int declarationSourceStart;
+//	public int declarationSourceEnd;
+//	public int bodyStart;
+//	public int bodyEnd; // doesn't include the trailing comment if any.
+//	public CompilationResult compilationResult;
 	
 	public ModuleDeclaration(CompilationResult compilationResult, char[][] tokens, long[] positions) {
+		super(compilationResult);
 		this.compilationResult = compilationResult;
 		this.exportsCount = 0;
 		this.requiresCount = 0;
-		this.moduleName = tokens;
+		this.tokens = tokens;
+		this.moduleName = CharOperation.concatWith(tokens, '.');
 		this.sourcePositions = positions;
 		this.sourceEnd = (int) (positions[positions.length-1] & 0x00000000FFFFFFFF);
 		this.sourceStart = (int) (positions[0] >>> 32);
 	}
 
-	public boolean isModule() {
-		return true;
-	}
-
 	@Override
 	public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
 		// TODO Auto-generated method stub
 		return null;
 	}
-
-	@Override
-	public void generateCode(BlockScope currentScope, CodeStream codeStream) {
-		// TODO Auto-generated method stub
-		
-	}
-
+	
 	@Override
 	public StringBuffer printStatement(int indent, StringBuffer output) {
 		// TODO Auto-generated method stub
@@ -60,8 +69,74 @@ public class ModuleDeclaration extends Statement {
 	}
 
 	@Override
-	public void resolve(BlockScope scope) {
-		// TODO Auto-generated method stub
-		
+	public void resolve() {
+		//
+		if (this.binding == null) {
+			this.ignoreFurtherInvestigation = true;
+			return;
+		}
+		this.binding.compoundName = CharOperation.arrayConcat(this.tokens, this.name);
+		for(int i = 0; i < this.usesCount; i++) {
+			TypeReference ref = this.uses[i];
+			TypeBinding type = ref.resolveType(this.binding.scope);
+			if (type == null || !type.isValidBinding()) {
+				this.ignoreFurtherInvestigation = true;
+			}
+		}
+		for(int i = 0; i < this.servicesCount; i++) {
+			TypeBinding inf = this.interfaces[i].resolveType(this.binding.scope);
+			TypeBinding imp = this.implementations[i].resolveType(this.binding.scope);
+			if (inf == null || !inf.isValidBinding() || imp == null || !imp.isValidBinding()) {
+				this.ignoreFurtherInvestigation = true;
+			}
+		}
+	}
+
+	public StringBuffer printHeader(int indent, StringBuffer output) {
+		output.append("module "); //$NON-NLS-1$
+		output.append(CharOperation.charToString(this.moduleName));
+		return output;
+	}
+	public StringBuffer printBody(int indent, StringBuffer output) {
+		output.append(" {"); //$NON-NLS-1$
+		if (this.requires != null) {
+			for(int i = 0; i < this.requiresCount; i++) {
+				output.append('\n');
+				printIndent(indent + 1, output);
+				output.append("requires "); //$NON-NLS-1$
+				this.requires[i].print(0, output);
+				output.append(";"); //$NON-NLS-1$
+			}
+		}
+		if (this.exports != null) {
+			for(int i = 0; i < this.exportsCount; i++) {
+				output.append('\n');
+				this.exports[i].print(indent + 1, output);
+			}
+		}
+		if (this.uses != null) {
+			for(int i = 0; i < this.usesCount; i++) {
+				output.append('\n');
+				printIndent(indent + 1, output);
+				output.append("uses "); //$NON-NLS-1$
+				this.uses[i].print(0, output);
+				output.append(";"); //$NON-NLS-1$
+			}
+		}
+		if (this.servicesCount != 0) {
+			for(int i = 0; i < this.servicesCount; i++) {
+				output.append('\n');
+				printIndent(indent + 1, output);
+				output.append("provides "); //$NON-NLS-1$
+				this.interfaces[i].print(0, output);
+				output.append('\n');
+				printIndent(indent + 2, output);
+				output.append("with "); //$NON-NLS-1$
+				this.implementations[i].print(0, output);
+				output.append(";"); //$NON-NLS-1$
+			}
+		}
+		output.append('\n');
+		return printIndent(indent, output).append('}');
 	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
index 0ae4bd8..438eb8c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
@@ -1,5 +1,21 @@
+/*******************************************************************************
+ * Copyright (c) 2015, 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     
+ *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 
 public class ModuleReference extends ASTNode {
@@ -10,12 +26,14 @@ public class ModuleReference extends ASTNode {
 	public int declarationSourceEnd;
 	public int modifiers = ClassFileConstants.AccDefault;
 	public int modifiersSourceStart;
+	public char[] moduleName;
 
 	public ModuleReference(char[][] tokens, long[] sourcePositions) {
 		this.tokens = tokens;
 		this.sourcePositions = sourcePositions;
 		this.sourceEnd = (int) (sourcePositions[sourcePositions.length - 1] & 0x00000000FFFFFFFF);
 		this.sourceStart = (int) (sourcePositions[0] >>> 32);
+		this.moduleName = CharOperation.concatWith(tokens, '.');
 	}
 	
 	public boolean isPublic() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
index 33c526d..58ba5e0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileConstants.java
@@ -52,6 +52,8 @@ public interface ClassFileConstants {
 	 */
 	int AccMandated     = 0x8000;
 
+	int ACC_PUBLIC 		= 0x0020;
+	int ACC_SYNTHETIC 	= 0x1000;
 	
 	/**
 	 * Other VM flags.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
index aabd3c7..92f0c55 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
@@ -640,6 +644,10 @@ public class ClassScope extends Scope {
 				}
 			}
 		} else {
+			if (sourceType.sourceName == TypeConstants.MODULE_INFO_NAME) {
+				// TBD - allowed only at source level 1.9 or above
+				modifiers = ClassFileConstants.AccModule;
+			} else
 			// detect abnormal cases for classes
 			if (isMemberType) { // includes member types defined inside local types
 				final int UNEXPECTED_MODIFIERS = ~(ClassFileConstants.AccPublic | ClassFileConstants.AccPrivate | ClassFileConstants.AccProtected | ClassFileConstants.AccStatic | ClassFileConstants.AccAbstract | ClassFileConstants.AccFinal | ClassFileConstants.AccStrictfp);
@@ -945,6 +953,8 @@ public class ClassScope extends Scope {
 		if (this.referenceContext.superclass == null) {
 			if (sourceType.isEnum() && compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) // do not connect if source < 1.5 as enum already got flagged as syntax error
 				return connectEnumSuperclass();
+			if (sourceType.isModule())
+				return true;
 			sourceType.setSuperClass(getJavaLangObject());
 			return !detectHierarchyCycle(sourceType, sourceType.superclass, null);
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index a3dfa1b..ee331f8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -147,7 +147,8 @@ void buildTypeBindings(AccessRestriction accessRestriction) {
 			// if a type exists, check that its a valid type
 			// it can be a NotFound problem type if its a secondary type referenced before its primary type found in additional units
 			// and it can be an unresolved type which is now being defined
-			problemReporter().duplicateTypes(this.referenceContext, typeDecl);
+			if (!typeBinding.isModule()) // Kludge?
+				problemReporter().duplicateTypes(this.referenceContext, typeDecl);
 			continue nextType;
 		}
 		if (this.fPackage != this.environment.defaultPackage && this.fPackage.getPackage(typeDecl.name) != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 569bc99..8a5c755 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -5,6 +5,10 @@
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contributions for
@@ -1461,6 +1465,10 @@ public boolean isHierarchyConnected() {
 	return true;
 }
 
+public boolean isModule() {
+	return (this.modifiers & ClassFileConstants.AccModule) != 0;
+}
+
 public boolean isInterface() {
 	// consider strict interfaces and annotation types
 	return (this.modifiers & ClassFileConstants.AccInterface) != 0;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index 0fd2efd..199eeea 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -395,4 +395,7 @@ public interface TypeConstants {
 	// synthetic package-info name
 	public static final char[] PACKAGE_INFO_NAME = "package-info".toCharArray(); //$NON-NLS-1$
 	public static final char[] MODULE_INFO_NAME = "module-info".toCharArray(); //$NON-NLS-1$
+
+	// java.base module name
+	char[] JAVA_BASE = "java.base".toCharArray(); //$NON-NLS-1$
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index 485c19c..e28e213 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -5609,6 +5609,10 @@ protected void consumePackageComment() {
 }
 protected void consumeInternalCompilationUnitWithModuleDeclaration() {
 	this.compilationUnit.moduleDeclaration = (ModuleDeclaration)this.astStack[this.astPtr--];
+	if (this.compilationUnit.isModuleInfo()) {
+		this.compilationUnit.types = new TypeDeclaration[1];
+		this.compilationUnit.createModuleInfoType(this.compilationUnit.moduleDeclaration);
+	}
 	this.astLengthStack[this.astLengthPtr--] = 0;
 }
 protected void consumeRequiresStatement() {
@@ -5692,14 +5696,14 @@ protected void consumeExportsStatement() {
 //	}
 }
 protected void consumeSingleExportsTargetName() {
-	ImportReference impt;
+	ModuleReference impt;
 	int length;
 	char[][] tokens = new char[length = this.identifierLengthStack[this.identifierLengthPtr--]][];
 	this.identifierPtr -= length;
 	long[] positions = new long[length];
 	System.arraycopy(this.identifierStack, this.identifierPtr + 1, tokens, 0, length);
 	System.arraycopy(this.identifierPositionStack, this.identifierPtr + 1, positions, 0, length);
-	pushOnAstStack(impt = new ImportReference(tokens, positions, false, ClassFileConstants.AccDefault));
+	pushOnAstStack(impt = new ModuleReference(tokens, positions));
 
 //	if (this.currentToken == TokenNameSEMICOLON){
 //		impt.declarationSourceEnd = this.scanner.currentPosition - 1;
@@ -5719,7 +5723,7 @@ protected void consumeExportTarget() {
 	System.arraycopy(
 		this.astStack,
 		this.astPtr + 1,
-		expt.targets = new ImportReference[length],
+		expt.targets = new ModuleReference[length],
 		0,
 		length);
 
@@ -5730,6 +5734,8 @@ protected void consumeExportTarget() {
 //	}
 }
 protected void consumeExportsTargetNameList() {
+	consumeSingleExportsTargetName();
+	this.listLength++;
 	optimizedConcatNodeLists();
 }
 protected void consumeSingleExportsPkgName() {
@@ -5807,7 +5813,7 @@ protected void consumeWithClause() {
 		module.implementations = new TypeReference[1];
 	}
 	if (module.servicesCount + 1 > module.implementations.length) {
-		System.arraycopy(module.implementations, 0, module.uses = new TypeReference[module.servicesCount + 1], 0, module.servicesCount);
+		System.arraycopy(module.implementations, 0, module.implementations = new TypeReference[module.servicesCount + 1], 0, module.servicesCount);
 	}
 	module.implementations[module.servicesCount] = siName;
 	
commit fedbc6d7a5d46f5e2753336d3dea1120d8eb811b
Author: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
Date:   Mon Feb 15 16:08:04 2016 +0530

    bug 479610: Module resolution support + crude changes in model to
    facilitate module resolution during reconcile
    
    Change-Id: I4721ab5d9ad9fd9291db4542aa68ec08a9a93106

6	0	org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
12	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
5	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InMemoryNameEnvironment.java
5	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
6	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
5	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
13	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
22	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExportReference.java
48	20	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
11	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ModuleInfo.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/INameEnvironment.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
21	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
215	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
19	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
27	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
7	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
5	0	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetEnvironment.java
14	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IJavaElement.java
8	5	org.eclipse.jdt.core/model/org/eclipse/jdt/core/IModule.java
13	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
25	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
6	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
7	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
27	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
30	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementRequestor.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProjectElementInfo.java
206	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java
64	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
10	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/OpenableElementInfo.java
15	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
10	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
16	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
13	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
25	5	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJimage.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java
33	6	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
9	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
6	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
diff --git a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
index a339614..16a22d5 100644
--- a/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
+++ b/org.eclipse.jdt.compiler.tool/src/org/eclipse/jdt/internal/compiler/batch/ClasspathJsr199.java
@@ -204,4 +204,10 @@ public class ClasspathJsr199 extends ClasspathLocation {
 	public boolean hasAnnotationFileFor(String qualifiedTypeName) {
 		return false;
 	}
+
+	@Override
+	public IModule getModule(char[] moduleName) {
+		// TODO Auto-generated method stub
+		return null;
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 94ab38e..5139ebd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -447,6 +447,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("ConflictingInheritedNullAnnotations", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ConstructorReferenceNotBelow18", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("ConstructorVarargsArgumentNeedCast", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("CyclicModuleDependency", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("CorruptedSignature", new ProblemAttributes(CategorizedProblem.CAT_BUILDPATH));
 		expectedProblemAttributes.put("DanglingReference", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("DeadCode", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -467,6 +468,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("DuplicateBoundInIntersectionCast", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DuplicateCase", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("DuplicateDefaultCase", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
+		expectedProblemAttributes.put("DuplicateExports", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DuplicateField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("DuplicateFinalLocalInitialization", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("DuplicateImport", new ProblemAttributes(CategorizedProblem.CAT_IMPORT));
@@ -482,10 +484,13 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("DuplicateModifierForVariable", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("DuplicateNestedType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DuplicateParameterizedMethods", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("DuplicateRequires", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("DuplicateServices", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DuplicateSuperInterface", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DuplicateTargetInTargetAnnotation", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("DuplicateTypeVariable", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("DuplicateTypes", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("DuplicateUses", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("EmptyControlFlowStatement", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("EnclosingInstanceInConstructorCall", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("EndOfSource", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
@@ -1014,6 +1019,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("UndefinedField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("UndefinedLabel", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("UndefinedMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("UndefinedModule", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("UndefinedName", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("UndefinedType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("UndefinedTypeVariable", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -1276,6 +1282,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("ContradictoryNullAnnotationsInferredFunctionType", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("ConstructorVarargsArgumentNeedCast", new ProblemAttributes(JavaCore.COMPILER_PB_VARARGS_ARGUMENT_NEED_CAST));
 		expectedProblemAttributes.put("CorruptedSignature", SKIP);
+		expectedProblemAttributes.put("CyclicModuleDependency", SKIP);
 		expectedProblemAttributes.put("DanglingReference", SKIP);
 		expectedProblemAttributes.put("DeadCode", new ProblemAttributes(JavaCore.COMPILER_PB_DEAD_CODE));
 		expectedProblemAttributes.put("DefaultMethodNotBelow18", SKIP);
@@ -1294,6 +1301,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("DuplicateBoundInIntersectionCast", SKIP);
 		expectedProblemAttributes.put("DuplicateCase", SKIP);
 		expectedProblemAttributes.put("DuplicateDefaultCase", SKIP);
+		expectedProblemAttributes.put("DuplicateExports", SKIP);
 		expectedProblemAttributes.put("DuplicateField", SKIP);
 		expectedProblemAttributes.put("DuplicateFinalLocalInitialization", SKIP);
 		expectedProblemAttributes.put("DuplicateImport", SKIP);
@@ -1309,10 +1317,13 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("DuplicateModifierForVariable", SKIP);
 		expectedProblemAttributes.put("DuplicateNestedType", SKIP);
 		expectedProblemAttributes.put("DuplicateParameterizedMethods", SKIP);
+		expectedProblemAttributes.put("DuplicateRequires", SKIP);
+		expectedProblemAttributes.put("DuplicateServices", SKIP);
 		expectedProblemAttributes.put("DuplicateSuperInterface", SKIP);
 		expectedProblemAttributes.put("DuplicateTargetInTargetAnnotation", SKIP);
 		expectedProblemAttributes.put("DuplicateTypeVariable", SKIP);
 		expectedProblemAttributes.put("DuplicateTypes", SKIP);
+		expectedProblemAttributes.put("DuplicateUses", SKIP);
 		expectedProblemAttributes.put("EmptyControlFlowStatement", new ProblemAttributes(JavaCore.COMPILER_PB_EMPTY_STATEMENT));
 		expectedProblemAttributes.put("EnclosingInstanceInConstructorCall", SKIP);
 		expectedProblemAttributes.put("EndOfSource", SKIP);
@@ -1841,6 +1852,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("UndefinedField", SKIP);
 		expectedProblemAttributes.put("UndefinedLabel", SKIP);
 		expectedProblemAttributes.put("UndefinedMethod", SKIP);
+		expectedProblemAttributes.put("UndefinedModule", SKIP);
 		expectedProblemAttributes.put("UndefinedName", SKIP);
 		expectedProblemAttributes.put("UndefinedType", SKIP);
 		expectedProblemAttributes.put("UndefinedTypeVariable", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InMemoryNameEnvironment.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InMemoryNameEnvironment.java
index 597c0ca..f79b80b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InMemoryNameEnvironment.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InMemoryNameEnvironment.java
@@ -103,4 +103,9 @@ public NameEnvironmentAnswer findType(char[] typeName, char[][] packageName, IMo
 public boolean isPackage(char[][] parentPackageName, char[] packageName, IModule[] module) {
 	return false;
 }
+@Override
+public IModule getModule(char[] name) {
+	// TODO Auto-generated method stub
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
index 6d7af1e..e61192e 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java
@@ -285,4 +285,9 @@ public String getPath() {
 public int getMode() {
 	return this.mode;
 }
+@Override
+public IModule getModule(char[] moduleName) {
+	// TODO Auto-generated method stub
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index 410a697..8512b99 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -334,4 +334,10 @@ public String getPath() {
 public int getMode() {
 	return BINARY;
 }
+
+@Override
+public IModule getModule(char[] moduleName) {
+	// TODO Auto-generated method stub
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
index e67b184..547e72f 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/FileSystem.java
@@ -449,4 +449,9 @@ public boolean isPackage(char[][] compoundName, char[] packageName, IModule[] mo
 	}
 	return false;
 }
+@Override
+public IModule getModule(char[] name) {
+	// TODO Auto-generated method stub
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index a6b322b..7db0a96 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1850,6 +1850,19 @@ void setSourceStart(int sourceStart);
 	/** @since 3.10 */
 	int IllegalDefaultModifierSpecification = MethodRelated + 1058;
 
+	/** @since 3.12 */
+	int UndefinedModule = TypeRelated + 1200;
+	/** @since 3.12 */
+	int DuplicateRequires = TypeRelated + 1201;
+	/** @since 3.12 */
+	int DuplicateExports = TypeRelated + 1202;
+	/** @since 3.12 */
+	int DuplicateUses = TypeRelated + 1203;
+	/** @since 3.12 */
+	int DuplicateServices = TypeRelated + 1204;
+	/** @since 3.12 */
+	int CyclicModuleDependency = TypeRelated + 1205;
+
 	/** @since 3.10 */
 	int GenericInferenceError = 1100; 	// FIXME: This is just a stop-gap measure, be more specific via https://bugs.eclipse.org/404675
 	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExportReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExportReference.java
index 5e615d5..6d57fcf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExportReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExportReference.java
@@ -15,7 +15,13 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import java.util.HashSet;
+import java.util.Set;
+
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Scope;
 
 public class ExportReference extends ASTNode {
 	public char[][] tokens;
@@ -42,6 +48,22 @@ public class ExportReference extends ASTNode {
 		return this.targets;
 	}
 
+	public boolean resolve(Scope scope) {
+		boolean errorsExist = false;
+		if (this.isTargeted()) {
+			Set<ModuleBinding> modules = new HashSet<ModuleBinding>();
+			for (int i = 0; i < this.targets.length; i++) {
+				ModuleReference ref = this.targets[i];
+				if (ref.resolve(scope) != null) {
+					if (!modules.add(ref.binding)) {
+						scope.problemReporter().duplicateModuleReference(IProblem.DuplicateExports, ref);
+						errorsExist = true;
+					}
+				}
+			}
+		}
+		return !errorsExist;
+	}
 	@Override
 	public StringBuffer print(int indent, StringBuffer output) {
 		printIndent(indent, output);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
index cd0507c..5a63b6e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
@@ -15,11 +15,20 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.internal.compiler.ClassFile;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
 import org.eclipse.jdt.internal.compiler.flow.FlowContext;
 import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
 public class ModuleDeclaration extends TypeDeclaration {
@@ -33,17 +42,12 @@ public class ModuleDeclaration extends TypeDeclaration {
 	public int requiresCount;
 	public int usesCount;
 	public int servicesCount;
+	public ModuleBinding moduleBinding;
 
 	public char[][] tokens;
 	public char[] moduleName;
 	public long[] sourcePositions;
 
-//	public int declarationSourceStart;
-//	public int declarationSourceEnd;
-//	public int bodyStart;
-//	public int bodyEnd; // doesn't include the trailing comment if any.
-//	public CompilationResult compilationResult;
-	
 	public ModuleDeclaration(CompilationResult compilationResult, char[][] tokens, long[] positions) {
 		super(compilationResult);
 		this.compilationResult = compilationResult;
@@ -55,15 +59,15 @@ public class ModuleDeclaration extends TypeDeclaration {
 		this.sourceEnd = (int) (positions[positions.length-1] & 0x00000000FFFFFFFF);
 		this.sourceStart = (int) (positions[0] >>> 32);
 	}
-
 	@Override
-	public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
-		// TODO Auto-generated method stub
-		return null;
+	public void generateCode(ClassFile enclosingClassFile) {
+		if (this.ignoreFurtherInvestigation) {
+			return;
+		}
+		super.generateCode(enclosingClassFile);
 	}
-	
 	@Override
-	public StringBuffer printStatement(int indent, StringBuffer output) {
+	public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
 		// TODO Auto-generated method stub
 		return null;
 	}
@@ -75,19 +79,43 @@ public class ModuleDeclaration extends TypeDeclaration {
 			this.ignoreFurtherInvestigation = true;
 			return;
 		}
+		this.moduleBinding = this.scope.environment().getModule(this.moduleName);
 		this.binding.compoundName = CharOperation.arrayConcat(this.tokens, this.name);
+		Set<ModuleBinding> requiredModules = new HashSet<ModuleBinding>();
+		for(int i = 0; i < this.requiresCount; i++) {
+			ModuleReference ref = this.requires[i];
+			if (ref.resolve(this.scope) != null) {
+				if (!requiredModules.add(ref.binding)) {
+					this.scope.problemReporter().duplicateModuleReference(IProblem.DuplicateRequires, ref);
+				}
+				Collection<ModuleBinding> deps = ref.binding.getImplicitDependencies();
+				if (deps.contains(this.moduleBinding))
+					this.scope.problemReporter().cyclicModuleDependency(this.moduleBinding, ref);
+			}
+		}
+		for (int i = 0; i < this.exportsCount; i++) {
+			this.exports[i].resolve(this.scope);
+		}
 		for(int i = 0; i < this.usesCount; i++) {
-			TypeReference ref = this.uses[i];
-			TypeBinding type = ref.resolveType(this.binding.scope);
-			if (type == null || !type.isValidBinding()) {
-				this.ignoreFurtherInvestigation = true;
+			Set<TypeBinding> allTypes = new HashSet<TypeBinding>();
+			if (this.uses[i].resolveType(this.scope) != null) {
+				if (!allTypes.add(this.uses[i].resolvedType)) {
+					this.scope.problemReporter().duplicateTypeReference(IProblem.DuplicateUses, this.uses[i]);
+				}
 			}
 		}
+		Map<TypeBinding, TypeBinding> services = new HashMap<TypeBinding, TypeBinding>(this.servicesCount); 
 		for(int i = 0; i < this.servicesCount; i++) {
-			TypeBinding inf = this.interfaces[i].resolveType(this.binding.scope);
-			TypeBinding imp = this.implementations[i].resolveType(this.binding.scope);
-			if (inf == null || !inf.isValidBinding() || imp == null || !imp.isValidBinding()) {
-				this.ignoreFurtherInvestigation = true;
+			if (this.interfaces[i].resolveType(this.scope) != null) {
+				TypeBinding inf = this.interfaces[i].resolvedType;
+				if (this.implementations[i].resolveType(this.scope) != null) {
+					TypeBinding imp = this.implementations[i].resolvedType;
+					if (services.get(inf) == imp)  { //$IDENTITY-COMPARISON$
+						this.scope.problemReporter().duplicateTypeReference(IProblem.DuplicateServices, this.interfaces[i], this.implementations[i]);
+					} else {
+						services.put(this.interfaces[i].resolvedType, this.implementations[i].resolvedType);
+					}
+				}
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
index 438eb8c..0d574ac 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2015, 2016 IBM Corporation and others.
+ * Copyright (c) 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,6 +17,8 @@ package org.eclipse.jdt.internal.compiler.ast;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
+import org.eclipse.jdt.internal.compiler.lookup.Scope;
 
 public class ModuleReference extends ASTNode {
 	public char[][] tokens;
@@ -27,6 +29,7 @@ public class ModuleReference extends ASTNode {
 	public int modifiers = ClassFileConstants.AccDefault;
 	public int modifiersSourceStart;
 	public char[] moduleName;
+	public ModuleBinding binding;
 
 	public ModuleReference(char[][] tokens, long[] sourcePositions) {
 		this.tokens = tokens;
@@ -47,4 +50,11 @@ public class ModuleReference extends ASTNode {
 		}
 		return output;
 	}
+
+	public ModuleBinding resolve(Scope scope) {
+		if ((this.binding = scope.environment().getModule(this.moduleName)) == null) {
+			scope.problemReporter().invalidModule(this);
+		}
+		return this.binding;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
index a254f4f..7caee08 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
@@ -35,6 +35,7 @@ public class TypeDeclaration extends Statement implements ProblemSeverities, Ref
 	public static final int INTERFACE_DECL = 2;
 	public static final int ENUM_DECL = 3;
 	public static final int ANNOTATION_TYPE_DECL = 4;
+	public static final int MODULE_DECL = 5;
 
 	public int modifiers = ClassFileConstants.AccDefault;
 	public int modifiersSourceStart;
@@ -746,13 +747,15 @@ private void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {
 }
 
 public final static int kind(int flags) {
-	switch (flags & (ClassFileConstants.AccInterface|ClassFileConstants.AccAnnotation|ClassFileConstants.AccEnum)) {
+	switch (flags & (ClassFileConstants.AccInterface|ClassFileConstants.AccAnnotation|ClassFileConstants.AccEnum|ClassFileConstants.AccModule)) {
 		case ClassFileConstants.AccInterface :
 			return TypeDeclaration.INTERFACE_DECL;
 		case ClassFileConstants.AccInterface|ClassFileConstants.AccAnnotation :
 			return TypeDeclaration.ANNOTATION_TYPE_DECL;
 		case ClassFileConstants.AccEnum :
 			return TypeDeclaration.ENUM_DECL;
+		case ClassFileConstants.AccModule:
+			return TypeDeclaration.MODULE_DECL;
 		default :
 			return TypeDeclaration.CLASS_DECL;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ModuleInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ModuleInfo.java
index a110905..54f1575 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ModuleInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ModuleInfo.java
@@ -100,7 +100,7 @@ public class ModuleInfo extends ClassFileStruct implements IModule {
 				module.requires[i].refName = requiresNames;
 				moduleOffset += 2;
 				int pub = module.u2At(moduleOffset);
-				module.requires[i].isPublic = (ClassFileConstants.AccPublic == pub); // Access modifier
+				module.requires[i].isPublic = (ClassFileConstants.ACC_PUBLIC == pub); // Access modifier
 				moduleOffset += 2;
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
index 779d9f0..430938e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModule.java
@@ -30,17 +30,17 @@ public interface IModule {
 
 	public IService[] provides();
 
-	interface IModuleReference {
+	public interface IModuleReference {
 		public char[] name();
 		public boolean isPublic();
 	}
 
-	interface IPackageExport {
+	public interface IPackageExport {
 		public char[] name();
 		public char[][] exportedTo();
 	}
 
-	interface IService {
+	public interface IService {
 		public char[] name();
 		char[] with();
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
index 7c6a23f..013d622 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleLocation.java
@@ -32,7 +32,7 @@ public interface IModuleLocation {
 	public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageName, String qualifiedBinaryFileName, IModule mod);
 	public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageName, String qualifiedBinaryFileName, boolean asBinaryOnly, IModule mod);
 	public boolean isPackage(String qualifiedPackageName);
-
+	public IModule getModule(char[] moduleName);
 	/**
 	 * Tells the client whether or not this module location serves the given module.
 	 * @param module
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/INameEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/INameEnvironment.java
index bb0b5e0..22cb35f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/INameEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/INameEnvironment.java
@@ -75,7 +75,7 @@ boolean isPackage(char[][] parentPackageName, char[] packageName, char[] client)
  */
 public void acceptModule(IModule module, IModuleLocation location);
 public boolean isPackageVisible(char[] pack, char[] source, char[] client);
-public IModule getModule(String name);
+public IModule getModule(char[] name);
 public IModule getModule(IModuleLocation location);
 
 /**
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index 0928668..143107c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -86,6 +86,7 @@ public class BinaryTypeBinding extends ReferenceBinding {
 	protected MethodBinding[] methods;
 	protected ReferenceBinding[] memberTypes;
 	protected TypeVariableBinding[] typeVariables;
+	protected ModuleBinding module;
 	private BinaryTypeBinding prototype;
 
 	// For the link with the principle structure
@@ -246,7 +247,7 @@ public BinaryTypeBinding(PackageBinding packageBinding, IBinaryType binaryType,
 	this.environment = environment;
 	this.fPackage = packageBinding;
 	this.fileName = binaryType.getFileName();
-
+	this.module = environment.getModule(binaryType.getModule());
 	/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=324850, even in a 1.4 project, we
 	   must internalize type variables and observe any parameterization of super class
 	   and/or super interfaces in order to be able to detect overriding in the presence
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index 4e18891..5d88eea 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -129,6 +129,9 @@ void buildTypeBindings(AccessRestriction accessRestriction) {
 			if (this.referenceContext.currentPackage != null && this.referenceContext.currentPackage.annotations != null) {
 				this.referenceContext.types[0].annotations = this.referenceContext.currentPackage.annotations;
 			}
+		} else if (this.referenceContext.isModuleInfo()) {
+			ModuleDeclaration module = this.referenceContext.moduleDeclaration;
+			module.moduleBinding = this.environment().createModuleInfo(this);
 		}
 		recordQualifiedReference(this.currentPackageName); // always dependent on your own package
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 4e9742a..ac15704 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -58,6 +58,7 @@ import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.ITypeRequestor;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
+import org.eclipse.jdt.internal.compiler.util.HashtableOfObject;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfPackage;
 import org.eclipse.jdt.internal.compiler.util.JimageUtil;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
@@ -95,6 +96,9 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 	private SimpleLookupTable uniquePolymorphicMethodBindings;
 	private SimpleLookupTable uniqueGetClassMethodBinding; // https://bugs.eclipse.org/bugs/show_bug.cgi?id=300734
 
+	// key is a string with the module name value is a module binding
+	private HashtableOfObject knownModules;
+
 	public CompilationUnitDeclaration unitBeingCompleted = null; // only set while completing units
 	public Object missingClassFileLocation = null; // only set when resolving certain references, to help locating problems
 	private CompilationUnitDeclaration[] units = new CompilationUnitDeclaration[4];
@@ -128,7 +132,7 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 
 	static final ProblemPackageBinding TheNotFoundPackage = new ProblemPackageBinding(CharOperation.NO_CHAR, NotFound);
 	static final ProblemReferenceBinding TheNotFoundType = new ProblemReferenceBinding(CharOperation.NO_CHAR_CHAR, null, NotFound);
-
+	final ModuleBinding UnNamedModule = new ModuleBinding(ModuleEnvironment.UNNAMED_MODULE, this);
 
 public LookupEnvironment(ITypeRequestor typeRequestor, CompilerOptions globalOptions, ProblemReporter problemReporter, INameEnvironment nameEnvironment) {
 	this.typeRequestor = typeRequestor;
@@ -145,14 +149,27 @@ public LookupEnvironment(ITypeRequestor typeRequestor, CompilerOptions globalOpt
 	this.classFilePool = ClassFilePool.newInstance();
 	this.typesBeingConnected = new HashSet<>();
 	this.typeSystem = this.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8 && this.globalOptions.storeAnnotations ? new AnnotatableTypeSystem(this) : new TypeSystem(this);
+	this.knownModules = new HashtableOfObject(5);
 }
 
 public ReferenceBinding askForType(char[][] compoundName) {
 	return askForType(compoundName, null);
 }
 //TODO: BETA_JAVA9 - should ideally return ModuleBinding?
-public IModule getModule(String name) {
-	return this.nameEnvironment.getModule(name);
+public ModuleBinding getModule(char[] name) {
+	if (name == null || name.length == 0)
+		return ModuleBinding.UnNamedModule;
+	ModuleBinding module = (ModuleBinding) this.knownModules.get(name);
+	if (module == null) {
+		IModule mod = this.nameEnvironment.getModule(name);
+		if (mod != null) {
+			this.knownModules.put(name, module = new ModuleBinding(mod, this));
+		}
+	}
+	return module;
+}
+public ModuleBinding createModuleInfo(CompilationUnitScope scope) {
+	return new ModuleBinding(scope);
 }
 /**
  * Ask the name environment for a type which corresponds to the compoundName.
@@ -214,7 +231,7 @@ ReferenceBinding askForType(PackageBinding packageBinding, char[] name, char[] m
 	return packageBinding.getType0(name);
 }
 public boolean canTypeBeSeen(SourceTypeBinding binding, Scope scope) {
-	return this.nameEnvironment.isPackageVisible(binding.fPackage.readableName(), binding.module, scope.module());
+	return this.nameEnvironment.isPackageVisible(binding.fPackage.readableName(), binding.module == null ? ModuleEnvironment.UNNAMED : binding.module.name(), scope.module());
 }
 
 /* Create the initial type bindings for the compilation unit.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
new file mode 100644
index 0000000..4c02a98
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -0,0 +1,215 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *     
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.lookup;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.env.IModule.IModuleReference;
+import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
+import org.eclipse.jdt.internal.compiler.util.JimageUtil;
+
+public class ModuleBinding extends Binding {
+
+	public char[] moduleName;
+	public IModuleReference[] requires;
+	public IPackageExport[] exportedPackages;
+	public TypeBinding[] uses;
+	public TypeBinding[] services;
+	public TypeBinding[] implementations;
+	public CompilationUnitScope scope;
+	public LookupEnvironment environment;
+	public int tagBits;
+	private ModuleBinding[] requiredModules = null;
+
+	public boolean isBinary = false;
+
+	public static ModuleBinding[] NO_REQUIRES = new ModuleBinding[0];
+	public static IModuleReference[] NO_MODULE_REFS = new IModuleReference[0];
+	public static IPackageExport[] NO_EXPORTS = new IPackageExport[0];
+
+	static ModuleBinding UnNamedModule = new ModuleBinding(); 
+
+	private ModuleBinding() {
+		this.moduleName = ModuleEnvironment.UNNAMED;
+	}
+	public ModuleBinding(IModule module, LookupEnvironment environment) {
+		this.moduleName = module.name();
+		this.requires = module.requires();
+		if (this.requires == null)
+			this.requires = NO_MODULE_REFS;
+		this.exportedPackages = module.exports();
+		if (this.exportedPackages == null)
+			this.exportedPackages = NO_EXPORTS;
+		this.environment = environment;
+		this.uses = Binding.NO_TYPES;
+		this.services = Binding.NO_TYPES;
+		this.implementations = Binding.NO_TYPES;
+		this.isBinary = true;
+	}
+
+	public ModuleBinding(CompilationUnitScope scope) {
+		this.scope = scope;
+		this.environment = scope.environment;
+		this.isBinary = false;
+		this.uses = Binding.NO_TYPES;
+		this.services = Binding.NO_TYPES;
+		this.implementations = Binding.NO_TYPES;
+	}
+
+	public boolean isBinary() {
+		return this.isBinary;
+	}
+	private void getImplicitDependencies(ModuleBinding module, Set<ModuleBinding> deps) {
+		if (module == UnNamedModule)
+			return;
+		if (module.isBinary()) {
+			getImplicitDependencies(module.requires, deps);
+		} else {
+			getImplicitDependencies(module.scope.referenceContext.moduleDeclaration.requires, deps);
+		}
+	}
+	private void getImplicitDependencies(IModule.IModuleReference[] reqs, Set<ModuleBinding> deps) {
+		if (reqs != null && reqs.length > 0) {
+			for (IModule.IModuleReference ref : reqs) {
+				ModuleBinding refModule = this.environment.getModule(ref.name());
+				if (refModule != null) {
+					if (deps.add(refModule))
+						getImplicitDependencies(refModule.requires, deps);
+				}
+			}
+		}
+	}
+
+	private void getImplicitDependencies(ModuleReference[] refs, Set<ModuleBinding> deps) {
+		if (refs != null && refs.length > 0) {
+			for (ModuleReference ref : refs) {
+				ModuleBinding refModule = this.environment.getModule(ref.moduleName);
+				if (refModule != null) {
+					if (deps.add(refModule))
+						getImplicitDependencies(refModule, deps);
+				}
+			}
+		}
+	}
+	/**
+	 * Collect all implicit dependencies offered by this module
+	 * Any module dependent on this module will have an implicit dependence on all other modules
+	 * specified as ' requires public '
+	 * @return
+	 *  collection of implicit dependencies
+	 */
+	public Collection<ModuleBinding> getImplicitDependencies() {
+		Set<ModuleBinding> dependencies = new HashSet<ModuleBinding>();
+		getImplicitDependencies(this, dependencies);
+		return dependencies;
+	}
+
+	/**
+	 * get all the modules required by this module
+	 * All required modules include modules explicitly specified as required in the module declaration
+	 * as well as implicit dependencies - those specified as ' requires public ' by one of the
+	 * dependencies
+	 * 
+	 * @return
+	 *   An array of all required modules
+	 */
+	public ModuleBinding[] getAllRequiredModules() {
+		if (this == UnNamedModule)
+			return NO_REQUIRES;
+		if (this.requiredModules != null)
+			return this.requiredModules;
+		Set<ModuleBinding> allRequires = new HashSet<ModuleBinding>();
+		for (int i = 0; i < this.requires.length; i++) {
+			ModuleBinding mod = this.environment.getModule(this.requires[i].name());
+			if (mod != null) {
+				allRequires.add(mod);
+				allRequires.addAll(mod.getImplicitDependencies());
+			}
+		}
+		if (!CharOperation.equals(this.moduleName, TypeConstants.JAVA_BASE)) {
+			// TODO: Do we need to add java.base here?
+			allRequires.add(this.environment.getModule(JimageUtil.JAVA_BASE_CHAR));
+		}
+		return this.requiredModules = allRequires.size() > 0 ? allRequires.toArray(new ModuleBinding[allRequires.size()]) : NO_REQUIRES;
+	}
+
+	public char[] name() {
+		return this.moduleName;
+	}
+	public boolean isPackageVisible(PackageBinding pkg, Scope skope) {
+		ModuleBinding other = this.environment.getModule(skope.module());
+		return isPackageExportedTo(pkg, this, other);
+	}
+
+	public boolean isPackageExported(char[] pkgName) {
+		for (IPackageExport export : this.exportedPackages) {
+			if (CharOperation.prefixEquals(pkgName, export.name()))
+				return true;
+		}
+		return false;
+	}
+	/**
+	 * Check if the specified package is exported to the client module
+	 * @param pkg - the package whose visibility is to be checked
+	 * @param source - the module which 'contains' the package 
+	 * @param client - the module that wishes to use the package
+	 * @return true if the package is exported to the client module and the client
+	 *  is dependent on the source module either directly or indirectly, false otherwise
+	 */
+	public static boolean isPackageExportedTo(PackageBinding pkg, ModuleBinding source, ModuleBinding client) {
+		if (client == null || client == source) // same or unnamed
+			return true;
+		if (!client.dependsOn(source))
+			return false;
+		for (IPackageExport export : source.exportedPackages) {
+			if (CharOperation.equals(export.name(), pkg.readableName())) {
+				if (export.exportedTo() != null) {
+					for (char[] target : export.exportedTo()) {
+						if (CharOperation.equals(target, client.moduleName))
+							return true;
+					}
+				}
+			}
+		}
+		return false;
+	}
+ 	public boolean dependsOn(ModuleBinding other) {
+ 		if (other == this)
+ 			return true;
+		for (ModuleBinding ref : getAllRequiredModules()) {
+			if (ref == other)
+				return true;
+		}
+		return false;
+	}
+	@Override
+	public int kind() {
+		//
+		return ClassFileConstants.AccModule;
+	}
+
+	@Override
+	public char[] readableName() {
+		//
+		return this.moduleName;
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
index a79c6fc..d622495 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
@@ -105,9 +105,15 @@ public abstract class ModuleEnvironment implements INameEnvironment {
 
 	public abstract boolean isPackage(char[][] parentPackageName, char[] packageName, IModule[] module);
 
-	public IModule getModule(String name) {
-		return this.modulesCache.get(name);
-	}
+//	public abstract IModule getModule(String name);
+//	{
+////		IModule mod = this.modulesCache.get(name);
+////		if (mod == null) {
+////			
+////		}
+////		return mod;
+//		for ()
+//	}
 
 	public boolean isPackageVisible(char[] packageName, char[] sourceName, char[] clientName) {
 		if (CharOperation.equals(sourceName, clientName)) 
@@ -184,8 +190,8 @@ public abstract class ModuleEnvironment implements INameEnvironment {
 				for (IModule.IModuleReference ref : requires) {
 					IModule refModule = getModule(ref.name());
 					if (refModule != null) {
-						targets.add(refModule);
-						collectAllVisibleModules(refModule, targets);
+						if (targets.add(refModule))
+							collectAllVisibleModules(refModule, targets);
 					}
 				}
 			}
@@ -197,12 +203,13 @@ public abstract class ModuleEnvironment implements INameEnvironment {
 	 * @param name the name of the module to lookup
 	 * @return the module with the given name
 	 */
-	public IModule getModule(final char[] name) {
-		if (name == null) return null;
-		String mod = new String(name);
-		IModule module = this.modulesCache.get(mod);
-		return module;
-	}
+//	public IModule getModule(final char[] name) {
+////		if (name == null) return null;
+////		String mod = new String(name);
+////		IModule module = this.modulesCache.get(mod);
+////		return module;
+//		return name == null ? null : getModule(CharOperation.charToString(name));
+//	}
 	/**
 	 * Accepts the given module to be served later on requests. If 
 	 * any older copies of module already present, they will be 
@@ -285,7 +292,7 @@ public abstract class ModuleEnvironment implements INameEnvironment {
 		if (imp != null) {
 			exp.exportedTo = new char[imp.length][];
 			for(int j = 0; j < imp.length; j++) {
-				exp.exportedTo = imp[i].tokens;
+				exp.exportedTo = imp[j].tokens;
 			}
 		}
 		return exp;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index fae2c6a..57f25db 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -87,8 +87,8 @@ public class SourceTypeBinding extends ReferenceBinding {
 	public ClassScope scope;
 	protected SourceTypeBinding prototype;
 	LookupEnvironment environment;
-	char[] module; //TODO: Should it be something like ModuleBinding?
-
+	//char[] module; //TODO: Should be replaced by ModuleBinding
+	ModuleBinding module;
 	// Synthetics are separated into 4 categories: methods, super methods, fields, class literals and bridge methods
 	// if a new category is added, also increment MAX_SYNTHETICS
 	private final static int METHOD_EMUL = 0;
@@ -120,7 +120,7 @@ public SourceTypeBinding(char[][] compoundName, PackageBinding fPackage, ClassSc
 	this.fields = Binding.UNINITIALIZED_FIELDS;
 	this.methods = Binding.UNINITIALIZED_METHODS;
 	this.prototype = this;
-	this.module = scope.module();
+	this.module = scope.environment().getModule(scope.module());
 	computeId();
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index f3f50e2..9090767 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -126,6 +126,7 @@ import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
 import org.eclipse.jdt.internal.compiler.ast.NameReference;
 import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
 import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
@@ -163,6 +164,7 @@ import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
@@ -10249,4 +10251,29 @@ public void invalidTypeArguments(TypeReference[] typeReference) {
 			typeReference[0].sourceStart,
 			typeReference[typeReference.length - 1].sourceEnd);
 }
+public void invalidModule(ModuleReference ref) {
+	this.handle(IProblem.UndefinedModule, 
+		NoArgument, new String[] { CharOperation.charToString(ref.moduleName) },
+		ref.sourceStart, ref.sourceEnd);
+}
+public void duplicateModuleReference(int problem, ModuleReference ref) {
+	this.handle(problem, 
+		NoArgument, new String[] { CharOperation.charToString(ref.moduleName) },
+		ref.sourceStart, ref.sourceEnd);
+}
+public void duplicateTypeReference(int problem, TypeReference ref) {
+	this.handle(problem, 
+		NoArgument, new String[] { ref.toString() },
+		ref.sourceStart, ref.sourceEnd);
+}
+public void duplicateTypeReference(int problem, TypeReference ref1, TypeReference ref2) {
+	this.handle(problem, 
+		NoArgument, new String[] { ref1.toString(), ref2.toString() },
+		ref1.sourceStart, ref2.sourceEnd);
+}
+public void cyclicModuleDependency(ModuleBinding binding, ModuleReference ref) {
+	this.handle(IProblem.CyclicModuleDependency, 
+		NoArgument, new String[] { CharOperation.charToString(binding.moduleName), CharOperation.charToString(ref.moduleName) },
+		ref.sourceStart, ref.sourceEnd);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 2319d37..61b76a4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -852,6 +852,13 @@
 
 1100 = Problem detected during type inference: {0}
 
+1200 = {0} cannot be resolved to a module
+1201 = Duplicate requires entry: {0}
+1202 = Duplicate exports entry: {0}
+1203 = Duplicate uses entry: {0}
+1204 = Duplicate service entry: provides {0} with {1}
+1205 = Cycle exists in module dependencies, Module {0} requires itself via {1}
+
 ### ELABORATIONS
 ## Access restrictions
 78592 = The type ''{1}'' is not API (restriction on classpath entry ''{0}'')
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetEnvironment.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetEnvironment.java
index 9da015a..b0fe539 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetEnvironment.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetEnvironment.java
@@ -104,4 +104,9 @@ public NameEnvironmentAnswer findType(char[] typeName, char[][] packageName, IMo
 public boolean isPackage(char[][] parentPackageName, char[] packageName, IModule[] module) {
 	return false;
 }
+@Override
+public IModule getModule(char[] name) {
+	// TODO Auto-generated method stub
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IJavaElement.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IJavaElement.java
index 62b9372..31a6b78 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IJavaElement.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IJavaElement.java
@@ -15,6 +15,7 @@ import org.eclipse.core.runtime.IAdaptable;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.jobs.ISchedulingRule;
+import org.eclipse.jdt.core.IModule.IPackageExport;
 
 /**
  * Common protocol for all elements provided by the Java model.
@@ -132,6 +133,19 @@ public interface IJavaElement extends IAdaptable {
 	int ANNOTATION = 16;
 
 	/**
+	 * Constant representing a module declaration.
+	 * A Java element with this type can be safely cast to {@link IModule}.
+	 * @since 3.12
+	 */
+	int MODULE_DECLARATION = 17;
+
+	/**
+	 * Constant representing a module declaration.
+	 * A Java element with this type can be safely cast to {@link IPackageExport}.
+	 * @since 3.12
+	 */
+	int PACKAGE_EXPORT = 17;
+	/**
 	 * Returns whether this Java element exists in the model.
 	 * <p>
 	 * Java elements are handle objects that may or may not be backed by an
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IModule.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IModule.java
index abd6a59..3102661 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IModule.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/IModule.java
@@ -14,6 +14,8 @@
  *******************************************************************************/
 package org.eclipse.jdt.core;
 
+import org.eclipse.core.runtime.IProgressMonitor;
+
 /**
  * @since 3.12 BETA_JAVA9
  */
@@ -21,13 +23,14 @@ public interface IModule {
 	
 	public char[] name();
 
-	public IModule[] requires();
+	public String[] requires() throws JavaModelException;
 
-	public IPackageFragment exports();
+	public IPackageExport[] exports() throws JavaModelException;
 
 	interface IPackageExport {
-		IPackageFragment exportedPackage();
-		IModule targetModule();
+		IPackageFragment getExportedPackage();
+		String getTargetModule();
 	}
-
+	IPackageExport createPackageExport(String contents, IJavaElement sibling, boolean force, IProgressMonitor monitor)
+			throws JavaModelException;
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
index 126ffac..863dbd5 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/ISourceElementRequestor.java
@@ -46,6 +46,19 @@ import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 @SuppressWarnings("rawtypes")
 public interface ISourceElementRequestor {
 
+	public static class ModuleInfo extends TypeInfo {
+		public char[] moduleName;
+		public RequiresInfo[] requires;
+		public PackageExportInfo[] exports;
+	}
+	public static class RequiresInfo {
+		public char[][] moduleName;
+		public int modifiers;
+	}
+	public static class PackageExportInfo {
+		public char[] pkgName;
+		public char[] targetModule;
+	}
 	public static class TypeInfo {
 		public boolean typeAnnotated;
 		public int declarationStart;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
index 6e69956..97d2d32 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/SourceElementNotifier.java
@@ -14,6 +14,7 @@ import java.util.ArrayList;
 import java.util.Map;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ISourceElementRequestor.ModuleInfo;
 import org.eclipse.jdt.internal.compiler.ISourceElementRequestor.ParameterInfo;
 import org.eclipse.jdt.internal.compiler.ISourceElementRequestor.TypeParameterInfo;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
@@ -37,6 +38,7 @@ import org.eclipse.jdt.internal.compiler.ast.ImportReference;
 import org.eclipse.jdt.internal.compiler.ast.Initializer;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
 import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
 import org.eclipse.jdt.internal.compiler.ast.ThisReference;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
@@ -598,7 +600,7 @@ protected void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boo
 		char[][] interfaceNames = getInterfaceNames(typeDeclaration);
 		int kind = TypeDeclaration.kind(typeDeclaration.modifiers);
 		char[] implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_OBJECT;
-		ISourceElementRequestor.TypeInfo typeInfo = new ISourceElementRequestor.TypeInfo();
+		ISourceElementRequestor.TypeInfo typeInfo = kind == TypeDeclaration.MODULE_DECL ? new ISourceElementRequestor.ModuleInfo(): new ISourceElementRequestor.TypeInfo();
 		typeInfo.typeAnnotated = ((typeDeclaration.bits & ASTNode.HasTypeAnnotations) != 0);
 		if (isInRange) {
 			int currentModifiers = typeDeclaration.modifiers;
@@ -649,6 +651,28 @@ protected void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boo
 				case TypeDeclaration.ANNOTATION_TYPE_DECL :
 					implicitSuperclassName = TypeConstants.CharArray_JAVA_LANG_ANNOTATION_ANNOTATION;
 					break;
+				case TypeDeclaration.MODULE_DECL:
+					ModuleDeclaration mod = (ModuleDeclaration)typeDeclaration;
+					ModuleInfo modInfo = (ModuleInfo)typeInfo;
+					modInfo.moduleName = mod.moduleName;
+					if (mod.requiresCount > 0) {
+						ISourceElementRequestor.RequiresInfo reqs[] = new ISourceElementRequestor.RequiresInfo[mod.requiresCount];
+						for (int i = 0; i < mod.requiresCount; i++) {
+							ISourceElementRequestor.RequiresInfo req = new ISourceElementRequestor.RequiresInfo();
+							req.moduleName = mod.requires[i].tokens;
+							req.modifiers = mod.requires[i].modifiers;
+						}
+						modInfo.requires = reqs;
+					}
+					if (mod.exportsCount > 0) {
+						ISourceElementRequestor.PackageExportInfo exports[] = new ISourceElementRequestor.PackageExportInfo[mod.exportsCount];
+						for (int i = 0; i < mod.exportsCount; i++) {
+							ISourceElementRequestor.PackageExportInfo exp = new ISourceElementRequestor.PackageExportInfo();
+							exp.pkgName = mod.exports[i].pkgName;
+							modInfo.exports = exports;
+						}					
+					}
+					break;
 			}
 		}
 		if (this.nestedTypeIndex == this.typeNames.length) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index 4a54cf5..e730b45 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -39,6 +39,7 @@ import org.eclipse.core.runtime.Path;
 import org.eclipse.core.runtime.Status;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
@@ -102,12 +103,15 @@ protected boolean buildStructure(OpenableElementInfo info, IProgressMonitor pm,
 		info.setChildren(new IJavaElement[] {});
 		return false;
 	}
-
+	
 	// Make the type
 	IType type = getType();
 	info.setChildren(new IJavaElement[] {type});
+	org.eclipse.jdt.internal.compiler.env.IModule moduleInfo = ((ClassFileReader)typeInfo).getModuleDeclaration();
 	newElements.put(type, typeInfo);
-
+	if (TypeDeclaration.kind(typeInfo.getModifiers()) == TypeDeclaration.MODULE_DECL) {
+		((PackageFragmentRootInfo)getPackageFragmentRoot().getElementInfo()).setModule(moduleInfo);
+	}
 	// Read children
 	((ClassFileInfo) info).readBinaryChildren(this, (HashMap) newElements, typeInfo);
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
index abf5a71..97c81b2 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
@@ -1357,7 +1357,13 @@ public ISourceRange getNameRange() {
 
 @Override
 public char[] module() {
-	IModule module = this.getPackageFragmentRoot().getModule();
+	org.eclipse.jdt.internal.compiler.env.IModule module = null;
+	try {
+		if (this.getPackageFragmentRoot().isOpen())
+			module = ((PackageFragmentRootInfo)this.getPackageFragmentRoot().getElementInfo()).getModule();
+	} catch (JavaModelException e) {
+		//
+	}
 	return (module == null) ? null : module.name();
 }
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
index d656423..644d33f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
@@ -23,6 +23,7 @@ import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IMemberValuePair;
 import org.eclipse.jdt.core.ITypeParameter;
+import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.Signature;
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
 import org.eclipse.jdt.core.compiler.CharOperation;
@@ -36,6 +37,7 @@ import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.ImportReference;
 import org.eclipse.jdt.internal.compiler.ast.Literal;
 import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
+import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.NullLiteral;
 import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
@@ -509,6 +511,16 @@ public void enterType(TypeInfo typeInfo) {
 		((TypeInfo) parentInfo).childrenCategories.put(handle, typeInfo.categories);
 	addToChildren(parentInfo, handle);
 }
+private org.eclipse.jdt.internal.core.ModuleInfo createModuleInfo(TypeInfo typeInfo, SourceType handle) {
+	org.eclipse.jdt.internal.core.ModuleInfo info = org.eclipse.jdt.internal.core.ModuleInfo.createModule((ModuleDeclaration) typeInfo.node);
+	info.setHandle(handle);
+	info.setSourceRangeStart(typeInfo.declarationStart);
+	info.setFlags(typeInfo.modifiers);
+	info.setNameSourceStart(typeInfo.nameSourceStart);
+	info.setNameSourceEnd(typeInfo.nameSourceEnd);
+	this.newElements.put(handle, info);
+	return info;
+}
 private SourceTypeElementInfo createTypeInfo(TypeInfo typeInfo, SourceType handle) {
 	SourceTypeElementInfo info =
 		typeInfo.anonymousMember ?
@@ -705,10 +717,21 @@ public void exitMethod(int declarationEnd, Expression defaultValue) {
 public void exitType(int declarationEnd) {
 	SourceType handle = (SourceType) this.handleStack.peek();
 	TypeInfo typeInfo = (TypeInfo) this.infoStack.peek();
-	SourceTypeElementInfo info = createTypeInfo(typeInfo, handle);
-	info.setSourceRangeEnd(declarationEnd);
-	info.children = getChildren(typeInfo);
-	
+	if (typeInfo instanceof ModuleInfo) {
+		PackageFragmentRoot root= (PackageFragmentRoot) handle.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
+		if (root != null) {
+			try {
+				((PackageFragmentRootInfo)(root.getElementInfo())).setModule(createModuleInfo(typeInfo, handle));
+			} catch (JavaModelException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+		}
+	} else {
+		SourceTypeElementInfo info = createTypeInfo(typeInfo, handle);
+		info.setSourceRangeEnd(declarationEnd);
+		info.children = getChildren(typeInfo);
+	}
 	this.handleStack.pop();
 	this.infoStack.pop();
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementRequestor.java
index 86b94bf..675fde4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaElementRequestor.java
@@ -15,8 +15,10 @@ import java.util.ArrayList;
 import org.eclipse.jdt.core.IField;
 import org.eclipse.jdt.core.IInitializer;
 import org.eclipse.jdt.core.IMethod;
+
 import org.eclipse.jdt.core.IPackageFragment;
 import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.internal.compiler.env.IModule;
 
 /**
  * @see IJavaElementRequestor
@@ -67,6 +69,12 @@ public class JavaElementRequestor implements IJavaElementRequestor {
 	protected ArrayList types= null;
 
 	/**
+	 * A collection of the resulting modules, or <code>null</code>
+	 * if no module results have been received
+	 */
+	protected ArrayList modules = null;
+
+	/**
 	 * Empty arrays used for efficiency
 	 */
 	protected static final IField[] EMPTY_FIELD_ARRAY= new IField[0];
@@ -74,6 +82,7 @@ public class JavaElementRequestor implements IJavaElementRequestor {
 	protected static final IType[] EMPTY_TYPE_ARRAY= new IType[0];
 	protected static final IPackageFragment[] EMPTY_PACKAGE_FRAGMENT_ARRAY= new IPackageFragment[0];
 	protected static final IMethod[] EMPTY_METHOD_ARRAY= new IMethod[0];
+	protected static final IModule[] EMPTY_MODULE_ARRAY= new IModule[0];
 /**
  * @see IJavaElementRequestor
  */
@@ -131,6 +140,15 @@ public void acceptType(IType type) {
 /**
  * @see IJavaElementRequestor
  */
+public void acceptModuleDeclaration(IModule module) {
+	if (this.modules == null) {
+		this.modules= new ArrayList();
+	}
+	this.modules.add(module);
+}
+/**
+ * @see IJavaElementRequestor
+ */
 public IField[] getFields() {
 	if (this.fields == null) {
 		return EMPTY_FIELD_ARRAY;
@@ -203,6 +221,18 @@ public IType[] getTypes() {
 /**
  * @see IJavaElementRequestor
  */
+public IModule[] getModules() {
+	if (this.modules == null) {
+		return EMPTY_MODULE_ARRAY;
+	}
+	int size = this.modules.size();
+	IModule[] results = new IModule[size];
+	this.modules.toArray(results);
+	return results;
+}
+/**
+ * @see IJavaElementRequestor
+ */
 public boolean isCanceled() {
 	return this.canceled;
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProjectElementInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProjectElementInfo.java
index 12a20a4..8032a41 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProjectElementInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProjectElementInfo.java
@@ -259,7 +259,7 @@ class JavaProjectElementInfo extends OpenableElementInfo {
 			return;
 		}
 		for (int j = 0, length = frags.length; j < length; j++) {
-			fragmentsCache.add(((PackageFragment) frags[j]).names);
+			if (frags[j] instanceof PackageFragment) fragmentsCache.add(((PackageFragment) frags[j]).names);
 		}
 	}
 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java
new file mode 100644
index 0000000..9a6e0c3
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java
@@ -0,0 +1,206 @@
+package org.eclipse.jdt.internal.core;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ExportReference;
+import org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+
+public class ModuleInfo extends SourceTypeElementInfo implements IModule {
+
+	protected static final IModuleReference[] NO_REQUIRES = new IModuleReference[0];
+	protected static final IPackageExport[] NO_EXPORTS = new IPackageExport[0];
+	protected static final IService[] NO_SERVICES = new IService[0];
+	protected static final char[][] NO_USES = new char[0][0];
+
+	static class ModuleReferenceImpl implements IModule.IModuleReference {
+		char[] name;
+		boolean isPublic = false;
+		@Override
+		public char[] name() {
+			return this.name;
+		}
+		@Override
+		public boolean isPublic() {
+			return this.isPublic;
+		}
+		
+	}
+	static class PackageExport implements IModule.IPackageExport {
+		char[] pack;
+		char[][] exportedTo;
+		@Override
+		public char[] name() {
+			return this.pack;
+		}
+
+		@Override
+		public char[][] exportedTo() {
+			return this.exportedTo;
+		}
+		public String toString() {
+			StringBuffer buffer = new StringBuffer();
+			buffer.append(this.pack);
+			if (this.exportedTo != null) {
+				for (char[] cs : this.exportedTo) {
+					buffer.append(cs);
+				}
+			}
+			buffer.append(';');
+			return buffer.toString();
+		}
+	}
+	static class Service implements IModule.IService {
+		char[] provides;
+		char[] with;
+		@Override
+		public char[] name() {
+			return this.provides;
+		}
+
+		@Override
+		public char[] with() {
+			return this.with;
+		}
+		public String toString() {
+			StringBuffer buffer = new StringBuffer();
+			buffer.append("provides"); //$NON-NLS-1$
+			buffer.append(this.provides);
+			buffer.append(" with "); //$NON-NLS-1$
+			buffer.append(this.with);
+			buffer.append(';');
+			return buffer.toString();
+		}
+	}
+	char[] name;
+	ModuleReferenceImpl[] requires;
+	PackageExport[] exports;
+	char[][] uses;
+	Service[] provides;
+	@Override
+	public char[] name() {
+		return this.name;
+	}
+
+	public static ModuleInfo createModule(ModuleDeclaration module) {
+		ModuleInfo mod = new ModuleInfo();
+		mod.name = module.moduleName;
+		if (module.requiresCount > 0) {
+			ModuleReference[] refs = module.requires;
+			mod.requires = new ModuleReferenceImpl[refs.length];
+			for (int i = 0; i < refs.length; i++) {
+				mod.requires[i] = new ModuleReferenceImpl();
+				mod.requires[i].name = CharOperation.concatWith(refs[i].tokens, '.');
+				mod.requires[i].isPublic = refs[i].isPublic();
+			}
+		} else {
+			mod.requires = new ModuleReferenceImpl[0];
+		}
+		if (module.exportsCount > 0) {
+			ExportReference[] refs = module.exports;
+			mod.exports = new PackageExport[refs.length];
+			for (int i = 0; i < refs.length; i++) {
+				PackageExport exp = createPackageExport(refs, i);
+				mod.exports[i] = exp;
+			}
+		} else {
+			mod.exports = new PackageExport[0];
+		}
+		if (module.usesCount > 0) {
+			TypeReference[] uses = module.uses;
+			mod.uses = new char[uses.length][];
+			for(int i = 0; i < uses.length; i++) {
+				mod.uses[i] = CharOperation.concatWith(uses[i].getTypeName(), '.');
+			}
+		}
+		if (module.servicesCount > 0) {
+			TypeReference[] services = module.interfaces;
+			TypeReference[] with = module.implementations;
+			mod.provides = new Service[module.servicesCount];
+			for (int i = 0; i < module.servicesCount; i++) {
+				mod.provides[i] = createService(services[i], with[i]);
+			}
+		}
+		return mod;
+	}
+
+	private static PackageExport createPackageExport(ExportReference[] refs, int i) {
+		ExportReference ref = refs[i];
+		PackageExport exp = new PackageExport();
+		exp.pack = CharOperation.concatWith(ref.tokens, '.');
+		ModuleReference[] imp = ref.targets;
+		if (imp != null) {
+			exp.exportedTo = new char[imp.length][];
+			for(int j = 0; j < imp.length; j++) {
+				exp.exportedTo = imp[j].tokens;
+			}
+		}
+		return exp;
+	}
+	private static Service createService(TypeReference service, TypeReference with) {
+		Service ser = new Service();
+		ser.provides = CharOperation.concatWith(service.getTypeName(), '.');
+		ser.with = CharOperation.concatWith(with.getTypeName(), '.');
+		return ser;
+	}
+
+	@Override
+	public IModule.IModuleReference[] requires() {
+		return this.requires;
+	}
+	@Override
+	public IPackageExport[] exports() {
+		return this.exports;
+	}
+	@Override
+	public char[][] uses() {
+		return this.uses;
+	}
+	@Override
+	public IService[] provides() {
+		return this.provides();
+	}
+	public String toString() {
+		StringBuffer buffer = new StringBuffer(getClass().getName());
+		toStringContent(buffer);
+		return buffer.toString();
+	}
+	protected void toStringContent(StringBuffer buffer) {
+		buffer.append("\nmodule "); //$NON-NLS-1$
+		buffer.append(this.name).append(' ');
+		buffer.append('{').append('\n');
+		if (this.requires != null) {
+			for(int i = 0; i < this.requires.length; i++) {
+				buffer.append("\trequires "); //$NON-NLS-1$
+				if (this.requires[i].isPublic) {
+					buffer.append(" public "); //$NON-NLS-1$
+				}
+				buffer.append(this.requires[i].name);
+				buffer.append(';').append('\n');
+			}
+		}
+		if (this.exports != null) {
+			buffer.append('\n');
+			for(int i = 0; i < this.exports.length; i++) {
+				buffer.append("\texports "); //$NON-NLS-1$
+				buffer.append(this.exports[i].toString());
+			}
+		}
+		if (this.uses != null) {
+			buffer.append('\n');
+			for (char[] cs : this.uses) {
+				buffer.append(cs);
+				buffer.append(';').append('\n');
+			}
+		}
+		if (this.provides != null) {
+			buffer.append('\n');
+			for(Service ser : this.provides) {
+				buffer.append(ser.toString());
+			}
+		}
+		buffer.append('\n').append('}').toString();
+	}
+
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
index 517b19b..e73aa68 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
@@ -29,9 +29,11 @@ import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.parser.ScannerHelper;
 import org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt;
@@ -60,11 +62,16 @@ import org.eclipse.jdt.internal.core.util.Util;
 public class NameLookup implements SuffixConstants {
 	public static class Answer {
 		public IType type;
+		public IModule module;
 		AccessRestriction restriction;
 		Answer(IType type, AccessRestriction restriction) {
 			this.type = type;
 			this.restriction = restriction;
 		}
+		Answer(IModule module) {
+			this.module = module;
+			this.restriction = null;
+		}
 		public boolean ignoreIfBetter() {
 			return this.restriction != null && this.restriction.ignoreIfBetter();
 		}
@@ -844,6 +851,15 @@ public class NameLookup implements SuffixConstants {
 		}
 		return findType(className, packageName, partialMatch, acceptFlags, considerSecondaryTypes, waitForIndexes, checkRestrictions, monitor);
 	}
+	public Answer findModule(String moduleName) {
+		JavaElementRequestor requestor = new JavaElementRequestor();
+		seekModules(moduleName, requestor);
+		org.eclipse.jdt.internal.compiler.env.IModule[] modules = requestor.getModules();
+		if (modules.length == 1) {
+			return new Answer(modules[0]);
+		}
+		return null;
+	}
 
 	private IType getMemberType(IType type, String name, int dot) {
 		while (dot != -1) {
@@ -962,6 +978,54 @@ public class NameLookup implements SuffixConstants {
 		seekTypes(name, pkg, partialMatch, acceptFlags, requestor, true);
 	}
 
+	public void seekModules(String name, JavaElementRequestor requestor) {
+		int count= this.packageFragmentRoots.length;
+		for (int i= 0; i < count; i++) {
+			if (requestor.isCanceled())
+				return;
+			//Answer answer = findType(String.valueOf(TypeConstants.MODULE_INFO_NAME), false, 0, false);
+			IPackageFragmentRoot root= this.packageFragmentRoots[i];
+			IModule module = null;
+			if (root instanceof JarPackageFragmentRoot) {
+				if (!root.getElementName().equals(name)) {
+					continue;
+				}
+			} else {
+				try {
+					module = ((PackageFragmentRootInfo) ((PackageFragmentRoot) root).getElementInfo()).getModule();
+				} catch (JavaModelException e1) {
+					//
+					continue;
+				}
+			}
+			if (module != null && CharOperation.equals(module.name(), name.toCharArray()))
+				requestor.acceptModuleDeclaration(module);
+			else if (module == null) {
+				try {
+					IJavaElement[] compilationUnits = root.getChildren();
+					for (int j = 0, length = compilationUnits.length; j < length; j++) {
+						if (requestor.isCanceled())
+							return;
+						// only look in the default package
+						if (compilationUnits[j].getElementName().length() > 0)
+							continue;
+						IType type = findType(String.valueOf(TypeConstants.MODULE_INFO_NAME), (PackageFragment)compilationUnits[j], false, 0, false, false);
+						if (type == null)
+							continue;
+						if (type.isBinary()) {
+								module = ((ClassFileReader)(((BinaryType)type).getElementInfo())).getModuleDeclaration();
+						} else {
+							module = (IModule)(((SourceType)type).getElementInfo());
+						}
+						if (module != null && CharOperation.equals(module.name(), name.toCharArray()))
+							requestor.acceptModuleDeclaration(module);
+					}
+				} catch (JavaModelException e) {
+					//
+				}
+			}
+		}
+	}
 	/**
 	 * Notifies the given requestor of all types (classes and interfaces) in the
 	 * given package fragment with the given (unqualified) name.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/OpenableElementInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/OpenableElementInfo.java
index 6a7dc0c..d5698ae 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/OpenableElementInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/OpenableElementInfo.java
@@ -12,6 +12,9 @@
 package org.eclipse.jdt.internal.core;
 
 import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+
+
 
 /** Element info for IOpenable elements. */
 public class OpenableElementInfo extends JavaElementInfo {
@@ -22,7 +25,7 @@ public class OpenableElementInfo extends JavaElementInfo {
 	 * no children.
 	 */
 	protected volatile IJavaElement[] children = JavaElement.NO_ELEMENTS;
-	
+	protected IModule module;
 	/**
 	 * Is the structure of this element known
 	 * @see IJavaElement#isStructureKnown()
@@ -79,6 +82,12 @@ public class OpenableElementInfo extends JavaElementInfo {
 		this.children = children;
 	}
 
+	public void setModule(IModule module) {
+		this.module = module;
+	}
+	public IModule getModule() {
+		return this.module;
+	}
 	/**
 	 * Sets whether the structure of this element known
 	 * @see IJavaElement#isStructureKnown()
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index 68c0464..05d59b8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -22,6 +22,7 @@ import org.eclipse.core.resources.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
+
 import org.eclipse.jdt.internal.core.util.MementoTokenizer;
 import org.eclipse.jdt.internal.core.util.Messages;
 import org.eclipse.jdt.internal.core.util.Util;
@@ -200,6 +201,12 @@ protected boolean computeChildren(OpenableElementInfo info, IResource underlying
 			char[][] inclusionPatterns = fullInclusionPatternChars();
 			char[][] exclusionPatterns = fullExclusionPatternChars();
 			computeFolderChildren(rootFolder, !Util.isExcluded(rootFolder, inclusionPatterns, exclusionPatterns), CharOperation.NO_STRINGS, vChildren, inclusionPatterns, exclusionPatterns);
+//			char[] suffix = getKind() == K_SOURCE ? SuffixConstants.SUFFIX_java : SuffixConstants.SUFFIX_class;
+//			char[] moduleInfoName = CharOperation.concat(TypeConstants.MODULE_INFO_NAME, suffix);
+//			IResource module = rootFolder.findMember(String.valueOf(moduleInfoName), true);
+//			if (module != null && module.exists()) {
+//				vChildren.add(new ClassFile(getPackageFragment(CharOperation.NO_STRINGS), String.valueOf(TypeConstants.MODULE_INFO_NAME)));
+//			}
 			IJavaElement[] children = new IJavaElement[vChildren.size()];
 			vChildren.toArray(children);
 			info.setChildren(children);
@@ -837,6 +844,13 @@ protected void verifyAttachSource(IPath sourcePath) throws JavaModelException {
 
 @Override
 public IModule getModule() {
-	return null;
+	IModule module = null;
+//	try {
+//		module = ((PackageFragmentRootInfo)getElementInfo()).getModule();
+//
+//	} catch (JavaModelException e) {
+//		// 
+//	}
+	return module;
 }
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
index 1901266..a16bd1d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
@@ -730,4 +730,14 @@ public class SearchableEnvironment extends ModuleEnvironment
 	public void cleanup() {
 		// nothing to do
 	}
+
+	@Override
+	public IModule getModule(char[] name) {
+		IModule module = null;
+		NameLookup.Answer answer = this.nameLookup.findModule(CharOperation.charToString(name));
+		if (answer != null) {
+			module = answer.module;
+		}
+		return module;
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
index af3c0ca..681de84 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
@@ -21,6 +21,7 @@ import org.eclipse.core.resources.IResource;
 import org.eclipse.core.runtime.CoreException;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
@@ -120,9 +121,10 @@ String[] directoryList(String qualifiedPackageName) {
 }
 void acceptModule(ClassFileReader classfile) {
 	if (classfile != null) {
-		if ((this.module = classfile.getModuleDeclaration()) != null) {
-			this.env.acceptModule(this.module, this);
-		}
+//		if ((this.module = classfile.getModuleDeclaration()) != null) {
+//			this.env.acceptModule(this.module, this);
+//		}
+		this.module = classfile.getModuleDeclaration();
 	}
 }
 boolean doesFileExist(String fileName, String qualifiedPackageName, String qualifiedFullName) {
@@ -152,9 +154,9 @@ public NameEnvironmentAnswer findClass(String typeName, String qualifiedPackageN
 
 public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String qualifiedBinaryFileName, IModule mod) {
 	if (!doesFileExist(binaryFileName, qualifiedPackageName, qualifiedBinaryFileName)) return null; // most common case
-	if (!this.env.isPackageVisible(qualifiedPackageName.toCharArray(), this.module != null ? this.module.name() : null, mod != null ? mod.name() : null)) {
-		return null;
-	}
+//	if (!this.env.isPackageVisible(qualifiedPackageName.toCharArray(), this.module != null ? this.module.name() : null, mod != null ? mod.name() : null)) {
+//		return null;
+//	}
 	ClassFileReader reader = null;
 	try {
 		reader = Util.newClassFileReader(this.binaryFolder.getFile(new Path(qualifiedBinaryFileName)));
@@ -218,4 +220,12 @@ public boolean servesModule(IModule mod) {
 		return true;
 	return this.module.equals(mod);
 }
+
+@Override
+public IModule getModule(char[] moduleName) {
+	// 
+	if (this.module == null)
+		return null;
+	return CharOperation.equals(this.module.name(), moduleName) ? this.module : null;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index 4c41607..83b0e61 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -19,6 +19,7 @@ package org.eclipse.jdt.internal.core.builder;
 
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.runtime.*;
+import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
@@ -103,9 +104,10 @@ static SimpleSet findPackageSet(final ClasspathJar jar) {
 }
 void acceptModule(ClassFileReader classfile) {
 	if (classfile != null) {
-		if ((this.module = classfile.getModuleDeclaration()) != null) {
-			this.env.acceptModule(this.module, this);
-		}
+//		if ((this.module = classfile.getModuleDeclaration()) != null) {
+//			this.env.acceptModule(this.module, this);
+//		}
+		this.module = classfile.getModuleDeclaration();
 	}
 }
 
@@ -281,4 +283,12 @@ public boolean servesModule(IModule mod) {
 		return true;
 	return this.module.equals(mod);
 }
+
+@Override
+public IModule getModule(char[] moduleName) {
+	// 
+	if (this.module != null && CharOperation.equals(moduleName, this.module.name()))
+		return this.module;
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJimage.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJimage.java
index f3d0d2e..8b7c0d1 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJimage.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJimage.java
@@ -20,10 +20,12 @@ import java.nio.file.FileVisitResult;
 import java.nio.file.Path;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Set;
 import java.util.zip.ZipFile;
 
 import org.eclipse.core.runtime.IPath;
+import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
 import org.eclipse.jdt.internal.compiler.env.IModule;
@@ -137,9 +139,9 @@ public static void loadModules(final ClasspathJimage jimage) {
 			// TODO: BETA_JAVA9 Should report better
 		}
 	} else {
-		for (IModule iModule : cache) {
-			jimage.env.acceptModule(iModule, jimage);
-		}
+//		for (IModule iModule : cache) {
+//			jimage.env.acceptModule(iModule, jimage);
+//		}
 	}
 }
 void acceptModule(byte[] content) {
@@ -153,8 +155,14 @@ void acceptModule(byte[] content) {
 	}
 	if (reader != null) {
 		IModule moduleDecl = reader.getModuleDeclaration();
-		if (moduleDecl != null)
-			this.env.acceptModule(moduleDecl, this);
+		if (moduleDecl != null) {
+			Set<IModule> cache = ModulesCache.get(this.zipFilename);
+			if (cache == null) {
+				ModulesCache.put(this.zipFilename, new HashSet<IModule>());
+			}
+			cache.add(moduleDecl);
+			//this.env.acceptModule(moduleDecl, this);
+		}
 	}
 }
 public void cleanup() {
@@ -251,4 +259,16 @@ public boolean servesModule(IModule mod) {
 	}
 	return false;
 }
+@Override
+public IModule getModule(char[] moduleName) {
+	// 
+	Set<IModule> modules = ModulesCache.get(this.zipFilename);
+	if (modules != null) {
+		for (IModule mod : modules) {
+			if (CharOperation.equals(mod.name(), moduleName))
+					return mod;
+		}
+	}
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
index de94c3d..23ab6ff 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathMultiDirectory.java
@@ -85,7 +85,7 @@ public void acceptModuleInfo(ICompilationUnit cu, Parser parser) {
 		IModule mod = ModuleEnvironment.createModule(unit.moduleDeclaration);
 		if (mod != null) {
 			this.module = mod;
-			this.env.acceptModule(mod, this);
+			//this.env.acceptModule(mod, this);
 		}
 	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java
index a6d07ec..1f90084 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/IncrementalImageBuilder.java
@@ -648,7 +648,7 @@ protected boolean findSourceFiles(IResourceDelta sourceDelta, ClasspathMultiDire
 						this.sourceFiles.add(new SourceFile((IFile) resource, md, true));
 						complianceLevel = IncrementalImageBuilder.this.javaBuilder.javaProject.getOption(JavaCore.COMPILER_COMPLIANCE, true);
 						if (CompilerOptions.versionToJdkLevel(complianceLevel) >= ClassFileConstants.JDK1_9) {
-							md.resetModule(this.nameEnvironment.getModule(md));
+							//md.resetModule(this.nameEnvironment.getModule(md)); TODO: revisit why this is needed
 						}
 				}
 				return true;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index 111a5c3..c8593c7 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -359,14 +359,22 @@ public boolean isPackage(char[][] compoundName, char[] packageName, IModule[] mo
 }
 
 public boolean isPackage(String qualifiedPackageName, IModule[] modules) {
-	// NOTE: the output folders are added at the beginning of the binaryLocations
-	for (int i = 0, l = this.binaryLocations.length; i < l; i++) {
-		for (IModule iModule : modules) {
-			if (this.binaryLocations[i].servesModule(iModule)) {
-				// TODO: BETA_JAVA9 Should really check with the module context.
-				if (this.binaryLocations[i].isPackage(qualifiedPackageName))
+	if (modules == null) {
+		for (int i = 0, l = this.binaryLocations.length; i < l; i++) {
+			// TODO: BETA_JAVA9 Should really check with the module context.
+			if (this.binaryLocations[i].isPackage(qualifiedPackageName))
 					return true;
 			}
+	} else {
+		// NOTE: the output folders are added at the beginning of the binaryLocations
+		for (int i = 0, l = this.binaryLocations.length; i < l; i++) {
+			for (IModule iModule : modules) {
+				if (this.binaryLocations[i].servesModule(iModule)) {
+					// TODO: BETA_JAVA9 Should really check with the module context.
+					if (this.binaryLocations[i].isPackage(qualifiedPackageName))
+						return true;
+				}
+			}
 		}
 	}
 	return false;
@@ -399,6 +407,25 @@ void setNames(String[] typeNames, SourceFile[] additionalFiles) {
 		this.binaryLocations[i].reset();
 }
 
+@Override
+public IModule getModule(char[] name) {
+	// 
+	if (name == null)
+		return null;
+	IModule module = null;
+	for (int i = 0, l = this.sourceLocations.length; i < l; i++) {
+		if ((module = this.sourceLocations[i].getModule(name)) != null)
+			break;
+	}
+	if (module == null) {
+		for (int i = 0, l = this.binaryLocations.length; i < l; i++) {
+			if ((module = this.binaryLocations[i].getModule(name)) != null)
+				break;
+		}
+	}
+	return module;
+}
+
 //@Override
 //public void acceptModule(IModule mod) {
 //	this.ms.acceptModule(mod);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
index 79999b2..bf9cb0f 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ClasspathSourceDirectory.java
@@ -161,4 +161,13 @@ public boolean servesModule(IModule mod) {
 		return true;
 	return CharOperation.equals(this.module.name(), mod.name());
 }
+
+@Override
+public IModule getModule(char[] moduleName) {
+	// 
+	if (this.module != null && CharOperation.equals(this.module.name(), moduleName)) {
+		return this.module;
+	}
+	return null;
+}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
index 20055a2..45f2f35 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/JavaSearchNameEnvironment.java
@@ -224,4 +224,10 @@ public boolean isPackage(String qualifiedPackageName, IModule[] modules) {
 	return false;
 }
 
+@Override
+public IModule getModule(char[] name) {
+	// TODO Auto-generated method stub
+	return null;
+}
+
 }
commit a094f91e94a12f5a24842148840a250ae35927cb
Author: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
Date:   Fri Jun 24 13:38:38 2016 +0530

    bug 479610 [1.9][compiler] Compiler support for module-info.java
    
    Module support - improvements in NameLookup and module lookup - every
    lookup for a type also answers the module the type was found in
    NameLookup uses the module context passed in during type look up, so
    that only types declared in the specified modules are returned
    PackageFragmentRoot answers getModule()
    
    Change-Id: I90dfa9d0f3c1760b05e7bb1628baaa20527f2270

9	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
16	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
0	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
20	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
0	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
1	5	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
1	7	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
3	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
15	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java
117	27	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
53	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
4	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
5	7	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
1	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
index a5e2a42..d938a29 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
@@ -94,7 +94,7 @@ public class CompilationUnitDeclaration extends ASTNode implements ProblemSeveri
 	 * moduleDeclaration, which represents the module this compilation unit may
 	 * define, i.e. if this unit represents module-info.java.
 	 */
-	public char[] module;
+//	public char[] module;
 
 public CompilationUnitDeclaration(ProblemReporter problemReporter, CompilationResult compilationResult, int sourceLength) {
 	this.problemReporter = problemReporter;
@@ -102,13 +102,6 @@ public CompilationUnitDeclaration(ProblemReporter problemReporter, CompilationRe
 	//by definition of a compilation unit....
 	this.sourceStart = 0;
 	this.sourceEnd = sourceLength - 1;
-	 if (compilationResult != null) {
-		 if (this.isModuleInfo()) {
-			 this.module = this.moduleDeclaration != null ? this.moduleDeclaration.moduleName : ModuleEnvironment.UNNAMED;
-		 } else if (compilationResult.compilationUnit != null) {
-			 this.module = compilationResult.compilationUnit.module();
-		 }
-	 }
 }
 
 /*
@@ -788,4 +781,12 @@ public void traverse(ASTVisitor visitor, CompilationUnitScope unitScope, boolean
 		// ignore
 	}
 }
+public char[] module() {
+	if (this.isModuleInfo()) {
+		return this.moduleDeclaration != null ? this.moduleDeclaration.moduleName : ModuleEnvironment.UNNAMED;
+	} else if (this.compilationResult != null && this.compilationResult.compilationUnit != null) {
+		return this.compilationResult.compilationUnit.module();
+	}
+	return ModuleEnvironment.UNNAMED;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
index 73a36af..894e3c2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
@@ -14,6 +14,8 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.env;
 
+import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment;
+
 public class NameEnvironmentAnswer {
 
 	// only one of the three can be set
@@ -25,21 +27,32 @@ public class NameEnvironmentAnswer {
 	String externalAnnotationPath; // should be an absolute file system path
 
 	public NameEnvironmentAnswer(IBinaryType binaryType, AccessRestriction accessRestriction) {
+		this(binaryType, accessRestriction, binaryType.getModule());
+	}
+
+	public NameEnvironmentAnswer(IBinaryType binaryType, AccessRestriction accessRestriction, char[] module) {
 		this.binaryType = binaryType;
 		this.accessRestriction = accessRestriction;
-		this.module = binaryType.getModule();
+		this.module = module;
 	}
-
 	public NameEnvironmentAnswer(ICompilationUnit compilationUnit, AccessRestriction accessRestriction) {
+		this(compilationUnit, accessRestriction, compilationUnit.module());
+	}
+	public NameEnvironmentAnswer(ICompilationUnit compilationUnit, AccessRestriction accessRestriction, char[] module) {
 		this.compilationUnit = compilationUnit;
 		this.accessRestriction = accessRestriction;
-		this.module = compilationUnit.module();
+		this.module = module;
 	}
 
 	public NameEnvironmentAnswer(ISourceType[] sourceTypes, AccessRestriction accessRestriction, String externalAnnotationPath) {
+		this(sourceTypes, accessRestriction, externalAnnotationPath, ModuleEnvironment.UNNAMED);
+	}
+
+	public NameEnvironmentAnswer(ISourceType[] sourceTypes, AccessRestriction accessRestriction, String externalAnnotationPath, char[] module) {
 		this.sourceTypes = sourceTypes;
 		this.accessRestriction = accessRestriction;
 		this.externalAnnotationPath = externalAnnotationPath;
+		this.module = module;
 	}
 	/**
 	 * Returns the associated access restriction, or null if none.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index babf5ec..8859863 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -270,7 +270,6 @@ public BinaryTypeBinding(PackageBinding packageBinding, IBinaryType binaryType,
 	this.environment = environment;
 	this.fPackage = packageBinding;
 	this.fileName = binaryType.getFileName();
-	this.module = environment.getModule(binaryType.getModule());
 	/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=324850, even in a 1.4 project, we
 	   must internalize type variables and observe any parameterization of super class
 	   and/or super interfaces in order to be able to detect overriding in the presence
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
index 0c07c11..733df49 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ClassScope.java
@@ -425,6 +425,7 @@ public class ClassScope extends Scope {
 		}
 
 		SourceTypeBinding sourceType = this.referenceContext.binding;
+		sourceType.module = environment().getModule(module());
 		environment().setAccessRestriction(sourceType, accessRestriction);
 		
 		TypeParameter[] typeParameters = this.referenceContext.typeParameters;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index d4ef740..d44a305 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -157,7 +157,7 @@ public ReferenceBinding askForType(char[][] compoundName) {
 }
 //TODO: BETA_JAVA9 - should ideally return ModuleBinding?
 public ModuleBinding getModule(char[] name) {
-	if (name == null || name.length == 0)
+	if (name == null || name.length == 0 || CharOperation.equals(name, ModuleEnvironment.UNNAMED))
 		return ModuleBinding.UnNamedModule;
 	ModuleBinding module = (ModuleBinding) this.knownModules.get(name);
 	if (module == null) {
@@ -179,16 +179,25 @@ public ModuleBinding createModuleInfo(CompilationUnitScope scope) {
 public ReferenceBinding askForType(char[][] compoundName, char[] mod) {
 	NameEnvironmentAnswer answer = this.nameEnvironment.findType(compoundName, mod);
 	if (answer == null) return null;
-
 	if (answer.isBinaryType()) {
 		// the type was found as a .class file
-		this.typeRequestor.accept(answer.getBinaryType(), computePackageFrom(compoundName, false /* valid pkg */), answer.getAccessRestriction());
+		PackageBinding pkg = computePackageFrom(compoundName, false /* valid pkg */);
+		this.typeRequestor.accept(answer.getBinaryType(), pkg, answer.getAccessRestriction());
+		ReferenceBinding binding = pkg.getType0(compoundName[compoundName.length - 1]);
+		if (binding instanceof BinaryTypeBinding) {
+			((BinaryTypeBinding) binding).module = getModule(answer.moduleName());
+		}
 	} else if (answer.isCompilationUnit()) {
 		// the type was found as a .java file, try to build it then search the cache
 		this.typeRequestor.accept(answer.getCompilationUnit(), answer.getAccessRestriction());
 	} else if (answer.isSourceType()) {
 		// the type was found as a source model
-		this.typeRequestor.accept(answer.getSourceTypes(), computePackageFrom(compoundName, false /* valid pkg */), answer.getAccessRestriction());
+		PackageBinding pkg = computePackageFrom(compoundName, false /* valid pkg */);
+		this.typeRequestor.accept(answer.getSourceTypes(), pkg, answer.getAccessRestriction());
+		ReferenceBinding binding = pkg.getType0(compoundName[compoundName.length - 1]);
+		if (binding instanceof SourceTypeBinding) {
+			((SourceTypeBinding) binding).module = getModule(answer.moduleName());
+		}
 	}
 	return getCachedType(compoundName);
 }
@@ -215,6 +224,10 @@ ReferenceBinding askForType(PackageBinding packageBinding, char[] name, char[] m
 	if (answer.isBinaryType()) {
 		// the type was found as a .class file
 		this.typeRequestor.accept(answer.getBinaryType(), packageBinding, answer.getAccessRestriction());
+		ReferenceBinding binding = packageBinding.getType0(name);
+		if (binding instanceof BinaryTypeBinding) {
+			((BinaryTypeBinding) binding).module = getModule(module);
+		}
 	} else if (answer.isCompilationUnit()) {
 		// the type was found as a .java file, try to build it then search the cache
 		try {
@@ -228,6 +241,9 @@ ReferenceBinding askForType(PackageBinding packageBinding, char[] name, char[] m
 		// the type was found as a source model
 		this.typeRequestor.accept(answer.getSourceTypes(), packageBinding, answer.getAccessRestriction());
 		ReferenceBinding binding = packageBinding.getType0(name);
+		if (binding instanceof SourceTypeBinding) {
+			((SourceTypeBinding) binding).module = getModule(module);
+		}
 		String externalAnnotationPath = answer.getExternalAnnotationPath();
 		if (externalAnnotationPath != null && this.globalOptions.isAnnotationBasedNullAnalysisEnabled && binding instanceof SourceTypeBinding) {
 			ExternalAnnotationSuperimposer.apply((SourceTypeBinding) binding, externalAnnotationPath);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
index 2ab5c50..6313669 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleEnvironment.java
@@ -188,7 +188,7 @@ public abstract class ModuleEnvironment implements INameEnvironmentExtension {
 	}
 
 	public IModule[] getVisibleModules(char[] mod) {
-		IModule[] targets = null;
+		IModule[] targets = new IModule[0];
 		if (mod != null && !CharOperation.equals(mod, UNNAMED)) {
 			Set<IModule> set = new LinkedHashSet<>();
 			IModule client = getModule(JRTUtil.JAVA_BASE.toCharArray());
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index 81ea686..d78d199 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -668,7 +668,7 @@ public abstract class Scope {
 		return (CompilationUnitScope) lastScope;
 	}
 	public final char[] module() {
-		return compilationUnitScope().referenceCompilationUnit().module;
+		return compilationUnitScope().referenceCompilationUnit().module();
 	}
 	public boolean isLambdaScope() {
 		return false;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 71ae416..722da1e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -124,7 +124,6 @@ public SourceTypeBinding(char[][] compoundName, PackageBinding fPackage, ClassSc
 	this.fields = Binding.UNINITIALIZED_FIELDS;
 	this.methods = Binding.UNINITIALIZED_METHODS;
 	this.prototype = this;
-	this.module = scope.environment().getModule(scope.module());
 	computeId();
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
index 31c3643..74d5894 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeConstants.java
@@ -397,7 +397,8 @@ public interface TypeConstants {
 	public static final char[] PACKAGE_INFO_NAME = "package-info".toCharArray(); //$NON-NLS-1$
 	public static final char[] MODULE_INFO_NAME = "module-info".toCharArray(); //$NON-NLS-1$
 	public static final char[] MODULE_INFO_FILE_NAME = "module-info.java".toCharArray(); //$NON-NLS-1$
-
+	public static final String MODULE_INFO_FILE_NAME_STRING = "module-info.java"; //$NON-NLS-1$
+	public static final String MODULE_INFO_CLASS_NAME_STRING = "module-info.class"; //$NON-NLS-1$
 	// java.base module name
 	char[] JAVA_BASE = "java.base".toCharArray(); //$NON-NLS-1$
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
index 1c9819b..ff05146 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/compiler/parser/SourceTypeConverter.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2016 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -114,10 +114,6 @@ public class SourceTypeConverter extends TypeConverter {
 		SourceTypeElementInfo topLevelTypeInfo = (SourceTypeElementInfo) sourceTypes[0];
 		org.eclipse.jdt.core.ICompilationUnit cuHandle = topLevelTypeInfo.getHandle().getCompilationUnit();
 		this.cu = (ICompilationUnit) cuHandle;
-		OpenableElementInfo info =  (OpenableElementInfo) ((PackageFragment) cuHandle.getParent()).getPackageFragmentRoot().getElementInfo();
-		IModule module = info.getModule();
-		if (module != null)
-			this.unit.module = module.name();
 		final CompilationUnitElementInfo compilationUnitElementInfo = (CompilationUnitElementInfo) ((JavaElement) this.cu).getElementInfo();
 		if (this.has1_5Compliance && 
 				(compilationUnitElementInfo.annotationNumber >= CompilationUnitElementInfo.ANNOTATION_THRESHOLD_FOR_DIET_PARSE ||
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
index 97c81b2..22d5bf8 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnit.java
@@ -1357,13 +1357,7 @@ public ISourceRange getNameRange() {
 
 @Override
 public char[] module() {
-	org.eclipse.jdt.internal.compiler.env.IModule module = null;
-	try {
-		if (this.getPackageFragmentRoot().isOpen())
-			module = ((PackageFragmentRootInfo)this.getPackageFragmentRoot().getElementInfo()).getModule();
-	} catch (JavaModelException e) {
-		//
-	}
+	org.eclipse.jdt.internal.compiler.env.IModule module = (this.getPackageFragmentRoot()).getModule();
 	return (module == null) ? null : module.name();
 }
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
index 869d960..b5ff7a9 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitStructureRequestor.java
@@ -724,7 +724,9 @@ public void exitType(int declarationEnd) {
 		PackageFragmentRoot root= (PackageFragmentRoot) handle.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
 		if (root != null) {
 			try {
-				((PackageFragmentRootInfo)(root.getElementInfo())).setModule(createModuleInfo(typeInfo, handle));
+				org.eclipse.jdt.internal.core.ModuleInfo module = createModuleInfo(typeInfo, handle);
+				this.unitInfo.setModule(module);
+				((PackageFragmentRootInfo)(root.getElementInfo())).setModule(module);
 			} catch (JavaModelException e) {
 				// TODO Auto-generated catch block
 				e.printStackTrace();
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java
index 9a6e0c3..47c68ca 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleInfo.java
@@ -1,3 +1,17 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
 package org.eclipse.jdt.internal.core;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
@@ -133,7 +147,7 @@ public class ModuleInfo extends SourceTypeElementInfo implements IModule {
 		if (imp != null) {
 			exp.exportedTo = new char[imp.length][];
 			for(int j = 0; j < imp.length; j++) {
-				exp.exportedTo = imp[j].tokens;
+				exp.exportedTo[j] = imp[j].moduleName;
 			}
 		}
 		return exp;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
index 7046b47..7e5205d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
@@ -67,9 +67,13 @@ public class NameLookup implements SuffixConstants {
 		AccessRestriction restriction;
 		IClasspathEntry entry;
 		Answer(IType type, AccessRestriction restriction, IClasspathEntry entry) {
+			this(type, restriction, entry, ModuleEnvironment.UNNAMED_MODULE);
+		}
+		Answer(IType type, AccessRestriction restriction, IClasspathEntry entry, IModule module) {
 			this.type = type;
 			this.restriction = restriction;
 			this.entry = entry;
+			this.module = module;
 		}
 		Answer(IModule module) {
 			this.module = module;
@@ -624,6 +628,41 @@ public class NameLookup implements SuffixConstants {
 	}
 
 	/**
+	 * Find type in the given modules considering secondary types but without waiting for indexes.
+	 * It means that secondary types may be not found under certain circumstances...
+	 * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=118789"
+	 */
+	public Answer findType(String typeName, String packageName, boolean partialMatch, int acceptFlags, boolean checkRestrictions, IModule[] modules) {
+		Answer suggestedAnswer = null;
+		if (modules != null) {
+			for (IModule module : modules) {
+				Answer answer = findType(typeName, packageName, partialMatch, acceptFlags,
+						true/* consider secondary types */, false/* do NOT wait for indexes */, checkRestrictions,
+						module.name(), null);
+				if (answer != null) {
+					if (!answer.ignoreIfBetter()) {
+						if (answer.isBetter(suggestedAnswer))
+							return answer;
+					} else if (answer.isBetter(suggestedAnswer))
+						// remember suggestion and keep looking
+						suggestedAnswer = answer;
+				}
+			}
+		} else {
+			suggestedAnswer = findType(typeName,
+					packageName,
+					partialMatch,
+					acceptFlags,
+					true/* consider secondary types */,
+					false/* do NOT wait for indexes */,
+					checkRestrictions,
+					null,
+					null);
+		}
+		return suggestedAnswer;
+	}
+
+	/**
 	 * Find type considering secondary types but without waiting for indexes.
 	 * It means that secondary types may be not found under certain circumstances...
 	 * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=118789"
@@ -638,7 +677,29 @@ public class NameLookup implements SuffixConstants {
 			checkRestrictions,
 			null);
 	}
+	/**
+	 * Find type. Considering secondary types and waiting for indexes depends on given corresponding parameters.
+	 */
+	public Answer findType(
+			String typeName,
+			String packageName,
+			boolean partialMatch,
+			int acceptFlags,
+			boolean considerSecondaryTypes,
+			boolean waitForIndexes,
+			boolean checkRestrictions,
+			IProgressMonitor monitor) {
 
+		return findType(typeName,
+				packageName,
+				partialMatch,
+				acceptFlags,
+				considerSecondaryTypes,
+				waitForIndexes,
+				checkRestrictions,
+				null,
+				monitor);
+	}
 	/**
 	 * Find type. Considering secondary types and waiting for indexes depends on given corresponding parameters.
 	 */
@@ -650,6 +711,7 @@ public class NameLookup implements SuffixConstants {
 			boolean considerSecondaryTypes,
 			boolean waitForIndexes,
 			boolean checkRestrictions,
+			char[] module,
 			IProgressMonitor monitor) {
 		if (packageName == null || packageName.length() == 0) {
 			packageName= IPackageFragment.DEFAULT_PACKAGE_NAME;
@@ -660,7 +722,7 @@ public class NameLookup implements SuffixConstants {
 
 		// Look for concerned package fragments
 		JavaElementRequestor elementRequestor = new JavaElementRequestor();
-		seekPackageFragments(packageName, false, elementRequestor);
+		seekPackageFragments(packageName, false, module, elementRequestor);
 		IPackageFragment[] packages= elementRequestor.getPackageFragments();
 
 		// Try to find type in package fragments list
@@ -680,7 +742,7 @@ public class NameLookup implements SuffixConstants {
 						accessRestriction = getViolatedRestriction(typeName, packageName, entry, accessRestriction);
 					}
 				}
-				Answer answer = new Answer(type, accessRestriction, entry);
+				Answer answer = new Answer (type, accessRestriction, entry, getModule(root));
 				if (!answer.ignoreIfBetter()) {
 					if (answer.isBetter(suggestedAnswer))
 						return answer;
@@ -739,6 +801,10 @@ public class NameLookup implements SuffixConstants {
 		return type == null ? null : new Answer(type, null, null);
 	}
 
+	private IModule getModule(PackageFragmentRoot root) {
+		IModule module = root.getModule();
+		return module == null ? ModuleEnvironment.UNNAMED_MODULE : module;
+	}
 	private AccessRestriction getViolatedRestriction(String typeName, String packageName, ClasspathEntry entry, AccessRestriction accessRestriction) {
 		AccessRuleSet accessRuleSet = entry.getAccessRuleSet();
 		if (accessRuleSet != null) {
@@ -856,9 +922,9 @@ public class NameLookup implements SuffixConstants {
 	}
 	public Answer findModule(String moduleName) {
 		JavaElementRequestor requestor = new JavaElementRequestor();
-		seekModules(moduleName, requestor);
+		seekModules(moduleName.toCharArray(), requestor);
 		org.eclipse.jdt.internal.compiler.env.IModule[] modules = requestor.getModules();
-		if (modules.length == 1) {
+		if (modules.length == 1) { // TODO what to do??
 			return new Answer(modules[0]);
 		}
 		return null;
@@ -925,12 +991,27 @@ public class NameLookup implements SuffixConstants {
 	 *	only exact name matches qualify when <code>false</code>
 	 */
 	public void seekPackageFragments(String name, boolean partialMatch, IJavaElementRequestor requestor) {
+		seekPackageFragments(name, partialMatch, null, requestor);
+	}
+	/**
+	 * Notifies the given requestor of all package fragments with the
+	 * given name. Checks the requestor at regular intervals to see if the
+	 * requestor has canceled. The domain of
+	 * the search is bounded by the <code>IJavaProject</code>
+	 * this <code>NameLookup</code> was obtained from.
+	 *
+	 * @param partialMatch partial name matches qualify when <code>true</code>;
+	 *	only exact name matches qualify when <code>false</code>
+	 */
+	public void seekPackageFragments(String name, boolean partialMatch, char[] moduleName, IJavaElementRequestor requestor) {
 /*		if (VERBOSE) {
 			Util.verbose(" SEEKING PACKAGE FRAGMENTS");  //$NON-NLS-1$
 			Util.verbose(" -> name: " + name);  //$NON-NLS-1$
 			Util.verbose(" -> partial match:" + partialMatch);  //$NON-NLS-1$
 		}
-*/		if (partialMatch) {
+*/
+		boolean isUnnamedModule = (moduleName == null || CharOperation.equals(moduleName, ModuleEnvironment.UNNAMED));
+		if (partialMatch) {
 			String[] splittedName = Util.splitOn('.', name, 0, name.length());
 			Object[][] keys = this.packageFragments.keyTable;
 			for (int i = 0, length = keys.length; i < length; i++) {
@@ -941,14 +1022,18 @@ public class NameLookup implements SuffixConstants {
 					Object value = this.packageFragments.valueTable[i];
 					if (value instanceof PackageFragmentRoot) {
 						PackageFragmentRoot root = (PackageFragmentRoot) value;
-						requestor.acceptPackageFragment(root.getPackageFragment(pkgName));
+						IModule module = null;
+						if (isUnnamedModule || ((module = getModule(root)) != null && CharOperation.equals(moduleName, module.name())))
+							requestor.acceptPackageFragment(root.getPackageFragment(pkgName));
 					} else {
 						IPackageFragmentRoot[] roots = (IPackageFragmentRoot[]) value;
 						for (int j = 0, length2 = roots.length; j < length2; j++) {
 							if (requestor.isCanceled())
 								return;
 							PackageFragmentRoot root = (PackageFragmentRoot) roots[j];
-							requestor.acceptPackageFragment(root.getPackageFragment(pkgName));
+							IModule module = null;
+							if (isUnnamedModule || ((module = getModule(root)) != null && CharOperation.equals(moduleName, module.name())))
+								requestor.acceptPackageFragment(root.getPackageFragment(pkgName));
 						}
 					}
 				}
@@ -961,7 +1046,10 @@ public class NameLookup implements SuffixConstants {
 				// reuse existing String[]
 				String[] pkgName = (String[]) this.packageFragments.keyTable[pkgIndex];
 				if (value instanceof PackageFragmentRoot) {
-					requestor.acceptPackageFragment(((PackageFragmentRoot) value).getPackageFragment(pkgName));
+					PackageFragmentRoot root = (PackageFragmentRoot) value;
+					IModule module = null;
+					if (isUnnamedModule || ((module = getModule(root)) != null && CharOperation.equals(moduleName, module.name())))
+						requestor.acceptPackageFragment(root.getPackageFragment(pkgName));
 				} else {
 					IPackageFragmentRoot[] roots = (IPackageFragmentRoot[]) value;
 					if (roots != null) {
@@ -969,7 +1057,9 @@ public class NameLookup implements SuffixConstants {
 							if (requestor.isCanceled())
 								return;
 							PackageFragmentRoot root = (PackageFragmentRoot) roots[i];
-							requestor.acceptPackageFragment(root.getPackageFragment(pkgName));
+							IModule module = null;
+							if (isUnnamedModule || ((module = getModule(root)) != null && CharOperation.equals(moduleName, module.name())))
+								requestor.acceptPackageFragment(root.getPackageFragment(pkgName));
 						}
 					}
 				}
@@ -1045,31 +1135,24 @@ public class NameLookup implements SuffixConstants {
 		if (javaProject != null) {
 			seekTargettedModuleReferences(name, requestor, javaProject);			
 		} else {
-			seekModule(name, true /* prefix */, requestor);
+			seekModule(name.toCharArray(), true /* prefix */, requestor);
 		}
 	}
-	public void seekModule(String name, boolean prefix, IJavaElementRequestor requestor) {
+	public void seekModule(char[] name, boolean prefix, IJavaElementRequestor requestor) {
 		int count= this.packageFragmentRoots.length;
-		char[] nameArray = name.toCharArray();
 		for (int i= 0; i < count; i++) {
 			if (requestor.isCanceled())
 				return;
 			//Answer answer = findType(String.valueOf(TypeConstants.MODULE_INFO_NAME), false, 0, false);
 			IPackageFragmentRoot root= this.packageFragmentRoots[i];
 			IModule module = null;
-			if (root instanceof JarPackageFragmentRoot) {
-				if (!isMatching(nameArray, root.getElementName().toCharArray(), prefix)) {
-					continue;
-				}
-			} else {
-				try {
-					module = ((PackageFragmentRootInfo) ((PackageFragmentRoot) root).getElementInfo()).getModule();
-				} catch (JavaModelException e1) {
-					//
+			if (root instanceof JrtPackageFragmentRoot) {
+				if (!isMatching(name, root.getElementName().toCharArray(), prefix)) {
 					continue;
 				}
 			}
-			if (module != null && isMatching(nameArray, module.name(), prefix))
+			module = getModule((PackageFragmentRoot) root);
+			if (module != null && isMatching(name, module.name(), prefix))
 				requestor.acceptModule(module);
 			else if (module == null) {
 				try {
@@ -1078,8 +1161,8 @@ public class NameLookup implements SuffixConstants {
 						if (requestor.isCanceled())
 							return;
 						// only look in the default package
-						if (compilationUnits[j].getElementName().length() > 0)
-							continue;
+						if (compilationUnits[j].getElementName().length() == 0) {
+							
 						IType type = findType(String.valueOf(TypeConstants.MODULE_INFO_NAME), (PackageFragment)compilationUnits[j], false, 0, false, false);
 						if (type == null)
 							continue;
@@ -1088,8 +1171,15 @@ public class NameLookup implements SuffixConstants {
 						} else {
 							module = (IModule)(((SourceType)type).getElementInfo());
 						}
-						if (module != null && isMatching(nameArray, module.name(), prefix))
-							requestor.acceptModule(module);
+						if (module != null) {
+							((PackageFragmentRootInfo) ((PackageFragmentRoot) root).getElementInfo()).setModule(module);
+							 if (isMatching(name, module.name(), prefix))
+								 requestor.acceptModule(module);
+						} else {
+							((PackageFragmentRootInfo) ((PackageFragmentRoot) root).getElementInfo()).setModule(ModuleEnvironment.UNNAMED_MODULE);
+						}
+						break;
+						}
 					}
 				} catch (JavaModelException e) {
 					//
@@ -1097,7 +1187,7 @@ public class NameLookup implements SuffixConstants {
 			}
 		}
 	}
-	public void seekModules(String name, JavaElementRequestor requestor) {
+	public void seekModules(char[] name, JavaElementRequestor requestor) {
 		seekModule(name, false, requestor);
 	}
 	/**
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index facfda0..67e951d 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -22,7 +22,7 @@ import org.eclipse.core.resources.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
-
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.core.util.MementoTokenizer;
 import org.eclipse.jdt.internal.core.util.Messages;
 import org.eclipse.jdt.internal.core.util.Util;
@@ -844,10 +844,60 @@ protected void verifyAttachSource(IPath sourcePath) throws JavaModelException {
 
 @Override
 public boolean isModule() {
+	// Only kind source handled here. Roots of Other kinds should answer appropriately, without actually opening the
+	// root whenever possible
 	try {
-		return ((PackageFragmentRootInfo) getElementInfo()).isModule(resource(), this);
+		if (getKind() == IPackageFragmentRoot.K_SOURCE) {
+			IPackageFragment fragment = getPackageFragment(""); //$NON-NLS-1$
+			ICompilationUnit[] units = fragment.getCompilationUnits();
+			for (ICompilationUnit unit : units) {
+				if (unit.getElementName().toLowerCase().indexOf(new String(TypeConstants.MODULE_INFO_NAME)) != -1) {
+					return true;
+				}
+			}
+		}
+	} catch(JavaModelException jme) {
+		//
+	}
+	return false;
+}
+
+
+public org.eclipse.jdt.internal.compiler.env.IModule getModule() {
+	if (!this.isModule()) {
+		return null;
+	}
+	try {
+		PackageFragmentRootInfo rootInfo = (PackageFragmentRootInfo) getElementInfo();
+		org.eclipse.jdt.internal.compiler.env.IModule module = rootInfo.getModule();
+		if (module != null)
+			return module;
+		IJavaElement[] pkgs = getChildren();
+		for (int j = 0, length = pkgs.length; j < length; j++) {
+			// only look in the default package
+			if (pkgs[j].getElementName().length() == 0) {
+				OpenableElementInfo info = null;
+				if (getKind() == IPackageFragmentRoot.K_SOURCE) {
+					ICompilationUnit unit = ((PackageFragment) pkgs[j])
+							.getCompilationUnit(TypeConstants.MODULE_INFO_FILE_NAME_STRING);
+					if (unit instanceof CompilationUnit && unit.exists()) {
+						info = (CompilationUnitElementInfo) ((CompilationUnit) unit)
+								.getElementInfo();
+					}
+				} else {
+					IClassFile classFile = ((IPackageFragment)pkgs[j]).getClassFile(TypeConstants.MODULE_INFO_CLASS_NAME_STRING);
+					if (classFile instanceof ClassFile && classFile.exists()) {
+						info = (ClassFileInfo) ((ClassFile) classFile).getElementInfo();
+					}
+				}
+				if (info != null)
+					return info.getModule();
+				break;
+			}
+		}
 	} catch (JavaModelException e) {
-		return false;
+		//
 	}
+	return null;
 }
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
index 55e42a1..9cd795b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SearchableEnvironment.java
@@ -112,12 +112,13 @@ public class SearchableEnvironment extends ModuleEnvironment
 				packageName,
 				false/*exact match*/,
 				NameLookup.ACCEPT_ALL,
-				this.checkAccessRestrictions);
+				this.checkAccessRestrictions,
+				module);
 		if (answer != null) {
 			// construct name env answer
 			if (answer.type instanceof BinaryType) { // BinaryType
 				try {
-					return new NameEnvironmentAnswer((IBinaryType) ((BinaryType) answer.type).getElementInfo(), answer.restriction);
+					return new NameEnvironmentAnswer((IBinaryType) ((BinaryType) answer.type).getElementInfo(), answer.restriction, answer.module.name());
 				} catch (JavaModelException npe) {
 					// fall back to using owner
 				}
@@ -142,7 +143,7 @@ public class SearchableEnvironment extends ModuleEnvironment
 						if (!otherType.equals(topLevelType) && index < length) // check that the index is in bounds (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=62861)
 							sourceTypes[index++] = otherType;
 					}
-					return new NameEnvironmentAnswer(sourceTypes, answer.restriction, getExternalAnnotationPath(answer.entry));
+					return new NameEnvironmentAnswer(sourceTypes, answer.restriction, getExternalAnnotationPath(answer.entry), answer.module.name());
 				} catch (JavaModelException jme) {
 					if (jme.isDoesNotExist() && String.valueOf(TypeConstants.PACKAGE_INFO_NAME).equals(typeName)) {
 						// in case of package-info.java the type doesn't exist in the model,
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
index e85fef3..df40727 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
@@ -193,8 +193,8 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 			}
 		}
 		if (this.accessRuleSet == null)
-			return new NameEnvironmentAnswer(reader, null);
-		return new NameEnvironmentAnswer(reader, this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()));
+			return this.module == null ? new NameEnvironmentAnswer(reader, null) : new NameEnvironmentAnswer(reader, null, reader.moduleName);
+		return new NameEnvironmentAnswer(reader, this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()), reader.moduleName);
 	}
 	return null;
 }
@@ -236,11 +236,9 @@ public String debugPathString() {
 
 @Override
 public boolean servesModule(IModule mod) {
-	if (mod == null) 
-		return false;
-	if (this.module == null || mod == this || mod == ModuleEnvironment.UNNAMED_MODULE)
-		return true;
-	return this.module.equals(mod);
+	if (mod == null)
+		return this.module == null || this.module == ModuleEnvironment.UNNAMED_MODULE;
+	return this.module == null ? mod == ModuleEnvironment.UNNAMED_MODULE : this.module.equals(mod);
 }
 
 @Override
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
index cea35c7..6f43210 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
@@ -199,7 +199,7 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 					// don't let error on annotations fail class reading
 				}
 			}
-			return new NameEnvironmentAnswer(reader, null);
+			return new NameEnvironmentAnswer(reader, null, mod.name());
 		}
 	} catch (IOException e) { // treat as if class file is missing
 	} catch (ClassFormatException e) { // treat as if class file is missing
commit f8880b63de20e0a6e3add3507cd9c08aea5dd1c2
Author: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
Date:   Wed Jul 20 14:07:29 2016 +0530

    Bug 479610 - Resolution of target modules of targeted exports statements
    using workspace root as module source path, thus avoiding circular
    dependency issue
    
    Change-Id: Ice66997ee02ac7f9b598f91f7d970b879e7801b5

150	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
8	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
13	1	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
19	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
110	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleSourcePathManager.java
10	34	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
5	3	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
3	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index b406815..fe167dd 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -941,6 +941,156 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			deleteProject("com.greetings");
 		}
 	}
+
+	// Types from source module should be resolved in target module
+	// when package is exported specifically to the target module
+	public void test_TargetedExports() throws CoreException {
+		if (!isJRE9) return;
+		try {
+			String[] sources = new String[] {
+				"src/module-info.java",
+				"module org.astro {\n" +
+				"	exports org.astro to com.greetings;\n" + 
+				"}",
+				"src/org/astro/World.java",
+				"package org.astro;\n" +
+				"public interface World {\n" +
+				"	public String name();\n" +
+				"}"
+			};
+			IJavaProject p1 = setupModuleProject("org.astro", sources);
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			String[] src = new String[] {
+				"src/module-info.java",
+				"module com.greetings {\n" +
+				"	requires org.astro;\n" +
+				"	exports com.greetings;\n" +
+				"}",
+				"src/com/greetings/MyWorld.java",
+				"package com.greetings;\n" +
+				"import org.astro.World;\n" +
+				"public class MyWorld implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" My World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep });
+			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers",	"",  markers);
+		} finally {
+			deleteProject("org.astro");
+			deleteProject("com.greetings");
+		}
+	}
+	// Types in one module should not be visible in target module when
+	// source module exports packages to a specific module which is not
+	// the same as the target module
+	public void test_TargetedExports_Error() throws CoreException {
+		if (!isJRE9) return;
+		try {
+			String[] sources = new String[] {
+				"src/module-info.java",
+				"module some.mod { }",
+			};
+			setupModuleProject("some.mod", sources);
+			sources = new String[] {
+				"src/module-info.java",
+				"module org.astro {\n" +
+				"	exports org.astro to some.mod;\n" + 
+				"}",
+				"src/org/astro/World.java",
+				"package org.astro;\n" +
+				"public interface World {\n" +
+				"	public String name();\n" +
+				"}"
+			};
+			IJavaProject p1 = setupModuleProject("org.astro", sources);
+			IClasspathEntry dep = JavaCore.newProjectEntry(p1.getPath());
+			String[] src = new String[] {
+				"src/module-info.java",
+				"module com.greetings {\n" +
+				"	requires org.astro;\n" +
+				"	exports com.greetings;\n" +
+				"}",
+				"src/com/greetings/MyWorld.java",
+				"package com.greetings;\n" +
+				"import org.astro.World;\n" +
+				"public class MyWorld implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" My World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep });
+			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers",	
+					"The import org.astro.World cannot be resolved\n" +
+					"World cannot be resolved to a type",
+					markers);
+		} finally {
+			deleteProject("some.mod");
+			deleteProject("org.astro");
+			deleteProject("com.greetings");
+		}
+	}
+	// Report an error when the target module of a targeted exports statement
+	// cannot be resolved
+	public void test_TargetedExports_Unresolved() throws CoreException {
+		if (!isJRE9) return;
+		try {
+			String[] sources = new String[] {
+				"src/module-info.java",
+				"module org.astro {\n" +
+				"	exports org.astro to some.mod;\n" + 
+				"}",
+				"src/org/astro/World.java",
+				"package org.astro;\n" +
+				"public interface World {\n" +
+				"	public String name();\n" +
+				"}"
+			};
+			IJavaProject p1 = setupModuleProject("org.astro", sources);
+			p1.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p1.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers",	"some.mod cannot be resolved to a module",  markers);
+		} finally {
+			deleteProject("org.astro");
+		}
+	}
+	// Target module of an exports statement should be resolved without having an explicit
+	// dependency to the project that defines the module
+	public void test_TargetedExports_Resolution() throws CoreException {
+		if (!isJRE9) return;
+		try {
+			String[] sources = new String[] {
+				"src/module-info.java",
+				"module some.mod {\n" +
+				"}"
+			};
+			setupModuleProject("some.mod", sources);
+			sources = new String[] {
+				"src/module-info.java",
+				"module org.astro {\n" +
+				"	exports org.astro to some.mod;\n" + 
+				"}",
+				"src/org/astro/World.java",
+				"package org.astro;\n" +
+				"public interface World {\n" +
+				"	public String name();\n" +
+				"}"
+			};
+			IJavaProject p1 = setupModuleProject("org.astro", sources);
+			p1.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p1.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "",  markers);
+		} finally {
+			deleteProject("org.astro");
+			deleteProject("some.mod");
+		}
+	}
 	private IJavaProject setupModuleProject(String name, String[] sources) throws CoreException {
 		return setupModuleProject(name, sources, null);
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
index 494e270..6d82a35 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JarPackageFragmentRoot.java
@@ -28,6 +28,7 @@ import org.eclipse.core.runtime.IStatus;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.core.util.HashtableOfArrayToObject;
 import org.eclipse.jdt.internal.core.util.Util;
 
@@ -44,6 +45,13 @@ import org.eclipse.jdt.internal.core.util.Util;
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class JarPackageFragmentRoot extends PackageFragmentRoot {
 
+	@Override
+	public boolean isModule() {
+		//
+		ClassFile clsFile = new ClassFile((PackageFragment)getPackageFragment(""), String.valueOf(TypeConstants.MODULE_INFO_NAME)); //$NON-NLS-1$
+		return clsFile.existsUsingJarTypeCache();
+	}
+
 	protected final static ArrayList EMPTY_LIST = new ArrayList();
 
 	/**
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
index b2041a1..3c318f4 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java
@@ -1533,7 +1533,8 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 	private ThreadLocal zipFiles = new ThreadLocal();
 
 	private UserLibraryManager userLibraryManager;
-	
+
+	private ModuleSourcePathManager modulePathManager;
 	/*
 	 * A set of IPaths for jars that are known to not contain a chaining (through MANIFEST.MF) to another library
 	 */
@@ -2668,6 +2669,17 @@ public class JavaModelManager implements ISaveParticipant, IContentTypeChangeLis
 		return MANAGER.userLibraryManager;
 	}
 
+	public static ModuleSourcePathManager getModulePathManager() {
+		if (MANAGER.modulePathManager == null) {
+			ModuleSourcePathManager modulePathManager = new ModuleSourcePathManager();
+			synchronized(MANAGER) {
+				if (MANAGER.modulePathManager == null) { // ensure another library manager was not set while creating the instance above
+					MANAGER.modulePathManager = modulePathManager;
+				}
+			}
+		}
+		return MANAGER.modulePathManager;
+	}
 	/*
 	 * Returns all the working copies which have the given owner.
 	 * Adds the working copies of the primary owner if specified.
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
index 7460fd4..efeeeef 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
@@ -75,6 +75,7 @@ import org.eclipse.jdt.core.WorkingCopyOwner;
 import org.eclipse.jdt.core.compiler.CategorizedProblem;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.eval.IEvaluationContext;
+import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.util.JRTUtil;
 import org.eclipse.jdt.internal.compiler.util.ObjectVector;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
@@ -3330,4 +3331,22 @@ public class JavaProject
 		}
 		return JavaModelStatus.VERIFIED_OK;
 	}
+
+	public IModule getModule() throws JavaModelException {
+		IModule module = null;
+		JavaProjectElementInfo info = (JavaProjectElementInfo) getElementInfo();
+		module = info.getModule();
+		if (module != null)
+			return module;
+		List<IPackageFragmentRoot> children = getChildrenOfType(IJavaElement.PACKAGE_FRAGMENT_ROOT);
+		for (IPackageFragmentRoot root : children) {
+			module = ((PackageFragmentRoot)root).getModule();
+			if (module != null) {
+				info.setModule(module);
+				break;
+			}
+		}
+		
+		return module;
+	}
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleSourcePathManager.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleSourcePathManager.java
new file mode 100644
index 0000000..8562baf
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModuleSourcePathManager.java
@@ -0,0 +1,110 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+
+public class ModuleSourcePathManager {
+
+	private Map<String, JavaProject> knownModules = new HashMap<String, JavaProject>(11);
+
+	private JavaProject getModuleRoot0(String name) {
+		return this.knownModules.get(name);
+	}
+	public JavaProject getModuleRoot(String name) {
+		JavaProject root = getModuleRoot0(name);
+		if (root == null) {
+			try {
+				seekModule(name.toCharArray(),false, new JavaElementRequestor());
+			} catch (JavaModelException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+		}
+		root = this.knownModules.get(name);
+		return root;
+	}
+
+	public void seekModule(char[] name, boolean partialMatch, IJavaElementRequestor requestor) throws JavaModelException {
+		if (name == null)
+			return;
+		if (!partialMatch) {
+			IJavaProject[] projects = JavaModelManager.getJavaModelManager().getJavaModel().getJavaProjects();
+			for (int i = 0; i < projects.length; i++) {
+				IJavaProject project = projects[i];
+				if (!project.getProject().isAccessible())
+					continue;
+				if (project instanceof JavaProject) {
+					IModule module = ((JavaProject) project).getModule();
+					if (module != null) {
+						char[] moduleName = module.name();
+						if (CharOperation.equals(name, moduleName)) {
+							this.knownModules.put(CharOperation.charToString(name), (JavaProject) project);
+							requestor.acceptModule(module);
+							break;
+						}
+					}
+				}
+			}
+		} else {
+			for (String key : this.knownModules.keySet()) {
+				if (CharOperation.prefixEquals(name, key.toCharArray())) {
+					requestor.acceptModule(this.knownModules.get(key).getModule());
+				}
+			}
+		}
+	}
+	public IModule getModule(char[] name) {
+		JavaProject root = getModuleRoot0(CharOperation.charToString(name));
+		if (root != null)
+			try {
+				return root.getModule();
+			} catch (JavaModelException e1) {
+				//
+				return null;
+			}
+		JavaElementRequestor requestor = new JavaElementRequestor();
+		try {
+			seekModule(name, false, requestor);
+		} catch (JavaModelException e) {
+			// TODO Auto-generated catch block
+		}
+		IModule[] modules = requestor.getModules();
+		return modules.length > 0 ? modules[0] : null; 
+	}
+	public IModule[] getModules() {
+		if (this.knownModules.size() == 0) {
+			return new IModule[0];
+		}
+		List<IModule> modules = new ArrayList<IModule>();
+		for (JavaProject val : this.knownModules.values()) {
+			try {
+				modules.add(val.getModule());
+			} catch (JavaModelException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+		}
+		return modules.toArray(new IModule[modules.size()]);
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
index b750137..5e103e3 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java
@@ -29,7 +29,6 @@ import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
-import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
@@ -928,8 +927,17 @@ public class NameLookup implements SuffixConstants {
 	}
 	public Answer findModule(String moduleName) {
 		JavaElementRequestor requestor = new JavaElementRequestor();
-		seekModules(moduleName.toCharArray(), requestor);
+		char[] nameArray = moduleName.toCharArray();
+		seekModules(nameArray, requestor);
 		org.eclipse.jdt.internal.compiler.env.IModule[] modules = requestor.getModules();
+		if (modules.length == 0) {
+			try {
+				JavaModelManager.getModulePathManager().seekModule(nameArray, false, requestor);
+				modules = requestor.getModules();
+			} catch (JavaModelException e) {
+				// TODO Auto-generated catch block
+			}
+		}
 		if (modules.length == 1) { // TODO what to do??
 			return new Answer(modules[0]);
 		}
@@ -1149,7 +1157,6 @@ public class NameLookup implements SuffixConstants {
 		for (int i= 0; i < count; i++) {
 			if (requestor.isCanceled())
 				return;
-			//Answer answer = findType(String.valueOf(TypeConstants.MODULE_INFO_NAME), false, 0, false);
 			IPackageFragmentRoot root= this.packageFragmentRoots[i];
 			IModule module = null;
 			if (root instanceof JrtPackageFragmentRoot) {
@@ -1160,37 +1167,6 @@ public class NameLookup implements SuffixConstants {
 			module = getModule((PackageFragmentRoot) root);
 			if (module != null && isMatching(name, module.name(), prefix))
 				requestor.acceptModule(module);
-			else if (module == null) {
-				try {
-					IJavaElement[] compilationUnits = root.getChildren();
-					for (int j = 0, length = compilationUnits.length; j < length; j++) {
-						if (requestor.isCanceled())
-							return;
-						// only look in the default package
-						if (compilationUnits[j].getElementName().length() == 0) {
-							
-						IType type = findType(String.valueOf(TypeConstants.MODULE_INFO_NAME), (PackageFragment)compilationUnits[j], false, 0, false, false);
-						if (type == null)
-							continue;
-						if (type.isBinary()) {
-								module = ((ClassFileReader)(((BinaryType)type).getElementInfo())).getModuleDeclaration();
-						} else {
-							module = (IModule)(((SourceType)type).getElementInfo());
-						}
-						if (module != null) {
-							((PackageFragmentRootInfo) ((PackageFragmentRoot) root).getElementInfo()).setModule(module);
-							 if (isMatching(name, module.name(), prefix))
-								 requestor.acceptModule(module);
-						} else {
-							((PackageFragmentRootInfo) ((PackageFragmentRoot) root).getElementInfo()).setModule(ModuleEnvironment.UNNAMED_MODULE);
-						}
-						break;
-						}
-					}
-				} catch (JavaModelException e) {
-					//
-				}
-			}
 		}
 	}
 	public void seekModules(char[] name, JavaElementRequestor requestor) {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
index 67e951d..f1f8da6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/PackageFragmentRoot.java
@@ -22,6 +22,7 @@ import org.eclipse.core.resources.*;
 import org.eclipse.core.runtime.*;
 import org.eclipse.jdt.core.*;
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.core.util.MementoTokenizer;
 import org.eclipse.jdt.internal.core.util.Messages;
@@ -883,15 +884,16 @@ public org.eclipse.jdt.internal.compiler.env.IModule getModule() {
 					if (unit instanceof CompilationUnit && unit.exists()) {
 						info = (CompilationUnitElementInfo) ((CompilationUnit) unit)
 								.getElementInfo();
+						if (info != null)
+							return info.getModule();
 					}
 				} else {
 					IClassFile classFile = ((IPackageFragment)pkgs[j]).getClassFile(TypeConstants.MODULE_INFO_CLASS_NAME_STRING);
 					if (classFile instanceof ClassFile && classFile.exists()) {
-						info = (ClassFileInfo) ((ClassFile) classFile).getElementInfo();
+						IType type = classFile.getType();
+						return ((ClassFileReader)(((BinaryType)type).getElementInfo())).getModuleDeclaration();
 					}
 				}
-				if (info != null)
-					return info.getModule();
 				break;
 			}
 		}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
index f246ba4..27e8399 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/NameEnvironment.java
@@ -422,6 +422,9 @@ public IModule getModule(char[] name) {
 				break;
 		}
 	}
+	if (module == null) {
+		module = JavaModelManager.getModulePathManager().getModule(name);
+	}
 	return module;
 }
 
commit 9b4c6fe06310162fcf691a59705683aa5c5ce814
Author: Sasikanth Bharadwaj <sasikanth.bharadwaj@in.ibm.com>
Date:   Wed Jul 20 14:07:58 2016 +0530

    Bug 479610 Module path container implementation to handle implicit
    module dependencies via the 'requires public' statement
    
    Change-Id: Idd7943949c09531a8e31c1794d86ef7a11eac58c

265	7	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
5	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
2	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
79	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
55	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainerInitializer.java
11	0	org.eclipse.jdt.core/plugin.xml
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index fe167dd..d5cfb49 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -1091,18 +1091,269 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			deleteProject("some.mod");
 		}
 	}
+	// Make sure modules in the workspace are resolved via the module source path container
+	// without needing to add a dependency to the project explicitly
+	public void test_ModuleSourcePathContainer() throws CoreException {
+		if (!isJRE9) return;
+		try {
+			String[] sources = new String[] {
+				"src/module-info.java",
+				"module org.astro {\n" +
+				"	exports org.astro;\n" + 
+				"}",
+				"src/org/astro/World.java",
+				"package org.astro;\n" +
+				"public interface World {\n" +
+				"	public String name();\n" +
+				"}"
+			};
+			setupModuleProject("org.astro", sources);
+			String[] src = new String[] {
+				"src/module-info.java",
+				"module com.greetings {\n" +
+				"	requires org.astro;\n" +
+				"	exports com.greetings;\n" +
+				"}",
+				"src/com/greetings/MyWorld.java",
+				"package com.greetings;\n" +
+				"import org.astro.World;\n" +
+				"public class MyWorld implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" My World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathEntry dep = JavaCore.newContainerEntry(new Path(JavaCore.MODULE_PATH_CONTAINER_ID));
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep });
+			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "",  markers);
+		} finally {
+			deleteProject("org.astro");
+			deleteProject("com.greetings");
+		}
+	}
+	// Make sure module path container picks up changes to module-info
+	public void test_ModuleSourcePath_update() throws CoreException {
+		if (!isJRE9) return;
+		try {
+			String[] sources = new String[] {
+				"src/module-info.java",
+				"module some.mod {\n" +
+				"}"
+			};
+			setupModuleProject("some.mod", sources);
+			sources = new String[] {
+				"src/module-info.java",
+				"module org.astro {\n" +
+				"	exports org.astro;\n" + 
+				"}",
+				"src/org/astro/World.java",
+				"package org.astro;\n" +
+				"public interface World {\n" +
+				"	public String name();\n" +
+				"}"
+			};
+			setupModuleProject("org.astro", sources);
+			String[] src = new String[] {
+				"src/module-info.java",
+				"module com.greetings {\n" +
+				"	requires org.astro;\n" +
+				"	exports com.greetings;\n" +
+				"}",
+				"src/com/greetings/MyWorld.java",
+				"package com.greetings;\n" +
+				"import org.astro.World;\n" +
+				"public class MyWorld implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" My World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			IClasspathEntry dep = JavaCore.newContainerEntry(new Path(JavaCore.MODULE_PATH_CONTAINER_ID));
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep });
+			this.editFile("com.greetings/src/module-info.java",
+				"module com.greetings {\n" +
+				"	requires org.astro;\n" +
+				"	requires some.mod;\n" +
+				"	exports com.greetings;\n" +
+				"}");
+			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "",  markers);
+		} finally {
+			deleteProject("org.astro");
+			deleteProject("some.mod");
+			deleteProject("com.greetings");
+		}
+	}
+	// Implicit module dependencies via the 'requires public' directive should be
+	// resolved via the module path container
+	public void test_ModuleSourcePath_implicitdeps() throws CoreException {
+		if (!isJRE9) return;
+		try {
+			String[] sources = new String[] {
+				"src/module-info.java",
+				"module some.mod {\n" +
+				"	requires public org.astro;\n" +
+				"}"
+			};
+			IClasspathEntry dep = JavaCore.newContainerEntry(new Path(JavaCore.MODULE_PATH_CONTAINER_ID));
+			setupModuleProject("some.mod", sources, new IClasspathEntry[]{dep});
+			sources = new String[] {
+				"src/module-info.java",
+				"module org.astro {\n" +
+				"	exports org.astro;\n" + 
+				"}",
+				"src/org/astro/World.java",
+				"package org.astro;\n" +
+				"public interface World {\n" +
+				"	public String name();\n" +
+				"}"
+			};
+			setupModuleProject("org.astro", sources, new IClasspathEntry[]{dep});
+			String[] src = new String[] {
+				"src/module-info.java",
+				"module com.greetings {\n" +
+				"	requires some.mod;\n" +
+				"	exports com.greetings;\n" +
+				"}",
+				"src/com/greetings/MyWorld.java",
+				"package com.greetings;\n" +
+				"import org.astro.World;\n" +
+				"public class MyWorld implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" My World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep });
+			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "",  markers);
+		} finally {
+			deleteProject("org.astro");
+			deleteProject("some.mod");
+			deleteProject("com.greetings");
+		}
+	}
+	// Changes to implicit dependencies should be reflected
+	public void test_ModuleSourcePath_implicitdeps2() throws CoreException {
+		if (!isJRE9) return;
+		try {
+			String[] sources = new String[] {
+				"src/module-info.java",
+				"module some.mod {\n" +
+				"	requires public org.astro;\n" +
+				"}"
+			};
+			IClasspathEntry dep = JavaCore.newContainerEntry(new Path(JavaCore.MODULE_PATH_CONTAINER_ID));
+			setupModuleProject("some.mod", sources, new IClasspathEntry[]{dep});
+			sources = new String[] {
+				"src/module-info.java",
+				"module org.astro {\n" +
+				"	exports org.astro;\n" + 
+				"}",
+				"src/org/astro/World.java",
+				"package org.astro;\n" +
+				"public interface World {\n" +
+				"	public String name();\n" +
+				"}"
+			};
+			setupModuleProject("org.astro", sources, new IClasspathEntry[]{dep});
+			String[] src = new String[] {
+				"src/module-info.java",
+				"module com.greetings {\n" +
+				"	requires some.mod;\n" +
+				"	exports com.greetings;\n" +
+				"}",
+				"src/com/greetings/MyWorld.java",
+				"package com.greetings;\n" +
+				"import org.astro.World;\n" +
+				"public class MyWorld implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" My World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep });
+			this.editFile("some.mod/src/module-info.java",
+				"module some.mod {\n" +
+				"	requires org.astro;\n" +
+				"}");
+			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", 
+					"The import org cannot be resolved\n" +
+					"World cannot be resolved to a type",  markers);
+		} finally {
+			deleteProject("org.astro");
+			deleteProject("some.mod");
+			deleteProject("com.greetings");
+		}
+	}
+	// Changes to implicit dependencies should be reflected
+	//TODO enable once we know how to update project cache
+	public void _test_ModuleSourcePath_implicitdeps3() throws CoreException {
+		if (!isJRE9) return;
+		try {
+			String[] sources = new String[] {
+				"src/module-info.java",
+				"module some.mod {\n" +
+				"	requires org.astro;\n" +
+				"}"
+			};
+			IClasspathEntry dep = JavaCore.newContainerEntry(new Path(JavaCore.MODULE_PATH_CONTAINER_ID));
+			setupModuleProject("some.mod", sources, new IClasspathEntry[]{dep});
+			sources = new String[] {
+				"src/module-info.java",
+				"module org.astro {\n" +
+				"	exports org.astro;\n" + 
+				"}",
+				"src/org/astro/World.java",
+				"package org.astro;\n" +
+				"public interface World {\n" +
+				"	public String name();\n" +
+				"}"
+			};
+			setupModuleProject("org.astro", sources, new IClasspathEntry[]{dep});
+			String[] src = new String[] {
+				"src/module-info.java",
+				"module com.greetings {\n" +
+				"	requires some.mod;\n" +
+				"	exports com.greetings;\n" +
+				"}",
+				"src/com/greetings/MyWorld.java",
+				"package com.greetings;\n" +
+				"import org.astro.World;\n" +
+				"public class MyWorld implements World {\n" +
+				"	public String name() {\n" +
+				"		return \" My World!!\";\n" +
+				"	}\n" +
+				"}"
+			};
+			
+			IJavaProject p2 = setupModuleProject("com.greetings", src, new IClasspathEntry[] { dep });
+			this.editFile("some.mod/src/module-info.java",
+				"module some.mod {\n" +
+				"	requires public org.astro;\n" +
+				"}");
+			p2.getProject().getWorkspace().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p2.getProject().findMarkers(null, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers", "",  markers);
+		} finally {
+			deleteProject("org.astro");
+			deleteProject("some.mod");
+			deleteProject("com.greetings");
+		}
+	}
 	private IJavaProject setupModuleProject(String name, String[] sources) throws CoreException {
 		return setupModuleProject(name, sources, null);
 	}
 	private IJavaProject setupModuleProject(String name, String[] sources, IClasspathEntry[] deps) throws CoreException {
 		IJavaProject project = createJava9Project(name);
-		if (deps != null) {
-			IClasspathEntry[] old = project.getRawClasspath();
-			IClasspathEntry[] newPath = new IClasspathEntry[old.length + deps.length];
-			System.arraycopy(old, 0, newPath, 0, old.length);
-			System.arraycopy(deps, 0, newPath, old.length, deps.length);
-			project.setRawClasspath(newPath, null);
-		}
 		IProgressMonitor monitor = new NullProgressMonitor();
 		for (int i = 0; i < sources.length; i+= 2) {
 			IPath path = new Path(sources[i]);
@@ -1113,6 +1364,13 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 			IFile file = project.getProject().getFile(new Path(sources[i]));
 			file.create(new ByteArrayInputStream(sources[i+1].getBytes()), true, monitor);
 		}
+		if (deps != null) {
+			IClasspathEntry[] old = project.getRawClasspath();
+			IClasspathEntry[] newPath = new IClasspathEntry[old.length + deps.length];
+			System.arraycopy(old, 0, newPath, 0, old.length);
+			System.arraycopy(deps, 0, newPath, old.length, deps.length);
+			project.setRawClasspath(newPath, null);
+		}
 		return project;
 	}
 	public void tearDownSuite() throws Exception {
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 30d2802..d06ebc6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -226,6 +226,11 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String USER_LIBRARY_CONTAINER_ID= "org.eclipse.jdt.USER_LIBRARY"; //$NON-NLS-1$
 
+	/**
+	 * @since 3.13
+	 */
+	public static final String MODULE_PATH_CONTAINER_ID = "org.eclipse.jdt.MODULE_PATH"; //$NON-NLS-1$
+
 	// Begin configurable option IDs {
 
 	/**
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
index efeeeef..b40d869 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java
@@ -3340,6 +3340,8 @@ public class JavaProject
 			return module;
 		List<IPackageFragmentRoot> children = getChildrenOfType(IJavaElement.PACKAGE_FRAGMENT_ROOT);
 		for (IPackageFragmentRoot root : children) {
+			if (root.getKind() != IPackageFragmentRoot.K_SOURCE)
+				continue;
 			module = ((PackageFragmentRoot)root).getModule();
 			if (module != null) {
 				info.setModule(module);
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
new file mode 100644
index 0000000..f7903f0
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainer.java
@@ -0,0 +1,79 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.IClasspathContainer;
+import org.eclipse.jdt.core.IClasspathEntry;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.env.IModule.IModuleReference;
+
+public class ModulePathContainer implements IClasspathContainer{
+
+	private IJavaProject project;
+
+	public ModulePathContainer(IJavaProject project) {
+		this.project = project;
+	}
+	@Override
+	public IClasspathEntry[] getClasspathEntries() {
+		//
+		List<IClasspathEntry> entries = new ArrayList<>();
+		ModuleSourcePathManager manager = JavaModelManager.getModulePathManager();
+		try {
+			IModule module = ((JavaProject)this.project).getModule();
+			if (module == null)
+				return new IClasspathEntry[0];
+			for (IModuleReference ref : module.requires()) {
+				JavaProject refRoot = manager.getModuleRoot(CharOperation.charToString(ref.name()));
+				if (refRoot == null)
+					continue;
+				IPath path = refRoot.getPath();
+				entries.add(JavaCore.newProjectEntry(path, ref.isPublic()));
+			}
+		} catch (JavaModelException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		return entries.toArray(new IClasspathEntry[entries.size()]);
+	}
+
+	@Override
+	public String getDescription() {
+		// 
+		return "Module source path"; //$NON-NLS-1$
+	}
+
+	@Override
+	public int getKind() {
+		// 
+		return K_APPLICATION;
+	}
+
+	@Override
+	public IPath getPath() {
+		// 
+		return new Path(JavaCore.MODULE_PATH_CONTAINER_ID);
+	}
+
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainerInitializer.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainerInitializer.java
new file mode 100644
index 0000000..1fc8735
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ModulePathContainerInitializer.java
@@ -0,0 +1,55 @@
+/*******************************************************************************
+ * Copyright (c) 2016 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core;
+
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.jdt.core.ClasspathContainerInitializer;
+import org.eclipse.jdt.core.IClasspathContainer;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment;
+import org.eclipse.jdt.internal.core.util.Util;
+
+public class ModulePathContainerInitializer extends ClasspathContainerInitializer {
+
+	@Override
+	public void initialize(IPath containerPath, IJavaProject project) throws CoreException {
+		//
+		if (isModulePathContainer(containerPath)) {
+			if (project instanceof JavaProject) {
+				// TODO: should project compliance level be checked here?
+				IModule module = ((JavaProject) project).getModule();
+				if (module != null && module != ModuleEnvironment.UNNAMED_MODULE) {
+					ModulePathContainer container = new ModulePathContainer(project);
+					JavaCore.setClasspathContainer(containerPath, new IJavaProject[] { project },
+							new IClasspathContainer[] { container }, null);
+				}
+			}
+		} else if (JavaModelManager.CP_RESOLVE_VERBOSE || JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {
+			verbose_not_a_module_project(project, containerPath);
+		}
+	}
+	private boolean isModulePathContainer(IPath path) {
+		return path != null && JavaCore.MODULE_PATH_CONTAINER_ID.equals(path.segment(0));
+	}
+	private void verbose_not_a_module_project(IJavaProject project, IPath containerPath) {
+		Util.verbose(
+			"Module path INIT - FAILED (not a module project)\n" + //$NON-NLS-1$
+			"	project: " + project.getElementName() + '\n' + //$NON-NLS-1$
+			"	container path: " + containerPath); //$NON-NLS-1$
+	}
+}
diff --git a/org.eclipse.jdt.core/plugin.xml b/org.eclipse.jdt.core/plugin.xml
index 76e3e99..a80ed50 100644
--- a/org.eclipse.jdt.core/plugin.xml
+++ b/org.eclipse.jdt.core/plugin.xml
@@ -186,6 +186,17 @@
    </extension>
 
 <!-- =================================================================================== -->
+<!-- Extension: Module Path Container                                                   -->
+<!-- =================================================================================== -->
+<extension
+      point="org.eclipse.jdt.core.classpathContainerInitializer">
+      <classpathContainerInitializer
+            class="org.eclipse.jdt.internal.core.ModulePathContainerInitializer"
+            id="org.eclipse.jdt.MODULE_PATH">
+      </classpathContainerInitializer>
+   </extension>
+
+<!-- =================================================================================== -->
 <!-- Extension: Java File Types                                                          -->
 <!-- =================================================================================== -->
 <extension point="org.eclipse.team.core.fileTypes">
