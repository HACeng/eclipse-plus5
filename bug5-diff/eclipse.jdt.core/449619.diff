commit 2a90eeb9372f2a1a1f5e7c24d7c19363b361caf2
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sun Nov 2 20:43:25 2014 +0530

    Fix for bug 449619 + bug 448799 + bug 401850

90	6	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_7.java
9	9	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
0	6	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
4	4	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java
41	51	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
245	235	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
3	4	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_7.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_7.java
index dbc14e9..ad28799 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_7.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_7.java
@@ -1178,11 +1178,6 @@ public void test0026() {
 			"	X<Object> x4 = new X<>(1).idem();\n" + 
 			"	               ^^^^^^^^^^^^^^^^^\n" + 
 			"Type mismatch: cannot convert from X<Integer> to X<Object>\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 15)\n" + 
-			"	int i = m(new X<>(\"\"));\n" + 
-			"	          ^^^^^^^^^^^\n" + 
-			"The constructor X<String>(String) is ambiguous\n" + 
 			"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=344655
@@ -1400,7 +1395,7 @@ public void test0034() {
 		"5. ERROR in X.java (at line 17)\n" + 
 		"	X<Integer>.Y<String> y4 = new X<>(1).new Y<>(\"\",\"\");\n" + 
 		"	                          ^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
-		"The constructor X<Integer>.Y<String>(String, String) is undefined\n" + 
+		"Cannot infer type arguments for Y<>\n" + 
 		"----------\n" + 
 		"6. ERROR in X.java (at line 19)\n" + 
 		"	X<Integer>.Y<String> y6 = new X<>().new Y<>(1,\"\");\n" + 
@@ -1422,6 +1417,35 @@ public void test0034() {
 		"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=345559
+public void test0034b() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X<T>  {\n" +
+			"    X(T t) {}\n" +
+			"    X() {}\n" +
+			"    void foo(T a) {\n" +
+			"	 System.out.println(a);\n" +
+			"	 }\n" +
+			"	 class Y<K>{\n" +
+			"		Y(T t,K k) {}\n" +
+			"		Y(K k) {}\n" +
+			"	 }\n" +
+			"    public static void main(String[] args) {\n" +
+			"		X<String>.Y<String> y42 = new X<>(\"\").new Y<>(\"\");\n" +
+			"		X<String>.Y<String> y41 = new X<>(\"\").new Y<>(\"\",\"\");\n" +
+			"		X<Integer>.Y<String> y4 = new X<>(1).new Y<>(\"\",\"\");\n" +
+			"	 }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 14)\n" + 
+		"	X<Integer>.Y<String> y4 = new X<>(1).new Y<>(\"\",\"\");\n" + 
+		"	                          ^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Cannot infer type arguments for Y<>\n" + 
+		"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=345559
 public void test0035() {
 	this.runNegativeTest(
 		new String[] {
@@ -2176,6 +2200,35 @@ public void test0052c() {
 		customOptions);
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=340747
+public void test0052d() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportRedundantSpecificationOfTypeArguments, CompilerOptions.ERROR);	
+	customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);	
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X<E> {\n" +
+			"    X(E e) {}\n" +
+			"    X() {}\n" +
+			"    public static void main(String[] args) {\n" +
+			"        X<Number> x = new X<Number>(1);\n" +
+			"	}\n" +
+			"}\n" +
+			"class AX<T>{}\n"
+		},
+		this.complianceLevel < ClassFileConstants.JDK1_8 ?
+		"" : 
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	X<Number> x = new X<Number>(1);\n" + 
+		"	                  ^\n" + 
+		"Redundant specification of type arguments <Number>\n" + 
+		"----------\n",
+		null,
+		false,
+		customOptions);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=340747
 public void test0053() {
 	Map customOptions = getCompilerOptions();
 	customOptions.put(CompilerOptions.OPTION_ReportRedundantSpecificationOfTypeArguments, CompilerOptions.ERROR);	
@@ -2756,6 +2809,37 @@ public void test448028() {
 			"----------\n", 
 			null, false, customOptions);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=449619,  [1.8][compiler] Qualified <> allocation fails to compile.   
+public void test449619() {
+	String source = "public class X {\n" +
+			   "	public class Y<T> {\n" +
+			   "	}\n" +
+			   "	static void foo(Y<String> ys) {\n" +
+			   "	}\n" +
+			   "	public static void main(String[] args) {\n" +
+			   "		foo(new X().new Y<>());\n" +
+			   "	}\n" +
+			   "}\n";
+	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
+		this.runConformTest(
+		   new String[] {
+			   "X.java",
+			   source,
+		   },
+		   "");
+	else 
+		this.runNegativeTest(
+		   new String[] {
+			   "X.java",
+			   source,
+		   },
+		   "----------\n" + 
+			"1. ERROR in X.java (at line 7)\n" + 
+			"	foo(new X().new Y<>());\n" + 
+			"	^^^\n" + 
+			"The method foo(X.Y<String>) in the type X is not applicable for the arguments (X.Y<Object>)\n" + 
+			"----------\n");
+}
 public static Class testClass() {
 	return GenericsRegressionTest_1_7.class;
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
index 86a9f90..8e3dbfa 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
@@ -467,10 +467,15 @@ public void testBug401850a() {
 			"}\n"
 		},
 		"----------\n" + 
-		"1. ERROR in X.java (at line 7)\n" + 
-		"	int i = m(new X<>(\"\"));\n" + 
-		"	          ^^^^^^^^^^^\n" + 
-		"The constructor X<String>(String) is ambiguous\n" + 
+		"1. WARNING in X.java (at line 1)\n" + 
+		"	import java.util.List;\n" + 
+		"	       ^^^^^^^^^^^^^^\n" + 
+		"The import java.util.List is never used\n" + 
+		"----------\n" + 
+		"2. WARNING in X.java (at line 2)\n" + 
+		"	import java.util.ArrayList;\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^\n" + 
+		"The import java.util.ArrayList is never used\n" + 
 		"----------\n");
 }
 public void testBug401850b() {
@@ -1687,11 +1692,6 @@ public void testBug424930c() {
 		"----------\n" + 
 		"1. ERROR in X.java (at line 14)\n" + 
 		"	return new X<>(() -> new ArrayDeque<>(dequeCapacity));\n" + 
-		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-		"The constructor X<S,Deque<S>>(() -> {}) is undefined\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 14)\n" + 
-		"	return new X<>(() -> new ArrayDeque<>(dequeCapacity));\n" + 
 		"	                                      ^^^^^^^^^^^^^\n" + 
 		"Cannot make a static reference to the non-static field dequeCapacity\n" + 
 		"----------\n");
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 730c8d4..8752742 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -6750,15 +6750,9 @@ public void test443467() throws Exception {
 			"}\n" +
 			"}\n",
 		},
-		// Note: we used to emit a duplicate message of 2. Fixed.
 		"----------\n" + 
 		"1. ERROR in BuildIdeMain.java (at line 9)\n" + 
 		"	filter2.map(p -> new Pair<>(updateToFile.get(p), p->ideFiles.get(p)));\n" + 
-		"	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-		"The constructor Pair<Path,Object>(Path, (<no type> p) -> {}) is undefined\n" + 
-		"----------\n" + 
-		"2. ERROR in BuildIdeMain.java (at line 9)\n" + 
-		"	filter2.map(p -> new Pair<>(updateToFile.get(p), p->ideFiles.get(p)));\n" + 
 		"	                                                 ^^^^^^^^^^^^^^^^^^\n" + 
 		"The target type of this expression must be a functional interface\n" + 
 		"----------\n",
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java
index da45d53..99bb9cc 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java
@@ -66,9 +66,9 @@ public TypeBinding resolveType(BlockScope scope) {
 		}
 		this.resolvedType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingType);
 		if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {
-			TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, this.argumentTypes, scope);
+			TypeBinding [] inferredTypes = inferElidedTypes(scope);
 			if (inferredTypes != null) {
-				this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
+				this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());
 			} else {
 				// inference failed. Resolved type will be of the form Test<>
 				this.bits |= ASTNode.IsDiamond;
@@ -81,9 +81,9 @@ public TypeBinding resolveType(BlockScope scope) {
 	} else {
 	 	this.resolvedType = this.type.resolveType(scope, true /* check bounds*/);
 	 	if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {
-			TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, this.argumentTypes, scope);
+			TypeBinding [] inferredTypes = inferElidedTypes(scope);
 			if (inferredTypes != null) {
-				this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
+				this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());
 			} else {
 				// inference failed. Resolved type will be of the form Test<>
 				this.bits |= ASTNode.IsDiamond;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 35cbef8..9fc7930 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -73,11 +73,11 @@ public class AllocationExpression extends Expression implements Invocation {
 	public boolean inferredReturnType;
 
 	public FakedTrackingVariable closeTracker;	// when allocation a Closeable store a pre-liminary tracking variable here
-	private ExpressionContext expressionContext = VANILLA_CONTEXT;
+	public ExpressionContext expressionContext = VANILLA_CONTEXT;
 
 	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
 	private SimpleLookupTable/*<PMB,IC18>*/ inferenceContexts;
-	private boolean argsContainCast;
+	public boolean argsContainCast;
 	public TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
 	public boolean argumentsHaveErrors = false;
 	
@@ -443,44 +443,24 @@ public TypeBinding resolveType(BlockScope scope) {
 			scope.problemReporter().cannotInstantiate(this.type, this.resolvedType);
 			return this.resolvedType;
 		}
-		if (isDiamond) {
-			ReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();
-			ParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());
-			if (this.typeExpected == null && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8 && this.expressionContext.definesTargetType()) {
-				this.binding = inferConstructorOfElidedParameterizedType(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);
-				if (this.binding == null) {
-					scope.problemReporter().cannotInferElidedTypes(this);
-					return this.resolvedType = null;
-				}
-				return new PolyTypeBinding(this);
-			}
-			TypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);
-			if (inferredTypes == null) {
-				scope.problemReporter().cannotInferElidedTypes(this);
-				return this.resolvedType = null;
-			}
-			ReferenceBinding allocationType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
-			this.resolvedType = this.type.resolvedType = allocationType; 
+	} 
+	if (isDiamond) {
+		this.binding = inferConstructorOfElidedParameterizedType(scope);
+		if (this.binding == null || !this.binding.isValidBinding()) {
+			scope.problemReporter().cannotInferElidedTypes(this);
+			return this.resolvedType = null;
 		}
-	} else {
-		if (isDiamond) {
-			ReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();
-			ParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());
-			TypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);
-			if (inferredTypes == null) {
-				scope.problemReporter().cannotInferElidedTypes(this);
-				return this.resolvedType = null;
-			}
-			this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
+		if (this.typeExpected == null && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8 && this.expressionContext.definesTargetType()) {
+			return new PolyTypeBinding(this);
 		}
+		this.resolvedType = this.type.resolvedType = this.binding.declaringClass;
+		resolvePolyExpressionArguments(this, this.binding, this.argumentTypes, scope);
+	} else {
+		this.binding = findConstructorBinding(scope, this, (ReferenceBinding) this.resolvedType, this.argumentTypes);
 	}
-	
-	ReferenceBinding allocationType = (ReferenceBinding) this.resolvedType;
-	this.binding = findConstructorBinding(scope, this, allocationType, this.argumentTypes);
-		
 	if (!this.binding.isValidBinding()) {
 		if (this.binding.declaringClass == null) {
-			this.binding.declaringClass = allocationType;
+			this.binding.declaringClass = (ReferenceBinding) this.resolvedType;
 		}
 		if (this.type != null && !this.type.resolvedType.isValidBinding()) {
 			return null;
@@ -494,21 +474,21 @@ public TypeBinding resolveType(BlockScope scope) {
 	if (isMethodUseDeprecated(this.binding, scope, true)) {
 		scope.problemReporter().deprecatedMethod(this.binding, this);
 	}
-	if (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {
+	if (checkInvocationArguments(scope, null, this.resolvedType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {
 		this.bits |= ASTNode.Unchecked;
 	}
 	if (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {
 		scope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);
 	}
 	if (!isDiamond && this.resolvedType.isParameterizedTypeWithActualArguments()) {
- 		checkTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);
+ 		checkTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, scope);
  	}
 	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
 		new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
 				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
 	}
 	recordExceptionsForEnclosingLambda(scope, this.binding.thrownExceptions);
-	return allocationType;
+	return this.resolvedType;
 }
 
 /**
@@ -539,12 +519,10 @@ public boolean isCompatibleWith(TypeBinding targetType, final Scope scope) {
 		TypeBinding originalExpectedType = this.typeExpected;
 		try {
 			this.typeExpected = targetType;
-			ReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();
-			ParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());
-			TypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);
+			TypeBinding [] inferredTypes = inferElidedTypes(scope);
 			if (inferredTypes == null)
 				return false;
-			allocationType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
+			allocationType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());
 		} finally {
 			this.typeExpected = originalExpectedType;
 		}
@@ -552,10 +530,17 @@ public boolean isCompatibleWith(TypeBinding targetType, final Scope scope) {
 	return allocationType != null && allocationType.isCompatibleWith(targetType, scope);
 }
 
-public MethodBinding inferConstructorOfElidedParameterizedType(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final Scope scope) {
+public MethodBinding inferConstructorOfElidedParameterizedType(final Scope scope) {
+	
+	ReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();
+	ReferenceBinding enclosingType = this.resolvedType.enclosingType();
+	ParameterizedTypeBinding allocationType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), enclosingType);
+	
 	// Given the allocation type and the arguments to the constructor, see if we can infer the constructor of the elided parameterized type.
-	MethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, argumentTyps, this);
+	MethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, this.argumentTypes, this);
 	if (factory instanceof ParameterizedGenericMethodBinding && factory.isValidBinding()) {
+		ParameterizedGenericMethodBinding genericFactory = (ParameterizedGenericMethodBinding) factory;
+		this.inferredReturnType = genericFactory.inferredReturnType;
 		SyntheticFactoryMethodBinding sfmb = (SyntheticFactoryMethodBinding) factory.original();
 		TypeVariableBinding[] constructorTypeVariables = sfmb.getConstructor().typeVariables();
 		TypeBinding [] constructorTypeArguments = constructorTypeVariables != null ? new TypeBinding[constructorTypeVariables.length] : Binding.NO_TYPES;
@@ -565,20 +550,25 @@ public MethodBinding inferConstructorOfElidedParameterizedType(ParameterizedType
 		MethodBinding constructor = sfmb.applyTypeArgumentsOnConstructor(((ParameterizedTypeBinding)factory.returnType).arguments, constructorTypeArguments);
 		if (constructor instanceof ParameterizedGenericMethodBinding && scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {
 			// force an inference context to be established, but avoid tunneling through overload resolution. We know this is the MSMB.
-			return ParameterizedGenericMethodBinding.computeCompatibleMethod18(constructor.shallowOriginal(), argumentTyps, scope, this);
+			return ParameterizedGenericMethodBinding.computeCompatibleMethod18(constructor.shallowOriginal(), this.argumentTypes, scope, this);
 		}
 		return constructor;
 	}
 	return null;
 }
 
-public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final Scope scope) {
+public TypeBinding[] inferElidedTypes(final Scope scope) {
+	
+	ReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();
+	ReferenceBinding enclosingType = this.resolvedType.enclosingType();
+	ParameterizedTypeBinding allocationType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), enclosingType);
+	
 	/* Given the allocation type and the arguments to the constructor, see if we can synthesize a generic static factory
 	   method that would, given the argument types and the invocation site, manufacture a parameterized object of type allocationType.
 	   If we are successful then by design and construction, the parameterization of the return type of the factory method is identical
 	   to the types elided in the <>.
-	 */   
-	MethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, argumentTyps, this);
+	*/
+	MethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, this.argumentTypes, this);
 	if (factory instanceof ParameterizedGenericMethodBinding && factory.isValidBinding()) {
 		ParameterizedGenericMethodBinding genericFactory = (ParameterizedGenericMethodBinding) factory;
 		this.inferredReturnType = genericFactory.inferredReturnType;
@@ -587,12 +577,12 @@ public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, R
 	return null;
 }
 
-public void checkTypeArgumentRedundancy(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final BlockScope scope) {
+public void checkTypeArgumentRedundancy(ParameterizedTypeBinding allocationType, final BlockScope scope) {
 	if ((scope.problemReporter().computeSeverity(IProblem.RedundantSpecificationOfTypeArguments) == ProblemSeverities.Ignore) || scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_7) return;
 	if (allocationType.arguments == null) return;  // raw binding
 	if (this.genericTypeArguments != null) return; // diamond can't occur with explicit type args for constructor
 	if (this.type == null) return;
-	if (argumentTyps == Binding.NO_PARAMETERS && this.typeExpected instanceof ParameterizedTypeBinding) {
+	if (this.argumentTypes == Binding.NO_PARAMETERS && this.typeExpected instanceof ParameterizedTypeBinding) {
 		ParameterizedTypeBinding expected = (ParameterizedTypeBinding) this.typeExpected;
 		if (expected.arguments != null && allocationType.arguments.length == expected.arguments.length) {
 			// check the case when no ctor takes no params and inference uses the expected type directly
@@ -614,7 +604,7 @@ public void checkTypeArgumentRedundancy(ParameterizedTypeBinding allocationType,
 		// checking for redundant type parameters must fake a diamond, 
 		// so we infer the same results as we would get with a diamond in source code:
 		this.type.bits |= IsDiamond;
-		inferredTypes = inferElidedTypes(allocationType, enclosingType, argumentTyps, scope);
+		inferredTypes = inferElidedTypes(scope);
 	} finally {
 		// reset effects of inference
 		this.type.bits = previousBits;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index b2fbd3b..19fe2de 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -51,6 +51,7 @@ import org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier;
 import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
+import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
@@ -280,8 +281,8 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 		if (this.anonymousType == null && this.enclosingInstance == null) {
 			return super.resolveType(scope);
 		}
-		TypeBinding result=resolveTypeForQualifiedAllocationExpression(scope);
-		if(result != null && this.binding != null) {
+		TypeBinding result = resolveTypeForQualifiedAllocationExpression(scope);
+		if (result != null && !result.isPolyType() && this.binding != null) {
 			final CompilerOptions compilerOptions = scope.compilerOptions();
 			if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
 				new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
@@ -295,288 +296,297 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 		// Propagate the type checking to the arguments, and checks if the constructor is defined.
 		// ClassInstanceCreationExpression ::= Primary '.' 'new' SimpleName '(' ArgumentListopt ')' ClassBodyopt
 		// ClassInstanceCreationExpression ::= Name '.' 'new' SimpleName '(' ArgumentListopt ')' ClassBodyopt
-
-		this.constant = Constant.NotAConstant;
+		final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;
 		TypeBinding enclosingInstanceType = null;
-		ReferenceBinding enclosingInstanceReference = null;
 		TypeBinding receiverType = null;
-		boolean hasError = false;
-		boolean enclosingInstanceContainsCast = false;
-		boolean argsContainCast = false;
-
-		if (this.enclosingInstance != null) {
-			if (this.enclosingInstance instanceof CastExpression) {
-				this.enclosingInstance.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
-				enclosingInstanceContainsCast = true;
-			}
-			if ((enclosingInstanceType = this.enclosingInstance.resolveType(scope)) == null){
-				hasError = true;
-			} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {
-				scope.problemReporter().illegalPrimitiveOrArrayTypeForEnclosingInstance(
-					enclosingInstanceType,
-					this.enclosingInstance);
-				hasError = true;
-			} else if (this.type instanceof QualifiedTypeReference) {
-				scope.problemReporter().illegalUsageOfQualifiedTypeReference((QualifiedTypeReference)this.type);
-				hasError = true;
-			} else if (!(enclosingInstanceReference = (ReferenceBinding) enclosingInstanceType).canBeSeenBy(scope)) {
-				// https://bugs.eclipse.org/bugs/show_bug.cgi?id=317212
-				enclosingInstanceType = new ProblemReferenceBinding(
+		long sourceLevel = scope.compilerOptions().sourceLevel;
+		if (this.constant != Constant.NotAConstant) {
+			this.constant = Constant.NotAConstant;
+			ReferenceBinding enclosingInstanceReference = null;
+			boolean hasError = false;
+			boolean enclosingInstanceContainsCast = false;
+
+			if (this.enclosingInstance != null) {
+				if (this.enclosingInstance instanceof CastExpression) {
+					this.enclosingInstance.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
+					enclosingInstanceContainsCast = true;
+				}
+				if ((enclosingInstanceType = this.enclosingInstance.resolveType(scope)) == null){
+					hasError = true;
+				} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {
+					scope.problemReporter().illegalPrimitiveOrArrayTypeForEnclosingInstance(
+							enclosingInstanceType,
+							this.enclosingInstance);
+					hasError = true;
+				} else if (this.type instanceof QualifiedTypeReference) {
+					scope.problemReporter().illegalUsageOfQualifiedTypeReference((QualifiedTypeReference)this.type);
+					hasError = true;
+				} else if (!(enclosingInstanceReference = (ReferenceBinding) enclosingInstanceType).canBeSeenBy(scope)) {
+					// https://bugs.eclipse.org/bugs/show_bug.cgi?id=317212
+					enclosingInstanceType = new ProblemReferenceBinding(
 							enclosingInstanceReference.compoundName,
 							enclosingInstanceReference,
 							ProblemReasons.NotVisible);
-				scope.problemReporter().invalidType(this.enclosingInstance, enclosingInstanceType);
-				hasError = true;
-			} else {
-				receiverType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingInstanceType);
-				checkIllegalNullAnnotation(scope, receiverType);
-				if (receiverType != null && enclosingInstanceContainsCast) {
-					CastExpression.checkNeedForEnclosingInstanceCast(scope, this.enclosingInstance, enclosingInstanceType, receiverType);
+					scope.problemReporter().invalidType(this.enclosingInstance, enclosingInstanceType);
+					hasError = true;
+				} else {
+					this.resolvedType = receiverType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingInstanceType);
+					checkIllegalNullAnnotation(scope, receiverType);
+					if (receiverType != null && enclosingInstanceContainsCast) {
+						CastExpression.checkNeedForEnclosingInstanceCast(scope, this.enclosingInstance, enclosingInstanceType, receiverType);
+					}
 				}
-			}
-		} else {
-			if (this.type == null) {
-				// initialization of an enum constant
-				receiverType = scope.enclosingSourceType();
 			} else {
-				receiverType = this.type.resolveType(scope, true /* check bounds*/);
-				checkIllegalNullAnnotation(scope, receiverType);
-				checkParameterizedAllocation: {
-					if (receiverType == null || !receiverType.isValidBinding()) break checkParameterizedAllocation;
-					if (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()
-						ReferenceBinding currentType = (ReferenceBinding)receiverType;
-						do {
-							// isStatic() is answering true for toplevel types
-							if ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;
-							if (currentType.isRawType()) break checkParameterizedAllocation;
-						} while ((currentType = currentType.enclosingType())!= null);
-						ParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;
-						for (int i = qRef.typeArguments.length - 2; i >= 0; i--) {
-							if (qRef.typeArguments[i] != null) {
-								scope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, receiverType);
-								break;
+				if (this.type == null) {
+					// initialization of an enum constant
+					receiverType = scope.enclosingSourceType();
+				} else {
+					receiverType = this.type.resolveType(scope, true /* check bounds*/);
+					checkIllegalNullAnnotation(scope, receiverType);
+					checkParameterizedAllocation: {
+						if (receiverType == null || !receiverType.isValidBinding()) break checkParameterizedAllocation;
+						if (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()
+							ReferenceBinding currentType = (ReferenceBinding)receiverType;
+							do {
+								// isStatic() is answering true for toplevel types
+								if ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;
+								if (currentType.isRawType()) break checkParameterizedAllocation;
+							} while ((currentType = currentType.enclosingType())!= null);
+							ParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;
+							for (int i = qRef.typeArguments.length - 2; i >= 0; i--) {
+								if (qRef.typeArguments[i] != null) {
+									scope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, receiverType);
+									break;
+								}
 							}
 						}
 					}
 				}
 			}
-		}
-		if (receiverType == null || !receiverType.isValidBinding()) {
-			hasError = true;
-		}
+			if (receiverType == null || !receiverType.isValidBinding()) {
+				hasError = true;
+			}
 
-		// resolve type arguments (for generic constructor call)
-		long sourceLevel = scope.compilerOptions().sourceLevel;
-		final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;
-		if (this.typeArguments != null) {
-			int length = this.typeArguments.length;
-			this.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5;
-			this.genericTypeArguments = new TypeBinding[length];
-			for (int i = 0; i < length; i++) {
-				TypeReference typeReference = this.typeArguments[i];
-				if ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {
-					this.argumentsHaveErrors = true;
+			// resolve type arguments (for generic constructor call)
+			if (this.typeArguments != null) {
+				int length = this.typeArguments.length;
+				this.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5;
+				this.genericTypeArguments = new TypeBinding[length];
+				for (int i = 0; i < length; i++) {
+					TypeReference typeReference = this.typeArguments[i];
+					if ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {
+						this.argumentsHaveErrors = true;
+					}
+					if (this.argumentsHaveErrors && typeReference instanceof Wildcard) {
+						scope.problemReporter().illegalUsageOfWildcard(typeReference);
+					}
 				}
-				if (this.argumentsHaveErrors && typeReference instanceof Wildcard) {
-					scope.problemReporter().illegalUsageOfWildcard(typeReference);
+				if (isDiamond) {
+					scope.problemReporter().diamondNotWithExplicitTypeArguments(this.typeArguments);
+					return null;
 				}
-			}
-			if (isDiamond) {
-				scope.problemReporter().diamondNotWithExplicitTypeArguments(this.typeArguments);
-				return null;
-			}
-			if (this.argumentsHaveErrors) {
-				if (this.arguments != null) { // still attempt to resolve arguments
-					for (int i = 0, max = this.arguments.length; i < max; i++) {
-						this.arguments[i].resolveType(scope);
+				if (this.argumentsHaveErrors) {
+					if (this.arguments != null) { // still attempt to resolve arguments
+						for (int i = 0, max = this.arguments.length; i < max; i++) {
+							this.arguments[i].resolveType(scope);
+						}
 					}
+					return null;
 				}
-				return null;
 			}
-		}
 
-		// will check for null after args are resolved
-		this.argumentTypes = Binding.NO_PARAMETERS;
-		if (this.arguments != null) {
-			int length = this.arguments.length;
-			this.argumentTypes = new TypeBinding[length];
-			for (int i = 0; i < length; i++) {
-				Expression argument = this.arguments[i];
-				if (argument instanceof CastExpression) {
-					argument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
-					argsContainCast = true;
-				}
-				argument.setExpressionContext(INVOCATION_CONTEXT);
-				if ((this.argumentTypes[i] = argument.resolveType(scope)) == null){
-					hasError = true;
+			// will check for null after args are resolved
+			this.argumentTypes = Binding.NO_PARAMETERS;
+			if (this.arguments != null) {
+				int length = this.arguments.length;
+				this.argumentTypes = new TypeBinding[length];
+				for (int i = 0; i < length; i++) {
+					Expression argument = this.arguments[i];
+					if (argument instanceof CastExpression) {
+						argument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
+						this.argsContainCast = true;
+					}
+					argument.setExpressionContext(INVOCATION_CONTEXT);
+					if ((this.argumentTypes[i] = argument.resolveType(scope)) == null){
+						this.argumentsHaveErrors = hasError = true;
+					}
 				}
 			}
-		}
 
-		// limit of fault-tolerance
-		if (hasError) {
-			/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.
-			   No meaningful type resolution is possible since inference of the elided types is fully tied to argument types. Do
-			   not return the partially resolved type.
-			 */
-			if (isDiamond) {
-				return null; // not the partially cooked this.resolvedType
-			}
-			if (receiverType instanceof ReferenceBinding) {
-				ReferenceBinding referenceReceiver = (ReferenceBinding) receiverType;
-				if (receiverType.isValidBinding()) {
-					// record a best guess, for clients who need hint about possible contructor match
-					int length = this.arguments  == null ? 0 : this.arguments.length;
-					TypeBinding[] pseudoArgs = new TypeBinding[length];
-					for (int i = length; --i >= 0;) {
-						pseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type
-					}
-					this.binding = scope.findMethod(referenceReceiver, TypeConstants.INIT, pseudoArgs, this, false);
-					if (this.binding != null && !this.binding.isValidBinding()) {
-						MethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;
-						// record the closest match, for clients who may still need hint about possible method match
-						if (closestMatch != null) {
-							if (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method
-								// shouldn't return generic method outside its context, rather convert it to raw method (175409)
-								closestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);
-							}
-							this.binding = closestMatch;
-							MethodBinding closestMatchOriginal = closestMatch.original();
-							if (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {
-								// ignore cases where method is used from within inside itself (e.g. direct recursions)
-								closestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;
+			// limit of fault-tolerance
+			if (hasError) {
+				/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.
+			       No meaningful type resolution is possible since inference of the elided types is fully tied to argument types. Do
+			       not return the partially resolved type.
+				 */
+				if (isDiamond) {
+					return null; // not the partially cooked this.resolvedType
+				}
+				if (receiverType instanceof ReferenceBinding) {
+					ReferenceBinding referenceReceiver = (ReferenceBinding) receiverType;
+					if (receiverType.isValidBinding()) {
+						// record a best guess, for clients who need hint about possible contructor match
+						int length = this.arguments  == null ? 0 : this.arguments.length;
+						TypeBinding[] pseudoArgs = new TypeBinding[length];
+						for (int i = length; --i >= 0;) {
+							pseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type
+						}
+						this.binding = scope.findMethod(referenceReceiver, TypeConstants.INIT, pseudoArgs, this, false);
+						if (this.binding != null && !this.binding.isValidBinding()) {
+							MethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;
+							// record the closest match, for clients who may still need hint about possible method match
+							if (closestMatch != null) {
+								if (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method
+									// shouldn't return generic method outside its context, rather convert it to raw method (175409)
+									closestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);
+								}
+								this.binding = closestMatch;
+								MethodBinding closestMatchOriginal = closestMatch.original();
+								if (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {
+									// ignore cases where method is used from within inside itself (e.g. direct recursions)
+									closestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;
+								}
 							}
 						}
 					}
+					if (this.anonymousType != null) {
+						// insert anonymous type in scope (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=210070)
+						scope.addAnonymousType(this.anonymousType, referenceReceiver);
+						this.anonymousType.resolve(scope);
+						return this.resolvedType = this.anonymousType.binding;
+					}
 				}
-				if (this.anonymousType != null) {
-					// insert anonymous type in scope (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=210070)
-					scope.addAnonymousType(this.anonymousType, referenceReceiver);
-					this.anonymousType.resolve(scope);
-					return this.resolvedType = this.anonymousType.binding;
-				}
-			}
-			return this.resolvedType = receiverType;
-		}
-		if (this.anonymousType == null) {
-			// qualified allocation with no anonymous type
-			if (!receiverType.canBeInstantiated()) {
-				scope.problemReporter().cannotInstantiate(this.type, receiverType);
 				return this.resolvedType = receiverType;
 			}
-			if (isDiamond) {
-				TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) receiverType, receiverType.enclosingType(), this.argumentTypes, scope);
-				if (inferredTypes == null) {
-					scope.problemReporter().cannotInferElidedTypes(this);
-					return this.resolvedType = null;
+			if (this.anonymousType == null) {
+				// qualified allocation with no anonymous type
+				if (!receiverType.canBeInstantiated()) {
+					scope.problemReporter().cannotInstantiate(this.type, receiverType);
+					return this.resolvedType = receiverType;
 				}
-				receiverType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) receiverType).genericType(), inferredTypes, ((ParameterizedTypeBinding) receiverType).enclosingType());
-			}
-			ReferenceBinding allocationType = (ReferenceBinding) receiverType;
-			this.binding = findConstructorBinding(scope, this, allocationType, this.argumentTypes);
+			} else {
+				if (isDiamond) {
+					scope.problemReporter().diamondNotWithAnoymousClasses(this.type);
+					return null;
+				}	
+				ReferenceBinding superType = (ReferenceBinding) receiverType;
+				if (superType.isTypeVariable()) {
+					superType = new ProblemReferenceBinding(new char[][]{superType.sourceName()}, superType, ProblemReasons.IllegalSuperTypeVariable);
+					scope.problemReporter().invalidType(this, superType);
+					return null;
+				} else if (this.type != null && superType.isEnum()) { // tolerate enum constant body
+					scope.problemReporter().cannotInstantiate(this.type, superType);
+					return this.resolvedType = superType;
+				}
+				// anonymous type scenario
+				// an anonymous class inherits from java.lang.Object when declared "after" an interface
+				ReferenceBinding anonymousSuperclass = superType.isInterface() ? scope.getJavaLangObject() : superType;
+				// insert anonymous type in scope
+				scope.addAnonymousType(this.anonymousType, superType);
+				this.anonymousType.resolve(scope);
+
+				// find anonymous super constructor
+				this.resolvedType = this.anonymousType.binding; // 1.2 change
+				if ((this.resolvedType.tagBits & TagBits.HierarchyHasProblems) != 0) {
+					return null; // stop secondary errors
+				}
+				MethodBinding inheritedBinding = findConstructorBinding(scope, this, anonymousSuperclass, this.argumentTypes);
 
-			if (this.binding.isValidBinding()) {	
-				if (isMethodUseDeprecated(this.binding, scope, true)) {
-					scope.problemReporter().deprecatedMethod(this.binding, this);
+				if (!inheritedBinding.isValidBinding()) {
+					if (inheritedBinding.declaringClass == null) {
+						inheritedBinding.declaringClass = anonymousSuperclass;
+					}
+					if (this.type != null && !this.type.resolvedType.isValidBinding()) {
+						// problem already got signaled on type reference, do not report secondary problem
+						return null;
+					}
+					scope.problemReporter().invalidConstructor(this, inheritedBinding);
+					return this.resolvedType;
 				}
-				if (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, this.argumentTypes, argsContainCast, this)) {
-					this.bits |= ASTNode.Unchecked;
+				if ((inheritedBinding.tagBits & TagBits.HasMissingType) != 0) {
+					scope.problemReporter().missingTypeInConstructor(this, inheritedBinding);
 				}
-				if (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {
-					scope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);
+				if (this.enclosingInstance != null) {
+					ReferenceBinding targetEnclosing = inheritedBinding.declaringClass.enclosingType();
+					if (targetEnclosing == null) {
+						scope.problemReporter().unnecessaryEnclosingInstanceSpecification(this.enclosingInstance, superType);
+						return this.resolvedType;
+					} else if (!enclosingInstanceType.isCompatibleWith(targetEnclosing) && !scope.isBoxingCompatibleWith(enclosingInstanceType, targetEnclosing)) {
+						scope.problemReporter().typeMismatchError(enclosingInstanceType, targetEnclosing, this.enclosingInstance, null);
+						return this.resolvedType;
+					}
+					this.enclosingInstance.computeConversion(scope, targetEnclosing, enclosingInstanceType);
 				}
-			} else {
-				if (this.binding.declaringClass == null) {
-					this.binding.declaringClass = allocationType;
+				if (this.arguments != null) {
+					if (checkInvocationArguments(scope, null, anonymousSuperclass, inheritedBinding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {
+						this.bits |= ASTNode.Unchecked;
+					}
 				}
-				if (this.type != null && !this.type.resolvedType.isValidBinding()) {
-					// problem already got signaled on type reference, do not report secondary problem
-					return null;
+				if (this.typeArguments != null && inheritedBinding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {
+					scope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(inheritedBinding, this.genericTypeArguments, this.typeArguments);
 				}
-				scope.problemReporter().invalidConstructor(this, this.binding);
-				return this.resolvedType = receiverType;
+				// Update the anonymous inner class : superclass, interface
+				this.binding = this.anonymousType.createDefaultConstructorWithBinding(inheritedBinding, 	(this.bits & ASTNode.Unchecked) != 0 && this.genericTypeArguments == null);
+				return this.resolvedType;
 			}
-			if ((this.binding.tagBits & TagBits.HasMissingType) != 0) {
-				scope.problemReporter().missingTypeInConstructor(this, this.binding);
+		} else {
+			if (this.enclosingInstance != null) {
+				enclosingInstanceType = this.enclosingInstance.resolvedType;
+				this.resolvedType = receiverType = this.type.resolvedType;
 			}
-			if (!isDiamond && receiverType.isParameterizedTypeWithActualArguments()) {
-		 		checkTypeArgumentRedundancy((ParameterizedTypeBinding)receiverType, receiverType.enclosingType(), this.argumentTypes , scope);
-		 	}
-			// The enclosing instance must be compatible with the innermost enclosing type
-			ReferenceBinding expectedType = this.binding.declaringClass.enclosingType();
-			if (TypeBinding.notEquals(expectedType, enclosingInstanceType)) // must call before computeConversion() and typeMismatchError()
-				scope.compilationUnitScope().recordTypeConversion(expectedType, enclosingInstanceType);
-			if (enclosingInstanceType.isCompatibleWith(expectedType) || scope.isBoxingCompatibleWith(enclosingInstanceType, expectedType)) {
-				this.enclosingInstance.computeConversion(scope, expectedType, enclosingInstanceType);
-				return this.resolvedType = receiverType;
+		}
+		if (isDiamond) {
+			this.binding = inferConstructorOfElidedParameterizedType(scope);
+			if (this.binding == null || !this.binding.isValidBinding()) {
+				scope.problemReporter().cannotInferElidedTypes(this);
+				return this.resolvedType = null;
 			}
-			scope.problemReporter().typeMismatchError(enclosingInstanceType, expectedType, this.enclosingInstance, null);
-			return this.resolvedType = receiverType;
+			if (this.typeExpected == null && sourceLevel >= ClassFileConstants.JDK1_8 && this.expressionContext.definesTargetType()) {
+				return new PolyTypeBinding(this);
+			}
+			this.resolvedType = this.type.resolvedType = receiverType = this.binding.declaringClass;
+			resolvePolyExpressionArguments(this, this.binding, this.argumentTypes, scope);
 		} else {
-			if (isDiamond) {
-				scope.problemReporter().diamondNotWithAnoymousClasses(this.type);
-				return null;
-			}	
-		}
-		ReferenceBinding superType = (ReferenceBinding) receiverType;
-		if (superType.isTypeVariable()) {
-			superType = new ProblemReferenceBinding(new char[][]{superType.sourceName()}, superType, ProblemReasons.IllegalSuperTypeVariable);
-			scope.problemReporter().invalidType(this, superType);
-			return null;
-		} else if (this.type != null && superType.isEnum()) { // tolerate enum constant body
-			scope.problemReporter().cannotInstantiate(this.type, superType);
-			return this.resolvedType = superType;
-		}
-		// anonymous type scenario
-		// an anonymous class inherits from java.lang.Object when declared "after" an interface
-		ReferenceBinding anonymousSuperclass = superType.isInterface() ? scope.getJavaLangObject() : superType;
-		// insert anonymous type in scope
-		scope.addAnonymousType(this.anonymousType, superType);
-		this.anonymousType.resolve(scope);
-
-		// find anonymous super constructor
-		this.resolvedType = this.anonymousType.binding; // 1.2 change
-		if ((this.resolvedType.tagBits & TagBits.HierarchyHasProblems) != 0) {
-			return null; // stop secondary errors
+			this.binding = findConstructorBinding(scope, this, (ReferenceBinding) receiverType, this.argumentTypes);
 		}
-		MethodBinding inheritedBinding = findConstructorBinding(scope, this, anonymousSuperclass, this.argumentTypes);
-			
-		if (!inheritedBinding.isValidBinding()) {
-			if (inheritedBinding.declaringClass == null) {
-				inheritedBinding.declaringClass = anonymousSuperclass;
+
+		if (this.binding.isValidBinding()) {	
+			if (isMethodUseDeprecated(this.binding, scope, true)) {
+				scope.problemReporter().deprecatedMethod(this.binding, this);
+			}
+			if (checkInvocationArguments(scope, null, receiverType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {
+				this.bits |= ASTNode.Unchecked;
+			}
+			if (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {
+				scope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);
+			}
+		} else {
+			if (this.binding.declaringClass == null) {
+				this.binding.declaringClass = (ReferenceBinding) receiverType;
 			}
 			if (this.type != null && !this.type.resolvedType.isValidBinding()) {
 				// problem already got signaled on type reference, do not report secondary problem
 				return null;
 			}
-			scope.problemReporter().invalidConstructor(this, inheritedBinding);
-			return this.resolvedType;
+			scope.problemReporter().invalidConstructor(this, this.binding);
+			return this.resolvedType = receiverType;
 		}
-		if ((inheritedBinding.tagBits & TagBits.HasMissingType) != 0) {
-			scope.problemReporter().missingTypeInConstructor(this, inheritedBinding);
+		if ((this.binding.tagBits & TagBits.HasMissingType) != 0) {
+			scope.problemReporter().missingTypeInConstructor(this, this.binding);
 		}
-		if (this.enclosingInstance != null) {
-			ReferenceBinding targetEnclosing = inheritedBinding.declaringClass.enclosingType();
-			if (targetEnclosing == null) {
-				scope.problemReporter().unnecessaryEnclosingInstanceSpecification(this.enclosingInstance, superType);
-				return this.resolvedType;
-			} else if (!enclosingInstanceType.isCompatibleWith(targetEnclosing) && !scope.isBoxingCompatibleWith(enclosingInstanceType, targetEnclosing)) {
-				scope.problemReporter().typeMismatchError(enclosingInstanceType, targetEnclosing, this.enclosingInstance, null);
-				return this.resolvedType;
-			}
-			this.enclosingInstance.computeConversion(scope, targetEnclosing, enclosingInstanceType);
+		if (!isDiamond && receiverType.isParameterizedTypeWithActualArguments()) {
+			checkTypeArgumentRedundancy((ParameterizedTypeBinding)receiverType, scope);
 		}
-		if (this.arguments != null) {
-			if (checkInvocationArguments(scope, null, anonymousSuperclass, inheritedBinding, this.arguments, this.argumentTypes, argsContainCast, this)) {
-				this.bits |= ASTNode.Unchecked;
-			}
-		}
-		if (this.typeArguments != null && inheritedBinding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {
-			scope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(inheritedBinding, this.genericTypeArguments, this.typeArguments);
+		// The enclosing instance must be compatible with the innermost enclosing type
+		ReferenceBinding expectedType = this.binding.declaringClass.enclosingType();
+		if (TypeBinding.notEquals(expectedType, enclosingInstanceType)) // must call before computeConversion() and typeMismatchError()
+			scope.compilationUnitScope().recordTypeConversion(expectedType, enclosingInstanceType);
+		if (enclosingInstanceType.isCompatibleWith(expectedType) || scope.isBoxingCompatibleWith(enclosingInstanceType, expectedType)) {
+			this.enclosingInstance.computeConversion(scope, expectedType, enclosingInstanceType);
+			return this.resolvedType = receiverType;
 		}
-		// Update the anonymous inner class : superclass, interface
-		this.binding = this.anonymousType.createDefaultConstructorWithBinding(inheritedBinding, 	(this.bits & ASTNode.Unchecked) != 0 && this.genericTypeArguments == null);
-		return this.resolvedType;
+		scope.problemReporter().typeMismatchError(enclosingInstanceType, expectedType, this.enclosingInstance, null);
+		return this.resolvedType = receiverType;
 	}
 
 	public void traverse(ASTVisitor visitor, BlockScope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index ce588c5..aa81b84 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -4847,7 +4847,7 @@ public abstract class Scope {
 			currentType = currentType.enclosingType();
 		}
 	
-		MethodBinding[] methods = genericType.getMethods(TypeConstants.INIT, argumentTypes.length);
+		MethodBinding[] methods = allocationType.getMethods(TypeConstants.INIT, argumentTypes.length);
 		MethodBinding [] staticFactories = new MethodBinding[methods.length];
 		int sfi = 0;
 		for (int i = 0, length = methods.length; i < length; i++) {
@@ -4866,7 +4866,7 @@ public abstract class Scope {
 			final int factoryArity = classTypeVariablesArity + methodTypeVariablesArity;
 			final LookupEnvironment environment = environment();
 			
-			MethodBinding staticFactory = new SyntheticFactoryMethodBinding(method, environment, originalEnclosingType);
+			MethodBinding staticFactory = new SyntheticFactoryMethodBinding(method.original(), environment, originalEnclosingType);
 			staticFactory.typeVariables = new TypeVariableBinding[factoryArity];
 			final SimpleLookupTable map = new SimpleLookupTable(factoryArity);
 			
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
index 48a8f4f..24c13b9 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
@@ -183,7 +183,6 @@ public TypeBinding resolveType(BlockScope scope) {
 	}
 
 	// buffering the arguments' types
-	boolean argsContainCast = false;
 	this.argumentTypes = Binding.NO_PARAMETERS;
 	if (this.arguments != null) {
 		this.argumentsHaveErrors = false;
@@ -193,7 +192,7 @@ public TypeBinding resolveType(BlockScope scope) {
 			Expression argument = this.arguments[i];
 			if (argument instanceof CastExpression) {
 				argument.bits |= DisableUnnecessaryCastCheck; // will check later on
-				argsContainCast = true;
+				this.argsContainCast = true;
 			}
 			argument.setExpressionContext(INVOCATION_CONTEXT);
 			if ((this.argumentTypes[i] = argument.resolveType(scope)) == null) {
@@ -212,7 +211,7 @@ public TypeBinding resolveType(BlockScope scope) {
 		return this.resolvedType;
 	}
 	if (isDiamond) {
-		TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, this.argumentTypes, scope);
+		TypeBinding [] inferredTypes = inferElidedTypes(scope);
 		if (inferredTypes == null) {
 			scope.problemReporter().cannotInferElidedTypes(this);
 			return this.resolvedType = null;
@@ -285,7 +284,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				scope.problemReporter().unsafeTypeConversion(this.arguments[i], argumentType, parameterType);
 			}
 		}
-		if (argsContainCast) {
+		if (this.argsContainCast) {
 			CastExpression.checkNeedForArgumentCasts(scope, null, allocatedType, this.binding, this.arguments, this.argumentTypes, this);
 		}
 	}
