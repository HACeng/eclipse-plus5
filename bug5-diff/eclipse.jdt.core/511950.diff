commit 1b5cbd826a5a9c2f7934e718ce4c8ef866e69bbf
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Mon Feb 13 16:49:22 2017 +0530

    Bug 511950 - [9][test] Create jclMin*.jar for model tests for compliance
    9

-	-	org.eclipse.jdt.core.tests.model/JCL/jclMin9.jar
-	-	org.eclipse.jdt.core.tests.model/JCL/jclMin9src.zip
13	7	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
22	16	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
4	3	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
3	2	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationDecorator.java
4	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
3	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
3	2	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
3	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
5	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
122	0	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
37	25	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
3	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
3	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
3	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
2	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
diff --git a/org.eclipse.jdt.core.tests.model/JCL/jclMin9.jar b/org.eclipse.jdt.core.tests.model/JCL/jclMin9.jar
new file mode 100644
index 0000000..6f2af93
Binary files /dev/null and b/org.eclipse.jdt.core.tests.model/JCL/jclMin9.jar differ
diff --git a/org.eclipse.jdt.core.tests.model/JCL/jclMin9src.zip b/org.eclipse.jdt.core.tests.model/JCL/jclMin9src.zip
new file mode 100644
index 0000000..d46027f
Binary files /dev/null and b/org.eclipse.jdt.core.tests.model/JCL/jclMin9src.zip differ
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
index c1e41cd..4c5f249 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java
@@ -2910,11 +2910,8 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 			newJclSrcString = "JCL18_SRC"; // Use the same source
 		} else {
 			if (compliance.length() < 3) {
-				// stop-gap measure. As of now, the Java 9 tests rely
-				// on adding the JREContainer directly to the classpath.
-					newJclLibString = "JCL18_LIB";
-					newJclSrcString = "JCL18_SRC";
-				//}
+					newJclLibString = "JCL19_LIB";
+					newJclSrcString = "JCL19_SRC";
 			} else if (compliance.charAt(2) > '7') {
 				newJclLibString = "JCL18_LIB";
 				newJclSrcString = "JCL18_SRC";
@@ -2960,9 +2957,10 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 		IPath jclLib = new Path("JCL_LIB");
 		IPath jcl5Lib = new Path("JCL15_LIB");
 		IPath jcl8Lib = new Path("JCL18_LIB");
+		IPath jcl9Lib = new Path("JCL19_LIB");
 		IPath jclFull = new Path("JCL18_FULL");
 
-		return path.equals(jclLib) || path.equals(jcl5Lib) || path.equals(jcl8Lib) || path.equals(jclFull);
+		return path.equals(jclLib) || path.equals(jcl5Lib) || path.equals(jcl8Lib) || path.equals(jcl9Lib) || path.equals(jclFull);
 	}
 	public void setUpJCLClasspathVariables(String compliance) throws JavaModelException, IOException {
 		setUpJCLClasspathVariables(compliance, false);
@@ -2984,7 +2982,7 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 					new IPath[] {getExternalJCLPath("1.7"), getExternalJCLSourcePath("1.7"), getExternalJCLRootSourcePath()},
 					null);
 			}
-		} else if ("1.8".equals(compliance) || "9".equals(compliance)) {
+		} else if ("1.8".equals(compliance)) {
 			if (useFullJCL) {
 				if (JavaCore.getClasspathVariable("JCL18_FULL") == null) {
 					setupExternalJCL("jclMin1.8"); // Create the whole mininmal 1.8 set, though we will need only the source zip
@@ -3001,6 +2999,14 @@ public abstract class AbstractJavaModelTests extends SuiteOfTestCases {
 							new IPath[] {getExternalJCLPath("1.8"), getExternalJCLSourcePath("1.8"), getExternalJCLRootSourcePath()},
 							null);
 			}
+		} else if ("9".equals(compliance)) {
+			if (JavaCore.getClasspathVariable("JCL19_LIB") == null) {
+				setupExternalJCL("jclMin9");
+				JavaCore.setClasspathVariables(
+					new String[] {"JCL19_LIB", "JCL19_SRC", "JCL_SRCROOT"},
+					new IPath[] {getExternalJCLPath("9"), getExternalJCLSourcePath("9"), getExternalJCLRootSourcePath()},
+					null);
+			}
 		} else {
 			if (JavaCore.getClasspathVariable("JCL_LIB") == null) {
 				setupExternalJCL("jclMin");
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
index 661ff11..dac6058 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ModuleBuilderTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -32,6 +32,7 @@ import org.eclipse.jdt.core.IClasspathEntry;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaModelMarker;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IModuleDescription;
 import org.eclipse.jdt.core.IPackageFragmentRoot;
 import org.eclipse.jdt.core.IProblemRequestor;
 import org.eclipse.jdt.core.JavaCore;
@@ -39,7 +40,6 @@ import org.eclipse.jdt.core.WorkingCopyOwner;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
-import org.eclipse.jdt.internal.core.JrtPackageFragmentRoot;
 import org.eclipse.jdt.internal.core.util.Messages;
 
 import junit.framework.Test;
@@ -88,18 +88,26 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	public void test001() throws CoreException {
 		if (!isJRE9) return;
 		try {
-			IPackageFragmentRoot[] roots = this.currentProject.getPackageFragmentRoots();
+			IJavaProject project = createJava9Project("Test01", new String[]{"src"});
+			this.createFile("Test01/src/module-info.java", "");
+			this.createFolder("Test01/src/com/greetings");
+			this.createFile("Test01/src/com/greetings/Main.java", "");
+			waitForManualRefresh();
+			waitForAutoBuild();
+			project.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IPackageFragmentRoot[] roots = project.getPackageFragmentRoots();
 			IPackageFragmentRoot base = null;
 			for (IPackageFragmentRoot iRoot : roots) {
-				if (iRoot.getElementName().equals("java.base")) {
+				IModuleDescription moduleDescription = iRoot.getModuleDescription();
+				if (moduleDescription != null) {
 					base = iRoot;
 					break;
 				}
 			}
 			assertNotNull("Java.base module should not null", base);
-			assertTrue("Java.base should be a module package fragment root", (base instanceof JrtPackageFragmentRoot));
-			assertMarkers("Unexpected markers", "", this.currentProject);
+			assertMarkers("Unexpected markers", "", project);
 		} finally {
+			deleteProject("Test01");
 		}
 	}
 	// Test the project compiles without errors with a simple module-info.java
@@ -130,7 +138,6 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 					"package com.greetings;\n" +
 					"public class Main {\n" +
 					"	public static void main(String[] args) {\n" +
-					"		System.out.println(\"Hello\");\n" +
 					"	}\n" +
 					"}");
 			waitForManualRefresh();
@@ -225,7 +232,6 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 				"package com.greetings;\n" +
 				"public class Main {\n" +
 				"	public static void main(String[] args) {\n" +
-				"		System.out.println(\"Hello\");\n" +
 				"	}\n" +
 				"}");
 		this.createFile("P2/src/module-info.java",
@@ -249,7 +255,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	 * module M2 has no 'requires' M1. Should report unresolved type, import etc.  
 	 *
 	 */
-	public void test007() throws CoreException {
+	public void test007() throws Exception {
 		if (!isJRE9) return;
 		try {
 			IJavaProject project = setupP2();
@@ -281,7 +287,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	 * the types in unexported packages.
 	 *
 	 */
-	public void test008() throws CoreException {
+	public void test008() throws Exception {
 		if (!isJRE9) return;
 		try {
 			IJavaProject project = setupP2();
@@ -311,7 +317,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	 * Module M2 has "requires M1" in module-info and all packages used by M2 
 	 * are exported by M1. No errors expected. 
 	 */
-	public void test009() throws CoreException {
+	public void test009() throws Exception {
 		if (!isJRE9) return;
 		try {
 			IJavaProject project = setupP2();
@@ -338,7 +344,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	 * Module M1 exports a package to a specific module, which is not M2.
 	 * Usage of types from M1 in M2 should be reported.
 	 */
-	public void _test010() throws CoreException {
+	public void _test010() throws Exception {
 		if (!isJRE9) return;
 		try {
 			IJavaProject project = setupP2();
@@ -393,7 +399,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	 * Module M1 exports a package (to all), M2 requires M1 and M3 requires M2. Usage of types from
 	 * M1 in M3 should be reported as errors.
 	 */
-	public void test011() throws CoreException {
+	public void test011() throws Exception {
 		if (!isJRE9) return;
 		try {
 			this.editFile("P1/src/module-info.java",
@@ -420,7 +426,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	 * Module M1 exports a package only to M2, M2 requires M1 and M3 requires M2. Usage of types from
 	 * M1 in M3 should not be allowed.
 	 */
-	public void test012() throws CoreException {
+	public void test012() throws Exception {
 		if (!isJRE9) return;
 		try {
 			this.editFile("P1/src/module-info.java",
@@ -454,7 +460,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	 * Module M1 exports a package (to all), M2 requires 'public' M1 and M3 requires M2. Usage of types from
 	 * M1 in M3 should be allowed.
 	 */
-	public void test013() throws CoreException {
+	public void test013() throws Exception {
 		if (!isJRE9) return;
 		try {
 			IJavaProject p2 = setupP2();
@@ -478,7 +484,7 @@ public class ModuleBuilderTests extends ModifyingResourceTests {
 	 * Module M1 exports a package only to M2, M2 requires 'public' M1 and M3 requires M2. Usage of types from
 	 * M1 in M3 should be allowed. And no errors reported on M2.
 	 */
-	public void test014() throws CoreException {
+	public void test014() throws Exception {
 		if (!isJRE9) return;
 		try {
 			this.editFile("P1/src/module-info.java",
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
index ebce172..d043886 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJar.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -120,10 +120,11 @@ public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageN
 	try {
 		IBinaryType reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
 		if (reader != null) {
+			char[] modName = this.module == null ? null : this.module.name();
 			if (reader instanceof ClassFileReader) {
 				ClassFileReader classReader = (ClassFileReader) reader;
 				if (classReader.moduleName == null) {
-					classReader.moduleName = this.module == null ? null : this.module.name();
+					classReader.moduleName = modName;
 				}
 			}
 			searchPaths:
@@ -146,7 +147,7 @@ public NameEnvironmentAnswer findClass(char[] typeName, String qualifiedPackageN
 				// location is configured for external annotations, but no .eea found, decorate in order to answer NO_EEA_FILE:
 				reader = new ExternalAnnotationDecorator(reader, null);
 			}
-			return new NameEnvironmentAnswer(reader, fetchAccessRestriction(qualifiedBinaryFileName), reader.getModule());
+			return new NameEnvironmentAnswer(reader, fetchAccessRestriction(qualifiedBinaryFileName), modName);
 		}
 	} catch(ClassFormatException e) {
 		// treat as if class file is missing
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
index b841a9a..3573276 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/ClasspathJrt.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation.
+ * Copyright (c) 2016, 2017 IBM Corporation.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -114,7 +114,8 @@ public class ClasspathJrt extends ClasspathLocation implements IMultiModuleEntry
 						}
 					}
 				}
-				return new NameEnvironmentAnswer(reader, fetchAccessRestriction(qualifiedBinaryFileName), reader.getModule());
+				char[] modName = reader.getModule() == null ? null : reader.getModule().name();
+				return new NameEnvironmentAnswer(reader, fetchAccessRestriction(qualifiedBinaryFileName), modName);
 			}
 		} catch(ClassFormatException e) {
 			// treat as if class file is missing
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index c7bc52e..0dd5d0f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -616,8 +616,8 @@ public IBinaryField[] getFields() {
 /**
  * @see IBinaryType#getModule()
  */
-public char[] getModule() {
-	return this.moduleName;
+public IModule getModule() {
+	return this.moduleDeclaration;
 }
 /**
  * Returns the module declaration that this class file represents. This will be 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationDecorator.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationDecorator.java
index 6c728a2..aa940ac 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationDecorator.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ExternalAnnotationDecorator.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 Google, Inc. and others.
+ * Copyright (c) 2016, 2017 Google, Inc. and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -23,6 +23,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
@@ -289,7 +290,7 @@ public class ExternalAnnotationDecorator implements IBinaryType {
 	}
 
 	@Override
-	public char[] getModule() {
+	public IModule getModule() {
 		// TODO Auto-generated method stub
 		return null;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
index 15c967a..20e93de 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -63,11 +63,11 @@ char[] getEnclosingTypeName();
 
 IBinaryField[] getFields();
 /**
- * Answer the name of the module to which this type belongs.
+ * Answer the module to which this type belongs.
  *
- * @return the name of the module as char array
+ * @return the module
  */
-char[] getModule();
+IModule getModule();
 /**
  * Answer the receiver's ClassSignature, which describes the type parameters,
  * super class, and super interfaces as specified in section "4.7.9.1 Signatures"
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
index 8fb006c..51d0dea 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IModuleEnvironment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -23,8 +23,8 @@ package org.eclipse.jdt.internal.compiler.env;
  * @see IModulePathEntry#getLookupEnvironmentFor(IModule)
  */
 public interface IModuleEnvironment {
-	String MODULE_INFO_JAVA = "module-info.java"; //$NON-NLS-1$
-	String MODULE_INFO_CLASS = "module-info.class"; //$NON-NLS-1$
+	static String MODULE_INFO_JAVA = "module-info.java"; //$NON-NLS-1$
+	static String MODULE_INFO_CLASS = "module-info.class"; //$NON-NLS-1$
 
 	/**
 	 * A way to lookup types in a module
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
index 992c7b7..70182ec 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -27,7 +27,9 @@ public class NameEnvironmentAnswer {
 	String externalAnnotationPath; // should be an absolute file system path
 
 	public NameEnvironmentAnswer(IBinaryType binaryType, AccessRestriction accessRestriction) {
-		this(binaryType, accessRestriction, binaryType.getModule());
+		this.binaryType = binaryType;
+		this.accessRestriction = accessRestriction;
+		this.module = binaryType.getModule() != null ? binaryType.getModule().name() : null;
 	}
 
 	public NameEnvironmentAnswer(IBinaryType binaryType, AccessRestriction accessRestriction, char[] module) {
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
index 109cf37..222d373 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -29,6 +29,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
@@ -203,7 +204,7 @@ public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWal
 	return walker;
 }
 @Override
-public char[] getModule() {
+public IModule getModule() {
 	// TODO BETA_JAVA9 Auto-generated method stub
 	return null;
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
index 36e3bf2..1d2cf29 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/ClassFile.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -45,6 +45,7 @@ import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationDecorator;
 import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationProvider;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IDependent;
+import org.eclipse.jdt.internal.compiler.env.IModuleEnvironment;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
 import org.eclipse.jdt.internal.core.nd.java.JavaNames;
 import org.eclipse.jdt.internal.core.nd.java.model.BinaryTypeDescriptor;
@@ -388,7 +389,7 @@ private IBinaryType getJarBinaryTypeInfo() throws CoreException, IOException, Cl
 		PackageFragment pkg = (PackageFragment) getParent();
 		JarPackageFragmentRoot jarRoot = (JarPackageFragmentRoot) getPackageFragmentRoot();
 		String entryName = Util.concatWith(pkg.names, getElementName(), '/');
-		if (root instanceof JrtPackageFragmentRoot) {
+		if (root instanceof JrtPackageFragmentRoot || entryName.equals(IModuleEnvironment.MODULE_INFO_CLASS)) {
 			byte[] contents = getClassFileContent(jarRoot, entryName);
 			if (contents != null) {
 				String fileName;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
index 9d297d9..21107db 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathDirectory.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -177,8 +177,9 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 		return null;
 	}
 	if (reader != null) {
+		char[] modName = this.module == null ? null : this.module.name();
 		if (reader instanceof ClassFileReader) {
-			((ClassFileReader) reader).moduleName = this.module == null ? null : this.module.name();
+			((ClassFileReader) reader).moduleName = modName;
 		}
 		String fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);
 		if (this.externalAnnotationPath != null) {
@@ -194,8 +195,8 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 			}
 		}
 		if (this.accessRuleSet == null)
-			return this.module == null ? new NameEnvironmentAnswer(reader, null) : new NameEnvironmentAnswer(reader, null, reader.getModule());
-		return new NameEnvironmentAnswer(reader, this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()), reader.getModule());
+			return this.module == null ? new NameEnvironmentAnswer(reader, null) : new NameEnvironmentAnswer(reader, null, modName);
+		return new NameEnvironmentAnswer(reader, this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()), modName);
 	}
 	return null;
 }
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
new file mode 100644
index 0000000..51dab52
--- /dev/null
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
@@ -0,0 +1,122 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corporation.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.builder;
+
+import java.io.BufferedInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Enumeration;
+import java.util.zip.ZipEntry;
+
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
+import org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationDecorator;
+import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;
+import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.env.IModule;
+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
+import org.eclipse.jdt.internal.compiler.util.SimpleSet;
+import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
+import org.eclipse.jdt.internal.compiler.util.Util;
+
+public class ClasspathJMod extends ClasspathJar {
+
+	private static char[] CLASSES = "classes".toCharArray(); //$NON-NLS-1$
+	private static int MODULE_DESCRIPTOR_NAME_LENGTH = MODULE_INFO_CLASS.length();
+
+	ClasspathJMod(String zipFilename, long lastModified, AccessRuleSet accessRuleSet, IPath externalAnnotationPath, INameEnvironment env) {
+		super(zipFilename, lastModified, accessRuleSet, externalAnnotationPath, env, true);
+	}
+
+
+	public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPackageName, String qualifiedBinaryFileName, IModule mod) {
+		// TOOD: BETA_JAVA9 - Should really check for packages with the module context
+		if (!isPackage(qualifiedPackageName)) return null; // most common case
+
+		try {
+			IBinaryType reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
+			if (reader != null) {
+				if (reader instanceof ClassFileReader) {
+					ClassFileReader classReader = (ClassFileReader) reader;
+					if (classReader.moduleName == null) {
+						classReader.moduleName = this.module == null ? null : this.module.name();
+					}
+				}
+				String fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);
+				if (this.externalAnnotationPath != null) {
+					try {
+						if (this.annotationZipFile == null) {
+							this.annotationZipFile = ExternalAnnotationDecorator
+									.getAnnotationZipFile(this.externalAnnotationPath, null);
+						}
+
+						reader = ExternalAnnotationDecorator.create(reader, this.externalAnnotationPath,
+								fileNameWithoutExtension, this.annotationZipFile);
+					} catch (IOException e) {
+						// don't let error on annotations fail class reading
+					}
+				}
+				if (this.accessRuleSet == null)
+					return new NameEnvironmentAnswer(reader, null);
+				return new NameEnvironmentAnswer(reader, this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()));
+			}
+		} catch (IOException e) { // treat as if class file is missing
+		} catch (ClassFormatException e) { // treat as if class file is missing
+		}
+		return null;
+	}
+	protected String readJarContent(final SimpleSet packageSet) {
+		String modInfo = null;
+		for (Enumeration<? extends ZipEntry> e = this.zipFile.entries(); e.hasMoreElements(); ) {
+			ZipEntry entry = e.nextElement();
+			char[] entryName = entry.getName().toCharArray();
+			int index = CharOperation.indexOf('/', entryName);
+			if (index != -1) {
+				char[] folder = CharOperation.subarray(entryName, 0, index);
+				if (CharOperation.equals(CLASSES, folder)) {
+					char[] fileName = CharOperation.subarray(entryName, index + 1, entryName.length);
+					if (modInfo == null && fileName.length == MODULE_DESCRIPTOR_NAME_LENGTH) {
+						if (CharOperation.equals(fileName, MODULE_INFO_CLASS.toCharArray())) {
+							InputStream stream = null;
+							InputStream inputStream;
+							try {
+								inputStream = this.zipFile.getInputStream(entry);
+								if (inputStream == null) throw new IOException("Invalid zip entry name : " + entry.getName()); //$NON-NLS-1$
+								stream = new BufferedInputStream(inputStream);
+								byte[] content = Util.getInputStreamAsByteArray(stream, (int) entry.getSize());
+								DataOutputStream dos = new DataOutputStream(new FileOutputStream(new File("c:\\temp\\module-info.class"))); //$NON-NLS-1$
+								dos.write(content);
+								dos.close();
+//								FileWriter writer = new FileWriter(new File("c:\\temp\\module-info.class")); //$NON-NLS-1$
+							} catch (IOException e1) {
+								// TODO Auto-generated catch block
+								e1.printStackTrace();
+							}
+							modInfo = new String(entryName);
+						}
+					}
+					addToPackageSet(packageSet, new String(fileName), false);
+				}
+			}
+		}
+		return modInfo;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
index b814119..6fffe1b 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJar.java
@@ -61,7 +61,8 @@ static class PackageCacheEntry {
 	}
 }
 
-private static SimpleLookupTable PackageCache = new SimpleLookupTable();
+protected static SimpleLookupTable PackageCache = new SimpleLookupTable();
+protected static SimpleLookupTable ModuleCache = new SimpleLookupTable();
 INameEnvironment env = null;
 
 protected static void addToPackageSet(SimpleSet packageSet, String fileName, boolean endsWithSep) {
@@ -77,34 +78,24 @@ protected static void addToPackageSet(SimpleSet packageSet, String fileName, boo
 
 /**
  * Calculate and cache the package list available in the zipFile.
- * @param jar The ClasspathJar to use
  * @return A SimpleSet with the all the package names in the zipFile.
  */
-static SimpleSet findPackageSet(final ClasspathJar jar) {
-	String zipFileName = jar.zipFilename;
+protected SimpleSet findPackageSet() {
+	String zipFileName = this.zipFilename;
 	PackageCacheEntry cacheEntry = (PackageCacheEntry) PackageCache.get(zipFileName);
-	long lastModified = jar.lastModified();
+	long timestamp = this.lastModified();
 	long fileSize = new File(zipFileName).length();
-	if (cacheEntry != null && cacheEntry.lastModified == lastModified && cacheEntry.fileSize == fileSize)
+	if (cacheEntry != null && cacheEntry.lastModified == timestamp && cacheEntry.fileSize == fileSize) {
+		this.module = (IModule) ModuleCache.get(zipFileName);
 		return cacheEntry.packageSet;
+	}
 	final SimpleSet packageSet = new SimpleSet(41);
 	packageSet.add(""); //$NON-NLS-1$
-	String modInfo = null;
-	for (Enumeration e = jar.zipFile.entries(); e.hasMoreElements(); ) {
-		String fileName = ((ZipEntry) e.nextElement()).getName();
-		int folderEnd = fileName.lastIndexOf('/');
-		folderEnd += 1;
-		String className = fileName.substring(folderEnd, fileName.length());
-		if (className.equalsIgnoreCase(IModuleEnvironment.MODULE_INFO_CLASS)) {
-			modInfo = fileName;
-		}
-		addToPackageSet(packageSet, fileName, false);
-	}
-	PackageCache.put(zipFileName, new PackageCacheEntry(lastModified, fileSize, packageSet));
+	String modInfo = readJarContent(packageSet);
+	PackageCache.put(zipFileName, new PackageCacheEntry(timestamp, fileSize, packageSet));
 	if (modInfo != null) {
 		try {
-			jar.acceptModule(ClassFileReader.read(jar.zipFile, modInfo));
-			jar.isAutoModule = false; // TODO: check with spec on what the behavior should be
+			this.acceptModule(ClassFileReader.read(this.zipFile, modInfo));
 		} catch (ClassFormatException | IOException e) {
 			// TODO BETA_JAVA9 Auto-generated catch block
 			e.printStackTrace();
@@ -112,9 +103,27 @@ static SimpleSet findPackageSet(final ClasspathJar jar) {
 	}
 	return packageSet;
 }
+protected String readJarContent(final SimpleSet packageSet) {
+	String modInfo = null;
+	for (Enumeration e = this.zipFile.entries(); e.hasMoreElements(); ) {
+		String fileName = ((ZipEntry) e.nextElement()).getName();
+		if (modInfo == null) {
+			int folderEnd = fileName.lastIndexOf('/');
+			folderEnd += 1;
+			String className = fileName.substring(folderEnd, fileName.length());
+			if (className.equalsIgnoreCase(MODULE_INFO_CLASS)) {
+				modInfo = fileName;
+			}
+		}
+		addToPackageSet(packageSet, fileName, false);
+	}
+	return modInfo;
+}
 void acceptModule(ClassFileReader classfile) {
 	if (classfile != null) {
-		acceptModule(classfile.getModuleDeclaration());
+		IModule mod = classfile.getModuleDeclaration();
+		ModuleCache.put(this.zipFilename, mod);
+		acceptModule(mod);
 	}
 }
 
@@ -229,10 +238,11 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 	try {
 		IBinaryType reader = ClassFileReader.read(this.zipFile, qualifiedBinaryFileName);
 		if (reader != null) {
+			char[] modName = this.module == null ? null : this.module.name();
 			if (reader instanceof ClassFileReader) {
 				ClassFileReader classReader = (ClassFileReader) reader;
 				if (classReader.moduleName == null) {
-					classReader.moduleName = this.module == null ? null : this.module.name();
+					classReader.moduleName = modName;
 				}
 			}
 			String fileNameWithoutExtension = qualifiedBinaryFileName.substring(0, qualifiedBinaryFileName.length() - SuffixConstants.SUFFIX_CLASS.length);
@@ -255,7 +265,9 @@ public NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedPa
 			}
 			if (this.accessRuleSet == null)
 				return new NameEnvironmentAnswer(reader, null);
-			return new NameEnvironmentAnswer(reader, this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()), reader.getModule());
+			return new NameEnvironmentAnswer(reader, 
+					this.accessRuleSet.getViolatedRestriction(fileNameWithoutExtension.toCharArray()), 
+					modName);
 		}
 	} catch (IOException e) { // treat as if class file is missing
 	} catch (ClassFormatException e) { // treat as if class file is missing
@@ -283,9 +295,9 @@ public boolean isPackage(String qualifiedPackageName) {
 			}
 			this.zipFile = new ZipFile(this.zipFilename);
 			this.closeZipFileAtEnd = true;
-			this.knownPackageNames = findPackageSet(this);
+			this.knownPackageNames = findPackageSet();
 		} else {
-			this.knownPackageNames = findPackageSet(this);
+			this.knownPackageNames = findPackageSet();
 		}
 	} catch(Exception e) {
 		this.knownPackageNames = new SimpleSet(); // assume for this build the zipFile is empty
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
index fb65af5..52824fd 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJrt.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 IBM Corporation and others.
+ * Copyright (c) 2016, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -219,7 +219,8 @@ private NameEnvironmentAnswer findClass(String binaryFileName, String qualifiedP
 					// don't let error on annotations fail class reading
 				}
 			}
-			return new NameEnvironmentAnswer(reader, null, reader.getModule());
+			char[] modName = reader.getModule() == null ? null : reader.getModule().name();
+			return new NameEnvironmentAnswer(reader, null, modName);
 		}
 	} catch (IOException e) { // treat as if class file is missing
 	} catch (ClassFormatException e) { // treat as if class file is missing
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
index 3fac0c7..b2331ea 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyBinaryType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -28,6 +28,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
@@ -305,7 +306,7 @@ public ITypeAnnotationWalker enrichWithExternalAnnotationsFor(ITypeAnnotationWal
 	return walker;
 }
 @Override
-public char[] getModule() {
+public IModule getModule() {
 	// TODO BETA_JAVA9 Auto-generated method stub
 	return null;
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
index d557fec..4262165 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/nd/java/model/IndexBinaryType.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016 Google, Inc and others.
+ * Copyright (c) 2016, 2017 Google, Inc and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -26,6 +26,7 @@ import org.eclipse.jdt.internal.compiler.env.IBinaryMethod;
 import org.eclipse.jdt.internal.compiler.env.IBinaryNestedType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.IBinaryTypeAnnotation;
+import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.ITypeAnnotationWalker;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.ExternalAnnotationStatus;
@@ -671,7 +672,7 @@ public class IndexBinaryType implements IBinaryType {
 	}
 
 	@Override
-	public char[] getModule() {
+	public IModule getModule() {
 		// TODO Auto-generated method stub
 		return null;
 	}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
index 9c69eca..7cda601 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2016 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -217,7 +217,7 @@ public abstract class AbstractIndexer implements IIndexConstants {
 		addIndexEntry(METHOD_REF, MethodPattern.createIndexKey(methodName, argCount));
 	}
 	public void addModuleDeclaration(char[] moduleName) {
-		addIndexEntry(METHOD_DECL, moduleName);
+		addIndexEntry(MODULE_DECL, moduleName);
 	}
 	public void addModuleExportedPackages(char[] packageName) {
 		char[][] tokens = CharOperation.splitOn('.', packageName);
commit 5b154f1db77e8f09ac33d4e747d6070bf41a80c7
Author: Jay Arthanareeswaran <jarthana@in.ibm.com>
Date:   Thu Aug 31 18:43:57 2017 +0530

    Bug 511950 - Remove test code left behind
    
    Change-Id: I6242ecf59c1f8e763e280677e648a95b68418374
    Signed-off-by: Jay Arthanareeswaran <jarthana@in.ibm.com>

0	22	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
index 94bb409..faea6ba 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/ClasspathJMod.java
@@ -14,12 +14,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.core.builder;
 
-import java.io.BufferedInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.Enumeration;
 import java.util.zip.ZipEntry;
 
@@ -34,7 +29,6 @@ import org.eclipse.jdt.internal.compiler.env.IModule;
 import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
-import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class ClasspathJMod extends ClasspathJar {
 
@@ -97,22 +91,6 @@ public class ClasspathJMod extends ClasspathJar {
 					char[] fileName = CharOperation.subarray(entryName, index + 1, entryName.length);
 					if (modInfo == null && fileName.length == MODULE_DESCRIPTOR_NAME_LENGTH) {
 						if (CharOperation.equals(fileName, IModule.MODULE_INFO_CLASS.toCharArray())) {
-							InputStream stream = null;
-							InputStream inputStream;
-							try {
-								inputStream = this.zipFile.getInputStream(entry);
-								if (inputStream == null) throw new IOException("Invalid zip entry name : " + entry.getName()); //$NON-NLS-1$
-								stream = new BufferedInputStream(inputStream);
-								byte[] content = Util.getInputStreamAsByteArray(stream, (int) entry.getSize());
-								// FIXME(SHMOD): avoid this (platform dependent) temp file!! https://bugs.eclipse.org/511950
-								DataOutputStream dos = new DataOutputStream(new FileOutputStream(new File("c:\\temp\\module-info.class"))); //$NON-NLS-1$
-								dos.write(content);
-								dos.close();
-//								FileWriter writer = new FileWriter(new File("c:\\temp\\module-info.class")); //$NON-NLS-1$
-							} catch (IOException e1) {
-								// TODO Auto-generated catch block
-								e1.printStackTrace();
-							}
 							modInfo = new String(entryName);
 						}
 					}
