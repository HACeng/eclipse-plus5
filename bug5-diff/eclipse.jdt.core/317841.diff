commit 650839ed308774b6702bdf04023742a308aab499
Author: Olivier Thomann <oliviert>
Date:   Tue Jun 29 01:03:56 2010 +0000

    HEAD - Fix for 317841

1106	1	org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
77	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConstantTest.java
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
31	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationInfo.java
21	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
36	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ElementValuePairInfo.java
27	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ClassSignature.java
30	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/EnumConstantSignature.java
23	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/BooleanConstant.java
22	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
22	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CharConstant.java
24	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/DoubleConstant.java
22	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/FloatConstant.java
22	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
22	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/LongConstant.java
22	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
26	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/StringConstant.java
11	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
diff --git a/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java b/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
index 02bad8f..9c921b2 100644
--- a/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
+++ b/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
@@ -60,6 +60,71 @@ public class AnnotationDependencyTests extends BuilderTests {
 			+ "String value();\n"
 			+ "}\n";
 		env.addClass(this.srcRoot, "p1", "Anno", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoInt {\n"
+			+ "int value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoInt", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoBoolean {\n"
+			+ "boolean value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoBoolean", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoByte {\n"
+			+ "byte value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoByte", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoChar {\n"
+			+ "char value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoChar", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoShort {\n"
+			+ "short value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoShort", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoDouble {\n"
+			+ "double value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoDouble", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoFloat {\n"
+			+ "float value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoFloat", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoLong {\n"
+			+ "long value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoLong", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoStringArray {\n"
+			+ "String[] value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoStringArray", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoAnnotation {\n"
+			+ "AnnoLong value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoAnnotation", annoCode);
+		annoCode = "package p1;\n"
+			+ "enum E {\n"
+			+ "A, B, C\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "E", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoEnum {\n"
+			+ "E value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoEnum", annoCode);
+		annoCode = "package p1;\n"
+			+ "@interface AnnoClass {\n"
+			+ "Class<?> value();\n"
+			+ "}\n";
+		env.addClass(this.srcRoot, "p1", "AnnoClass", annoCode);
 	}
 	
 	/**
@@ -265,5 +330,1045 @@ public class AnnotationDependencyTests extends BuilderTests {
 		env.addClass( this.srcRoot, "question", "package-info", question );
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
-	}	
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency2() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@Anno(\"A1\")" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@Anno(\"A1\")" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency3() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoInt(3)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoInt(3)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency4() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoByte(3)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoByte(3)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency5() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoBoolean(true)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoBoolean(true)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency6() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoChar('c')" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoChar('c')" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency7() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoDouble(1.0)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoDouble(1.0)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency8() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoFloat(1.0f)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoFloat(1.0f)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency9() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoLong(1L)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoLong(1L)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency10() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoShort(3)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoShort(3)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency11() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoStringArray({\"A1\",\"A2\"})" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoStringArray({\"A1\",\"A2\"})" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency12() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoAnnotation(@AnnoLong(3))" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoAnnotation(@AnnoLong(3))" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency13() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoEnum(E.A)\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoEnum(E.A)\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency14() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoClass(Object.class)\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoClass(Object.class)\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency15() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@Anno(\"A1\")" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@Anno(\"A1\")" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency16() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoInt(3)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoInt(4)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency17() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoByte(3)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoByte(4)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B"});
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency18() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoBoolean(true)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoBoolean(false)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency19() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoChar('c')" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoChar('d')" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency20() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoDouble(1.0)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoDouble(2.0)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency21() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoFloat(1.0f)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoFloat(2.0f)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency22() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoLong(1L)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoLong(2L)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency23() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoShort(3)" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoShort(5)" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency24() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoStringArray({\"A1\",\"A2\"})" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoStringArray({\"A2\",\"A1\"})" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency25() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoAnnotation(@AnnoLong(3))" + "\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoAnnotation(@AnnoLong(4))" + "\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency26() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoEnum(E.A)\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoEnum(E.C)\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
+	/**
+	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
+	 */
+	public void testTypeAnnotationDependency27() throws Exception
+	{
+		String a1Code = "package p1; " + "\n"
+			+ "@AnnoClass(Object.class)\n"
+			+ "public class A {\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String a2Code = "package p1; " + "\n"
+			+ "@AnnoClass(String.class)\n"
+			+ "public class A {\n"
+			+ "\n"
+			+ "    public void foo() {\n"
+			+ "        System.out.println(\"test\");"
+			+ "    }"
+			+ "}";
+		String bCode = "package p1; " + "\n"
+			+ "public class B {" + "\n"
+			+ "  public A a;" + "\n"
+			+ "}";
+
+		env.addClass( this.srcRoot, "p1", "A", a1Code );
+		env.addClass( this.srcRoot, "p1", "B", bCode );
+		addAnnotationType();
+		
+		fullBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// edit annotation in A
+		env.addClass( this.srcRoot, "p1", "A", a2Code );
+		incrementalBuild( this.projectPath );
+		expectingNoProblems();
+		
+		// verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConstantTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConstantTest.java
index e7878be..00d8136 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConstantTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConstantTest.java
@@ -18,6 +18,18 @@ import org.eclipse.jdt.core.ToolFactory;
 import org.eclipse.jdt.core.tests.util.Util;
 import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.env.ClassSignature;
+import org.eclipse.jdt.internal.compiler.env.EnumConstantSignature;
+import org.eclipse.jdt.internal.compiler.impl.BooleanConstant;
+import org.eclipse.jdt.internal.compiler.impl.ByteConstant;
+import org.eclipse.jdt.internal.compiler.impl.CharConstant;
+import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.impl.DoubleConstant;
+import org.eclipse.jdt.internal.compiler.impl.FloatConstant;
+import org.eclipse.jdt.internal.compiler.impl.IntConstant;
+import org.eclipse.jdt.internal.compiler.impl.LongConstant;
+import org.eclipse.jdt.internal.compiler.impl.ShortConstant;
+import org.eclipse.jdt.internal.compiler.impl.StringConstant;
 
 public class ConstantTest extends AbstractRegressionTest {
 
@@ -1101,6 +1113,71 @@ public void test020() {
 		"The field notAConstant cannot be declared static; static fields can only be declared in static or top level types\n" +
 		"----------\n");
 }
+public void testAllConstants() {
+	Constant byteConstant = ByteConstant.fromValue((byte) 1);
+	Constant byteConstant2 = ByteConstant.fromValue((byte) 2);
+	Constant byteConstant3 = ByteConstant.fromValue((byte) 1);
+	Constant charConstant = CharConstant.fromValue('c');
+	Constant charConstant2 = CharConstant.fromValue('d');
+	Constant charConstant3 = CharConstant.fromValue('c');
+	Constant booleanConstant = BooleanConstant.fromValue(true);
+	Constant booleanConstant2 = BooleanConstant.fromValue(false);
+	Constant booleanConstant3 = BooleanConstant.fromValue(true);
+	Constant doubleConstant = DoubleConstant.fromValue(1.0);
+	Constant doubleConstant2 = DoubleConstant.fromValue(2.0);
+	Constant doubleConstant3 = DoubleConstant.fromValue(1.0);
+	Constant floatConstant = FloatConstant.fromValue(1.0f);
+	Constant floatConstant2 =  FloatConstant.fromValue(2.0f);
+	Constant floatConstant3 =  FloatConstant.fromValue(1.0f);
+	Constant intConstant = IntConstant.fromValue(2);
+	Constant intConstant2 = IntConstant.fromValue(3);
+	Constant intConstant3 = IntConstant.fromValue(2);
+	Constant longConstant =  LongConstant.fromValue(3L);
+	Constant longConstant2 =  LongConstant.fromValue(4L);
+	Constant longConstant3 =  LongConstant.fromValue(3L);
+	Constant shortConstant = ShortConstant.fromValue((short) 4);
+	Constant shortConstant2 = ShortConstant.fromValue((short) 3);
+	Constant shortConstant3 = ShortConstant.fromValue((short) 4);
+	Constant stringConstant = StringConstant.fromValue("test");
+	Constant stringConstant2 = StringConstant.fromValue("test2");
+	Constant stringConstant3 = StringConstant.fromValue("test");
+	Constant stringConstant4 = StringConstant.fromValue(null);
+	ClassSignature classSignature = new ClassSignature("java.lang.Object".toCharArray());
+	ClassSignature classSignature2 = new ClassSignature("java.lang.String".toCharArray());
+	ClassSignature classSignature3 = new ClassSignature("java.lang.Object".toCharArray());
+	EnumConstantSignature enumConstantSignature = new EnumConstantSignature("myEnum".toCharArray(), "C".toCharArray());
+	EnumConstantSignature enumConstantSignature2 = new EnumConstantSignature("myEnum".toCharArray(), "A".toCharArray());
+	EnumConstantSignature enumConstantSignature3 = new EnumConstantSignature("myEnum".toCharArray(), "C".toCharArray());
+	EnumConstantSignature enumConstantSignature4 = new EnumConstantSignature("myEnum2".toCharArray(), "A".toCharArray());
+
+	verifyConstantEqualsAndHashcode(byteConstant, byteConstant2, byteConstant3, intConstant);
+	verifyConstantEqualsAndHashcode(charConstant, charConstant2, charConstant3, byteConstant);
+	verifyConstantEqualsAndHashcode(booleanConstant, booleanConstant2, booleanConstant3, byteConstant);
+	verifyConstantEqualsAndHashcode(doubleConstant, doubleConstant2, doubleConstant3, byteConstant);
+	verifyConstantEqualsAndHashcode(floatConstant, floatConstant2, floatConstant3, byteConstant);
+	verifyConstantEqualsAndHashcode(intConstant, intConstant2, intConstant3, stringConstant);
+	verifyConstantEqualsAndHashcode(longConstant, longConstant2, longConstant3, byteConstant);
+	verifyConstantEqualsAndHashcode(shortConstant, shortConstant2, shortConstant3, byteConstant);
+	verifyConstantEqualsAndHashcode(stringConstant, stringConstant2, stringConstant3, byteConstant);
+	verifyConstantEqualsAndHashcode(stringConstant, stringConstant4, stringConstant3, byteConstant);
+	verifyConstantEqualsAndHashcode(classSignature, classSignature2, classSignature3, byteConstant);
+	verifyConstantEqualsAndHashcode(enumConstantSignature, enumConstantSignature2, enumConstantSignature3, byteConstant);
+	verifyConstantEqualsAndHashcode(enumConstantSignature, enumConstantSignature4, enumConstantSignature3, byteConstant);
+	assertNotNull(Constant.NotAConstant.toString());
+}
+private void verifyConstantEqualsAndHashcode(
+		Object constant,
+		Object constant2,
+		Object constant3,
+		Object constant4) {
+	assertTrue(constant.equals(constant));
+	assertTrue(constant.equals(constant3));
+	assertFalse(constant.equals(constant2));
+	assertFalse(constant.equals(constant4));
+	assertFalse(constant.equals(null));
+	assertFalse(constant.hashCode() == constant2.hashCode());
+	assertNotNull(constant.toString());
+}
 public static Class testClass() {
 	return ConstantTest.class;
 }
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 5bdf809..34b4a69 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -50,7 +50,9 @@ Eclipse SDK 3.7M1 - %date% - 3.6M1
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=317468">317468</a>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841">317841</a>
+[incremental build] unnecessary 'structural changes' due to annotation parameters
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=317468">317468</a>
 Adding elements to an enum body with trailing comma generates bad code
 <br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=316937">316937</a>
 JavaElement.getElementInfo(..) throws JavaModelException when trying to get info for an inner class in an external jar
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationInfo.java
index 109bc66..13f27ee 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/AnnotationInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2009 BEA Systems, Inc.
+ * Copyright (c) 2005, 2010 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,15 +7,19 @@
  *
  * Contributors:
  *    tyeung@bea.com - initial API and implementation
+ *    olivier_thomann@ca.ibm.com - add hashCode() and equals(..) methods
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
+import java.util.Arrays;
+
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.Annotation;
 import org.eclipse.jdt.internal.compiler.codegen.ConstantPool;
 import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.impl.*;
 import org.eclipse.jdt.internal.compiler.lookup.TagBits;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 public class AnnotationInfo extends ClassFileStruct implements IBinaryAnnotation {
 	/** The name of the annotation type */
@@ -376,4 +380,30 @@ public String toString() {
 	}
 	return buffer.toString();
 }
+public int hashCode() {
+	final int prime = 31;
+	int result = 1;
+	result = prime * result + Util.hashCode(this.pairs);
+	result = prime * result + CharOperation.hashCode(this.typename);
+	return result;
+}
+public boolean equals(Object obj) {
+	if (this == obj) {
+		return true;
+	}
+	if (obj == null) {
+		return false;
+	}
+	if (getClass() != obj.getClass()) {
+		return false;
+	}
+	AnnotationInfo other = (AnnotationInfo) obj;
+	if (!Arrays.equals(this.pairs, other.pairs)) {
+		return false;
+	}
+	if (!Arrays.equals(this.typename, other.typename)) {
+		return false;
+	}
+	return true;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
index 4e41433..d2a2b62 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -974,8 +974,27 @@ private boolean hasStructuralAnnotationChanges(IBinaryAnnotation[] currentAnnota
 		for (int j = 0; j < currentPairsLength; j++) {
 			if (!CharOperation.equals(currentPairs[j].getName(), otherPairs[j].getName()))
 				return true;
-			if (!currentPairs[j].getValue().equals(otherPairs[j].getValue()))
+			final Object value = currentPairs[j].getValue();
+			final Object value2 = otherPairs[j].getValue();
+			if (value instanceof Object[]) {
+				Object[] currentValues = (Object[]) value;
+				if (value2 instanceof Object[]) {
+					Object[] currentValues2 = (Object[]) value2;
+					final int length = currentValues.length;
+					if (length != currentValues2.length) {
+						return true;
+					}
+					for (int n = 0; n < length; n++) {
+						if (!currentValues[n].equals(currentValues2[n])) {
+							return true;
+						}
+					}
+					return false;
+				}
+				return true;
+			} else if (!value.equals(value2)) {
 				return true;
+			}
 		}
 	}
 	return false;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ElementValuePairInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ElementValuePairInfo.java
index 188051b..5a40c0d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ElementValuePairInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ElementValuePairInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2010 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,9 +7,14 @@
  *
  * Contributors:
  *    tyeung@bea.com - initial API and implementation
+ *    olivier_thomann@ca.ibm.com - add hashCode() and equals(..) methods
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
+import java.util.Arrays;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+
 public class ElementValuePairInfo implements org.eclipse.jdt.internal.compiler.env.IBinaryElementValuePair {
 
 	static final ElementValuePairInfo[] NoMembers = new ElementValuePairInfo[0];
@@ -45,4 +50,34 @@ public String toString() {
 	}
 	return buffer.toString();
 }
+public int hashCode() {
+	final int prime = 31;
+	int result = 1;
+	result = prime * result + CharOperation.hashCode(this.name);
+	result = prime * result + ((this.value == null) ? 0 : this.value.hashCode());
+	return result;
+}
+public boolean equals(Object obj) {
+	if (this == obj) {
+		return true;
+	}
+	if (obj == null) {
+		return false;
+	}
+	if (getClass() != obj.getClass()) {
+		return false;
+	}
+	ElementValuePairInfo other = (ElementValuePairInfo) obj;
+	if (!Arrays.equals(this.name, other.name)) {
+		return false;
+	}
+	if (this.value == null) {
+		if (other.value != null) {
+			return false;
+		}
+	} else if (!this.value.equals(other.value)) {
+		return false;
+	}
+	return true;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ClassSignature.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ClassSignature.java
index 6c68a09..f3e4685 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ClassSignature.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/ClassSignature.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2010 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,9 +7,14 @@
  *
  * Contributors:
  *    tyeung@bea.com - initial API and implementation
+ *    olivier_thomann@ca.ibm.com - add hashCode() and equals(..) methods
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.env;
 
+import java.util.Arrays;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+
 /**
  * Represents a class reference in the class file.
  * One of the possible results for the default value of an annotation method or an element value pair.
@@ -35,4 +40,25 @@ public String toString() {
 	buffer.append(".class"); //$NON-NLS-1$
 	return buffer.toString();
 }
+
+public int hashCode() {
+	final int prime = 31;
+	int result = 1;
+	result = prime * result + CharOperation.hashCode(this.className);
+	return result;
+}
+
+public boolean equals(Object obj) {
+	if (this == obj) {
+		return true;
+	}
+	if (obj == null) {
+		return false;
+	}
+	if (getClass() != obj.getClass()) {
+		return false;
+	}
+	ClassSignature other = (ClassSignature) obj;
+	return Arrays.equals(this.className, other.className);
+}
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/EnumConstantSignature.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/EnumConstantSignature.java
index 66a8434..437df94 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/EnumConstantSignature.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/EnumConstantSignature.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2005, 2007 BEA Systems, Inc.
+ * Copyright (c) 2005, 2010 BEA Systems, Inc.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,9 +7,13 @@
  *
  * Contributors:
  *    tyeung@bea.com - initial API and implementation
+ *    olivier_thomann@ca.ibm.com - add hashCode() and equals(..) methods
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.env;
 
+import java.util.Arrays;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
 /**
  * Represents a reference to a enum constant in the class file.
  * One of the possible results for the default value of an annotation method.
@@ -45,4 +49,29 @@ public String toString() {
 	buffer.append(this.constName);
 	return buffer.toString();
 }
+
+public int hashCode() {
+	final int prime = 31;
+	int result = 1;
+	result = prime * result + CharOperation.hashCode(this.constName);
+	result = prime * result + CharOperation.hashCode(this.typeName);
+	return result;
+}
+
+public boolean equals(Object obj) {
+	if (this == obj) {
+		return true;
+	}
+	if (obj == null) {
+		return false;
+	}
+	if (getClass() != obj.getClass()) {
+		return false;
+	}
+	EnumConstantSignature other = (EnumConstantSignature) obj;
+	if (!Arrays.equals(this.constName, other.constName)) {
+		return false;
+	}
+	return Arrays.equals(this.typeName, other.typeName);
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/BooleanConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/BooleanConstant.java
index af70d44..1945e5d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/BooleanConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/BooleanConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -17,7 +17,7 @@ public class BooleanConstant extends Constant {
 	private static final BooleanConstant TRUE = new BooleanConstant(true);
 	private static final BooleanConstant FALSE = new BooleanConstant(false);
 
-	public static BooleanConstant fromValue(boolean value) {
+	public static Constant fromValue(boolean value) {
 		return value ? BooleanConstant.TRUE : BooleanConstant.FALSE;
 	}
 
@@ -41,4 +41,25 @@ public class BooleanConstant extends Constant {
 	public int typeID() {
 		return T_boolean;
 	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + (this.value ? 1231 : 1237);
+		return result;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj == null) {
+			return false;
+		}
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+		BooleanConstant other = (BooleanConstant) obj;
+		return this.value == other.value;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
index 28de82b..632e09a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -62,4 +62,25 @@ public class ByteConstant extends Constant {
 	public int typeID() {
 		return T_byte;
 	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + this.value;
+		return result;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj == null) {
+			return false;
+		}
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+		ByteConstant other = (ByteConstant) obj;
+		return this.value == other.value;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CharConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CharConstant.java
index 538315e..3532852 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CharConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CharConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -62,4 +62,25 @@ public class CharConstant extends Constant {
 	public int typeID() {
 		return T_char;
 	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + this.value;
+		return result;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj == null) {
+			return false;
+		}
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+		CharConstant other = (CharConstant) obj;
+		return this.value == other.value;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/DoubleConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/DoubleConstant.java
index a163d81..b8f419e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/DoubleConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/DoubleConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -63,4 +63,27 @@ public class DoubleConstant extends Constant {
 	public int typeID() {
 		return T_double;
 	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		long temp;
+		temp = Double.doubleToLongBits(this.value);
+		result = prime * result + (int) (temp ^ (temp >>> 32));
+		return result;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj == null) {
+			return false;
+		}
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+		DoubleConstant other = (DoubleConstant) obj;
+		return Double.doubleToLongBits(this.value) == Double.doubleToLongBits(other.value);
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/FloatConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/FloatConstant.java
index 8a2b9c6..977e800 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/FloatConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/FloatConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -61,4 +61,25 @@ public class FloatConstant extends Constant {
 	public int typeID() {
 		return T_float;
 	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + Float.floatToIntBits(this.value);
+		return result;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj == null) {
+			return false;
+		}
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+		FloatConstant other = (FloatConstant) obj;
+		return Float.floatToIntBits(this.value) == Float.floatToIntBits(other.value);
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IntConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
index 8464934..bed2c34 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -97,4 +97,25 @@ public class IntConstant extends Constant {
 	public int typeID() {
 		return T_int;
 	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + this.value;
+		return result;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj == null) {
+			return false;
+		}
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+		IntConstant other = (IntConstant) obj;
+		return this.value == other.value;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/LongConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/LongConstant.java
index 3f83954..9bbb846 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/LongConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/LongConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -71,4 +71,25 @@ public String toString(){
 public int typeID() {
 	return T_long;
 }
+
+public int hashCode() {
+	final int prime = 31;
+	int result = 1;
+	result = prime * result + (int) (this.value ^ (this.value >>> 32));
+	return result;
+}
+
+public boolean equals(Object obj) {
+	if (this == obj) {
+		return true;
+	}
+	if (obj == null) {
+		return false;
+	}
+	if (getClass() != obj.getClass()) {
+		return false;
+	}
+	LongConstant other = (LongConstant) obj;
+	return this.value == other.value;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
index 9afba0f..bff04a8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -63,4 +63,25 @@ public class ShortConstant extends Constant {
 	public int typeID() {
 		return T_short;
 	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + this.value;
+		return result;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj == null) {
+			return false;
+		}
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+		ShortConstant other = (ShortConstant) obj;
+		return this.value == other.value;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/StringConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/StringConstant.java
index adf9158..37d493f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/StringConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/StringConstant.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2010 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -39,4 +39,29 @@ public class StringConstant extends Constant {
 	public int typeID() {
 		return T_JavaLangString;
 	}
+
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((this.value == null) ? 0 : this.value.hashCode());
+		return result;
+	}
+
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj == null) {
+			return false;
+		}
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+		StringConstant other = (StringConstant) obj;
+		if (this.value == null) {
+			return other.value == null;
+		} else {
+			return this.value.equals(other.value);
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
index 7f2dd7b..5805a0c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/util/Util.java
@@ -522,7 +522,17 @@ public class Util implements SuffixConstants {
 			}
 		}
 	}
-
+	public static int hashCode(Object[] array) {
+		int prime = 31;
+		if (array == null) {
+			return 0;
+		}
+		int result = 1;
+		for (int index = 0; index < array.length; index++) {
+			result = prime * result + (array[index] == null ? 0 : array[index].hashCode());
+		}
+		return result;
+	}
 	/**
 	 * Returns whether the given name is potentially a zip archive file name
 	 * (it has a file extension and it is not ".java" nor ".class")


commit ad7e9270b4d624e04d15413f781ffa745f2545fa
Author: Olivier Thomann <oliviert>
Date:   Tue Jul 13 18:13:31 2010 +0000

    HEAD - Additional changes for bug 317841

18	18	org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
1	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/BooleanConstant.java
1	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
1	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CharConstant.java
2	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/DoubleConstant.java
1	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/FloatConstant.java
1	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
1	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/LongConstant.java
1	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
diff --git a/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java b/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
index 9c921b2..38f0a99 100644
--- a/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
+++ b/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/AnnotationDependencyTests.java
@@ -368,7 +368,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -377,14 +377,14 @@ public class AnnotationDependencyTests extends BuilderTests {
 	public void testTypeAnnotationDependency3() throws Exception
 	{
 		String a1Code = "package p1; " + "\n"
-			+ "@AnnoInt(3)" + "\n"
+			+ "@AnnoInt(24)" + "\n"
 			+ "public class A {\n"
 			+ "    public void foo() {\n"
 			+ "        System.out.println(\"test\");"
 			+ "    }"
 			+ "}";
 		String a2Code = "package p1; " + "\n"
-			+ "@AnnoInt(3)" + "\n"
+			+ "@AnnoInt(24)" + "\n"
 			+ "public class A {\n"
 			+ "\n"
 			+ "    public void foo() {\n"
@@ -408,7 +408,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -448,7 +448,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -488,7 +488,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -528,7 +528,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -568,7 +568,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -608,7 +608,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -648,7 +648,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -688,7 +688,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -728,7 +728,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -768,7 +768,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -808,7 +808,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -848,7 +848,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
+		//  verify that B was NOT recompiled
 		expectingUniqueCompiledClasses(new String[] { "p1.A" });
 	}
 	/**
@@ -864,7 +864,7 @@ public class AnnotationDependencyTests extends BuilderTests {
 			+ "    }"
 			+ "}";
 		String a2Code = "package p1; " + "\n"
-			+ "@Anno(\"A1\")" + "\n"
+			+ "@Anno(\"A2\")" + "\n"
 			+ "public class A {\n"
 			+ "\n"
 			+ "    public void foo() {\n"
@@ -888,8 +888,8 @@ public class AnnotationDependencyTests extends BuilderTests {
 		incrementalBuild( this.projectPath );
 		expectingNoProblems();
 		
-		// verify that B was recompiled
-		expectingUniqueCompiledClasses(new String[] { "p1.A" });
+		//  verify that B was recompiled
+		expectingUniqueCompiledClasses(new String[] { "p1.A", "p1.B" });
 	}
 	/**
 	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=317841
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/BooleanConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/BooleanConstant.java
index 1945e5d..4f486df 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/BooleanConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/BooleanConstant.java
@@ -43,10 +43,7 @@ public class BooleanConstant extends Constant {
 	}
 
 	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + (this.value ? 1231 : 1237);
-		return result;
+		return this.value ? 1231 : 1237;
 	}
 
 	public boolean equals(Object obj) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
index 632e09a..f563962 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ByteConstant.java
@@ -64,10 +64,7 @@ public class ByteConstant extends Constant {
 	}
 
 	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + this.value;
-		return result;
+		return this.value;
 	}
 
 	public boolean equals(Object obj) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CharConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CharConstant.java
index 3532852..6f740d6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CharConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CharConstant.java
@@ -64,10 +64,7 @@ public class CharConstant extends Constant {
 	}
 
 	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + this.value;
-		return result;
+		return this.value;
 	}
 
 	public boolean equals(Object obj) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/DoubleConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/DoubleConstant.java
index b8f419e..ef841cb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/DoubleConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/DoubleConstant.java
@@ -65,12 +65,8 @@ public class DoubleConstant extends Constant {
 	}
 
 	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		long temp;
-		temp = Double.doubleToLongBits(this.value);
-		result = prime * result + (int) (temp ^ (temp >>> 32));
-		return result;
+		long temp = Double.doubleToLongBits(this.value);
+		return (int) (temp ^ (temp >>> 32));
 	}
 
 	public boolean equals(Object obj) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/FloatConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/FloatConstant.java
index 977e800..41ced2d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/FloatConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/FloatConstant.java
@@ -63,10 +63,7 @@ public class FloatConstant extends Constant {
 	}
 
 	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + Float.floatToIntBits(this.value);
-		return result;
+		return Float.floatToIntBits(this.value);
 	}
 
 	public boolean equals(Object obj) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IntConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
index bed2c34..01fb04a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IntConstant.java
@@ -99,10 +99,7 @@ public class IntConstant extends Constant {
 	}
 
 	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + this.value;
-		return result;
+		return this.value;
 	}
 
 	public boolean equals(Object obj) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/LongConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/LongConstant.java
index 9bbb846..99f9f8e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/LongConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/LongConstant.java
@@ -73,10 +73,7 @@ public int typeID() {
 }
 
 public int hashCode() {
-	final int prime = 31;
-	int result = 1;
-	result = prime * result + (int) (this.value ^ (this.value >>> 32));
-	return result;
+	return (int) (this.value ^ (this.value >>> 32));
 }
 
 public boolean equals(Object obj) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
index bff04a8..6f107ae 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/ShortConstant.java
@@ -65,10 +65,7 @@ public class ShortConstant extends Constant {
 	}
 
 	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + this.value;
-		return result;
+		return this.value;
 	}
 
 	public boolean equals(Object obj) {

