commit 12060a89a038be2ae8b77c65d492846c318015e3
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Fri May 26 21:57:38 2017 +0530

    Fix for bug 515875  [1.9] [dom ast] Module Binding for modules - part1

186	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/RequiresStatement.java
4	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
11	6	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
24	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingComparator.java
43	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
53	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
17	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IBinding.java
89	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IModuleBinding.java
229	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleBinding.java
14	0	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
index 53e1f60..bfd7321 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
@@ -20,6 +20,7 @@ import org.eclipse.jdt.core.dom.*;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.core.JrtPackageFragmentRoot;
+import org.eclipse.jdt.internal.core.SourceModule;
 
 import java.util.List;
 
@@ -50,7 +51,7 @@ public class ASTConverter9Test extends ConverterTestSetup {
 	static {
 //		TESTS_NUMBERS = new int[] { 19 };
 //		TESTS_RANGE = new int[] { 1, -1 };
-//		TESTS_NAMES = new String[] {"testBug512023_0001"};
+//		TESTS_NAMES = new String[] {"testBug515875_003"};
 	}
 	public static Test suite() {
 		String javaVersion = System.getProperty("java.version");
@@ -243,6 +244,7 @@ public class ASTConverter9Test extends ConverterTestSetup {
 			deleteProject("ConverterTests9");
 		}
 	}
+
 	public void testBug514417() throws CoreException {
 		if (!isJRE9) return;
 		try {
@@ -326,6 +328,189 @@ public class ASTConverter9Test extends ConverterTestSetup {
 		checkSourceRange((ASTNode) req.modifiers().get(1), "static", content);
 	}
 
+	public void testBug515875_001() throws Exception {
+		try {
+			IJavaProject project1 = createJavaProject("ConverterTests9", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String content = 
+				"module first {\n" +
+				"    requires transitive static second.third;\n" +
+				"    exports pack1.X11 to org.eclipse.jdt;\n" +
+				"}";
+			createFile("/ConverterTests9/src/module-info.java",	content);
+			createFolder("/ConverterTests9/src/pack1");
+			createFile("/ConverterTests9/src/pack1/X11.java",
+					"package pack1;\n" +
+					"public class X11 {}\n");
+			this.workingCopy = getWorkingCopy("/ConverterTests9/src/module-info.java", true);
+			ASTNode node = buildAST(content, this.workingCopy, false);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit unit = (CompilationUnit) node;
+			ModuleDeclaration moduleDecl = unit.getModule();
+			checkSourceRange(moduleDecl, content, content);
+
+			ModuleBinding moduleBinding = (ModuleBinding) moduleDecl.resolveBinding();
+			assertTrue("Module Binding null", moduleBinding != null);
+			String name = moduleBinding.getName();
+			assertTrue("Module Name null", name != null);
+			assertTrue("Wrong Module Name", name.equals("first"));
+
+			IJavaElement element = moduleBinding.getJavaElement();
+			assertNotNull("Module Java Element Null", element);
+			assertTrue(element instanceof SourceModule);
+			SourceModule sModule = (SourceModule) element;
+			assertTrue("Source module name incorrect", sModule.getElementName().equals("first"));
+
+			String key = moduleBinding.getKey();
+			assertTrue("Unique Key incorrecct", key.equals("first"));
+
+		} finally {
+			deleteProject("ConverterTests9");
+		}
+	}
+
+	public void testBug515875_002() throws Exception {
+		try {
+
+			IJavaProject project1 = createJavaProject("ConverterTests9", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent = 
+				"module first {\n" +
+				"    requires second;\n" +
+				"    provides pack22.I22 with pack1.X11;\n" +
+				"}";
+			createFile("/ConverterTests9/src/module-info.java",	fileContent);
+			createFolder("/ConverterTests9/src/pack1");
+			createFile("/ConverterTests9/src/pack1/X11.java",
+					"package pack1;\n" +
+					"public class X11 implements pack22.I22{}\n");
+
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project2.open(null);
+			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String secondFile = 
+					"module second {\n" +
+					"    exports pack22 to first;\n" +
+					"}";
+			createFile("/second/src/module-info.java",	secondFile);
+			createFolder("/second/src/pack22");
+			createFile("/second/src/pack22/I22.java",
+					"package pack22;\n" +
+					"public interface I22 {}\n");
+
+			addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+			project1.close(); // sync
+			project2.close();
+			project2.open(null);
+			project1.open(null);
+
+			ICompilationUnit sourceUnit1 = getCompilationUnit("ConverterTests9" , "src", "", "module-info.java"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+			ASTNode unit1 = runConversion(AST_INTERNAL_JLS9, sourceUnit1, true);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, unit1.getNodeType());
+			ModuleDeclaration moduleDecl1 = ((CompilationUnit) unit1).getModule();
+			checkSourceRange(moduleDecl1, fileContent, fileContent);
+
+			ModuleBinding moduleBinding = (ModuleBinding) moduleDecl1.resolveBinding();
+			assertTrue("Module Binding null", moduleBinding != null);
+			String name = moduleBinding.getName();
+			assertTrue("Module Name null", name != null);
+			assertTrue("Wrong Module Name", name.equals("first"));
+			
+			Name modName1 = moduleDecl1.getName();
+			IBinding binding = modName1.resolveBinding();
+			assertTrue("binding not a module binding", binding instanceof ModuleBinding);
+			moduleBinding = (ModuleBinding) binding;
+			assertTrue("Module Binding null", moduleBinding != null);
+			name = moduleBinding.getName();
+			assertTrue("Module Name null", name != null);
+			assertTrue("Wrong Module Name", name.equals("first"));
+
+			IModuleBinding[] reqs = moduleBinding.getRequiredModules();
+			assertTrue("Null requires", reqs != null);
+			assertTrue("incorrect number of requires modules", reqs.length == 1);
+			ModuleBinding req11 = (ModuleBinding) reqs[0];
+			assertTrue("incorrect name for requires modules", req11.getName().equals("second"));
+
+			IPackageBinding[] secPacks = req11.getExportedPackages();
+			assertTrue("Packages Exported in second module null", secPacks != null);
+			assertTrue("Incorrect number of exported packages in second module", secPacks.length == 1);
+			IPackageBinding pack22 = secPacks[0];
+			assertTrue("Incorrect Package", pack22.getName().equals("pack22"));
+
+/*			ITypeBinding[] services = moduleBinding.getServices();
+			assertTrue("services null", services != null);
+			assertTrue("Incorrect number of services", services.length == 1);
+			assertTrue("Incorrect service", services[0].getName().equals("pack22.I22"));
+
+			ITypeBinding[] implementations = moduleBinding.getImplementations();
+			assertTrue("implementations null", implementations != null);
+			assertTrue("Incorrect number of implementations", implementations.length == 1);
+			assertTrue("Incorrect implementation", implementations[0].getName().equals("pack1.X11"));
+*/		}
+		finally {
+			deleteProject("ConverterTests9");
+			deleteProject("second");
+		}
+	}
+
+	public void testBug515875_003() throws Exception {
+		try {
+
+			IJavaProject project1 = createJavaProject("ConverterTests9", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent = 
+				"module first {\n" +
+				"    requires second;\n" +
+				"    provides pack22.I22 with pack1.X11;\n" +
+				"}";
+			createFile("/ConverterTests9/src/module-info.java",	fileContent);
+			createFolder("/ConverterTests9/src/pack1");
+			createFile("/ConverterTests9/src/pack1/X11.java",
+					"package pack1;\n" +
+					"public class X11 implements pack22.I22{}\n");
+
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project2.open(null);
+			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String secondFile = 
+					"module second {\n" +
+					"    exports pack22 to first;\n" +
+					"}";
+			createFile("/second/src/module-info.java",	secondFile);
+			createFolder("/second/src/pack22");
+			createFile("/second/src/pack22/I22.java",
+					"package pack22;\n" +
+					"public interface I22 {}\n");
+
+			addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+			project1.close(); // sync
+			project2.close();
+			project2.open(null);
+			project1.open(null);
+
+			ICompilationUnit sourceUnit1 = getCompilationUnit("ConverterTests9" , "src", "", "module-info.java"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+			ASTNode unit1 = runConversion(AST_INTERNAL_JLS9, sourceUnit1, true);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, unit1.getNodeType());
+			ModuleDeclaration moduleDecl1 = ((CompilationUnit) unit1).getModule();
+			checkSourceRange(moduleDecl1, fileContent, fileContent);
+
+			RequiresStatement req = (RequiresStatement) moduleDecl1.moduleStatements().get(0);
+			Name reqModule = req.getName();
+			ModuleBinding moduleBinding = (ModuleBinding) reqModule.resolveBinding();
+			assertTrue("Module Binding null", moduleBinding != null);
+			String name = moduleBinding.getName();
+			assertTrue("Module Name null", name != null);
+			assertTrue("Wrong Module Name", name.equals("second"));
+		}
+		finally {
+			deleteProject("ConverterTests9");
+			deleteProject("second");
+		}
+	}
+
 
 // Add new tests here 
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
index 2c53baa..7ec6aea 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleReference.java
@@ -23,7 +23,7 @@ public class ModuleReference extends ASTNode {
 	public char[][] tokens;
 	public long[] sourcePositions; //each entry is using the code : (start<<32) + end
 	public char[] moduleName;
-	ModuleBinding binding = null;
+	public ModuleBinding binding = null;
 
 	public ModuleReference(char[][] tokens, long[] sourcePositions) {
 		this.tokens = tokens;
@@ -32,7 +32,7 @@ public class ModuleReference extends ASTNode {
 		this.sourceStart = (int) (sourcePositions[0] >>> 32);
 		this.moduleName = CharOperation.concatWith(tokens, '.');
 	}
-	
+
 	@Override
 	public StringBuffer print(int indent, StringBuffer output) {
 		for (int i = 0; i < this.tokens.length; i++) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/RequiresStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/RequiresStatement.java
index 593a867..c56c131 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/RequiresStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/RequiresStatement.java
@@ -37,6 +37,7 @@ public class RequiresStatement extends ModuleStatement {
 	}
 	@Override
 	public StringBuffer print(int indent, StringBuffer output) {
+		output.append("requires "); //$NON-NLS-1$
 		if (isTransitive())
 			output.append("transitive "); //$NON-NLS-1$
 		if (isStatic())
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
index 81f2ce3..b40c382 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
@@ -112,14 +112,16 @@ public abstract class Binding {
 	public abstract int kind();
 	/*
 	 * Computes a key that uniquely identifies this binding.
-	 * Returns null if binding is not a TypeBinding, a MethodBinding, a FieldBinding, a LocalVariableBinding or a PackageBinding (i.e. an ImportBinding).
+	 * Returns null if binding is not a TypeBinding, a MethodBinding, a FieldBinding, a LocalVariableBinding, a PackageBinding (i.e. an ImportBinding)
+	 * or a ModuleBinding.
 	 */
 	public char[] computeUniqueKey() {
 		return computeUniqueKey(true/*leaf*/);
 	}
 	/*
 	 * Computes a key that uniquely identifies this binding. Optionally include access flags.
-	 * Returns null if binding is not a TypeBinding, a MethodBinding, a FieldBinding, a LocalVariableBinding or a PackageBinding (i.e. an ImportBinding)
+	 * Returns null if binding is not a TypeBinding, a MethodBinding, a FieldBinding, a LocalVariableBinding, a PackageBinding (i.e. an ImportBinding)
+	 * or a ModuleBinding.
 	 */
 	public char[] computeUniqueKey(boolean isLeaf) {
 		return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
index ec463c3..b23f6c8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ModuleBinding.java
@@ -350,6 +350,10 @@ public class ModuleBinding extends Binding {
 				dep -> dep.isPackageExportedTo(pkg, ModuleBinding.this)
 		);
 	}
+	@Override
+	public char[] computeUniqueKey(boolean isLeaf) {
+		return this.moduleName; // for now just return the module name - tied to Signature if any.
+	}
 	public boolean dependsOn(ModuleBinding other) {
  		if (other == this)
  			return true;
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index b136bb5..7903a03 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -1714,12 +1714,17 @@ class ASTConverter {
 		if (pvsStmt.targets != null && pvsStmt.targets.length > 0) {
 			List<Name> modules = stmt.modules();
 			for (ModuleReference moduleRef : pvsStmt.getTargetedModules()) {
-				modules.add(getName(moduleRef, CharOperation.splitOn('.', moduleRef.moduleName), moduleRef.sourcePositions));
+				Name target = getName(moduleRef, CharOperation.splitOn('.', moduleRef.moduleName), moduleRef.sourcePositions);
+				modules.add(target);
 				if (tmp < moduleRef.sourceEnd) tmp = moduleRef.sourceEnd;
+				if (this.resolveBindings) {
+					this.recordNodes(target, moduleRef);
+				}
+
 			}
 		}
 		if (tmp > sourceEnd) sourceEnd = tmp;
-		stmt.setSourceRange(pvsStmt.declarationSourceStart, sourceEnd - pvsStmt.declarationSourceStart + 1);			
+		stmt.setSourceRange(pvsStmt.declarationSourceStart, sourceEnd - pvsStmt.declarationSourceStart + 1);
 		return stmt;
 	}
 
@@ -3309,9 +3314,6 @@ class ASTConverter {
 		moduleDecl.setName(moduleName);
 		moduleDecl.setSourceRange(moduleDeclaration.declarationSourceStart, moduleDeclaration.declarationSourceEnd - moduleDeclaration.declarationSourceStart + 1);
 
-		if (this.resolveBindings) {
-			this.recordNodes(moduleDecl, moduleDeclaration);
-		}
 		List<ModuleStatement> stmts = moduleDecl.moduleStatements();
 		TreeSet<ModuleStatement> tSet = new TreeSet<> (new Comparator() {
 			public int compare(Object o1, Object o2) {
@@ -3332,6 +3334,9 @@ class ASTConverter {
 			RequiresStatement stmt = new RequiresStatement(this.ast);
 			Name name = getName(moduleRef, CharOperation.splitOn('.', moduleRef.moduleName), moduleRef.sourcePositions);
 			stmt.setName(name);
+			if (this.resolveBindings) {
+				recordNodes(name, moduleRef);
+			}
 
 			setModuleModifiers(req, stmt);
 			stmt.setSourceRange(req.declarationSourceStart, req.declarationEnd - req.declarationSourceStart + 1);
@@ -3353,7 +3358,7 @@ class ASTConverter {
 			for (TypeReference impl : impls) {
 				stmt.implementations().add(convertType(impl));
 			}
-			stmt.setSourceRange(pStmt.declarationSourceStart, pStmt.declarationSourceEnd - pStmt.declarationSourceStart + 1);			
+			stmt.setSourceRange(pStmt.declarationSourceStart, pStmt.declarationSourceEnd - pStmt.declarationSourceStart + 1);
 			tSet.add(stmt);
 		}
 		// The javadoc comment is now got from 	list store in compilation unit declaration
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingComparator.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingComparator.java
index d450161..317f99f 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingComparator.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingComparator.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2004, 2013 IBM Corporation and others.
+ * Copyright (c) 2004, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -101,6 +105,13 @@ class BindingComparator {
 			return importBinding.isStatic() == importBinding2.isStatic()
 				&& importBinding.onDemand == importBinding2.onDemand
 				&& CharOperation.equals(importBinding.compoundName, importBinding2.compoundName);
+		} else if (declaringElement instanceof org.eclipse.jdt.internal.compiler.lookup.ModuleBinding) {
+			if (!(declaringElement2 instanceof org.eclipse.jdt.internal.compiler.lookup.ModuleBinding)) {
+				return false;
+			}
+			org.eclipse.jdt.internal.compiler.lookup.ModuleBinding moduleBinding = (org.eclipse.jdt.internal.compiler.lookup.ModuleBinding) declaringElement;
+			org.eclipse.jdt.internal.compiler.lookup.ModuleBinding moduleBinding2 = (org.eclipse.jdt.internal.compiler.lookup.ModuleBinding) declaringElement2;
+			return isEqual(moduleBinding, moduleBinding2);
 		}
 		return false;
 	}
@@ -125,6 +136,18 @@ class BindingComparator {
 				&& isEqual(methodBinding.parameters, methodBinding2.parameters, visitedTypes);
 	}
 
+	/*
+	 * Assumption here is that there is only one module with the same name.
+	 */
+	static boolean isEqual(org.eclipse.jdt.internal.compiler.lookup.ModuleBinding moduleBinding,
+			org.eclipse.jdt.internal.compiler.lookup.ModuleBinding moduleBinding2) {
+		if (moduleBinding == null)
+			return moduleBinding2 == null;
+		if (moduleBinding2 == null)
+			return false;
+		return CharOperation.equals(moduleBinding.moduleName, moduleBinding2.moduleName); 
+	}
+
 	static boolean isEqual(VariableBinding variableBinding, VariableBinding variableBinding2) {
 		return (variableBinding.modifiers & ExtraCompilerModifiers.AccJustFlag) == (variableBinding2.modifiers & ExtraCompilerModifiers.AccJustFlag)
 				&& CharOperation.equals(variableBinding.name, variableBinding2.name)
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
index 2776bb3..76397dd 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/BindingResolver.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -154,6 +158,21 @@ class BindingResolver {
 	}
 
 	/**
+	 * Returns the new module binding corresponding to the given old module binding.
+	 * <p>
+	 * The default implementation of this method returns <code>null</code>.
+	 * Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param moduleBinding the old module binding
+	 * @return the new module binding
+	 *
+	 */
+	IModuleBinding getModuleBinding(org.eclipse.jdt.internal.compiler.lookup.ModuleBinding moduleBinding) {
+		return null;
+	}
+
+	/**
 	 * Returns the new package binding corresponding to the given old package binding.
 	 * <p>
 	 * The default implementation of this method returns <code>null</code>.
@@ -662,6 +681,29 @@ class BindingResolver {
 	}
 
 	/**
+	 * Resolves the given module declaration and returns the binding for it.
+	 * <p>
+	 * The implementation of <code>ModuleDeclaration.resolveBinding</code>
+	 * forwards to this method. How the method resolves is often a function of
+	 * the context in which the method declaration node is embedded as well as
+	 * the method declaration subtree itself.
+	 * </p>
+	 * <p>
+	 * The default implementation of this method returns <code>null</code>.
+	 * Subclasses may reimplement.
+	 * </p>
+	 *
+	 * @param module declaration of interest
+	 * @return the binding for the given module declaration, or
+	 *    <code>null</code> if no binding is available
+	 *    
+	 * @since 3.13 BETA_JAVA9
+	 */
+	IModuleBinding resolveModule(ModuleDeclaration module) {
+		return null;
+	}
+
+	/**
 	 * Resolves the given name and returns the type binding for it.
 	 * <p>
 	 * The implementation of <code>Name.resolveBinding</code> forwards to
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
index 3794765..d940584 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java
@@ -43,6 +43,7 @@ import org.eclipse.jdt.internal.compiler.ast.Literal;
 import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
+import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
 import org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference;
@@ -233,6 +234,8 @@ class DefaultBindingResolver extends BindingResolver {
 				return new TypeBinding(this, (org.eclipse.jdt.internal.compiler.lookup.TypeBinding) binding);
 			case Binding.METHOD:
 				return getMethodBinding((org.eclipse.jdt.internal.compiler.lookup.MethodBinding) binding);
+			case Binding.MODULE:
+				return getModuleBinding((org.eclipse.jdt.internal.compiler.lookup.ModuleBinding) binding);
 			case Binding.FIELD:
 			case Binding.LOCAL:
 				return getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) binding);
@@ -300,6 +303,20 @@ class DefaultBindingResolver extends BindingResolver {
 		return binding;
 	}
 
+	/**
+	 * @see org.eclipse.jdt.core.dom.BindingResolver#getModuleBinding(org.eclipse.jdt.internal.compiler.lookup.ModuleBinding)
+	 */
+	synchronized IModuleBinding getModuleBinding(org.eclipse.jdt.internal.compiler.lookup.ModuleBinding moduleBinding) {
+		if (moduleBinding != null) {
+			IModuleBinding binding = (IModuleBinding) this.bindingTables.compilerBindingsToASTBindings.get(moduleBinding);
+			if (binding == null) {
+				binding = new ModuleBinding(this, moduleBinding);
+				this.bindingTables.compilerBindingsToASTBindings.put(moduleBinding, binding);
+			}
+			return binding;
+		}
+		return null;
+	}
 	/*
 	 * Method declared on BindingResolver.
 	 */
@@ -1432,6 +1449,18 @@ class DefaultBindingResolver extends BindingResolver {
 			if (methodBinding != null) {
 				return methodBinding;
 			}
+		} else if (node instanceof ModuleReference) {
+			ModuleReference moduleReference = (ModuleReference) node;
+			IModuleBinding moduleBinding = getModuleBinding(moduleReference.binding);
+			if (moduleBinding != null) {
+				return moduleBinding;
+			}
+		} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration) {
+			org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration moduleDeclaration = (org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration) node;
+			IModuleBinding moduleBinding = getModuleBinding(moduleDeclaration.moduleBinding);
+			if (moduleBinding != null) {
+				return moduleBinding;
+			}
 		} else if (node instanceof org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) {
 			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration typeDeclaration = (org.eclipse.jdt.internal.compiler.ast.TypeDeclaration) node;
 			ITypeBinding typeBinding = this.getTypeBinding(typeDeclaration.binding);
@@ -1596,6 +1625,30 @@ class DefaultBindingResolver extends BindingResolver {
 		return null;
 	}
 
+	/**
+	 * @see BindingResolver#resolveModule(ModuleDeclaration)
+	 * @since 3.13 BETA_JAVA9	
+	 */
+	@Override
+	IModuleBinding resolveModule(ModuleDeclaration module) {
+		Object oldNode = this.newAstToOldAst.get(module);
+		if (oldNode instanceof org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration) {
+			org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration moduleDeclaration = (org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration) oldNode;
+			IModuleBinding moduleBinding = getModuleBinding(moduleDeclaration.moduleBinding);
+			if (moduleBinding == null) {
+				return null;
+			}
+			this.bindingsToAstNodes.put(moduleBinding, module);
+			String key = moduleBinding.getKey();
+			if (key != null) {
+				this.bindingTables.bindingKeysToBindings.put(key, moduleBinding);
+			}
+			return moduleBinding;
+		}
+
+		return null;
+	}
+
 	/* (non-Javadoc)
 	 * @see BindingResolver#resolveReference(MethodRef)
      * @since 3.0
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IBinding.java
index 72927a0..d85b61f 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IBinding.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2014 IBM Corporation and others.
+ * Copyright (c) 2000, 2017 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -89,6 +93,16 @@ public interface IBinding {
 	public static final int MEMBER_VALUE_PAIR = 6;
 
 	/**
+	 * Kind constant (value 7) indicating a module binding.
+	 * Bindings of this kind can be safely cast to <code>IModuleBinding</code>.
+	 *
+	 * @see #getKind()
+	 * @see IModuleBinding
+	 * @since 3.13 BETA_JAVA9
+	 */
+	public static final int MODULE = 7;
+
+	/**
 	 * Returns the resolved declaration annotations associated with this binding.
 	 * <ul>
 	 * <li>Package bindings - these are annotations on a package declaration.
@@ -123,7 +137,8 @@ public interface IBinding {
 	 * 	<code>VARIABLE</code>,
 	 * 	<code>METHOD</code>,
 	 * 	<code>ANNOTATION</code>,
-	 * or <code>MEMBER_VALUE_PAIR</code>.
+	 *  <code>MEMBER_VALUE_PAIR</code>, or
+	 * <code>MODULE</code>.
 	 * <p>
 	 * Note that additional kinds might be added in the
 	 * future, so clients should not assume this list is exhaustive and
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IModuleBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IModuleBinding.java
new file mode 100644
index 0000000..7f16727
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IModuleBinding.java
@@ -0,0 +1,89 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *
+ *******************************************************************************/
+
+package org.eclipse.jdt.core.dom;
+
+
+/**
+ * A module binding represents a module.
+ *
+ * @since 3.13 BETA_JAVA9
+ * @noimplement This interface is not intended to be implemented by clients.
+ */
+public interface IModuleBinding extends IBinding {
+
+	@Override
+	public default int getKind() {
+		return IBinding.MODULE;
+	}
+
+	/**
+	 * answers whether the module is open or not
+	 * @return <code>true</code> if open, <code>false</code> otherwise
+	 */
+	public abstract boolean isOpen();
+
+	/**
+	 * All the required modules, transitive and otherwise
+	 * @return required modules
+	 */
+	public abstract IModuleBinding[] getRequiredModules();
+
+	/**
+	 *
+	 * @return array of exported package bindings
+	 */
+	public abstract IPackageBinding[] getExportedPackages();
+
+	/**
+	 * if targeted, returns the array of targeted modules, else returns an empty array.
+	 * @param packageBinding
+	 * @return array of targeted modules
+	 */
+	public abstract IModuleBinding[] getExportedTo(IPackageBinding packageBinding);
+
+	/**
+	 *
+	 * @return array of open package bindings
+	 */
+	public abstract IPackageBinding[] getOpenPackages();
+
+	/**
+	 * if targeted open, returns the array of targeted module bindings else empty array.
+	 *
+	 * @param packageBinding
+	 * @return array of targeted module bindings
+	 */
+	public abstract IModuleBinding[] getOpenedTo(IPackageBinding packageBinding);
+
+	/**
+	 *
+	 * @return array of uses type bindings
+	 */
+	public abstract ITypeBinding[] getUses();
+
+	/**
+	 *
+	 * @return array of service interfaces
+	 */
+	public abstract ITypeBinding[] getServices();
+
+	/**
+	 *
+	 * @return array of implementations
+	 */
+	public abstract ITypeBinding[] getImplementations();
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleBinding.java
new file mode 100644
index 0000000..247cde8
--- /dev/null
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleBinding.java
@@ -0,0 +1,229 @@
+package org.eclipse.jdt.core.dom;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.env.IModule.IPackageExport;
+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
+import org.eclipse.jdt.internal.compiler.util.Util;
+import org.eclipse.jdt.internal.core.NameLookup;
+import org.eclipse.jdt.internal.core.NameLookup.Answer;
+import org.eclipse.jdt.internal.core.SearchableEnvironment;
+
+/**
+ * @since 3.13 BETA_JAVA9
+ */
+public class ModuleBinding implements IModuleBinding {
+
+	protected static final ITypeBinding[] NO_TYPE_BINDINGS = new ITypeBinding[0];
+	private String name = null;
+	private volatile String key;
+	private boolean isOpen = false;
+
+	private org.eclipse.jdt.internal.compiler.lookup.ModuleBinding binding;
+	protected BindingResolver resolver;
+
+	private IAnnotationBinding[] annotations;
+	private IModuleBinding[] requiredModules;
+	private IPackageBinding[] exportedPackages;
+	private IModuleBinding[] exportTargets;
+	private IPackageBinding[] openPackages;
+	private IModuleBinding[] openTargets;
+
+	ModuleBinding(BindingResolver resolver, org.eclipse.jdt.internal.compiler.lookup.ModuleBinding binding) {
+		this.resolver = resolver;
+		this.binding = binding;
+		// this.open = binding.isOpen; // TODO
+	}
+
+	@Override
+	public IAnnotationBinding[] getAnnotations() {
+		if (this.annotations == null) {
+			this.annotations = resolveAnnotationBindings(this.binding.getAnnotations());
+		}
+		return this.annotations;
+	}
+
+	private IAnnotationBinding[] resolveAnnotationBindings(org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding[] internalAnnotations) {
+		int length = internalAnnotations == null ? 0 : internalAnnotations.length;
+		if (length != 0) {
+			IAnnotationBinding[] tempAnnotations = new IAnnotationBinding[length];
+			int convertedAnnotationCount = 0;
+			for (int i = 0; i < length; i++) {
+				org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding internalAnnotation = internalAnnotations[i];
+				if (internalAnnotation == null)
+					break;
+				IAnnotationBinding annotationInstance = this.resolver.getAnnotationInstance(internalAnnotation);
+				if (annotationInstance == null)
+					continue;
+				tempAnnotations[convertedAnnotationCount++] = annotationInstance;
+			}
+			if (convertedAnnotationCount != length) {
+				if (convertedAnnotationCount == 0) {
+					return this.annotations = AnnotationBinding.NoAnnotations;
+				}
+				System.arraycopy(tempAnnotations, 0, (tempAnnotations = new IAnnotationBinding[convertedAnnotationCount]), 0, convertedAnnotationCount);
+			}
+			return tempAnnotations;
+		}
+		return AnnotationBinding.NoAnnotations;
+	}
+
+	@Override
+	public String getName() {
+		if (this.name == null) {
+			char[] tmp = this.binding.moduleName;	
+			return tmp != null && tmp.length != 0 ? new String(tmp) : Util.EMPTY_STRING;
+		}
+		return this.name;
+	}
+
+	@Override
+	public int getModifiers() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	public boolean isDeprecated() {
+		return false;
+	}
+
+	@Override
+	public boolean isRecovered() {
+		return false;
+	}
+
+	@Override
+	public boolean isSynthetic() {
+		// TODO Auto-generated method stub
+		// TODO BETA_JAVA9 no reference seen in jvms draft - only in sotm
+		// check on version change and after compiler ast implements isSynthetic return this.binding.isSynthetic();
+		
+		return false;
+	}
+
+	@Override
+	public IJavaElement getJavaElement() {
+		INameEnvironment nameEnvironment = this.binding.environment.nameEnvironment;
+		if (!(nameEnvironment instanceof SearchableEnvironment)) return null;
+		NameLookup nameLookup = ((SearchableEnvironment) nameEnvironment).nameLookup;
+		if (nameLookup == null) return null;
+		Answer answer = nameLookup.findModule(this.getName());
+		if (answer == null) return null;
+		return answer.module;
+	}
+
+	@Override
+	public String getKey() {
+		if (this.key == null) {
+			char[] k = this.binding.computeUniqueKey();
+			this.key = k == null || k == CharOperation.NO_CHAR ? Util.EMPTY_STRING : new String(k);
+		}
+		return this.key;
+	}
+
+	@Override
+	public boolean isEqualTo(IBinding other) {
+		if (other == this) // identical binding - equal (key or no key)
+			return true;
+		if (other == null) // other binding missing
+			return false;
+
+		if (!(other instanceof ModuleBinding))
+			return false;
+
+		org.eclipse.jdt.internal.compiler.lookup.ModuleBinding otherBinding = ((ModuleBinding) other).binding;
+		return BindingComparator.isEqual(this.binding, otherBinding);
+	}
+
+	@Override
+	public boolean isOpen() {
+		return this.isOpen; // TODO: info needs to be derived from compiler ast - bug 517269 awaited.
+	}
+	@Override
+	public IModuleBinding[] getRequiredModules() {
+		if (this.requiredModules != null)
+			return this.requiredModules;
+
+		org.eclipse.jdt.internal.compiler.lookup.ModuleBinding[] reqs = this.binding.getAllRequiredModules();	
+		IModuleBinding[] result = new IModuleBinding[reqs != null ? reqs.length : 0];
+		for (int i = 0, l = result.length; i < l; ++i) {
+			org.eclipse.jdt.internal.compiler.lookup.ModuleBinding req = reqs[i];
+			result[i] = req != null ? this.resolver.getModuleBinding(req) : null;
+		}
+		return this.requiredModules = result;
+	}
+
+	private void getPacks(IPackageExport[] packs, List<IPackageBinding> packBindings, List<IModuleBinding> targets) {
+		for (IPackageExport pack : packs) {
+			org.eclipse.jdt.internal.compiler.lookup.PackageBinding packB = this.binding.getExportedPackage(pack.name());
+			if (packB == null) continue;
+			IPackageBinding p = this.resolver.getPackageBinding(packB);	
+			if (p != null)
+				packBindings.add(p);
+			//TODO: How do we resolve target modules? From the entire Java Model Scope? Wait for the new lookup environment.
+		}
+	}
+
+	@Override
+	public IPackageBinding[] getExportedPackages() {
+		if (this.exportedPackages != null) 
+			return this.exportedPackages;
+	
+		List<IPackageBinding> packs = new ArrayList<>();
+		getPacks(this.binding.exports, packs, null);
+		return this.exportedPackages = packs.toArray(new IPackageBinding[0]);
+	}
+
+	@Override
+	public IModuleBinding[] getExportedTo(IPackageBinding packageBinding) {
+		getExportedPackages();
+		return this.exportTargets;// TODO Auto-generated method stub
+	}
+
+	@Override
+	public IPackageBinding[] getOpenPackages() {
+		if (this.openPackages != null) 
+			return this.openPackages;
+	
+		List<IPackageBinding> packs = new ArrayList<>();
+		getPacks(this.binding.exports, packs, null);
+		return this.openPackages = packs.toArray(new IPackageBinding[0]);
+	}
+
+	@Override
+	public IModuleBinding[] getOpenedTo(IPackageBinding packageBinding) {
+		getOpenPackages();
+		return this.openTargets;// TODO Auto-generated method stub
+	}
+
+	/*
+	 * helper method
+	 */
+	private ITypeBinding[] getTypes(org.eclipse.jdt.internal.compiler.lookup.TypeBinding[] types) {
+		int length = types == null ? 0 : types.length;
+		TypeBinding[] result = new TypeBinding[length];
+		for (int i = 0; i < length; ++i) {
+			result[i] = (TypeBinding) this.resolver.getTypeBinding(types[i]);
+		}
+		return result;
+	}
+
+	@Override
+	public ITypeBinding[] getUses() {
+		return getTypes(this.binding.uses);
+	}
+
+	@Override
+	public ITypeBinding[] getServices() {
+		return getTypes(this.binding.services);
+	}
+
+	@Override
+	public ITypeBinding[] getImplementations() {
+		return getTypes(this.binding.implementations);
+	}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
index 80c3cf6..20f26c9 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleDeclaration.java
@@ -339,6 +339,20 @@ public class ModuleDeclaration extends ASTNode {
 		return this.moduleStatements;
 	}
 
+	/**
+	 * Resolves and returns the binding for the module
+	 * <p>
+	 * Note that bindings are generally unavailable unless requested when the
+	 * AST is being built.
+	 * </p>
+	 *
+	 * @return the binding, or <code>null</code> if the binding cannot be
+	 *    resolved
+	 */
+	public IModuleBinding resolveBinding() {
+		return this.ast.getBindingResolver().resolveModule(this);
+	}
+
 	@Override
 	int memSize() {
 		return BASE_NODE_SIZE + 5 * 4;
commit fa1b87c9a0cd7945f08b18dcaf16d78510595c89
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Mon Jun 5 14:28:19 2017 +0530

    isOpen part of bug 515875  [1.9] [dom ast] Module Binding for modules

65	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
8	1	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleBinding.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
index bfd7321..30b609f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter9Test.java
@@ -51,7 +51,7 @@ public class ASTConverter9Test extends ConverterTestSetup {
 	static {
 //		TESTS_NUMBERS = new int[] { 19 };
 //		TESTS_RANGE = new int[] { 1, -1 };
-//		TESTS_NAMES = new String[] {"testBug515875_003"};
+//		TESTS_NAMES = new String[] {"testBug515875_004"};
 	}
 	public static Test suite() {
 		String javaVersion = System.getProperty("java.version");
@@ -379,6 +379,7 @@ public class ASTConverter9Test extends ConverterTestSetup {
 			String fileContent = 
 				"module first {\n" +
 				"    requires second;\n" +
+				"	 uses pack22.I22;\n" + 
 				"    provides pack22.I22 with pack1.X11;\n" +
 				"}";
 			createFile("/ConverterTests9/src/module-info.java",	fileContent);
@@ -511,6 +512,69 @@ public class ASTConverter9Test extends ConverterTestSetup {
 		}
 	}
 
+	public void testBug515875_004() throws Exception {
+		try {
+
+			IJavaProject project1 = createJavaProject("ConverterTests9", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project1.open(null);
+			addClasspathEntry(project1, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String fileContent = 
+				"open module first {\n" +
+				"    requires second;\n" +
+				"    provides pack22.I22 with pack1.X11;\n" +
+				"}";
+			createFile("/ConverterTests9/src/module-info.java",	fileContent);
+			createFolder("/ConverterTests9/src/pack1");
+			createFile("/ConverterTests9/src/pack1/X11.java",
+					"package pack1;\n" +
+					"public class X11 implements pack22.I22{}\n");
+
+			IJavaProject project2 = createJavaProject("second", new String[] {"src"}, new String[] {"JCL18_LIB"}, "bin", "9");
+			project2.open(null);
+			addClasspathEntry(project2, JavaCore.newContainerEntry(new Path("org.eclipse.jdt.MODULE_PATH")));
+			String secondFile = 
+					"open module second {\n" +
+					"    exports pack22 to first;\n" +
+					"}";
+			createFile("/second/src/module-info.java",	secondFile);
+			createFolder("/second/src/pack22");
+			createFile("/second/src/pack22/I22.java",
+					"package pack22;\n" +
+					"public interface I22 {}\n");
+
+			addClasspathEntry(project1, JavaCore.newProjectEntry(project2.getPath()));
+			project1.close(); // sync
+			project2.close();
+			project2.open(null);
+			project1.open(null);
+
+			ICompilationUnit sourceUnit1 = getCompilationUnit("ConverterTests9" , "src", "", "module-info.java"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+			ASTNode unit1 = runConversion(AST_INTERNAL_JLS9, sourceUnit1, true);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, unit1.getNodeType());
+			ModuleDeclaration moduleDecl1 = ((CompilationUnit) unit1).getModule();
+			checkSourceRange(moduleDecl1, fileContent, fileContent);
+			
+			Name name = moduleDecl1.getName();
+			ModuleBinding moduleBinding = (ModuleBinding) name.resolveBinding();
+			assertTrue("Module Binding null", moduleBinding != null);
+			assertTrue("Module not open", moduleBinding.isOpen());
+
+			RequiresStatement req = (RequiresStatement) moduleDecl1.moduleStatements().get(0);
+			name = req.getName();
+			moduleBinding = (ModuleBinding) name.resolveBinding();
+			assertTrue("Module Binding null", moduleBinding != null);
+			String moduleName = moduleBinding.getName();
+			assertTrue("Module Name null", moduleName != null);
+			assertTrue("Wrong Module Name", moduleName.equals("second"));
+			assertTrue("Module not open", moduleBinding.isOpen());
+		}
+		finally {
+			deleteProject("ConverterTests9");
+			deleteProject("second");
+		}
+	}
+
+
 
 // Add new tests here 
 }
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleBinding.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleBinding.java
index 247cde8..ad3ad4c 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleBinding.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ModuleBinding.java
@@ -35,7 +35,7 @@ public class ModuleBinding implements IModuleBinding {
 	ModuleBinding(BindingResolver resolver, org.eclipse.jdt.internal.compiler.lookup.ModuleBinding binding) {
 		this.resolver = resolver;
 		this.binding = binding;
-		// this.open = binding.isOpen; // TODO
+		this.isOpen = binding.isOpen; // TODO
 	}
 
 	@Override
@@ -226,4 +226,11 @@ public class ModuleBinding implements IModuleBinding {
 	public ITypeBinding[] getImplementations() {
 		return getTypes(this.binding.implementations);
 	}
+	/**
+	 * For debugging purpose only.
+	 * @see java.lang.Object#toString()
+	 */
+	public String toString() {
+		return this.binding.toString();
+	}
 }
\ No newline at end of file
commit 37ac8d15b271167aefddfdd98cbc1fbe3f2571ef
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Thu Jun 15 18:54:16 2017 +0530

    code cleanup plus fix for test failures of bug 515875 commit

0	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
2	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/RequiresStatement.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
index c474942..ef8680e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ModuleDeclaration.java
@@ -166,9 +166,7 @@ public class ModuleDeclaration extends ASTNode {
 			for(int i = 0; i < this.requiresCount; i++) {
 				output.append('\n');
 				printIndent(indent + 1, output);
-				output.append("requires "); //$NON-NLS-1$
 				this.requires[i].print(0, output);
-				output.append(";"); //$NON-NLS-1$
 			}
 		}
 		if (this.exports != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/RequiresStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/RequiresStatement.java
index c56c131..0aa7acf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/RequiresStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/RequiresStatement.java
@@ -43,7 +43,8 @@ public class RequiresStatement extends ModuleStatement {
 		if (isStatic())
 			output.append("static "); //$NON-NLS-1$
 		this.module.print(indent, output);
-		return output;
+		output.append(";"); //$NON-NLS-1$
+	return output;
 	}
 	public ModuleBinding resolve(Scope scope) {
 		if (this.resolvedBinding != null)
