commit 89e8879d5dd978e5f2535f9d8b7bac080dd4f73b
Author: Manoj Palat <manpalat@in.ibm.com>
Date:   Mon Feb 24 09:57:19 2014 +0530

    Fixed Bug 400905 - [1.8][search] Search engine skips functional
    interface types.

839	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
6	1	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchDocument.java
48	1	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchParticipant.java
27	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchParticipant.java
8	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
24	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
162	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
13	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java
82	0	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
14	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MemberDeclarationVisitor.java
47	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
index 34786e3..7533dc3 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
@@ -24,6 +24,8 @@ import org.eclipse.core.runtime.CoreException;
 import org.eclipse.jdt.core.ICompilationUnit;
 import org.eclipse.jdt.core.IJavaElement;
 import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IMethod;
+import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.WorkingCopyOwner;
 import org.eclipse.jdt.core.search.IJavaSearchScope;
@@ -99,6 +101,28 @@ public static Test suite() {
 	suite.addTest(new JavaSearchBugs8Tests("testBug424119_003"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug427537a"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug427677"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0001"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0002"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0003"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0004"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0005"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0006"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0007"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0008"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0009"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0010"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0011"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0012"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0013"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0014"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0015"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0001"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0002"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0003"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0004"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0005"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0006"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0007"));
 	return suite;
 }
 class TestCollector extends JavaSearchResultCollector {
@@ -1778,5 +1802,820 @@ public void testBug427677() throws CoreException {
 			null);
 	assertSearchResults("src/b427677/X.java b427677.X [Marker1] EXACT_MATCH");
 }
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - super:: form, without type arguments
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0001() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+			"    void foo(int x);\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"    public static void main(String [] args) {\n" +
+			"	new X().doit();\n" +
+			"    }\n" +
+			"    void doit() {\n" +
+			"        I i = super::foo;\n" +
+			"        i.foo(10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y {\n" +
+			"    public void foo(int x) {\n" +
+			"	System.out.println(x);\n" +
+			"    }\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.doit() [super::foo] EXACT_MATCH"
+	);	
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - super:: form, with type arguments
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0002() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+			"    void foo(int x);\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"    public static void main(String [] args) {\n" +
+			"	new X().doit();\n" +
+			"    }\n" +
+			"    void doit() {\n" +
+			"        I i = super::<String>foo;\n" +
+			"        i.foo(10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y {\n" +
+			"    public void foo(int x) {\n" +
+			"	System.out.println(x);\n" +
+			"    }\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.doit() [super::<String>foo] EXACT_MATCH"
+	);	
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - SimpleName:: form, without type arguments.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0003() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+			"	public void doit();\n" +
+			"}\n" +
+			"class Y {\n" + 
+			"	Y() {}\n" +
+			"	Y(int i) {}\n" +
+			"}\n" +
+			"\n" +
+			"public class X {\n" +
+			"    X(int i) {} \n" +
+			"   static void foo() {}\n" +
+			"   static void foo(int i) {}\n" +
+			"	I i = X :: foo;\n" +
+			"	I j = Y :: new;\n" +
+			"   public static void main() { \n" +
+			"     Y y = new Y(); \n" +
+			"     foo(); \n" +
+			"   }\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("X");
+	IMethod method = type.getMethod("foo", null);
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java b400904.X.i [X :: foo] EXACT_MATCH\n" + 
+			"src/b400904/X.java void b400904.X.main() [foo()] EXACT_MATCH"
+	);	
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - SimpleName:: form, with type arguments.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0004() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+			"    void foo(int x);\n" +
+			"}\n" +
+			"public class X  {\n" +
+			"    public static void main(String [] args) {\n" +
+			"        I i = Y::<String>foo;\n" +
+			"        i.foo(10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y {\n" +
+			"    public static void foo(int x) {\n" +
+			"	System.out.println(x);\n" +
+			"    }\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [Y::<String>foo] EXACT_MATCH"
+	);	
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - QualifiedName:: form, without type arguments.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0005() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+			"    void foo(int x);\n" +
+			"}\n" +
+			"public class X  {\n" +
+			"    public static void main(String [] args) {\n" +
+			"        I i = Y.Z::foo;\n" +
+			"        i.foo(10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y {\n" +
+			"    static class Z {\n" +
+			"        public static void foo(int x) {\n" +
+			"	    System.out.println(x);\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y").getType("Z");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [Y.Z::foo] EXACT_MATCH"
+	);	
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - QualifiedName:: form, with type arguments.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0006() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+			"    void foo(int x);\n" +
+			"}\n" +
+			"public class X  {\n" +
+			"    public static void main(String [] args) {\n" +
+			"        I i = Y.Z::<String>foo;\n" +
+			"        i.foo(10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y {\n" +
+			"    static class Z {\n" +
+			"        public static void foo(int x) {\n" +
+			"	    System.out.println(x);\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y").getType("Z");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [Y.Z::<String>foo] EXACT_MATCH"
+	);	
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - Primary:: form, without type arguments.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0007() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+			"    void foo(int x);\n" +
+			"}\n" +
+			"public class X  {\n" +
+			"    public static void main(String [] args) {\n" +
+			"        I i = new Y()::foo;\n" +
+			"        i.foo(10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y {\n" +
+			"        void foo(int x) {\n" +
+			"	    System.out.println(x);\n" +
+			"        }\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [new Y()::foo] EXACT_MATCH"
+	);	
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - Primary:: form, with type arguments.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0008() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+			"    void foo(int x);\n" +
+			"}\n" +
+			"public class X  {\n" +
+			"    public static void main(String [] args) {\n" +
+			"        I i = new Y()::<String>foo;\n" +
+			"        i.foo(10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y {\n" +
+			"        void foo(int x) {\n" +
+			"	    System.out.println(x);\n" +
+			"        }\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [new Y()::<String>foo] EXACT_MATCH"
+	);	
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - X<T>:: form, without type arguments
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0009() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" + 
+			"  void foo(Y<String> y, int x);\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"  public X() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"  public static void main(String[] args) {\n" + 
+			"    I i = Y<String>::foo;\n" + 
+			"    i.foo(new Y<String>(), 10);\n" + 
+			"  }\n" + 
+			"}\n" + 
+			"class Y<T> {\n" + 
+			"  Y() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"  void foo(int x) {\n" + 
+			"    System.out.println(x);\n" + 
+			"  }\n" + 
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [Y<String>::foo] EXACT_MATCH"
+	);
+}
+
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - X<T>:: form, with type arguments
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0010() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" + 
+			"  void foo(Y<String> y, int x);\n" + 
+			"}\n" + 
+			"public class X {\n" + 
+			"  public X() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"  public static void main(String[] args) {\n" + 
+			"    I i = Y<String>::<String>foo;\n" + 
+			"    i.foo(new Y<String>(), 10);\n" + 
+			"  }\n" + 
+			"}\n" + 
+			"class Y<T> {\n" + 
+			"  Y() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"  void foo(int x) {\n" + 
+			"    System.out.println(x);\n" + 
+			"  }\n" + 
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [Y<String>::<String>foo] EXACT_MATCH"
+	);
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - X<T>.Name :: form, without type arguments
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0011() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+				"    void foo(Y<String>.Z z, int x);\n" +
+			"}\n" +
+			"public class X  {\n" +
+			"	@SuppressWarnings(\"unused\")\n" +
+			"    public static void main(String [] args) {\n" +
+			"        I i = Y<String>.Z::foo;\n" +
+			"        i.foo(new Y<String>().new Z(), 10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y<T> {\n" +
+			"    class Z {\n" +
+			"        void foo(int x) {\n" +
+			"	    System.out.println(x);\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n" +
+			"\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	type = type.getType("Z");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [Y<String>.Z::foo] EXACT_MATCH"
+	);
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - X<T>.Name :: form, with type arguments
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0012() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+				"    void foo(Y<String>.Z z, int x);\n" +
+			"}\n" +
+			"public class X  {\n" +
+			"	@SuppressWarnings(\"unused\")\n" +
+			"    public static void main(String [] args) {\n" +
+			"        I i = Y<String>.Z::<String>foo;\n" +
+			"        i.foo(new Y<String>().new Z(), 10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y<T> {\n" +
+			"    class Z {\n" +
+			"        void foo(int x) {\n" +
+			"	    System.out.println(x);\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n" +
+			"\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	type = type.getType("Z");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [Y<String>.Z::<String>foo] EXACT_MATCH"
+	);
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - X<T>.Y<K> :: form, without type arguments
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0013() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+				"    void foo(Y<String>.Z<String> z, int x);\n" +
+			"}\n" +
+			"public class X  {\n" +
+			"    public static void main(String [] args) {\n" +
+			"        I i = Y<String>.Z<String>::foo;\n" +
+			"        i.foo(new Y<String>().new Z<String>(), 10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y<T> {\n" +
+			"    class Z<K> {\n" +
+			"        void foo(int x) {\n" +
+			"	    System.out.println(x);\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n" +
+			"\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	type = type.getType("Z");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, ERASURE_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [Y<String>.Z<String>::foo] EXACT_MATCH"
+	);
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - X<T>.Y<K> :: form, with type arguments
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0014() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+				"    void foo(Y<String>.Z<String> z, int x);\n" +
+			"}\n" +
+			"public class X  {\n" +
+			"    public static void main(String [] args) {\n" +
+			"        I i = Y<String>.Z<String>::<String>foo;\n" +
+			"        i.foo(new Y<String>().new Z<String>(), 10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y<T> {\n" +
+			"    class Z<K> {\n" +
+			"        void foo(int x) {\n" +
+			"	    System.out.println(x);\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n" +
+			"\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	type = type.getType("Z");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [Y<String>.Z<String>::<String>foo] EXACT_MATCH"
+	);
+}
+
+/**
+ * @bug 400904
+ * @test tests search for Reference expression - X<T>.Y<K> :: new form, with type arguments
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400904"
+ * 
+ */
+public void testBug400904_0015() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+				"    void foo(Y<String> y);\n" +
+			"}\n" +
+			"public class X  {\n" +
+			"    public static void main(String [] args) {\n" +
+			"        I i = Y<String>.Z<String>::<String>new;\n" +
+			"        i.foo(new Y<String>()); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y<T> {\n" +
+			"    class Z<K> {\n" +
+			"        Z(Y<String> y) {\n" +
+			"            System.out.println(\"Y<T>.Z<K>::new\");\n" +
+			"        }\n" +
+			"        Z1(Y<String> y) {\n" +
+			"            System.out.println(\"Y<T>.Z<K>::new\");\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	type = type.getType("Z");
+	IMethod method = type.getMethod("Z", new String[] {"QY<QString;>;"});
+	search(method, REFERENCES, EXACT_RULE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.main(String[]) [Y<String>.Z<String>::<String>new] EXACT_MATCH"
+	);
+}
+/**
+ * @bug 400905
+ * @test lambda expression search on a) field b)parameter
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400905"
+ * 
+ */
+public void testBug400905_0001() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400905/X.java",
+			"interface I {\n" +
+			"    int foo();\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"    public static void main(String [] args) {\n" +
+			"	     I i = () -> 42;\n" +
+			"    }\n" +
+			"	public void bar(I i) {}\n" +
+			" 	public void doit() {\n" +
+			"		bar(() ->1);\n" +
+			"	}\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("I");
+	IMethod method = type.getMethod("foo", new String[] {});
+	search(method, DECLARATIONS, EXACT_RULE);
+	assertSearchResults(
+			"src/b400905/X.java int b400905.I.foo() [foo] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [() ->] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.doit() [() ->] EXACT_MATCH"
+	);	
+}
+/**
+ * @bug 400905
+ * @test  lambda expression search on a set of contexts with
+ * interface declaration and usage being in different files.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400905"
+ * 
+ */
+public void testBug400905_0002() throws CoreException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400905/X.java",
+			"public class X extends Y {\n" +
+			"    public static void main(String [] args) {\n" +
+			"		Y y = new Y();\n" +
+			"		I i = () -> {};\n" + // variable declaration context
+			"		I i1;\n" +
+			"		i1 = ()  -> {}" + // assignment context
+			"		y.goo(()-> {});\n" + // method argument context
+			"		i.foo();\n" +
+			"	}\n" +
+			"	public I bar() {\n" +
+			"		return () -> {};\n" + // return statement context
+			"	}\n" +
+			"}\n"
+	);
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/b400905/I.java",
+			"public interface I {\n" +
+			"    int foo();\n" +
+			"}\n") ;
+	this.workingCopies[2] = getWorkingCopy("/JavaSearchBugs/src/b400905/Y.java",
+			"public class Y {\n" +
+			"    void goo(I i) {};\n" +
+			"}\n") ;
+	IType type = this.workingCopies[1].getType("I");
+	IMethod method = type.getMethod("foo", new String[] {});
+	search(method, DECLARATIONS, EXACT_RULE);
+	assertSearchResults(
+			"src/b400905/I.java int b400905.I.foo() [foo] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [() ->] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [()  ->] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [()->] EXACT_MATCH\n" +
+			"src/b400905/X.java I b400905.X.bar() [() ->] EXACT_MATCH"
+	);	
+}
+/**
+ * @bug 400905
+ * @test  lambda expression search on a set of contexts with the 
+ * interface declaration and usage being in different files.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400905"
+ * 
+ */
+public void testBug400905_0003() throws CoreException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400905/X.java",
+			"public class X extends Y {\n" +
+			"    public static void main(String [] args) {\n" +
+			"		I[] i = new I[] { y-> y.exists(), y -> y.canRead(), y  -> y.canWrite()};\n" + // array initialization context
+			"	}\n" +
+			"}\n"
+	);
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/b400905/I.java",
+			"public interface I {\n" +
+			"    boolean foo(Y y);\n" +
+			"}\n") ;
+	this.workingCopies[2] = getWorkingCopy("/JavaSearchBugs/src/b400905/Y.java",
+			"public class Y {\n" +
+			"    public boolean exists() { return true};\n" +
+			"    public boolean canRead() { return true};\n" +
+			"    public boolean canWrite() { return true};\n" +
+			"}\n") ;
+	IType type = this.workingCopies[1].getType("I");
+	IMethod method = type.getMethod("foo", new String[] {"QY;"});
+	search(method, DECLARATIONS, EXACT_RULE);
+	assertSearchResults(
+			"src/b400905/I.java boolean b400905.I.foo(Y) [foo] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [y->] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [y ->] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [y  ->] EXACT_MATCH"
+	);	
+}
+/**
+ * @bug 400905
+ * @test  lambda expression search on a set of contexts with the 
+ * interface declaration and usage being in different files.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400905"
+ * 
+ */
+public void testBug400905_0004() throws CoreException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400905/X.java",
+			"public class X extends Y {\n" +
+			"    public static void main(String [] args) {\n" +
+			"		I<Y> c = () /* foo */ -> () /* bar */ -> {};\n" + // array initialization context
+			"		I<Y> y = args.length < 1 ? (() /* true */-> 42) : (() /* false */ -> 23);\n" + // conditional expression context
+			"		Object o = (I) () /* cast */ -> 42;\n " + //cast expression
+			"	}\n" +
+			"}\n"
+	);
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/b400905/I.java",
+			"public interface I<T> {\n" +
+			"    public T foo();\n" +
+			"}\n") ;
+	this.workingCopies[2] = getWorkingCopy("/JavaSearchBugs/src/b400905/Y.java",
+			"public interface Y {\n" +
+			"    public abstract void run() { };\n" +
+			"}\n") ;
+	IType type = this.workingCopies[1].getType("I");
+	IMethod method = type.getMethod("foo", new String[] {});
+	search(method, DECLARATIONS, EXACT_RULE);
+	assertSearchResults(
+			"src/b400905/I.java T b400905.I.foo() [foo] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [() /* foo */ ->] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [() /* true */->] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [() /* false */ ->] EXACT_MATCH\n" +
+			"src/b400905/X.java void b400905.X.main(String[]) [() /* cast */ ->] EXACT_MATCH"
+	);	
+}
+/**
+ * @bug 400905
+ * @test  lambda expression search on a set of contexts with the 
+ * interface declaration and usage being in different files.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400905"
+ * 
+ */
+public void testBug400905_0005() throws CoreException {
+	this.workingCopies = new ICompilationUnit[3];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400905/X.java",
+			"public class X extends Y {\n" +
+			"    public static void main(String [] args) {\n" +
+			"		I<Y> c = () /* foo */ -> () /* bar */ -> {};\n" + // array initialization context
+			"	}\n" +
+			"}\n"
+	);
+	this.workingCopies[1] = getWorkingCopy("/JavaSearchBugs/src/b400905/I.java",
+			"public interface I<T> {\n" +
+			"    public T foo();\n" +
+			"}\n") ;
+	this.workingCopies[2] = getWorkingCopy("/JavaSearchBugs/src/b400905/Y.java",
+			"public interface Y {\n" +
+			"    public abstract void bar() { };\n" +
+			"}\n") ;
+	
+	IType type = this.workingCopies[2].getType("Y");
+	IMethod method = type.getMethod("bar", new String[] {});
+	search(method, DECLARATIONS, EXACT_RULE);
+	assertSearchResults(
+			"src/b400905/X.java void b400905.X.main(String[]) [() /* bar */ ->] EXACT_MATCH\n" +
+			"src/b400905/Y.java void b400905.Y.bar() [bar] EXACT_MATCH"
+	);	
+}
+/**
+ * @bug 400905
+ * @test  lambda expression search on a set of contexts with the 
+ * interface declaration and usage being in different files.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400905"
+ * 
+ */
+public void testBug400905_0006() throws CoreException {
+	try {
+		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/X.java",
+			"public class X {\n" +
+			"    public static void main(String [] args) {\n" +
+			"		Y.goo(()->{});\n" +
+			"	}\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/Y.java",
+			"public class Y {\n" +
+			"    public static void goo(I i) {};\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"public interface I {\n" +
+			"    public void foo();\n" +
+			"}\n"
+		);
+		IMethod method = getCompilationUnit("/P/src/I.java").getType("I").getMethod("foo", new String[0]);
+		search(method, DECLARATIONS, EXACT_RULE, SearchEngine.createJavaSearchScope(new IJavaProject[] {project}), this.resultCollector);
+		assertSearchResults(
+				"src/I.java void I.foo() [foo] EXACT_MATCH\n" + 
+				"src/X.java void X.main(String[]) [()->] EXACT_MATCH"
+		);
+	}
+	finally {
+		deleteProject("P");
+	}
+}
+
+/**
+ * @bug 400905
+ * @test  lambda expression search on a set of contexts with the 
+ * interface declaration and usage being in different files.
+ *		
+ * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400905"
+ * 
+ */
+public void testBug400905_0007() throws CoreException {
+	try {
+		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/X.java",
+			"public class X  {\n" +
+			"    void foo() {\n" +
+			"        I i = Y::new;\n" + 
+			"    }\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/Y.java",
+			"public class Y extends X {\n" +
+			"    Y(int x) {};\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"interface I {\n" +
+			"    X foo(int x);\n" +
+			"}\n"
+		);
+		IMethod method = getCompilationUnit("/P/src/Y.java").getType("Y").getMethod("Y", new String[] {"I"});
+		search(method, REFERENCES, EXACT_RULE, SearchEngine.createJavaSearchScope(new IJavaProject[] {project}), this.resultCollector);
+		assertSearchResults("src/X.java void X.foo() [Y::new] EXACT_MATCH");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
+
 // Add new tests in JavaSearchBugs8Tests
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
index 0214ab8..9b9033c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CompilationUnitDeclaration.java
@@ -691,7 +691,10 @@ public void tagAsHavingIgnoredMandatoryErrors(int problemId) {
 }
 
 public void traverse(ASTVisitor visitor, CompilationUnitScope unitScope) {
-	if (this.ignoreFurtherInvestigation)
+	traverse(visitor, unitScope, true);
+}
+public void traverse(ASTVisitor visitor, CompilationUnitScope unitScope, boolean skipOnError) {
+	if (skipOnError && this.ignoreFurtherInvestigation)
 		return;
 	try {
 		if (visitor.visit(this, this.scope)) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchDocument.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchDocument.java
index 0c16fe6..81fe194 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchDocument.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchDocument.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -28,6 +32,7 @@ public abstract class SearchDocument {
 	private SourceElementParser parser;
 	private String documentPath;
 	private SearchParticipant participant;
+	public boolean shouldIndexResolvedDocument = false;
 
 	/**
 	 * Creates a new search document. The given document path is a string that uniquely identifies the document.
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchParticipant.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchParticipant.java
index 15155e4..7ae9e2c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchParticipant.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchParticipant.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -134,6 +138,33 @@ public abstract class SearchParticipant {
 	public abstract void indexDocument(SearchDocument document, IPath indexLocation);
 
 	/**
+	 * Indexes the given resolved document in the given index. A search participant
+	 * asked to index a resolved document should process it and call
+	 * {@link SearchDocument#addIndexEntry(char[], char[])} as many times as
+	 * needed to add only those additional index entries which could not have been originally added
+	 * to the index during a call to {@link SearchParticipant#indexDocument}. If delegating to another
+	 * participant, it should use the original index location (and not the
+	 * delegatee's one). In the particular case of delegating to the default
+	 * search participant (see {@link SearchEngine#getDefaultSearchParticipant()}),
+	 * the provided document's path must be a path ending with one of the
+	 * {@link org.eclipse.jdt.core.JavaCore#getJavaLikeExtensions() Java-like extensions}
+	 * or with '.class'.
+	 * <p>
+	 * The given index location must represent a path in the file system to a file that
+	 * either already exists or is going to be created. If it exists, it must be an index file,
+	 * otherwise its data might be overwritten.
+	 * </p><p>
+	 * Clients are not expected to call this method.
+	 * </p>
+	 *
+	 * @param document the document to index
+	 * @param indexLocation the location in the file system to the index
+	 */
+	public void indexResolvedDocument(SearchDocument document, IPath indexLocation) {
+		// do nothing, subtypes should do the "appropriate thing"
+	}
+
+	/**
 	 * Locates the matches in the given documents using the given search pattern
 	 * and search scope, and reports them to the given search requestor. This
 	 * method is called by the search engine once it has search documents
@@ -180,6 +211,22 @@ public abstract class SearchParticipant {
 	}
 
 	/**
+	 * Resolves the given document. A search participant asked to resolve a document should parse it and 
+	 * resolve the types and preserve enough state to be able to tend to a indexResolvedDocument call
+	 * subsequently. This API is invoked without holding any index related locks or monitors.
+	 * <p>
+	 * Clients are not expected to call this method.
+	 * </p>
+	 *
+	 * @param document the document to resolve
+	 * @since 3.9 BETA_JAVA8
+	 * @see SearchParticipant#indexResolvedDocument
+	 */
+	public void resolveDocument(SearchDocument document) {
+		// do nothing, subtypes should do the "appropriate thing"
+	}
+	
+	/**
 	 * Schedules the indexing of the given document.
 	 * Once the document is ready to be indexed,
 	 * {@link #indexDocument(SearchDocument, IPath) indexDocument(document, indexPath)}
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchParticipant.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchParticipant.java
index 3d74f4a..615adb7 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchParticipant.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/JavaSearchParticipant.java
@@ -31,6 +31,7 @@ import org.eclipse.jdt.internal.core.search.matching.MatchLocator;
 public class JavaSearchParticipant extends SearchParticipant {
 
 	private ThreadLocal indexSelector = new ThreadLocal();
+	private SourceIndexer sourceIndexer;
 
 	/* (non-Javadoc)
 	 * @see org.eclipse.jdt.core.search.SearchParticipant#beginSearching()
@@ -71,13 +72,38 @@ public class JavaSearchParticipant extends SearchParticipant {
 
 		String documentPath = document.getPath();
 		if (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(documentPath)) {
-			new SourceIndexer(document).indexDocument();
+			this.sourceIndexer = new SourceIndexer(document);
+			this.sourceIndexer.indexDocument();
 		} else if (org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(documentPath)) {
 			new BinaryIndexer(document).indexDocument();
 		}
 	}
 
 	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.search.SearchParticipant#indexResolvedDocument(SearchDocument, IPath)
+	 */
+	@Override
+	public void indexResolvedDocument(SearchDocument document, IPath indexPath) {
+		String documentPath = document.getPath();
+		if (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(documentPath)) {
+			if (this.sourceIndexer != null)
+				this.sourceIndexer.indexResolvedDocument();
+			this.sourceIndexer = null;
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see org.eclipse.jdt.core.search.SearchParticipant#resolveDocument(SearchDocument document)
+	 */
+	public void resolveDocument(SearchDocument document) {
+		String documentPath = document.getPath();
+		if (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(documentPath)) {
+			if (this.sourceIndexer != null)
+				this.sourceIndexer.resolveDocument();
+		}
+	}
+	
+	/* (non-Javadoc)
 	 * @see SearchParticipant#locateMatches(SearchDocument[], SearchPattern, IJavaSearchScope, SearchRequestor, IProgressMonitor)
 	 */
 	public void locateMatches(SearchDocument[] indexMatches, SearchPattern pattern,
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
index 242a331..f26ef07 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/AbstractIndexer.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -194,4 +198,7 @@ public abstract class AbstractIndexer implements IIndexConstants {
 		addNameReference(CharOperation.lastSegment(typeName, '.'));
 	}
 	public abstract void indexDocument();
+	public void indexResolvedDocument() {
+		// subtypes should implement where it makes sense.
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
index b982c60..3df2ba3 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -506,6 +510,20 @@ public void indexDocument(SearchDocument searchDocument, SearchParticipant searc
 		searchDocument.setIndex(null);
 	}
 }
+public void indexResolvedDocument(SearchDocument searchDocument, SearchParticipant searchParticipant, Index index, IPath indexLocation) {
+	searchParticipant.resolveDocument(searchDocument);
+	ReadWriteMonitor monitor = index.monitor;
+	if (monitor == null) 
+		return; // index got deleted since acquired
+	try {
+		monitor.enterWrite(); // ask permission to write
+		searchDocument.setIndex(index);
+		searchParticipant.indexResolvedDocument(searchDocument, indexLocation);	
+	} finally {
+		searchDocument.setIndex(null);
+		monitor.exitWrite();
+	}
+}
 /**
  * Trigger addition of the entire content of a project
  * Note: the actual operation is performed in background
@@ -964,13 +982,16 @@ public void scheduleDocumentIndexing(final SearchDocument searchDocument, IPath
 			if (index == null) return true;
 			ReadWriteMonitor monitor = index.monitor;
 			if (monitor == null) return true; // index got deleted since acquired
-
+			final Path indexPath = new Path(indexLocation.getCanonicalFilePath());
 			try {
 				monitor.enterWrite(); // ask permission to write
-				indexDocument(searchDocument, searchParticipant, index, new Path(indexLocation.getCanonicalFilePath()));
+				indexDocument(searchDocument, searchParticipant, index, indexPath);
 			} finally {
 				monitor.exitWrite(); // free write lock
 			}
+			if (searchDocument.shouldIndexResolvedDocument) {
+				indexResolvedDocument(searchDocument, searchParticipant, index, indexPath);
+			}
 			return true;
 		}
 		public String toString() {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
index 3fdf60c..1567601 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -14,12 +18,41 @@ import org.eclipse.core.resources.IProject;
 import org.eclipse.core.resources.ResourcesPlugin;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.search.SearchDocument;
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.CompilationResult;
+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;
+import org.eclipse.jdt.internal.compiler.ISourceElementRequestor;
 import org.eclipse.jdt.internal.compiler.SourceElementParser;
+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
+import org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;
+import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
+import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
+import org.eclipse.jdt.internal.compiler.env.ISourceType;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.impl.ITypeRequestor;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
+import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
+import org.eclipse.jdt.internal.compiler.parser.Parser;
+import org.eclipse.jdt.internal.compiler.parser.SourceTypeConverter;
+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
+import org.eclipse.jdt.internal.core.CancelableNameEnvironment;
+import org.eclipse.jdt.internal.core.DefaultWorkingCopyOwner;
+import org.eclipse.jdt.internal.core.JavaModel;
 import org.eclipse.jdt.internal.core.JavaModelManager;
+import org.eclipse.jdt.internal.core.JavaProject;
+import org.eclipse.jdt.internal.core.SourceTypeElementInfo;
 import org.eclipse.jdt.internal.core.jdom.CompilationUnit;
+import org.eclipse.jdt.internal.core.search.matching.MethodPattern;
 import org.eclipse.jdt.internal.core.search.processing.JobManager;
 
 /**
@@ -35,22 +68,29 @@ import org.eclipse.jdt.internal.core.search.processing.JobManager;
  * - Types;<br>
  * - Constructors.
  */
-public class SourceIndexer extends AbstractIndexer implements SuffixConstants {
+public class SourceIndexer extends AbstractIndexer implements ITypeRequestor, SuffixConstants {
 
+	private LookupEnvironment lookupEnvironment;
+	private CompilerOptions options;
+	private CompilationUnitDeclaration cu;
+	public ISourceElementRequestor requestor;
+	private Parser basicParser;
+	private ProblemReporter problemReporter;
+	
 	public SourceIndexer(SearchDocument document) {
 		super(document);
+		this.requestor = new SourceIndexerRequestor(this);
 	}
 	public void indexDocument() {
 		// Create a new Parser
-		SourceIndexerRequestor requestor = new SourceIndexerRequestor(this);
 		String documentPath = this.document.getPath();
 		SourceElementParser parser = this.document.getParser();
 		if (parser == null) {
 			IPath path = new Path(documentPath);
 			IProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(path.segment(0));
-			parser = JavaModelManager.getJavaModelManager().indexManager.getSourceElementParser(JavaCore.create(project), requestor);
+			parser = JavaModelManager.getJavaModelManager().indexManager.getSourceElementParser(JavaCore.create(project), this.requestor);
 		} else {
-			parser.setRequestor(requestor);
+			parser.setRequestor(this.requestor);
 		}
 
 		// Launch the parser
@@ -65,11 +105,127 @@ public class SourceIndexer extends AbstractIndexer implements SuffixConstants {
 		if (source == null || name == null) return; // could not retrieve document info (e.g. resource was discarded)
 		CompilationUnit compilationUnit = new CompilationUnit(source, name);
 		try {
-			parser.parseCompilationUnit(compilationUnit, true/*full parse*/, null/*no progress*/);
+			this.cu = parser.parseCompilationUnit(compilationUnit, true/*full parse*/, null/*no progress*/);
+			this.document.shouldIndexResolvedDocument = this.cu.hasFunctionalTypes();
 		} catch (Exception e) {
 			if (JobManager.VERBOSE) {
 				e.printStackTrace();
 			}
 		}
 	}
+
+	public void resolveDocument() {
+		IPath path = new Path(this.document.getPath());
+		IProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(path.segment(0));
+		JavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();
+		JavaProject javaProject = (JavaProject) model.getJavaProject(project);
+		try {
+			CancelableNameEnvironment nameEnvironment;
+			nameEnvironment = new CancelableNameEnvironment(javaProject, DefaultWorkingCopyOwner.PRIMARY, null);
+			this.options = new CompilerOptions(javaProject.getOptions(true));
+			this.problemReporter =
+					new ProblemReporter(
+						DefaultErrorHandlingPolicies.proceedWithAllProblems(),
+						this.options,
+						new DefaultProblemFactory());
+			this.lookupEnvironment = new LookupEnvironment(this, this.options, this.problemReporter, nameEnvironment);
+		} catch (JavaModelException e) {
+			if (JobManager.VERBOSE) {
+				e.printStackTrace();
+			}
+			this.cu = null;
+			return;
+		}
+		this.lookupEnvironment.buildTypeBindings(this.cu, null);
+		this.lookupEnvironment.completeTypeBindings();
+		if (this.cu.scope != null) {
+			this.cu.scope.faultInTypes();
+			this.cu.resolve();
+		}
+	}
+	
+	public void accept(IBinaryType binaryType, PackageBinding packageBinding, AccessRestriction accessRestriction) {
+		this.lookupEnvironment.createBinaryTypeFrom(binaryType, packageBinding, accessRestriction);
+	}
+
+	public void accept(ICompilationUnit unit, AccessRestriction accessRestriction) {
+		CompilationResult unitResult = new CompilationResult(unit, 1, 1, this.options.maxProblemsPerUnit);
+		CompilationUnitDeclaration parsedUnit = basicParser().dietParse(unit, unitResult);
+		this.lookupEnvironment.buildTypeBindings(parsedUnit, accessRestriction);
+		this.lookupEnvironment.completeTypeBindings(parsedUnit, true);
+	}
+
+	public void accept(ISourceType[] sourceTypes, PackageBinding packageBinding, AccessRestriction accessRestriction) {
+		// ensure to jump back to toplevel type for first one (could be a member)
+		while (sourceTypes[0].getEnclosingType() != null) {
+			sourceTypes[0] = sourceTypes[0].getEnclosingType();
+		}
+
+		CompilationResult result =
+			new CompilationResult(sourceTypes[0].getFileName(), 1, 1, this.options.maxProblemsPerUnit);
+		
+		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=305259, build the compilation unit in its own sand box.
+		final long savedComplianceLevel = this.options.complianceLevel;
+		final long savedSourceLevel = this.options.sourceLevel;
+		
+		try {
+			IJavaProject project = ((SourceTypeElementInfo) sourceTypes[0]).getHandle().getJavaProject();
+			this.options.complianceLevel = CompilerOptions.versionToJdkLevel(project.getOption(JavaCore.COMPILER_COMPLIANCE, true));
+			this.options.sourceLevel = CompilerOptions.versionToJdkLevel(project.getOption(JavaCore.COMPILER_SOURCE, true));
+
+			// need to hold onto this
+			CompilationUnitDeclaration unit =
+				SourceTypeConverter.buildCompilationUnit(
+						sourceTypes,//sourceTypes[0] is always toplevel here
+						SourceTypeConverter.FIELD_AND_METHOD // need field and methods
+						| SourceTypeConverter.MEMBER_TYPE // need member types
+						| SourceTypeConverter.FIELD_INITIALIZATION // need field initialization
+						| SourceTypeConverter.LOCAL_TYPE, // need local type
+						this.lookupEnvironment.problemReporter,
+						result);
+
+			if (unit != null) {
+				this.lookupEnvironment.buildTypeBindings(unit, accessRestriction);
+				this.lookupEnvironment.completeTypeBindings(unit);
+			}
+		} finally {
+			this.options.complianceLevel = savedComplianceLevel;
+			this.options.sourceLevel = savedSourceLevel;
+		}
+	}
+	
+	protected Parser basicParser() {
+		if (this.basicParser == null) {
+			this.basicParser = new Parser(this.problemReporter, false);
+			this.basicParser.reportOnlyOneSyntaxError = true;
+		}
+		return this.basicParser;
+	}
+
+
+public void indexResolvedDocument() {
+	if (this.cu != null && this.cu.scope != null) {
+		final ASTVisitor visitor = new ASTVisitor() {
+				public boolean visit(LambdaExpression lambdaExpression, BlockScope blockScope) {
+					if (lambdaExpression.binding != null && lambdaExpression.binding.isValidBinding()) {
+						SourceIndexer.this.addIndexEntry(IIndexConstants.METHOD_DECL, MethodPattern.createIndexKey(lambdaExpression.descriptor.selector, lambdaExpression.descriptor.parameters.length));
+					}
+					return true;
+				}
+				public boolean visit(ReferenceExpression referenceExpression, BlockScope blockScope) {
+					if (referenceExpression.isArrayConstructorReference())
+						return true;
+					MethodBinding binding = referenceExpression.getMethodBinding();
+					if (binding != null && binding.isValidBinding()) {
+						if (referenceExpression.isMethodReference())
+							SourceIndexer.this.addMethodReference(binding.selector, binding.parameters.length);
+						else
+							SourceIndexer.this.addConstructorReference(binding.declaringClass.sourceName(), binding.parameters.length);
+					}
+					return true;
+				}
+			};
+		this.cu.traverse(visitor , this.cu.scope, false);
+	}
+}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java
index 8342e17..5b49f5b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -88,6 +92,11 @@ public int match(MessageSend msgSend, MatchingNodeSet nodeSet)  {
 	}
 	return IMPOSSIBLE_MATCH;
 }
+public int match(ReferenceExpression node, MatchingNodeSet nodeSet) {
+	if (!this.pattern.findReferences) return IMPOSSIBLE_MATCH;
+	return nodeSet.addMatch(node, this.pattern.mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH);
+}
+
 //public int match(Reference node, MatchingNodeSet nodeSet) - SKIP IT
 public int match(TypeDeclaration node, MatchingNodeSet nodeSet) {
 	if (!this.pattern.findReferences) return IMPOSSIBLE_MATCH;
@@ -303,6 +312,9 @@ public int resolveLevel(ASTNode node) {
 		if (node instanceof JavadocMessageSend) {
 			return resolveLevel(((JavadocMessageSend)node).binding);
 		}
+		if (node instanceof ReferenceExpression) {
+			return resolveLevel(((ReferenceExpression)node).getMethodBinding());
+		}
 	}
 	if (node instanceof ConstructorDeclaration)
 		return resolveLevel((ConstructorDeclaration) node, true);
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index 66caf9d..60a33af 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -451,6 +451,70 @@ protected char[][][] computeSuperTypeNames(IType focusType) {
 	return this.allSuperTypeNames;
 }
 /**
+ * Creates an IMethod from the given lambda declaration and type.
+ */
+protected IJavaElement createHandle(LambdaExpression lambdaExpression, IJavaElement parent) {
+	if (!(parent instanceof IType)) return parent;
+
+	IType type = (IType) parent;
+	Argument[] arguments = lambdaExpression.arguments();
+	int syntheticArgumentSize = lambdaExpression.getSyntheticArgumentSize();
+	MethodBinding descriptor = lambdaExpression.descriptor;
+	int argCount = arguments == null ? 0 : arguments.length;
+	if (type.isBinary()) {
+		ClassFileReader reader = classFileReader(type);
+		if (reader != null) {
+			// build arguments names
+			char[][] argumentTypeNames = new char[argCount - syntheticArgumentSize][];
+			for (int i = syntheticArgumentSize; i < argCount; i++) {
+				char[] typeName = null;
+				if (arguments != null) {
+					TypeReference typeRef = arguments[i].type;
+					typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');
+					for (int k = 0, dim = typeRef.dimensions(); k < dim; k++)
+						typeName = CharOperation.concat(typeName, new char[] {'[', ']'});
+				}
+				if (typeName == null) {
+					// invalid type name
+					return null;
+				}
+				argumentTypeNames[i - syntheticArgumentSize] = typeName;
+			}
+			// return binary method
+			IMethod binaryMethod = createBinaryMethodHandle(type, descriptor.selector, argumentTypeNames);
+			if (binaryMethod == null) {
+				// when first attempt fails, try with similar matches if any...
+				PossibleMatch similarMatch = this.currentPossibleMatch.getSimilarMatch();
+				while (similarMatch != null) {
+					type = ((ClassFile)similarMatch.openable).getType();
+					binaryMethod = createBinaryMethodHandle(type, descriptor.selector, argumentTypeNames);
+					if (binaryMethod != null) {
+						return binaryMethod;
+					}
+					similarMatch = similarMatch.getSimilarMatch();
+				}
+			}
+			return binaryMethod;
+		}
+		if (BasicSearchEngine.VERBOSE) {
+			System.out.println("Not able to createHandle for the lambda expression " + //$NON-NLS-1$
+					CharOperation.charToString(descriptor.selector) + " May miss some results");  //$NON-NLS-1$
+		}
+		return null;
+	}
+
+	String[] parameterTypeSignatures = new String[argCount - syntheticArgumentSize];
+	if (arguments != null) {
+		for (int i = syntheticArgumentSize; i < argCount; i++) {
+			TypeReference typeRef = arguments[i].type;
+			char[] typeName = CharOperation.concatWith(typeRef.getParameterizedTypeName(), '.');
+			parameterTypeSignatures[i - syntheticArgumentSize] = Signature.createTypeSignature(typeName, false);
+		}
+	}
+
+	return createMethodHandle(type, new String(descriptor.selector), parameterTypeSignatures);
+}
+/**
  * Creates an IMethod from the given method declaration and type.
  */
 protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent) {
@@ -2194,6 +2258,24 @@ protected void reportBinaryMemberDeclaration(IResource resource, IMember binaryM
 	SearchMatch match = newDeclarationMatch(binaryMember, binaryMemberBinding, accuracy, range.getOffset(), range.getLength(), getParticipant(), resource);
 	report(match);
 }
+
+protected void reportMatching(LambdaExpression lambdaExpression,  IJavaElement parent, int accuracy, MatchingNodeSet nodeSet) throws CoreException {
+	if (accuracy > -1) {
+		IJavaElement enclosingElement = createHandle(lambdaExpression, parent);
+		if (enclosingElement != null) { // skip if unable to find method
+			// compute source positions of the selector
+			int nameSourceStart = lambdaExpression.sourceStart;
+			if (encloses(enclosingElement)) {
+				SearchMatch match = null;
+				int length = lambdaExpression.getArrowPosition() + 1 - nameSourceStart;
+				match = this.patternLocator.newDeclarationMatch(lambdaExpression, enclosingElement, lambdaExpression.descriptor, accuracy, length, this);
+				if (match != null) {
+					report(match);
+				}
+			}
+		}
+	}
+}
 /**
  * Visit the given method declaration and report the nodes that match exactly the
  * search pattern (i.e. the ones in the matching nodes set)
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MemberDeclarationVisitor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MemberDeclarationVisitor.java
index ca95c05..5c19a55 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MemberDeclarationVisitor.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MemberDeclarationVisitor.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -203,6 +207,15 @@ public boolean visit(Argument argument, BlockScope scope) {
     this.localDeclaration = argument;
     return true;
 }
+public boolean visit(LambdaExpression lambdaExpression, BlockScope scope) {
+	Integer level = (Integer) this.nodeSet.matchingNodes.removeKey(lambdaExpression);
+	try {
+		this.locator.reportMatching(lambdaExpression, this.enclosingElement, level != null ? level.intValue() : -1, this.nodeSet);
+	} catch (CoreException e) {
+		throw new WrappedCoreException(e);
+	}
+	return true;
+}
 public boolean visit(LocalDeclaration declaration, BlockScope scope) {
     this.localDeclaration = declaration;
     return true;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java
index 3253e62..2898595 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java
@@ -1,9 +1,13 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
@@ -22,6 +26,7 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.search.*;
 import org.eclipse.jdt.internal.compiler.ast.*;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 import org.eclipse.jdt.internal.core.search.BasicSearchEngine;
@@ -168,6 +173,15 @@ public int match(ASTNode node, MatchingNodeSet nodeSet) {
 	}
 	return nodeSet.addMatch(node, declarationsLevel);
 }
+
+public int match(LambdaExpression node, MatchingNodeSet nodeSet) {
+	if (!this.pattern.findDeclarations) return IMPOSSIBLE_MATCH;
+	if (this.pattern.parameterSimpleNames.length != node.arguments().length) return IMPOSSIBLE_MATCH;
+
+	nodeSet.mustResolve = true;
+	return nodeSet.addMatch(node, POSSIBLE_MATCH);
+}
+
 //public int match(ConstructorDeclaration node, MatchingNodeSet nodeSet) - SKIP IT
 //public int match(Expression node, MatchingNodeSet nodeSet) - SKIP IT
 //public int match(FieldDeclaration node, MatchingNodeSet nodeSet) - SKIP IT
@@ -231,6 +245,12 @@ public int match(MessageSend node, MatchingNodeSet nodeSet) {
 	return nodeSet.addMatch(node, this.pattern.mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH);
 }
 //public int match(Reference node, MatchingNodeSet nodeSet) - SKIP IT
+public int match(ReferenceExpression node, MatchingNodeSet nodeSet) {
+	if (!this.pattern.findReferences) return IMPOSSIBLE_MATCH;
+	if (!matchesName(this.pattern.selector, node.selector)) return IMPOSSIBLE_MATCH;
+	nodeSet.mustResolve = true;
+	return nodeSet.addMatch(node, this.pattern.mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH);
+}
 public int match(Annotation node, MatchingNodeSet nodeSet) {
 	if (!this.pattern.findReferences) return IMPOSSIBLE_MATCH;
 	MemberValuePair[] pairs = node.memberValuePairs();
@@ -255,6 +275,8 @@ protected int matchContainer() {
 		// need to look almost everywhere to find in javadocs and static import
 		return ALL_CONTAINER;
 	}
+	if (CompilerOptions.versionToJdkLevel(JavaCore.getOption(JavaCore.COMPILER_SOURCE)) >= 8)
+		return ALL_CONTAINER;
 	return CLASS_CONTAINER;
 }
 /* (non-Javadoc)
@@ -648,11 +670,17 @@ public int resolveLevel(ASTNode possibleMatchingNode) {
 			MemberValuePair memberValuePair = (MemberValuePair) possibleMatchingNode;
 			return resolveLevel(memberValuePair.binding);
 		}
+		if (possibleMatchingNode instanceof ReferenceExpression) {
+			return resolveLevel((ReferenceExpression)possibleMatchingNode);
+		}
 	}
 	if (this.pattern.findDeclarations) {
 		if (possibleMatchingNode instanceof MethodDeclaration) {
 			return resolveLevel(((MethodDeclaration) possibleMatchingNode).binding);
 		}
+		if (possibleMatchingNode instanceof LambdaExpression) {
+			return resolveLevel(((LambdaExpression) possibleMatchingNode).descriptor);
+		}
 	}
 	return IMPOSSIBLE_MATCH;
 }
@@ -735,6 +763,24 @@ protected int resolveLevel(MessageSend messageSend) {
 	return (methodLevel & MATCH_LEVEL_MASK) > (declaringLevel & MATCH_LEVEL_MASK) ? declaringLevel : methodLevel; // return the weaker match
 }
 
+protected int resolveLevel(ReferenceExpression referenceExpression) {
+	MethodBinding method = referenceExpression.getMethodBinding();
+	if (method == null || referenceExpression.resolvedType == null)
+		return INACCURATE_MATCH;
+
+	int methodLevel = matchMethod(method, false);
+	if (methodLevel == IMPOSSIBLE_MATCH) {
+		if (method != method.original()) methodLevel = matchMethod(method.original(), false);
+		if (methodLevel == IMPOSSIBLE_MATCH) return IMPOSSIBLE_MATCH;
+		method = method.original();
+	}
+
+	// receiver type
+	if (this.pattern.declaringSimpleName == null && this.pattern.declaringQualification == null) return methodLevel; // since any declaring class will do
+	int declaringLevel = resolveLevelForType(this.pattern.declaringSimpleName, this.pattern.declaringQualification, method.declaringClass);
+	return (methodLevel & MATCH_LEVEL_MASK) > (declaringLevel & MATCH_LEVEL_MASK) ? declaringLevel : methodLevel; // return the weaker match
+}
+
 /**
  * Returns whether the given reference type binding matches or is a subtype of a type
  * that matches the given qualified pattern.
commit 124641ac651bbea2bd062a9605817d39b473bf0e
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Tue Feb 25 01:19:51 2014 +0530

    Simplified implementation for Bug 400905 - [1.8][search] Search engine
    skips functional interface types.

125	7	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
18	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
16	1	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchDocument.java
3	0	org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchParticipant.java
6	2	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
76	85	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
index 7a6f746..ce77e1b 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
@@ -45,7 +45,7 @@ public class JavaSearchBugs8Tests extends AbstractJavaSearchTests {
 
 	static {
 //	 org.eclipse.jdt.internal.core.search.BasicSearchEngine.VERBOSE = true;
-//	TESTS_NAMES = new String[] {"testBug400899g29"};
+//	TESTS_NAMES = new String[] {"testBug400905_0010"};
 }
 
 public JavaSearchBugs8Tests(String name) {
@@ -121,10 +121,13 @@ public static Test suite() {
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0003"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0004"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0005"));
-//	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0006"));
-//	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0007"));
-//	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0008"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0006"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0007"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0008"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0009"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0010"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0011"));
+//	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0012"));
 	return suite;
 }
 class TestCollector extends JavaSearchResultCollector {
@@ -2544,7 +2547,7 @@ public void testBug400905_0005() throws CoreException {
  * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400905"
  * 
  */
-public void _testBug400905_0006() throws CoreException {
+public void testBug400905_0006() throws CoreException {
 	try {
 		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
 		createFile(
@@ -2587,7 +2590,7 @@ public void _testBug400905_0006() throws CoreException {
  * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=400905"
  * 
  */
-public void _testBug400905_0007() throws CoreException {
+public void testBug400905_0007() throws CoreException {
 	try {
 		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
 		createFile(
@@ -2618,7 +2621,7 @@ public void _testBug400905_0007() throws CoreException {
 		deleteProject("P");
 	}
 }
-public void _testBug400905_0008() throws CoreException {
+public void testBug400905_0008() throws CoreException {
 	try {
 		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
 		createFile(
@@ -2681,6 +2684,121 @@ public void testBug400905_0009() throws CoreException {
 		deleteProject("P");
 	}
 }
+public void testBug400905_0010() throws CoreException {
+	try {
+		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/J.java",
+			"public interface J {\n" +
+			"    public static void main(String [] args) {\n" +
+			"		I i = Y::goo;\n" +
+			"	}\n" +
+			"    default void foo() {\n" +
+			"       I i = Y::goo;\n" +
+			"       Y.goo(()->{});\n" +
+			"   }\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/Y.java",
+			"public class Y {\n" +
+			"    public static void goo(I i) {};\n" +
+			"    public static void goo() {};\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"public interface I {\n" +
+			"    public void foo();\n" +
+			"}\n"
+		);
+		IMethod method = getCompilationUnit("/P/src/Y.java").getType("Y").getMethod("goo", new String[0]);
+		search(method, REFERENCES, EXACT_RULE, SearchEngine.createJavaSearchScope(new IJavaProject[] {project}), this.resultCollector);
+		assertSearchResults("src/J.java void J.main(String[]) [Y::goo] EXACT_MATCH\n" + 
+				"src/J.java void J.foo() [Y::goo] EXACT_MATCH");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
+public void testBug400905_0011() throws CoreException {
+	try {
+		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/J.java",
+			"public interface J {\n" +
+			"    public static void main(String [] args) {\n" +
+			"		I i = Y::goo;\n" +
+			"	}\n" +
+			"    default void foo() {\n" +
+			"       I i = Y::goo;\n" +
+			"       Y.goo(()->{});\n" +
+			"   }\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/Y.java",
+			"public class Y {\n" +
+			"    public static void goo(I i) {};\n" +
+			"    public static void goo() {};\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"public interface I {\n" +
+			"    public void foo();\n" +
+			"}\n"
+		);
+		IMethod method = getCompilationUnit("/P/src/I.java").getType("I").getMethod("foo", new String[0]);
+		search(method, REFERENCES, EXACT_RULE, SearchEngine.createJavaSearchScope(new IJavaProject[] {project}), this.resultCollector);
+		assertSearchResults("");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
+public void _testBug400905_0012() throws CoreException {
+	try {
+		createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/J.java",
+			"public class J implements I {\n" +
+			"    public static void main(String [] args) {\n" +
+			"		I i = Y::goo;\n" +
+			"	 }\n" +
+			"    void foo() {\n" +
+			"       I i = Y::goo;\n" +
+			"       Y.goo(()->{});\n" +
+			"       I i2 = new I() {\n" +
+			"		    public void foo() {\n" +
+			"		    }\n" +
+			"	    };\n" +
+			"   }\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/Y.java",
+			"public class Y {\n" +
+			"    public static void goo(I i) {};\n" +
+			"    public static void goo() {};\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"public interface I {\n" +
+			"    public void foo();\n" +
+			"}\n"
+		);
+		
+		IType type = getCompilationUnit("/P/src/I.java").getType("I");
+		IMethod method = type.getMethod("foo", new String[0]);
+		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
+		assertSearchResults("");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
 
 // Add new tests in JavaSearchBugs8Tests
 }
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
index e356924..650dd77 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Parser.java
@@ -4725,21 +4725,35 @@ protected void consumeInterfaceMethodDeclaration(boolean hasSemicolonBody) {
 	this.intStack :
 	*/
 
+	int explicitDeclarations = 0;
+	Statement[] statements = null;
 	if (!hasSemicolonBody) {
 		// pop the position of the {  (body of the method) pushed in block decl
 		this.intPtr--;
-		// retrieve end position of method declarator
-
+		this.intPtr--;
+		
+		explicitDeclarations = this.realBlockStack[this.realBlockPtr--];
+		
 		//statements
-		this.realBlockPtr--;
 		int length;
 		if ((length = this.astLengthStack[this.astLengthPtr--]) != 0) {
-			this.astPtr -= length;
+			if (this.options.ignoreMethodBodies) {
+				this.astPtr -= length;
+			} else {
+				System.arraycopy(
+					this.astStack,
+					(this.astPtr -= length) + 1,
+					statements = new Statement[length],
+					0,
+					length);
+			}
 		}
 	}
 
 	//watch for } that could be given as a unicode ! ( u007D is '}' )
 	MethodDeclaration md = (MethodDeclaration) this.astStack[this.astPtr];
+	md.statements = statements;
+	md.explicitDeclarations = explicitDeclarations;
 	md.bodyEnd = this.endPosition;
 	md.declarationSourceEnd = flushCommentsDefinedPriorTo(this.endStatementPosition);
 	
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchDocument.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchDocument.java
index 81fe194..479c3e2 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchDocument.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchDocument.java
@@ -32,7 +32,7 @@ public abstract class SearchDocument {
 	private SourceElementParser parser;
 	private String documentPath;
 	private SearchParticipant participant;
-	public boolean shouldIndexResolvedDocument = false;
+	private boolean shouldIndexResolvedDocument = false;
 
 	/**
 	 * Creates a new search document. The given document path is a string that uniquely identifies the document.
@@ -168,4 +168,19 @@ public abstract class SearchDocument {
 	public void setParser(SourceElementParser sourceElementParser) {
 		this.parser = sourceElementParser;
 	}
+
+	/** Flags the document as requiring indexing after symbol and type resolution. A participant would be asked 
+	 *  to resolve the document via {@link SearchParticipant#resolveDocument} and to index the document adding 
+	 *  additional entries via {@link SearchParticipant#indexResolvedDocument} 
+	 *  
+	 * @since 3.9 BETA_JAVA8 
+	 */
+	public void requireIndexingResolvedDocument() {
+		this.shouldIndexResolvedDocument = true;
+	}
+	
+	/* non API */
+	public boolean shouldIndexResolvedDocument() {
+		return this.shouldIndexResolvedDocument;
+	}
 }
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchParticipant.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchParticipant.java
index 7ae9e2c..1a11e51 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchParticipant.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/core/search/SearchParticipant.java
@@ -159,6 +159,8 @@ public abstract class SearchParticipant {
 	 *
 	 * @param document the document to index
 	 * @param indexLocation the location in the file system to the index
+	 * 
+	 * @since 3.9 BETA_JAVA8
 	 */
 	public void indexResolvedDocument(SearchDocument document, IPath indexLocation) {
 		// do nothing, subtypes should do the "appropriate thing"
@@ -221,6 +223,7 @@ public abstract class SearchParticipant {
 	 * @param document the document to resolve
 	 * @since 3.9 BETA_JAVA8
 	 * @see SearchParticipant#indexResolvedDocument
+	 * @see SearchDocument#requireIndexingResolvedDocument
 	 */
 	public void resolveDocument(SearchDocument document) {
 		// do nothing, subtypes should do the "appropriate thing"
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
index e29b5a7..db71342 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/index/DiskIndex.java
@@ -1,10 +1,14 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
+ * This is an implementation of an early-draft specification developed under the Java
+ * Community Process (JCP) and is made available for testing and evaluation purposes
+ * only. The code is not compatible with any specification of the JCP.
+ * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *******************************************************************************/
@@ -46,7 +50,7 @@ private int bufferIndex, bufferEnd; // used when reading from the file into the
 private int streamEnd; // used when writing data from the streamBuffer to the file
 char separator = Index.DEFAULT_SEPARATOR;
 
-public static final String SIGNATURE= "INDEX VERSION 1.126"; //$NON-NLS-1$
+public static final String SIGNATURE= "INDEX VERSION 1.127"; //$NON-NLS-1$
 private static final char[] SIGNATURE_CHARS = SIGNATURE.toCharArray();
 public static boolean DEBUG = false;
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
index 3df2ba3..5cca8dd 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexManager.java
@@ -989,7 +989,7 @@ public void scheduleDocumentIndexing(final SearchDocument searchDocument, IPath
 			} finally {
 				monitor.exitWrite(); // free write lock
 			}
-			if (searchDocument.shouldIndexResolvedDocument) {
+			if (searchDocument.shouldIndexResolvedDocument()) {
 				indexResolvedDocument(searchDocument, searchParticipant, index, indexPath);
 			}
 			return true;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
index 6f26f84..fdd412c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/SourceIndexer.java
@@ -18,9 +18,8 @@ import org.eclipse.core.resources.IProject;
 import org.eclipse.core.resources.ResourcesPlugin;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.Path;
-import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IType;
 import org.eclipse.jdt.core.JavaCore;
-import org.eclipse.jdt.core.JavaModelException;
 import org.eclipse.jdt.core.search.SearchDocument;
 import org.eclipse.jdt.internal.compiler.ASTVisitor;
 import org.eclipse.jdt.internal.compiler.CompilationResult;
@@ -33,6 +32,7 @@ import org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
 import org.eclipse.jdt.internal.compiler.env.ISourceType;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.ITypeRequestor;
@@ -41,17 +41,16 @@ import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.parser.Parser;
-import org.eclipse.jdt.internal.compiler.parser.SourceTypeConverter;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
 import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
 import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
-import org.eclipse.jdt.internal.core.CancelableNameEnvironment;
 import org.eclipse.jdt.internal.core.DefaultWorkingCopyOwner;
 import org.eclipse.jdt.internal.core.JavaModel;
 import org.eclipse.jdt.internal.core.JavaModelManager;
 import org.eclipse.jdt.internal.core.JavaProject;
 import org.eclipse.jdt.internal.core.SourceTypeElementInfo;
 import org.eclipse.jdt.internal.core.jdom.CompilationUnit;
+import org.eclipse.jdt.internal.core.search.matching.JavaSearchNameEnvironment;
 import org.eclipse.jdt.internal.core.search.matching.MethodPattern;
 import org.eclipse.jdt.internal.core.search.processing.JobManager;
 
@@ -62,6 +61,7 @@ import org.eclipse.jdt.internal.core.search.processing.JobManager;
  * - Interfaces;<br>
  * - Methods;<br>
  * - Fields;<br>
+ * - Lambda expressions;<br>
  * References to:<br>
  * - Methods (with number of arguments); <br>
  * - Fields;<br>
@@ -72,10 +72,11 @@ public class SourceIndexer extends AbstractIndexer implements ITypeRequestor, Su
 
 	private LookupEnvironment lookupEnvironment;
 	private CompilerOptions options;
-	private CompilationUnitDeclaration cu;
 	public ISourceElementRequestor requestor;
 	private Parser basicParser;
-	private ProblemReporter problemReporter;
+	private CompilationUnit compilationUnit;
+	private CompilationUnitDeclaration cud;
+	private static final boolean DEBUG = false;
 	
 	public SourceIndexer(SearchDocument document) {
 		super(document);
@@ -103,46 +104,16 @@ public class SourceIndexer extends AbstractIndexer implements ITypeRequestor, Su
 			// ignore
 		}
 		if (source == null || name == null) return; // could not retrieve document info (e.g. resource was discarded)
-		CompilationUnit compilationUnit = new CompilationUnit(source, name);
+		this.compilationUnit = new CompilationUnit(source, name);
 		try {
-			this.cu = parser.parseCompilationUnit(compilationUnit, true/*full parse*/, null/*no progress*/);
-			// this.document.shouldIndexResolvedDocument = this.cu.hasFunctionalTypes();
+			if (parser.parseCompilationUnit(this.compilationUnit, true, null).hasFunctionalTypes())
+				this.document.requireIndexingResolvedDocument();
 		} catch (Exception e) {
 			if (JobManager.VERBOSE) {
 				e.printStackTrace();
 			}
 		}
 	}
-
-	public void resolveDocument() {
-		IPath path = new Path(this.document.getPath());
-		IProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(path.segment(0));
-		JavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();
-		JavaProject javaProject = (JavaProject) model.getJavaProject(project);
-		try {
-			CancelableNameEnvironment nameEnvironment;
-			nameEnvironment = new CancelableNameEnvironment(javaProject, DefaultWorkingCopyOwner.PRIMARY, null);
-			this.options = new CompilerOptions(javaProject.getOptions(true));
-			this.problemReporter =
-					new ProblemReporter(
-						DefaultErrorHandlingPolicies.proceedWithAllProblems(),
-						this.options,
-						new DefaultProblemFactory());
-			this.lookupEnvironment = new LookupEnvironment(this, this.options, this.problemReporter, nameEnvironment);
-		} catch (JavaModelException e) {
-			if (JobManager.VERBOSE) {
-				e.printStackTrace();
-			}
-			this.cu = null;
-			return;
-		}
-		this.lookupEnvironment.buildTypeBindings(this.cu, null);
-		this.lookupEnvironment.completeTypeBindings();
-		if (this.cu.scope != null) {
-			this.cu.scope.faultInTypes();
-			this.cu.resolve();
-		}
-	}
 	
 	public void accept(IBinaryType binaryType, PackageBinding packageBinding, AccessRestriction accessRestriction) {
 		this.lookupEnvironment.createBinaryTypeFrom(binaryType, packageBinding, accessRestriction);
@@ -150,65 +121,72 @@ public class SourceIndexer extends AbstractIndexer implements ITypeRequestor, Su
 
 	public void accept(ICompilationUnit unit, AccessRestriction accessRestriction) {
 		CompilationResult unitResult = new CompilationResult(unit, 1, 1, this.options.maxProblemsPerUnit);
-		CompilationUnitDeclaration parsedUnit = basicParser().dietParse(unit, unitResult);
+		CompilationUnitDeclaration parsedUnit = this.basicParser.dietParse(unit, unitResult);
 		this.lookupEnvironment.buildTypeBindings(parsedUnit, accessRestriction);
 		this.lookupEnvironment.completeTypeBindings(parsedUnit, true);
 	}
 
 	public void accept(ISourceType[] sourceTypes, PackageBinding packageBinding, AccessRestriction accessRestriction) {
-		// ensure to jump back to toplevel type for first one (could be a member)
-		while (sourceTypes[0].getEnclosingType() != null) {
-			sourceTypes[0] = sourceTypes[0].getEnclosingType();
-		}
-
-		CompilationResult result =
-			new CompilationResult(sourceTypes[0].getFileName(), 1, 1, this.options.maxProblemsPerUnit);
-		
-		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=305259, build the compilation unit in its own sand box.
-		final long savedComplianceLevel = this.options.complianceLevel;
-		final long savedSourceLevel = this.options.sourceLevel;
-		
+		ISourceType sourceType = sourceTypes[0];
+		while (sourceType.getEnclosingType() != null)
+			sourceType = sourceType.getEnclosingType();
+		SourceTypeElementInfo elementInfo = (SourceTypeElementInfo) sourceType;
+		IType type = elementInfo.getHandle();
+		ICompilationUnit sourceUnit = (ICompilationUnit) type.getCompilationUnit();
+		accept(sourceUnit, accessRestriction);		
+	}
+	
+	public void resolveDocument() {
 		try {
-			IJavaProject project = ((SourceTypeElementInfo) sourceTypes[0]).getHandle().getJavaProject();
-			this.options.complianceLevel = CompilerOptions.versionToJdkLevel(project.getOption(JavaCore.COMPILER_COMPLIANCE, true));
-			this.options.sourceLevel = CompilerOptions.versionToJdkLevel(project.getOption(JavaCore.COMPILER_SOURCE, true));
+			IPath path = new Path(this.document.getPath());
+			IProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(path.segment(0));
+			JavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();
+			JavaProject javaProject = (JavaProject) model.getJavaProject(project);
+
+			this.options = new CompilerOptions(javaProject.getOptions(true));
+			ProblemReporter problemReporter =
+					new ProblemReporter(
+							DefaultErrorHandlingPolicies.proceedWithAllProblems(),
+							this.options,
+							new DefaultProblemFactory());
+
+			// Re-parse using normal parser, IndexingParser swallows several nodes, see comment above class.
+			this.basicParser = new Parser(problemReporter, false);
+			this.basicParser.reportOnlyOneSyntaxError = true;
+			this.cud = this.basicParser.parse(this.compilationUnit, new CompilationResult(this.compilationUnit, 0, 0, this.options.maxProblemsPerUnit));
 
-			// need to hold onto this
-			CompilationUnitDeclaration unit =
-				SourceTypeConverter.buildCompilationUnit(
-						sourceTypes,//sourceTypes[0] is always toplevel here
-						SourceTypeConverter.FIELD_AND_METHOD // need field and methods
-						| SourceTypeConverter.MEMBER_TYPE // need member types
-						| SourceTypeConverter.FIELD_INITIALIZATION // need field initialization
-						| SourceTypeConverter.LOCAL_TYPE, // need local type
-						this.lookupEnvironment.problemReporter,
-						result);
+			// Use a non model name environment to avoid locks, monitors and such.
+			INameEnvironment nameEnvironment = new JavaSearchNameEnvironment(javaProject, JavaModelManager.getJavaModelManager().getWorkingCopies(DefaultWorkingCopyOwner.PRIMARY, true/*add primary WCs*/));
+			this.lookupEnvironment = new LookupEnvironment(this, this.options, problemReporter, nameEnvironment);
 
-			if (unit != null) {
-				this.lookupEnvironment.buildTypeBindings(unit, accessRestriction);
-				this.lookupEnvironment.completeTypeBindings(unit);
+			this.lookupEnvironment.buildTypeBindings(this.cud, null);
+			this.lookupEnvironment.completeTypeBindings();
+			this.cud.scope.faultInTypes();
+			this.cud.resolve();
+		} catch (Exception e) {
+			if (JobManager.VERBOSE) {
+				e.printStackTrace();
 			}
-		} finally {
-			this.options.complianceLevel = savedComplianceLevel;
-			this.options.sourceLevel = savedSourceLevel;
-		}
-	}
-	
-	protected Parser basicParser() {
-		if (this.basicParser == null) {
-			this.basicParser = new Parser(this.problemReporter, false);
-			this.basicParser.reportOnlyOneSyntaxError = true;
 		}
-		return this.basicParser;
 	}
 
-
-public void indexResolvedDocument() {
-	if (this.cu != null && this.cu.scope != null) {
-		final ASTVisitor visitor = new ASTVisitor() {
+	public void indexResolvedDocument() {
+		try {
+			if (DEBUG) {
+				System.out.println(new String(this.cud.compilationResult.fileName) + ':');
+			}
+			final ASTVisitor visitor = new ASTVisitor() {
 				public boolean visit(LambdaExpression lambdaExpression, BlockScope blockScope) {
 					if (lambdaExpression.binding != null && lambdaExpression.binding.isValidBinding()) {
+						if (DEBUG) {
+							System.out.println('\t' + new String(lambdaExpression.descriptor.declaringClass.sourceName()) + '.' + 
+									new String(lambdaExpression.descriptor.selector) + "-> {}"); //$NON-NLS-1$
+						}
 						SourceIndexer.this.addIndexEntry(IIndexConstants.METHOD_DECL, MethodPattern.createIndexKey(lambdaExpression.descriptor.selector, lambdaExpression.descriptor.parameters.length));
+					} else {
+						if (DEBUG) {
+							System.out.println("\tnull/bad binding in lambda"); //$NON-NLS-1$
+						}
 					}
 					return true;
 				}
@@ -217,15 +195,28 @@ public void indexResolvedDocument() {
 						return true;
 					MethodBinding binding = referenceExpression.getMethodBinding();
 					if (binding != null && binding.isValidBinding()) {
+						if (DEBUG) {
+							System.out.println('\t' + new String(referenceExpression.descriptor.declaringClass.sourceName()) + "::"  //$NON-NLS-1$
+									+ new String(referenceExpression.descriptor.selector) + " == " + new String(binding.declaringClass.sourceName()) + '.' + //$NON-NLS-1$
+									new String(binding.selector));
+						}
 						if (referenceExpression.isMethodReference())
 							SourceIndexer.this.addMethodReference(binding.selector, binding.parameters.length);
 						else
 							SourceIndexer.this.addConstructorReference(binding.declaringClass.sourceName(), binding.parameters.length);
+					} else {
+						if (DEBUG) {
+							System.out.println("\tnull/bad binding in reference expression"); //$NON-NLS-1$
+						}
 					}
 					return true;
 				}
 			};
-		this.cu.traverse(visitor , this.cu.scope, false);
+			this.cud.traverse(visitor , this.cud.scope, false);
+		} catch (Exception e) {
+			if (JobManager.VERBOSE) {
+				e.printStackTrace();
+			}
+		}
 	}
 }
-}
commit ca349eb1728a54f5c4569863d8f64340b099c4ce
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sun Mar 2 04:05:34 2014 +0530

    Fixed Bug 400905 - [1.8][search] Search engine skips functional
    interface types.

428	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
4	2	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java
7	4	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
1	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java
36	6	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
13	1	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
5	3	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MemberDeclarationVisitor.java
4	5	org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
index 6d37a3a..0720d32 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchBugs8Tests.java
@@ -104,6 +104,7 @@ public static Test suite() {
 	suite.addTest(new JavaSearchBugs8Tests("testBug427537a"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug427677"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0001"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0001a"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0002"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0003"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400904_0004"));
@@ -125,12 +126,19 @@ public static Test suite() {
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0005"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0006"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0007"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0007a"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0008"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0009"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0010"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0011"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0012"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0013"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0013a"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0013b"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0013c"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0013d"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0013e"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0013f"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0014"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0015"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0016"));
@@ -141,6 +149,13 @@ public static Test suite() {
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0021"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0022"));
 	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0023"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0024"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0025"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0026"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0027"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0028"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0029"));
+	suite.addTest(new JavaSearchBugs8Tests("testBug400905_0030"));
 	return suite;
 }
 class TestCollector extends JavaSearchResultCollector {
@@ -1861,6 +1876,35 @@ public void testBug400904_0001() throws CoreException {
 	);	
 }
 
+public void testBug400904_0001a() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/b400904/X.java",
+			"interface I {\n" +
+			"    void foo(int x);\n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"    public static void main(String [] args) {\n" +
+			"	new X().doit();\n" +
+			"    }\n" +
+			"    void doit() {\n" +
+			"        I i = super::foo;\n" +
+			"        i.foo(10); \n" +
+			"    }\n" +
+			"}\n" +
+			"class Y {\n" +
+			"    public void foo(int x) {\n" +
+			"	System.out.println(x);\n" +
+			"    }\n" +
+			"}\n"
+	);
+	IType type = this.workingCopies[0].getType("Y");
+	IMethod method = type.getMethod("foo", new String[] {"I"});
+	search(method, SUPER_REFERENCE);
+	assertSearchResults(
+			"src/b400904/X.java void b400904.X.doit() [super::foo] EXACT_MATCH"
+	);	
+}
+
 /**
  * @bug 400904
  * @test tests search for Reference expression - super:: form, with type arguments
@@ -2551,7 +2595,7 @@ public void testBug400905_0005() throws CoreException {
 	IMethod method = type.getMethod("bar", new String[] {});
 	search(method, DECLARATIONS, EXACT_RULE);
 	assertSearchResults(
-			"src/b400905/X.java void void b400905.X.main(String[]):<lambda>#2.lambda$2() [() /* bar */ ->] EXACT_MATCH\n" + 
+			"src/b400905/X.java void b400905/Y void b400905.X.main(String[]):<lambda>#1.lambda$1():<lambda>#2.lambda$2() [() /* bar */ ->] EXACT_MATCH\n" + 
 			"src/b400905/Y.java void b400905.Y.bar() [bar] EXACT_MATCH"
 	);	
 }
@@ -2637,6 +2681,38 @@ public void testBug400905_0007() throws CoreException {
 		deleteProject("P");
 	}
 }
+public void testBug400905_0007a() throws CoreException {
+	try {
+		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL18_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/X.java",
+			"public class X  {\n" +
+			"    void foo() {\n" +
+			"        I i = Y::new;\n" + 
+			"    }\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/Y.java",
+			"public class Y extends X {\n" +
+			"    Y(int x) {};\n" +
+			"    Y() {};\n" +
+			"}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"interface I {\n" +
+			"    X foo();\n" +
+			"}\n"
+		);
+		IMethod method = getCompilationUnit("/P/src/Y.java").getType("Y").getMethod("Y", new String[] {"I"});
+		search(method, REFERENCES, EXACT_RULE, SearchEngine.createJavaSearchScope(new IJavaProject[] {project}), this.resultCollector);
+		assertSearchResults("");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
 public void testBug400905_0008() throws CoreException {
 	try {
 		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL18_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
@@ -2842,6 +2918,213 @@ public void testBug400905_0013() throws CoreException {
 		deleteProject("P");
 	}
 }
+// verify that nested lambdas are found and they are linked properly.
+public void testBug400905_0013a() throws CoreException {
+	try {
+		createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL18_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/X.java",
+			"public class X {\n" +
+			"   void zoo() {\n" +
+			"	    I i = () /*1*/-> {\n" +
+			"                 I i2 = () /*2*/-> 10;\n" +
+			"                 return 0;\n" +
+			"       };\n" +
+			"   }\n" +
+			"}\n" +
+			" class Y {}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"public interface I {\n" +
+			"    public int doit();\n" +
+			"}\n"
+		);
+		
+		IType type = getCompilationUnit("/P/src/I.java").getType("I");
+		IMethod method = type.getMethod("doit", new String[0]);
+		search(method, DECLARATIONS|IGNORE_DECLARING_TYPE|IGNORE_RETURN_TYPE, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
+		assertSearchResults("src/I.java int I.doit() [doit] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda>#1.lambda$1() [() /*1*/->] EXACT_MATCH\n" + 
+				"src/X.java int int void X.zoo():<lambda>#1.lambda$1():<lambda>#2.lambda$2() [() /*2*/->] EXACT_MATCH");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
+// Verify that nested lambdas are found and they are linked properly. (hierarchy scope)
+public void testBug400905_0013b() throws CoreException {
+	try {
+		createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL18_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/X.java",
+			"public class X {\n" +
+			"   void zoo() {\n" +
+			"	    I i = (X x2) /*1*/-> {\n" +
+			"                 I i2 = (X x3) /*2*/-> 10;\n" +
+			"                 return 0;\n" +
+			"       };\n" +
+			"   }\n" +
+			"}\n" +
+			" class Y {}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"public interface I {\n" +
+			"    public int doit(X x1);\n" +
+			"}\n"
+		);
+		
+		IType type = getCompilationUnit("/P/src/X.java").getType("X");
+		search(type, REFERENCES, SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_ERASURE_MATCH, SearchEngine.createHierarchyScope(type), this.resultCollector);
+		assertSearchResults("src/X.java int int void X.zoo():<lambda>#1.lambda$1(X):<lambda>#2.lambda$2(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
+// Verify that nested lambdas are found and they are linked properly. (java search scope - type)
+public void testBug400905_0013c() throws CoreException {
+	try {
+		createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL18_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/X.java",
+			"public class X {\n" +
+			"   void zoo() {\n" +
+			"	    I i = (X x2) /*1*/-> {\n" +
+			"                 I i2 = (X x3) /*2*/-> 10;\n" +
+			"                 return 0;\n" +
+			"       };\n" +
+			"   }\n" +
+			"}\n" +
+			" class Y {}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"public interface I {\n" +
+			"    public int doit(X x1);\n" +
+			"}\n"
+		);
+		
+		IType type = getCompilationUnit("/P/src/X.java").getType("X");
+		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {type}), this.resultCollector);
+		assertSearchResults("src/X.java int int void X.zoo():<lambda>#1.lambda$1(X):<lambda>#2.lambda$2(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
+// Verify that nested lambdas are found and they are linked properly. (java search scope - project)
+public void testBug400905_0013d() throws CoreException {
+	try {
+		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL18_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/X.java",
+			"public class X {\n" +
+			"   void zoo() {\n" +
+			"	    I i = (X x2) /*1*/-> {\n" +
+			"                 I i2 = (X x3) /*2*/-> 10;\n" +
+			"                 return 0;\n" +
+			"       };\n" +
+			"   }\n" +
+			"}\n" +
+			" class Y {}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"public interface I {\n" +
+			"    public int doit(X x1);\n" +
+			"}\n"
+		);
+		
+		IType type = getCompilationUnit("/P/src/X.java").getType("X");
+		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {project}), this.resultCollector);
+		assertSearchResults("src/I.java int I.doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int int void X.zoo():<lambda>#1.lambda$1(X):<lambda>#2.lambda$2(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
+// Verify that nested lambdas are found and they are linked properly. (java search scope - project)
+public void testBug400905_0013e() throws CoreException {
+	try {
+		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL18_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/X.java",
+			"public class X {\n" +
+			"   void zoo() {\n" +
+			"	    I i = (X x2) /*1*/-> {\n" +
+			"                 I i2 = (X x3) /*2*/-> 10;\n" +
+			"                 class Q {\n" +
+			"                     X x;\n" +
+			"                 }\n" +
+			"                 return 0;\n" +
+			"       };\n" +
+			"   }\n" +
+			"}\n" +
+			" class Y {}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"public interface I {\n" +
+			"    public int doit(X x1);\n" +
+			"}\n"
+		);
+		
+		IType type = getCompilationUnit("/P/src/X.java").getType("X");
+		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {project}), this.resultCollector);
+		assertSearchResults("src/I.java int I.doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int int void X.zoo():<lambda>#1.lambda$1(X):<lambda>#2.lambda$2(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X):Q#1.x [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
+// Verify that nested lambdas are found and they are linked properly. (java search scope - project)
+public void testBug400905_0013f() throws CoreException {
+	try {
+		IJavaProject project = createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL18_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
+		createFile(
+			"/P/src/X.java",
+			"public class X {\n" +
+			"   void zoo() {\n" +
+			"	    I i = (X x2) /*1*/-> {\n" +
+			"                 X x2;\n" +
+			"                 I i2 = (X x3) /*2*/-> 10;\n" +
+			"                 class Q {\n" +
+			"                     X x;\n" +
+			"                 }\n" +
+			"                 return 0;\n" +
+			"       };\n" +
+			"   }\n" +
+			"}\n" +
+			" class Y {}\n"
+		);
+		createFile(
+			"/P/src/I.java",
+			"public interface I {\n" +
+			"    public int doit(X x1);\n" +
+			"}\n"
+		);
+		
+		IType type = getCompilationUnit("/P/src/X.java").getType("X");
+		search(type, REFERENCES, SearchEngine.createJavaSearchScope(new IJavaElement[] {project}), this.resultCollector);
+		assertSearchResults("src/I.java int I.doit(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int int void X.zoo():<lambda>#1.lambda$1(X):<lambda>#2.lambda$2(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X):Q#1.x [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH\n" + 
+				"src/X.java int void X.zoo():<lambda>#1.lambda$1(X) [X] EXACT_MATCH");
+	}
+	finally {
+		deleteProject("P");
+	}
+}
 public void testBug400905_0014() throws CoreException {
 	try {
 		createJavaProject("P", new String[] { "", "src"}, new String[] {"JCL18_LIB"}, null, null, "bin", null, null, new String[][] {new String[] {"src/"}, new String[0]}, "1.8");
@@ -3142,6 +3425,150 @@ public void testBug400905_0023() throws CoreException {
 			"src/test/Test.java int void test.X.main(String[]):<lambda>#3.lambda$3(int) [(x) /* local */ ->] EXACT_MATCH"
 	);
 }
+public void testBug400905_0024() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/test/Test.java",
+			"interface I { \n" +
+			"	int thrice(int x);\n" +
+			"}\n" +
+			"public class X {\n" +
+			"	static int goo(int x) { return 3 * x; } \n" +
+			"	public static void main(String[] args) { \n" +
+			"		I i = X::goo;\n" +
+			"	}\n" +
+			"}\n"
+	);
+	
+	search(this.workingCopies[0].getType("X").getMethod("goo", new String[] { "I" }), THIS_REFERENCE);
+	assertSearchResults("");
+}
+public void testBug400905_0025() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/test/Test.java",
+			"interface I { \n" +
+			"	int thrice(int p);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	int goo(int x) { return 3 * x; } \n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public void main(String[] args) { \n" +
+			"		I i = this::goo;\n" +
+			"       i = super::goo;\n" +
+			"	}\n" +
+			"}\n"
+	);
+	
+	search(this.workingCopies[0].getType("Y").getMethod("goo", new String[] { "I" }), THIS_REFERENCE);
+	assertSearchResults("src/test/Test.java void test.X.main(String[]) [this::goo] EXACT_MATCH");
+}
+public void testBug400905_0026() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/test/Test.java",
+			"interface I { \n" +
+			"	int thrice(int p);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	int goo(int x) { return 3 * x; } \n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public void main(String[] args) { \n" +
+			"		I i = this::goo;\n" +
+			"       i = super::goo;\n" +
+			"	}\n" +
+			"}\n"
+	);
+	
+	search(this.workingCopies[0].getType("Y").getMethod("goo", new String[] { "I" }), SUPER_REFERENCE);
+	assertSearchResults("src/test/Test.java void test.X.main(String[]) [super::goo] EXACT_MATCH");
+}
+public void testBug400905_0027() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/test/Test.java",
+			"interface I { \n" +
+			"	int thrice(int p);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	int goo(int x) { return 3 * x; } \n" +
+			"}\n" +
+			"public class X extends Y {\n" +
+			"	public void main(String[] args) { \n" +
+			"		I i = this::goo;\n" +
+			"       i = super::goo;\n" +
+			"	}\n" +
+			"}\n"
+	);
+	
+	search(this.workingCopies[0].getType("Y").getMethod("goo", new String[] { "I" }), QUALIFIED_REFERENCE);
+	assertSearchResults("");
+}
+public void testBug400905_0028() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/test/Test.java",
+			"interface I { \n" +
+			"	int thrice(int p);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	static class Z {\n" +
+			"		static int goo(int x) { return 3 * x; }   \n" +
+			"		I i = Z::goo;\n" +
+			"   }\n" +
+			"}\n" +
+			"public class X extends Y.Z {\n" +
+			"	public void main(String[] args) { \n" +
+			"		I i = Y.Z::goo;\n" +
+			"	}\n" +
+			"}\n"
+	);
+	
+	search(this.workingCopies[0].getType("Y").getType("Z").getMethod("goo", new String[] { "I" }), THIS_REFERENCE | SUPER_REFERENCE | QUALIFIED_REFERENCE);
+	assertSearchResults("src/test/Test.java void test.X.main(String[]) [Y.Z::goo] EXACT_MATCH");
+}
+public void testBug400905_0029() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/test/Test.java",
+			"interface I { \n" +
+			"	int thrice(int p);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	static class Z {\n" +
+			"		static int goo(int x) { return 3 * x; }   \n" +
+			"		I i = Z::goo;\n" +
+			"   }\n" +
+			"}\n" +
+			"public class X extends Y.Z {\n" +
+			"	public void main(String[] args) { \n" +
+			"		I i = Y.Z::goo;\n" +
+			"	}\n" +
+			"}\n"
+	);
+	
+	search(this.workingCopies[0].getType("Y").getType("Z").getMethod("goo", new String[] { "I" }), REFERENCES, EXACT_RULE);
+	assertSearchResults("src/test/Test.java test.Y$Z.i [Z::goo] EXACT_MATCH\n" + 
+			"src/test/Test.java void test.X.main(String[]) [Y.Z::goo] EXACT_MATCH");
+}
+public void testBug400905_0030() throws CoreException {
+	this.workingCopies = new ICompilationUnit[1];
+	this.workingCopies[0] = getWorkingCopy("/JavaSearchBugs/src/test/Test.java",
+			"interface I { \n" +
+			"	int thrice(int p);\n" +
+			"}\n" +
+			"class Y {\n" +
+			"	static class Z {\n" +
+			"		static int goo(int x) { return 3 * x; }   \n" +
+			"		I i = Z::goo;\n" +
+			"   }\n" +
+			"}\n" +
+			"public class X extends Y.Z {\n" +
+			"	public void main(String[] args) { \n" +
+			"		I i = Y.Z::goo;\n" +
+			"	}\n" +
+			"}\n"
+	);
+	
+	search(this.workingCopies[0].getType("Y").getType("Z").getMethod("goo", new String[] { "I" }), IMPLICIT_THIS_REFERENCE);
+	assertSearchResults("");
+}
 // Add new tests in JavaSearchBugs8Tests
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 759745e..3f1ee4d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -93,10 +93,10 @@ import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 
 @SuppressWarnings({"rawtypes", "unchecked"})
 public class LambdaExpression extends FunctionalExpression implements ReferenceContext, ProblemSeverities {
-	private Argument [] arguments;
+	public Argument [] arguments;
 	private TypeBinding [] argumentTypes;
 	private int arrowPosition;
-	private Statement body;
+	public Statement body;
 	public boolean hasParentheses;
 	public MethodScope scope;
 	boolean voidCompatible = true;
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java
index a351945..c8ab4fe 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/hierarchy/HierarchyResolver.java
@@ -488,8 +488,10 @@ private void rememberAllTypes(CompilationUnitDeclaration parsedUnit, org.eclipse
 		for (int i = 0; i < parsedUnit.functionalExpressionsCount; i++) {
 			if (parsedUnit.functionalExpressions[i] instanceof LambdaExpression) {
 				final LambdaExpression expression = (LambdaExpression) parsedUnit.functionalExpressions[i];
-				IType typeHandle = (IType)factory.createLambdaTypeElement(expression, cu, existingElements, knownScopes);
-				remember(typeHandle, expression.getTypeBinding());
+				if (expression.binding != null && expression.binding.isValidBinding()) {
+					IType typeHandle = (IType)factory.createLambdaTypeElement(expression, cu, existingElements, knownScopes);
+					remember(typeHandle, expression.getTypeBinding());
+				}
 			}
 		}
 	}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
index 5bd43e0..5a1089f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/HandleFactory.java
@@ -211,10 +211,13 @@ public class HandleFactory {
 				break;
 			case Scope.METHOD_SCOPE :
 				if (scope.isLambdaScope()) {
-					parentElement = createElement(scope.parent, elementPosition, unit, existingElements, knownScopes);
-					newElement = new org.eclipse.jdt.internal.core.LambdaExpression((JavaElement) parentElement, (LambdaExpression) scope.referenceContext()).getMethod();
-					knownScopes.put(scope, newElement);
-					return newElement;
+					LambdaExpression expression = (LambdaExpression) scope.referenceContext();
+					if (expression.binding != null && expression.binding.isValidBinding()) { // chain in lambda element only if resolved properly.
+						parentElement = createElement(scope.parent, elementPosition, unit, existingElements, knownScopes);
+						newElement = new org.eclipse.jdt.internal.core.LambdaExpression((JavaElement) parentElement, expression).getMethod();
+						knownScopes.put(scope, newElement);
+						return newElement;
+					}
 				}
 				IType parentType = (IType) createElement(scope.parent, elementPosition, unit, existingElements, knownScopes);
 				MethodScope methodScope = (MethodScope) scope;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java
index 5b49f5b..1e9efc9 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorLocator.java
@@ -93,7 +93,7 @@ public int match(MessageSend msgSend, MatchingNodeSet nodeSet)  {
 	return IMPOSSIBLE_MATCH;
 }
 public int match(ReferenceExpression node, MatchingNodeSet nodeSet) {
-	if (!this.pattern.findReferences) return IMPOSSIBLE_MATCH;
+	if (!this.pattern.findReferences || node.isMethodReference()) return IMPOSSIBLE_MATCH;
 	return nodeSet.addMatch(node, this.pattern.mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH);
 }
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
index 9d91647..0e14928 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java
@@ -2204,9 +2204,11 @@ protected void reportBinaryMemberDeclaration(IResource resource, IMember binaryM
 	report(match);
 }
 
-protected void reportMatching(LambdaExpression lambdaExpression,  IJavaElement parent, int accuracy, MatchingNodeSet nodeSet) throws CoreException {
+protected void reportMatching(LambdaExpression lambdaExpression,  IJavaElement parent, int accuracy, MatchingNodeSet nodeSet, boolean typeInHierarchy) throws CoreException {
+	IJavaElement enclosingElement = null;
+	// Report the lambda declaration itself.
 	if (accuracy > -1) {
-		IJavaElement enclosingElement = createHandle(lambdaExpression, parent);
+		enclosingElement = createHandle(lambdaExpression, parent);
 		if (enclosingElement != null) { // skip if unable to find method
 			// compute source positions of the selector
 			int nameSourceStart = lambdaExpression.sourceStart;
@@ -2220,6 +2222,34 @@ protected void reportMatching(LambdaExpression lambdaExpression,  IJavaElement p
 			}
 		}
 	}
+	if (enclosingElement == null) {
+		enclosingElement = createHandle(lambdaExpression, parent);
+	}
+	// Traverse the lambda declaration to report matches inside, these matches if any should see the present lambda as the parent model element.
+	ASTNode[] nodes = typeInHierarchy ? nodeSet.matchingNodes(lambdaExpression.sourceStart, lambdaExpression.sourceEnd) : null;
+	boolean report = (this.matchContainer & PatternLocator.METHOD_CONTAINER) != 0 && encloses(enclosingElement);
+	MemberDeclarationVisitor declarationVisitor = new MemberDeclarationVisitor(enclosingElement, report ? nodes : null, nodeSet, this, typeInHierarchy);
+	
+	if (lambdaExpression.arguments != null) {
+		int argumentsLength = lambdaExpression.arguments.length;
+		for (int i = 0; i < argumentsLength; i++)
+			lambdaExpression.arguments[i].traverse(declarationVisitor, (BlockScope) null);
+	}
+
+	if (lambdaExpression.body != null) {
+		lambdaExpression.body.traverse(declarationVisitor, (BlockScope) null);
+	}
+	
+	// Report all nodes and remove them
+	if (nodes != null) {
+		int length = nodes.length;
+		for (int i = 0; i < length; i++) {
+			Integer level = (Integer) nodeSet.matchingNodes.removeKey(nodes[i]);
+			if (report && level != null) {
+				this.patternLocator.matchReportReference(nodes[i], enclosingElement, declarationVisitor.getLocalElement(i), declarationVisitor.getOtherElements(i), lambdaExpression.binding, level.intValue(), this);
+			}
+		}
+	}
 }
 /**
  * Visit the given method declaration and report the nodes that match exactly the
@@ -2269,7 +2299,7 @@ protected void reportMatching(AbstractMethodDeclaration method, TypeDeclaration
 		// and in local variables declaration
 		ASTNode[] nodes = typeInHierarchy ? nodeSet.matchingNodes(method.declarationSourceStart, method.declarationSourceEnd) : null;
 		boolean report = (this.matchContainer & PatternLocator.METHOD_CONTAINER) != 0 && encloses(enclosingElement);
-		MemberDeclarationVisitor declarationVisitor = new MemberDeclarationVisitor(enclosingElement, report ? nodes : null, nodeSet, this);
+		MemberDeclarationVisitor declarationVisitor = new MemberDeclarationVisitor(enclosingElement, report ? nodes : null, nodeSet, this, typeInHierarchy);
 		try {
 			method.traverse(declarationVisitor, (ClassScope) null);
 		} catch (WrappedCoreException e) {
@@ -2319,7 +2349,7 @@ protected void reportMatching(AbstractMethodDeclaration method, TypeDeclaration
 				if (encloses(enclosingElement)) {
 					if (this.pattern.mustResolve) {
 						// Visit only if the pattern must resolve
-						MemberDeclarationVisitor declarationVisitor = new MemberDeclarationVisitor(enclosingElement, nodes, nodeSet, this);
+						MemberDeclarationVisitor declarationVisitor = new MemberDeclarationVisitor(enclosingElement, nodes, nodeSet, this, typeInHierarchy);
 						method.traverse(declarationVisitor, (ClassScope) null);
 						int length = nodes.length;
 						for (int i = 0; i < length; i++) {
@@ -2577,7 +2607,7 @@ protected void reportMatching(FieldDeclaration field, FieldDeclaration[] otherFi
 		int fieldEnd = field.endPart2Position == 0 ? field.declarationSourceEnd : field.endPart2Position;
 		ASTNode[] nodes = typeInHierarchy ? nodeSet.matchingNodes(field.sourceStart, fieldEnd) : null;
 		boolean report = (this.matchContainer & PatternLocator.FIELD_CONTAINER) != 0 && encloses(enclosingElement);
-		MemberDeclarationVisitor declarationVisitor = new MemberDeclarationVisitor(enclosingElement, report ? nodes : null, nodeSet, this);
+		MemberDeclarationVisitor declarationVisitor = new MemberDeclarationVisitor(enclosingElement, report ? nodes : null, nodeSet, this, typeInHierarchy);
 		try {
 			field.traverse(declarationVisitor, (MethodScope) null);
 		} catch (WrappedCoreException e) {
@@ -2653,7 +2683,7 @@ protected void reportMatching(FieldDeclaration field, FieldDeclaration[] otherFi
 					enclosingElement = createHandle(field, type, parent);
 				}
 				if (encloses(enclosingElement)) {
-					MemberDeclarationVisitor declarationVisitor = new MemberDeclarationVisitor(enclosingElement, nodes, nodeSet, this);
+					MemberDeclarationVisitor declarationVisitor = new MemberDeclarationVisitor(enclosingElement, nodes, nodeSet, this, typeInHierarchy);
 					field.traverse(declarationVisitor, (MethodScope) null);
 					int length = nodes.length;
 					for (int i = 0; i < length; i++) {
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
index fbf3fb7..0cacc7b 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocatorParser.java
@@ -526,8 +526,20 @@ protected void consumePrimaryNoNewArrayWithName() {
 @Override
 protected void consumeReferenceExpression(ReferenceExpression referenceExpression) {
 	super.consumeReferenceExpression(referenceExpression);
-	if (this.patternFineGrain == 0 || (this.patternFineGrain & IJavaSearchConstants.THIS_REFERENCE) != 0) {
+	if (this.patternFineGrain == 0) {
 		this.patternLocator.match(referenceExpression, this.nodeSet);
+	} else if (referenceExpression.lhs.isThis()) {
+		if ((this.patternFineGrain & IJavaSearchConstants.THIS_REFERENCE) != 0) {
+			this.patternLocator.match(referenceExpression, this.nodeSet);
+		}
+	} else if (referenceExpression.lhs.isSuper()) {
+		if ((this.patternFineGrain & IJavaSearchConstants.SUPER_REFERENCE) != 0) {
+			this.patternLocator.match(referenceExpression, this.nodeSet);
+		}
+	} else if (referenceExpression.lhs instanceof QualifiedNameReference || referenceExpression.lhs instanceof QualifiedTypeReference) {
+		if ((this.patternFineGrain & IJavaSearchConstants.QUALIFIED_REFERENCE) != 0) {
+			this.patternLocator.match(referenceExpression, this.nodeSet);
+		} 
 	}
 }
 
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MemberDeclarationVisitor.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MemberDeclarationVisitor.java
index aa5bd47..8f8ac2c 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MemberDeclarationVisitor.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MemberDeclarationVisitor.java
@@ -52,9 +52,11 @@ class MemberDeclarationVisitor extends ASTVisitor {
 	IJavaElement[][] allOtherElements;
 	int ptr = -1;
 	int[] ptrs;
+	private boolean typeInHierarchy;
 
-public MemberDeclarationVisitor(IJavaElement element, ASTNode[] nodes, MatchingNodeSet set, MatchLocator locator) {
+public MemberDeclarationVisitor(IJavaElement element, ASTNode[] nodes, MatchingNodeSet set, MatchLocator locator, boolean typeInHierarchy) {
 	this.enclosingElement = element;
+	this.typeInHierarchy = typeInHierarchy;
 	this.nodeSet = set;
 	this.locator = locator;
 	if (nodes == null) {
@@ -211,11 +213,11 @@ public boolean visit(LambdaExpression lambdaExpression, BlockScope scope) {
 	Integer level = (Integer) this.nodeSet.matchingNodes.removeKey(lambdaExpression);
 	try {
 		if (lambdaExpression.binding != null && lambdaExpression.binding.isValidBinding())
-			this.locator.reportMatching(lambdaExpression, this.enclosingElement, level != null ? level.intValue() : -1, this.nodeSet);
+			this.locator.reportMatching(lambdaExpression, this.enclosingElement, level != null ? level.intValue() : -1, this.nodeSet, this.typeInHierarchy);
 	} catch (CoreException e) {
 		throw new WrappedCoreException(e);
 	}
-	return true;
+	return false; // Don't visit the children as they get traversed under control of reportMatching.
 }
 public boolean visit(LocalDeclaration declaration, BlockScope scope) {
     this.localDeclaration = declaration;
diff --git a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java
index dc664c3..3491335 100644
--- a/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java
+++ b/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodLocator.java
@@ -26,7 +26,6 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.core.search.*;
 import org.eclipse.jdt.internal.compiler.ast.*;
 import org.eclipse.jdt.internal.compiler.env.IBinaryType;
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 import org.eclipse.jdt.internal.compiler.util.SimpleSet;
 import org.eclipse.jdt.internal.core.search.BasicSearchEngine;
@@ -244,13 +243,14 @@ public int match(MessageSend node, MatchingNodeSet nodeSet) {
 
 	return nodeSet.addMatch(node, this.pattern.mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH);
 }
-//public int match(Reference node, MatchingNodeSet nodeSet) - SKIP IT
+
 public int match(ReferenceExpression node, MatchingNodeSet nodeSet) {
 	if (!this.pattern.findReferences) return IMPOSSIBLE_MATCH;
 	if (!matchesName(this.pattern.selector, node.selector)) return IMPOSSIBLE_MATCH;
 	nodeSet.mustResolve = true;
 	return nodeSet.addMatch(node, this.pattern.mustResolve ? POSSIBLE_MATCH : ACCURATE_MATCH);
 }
+
 public int match(Annotation node, MatchingNodeSet nodeSet) {
 	if (!this.pattern.findReferences) return IMPOSSIBLE_MATCH;
 	MemberValuePair[] pairs = node.memberValuePairs();
@@ -275,8 +275,6 @@ protected int matchContainer() {
 		// need to look almost everywhere to find in javadocs and static import
 		return ALL_CONTAINER;
 	}
-	if (CompilerOptions.versionToJdkLevel(JavaCore.getOption(JavaCore.COMPILER_SOURCE)) >= 8)
-		return ALL_CONTAINER;
 	return CLASS_CONTAINER;
 }
 /* (non-Javadoc)
@@ -288,6 +286,7 @@ protected void matchLevelAndReportImportRef(ImportReference importRef, Binding b
 		super.matchLevelAndReportImportRef(importRef, binding, locator);
 	}
 }
+
 protected int matchMethod(MethodBinding method, boolean skipImpossibleArg) {
 	if (!matchesName(this.pattern.selector, method.selector)) return IMPOSSIBLE_MATCH;
 
@@ -765,7 +764,7 @@ protected int resolveLevel(MessageSend messageSend) {
 
 protected int resolveLevel(ReferenceExpression referenceExpression) {
 	MethodBinding method = referenceExpression.getMethodBinding();
-	if (method == null || referenceExpression.resolvedType == null)
+	if (method == null || !method.isValidBinding())
 		return INACCURATE_MATCH;
 
 	int methodLevel = matchMethod(method, false);
